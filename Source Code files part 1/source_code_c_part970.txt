********************************************************
//
//  Common headers
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <oahelp.inl>
#include <wbemutil.h>
#include <flexarry.h>
#include <cominit.h>
#include <CHSTRING.H>

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Common macros and define
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#define SAFE_DELETE_PTR(pv)  \
	{ if(pv) delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
{   if(pv){  pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ if(pv) delete []pv;  \
      pv = NULL; }

#define SUCCESS             0
#define WARNING             10
#define FATAL_ERROR         20
#define FAILED_AS_EXPECTED  30
#define NO_MORE_DATA        40

#define ADD_CLASS 0
#define DELETE_CLASS 1

//====================================================================================================
//  The Repository tests        1-100
//====================================================================================================
//====================================================================================================
//  The Provider CIMV2 tests    200 - 299
//====================================================================================================
//====================================================================================================
//  The Event tests             300 - 399
//====================================================================================================
//====================================================================================================
// Scripting tests              1000
//====================================================================================================

#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__
#define WPTR (WCHAR*)(const WCHAR*)
/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Typedefs
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
typedef struct _EventInfo
{
    CHString   Query;
    CHString   Language;
    CHString   Namespace;
    int       Section;
    int       Results;
    BOOL      fProcessed;
 
    _EventInfo()     { Results = Section = 0; fProcessed = FALSE; }
    ~_EventInfo()    {}
} EventInfo;

typedef struct _IniInfo
{
    LPWSTR Key;
    LPWSTR Value;

} IniInfo;

typedef struct _PropertyInfo
{
    CHString   Property;
    CHString   QualifierName;
    CVARIANT   Var;
    long       Type;
    BOOL       fProcessed;

    _PropertyInfo()     { fProcessed = FALSE; }
    ~_PropertyInfo()    {}

} PropertyInfo;

 
typedef struct _CPropertyList
{
    CFlexArray m_List;
    void Add( PropertyInfo * p)       { m_List.Add(p);}
    inline long Size()                { return m_List.Size(); }
    PropertyInfo * GetAt(int x)       { return (PropertyInfo*)m_List.GetAt(x);}

    int PropertiesCompareAsExpectedAndLogErrors(WCHAR * wcsClass, WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);
    int PropertyInListAndLogErrors( PropertyInfo * pProperty, WCHAR * wcsClass, WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);

     _CPropertyList()            {}
     ~_CPropertyList();          
} CPropertyList;

typedef struct _ItemInfo
{
    CHString   Item;
    CHString   KeyName;
    BOOL       fProcessed;
    BOOL       fAction;
    DWORD      dwFlags;
    int        Results;

    _ItemInfo()    { fProcessed = 0; fAction = 0; dwFlags = 0; Results = -1;}
    ~_ItemInfo()   {}

}ItemInfo;

typedef struct _ItemList
{
    CFlexArray m_List;
    void Add( ItemInfo * p)       { m_List.Add(p);}
    inline long Size()            { return m_List.Size(); }
    ItemInfo * GetAt(int x)       { return (ItemInfo*)m_List.GetAt(x);}

    int ItemsCompareAsExpectedAndLogErrors(WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);
    int ItemInListAndLogErrors(WCHAR * wcsClass, WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);

     _ItemList()            {}
     ~_ItemList();          
} ItemList;

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Prototypes 
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
int GetFlags(int nWhichTest,ItemList & List);
BOOL ParseCommandLine(int argc, WCHAR *argv[]);


/////////////////////////////////////////////////////////////////////////////////////////////
//  The repository tests
/////////////////////////////////////////////////////////////////////////////////////////////
int BasicConnectUsingIWbemLocator(BOOL fCompareResults, BOOL fSuppressLogging );                    // Test 1
int BasicSyncConnectUsingIWbemConnection(BOOL fCompareResults, BOOL fSuppressLogging );             // Test 2
int BasicAsyncConnectUsingIWbemConnection(BOOL fCompareResults, BOOL fSuppressLogging );            // Test 3
int CreateNewTestNamespace(BOOL fCompareResults, BOOL fSuppressLogging );                           // Test 4
int CreateNewClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressLogging );                  // Test 5
int DeleteAndRecreateNewClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressLogging );       // Test 6
int CreateSimpleAssociations(BOOL fCompareResults, BOOL fSuppressLogging );                         // Test 7
int QueryAllClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressLogging );                   // Test 8
int CreateClassInstances(BOOL fCompareResults, BOOL fSuppressLogging );                                 // Test 9
int DeleteClassInstances(BOOL fCompareResults, BOOL fSuppressLogging );                                 // Test 10
int EnumerateClassInstances(BOOL fCompareResults, BOOL fSuppressLogging );                              // Test 11
int CreateAssociationInstances(BOOL fCompareResults, BOOL fSuppressLogging );                           // Test 12
int DeleteAssociationInstances(BOOL fCompareResults, BOOL fSuppressLogging );                           // Test 13
int EnumerateAssociationInstances(BOOL fCompareResults, BOOL fSuppressLogging );                        // Test 14
int DeleteClassDeletesInstances(BOOL fCompareResults, BOOL fSuppressLogging );                          // Test 15
int GetObjects(BOOL fCompareResults, BOOL fSuppressLogging );                                           // Test 16
int CreateMethods(BOOL fCompareResults, BOOL fSuppressLogging );                                        // Test 17
int DeleteMethods(BOOL fCompareResults, BOOL fSuppressLogging );                                        // Test 18
int ListMethods(BOOL fCompareResults, BOOL fSuppressLogging );                                          // Test 19
int DeleteAllNonSystemClasses(BOOL fCompareResults, BOOL fSuppressLogging );                            // Test 20
int DeleteRequestedNamespace(BOOL fCompareResults, BOOL fSuppressLogging );                             // Test 21


/////////////////////////////////////////////////////////////////////////////////////////////
//  The Provider Tests
/////////////////////////////////////////////////////////////////////////////////////////////
int ProviderOpenNamespace(BOOL f, BOOL fSuppress);
int ProviderEnumerateClasses(BOOL f, BOOL fSuppress);
int ProviderExecuteQueries(BOOL f, BOOL fSuppress);
int ProviderDeleteInstances(BOOL f, BOOL fSuppress);
int ProviderEnumerateInstances(BOOL f, BOOL fSuppress);
int ProviderGetObjects(BOOL f, BOOL fSuppress);
int ProviderEnumerateMethods(BOOL f, BOOL fSuppress);
int ProviderExecuteMethods(BOOL f, BOOL fSuppress);
int ProviderSemiSyncEvents(BOOL f, BOOL fSuppress);
int ProviderTempAsyncEvents(BOOL f, BOOL fSuppress);
int ProviderRefresher(BOOL f, BOOL fSuppress);
int ProviderCreateClasses(BOOL f, BOOL fSuppress);
int ProviderCreateInstances(BOOL f, BOOL fSuppress);

/////////////////////////////////////////////////////////////////////////////////////////////
//  The Event Tests
/////////////////////////////////////////////////////////////////////////////////////////////
int TempSemiSyncEvents(BOOL fCompareResults, BOOL fSuppressLogging );                                   // Test 300
int TempAsyncEvents(BOOL fCompareResults, BOOL fSuppressLogging );                                      // Test 301
int PermanentEvents(BOOL fCompareResults, BOOL fSuppressLogging );                                      // Test 302
int PermanentInstances(BOOL fCompareResults, BOOL fSuppressHeader );
int PermanentClasses(BOOL fCompareResults, BOOL fSuppressHeader );

/////////////////////////////////////////////////////////////////////////////////////////////
//  The OLEDB Adapter Tests
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Class definitions
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
class CVARIANTEx : public CVARIANT
{
    public:
        CVARIANTEx() {}
        CVARIANTEx(const WCHAR * pSrc) { VariantInit(&v); SetStr(pSrc); }
        ~CVARIANTEx() {}

        void   SetStr(const WCHAR * pSrc)
        {   Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
            V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
        }
};

class CCriticalSection 
{
    public:		
        CCriticalSection()          {  Init(); }

        ~CCriticalSection() 	    {  Delete(); }
        inline void Init()          {  InitializeCriticalSection(&m_criticalsection);   }
        inline void Delete()        {  DeleteCriticalSection(&m_criticalsection); }
        inline void Enter()         {  EnterCriticalSection(&m_criticalsection); }
        inline void Leave()         {  LeaveCriticalSection(&m_criticalsection); }

    private:

	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};  

/////////////////////////////////////////////////////////////////////////////////////////////
class CAutoBlock
{
    private:

	    CCriticalSection *m_pCriticalSection;

    public:

        CAutoBlock(CCriticalSection *pCriticalSection)
        {
	        m_pCriticalSection = NULL;
	        if(pCriticalSection)
            {
		        pCriticalSection->Enter();
            }
	        m_pCriticalSection = pCriticalSection;
        }

        ~CAutoBlock()
        {
	        if(m_pCriticalSection)
		        m_pCriticalSection->Leave();

        }
};

class CMulti
{
    private:
        int m_nMax;
    public:
        CMulti(int nMax) { m_nMax = nMax; }
        ~CMulti(){}

        int MultiThreadTest(int nThreads, int nConnections );
        inline int GetMax()    { return m_nMax;}
        static DWORD WINAPI RandomRunTest(LPVOID pHold);
};

/////////////////////////////////////////////////////////////////////////////////////////////
#include "bvtutil.h"
#include "bvtcom.h"
#include "bvtapi.h"

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Global Variables
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef DECLARE_GLOBALS

    extern CLogAndDisplayOnScreen  *  gp_LogFile;
    extern CIniFileAndGlobalOptions   g_Options;
    extern g_nDefaultTests[];
    extern g_nMultiThreadTests[];
#else
    int g_nDefaultTests[] =     {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,200,201,202,203,204,205,206,207,208,209,210,211,212,300,301,302};
    //  Note: don't include any tests that delete things, such as Namespace_Creation_events, which deletes a namespace first
    int g_nMultiThreadTests[] = {1,4,5,7,8,9,11,12,14,16,19,200,201,202,204,205,206,207,210,211,212};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvt.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Documentation arrays
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IniInfo g_Doc1[] = {  
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will use"} };

IniInfo g_Doc2[] = {
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc3[] = {
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc4[] = {
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will create" }};

IniInfo g_Doc5[] = {
    {L"FYI",            L"Classes = the list of comma separated class names, all of these classes should exist in this section as defined in the FYI_Format entry below" },
    {L"FYI_Format",     L"Classes are defined in this format: ClassName = Parent:XClass, Key:TmpKey:CIM_SINT32:3, Property:PropertyName3:CIM_UINT32:3" },
    {L"FYI_Class",      L"Using format as defined in FYI_Format, ClassName is the actual name of the class to be created" },
    {L"FYI_InHeritance",L"Using format as defined in FYI_Format, Parent:XClass where Parent means this entity describes the inheritance of the class. XClass is the name of the ParentClass." },
    {L"FYI_Qualifier",  L"Doc this" },
    {L"FYI_Property",   L"Using format as defined in FYI_Format, Property:PropName:CIM_UINT32:5 where Property means this entity describes the Property.  PropName is the name of the Property.  CIM_UINT32 is the type and 5 is the value." },
    {L"FYI_Comments",   L"Classes may contain more than one qualifier and more than one property.  These must be comma separated and identified as described." }};

IniInfo g_Doc6[] = {
    {L"FYI_Delete_Classes",           L"First,  Classes will be deleted as specified by the ini entry DELETE_CLASSES" },
    {L"FYI_Classes_After_Delete",     L"Second, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE" },
    {L"FYI_Add_Classes",              L"Third,  Classes to be added are then specified by the ini entry ADD_CLASSES" },
    {L"FYI_Classes_After_Add",        L"Fourth, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_ADD" },
    {L"FYI_Classes_Add_Delete_Order", L"Fifth,  Classes to be deleted and added in specified order DELETE_ADD_CLASS_ORDER" },
    {L"FYI_Classes_After_Delete_Add", L"Sixth,  Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE_ADD" },
    {L"FYI_Comments",   L"All of these entries, with the exception of DELETE_ADD_CLASS_ORDER are comma separated class names. See FYI_FORMAT for DELETE_ADD_CLASS_ORDER format" },
    {L"FYI_FORMAT",     L"DELETE_ADD_CLASS_ORDER format: 'Delete:Class1, Add:Class2, Add:Class3'  where Delete means to delete the following class, and Add to add the following class, this may be in any order." }};

IniInfo g_Doc7[] = {
                    {L"FYI",  L"ASSOCIATION_CLASSES is a comma separated list of associations to create.  These must exist in this section.  See FYI_Format to see how to create an association" },
                    {L"FYI_Format",   L"Example: Property:FirstPoint:TestClass1:Reference:REF:TestClass1, Property:SecondPoint:TestClass2:REF:TestClass2" },
                    {L"FYI_Property", L"Using format as defined in FYI_Format, Property:FirstPoint:TestClass1:REF:TestClass1 where Property means this entity describes the Property. FirstPoint is the name of first Key, TestClass1 is that key's value, Reference creates a strongly typed reference as defined in REF:TestClass1." },
                    {L"FYI_Comments", L"REF is optional" }};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The repository tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test1[] = {{L"NAMESPACE",L"ROOT\\DEFAULT" },
                    {L"Description", L"Basic connect using IWbemLocator"}};

IniInfo g_Test2[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"Description", L"Basic connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test3[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"Description", L"Basic async connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test4[] = {{L"NAMESPACE",L"ROOT\\BVTAPITEST" },
                     {L"Description", L"Creation of a test namespace"},
                     {L"PARENT_NAMESPACE",L"ROOT"},
                     {L"CLASSES", L"__NAMESPACE"},
                     {L"__NAMESPACE", L"Class:__NAMESPACE,Property:Name:CIM_STRING:BVTAPITEST" }};

IniInfo g_Test5[] = {
    { L"RUNTESTS", L"4" },
    {L"Description", L"Creates test classes in the test namespace"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"Classes",     L"1,2,3,4,5,6,7,8,9,10" },
    { L"1",  L"Class:TestClass1" }, // an abstract class, so 4 and 5 can define additional keys
    { L"2",  L"Class:TestClass2, Property:LaKey1:CIM_STRING:Key1, PropertyQualifier:KEY:LaKey1:CIM_BOOLEAN:1,    Property:LaKey2:CIM_STRING:Key2, PropertyQualifier:Key:LaKey2:CIM_BOOLEAN:1" },
    { L"3",  L"Class:TestClass3, Property:KeyName1:CIM_SINT32:3,  PropertyQualifier:KEY:KeyName1:CIM_BOOLEAN:1,  Property:PropertyName3:CIM_UINT32:3,  Property:PropertyName3B:CIM_STRING:Test" },
    { L"4",  L"Class:TestClass4, Parent:TestClass1,  Property:KeyName4:CIM_UINT32:4,    PropertyQualifier:KEY:KeyName4:CIM_BOOLEAN:1, Property:PropertyName4:CIM_STRING:0" },
    { L"5",  L"Class:TestClass5, Parent:TestClass1,  Property:KeyName5:CIM_STRING:Temp, PropertyQualifier:KEY:KeyName5:CIM_BOOLEAN:1, Property:PropertyName5:CIM_STRING:Value5" },
    { L"6",  L"Class:TestClass6, Parent:TestClass5,  Property:PropertyName6:CIM_STRING:Value6,PropertyQualifier:ID:PropertyName6:CIM_SINT32:1" },    // no additional key can be defined
    { L"7",  L"Class:TestClass7, Parent:TestClass6,  Property:PropertyName7:CIM_STRING:1,PropertyQualifier:ID:PropertyName7:CIM_SINT32:1" },        // no additional key can be defined
    { L"8",  L"Class:TestClass8, Parent:TestClass7,  Property:PropertyName8:CIM_SINT32:2" },        // no additional key can be defined
    { L"9",  L"Class:TestClass9, Parent:TestClass8,  Property:PropertyName9:CIM_STRING:Value9" },    // no additional key can be defined
    { L"10", L"Class:TestClass10, Parent:TestClass9,  Property:PropertyName10:CIM_STRING:0" } };     // no additional key can be defined

IniInfo g_Test6[] = {
    {L"Description", L"Deletes and Creates the classes in the requested order."},
    { L"RUNTESTS", L"20,5" },
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",        L"5"},
    { L"DELETE_CLASSES",            L"1,3" },
    { L"CLASSES_AFTER_DELETE",      L"2" },
    { L"ADD_CLASSES",               L"1,3,4,5,6,7,8,9,10" },
    { L"CLASSES_AFTER_ADD",         L"1,2,3,4,5,6,7,8,9,10" },
    { L"DELETE_ADD_CLASS_ORDER",    L"Delete:2, Delete:9, Add:2, Delete:7, Delete: 6" },
    { L"CLASSES_AFTER_DELETE_ADD",  L"1,2,3,4,5" }};


IniInfo g_Test7[] = 
{
    { L"RUNTESTS", L"5" },
    { L"Description",L"Creates simple associations"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"7"},
    { L"CLASSES",       L"1,2" },
    { L"1",  L"Class:Association1, Property:FirstPoint:CIM_REFERENCE:Value,   PropertyQualifier:KEY:FirstPoint:CIM_BOOLEAN:1, PropertyQualifier:CIMTYPE:FirstPoint:CIM_STRING:ref:TestClass4,Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:EndPoint:CIM_STRING:ref:TestClass5, PropertyQualifier:Key:EndPoint:CIM_BOOLEAN:1" },
    { L"2",  L"Class:Association2, Property:AssocProp1:CIM_STRING:TestClass4, PropertyQualifier:Key:AssocProp1:CIM_BOOLEAN:1, Property:AssocProp2:CIM_STRING:TestClass5, PropertyQualifier:Key:AssocProp2:CIM_BOOLEAN:1" }};

IniInfo g_Test8[] = {
    { L"RUNTESTS", L"12" },
    { L"Description",L"Executes queries"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"QUERY_LIST",        L"QUERY,ASSOCIATORS_QUERY,REFERENCES_QUERY"},
    { L"QUERY",              L"RESULTS:95,QUERY:select * from meta_class" },
    { L"ASSOCIATORS_QUERY",  L"RESULTS:1,QUERY:Associators of {TestClass4.KeyName4=555}" },
    { L"REFERENCES_QUERY",   L"RESULTS:1,QUERY:References of {TestClass4.KeyName4=555}" }};

IniInfo g_Test9[] = {
    { L"RUNTESTS",            L"5" },
    { L"Description",         L"Create Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"9"},
    { L"INSTANCE_LIST",       L"4,5,6,7"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4, Property:KeyName4:CIM_UINT32:555, Property:PropertyName4:CIM_STRING:1, InstanceName:TestClass4.KeyName4=555$EndInstanceName" },
    { L"5",                   L"Class:TestClass5, Property:KeyName5:CIM_STRING:InstanceTest, Property:PropertyName5:CIM_STRING:TestTest, InstanceName:TestClass5.KeyName5=\"InstanceTest\"$EndInstanceName" },
    { L"6",                   L"Class:TestClass4, Property:KeyName4:CIM_UINT32:556, Property:PropertyName4:CIM_STRING:1, InstanceName:TestClass4.KeyName4=556$EndInstanceName" },
    { L"7",                   L"Class:TestClass5, Property:KeyName5:CIM_STRING:InstanceTest2, Property:PropertyName5:CIM_STRING:TestTest, InstanceName:TestClass5.KeyName5=\"InstanceTest2\"$EndInstanceName" }};


IniInfo g_Test10[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Deletes Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"TestClass4.KeyName4=555" },
    { L"5",                   L"TestClass5.KeyName5=\"InstanceTest\"" }};


IniInfo g_Test11[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Enumerates Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4,RESULTS:2" },
    { L"5",                   L"Class:TestClass5,RESULTS:2" }};

IniInfo g_Test12[] = {
    { L"RUNTESTS",            L"7,9" },
    { L"Description",         L"Create Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"12"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:Association1, Property:FirstPoint:CIM_REFERENCE:TestClass4.KeyName4=555,Property:EndPoint:CIM_REFERENCE:TestClass5.KeyName5=\"InstanceTest\", InstanceName:Association1.EndPoint=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\",FirstPoint=\"TestClass4.KeyName4=555\"$EndInstanceName"},
    { L"5",                   L"Class:Association2, Property:AssocProp1:CIM_STRING:TestClass4.KeyName4=556,Property:AssocProp2:CIM_STRING:TestClass5.KeyName5=\"InstanceTest\", InstanceName:Association2.AssocProp2=TestClass5.KeyName5=\"InstanceTest\",AssocProp1=TestClass4.KeyName4=555$EndInstanceName"}};

IniInfo g_Test13[] = {
    { L"RUNTESTS",            L"12" },
    { L"Description",         L"Deletes Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},

    { L"4",                   L"Association1.EndPoint=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\",FirstPoint=\"TestClass4.KeyName4=555\"" },
    { L"5",                   L"Association2.AssocProp1=\"TestClass4.KeyName4=556\",AssocProp2=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\"" }};

IniInfo g_Test14[] = {
    { L"RUNTESTS",            L"12" },
    { L"Description",         L"Enumerates Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:Association1, RESULTS:1" },
    { L"5",                   L"CLASS:Association2, RESULTS:1" }};

IniInfo g_Test15[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Deletes Class deletes all the instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"15"},
    { L"CLASSES",             L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4" },
    { L"5",                   L"Class:TestClass5" }};


IniInfo g_Test16[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Gets specific objects by various specific paths"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"OBJECT_LIST",         L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"TestClass4.KeyName4=555" },
    { L"5",                   L"TestClass5.KeyName5=\"InstanceTest\"" }};

IniInfo g_Test17[] = {
    { L"RUNTESTS",            L"5" },
    { L"Description",         L"Create methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, METHOD:TestMethod, \
                                INPUT:Property:InputArg1:CIM_UINT32:555, \
                                INPUT:PropertyQualifier:ID:InputArg1:CIM_SINT32:0,\
                                INPUT:PropertyQualifier:In:InputArg1:CIM_BOOLEAN:1, \
                                OUTPUT:Property:OutputArg1:CIM_UINT32:111,\
                                OUTPUT:PropertyQualifier:ID:OutputArg1:CIM_SINT32:1,\
                                OUTPUT:PropertyQualifier:Out:OutputArg1:CIM_BOOLEAN:1"}};

IniInfo g_Test18[] = {
    { L"RUNTESTS",            L"17" },
    { L"Description",         L"Delete methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, METHOD:TestMethod"}};

IniInfo g_Test19[] = {
    { L"RUNTESTS",            L"17" },
    { L"Description",         L"Enumerate methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, RESULTS:1"}};

IniInfo g_Test20[] = {
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DESCRIPTION", L"Deletes all non-system classes in the namespace"}};

IniInfo g_Test21[] = {
    { L"NAMESPACE",    L"ROOT"},
    { L"NAMESPACE_TO_DELETE", L"__NAMESPACE.Name=\"BVTAPITEST\""},
    { L"DESCRIPTION", L"Deletes requested namespace"}};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Other Provider tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test200[] = {
    {L"PROVIDERS",     L"WDM,CIMV2"},
    {L"WDM",           L"NAMESPACE:ROOT\\WMI"},
    {L"CIMV2",         L"NAMESPACE:ROOT\\CIMV2"},
    {L"Description",   L"Basic connect using IWbemLocator"}};

IniInfo g_Test201[] = {
    {L"PROVIDERS",     L"WDM,CIMV2"},
    { L"Description",                   L"Enumerates Classes for Providers"},
    { L"RUNTESTS",                      L"200"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"FLAGS",                         L"WBEM_FLAG_SHALLOW, WBEM_FLAG_DEEP, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY "},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"CLASS:__ExtrinsicEvent, RESULTS:3, RESULTS:25, RESULTS: 25" },
    { L"2",                             L"Empty" },
    { L"3",                             L"Empty" },
    { L"4",                             L"CLASS:CIM_Action, RESULTS: 16, RESULTS:25, RESULTS:25" }};

IniInfo g_Test202[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    {L"Description",                    L"Executes queries for Providers"},
    {L"RUNTESTS",                       L"200"},
    {L"NAMESPACE_DEFINITION_SECTION",   L"201"},
    {L"WDM",                            L"WDMQUERY"},
    {L"CIMV2",                          L"QUERY"},
    {L"WDMQUERY",                       L"RESULTS:294,QUERY:select * from meta_class" },
    {L"QUERY",                          L"RESULTS:939,QUERY:select * from meta_class" }};


IniInfo g_Test204[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"Description",                   L"Enumerates Instances for Providers"},
    { L"RUNTESTS",                      L"200"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"CLASS:RegisteredGuids, RESULTS:-1" },
    { L"2",                             L"CLASS:WmiBinaryMofResource, RESULTS:-1" },
    { L"3",                             L"CLASS:Win32_Process, RESULTS:-1" },
    { L"4",                             L"CLASS:Win32_Directory, RESULTS:-1" }};

IniInfo g_Test205[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Gets specific objects by various specific paths for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"1",                             L"MSNdis_CoDriverVersion.InstanceName=\"WAN Miniport (IP)\""},
    { L"2",                             L"Win32_Directory.Name=\"c:\\\\\"" }};

IniInfo g_Test206[] = {
    {L"PROVIDERS",                      L"CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Enumerate methods for a class for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"CIMV2",                         L"3,4"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"3",                             L"CLASS:CIM_DataFile, RESULTS:14"},
    { L"4",                             L"CLASS:Win32_Process, RESULTS:4"}};

    
IniInfo g_Test207[] = {
    { L"PROVIDERS",                     L"CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Execute methods for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"CIMV2",                         L"1"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"1",                             L"Class:CIM_DataFile, InstanceName:CIM_DataFile.Name=\"c:\\\\BVT.TST\"$EndInstanceName, METHOD:Copy, INPUT:Property:FileName:CIM_STRING:c:\\\\BVT2.TST"}};

IniInfo g_Test208[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Test temporary semi-sync events for Providers"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"1",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\WMI"},
    { L"2",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\CIMV2"}};

IniInfo g_Test209[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Test temporary async events for Providers"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"1",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\WMI"},
    { L"2",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\CIMV2"}};

IniInfo g_Test210[] = {
    { L"PROVIDERS",                     L"WDM"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Create Refresher for Providers"},
    { L"WDM",                           L"1"},
    { L"1",                             L"Class:Win32_BasicHiPerf"}};

IniInfo g_Test211[] = {
    { L"PROVIDERS",                     L"WDM, CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Create Classes for Providers"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"Class:WDMTemp1, Property:Key1:CIM_UINT32:0, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1, Property:Prop1:CIM_STRING:x" },
    { L"2",                             L"Class:WDMTemp2, Property:Key2:CIM_UINT32:0, PropertyQualifier:KEY:Key2:CIM_BOOLEAN:1, Property:Prop2:CIM_STRING:x" },
    { L"3",                             L"Class:CIMTemp1, Property:Key1:CIM_UINT32:0, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1, Property:Prop1:CIM_STRING:x" },
    { L"4",                             L"Class:CIMTemp2, Property:Key2:CIM_UINT32:0, PropertyQualifier:KEY:Key2:CIM_BOOLEAN:1, Property:Prop2:CIM_STRING:x" }};
    
IniInfo g_Test212[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"211" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"DEFINITION_SECTION",            L"212"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"Description",                   L"Create Instances for Providers"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"Class:WDMTemp1, Property:Key1:CIM_UINT32:1, Property:Prop1:CIM_STRING:Test1, InstanceName:WDMTemp1.Key1=1$EndInstanceName" },
    { L"2",                             L"Class:WDMTemp2, Property:Key2:CIM_UINT32:2, Property:Prop2:CIM_STRING:Test2, InstanceName:WDMTemp2.Key2=2$EndInstanceName" },
    { L"3",                             L"Class:CIMTemp1, Property:Key1:CIM_UINT32:1, Property:Prop1:CIM_STRING:Test1, InstanceName:CIMTemp1.Key1=1$EndInstanceName" },
    { L"4",                             L"Class:CIMTemp2, Property:Key2:CIM_UINT32:2, Property:Prop2:CIM_STRING:Test2, InstanceName:CIMTemp2.Key2=2$EndInstanceName" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Event tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test300[] = {
    { L"RUNTESTS",             L"21" },
    { L"NAMESPACE",            L"ROOT"},
    { L"Description",          L"Test temporary semi-sync events"},
    { L"EVENT_LIST",           L"NAMESPACE_CREATION, CLASS_CREATION,INSTANCE_CREATION"},
    { L"NAMESPACE_CREATION",   L"LANGUAGE:WQL, QUERY:\"select * from __NamespaceCreationEvent\", EXECUTE_SECTION: 4, RESULTS:1,  NAMESPACE:ROOT"},
    { L"INSTANCE_CREATION",    L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent\",  EXECUTE_SECTION: 9, RESULTS:4,  NAMESPACE:ROOT\\BVTAPITEST"},
    { L"CLASS_CREATION",       L"LANGUAGE:WQL, QUERY:\"select * from __ClassCreationEvent\",     EXECUTE_SECTION: 5, RESULTS:10, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test301[] = {
    { L"RUNTESTS",             L"21" },
    { L"NAMESPACE",            L"ROOT"},
    { L"Description",          L"Test temporary async events"},
    { L"EVENT_LIST",           L"NAMESPACE_CREATION, CLASS_CREATION,INSTANCE_CREATION"},
    { L"NAMESPACE_CREATION",   L"LANGUAGE:WQL, QUERY:\"select * from __NamespaceCreationEvent\", EXECUTE_SECTION: 4, RESULTS:1,  NAMESPACE:ROOT"},
    { L"INSTANCE_CREATION",    L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent\",  EXECUTE_SECTION: 9, RESULTS:4,  NAMESPACE:ROOT\\BVTAPITEST"},
    { L"CLASS_CREATION",       L"LANGUAGE:WQL, QUERY:\"select * from __ClassCreationEvent\",     EXECUTE_SECTION: 5, RESULTS:10, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test302[] = {
    { L"RUNTESTS",                       L"21" },
    { L"NAMESPACE",                      L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",             L"302"},
    { L"Description",                    L"Permanent events"},
    { L"MOF_COMMAND",                    L"mofcomp bvtperm\\BVT.MOF"},
    { L"REGISTER_PERM_EVENT_CONSUMER",   L"bvtperm\\cmdlineconsumer.exe"},
    { L"RETRY",                          L"10"},
    { L"SLEEP_IN_MILLISECONDS",          L"1000"},
    { L"FIRE_EVENTS",                    L"1"},
    { L"1",                              L"EXECUTE_SECTION: 303, RESULTS:2, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test303[] = {
    { L"RUNTESTS",            L"304" },
    { L"Description",         L"Create Instances for PermEventConsumer"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"303"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:PermClass1, Property:Key1:CIM_SINT32:1, InstanceName:PermClass1.Key1=1$EndInstanceName" },
    { L"5",                   L"Class:PermClass1, Property:Key1:CIM_SINT32:2, InstanceName:PermClass1.Key1=2$EndInstanceName" }};


IniInfo g_Test304[] = {
    { L"Description",   L"Creates test classes for perm event consumer"},
    { L"NAMESPACE",     L"ROOT\\BVTAPITEST"},
    { L"Classes",       L"1" },
    { L"1",             L"Class:PermClass1, Property:Key1:CIM_SINT32:1, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Adapter tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The scripting tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IniInfo g_Test1000[] = { 
    { L"SCRIPTS",L"1,2,3,4"},
    { L"1,", L"scripts\\Test1.vbs" },
    { L"2,", L"scripts\\Test1.vbs" },
    { L"3,", L"scripts\\Test1.vbs" },
    { L"4,", L"scripts\\Test1.vbs" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetSpecificOptionForAPITest(const WCHAR * wcsKey, CHString & sInfo, int nTest)
{
    BOOL fRc = FALSE;
    int nNum = 0;
    int nMax = 0;
    IniInfo * pArray = NULL;
    WCHAR * wcsSection = NULL;

    switch( nTest )
    {
            //==================================================================
            //   The repository tests
            //==================================================================
        case 1:
            pArray = g_Test1;
            nMax = sizeof(g_Test1)/sizeof(IniInfo);
            wcsSection = L"1";
            break;

        case 2:
            pArray = g_Test2;
             nMax = sizeof(g_Test2)/sizeof(IniInfo);
           wcsSection = L"2";
            break;

        case 3:
            pArray = g_Test3;
            nMax = sizeof(g_Test3)/sizeof(IniInfo);
            wcsSection = L"3";
            break;

        case 4:
            pArray = g_Test4;
            nMax = sizeof(g_Test4)/sizeof(IniInfo);
            wcsSection = L"4";
            break;

        case 5:
            pArray = g_Test5;
            nMax = sizeof(g_Test5)/sizeof(IniInfo);
            wcsSection = L"5";
            break;

        case 6:
            pArray = g_Test6;
            nMax = sizeof(g_Test6)/sizeof(IniInfo);
            wcsSection = L"6";
            break;

        case 7:
            pArray = g_Test7;
            nMax = sizeof(g_Test7)/sizeof(IniInfo);
            wcsSection = L"7";
            break;

        case 8:
            pArray = g_Test8;
            nMax = sizeof(g_Test8)/sizeof(IniInfo);
            wcsSection = L"8";
            break;

        case 9:
            pArray = g_Test9;
            nMax = sizeof(g_Test9)/sizeof(IniInfo);
            wcsSection = L"9";
            break;

        case 10:
            pArray = g_Test10;
            nMax = sizeof(g_Test10)/sizeof(IniInfo);
            wcsSection = L"10";
            break;

        case 11:
            pArray = g_Test11;
            nMax = sizeof(g_Test11)/sizeof(IniInfo);
            wcsSection = L"11";
            break;

        case 12:
            pArray = g_Test12;
            nMax = sizeof(g_Test12)/sizeof(IniInfo);
            wcsSection = L"12";
            break;

        case 13:
            pArray = g_Test13;
            nMax = sizeof(g_Test13)/sizeof(IniInfo);
            wcsSection = L"13";
            break;

        case 14:
            pArray = g_Test14;
            nMax = sizeof(g_Test14)/sizeof(IniInfo);
            wcsSection = L"14";
            break;

        case 15:
            pArray = g_Test15;
            nMax = sizeof(g_Test15)/sizeof(IniInfo);
            wcsSection = L"15";
            break;

        case 16:
            pArray = g_Test16;
            nMax = sizeof(g_Test16)/sizeof(IniInfo);
            wcsSection = L"16";
            break;

        case 17:
            pArray = g_Test17;
            nMax = sizeof(g_Test17)/sizeof(IniInfo);
            wcsSection = L"17";
            break;

        case 18:
            pArray = g_Test18;
            nMax = sizeof(g_Test18)/sizeof(IniInfo);
            wcsSection = L"18";
            break;

        case 19:
            pArray = g_Test19;
            nMax = sizeof(g_Test19)/sizeof(IniInfo);
            wcsSection = L"19";
            break;

        case 20:
            pArray = g_Test20;
            nMax = sizeof(g_Test20)/sizeof(IniInfo);
            wcsSection = L"20";
            break;

        case 21:
            pArray = g_Test21;
            nMax = sizeof(g_Test21)/sizeof(IniInfo);
            wcsSection = L"21";
            break;

            //==================================================================
            //   The Other Provider tests
            //==================================================================
        case 200:
            pArray = g_Test200;
            nMax = sizeof(g_Test200)/sizeof(IniInfo);
            wcsSection = L"200";
            break;

        case 201:
            pArray = g_Test201;
            nMax = sizeof(g_Test201)/sizeof(IniInfo);
            wcsSection = L"201";
            break;

        case 202:
            pArray = g_Test202;
            nMax = sizeof(g_Test202)/sizeof(IniInfo);
            wcsSection = L"202";
            break;

        case 204:
            pArray = g_Test204;
            nMax = sizeof(g_Test204)/sizeof(IniInfo);
            wcsSection = L"204";
            break;

        case 205:
            pArray = g_Test205;
            nMax = sizeof(g_Test205)/sizeof(IniInfo);
            wcsSection = L"205";
            break;

        case 206:
            pArray = g_Test206;
            nMax = sizeof(g_Test206)/sizeof(IniInfo);
            wcsSection = L"206";
            break;

        case 207:
            pArray = g_Test207;
            nMax = sizeof(g_Test207)/sizeof(IniInfo);
            wcsSection = L"207";
            break;

        case 208:
            pArray = g_Test208;
            nMax = sizeof(g_Test208)/sizeof(IniInfo);
            wcsSection = L"208";
            break;

        case 209:
            pArray = g_Test209;
            nMax = sizeof(g_Test209)/sizeof(IniInfo);
            wcsSection = L"209";
            break;

        case 210:
            pArray = g_Test210;
            nMax = sizeof(g_Test210)/sizeof(IniInfo);
            wcsSection = L"210";
            break;

        case 211:
            pArray = g_Test211;
            nMax = sizeof(g_Test211)/sizeof(IniInfo);
            wcsSection = L"211";
            break;

        case 212:
            pArray = g_Test212;
            nMax = sizeof(g_Test212)/sizeof(IniInfo);
            wcsSection = L"212";
            break;

            //==================================================================
            //   The event tests
            //==================================================================
        case 300:
            pArray = g_Test300;
            nMax = sizeof(g_Test300)/sizeof(IniInfo);
            wcsSection = L"300";
            break;

        case 301:
            pArray = g_Test301;
            nMax = sizeof(g_Test301)/sizeof(IniInfo);
            wcsSection = L"301";
            break;

        case 302:
            pArray = g_Test302;
            nMax = sizeof(g_Test302)/sizeof(IniInfo);
            wcsSection = L"302";
            break;

        case 303:
            pArray = g_Test303;
            nMax = sizeof(g_Test303)/sizeof(IniInfo);
            wcsSection = L"303";
            break;

        case 304:
            pArray = g_Test304;
            nMax = sizeof(g_Test304)/sizeof(IniInfo);
            wcsSection = L"304";
            break;

            //==================================================================
            //   The scripting tests
            //==================================================================
       case 1000:
            pArray = g_Test1000;
            nMax = sizeof(g_Test1000)/sizeof(IniInfo);
            wcsSection = L"1000";
            break;

 
    }

    if( GetDefaultMatch(pArray,wcsKey,nNum, nMax))
    {
        fRc = ReadIniFile(wcsSection,wcsKey,pArray[nNum].Value,sInfo);
    }
    else
    {
        fRc = ReadIniFile(wcsSection,wcsKey,L"Empty",sInfo);
    }

    return fRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CIniFileAndGlobalOptions::WriteDefaultIniFile()
{
    BOOL fRc;
   //================================================================================
   // Write out test 1
   //================================================================================
    for( int i=0; i<sizeof(g_Doc1)/sizeof(IniInfo); i++ )
    {
        fRc = WritePrivateProfileString(L"1", g_Doc1[i].Key, g_Doc1[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test1)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"1", g_Test1[i].Key, g_Test1[i].Value,m_wcsFileName);
    }
  
   //================================================================================
   // Write out test 2
   //================================================================================
    for( int i=0; i<sizeof(g_Doc2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"2", g_Doc2[i].Key, g_Doc2[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"2", g_Test2[i].Key, g_Test2[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 3
   //================================================================================
    for( int i=0; i<sizeof(g_Doc3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"3", g_Doc3[i].Key, g_Doc3[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"3", g_Test3[i].Key, g_Test3[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 4
   //================================================================================
    for( int i=0; i<sizeof(g_Doc4)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"4", g_Doc4[i].Key, g_Doc4[i].Value,m_wcsFileName);
    }
    WritePrivateProfileString(L"4", g_Test4[0].Key, g_Test4[0].Value,m_wcsFileName);
   //================================================================================
   // Write out test 5
   //================================================================================
    for( int i=0; i<sizeof(g_Doc5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"5", g_Doc5[i].Key, g_Doc5[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"5", g_Test5[i].Key, g_Test5[i].Value,m_wcsFileName);
    }

    //================================================================================
    // Write out test 6
    //================================================================================
    for( int i=0; i<sizeof(g_Doc6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"6", g_Doc6[i].Key, g_Doc6[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"6", g_Test6[i].Key, g_Test6[i].Value,m_wcsFileName);
    }

   //================================================================================
   // Write out test 7
   //================================================================================
    for( int i=0; i<sizeof(g_Doc7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Doc7[i].Key, g_Doc7[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Test7[i].Key, g_Test7[i].Value,m_wcsFileName);
    }

   //================================================================================
    for( int i=0; i<sizeof(g_Test8)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"8", g_Test8[i].Key, g_Test8[i].Value,m_wcsFileName);
    }

   //================================================================================
    for( int i=0; i<sizeof(g_Test9)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"9", g_Test9[i].Key, g_Test9[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test10)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"10", g_Test10[i].Key, g_Test10[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test11)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"11", g_Test11[i].Key, g_Test11[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test12)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"12", g_Test12[i].Key, g_Test12[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test13)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"13", g_Test13[i].Key, g_Test13[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test14)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"14", g_Test14[i].Key, g_Test14[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test15)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"15", g_Test15[i].Key, g_Test15[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test16)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"16", g_Test16[i].Key, g_Test16[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test17)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"17", g_Test17[i].Key, g_Test17[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test18)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"18", g_Test18[i].Key, g_Test18[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test19)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"19", g_Test19[i].Key, g_Test19[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test20)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"20", g_Test20[i].Key, g_Test20[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test21)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"21", g_Test21[i].Key, g_Test21[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test200)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"200", g_Test200[i].Key, g_Test200[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test201)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"201", g_Test201[i].Key, g_Test201[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test202)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"202", g_Test202[i].Key, g_Test202[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test204)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"204", g_Test204[i].Key, g_Test204[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test205)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"205", g_Test205[i].Key, g_Test205[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test206)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"206", g_Test206[i].Key, g_Test206[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test207)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"207", g_Test207[i].Key, g_Test207[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test208)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"208", g_Test208[i].Key, g_Test208[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test209)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"209", g_Test209[i].Key, g_Test209[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test210)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"210", g_Test210[i].Key, g_Test210[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test211)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"211", g_Test211[i].Key, g_Test211[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test212)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"212", g_Test212[i].Key, g_Test212[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test300)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"300", g_Test300[i].Key, g_Test300[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test301)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"301", g_Test301[i].Key, g_Test301[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test302)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"302", g_Test302[i].Key, g_Test302[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test303)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"303", g_Test303[i].Key, g_Test303[i].Value,m_wcsFileName);
    }
//================================================================================
    for( int i=0; i<sizeof(g_Test304)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"304", g_Test304[i].Key, g_Test304[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Scripting: Write out test 1000
   //================================================================================
   for( int i=0; i<sizeof(g_Test1000)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Test1000[i].Key, g_Test1000[i].Value,m_wcsFileName);
    }
 
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  Run the tests
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int RunTests(int nWhichTest,BOOL fCompareResults, BOOL fSuppressHeader)
{

    int nRc = FATAL_ERROR;

    Sleep(200);
    switch( nWhichTest )
    {
        //*************************************************************
        //=============================================================
        // The Repository Tests
        //=============================================================
        //*************************************************************

        //=================================================================
        // Basic connect using IWbemLocator 
        //=================================================================
        case 1:
            nRc = BasicConnectUsingIWbemLocator(fCompareResults,fSuppressHeader);
            break;

        //=================================================================
        // Basic Sync connect using IWbemConnection
        //=================================================================
        case 2:
            nRc = BasicSyncConnectUsingIWbemConnection(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Basic connect sync & async using IWbemConnection
        //=============================================================
        case 3:
            nRc = BasicAsyncConnectUsingIWbemConnection(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create a new test namespace
        //=============================================================
        case 4:
            nRc = CreateNewTestNamespace(fCompareResults,fSuppressHeader);
            break;
        
        //=============================================================
        // Create 10 classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=============================================================
        case 5:
            nRc = CreateNewClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // "memorize the class definitions".  In a complex loop, 
        // delete the classes and recreate them in various sequences, 
        // ending with the full set.
        //=============================================================
        case 6:
            nRc = DeleteAndRecreateNewClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create associations
        //=============================================================
        case 7:
            nRc= CreateSimpleAssociations(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Execute queries
        //=============================================================
        case 8:
            nRc = QueryAllClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create instances of the above classes, randomly creating 
        // and deleting in a loop, finishing up with a known set.  
        // Query the instances and ensure that no instances disappeared 
        // or appeared that shouldn't be there.    
        //=============================================================
        case 9:
            nRc = CreateClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Verify that deletion of instances works.
        //=============================================================
        case 10:
            nRc = DeleteClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Enumerate the instances
        //=============================================================
        case 11:
            nRc = EnumerateClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create some simple association classes 
        //=============================================================
        case 12:
            nRc = CreateAssociationInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        //  Delete association instances
        //=============================================================
         case 13:
          nRc = DeleteAssociationInstances(fCompareResults,fSuppressHeader);
          break;

        //=============================================================
        //  Enumerate the association instances
        //=============================================================
        case 14:
            nRc = EnumerateAssociationInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Verify that deletion of a class takes out all the instances.
        //=============================================================
        case 15:
            nRc = DeleteClassDeletesInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        //
        //=============================================================
        case 16:
            nRc = GetObjects(fCompareResults,fSuppressHeader);
            break;

        case 17:
            nRc = CreateMethods(fCompareResults,fSuppressHeader);
            break;

        case 18:
            nRc = DeleteMethods(fCompareResults,fSuppressHeader);
            break;

        case 19:
            nRc = ListMethods(fCompareResults,fSuppressHeader);
            break;

        case 20:
            nRc = DeleteAllNonSystemClasses(fCompareResults,fSuppressHeader);
            break;

        case 21:
            nRc = DeleteRequestedNamespace(fCompareResults,fSuppressHeader);
            break;
        //*************************************************************
        //=============================================================
        // The Other Provider Tests
        //=============================================================
        //*************************************************************
        case 200:
            nRc = ProviderOpenNamespace(fCompareResults,fSuppressHeader);
            break;

        case 201:
            nRc = ProviderEnumerateClasses(fCompareResults,fSuppressHeader);
            break;

        case 202:
            nRc = ProviderExecuteQueries(fCompareResults,fSuppressHeader);
            break;

        case 203:
            nRc = SUCCESS;
            break;

        case 204:
            nRc = ProviderEnumerateInstances(fCompareResults,fSuppressHeader);
            break;

        case 205:
            nRc = ProviderGetObjects(fCompareResults,fSuppressHeader);
            break;

        case 206:
            nRc = ProviderEnumerateMethods(fCompareResults,fSuppressHeader);
            break;

        case 207:
            nRc = ProviderExecuteMethods(fCompareResults,fSuppressHeader);
            break;

        case 208:
            nRc = ProviderSemiSyncEvents(fCompareResults,fSuppressHeader);
            nRc = SUCCESS;
            break;

        case 209:
             nRc = ProviderTempAsyncEvents(fCompareResults,fSuppressHeader);
            nRc = SUCCESS;
            break;

        case 210:
            nRc = ProviderRefresher(fCompareResults,fSuppressHeader);
            break;

        case 211:
            nRc = ProviderCreateClasses(fCompareResults,fSuppressHeader);
            break;

        case 212:
            nRc = ProviderCreateInstances(fCompareResults,fSuppressHeader);
            break;

        //*************************************************************
        //=============================================================
        // The Event Tests
        //=============================================================
        //*************************************************************
        case 300:
            nRc = TempSemiSyncEvents(fCompareResults,fSuppressHeader);
            break;

        case 301:
            nRc = TempAsyncEvents(fCompareResults,fSuppressHeader);
            break;

        case 302:
            nRc = PermanentEvents(fCompareResults,fSuppressHeader);
            break;

        case 303:
            nRc = PermanentInstances(fCompareResults,fSuppressHeader);
            break;

        case 304:
            nRc = PermanentClasses(fCompareResults,fSuppressHeader);
            break;
        //*************************************************************
        //=============================================================
        // The XML Adapter Tests
        //=============================================================
        //*************************************************************

        //*************************************************************
        //=============================================================
        // The OLEDB Adapter Tests
        //=============================================================
        //*************************************************************

        //*************************************************************
        //=============================================================
        // The Scripting Tests
        //=============================================================
        //*************************************************************
        case 1000:
            ExecuteScript(nWhichTest);
            break;

        default:
            gp_LogFile->LogError(__FILE__,__LINE__,WARNING, L"Requested test does not exist." );
            break;
    }
        
    return nRc;  
}

////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CMulti::RandomRunTest(LPVOID pHold)
{
    CMulti * pTmp = (CMulti*) pHold;

    int nTest = 0, nMax = 0;

    nMax = pTmp->GetMax();

	if(nMax > 0)
    {
	    float f=((float)rand())/(RAND_MAX+1);
    
	    int nRet=(((int)(nMax*f))+1);

	    nTest = ((nTest+GetCurrentThreadId()) % nMax)+1;
    }
    
    return RunTests(g_nMultiThreadTests[nTest-1],FALSE,FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
int CMulti::MultiThreadTest(int nThreads, int nConnections )
{
	HRESULT hr = S_OK;	
	DWORD dwFlags = 0;
	DWORD lpExitCode;	

	HANDLE * hpHandles = new HANDLE[nThreads];

	for(int n = 0; n < nConnections; n++)
	{
		for(int i = 0; i < nThreads; i++)
		{		
            Sleep(100);
			hpHandles[i] = CreateThread(0, 0, RandomRunTest, (LPVOID)this, 0, &dwFlags);		
		}	

		for(i = 0; i < nThreads; i++)
		{
			do 
			{				
				GetExitCodeThread(hpHandles[i], &lpExitCode);
			} 
			while(lpExitCode == STILL_ACTIVE);

			CloseHandle(hpHandles[i]);
		}
	}

    SAFE_DELETE_ARRAY(hpHandles);
	
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(int argc, WCHAR *argv[])
{
    BOOL fRc = TRUE;

    //============================================================================================
    //  Set the default error log name.
    //============================================================================================

    gp_LogFile->SetFileName(L"BVT.LOG");
    g_Options.SetFileName(L"BVT.INI");


    //============================================================================================
    //
    //  Loop through the command line and get all of the available arguments.  
    //
    //============================================================================================
	for(int i=1; i<argc; i++)
	{
		if(_wcsicmp(argv[i], L"-INIFILE") == 0)
		{
            g_Options.SetFileName(argv[++i]);
		}
		else if(_wcsicmp(argv[i], L"-LOGFILE") == 0)
		{
            gp_LogFile->SetFileName(argv[++i]);
		}
		else if(_wcsicmp(argv[i], L"-TEST") == 0)
		{
            WCHAR * pSeps = L"[], ";
            WCHAR * pToken = wcstok( argv[++i], pSeps );

            while( pToken != NULL )
            {
                g_Options.AddToSpecificTestList(_wtoi(pToken));
                pToken = wcstok( NULL, pSeps );
            }

            g_Options.SpecificTests(TRUE);
		}
		else if(_wcsicmp(argv[i], L"-THREADS") == 0)
		{
            WCHAR * pSeps = L"[], ";
            WCHAR * pToken = wcstok( argv[++i], pSeps );

            g_Options.SetThreads(_wtoi(pToken));
		}
		else if(_wcsicmp(argv[i], L"-CONNECTIONS") == 0)
		{
            WCHAR * pSeps = L"[], ";
            WCHAR * pToken = wcstok( argv[++i], pSeps );

            g_Options.SetConnections(_wtoi(pToken));
		}
		else if(_wcsicmp(argv[i], L"-WRITEDEFAULTINI") == 0)
		{
           g_Options.WriteDefaultIniFile();
        }
		else
		{
	    	printf("Usage : %s OPTIONS\n\n", argv[0]);
			printf("Valid options are: \n");
            printf("  -TEST [1,2,10...]            Default: All tests are executed\n");
            printf("  -THREADS [210]               Default: 100\n");
            printf("  -CONNECTIONS [210]           Default: 100\n");
			printf("  -INIFILE inifilename        The name of the ini file.\n");
			printf("  -WRITEDEFAULTINI            Writes out the default ini file.\n");
			printf("  -LOGFILE logfilename        The name of the output log file.\n");
            printf("                              Default: BVT.LOG\n\n");
			return FALSE;
		}
	}

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\x.cpp ===
BOOL PermEvent::Wait()
{
	BOOL fStatus = TRUE ;
	BOOL fTerminated = FALSE ;

	while ( fStatus && ! fTerminated )
	{
 	    DWORD Event = MsgWaitForMultipleObjects (m_dwCount ,m_pHandles ,FALSE ,1000 ,QS_ALLINPUT) ;

		ULONG HandleIndex = Event - WAIT_OBJECT_0 ;

		if ( Event == 0xFFFFFFFF )
		{
			fStatus = FALSE ;
		}
		else if ( Event == WAIT_TIMEOUT)
		{
		//	TimedOut();
		}
		else if ( Event >= WAIT_OBJECT_0 && HandleIndex <= m_dwCount )
		{
            // Go into dispatch loop
			if ( HandleIndex == m_dwCount )
			{
				BOOL fDispatchStatus ;
				MSG Msg ;

				while ( ( fDispatchStatus = PeekMessage ( & Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					if ( ( fDispatchStatus = GetMessage ( & Msg , NULL , 0 , 0 ) ) == TRUE )
					{
						TranslateMessage ( & Msg ) ;
						DispatchMessage ( & Msg ) ;
					}

					BOOL fTimeout = FALSE ;

					while ( ! fTimeout & fStatus & ! fTerminated )
					{
						Event = WaitForMultipleObjects (m_dwCount ,m_pHandles ,FALSE ,0) ;

						HandleIndex = Event - WAIT_OBJECT_0 ;
						if ( Event == 0xFFFFFFFF )
						{
							fStatus = FALSE ;
						}
						else if ( Event == WAIT_TIMEOUT)
						{
							fTimeout = TRUE ;
						}
						else if ( HandleIndex < m_dwCount )
						{
							fStatus = WaitDispatch ( HandleIndex , fTerminated ) ;
						}
						else
						{
							fStatus = FALSE ;
						}
					}
				}
			}
			else if ( HandleIndex < m_dwCount )
			{
				fStatus = WaitDispatch ( HandleIndex, fTerminated ) ;
			}
			else
			{
				fStatus = FALSE ;
			}
		}
	}
	return fStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtapi.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CoCreateInstanceAndLogErrors( REFCLSID  clsid, REFIID  iid, void ** pPtr, 
                                  BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, iid, (void**) pPtr );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"CoCreateInstance failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CoCreateInstance was: 0x%x", hr );
            LogCLSID(csFile,Line, L"REFIID ",iid);
            LogCLSID(csFile,Line, L"REFCLSID ",clsid);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ConnectServerAndLogErrors(IWbemLocator * pLocator, IWbemServices ** pNamespace, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pLocator->ConnectServer( CBSTR(wcsNamespace),	// NameSpace Name
  							      NULL,			// UserName
								  NULL,			// Password
								  NULL,			// Locale
								  0L,				// Security Flags
								  NULL,			// Authority
								  NULL,			// Wbem Context
								  pNamespace	// Namespace
								);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ConnectServer via IWbemLocator failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ConnectServer was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to open namespace: %s",wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenObjectAndLogErrors( IWbemConnection * pConnection, REFIID  iid, void ** pObj, 
                            WCHAR * wcsObjectName, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the requested object
	// =================================================================
	HRESULT hr = pConnection->Open(	CBSTR(wcsObjectName), NULL, NULL, NULL, 0L, NULL, iid,(void**) &pObj, NULL);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Open via IWbemConnection failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Open was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Object Name: %s",wcsObjectName);
            LogCLSID(csFile,Line, L"REFIID",iid);

            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenObjectAsyncAndLogErrors( IWbemConnection * pConnection, REFIID  iid, WCHAR * wcsObjectName, IWbemObjectSinkEx * pHandler,
                                 BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the requested object
	// =================================================================
    HRESULT hr = pConnection->OpenAsync(CBSTR(wcsObjectName), NULL, NULL, NULL, 0L, NULL, iid,pHandler);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"OpenAsync via IWbemConnection failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from OpenAsync was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Object Name: %s",wcsObjectName);
            LogCLSID(csFile,Line, L"REFIID",iid);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetPropertyAndLogErrors( IWbemClassObject * pClass, WCHAR * wcsProperty, VARIANT * vProperty, CIMTYPE * pType,
                             LONG * plFlavor, WCHAR * wcsClassName, WCHAR * wcsNamespace,
                             BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->Get(CBSTR(wcsProperty),0L,vProperty,pType, plFlavor);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Get failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Get was: 0x%x", hr );
            if( wcsClassName )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get property %s from class: %s from Namespace %s",wcsProperty, wcsClassName,wcsNamespace);
            }
            else
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the class name (property %s) from Namespace %s",wcsProperty, wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassObjectAndLogErrors( IWbemServices * pNamespace, const WCHAR * wcsClassName, IWbemClassObject ** ppClass,
                                WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    WCHAR * wcsClass = (WCHAR*) wcsClassName;
  	
    HRESULT hr = pNamespace->GetObject(CBSTR(wcsClass),WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,ppClass,NULL );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"GetObject failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetObject was: 0x%x", hr );
            if( wcsClassName )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get class: %s from Namespace %s",wcsClassName,wcsNamespace);
            }
            else
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting create an empty class in the Namespace %s",wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int SpawnInstanceAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->SpawnInstance(0, ppInst);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"SpawnInstance failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from SpawnInstance was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to spawn instance of class: %s from Namespace %s",wcsClassName,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int SpawnDerivedClassAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->SpawnDerivedClass(0, ppInst);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"SpawnDerivedClass failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from SpawnDerivedClass was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to spawn derviced class: %s from Namespace %s",wcsClassName,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutPropertyAndLogErrors( IWbemClassObject * pInst, const WCHAR * wcsProperty, long lType, VARIANT * pVar, const WCHAR * wcsClass,
                             DWORD dwFlags,WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    WCHAR * wcsProp = (WCHAR*)wcsProperty;
    HRESULT hr = pInst->Put(CBSTR(wcsProp), dwFlags, pVar, lType);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Put failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put %s in class %s in Namespace %s",wcsProperty,wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutInstanceAndLogErrors( IWbemServices * pNamespace, IWbemClassObject * pInst, const WCHAR * wcsClass,
                             WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pNamespace->PutInstance(pInst,WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"PutInstance failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from PutInstance was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put instance of class %s in Namespace %s",wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ClassInheritsFromAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass, const WCHAR * wcsParent, 
                                   WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = pClass->InheritsFrom( wcsParent );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"InheritsFrom failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from InheritsFrom was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to inherit class %s from class %s in Namespace %s",wcsClass,wcsParent,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetPropertyQualifierSetAndLogErrors( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,const WCHAR * wcsProperty, 
                                 const WCHAR * wcsClass,
                                 WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    *pQualifierSet = NULL;
    WCHAR * wcsProp = (WCHAR*) wcsProperty;

    hr = pClass->GetPropertyQualifierSet(CBSTR(wcsProp),pQualifierSet);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"GetPropertyQualifierSet failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetPropertyQualifierSet was: 0x%x", hr );
            if( wcsProperty )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for property %s in class %s from class %s in Namespace %s",wcsProperty,wcsClass,wcsNamespace);
            }
            else
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for class %s from class %s in Namespace %s",wcsClass,wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutQualifierOnPropertyAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsProperty, const WCHAR * wcsQualifier, 
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    IWbemQualifierSet * pQualifierSet = NULL;

    nRc = GetPropertyQualifierSetAndLogErrors( pClass, &pQualifierSet,wcsProperty,wcsClass,wcsNamespace,fExpectedFailure,csFile,Line );
    if( nRc == SUCCESS )
    {
        WCHAR * wcsQual = (WCHAR*)wcsQualifier;
       	hr = pQualifierSet->Put(CBSTR(wcsQual), Var, dwFlags);
        if( FAILED(hr))
        {
            nRc = FATAL_ERROR;
        }
    }
    SAFE_RELEASE_PTR(pQualifierSet);
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"QualifierSet->Put failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put qualifier %s on property %s in class %s in Namespace %s",wcsQualifier, wcsProperty,wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassQualifierSetAndLogErrors( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet, 
                                      const WCHAR * wcsClass,
                                      WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    *pQualifierSet = NULL;

    hr = pClass->GetQualifierSet(pQualifierSet);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"GetQualifierSet failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetQualifierSet was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for class %s in Namespace %s",wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutQualifierOnClassAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsQualifier, 
                                     VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                     WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    IWbemQualifierSet * pQualifierSet = NULL;

    nRc = GetClassQualifierSetAndLogErrors( pClass, &pQualifierSet,wcsClass,wcsNamespace,fExpectedFailure,csFile,Line );
    if( nRc == SUCCESS )
    {
        WCHAR * wcsQual = (WCHAR*)wcsQualifier;
       	hr = pQualifierSet->Put(CBSTR(wcsQual), Var, dwFlags);
        if( FAILED(hr))
        {
            nRc = FATAL_ERROR;
        }
    }
    SAFE_RELEASE_PTR(pQualifierSet);
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"QualifierSet->Put failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put qualifier %s on class %s in Namespace %s",wcsQualifier, wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassesAndLogErrors( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, DWORD dwFlags, WCHAR * wcsClass, 
                                  WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Begin enumerating classes
	// =================================================================
    HRESULT hr = S_OK;

    hr = pNamespace->CreateClassEnum(CBSTR(wcsClass), dwFlags,NULL,pEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"CreateClassEnum failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CreateClassEnum was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to Enumerate Classes in Namespace %s",wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumeratePropertiesAndLogErrors( IWbemClassObject * pClass, DWORD dwFlags, WCHAR * wcsClass, 
                                     WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Begin enumerating properties
	// =================================================================
    HRESULT hr = S_OK;

    hr = pClass->BeginEnumeration(dwFlags);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"BeginEnumeration failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from BeginEnumeration was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to Enumerate properties for class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateInstancesAndLogErrors( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, const WCHAR * wcsClassName,
                                    WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Begin enumerating classes
	// =================================================================
    HRESULT hr = S_OK;
    WCHAR * wcsClass = (WCHAR*)wcsClassName;
    
    hr = pNamespace->CreateInstanceEnum(CBSTR(wcsClass), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,NULL,pEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"CreateInstanceEnum failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CreateInstanceEnum was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to Enumerate instances of class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int NextClassAndLogErrors( IEnumWbemClassObject * pEnum, IWbemClassObject ** pClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Get the next class
	// =================================================================

    unsigned long u = 0;
    HRESULT hr = pEnum->Next(0,1,pClass,&u);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    else if( hr != S_OK )
    {
        nRc = NO_MORE_DATA;
    }
    if( nRc == FATAL_ERROR )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Next failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Next was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the next Class in Namespace %s",wcsNamespace);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int NextPropertyAndLogErrors( IWbemClassObject * pClass, BSTR * pstrName, VARIANT * pVar, CIMTYPE * lType, 
                              LONG * lFlavor, WCHAR * wcsClass,
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Get the next class
	// =================================================================

    unsigned long u = 0;
    HRESULT hr = pClass->Next(0,pstrName, pVar, lType, lFlavor );
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    else if( hr != S_OK )
    {
        nRc = NO_MORE_DATA;
    }
    if( nRc == FATAL_ERROR )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Next failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Next was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the next property for class %s in Namespace %s", wcsClass, wcsNamespace);
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassAndLogErrors(IWbemServices * pNamespace, const WCHAR * wcsClassName,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the class
	// =================================================================
    
    WCHAR * wcsClass = (WCHAR*)wcsClassName;

    HRESULT hr = pNamespace->DeleteClass(CBSTR(wcsClass),0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Delete failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Delete was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to delete Class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteInstanceAndLogErrors(IWbemServices * pNamespace, const WCHAR * wcsInstanceName,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the requested instance
	// =================================================================
    WCHAR * wcsInstance = (WCHAR*)wcsInstanceName;

    HRESULT hr = pNamespace->DeleteInstance(CBSTR(wcsInstance),0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"DeleteInstance failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from DeleteInstance was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to delete instance %s in Namespace %s",wcsInstance, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutClassAndLogErrors(IWbemServices * pNamespace, IWbemClassObject * pClass, const WCHAR * wcsClass, 
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = pNamespace->PutClass(pClass,0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure && ( hr == WBEM_E_CLASS_HAS_CHILDREN ))
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"PutClass failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from PutClass was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecQueryAndLogErrors(IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum, WCHAR * wcsQuery, DWORD dwFlags,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    // Execute the query
	// =================================================================
 
    HRESULT hr = pNamespace->ExecQuery(CBSTR(L"WQL"), CBSTR(wcsQuery),dwFlags,NULL,ppEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure  )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ExecQuery failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecQuery was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to query %s in Namespace %s",wcsQuery, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecNotificationQueryAndLogErrors(IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, IWbemContext * pCtx,
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    // Execute the notification query
	// =================================================================
    WCHAR * wcsL = (WCHAR*)wcsLanguage;
    WCHAR * wcsQ = (WCHAR*)wcsQuery;
 	HRESULT hr = pNamespace->ExecNotificationQuery(CBSTR(wcsL),CBSTR(wcsQ),WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,pCtx,ppEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure  )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ExecNotificationQuery failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecNotificationQuery was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to query %s in Namespace %s using Language %s",wcsQuery, wcsNamespace, wcsLanguage);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecNotificationQueryAsyncAndLogErrors(IWbemServices * pNamespace, CSinkEx * pResponse, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, IWbemContext * pCtx,
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    // Execute the notification query
	// =================================================================
    WCHAR * wcsL = (WCHAR*)wcsLanguage;
    WCHAR * wcsQ = (WCHAR*)wcsQuery;

 	HRESULT hr = pNamespace->ExecNotificationQueryAsync(CBSTR(wcsL),CBSTR(wcsQ),0,pCtx,pResponse);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure  )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ExecNotificationQueryAsync failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecNotificationQueryAsync was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to query %s in Namespace %s using Language %s",wcsQuery, wcsNamespace, wcsLanguage);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CancelAsyncCallAndLogErrors(IWbemServices * pNamespace, CSinkEx * pResponse, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, 
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    // Cancel the notification query
 	// =================================================================

 	HRESULT hr = pNamespace->CancelAsyncCall(pResponse);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure  )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"CancelAsyncCall failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CancelAsyncCall was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to cancel handler for query %s in Namespace %s using Language %s",wcsQuery, wcsNamespace, wcsLanguage);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutMethodAndLogErrors( IWbemClassObject * pClass, IWbemClassObject * pInClass,
                           IWbemClassObject * pOutClass,const WCHAR * wcsMethodName, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set the method
	// =================================================================
    HRESULT hr = pClass->PutMethod(wcsMethodName,0,pInClass,pOutClass);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"PutMethod failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from PutMethod was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to put method %s on class %s in Namespace %s",wcsMethodName, wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsMethodName, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the method
	// =================================================================
    HRESULT hr = pClass->DeleteMethod(wcsMethodName);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"DeleteMethod failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from DeleteMethod was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to delete method %s on class %s in Namespace %s",wcsMethodName, wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the method
	// =================================================================
    HRESULT hr = pClass->BeginMethodEnumeration(0);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"BeginMethodEnumeration failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from BeginMethodEnumeration was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to enumerate methods on class %s in Namespace %s", wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int NextMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass, BSTR * pName, IWbemClassObject ** ppIn,
                           IWbemClassObject ** ppOut,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the method
	// =================================================================
    HRESULT hr = pClass->NextMethod(0,pName,ppIn,ppOut);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    else if( hr != S_OK )
    {
        nRc = NO_MORE_DATA;
    }
    if( nRc == FATAL_ERROR )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"NextMethod failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from NextMethod was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the next method for class %s in Namespace %s", wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecuteMethodAndLogErrors(IWbemServices * pNamespace, 
                              WCHAR * wcsMethod, WCHAR * wcsPath,         
                              long lFlags,                       
                              IWbemClassObject *pIn,
                              IWbemClassObject **ppOut,
                              const WCHAR * wcsClass, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Execute the method
	// =================================================================
    HRESULT hr = pNamespace->ExecMethod(CBSTR(wcsPath),CBSTR(wcsMethod), lFlags, NULL, pIn, ppOut,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ExecMethod failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecMethod was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to execute the method %s for class %s in Namespace %s", wcsMethod,wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecMethodAsyncAndLogErrors(IWbemServices * pNamespace,  WCHAR * wcsMethod, WCHAR * wcsPath,         
                              long lFlags,                       
                              IWbemClassObject *pIn,
                              IWbemObjectSink *pResponseHandler,
                              const WCHAR * wcsClass, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Execute the method
	// =================================================================
    HRESULT hr = pNamespace->ExecMethodAsync(CBSTR(wcsPath),CBSTR(wcsMethod), lFlags, NULL, pIn, pResponseHandler);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"ExecMethodAsync failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecMethodAsync was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to execute the method async %s for class %s in Namespace %s", wcsMethod,wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetMethodAndLogErrors(IWbemClassObject * pClass,  WCHAR * wcsMethod, IWbemClassObject **ppIn,
                          IWbemClassObject **ppOut,   const WCHAR * wcsClass, 
                          WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Get the method
	// =================================================================
    HRESULT hr = pClass->GetMethod(wcsMethod,0, ppIn, ppOut );
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = SUCCESS;
        }
        else
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"GetMethod failed." );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetMethod was: 0x%x", hr );
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Attempting to Get the method  %s for class %s in Namespace %s", wcsMethod,wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtapi.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_API_HEADER
#define _BVT_API_HEADER

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Prototypes 
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
int CoCreateInstanceAndLogErrors      ( REFCLSID clsid, REFIID  iid, void ** pPtr, BOOL fExpectedFailure, 
                                        const char * csFile, const ULONG Line );
int ConnectServerAndLogErrors         ( IWbemLocator * pLocator, IWbemServices ** pNamespace, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int OpenObjectAndLogErrors            ( IWbemConnection * pConnection, REFIID  iid, void ** pObj, WCHAR * wcsObjectName,
                                        BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int OpenObjectAsyncAndLogErrors       ( IWbemConnection * pConnection, REFIID  iid, WCHAR * wcsObjectName, 
                                        IWbemObjectSinkEx * pHandler, BOOL fExpectedFailure, const char * csFile,
                                        const ULONG Line );
int GetClassObjectAndLogErrors        ( IWbemServices * pNamespace, const WCHAR * wcsClassName, IWbemClassObject ** ppClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int SpawnInstanceAndLogErrors         ( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int SpawnDerivedClassAndLogErrors    ( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                                       WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutPropertyAndLogErrors           ( IWbemClassObject * pInst, const WCHAR * wcsProperty, long lType, VARIANT * pVar, 
                                        const WCHAR * wcsClass, DWORD dwFlags, WCHAR * wcsNamespace, BOOL fExpectedFailure, 
                                        const char * csFile , const ULONG Line );
int PutInstanceAndLogErrors           ( IWbemServices * pNamespace, IWbemClassObject * pInst,const WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int ClassInheritsFromAndLogErrors     ( IWbemClassObject * pClass, const WCHAR * wcsClass, const WCHAR * wcsParent, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int GetPropertyQualifierSetAndLogErrors ( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,
                                        const WCHAR * wcsProperty, const WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int GetClassQualifierSetAndLogErrors  ( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,
                                        const WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );

int PutQualifierOnClassAndLogErrors   ( IWbemClassObject * pClass, const WCHAR * wcsQualifier, 
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutQualifierOnPropertyAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsProperty,const WCHAR * wcsQualifier,
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteClassAndLogErrors           ( IWbemServices * pNamespace, const WCHAR * wcsClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutClassAndLogErrors              ( IWbemServices * pNamespace, IWbemClassObject * pClass, const WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int NextClassAndLogErrors             ( IEnumWbemClassObject * pEnum, IWbemClassObject ** pClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int EnumerateClassesAndLogErrors      ( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, DWORD dwFlags, WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );

int EnumerateInstancesAndLogErrors    ( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, const WCHAR * wcsClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int EnumeratePropertiesAndLogErrors   ( IWbemClassObject * pClass, DWORD dwFlags, WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int NextPropertyAndLogErrors          ( IWbemClassObject * pClass, BSTR * pstrName, VARIANT * pVar, CIMTYPE * lType, 
                                        LONG * lFlavor, WCHAR * wcsClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int GetPropertyAndLogErrors           ( IWbemClassObject * pClass, WCHAR * wcsProperty, VARIANT * vProperty, CIMTYPE * pType,
                                        LONG * plFlavor, WCHAR * wcsClassName, WCHAR * wcsNamespace,
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteInstanceAndLogErrors        ( IWbemServices * pNamespace, const WCHAR * wcsInstance,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecQueryAndLogErrors             ( IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum,WCHAR * wcsQuery, DWORD dwFlags, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecNotificationQueryAndLogErrors(IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, IWbemContext * pCtx,
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecNotificationQueryAsyncAndLogErrors(IWbemServices * pNamespace, CSinkEx * pResponse, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, IWbemContext * pCtx,
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int CancelAsyncCallAndLogErrors(IWbemServices * pNamespace, CSinkEx * pResponse, const WCHAR * wcsQuery,
                                      const WCHAR * wcsLanguage, WCHAR * wcsNamespace, 
                                      BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutMethodAndLogErrors( IWbemClassObject * pClass, IWbemClassObject * pInClass,
                           IWbemClassObject * pOutClass,const WCHAR * wcsMethodName, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsMethodName, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int EnumerateMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int NextMethodAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass, BSTR * pName, IWbemClassObject ** ppIn,
                           IWbemClassObject ** ppOut,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecuteMethodAndLogErrors(IWbemServices * pNamespace, 
                              WCHAR * wcsMethod, WCHAR * wcsPath,         
                              long lFlags,                       
                              IWbemClassObject *pIn,
                              IWbemClassObject **ppOut,
                              const WCHAR * wcsClass, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecMethodAsyncAndLogErrors(IWbemServices * pNamespace,  WCHAR * wcsMethod, WCHAR * wcsPath,         
                              long lFlags,                       
                              IWbemClassObject *pIn,
                              IWbemObjectSink *pResponseHandler,
                              const WCHAR * wcsClass, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int GetMethodAndLogErrors(IWbemClassObject * pClass,  WCHAR * wcsMethod, IWbemClassObject **ppIn,
                          IWbemClassObject **ppOut,   const WCHAR * wcsClass, 
                          WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtcom.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTCOM.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Common functional units used among tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogTestBeginning(int nWhich, BOOL fSuppress)
{
    CHString sBuffer;

    if( !fSuppress )
    {
        gp_LogFile->LogError(__FILE__,__LINE__,SUCCESS, L"**************************** Running Test# %d ", nWhich );
        if( g_Options.GetSpecificOptionForAPITest(L"DESCRIPTION",sBuffer, nWhich) )
        {
            gp_LogFile->LogError(__FILE__,__LINE__,SUCCESS, L"%s ", sBuffer );
        }
    }

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogTestEnding(int nWhich,int nRc, BOOL fSuppress)
{
    if( !fSuppress )
    {
       gp_LogFile->LogError(__FILE__,__LINE__,nRc, L"**************************** Ending Test# %d\n", nWhich );
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int RunRequestedTests(int nWhichTest, BOOL fCompareResults)
{
    int nRc = SUCCESS;
    //=========================================================
    //  Get the list of tests to run
    //=========================================================
    CHString sTests;
    if( g_Options.GetSpecificOptionForAPITest(L"RUNTESTS", sTests, nWhichTest))
    {
        nRc = FATAL_ERROR;
        ItemList TestList;
        //=======================================================
        //  Get the list of the tests to be run
        //=======================================================
        if( InitMasterList(sTests,TestList))
        {
            for( int i = 0; i < TestList.Size(); i++ )
            {
                ItemInfo * p = TestList.GetAt(i);
                if( _wcsicmp(L"Empty",p->Item ) == 0 )
                {
                    nRc = SUCCESS;
                }
                else
                {
                    int nTest = _wtoi(p->Item);
                    nRc = RunTests(nTest,fCompareResults,TRUE);
                }
                if( nRc != SUCCESS )
                {
                    break;
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int RunRequestedTestsAndOpenNamespace(int nWhichTest, CHString & sNamespace, IWbemServices ** ppNamespace, BOOL fCompareResults)
{
    //=========================================================
    //  Run the requested tests
    //=========================================================
    int nRc = RunRequestedTests(nWhichTest, fCompareResults);

    if( SUCCESS == nRc )
    {
        //=====================================================
        //  Get the name of the test namespace that was created
        //=====================================================
        if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace,nWhichTest))
        {
	        // ==================================================
            //  Open the namespace 
	        // ==================================================
            nRc = OpenNamespaceAndKeepOpen( ppNamespace, sNamespace,TRUE,fCompareResults);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenNamespaceAndKeepOpen( IWbemServices ** ppNamespace, const WCHAR * wcsNamespace, BOOL fCreateIfDoesntExist, BOOL fCompareResults)
{
    //==========================================================================
    // Open CIMV2 namespace
    //==========================================================================
    int nRc = FATAL_ERROR;
    IWbemLocator    * pLocator      = NULL;

	// =====================================================================
    //  Get the locator
	// =====================================================================
    nRc = CoCreateInstanceAndLogErrors(CLSID_WbemLocator,IID_IWbemLocator,(void**)&pLocator,NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
	    // =================================================================
	    // Connect to the desired namespace
        // =================================================================
        nRc = ConnectServerAndLogErrors(pLocator,ppNamespace,(WCHAR*)wcsNamespace,ERRORS_CAN_BE_EXPECTED);
        if( (SUCCESS != nRc ) && ( fCreateIfDoesntExist ))
        {
            nRc = CreateNewTestNamespace(fCompareResults,TRUE);
            if( nRc == S_OK )
            {
                nRc = ConnectServerAndLogErrors(pLocator,ppNamespace,(WCHAR*)wcsNamespace,NO_ERRORS_EXPECTED);
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pLocator);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int WritePropertiesAndQualifiers( IWbemServices * pNamespace, IWbemClassObject * pClass, CPropertyList & Props, 
                                  const WCHAR * wcsClass, DWORD dwFlags,
                                  WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = FATAL_ERROR;

    if( Props.Size() == 0 )
    {
        nRc = SUCCESS;
    }

    for( int i = 0; i < Props.Size(); i++ )
    {                                
        //======================================================
        //  Get the property info
        //======================================================
        PropertyInfo *p = Props.GetAt(i); 
        if( !p )
        {
            break;
        }

        if( wcslen(p->QualifierName) > 0 )
        {
            //======================================================
            //  If it is a qualifier, write the qualifier
            //======================================================
            nRc = PutQualifierOnPropertyAndLogErrors( pClass, p->Property, p->QualifierName ,
                                                      p->Var, wcsClass, dwFlags, wcsNamespace, fExpectedFailure, 
                                                      csFile , Line );
        }
        else
        {
            //======================================================
            //  Write out the property
            //======================================================
            int nTmp = CIM_STRING|CIM_FLAG_ARRAY;
            if( nTmp == p->Type) 
            {
                SAFEARRAY* saStr;
	            SAFEARRAYBOUND rgsabound[1];
		        long ix[1];

                rgsabound[0].cElements = 1;
		        rgsabound[0].lLbound = 0;
		        saStr = SafeArrayCreate(VT_BSTR, 1, rgsabound);
		        ix[0] = 0;

                SafeArrayPutElement( saStr,ix, p->Var.GetStr());

                CVARIANT vVar;
                vVar.SetArray( saStr,VT_BSTR | VT_ARRAY);
  
                nRc = PutPropertyAndLogErrors( pClass, p->Property, p->Type, vVar, wcsClass, 0,wcsNamespace, fExpectedFailure, csFile , Line );
            }
            else
            {
                nRc = PutPropertyAndLogErrors( pClass, p->Property, p->Type, p->Var, wcsClass, 0,wcsNamespace, fExpectedFailure, csFile , Line );
            }
        }
        if( nRc != SUCCESS )
        { 
            break;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateClassAndLogErrors( IWbemServices * pNamespace, WCHAR * wcsClassDefinition,
                             WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = FATAL_ERROR;
    IWbemClassObject *pClass = NULL;

    CHString sParentClass;
    CHString sInstance;
    CHString sClass;
    CPropertyList Properties;       // destructor will release
    int nResults = 0;

    //===========================================================
    //  Get the class definition
    //===========================================================
    nRc = CrackClass(wcsClassDefinition, sClass, sParentClass, sInstance, Properties, nResults, 
                            fExpectedFailure, csFile, Line );
    if( nRc == SUCCESS )
    {
        if( wcslen(sParentClass) > 0 )
        {
 	        // =================================================================
            //  Spawn a class from the parent
 	        // =================================================================
            IWbemClassObject * pParentClass = NULL;
            nRc = GetClassObjectAndLogErrors(pNamespace, WPTR sParentClass, &pParentClass, wcsNamespace, fExpectedFailure, csFile , Line );
            if( nRc == SUCCESS )
            {
                nRc = SpawnDerivedClassAndLogErrors(pParentClass,WPTR sParentClass, &pClass,wcsNamespace, fExpectedFailure, csFile , Line );
            }
        }
        else
        {
 	        // =================================================================
            //  Get an empty class object to work with
 	        // =================================================================
            nRc = GetClassObjectAndLogErrors(pNamespace, NULL, &pClass, wcsNamespace, fExpectedFailure, csFile , Line );
        }
        if( nRc == SUCCESS )
        {
            //==============================================================
            //  Now, set the properties of the class
            //  start with the name of the class
            //==============================================================
            CVARIANT var;
            var.SetStr(WPTR sClass);

            nRc = PutPropertyAndLogErrors( pClass, L"__CLASS", CIM_STRING, var, sClass, 0,wcsNamespace, fExpectedFailure, csFile , Line );
            if( SUCCESS == nRc )
            {
                //==========================================================
                //  Set the rest of the properties
                //==========================================================
                DWORD dwFlags = 0;
                nRc = WritePropertiesAndQualifiers(pNamespace, pClass, Properties,sClass,dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                //==============================================================
                //  Now, create the class
                //==============================================================
                if( SUCCESS == nRc )
                {
                    nRc = PutClassAndLogErrors(pNamespace, pClass,sClass,wcsNamespace, TRUE, csFile , Line );
                }
            }
        }
    }

    SAFE_RELEASE_PTR(pClass);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateClassesForSpecificTest( IWbemServices * pNamespace, WCHAR * wcsNamespace, WCHAR * wcsSection, int nTest)
{
    int nRc = FATAL_ERROR;

    CHString sItemList;
    if( g_Options.GetSpecificOptionForAPITest(wcsSection,sItemList,nTest))
    {
        ItemList MasterList;
        //=======================================================
        //  Get the list of the classes to be created
        //=======================================================
        if( InitMasterList(sItemList,MasterList))
        {
            for( int i = 0; i < MasterList.Size(); i++ )
            {
                ItemInfo * p = MasterList.GetAt(i);
                CHString sItemInformation;

                if( g_Options.GetSpecificOptionForAPITest(p->Item,sItemInformation,nTest) )
                {
                    //===========================================================
                    //  Add the keys and properties
                    //===========================================================
                    nRc = CreateClassAndLogErrors(pNamespace,(WCHAR*)((const WCHAR*) sItemInformation), wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClasses(CHString & sDeleteClasses, int nWhichTest, BOOL fCompareResults, IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;

    //=======================================================
    //  Get the list of the classes to be deleted
    //=======================================================
    if( InitAndExpandMasterList(sDeleteClasses,nWhichTest, MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pClass = MasterList.GetAt(i);
            nRc = DeleteClassAndLogErrors(pNamespace, pClass->Item, wcsNamespace,NO_ERRORS_EXPECTED);
            if( nRc != SUCCESS )
            {
                break;
            }
            if( fCompareResults )
            {   
                //===========================================
                //  Try to see if there are any instances
                //  of the deleted class
                //===========================================
                IEnumWbemClassObject * pEnum = NULL;

                nRc = EnumerateInstancesAndLogErrors( pNamespace,&pEnum,(WCHAR*)((const WCHAR*)pClass->Item), 
                                                      wcsNamespace,ERRORS_CAN_BE_EXPECTED);
                if( SUCCESS == nRc )
                {
        	        IWbemClassObject * pClass = NULL;
                    nRc = NextClassAndLogErrors( pEnum, &pClass, wcsNamespace, ERRORS_CAN_BE_EXPECTED );
                    if( FAILED_AS_EXPECTED == nRc )
                    {
                        nRc = SUCCESS;
                    }
                    else
                    {
                        nRc = FATAL_ERROR;
                    }
                    SAFE_RELEASE_PTR(pClass);
                }
                SAFE_RELEASE_PTR(pEnum);

                if( nRc != SUCCESS )
                {
                    break;
                }
    
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CompareProperties(IWbemClassObject * pClass, CPropertyList * pProps, DWORD dwFlags, WCHAR * wcsClass, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;
    //===================================================
    //  Begin enumerating the properties
    //===================================================
    nRc = EnumeratePropertiesAndLogErrors( pClass, dwFlags, wcsClass, wcsNamespace, NO_ERRORS_EXPECTED); 
    if( nRc == S_OK )
    {
        //===============================================
        //  Now, see if the properties in the instance or
        //  class are the same as we think we have
        //===============================================
        while(TRUE)
        {
            CVARIANT vProperty;
			
            LONG     lType = 0;
            LONG     lFlavor = 0;            
			
			CBSTR    bstrProp;
            //===================================================
            //  Get the name of the class
            //===================================================
            nRc =  NextPropertyAndLogErrors( pClass,(BSTR*) &bstrProp, &vProperty, &lType, &lFlavor, wcsClass, wcsNamespace, NO_ERRORS_EXPECTED );
            if( nRc == NO_MORE_DATA )
            {
                nRc = SUCCESS;
                break;
            }
            if( nRc != SUCCESS )
            { 
                break;
            }			

            PropertyInfo p;
            p.Property = bstrProp;
            p.Type = lType;
            p.Var = vProperty;
			vProperty.Unbind(); // THIS SHOULD BE OK !!!!

            nRc = pProps->PropertyInListAndLogErrors(&p,wcsClass,wcsNamespace, NO_ERRORS_EXPECTED);
            if( SUCCESS != nRc )
            {
                break;
            }			

			
        }

		
        if( nRc == SUCCESS )
        {
            //====================================================
            //  Go through the master list and see if there are
            //  any properties we expect to be there but we didn't
            //  get during the enumeration
            //====================================================
            nRc = pProps->PropertiesCompareAsExpectedAndLogErrors(wcsClass, wcsNamespace,NO_ERRORS_EXPECTED);
        }
    
    }
    return nRc;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetInstanceAndCompare( IWbemServices * pNamespace, DWORD dwFlags, CHString & sInstanceList, 
                           int nWhichTest, BOOL fCompareResults,  WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    //=======================================================
    //  Get the list of the classes to get instances for
    //=======================================================
    ItemList InstanceList;

    if( InitMasterList(sInstanceList,InstanceList))
    {
        for( int i=0; i < InstanceList.Size(); i++ )
        {
            ItemInfo * p = InstanceList.GetAt(i);
            
            //=======================================================
            //  Get the specific instance information
            //=======================================================
            CHString sItemInformation;
            if( g_Options.GetSpecificOptionForAPITest(p->Item,sItemInformation,nWhichTest) )
            {
                CHString sParentClass;
                CHString sInstance;
                CHString sClass;
                CPropertyList Properties;                   // destructor will release
                int nResults = -1;

                //===========================================================
                //  Get the instance information that we added
                //===========================================================
                nRc = CrackClass((WCHAR*)((const WCHAR*)sItemInformation),sClass, sParentClass, sInstance, Properties, 
                                            nResults, NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    //===================================================
                    //  Get the instance we added
                    //===================================================
                    IWbemClassObject * pInst = NULL;
                    nRc = GetClassObjectAndLogErrors( pNamespace, (WCHAR*)((const WCHAR*)sInstance), 
                                                      &pInst, wcsNamespace, NO_ERRORS_EXPECTED );
                    if( SUCCESS == nRc )
                    {
                        if( fCompareResults )
                        {
                            nRc = CompareProperties(pInst, &Properties, dwFlags, (WCHAR*)((const WCHAR*)p->Item), wcsNamespace);
                        }
                    }
                    SAFE_RELEASE_PTR(pInst);
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassesAndCompare(CHString & sClassesAfterDelete, int nWhichTest, BOOL fCompareResults, 
                               IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    IEnumWbemClassObject * pEnum = NULL;
    int nRc = FATAL_ERROR;

    //===========================================================
    //  Begin enumerating all of the classes in the namespace
    //===========================================================
    nRc = EnumerateClassesAndLogErrors(pNamespace,&pEnum, WBEM_FLAG_RETURN_IMMEDIATELY|WBEM_FLAG_FORWARD_ONLY , NULL, wcsNamespace,NO_ERRORS_EXPECTED);
    if( nRc == S_OK )
    {
        ItemList MasterList;

        //=======================================================
        //  Get the list of the classes to compare with what is
        //  in the namespace
        //=======================================================
        if( InitAndExpandMasterList(sClassesAfterDelete,nWhichTest,MasterList))
        {
            //===================================================
            //  while we get the classes in the namespace
            //===================================================
            while( TRUE )
            {
    	        IWbemClassObject * pClass = NULL;
                nRc = NextClassAndLogErrors(pEnum, &pClass,wcsNamespace,NO_ERRORS_EXPECTED);
                if( nRc == NO_MORE_DATA )
                {
                    nRc = SUCCESS;
                    SAFE_RELEASE_PTR(pClass);
                    break;
                }
                if( nRc != SUCCESS )
                { 
                    SAFE_RELEASE_PTR(pClass);
                    break;
                }
                CVARIANT vProperty;
                CIMTYPE pType = 0;
                LONG    lFlavor = 0;
                //===================================================
                //  Get the name of the class
                //===================================================
                nRc = GetPropertyAndLogErrors( pClass, L"__CLASS", &vProperty, &pType, &lFlavor, NULL,wcsNamespace, NO_ERRORS_EXPECTED);
                if( nRc == S_OK )
                {
                    //===============================================
                    //  filter out system classes
                    //===============================================
                    if( wcsncmp( vProperty.GetStr(), L"__", 2 ) != 0 )
                    {
                        //===============================================
                        //  Compare the class name with what we expect
                        //  and make sure we haven't already compared it
                        //  before, if it isn't in the list, then error
                        //  out, we have a big problem
                        //===============================================
                        nRc = MasterList.ItemInListAndLogErrors(vProperty.GetStr(),wcsNamespace,NO_ERRORS_EXPECTED);
                        if( nRc != SUCCESS )
                        {
                            SAFE_RELEASE_PTR(pClass);
                            break;
                        }
                    }
                }
                SAFE_RELEASE_PTR(pClass);
            }
        }
        if( nRc == SUCCESS )
        {
            if( fCompareResults )
            {
                //====================================================
                //  Go through the master list and see if there are
                //  any classes we expect to be there but we didn't
                //  get during the enumeration
                //====================================================
                nRc = MasterList.ItemsCompareAsExpectedAndLogErrors(wcsNamespace,NO_ERRORS_EXPECTED);
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateInstancesAndCompare( CHString & sInstances, int nWhichTest, BOOL fCompareResults, 
                                  IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;
    ItemList MasterList;
    //===========================================================
    //  Get the list of the classes to compare with what is
    //  in the namespace
    //===========================================================
    if( InitMasterList(sInstances,MasterList))
    {
        for( int i=0; i < MasterList.Size(); i++ )
        {
            ItemInfo * p = MasterList.GetAt(i);
            
            //=======================================================
            //  Get the specific instance information
            //=======================================================
            CHString sItemInformation;
            if( g_Options.GetSpecificOptionForAPITest(p->Item,sItemInformation,nWhichTest) )
            {
                CHString sParentClass;
                CHString sInstance;
                CHString sClass;
                CPropertyList Properties;                   // destructor will release
                int nResults = -1;

                //===========================================================
                //  Get the instance information that we added
                //===========================================================
                nRc = CrackClass( WPTR sItemInformation,sClass, sParentClass, sInstance, Properties, nResults, NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    //===================================================
                    //  Get the instance we added
                    //===================================================
                    IEnumWbemClassObject * pEnum = NULL;

                    nRc = EnumerateInstancesAndLogErrors( pNamespace,&pEnum,WPTR sClass, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS == nRc )
                    {
                        if( fCompareResults )
                        {
                            nRc = CompareResultsFromEnumeration(pEnum, nResults, WPTR sClass, wcsNamespace);
                        }
                    }
                    SAFE_RELEASE_PTR(pEnum);
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int AddClasses(CHString & sAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace, int nWhichTest)
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    int nDefinitionSection = 0;
    CHString sClassDef;

    nRc = GetClassDefinitionSection(nWhichTest, sClassDef, nDefinitionSection );
    if( SUCCESS == nRc )
    {

        //=======================================================
        //  Get the list of the classes to be added
        //=======================================================
        if( InitMasterList(sAddClasses,MasterList))
        {
            for( int i = 0; i < MasterList.Size(); i++ )
            {
                ItemInfo * pClass = MasterList.GetAt(i);
                CHString sClassDefinition;

                if( g_Options.GetSpecificOptionForAPITest( pClass->Item, sClassDefinition,nDefinitionSection))
                {
                    nRc = CreateClassAndLogErrors(pNamespace, (WCHAR*)((const WCHAR*)sClassDefinition), wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAndAddClasses(CHString & sDeleteAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace, int nWhichTest)
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    int nDefinitionSection = 0;
    CHString sClassDef;

    nRc = GetClassDefinitionSection(nWhichTest, sClassDef, nDefinitionSection );
    if( SUCCESS == nRc )
    {
        //=======================================================
        //  Get the list of the classes to be added & deleted
        //=======================================================
        if( InitMasterListOfAddDeleteClasses(sDeleteAddClasses,nWhichTest, MasterList))
        {

            for( int i = 0; i < MasterList.Size(); i++ )
            {
                ItemInfo * pClass = MasterList.GetAt(i);
                if( pClass->fAction == DELETE_CLASS )
                {
                    nRc = DeleteClassAndLogErrors(pNamespace, pClass->Item, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
                else
                {
                    ItemInfo * pClass = MasterList.GetAt(i);
                    CHString sClassDefinition;

                    if( g_Options.GetSpecificOptionForAPITest( pClass->KeyName, sClassDefinition, nDefinitionSection))
                    {
                        nRc = CreateClassAndLogErrors(pNamespace,(WCHAR*)((const WCHAR*) sClassDefinition), wcsNamespace,NO_ERRORS_EXPECTED);
                        if( nRc != SUCCESS )
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetSpecificObjects(CHString & sObjects, IWbemServices * pNamespace, int nWhichTest,WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;

    //=======================================================
    //  Get the list of the classes to be deleted
    //=======================================================
    if( InitMasterList(sObjects,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pItemInfo    = MasterList.GetAt(i);
            CHString sObjectPath;
            if( g_Options.GetSpecificOptionForAPITest( pItemInfo->Item, sObjectPath, nWhichTest))
            {
                IWbemClassObject * pClass = NULL;

                nRc = GetClassObjectAndLogErrors(pNamespace,(WCHAR*)(const WCHAR*) sObjectPath, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
                SAFE_RELEASE_PTR(pClass);
                if( nRc != SUCCESS )
                {
                    break;
                }
                SAFE_RELEASE_PTR(pClass);
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateInstance(IWbemServices * pNamespace,WCHAR * wcsInstanceInfo, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject *pInst   = NULL;

    CHString sParentClass;
    CHString sInstance;
    CHString sClass;
    CPropertyList Properties;       // destructor will release
    int nResults = 0;

    //===========================================================
    //  Get the class definition
    //===========================================================
    nRc = CrackClass(wcsInstanceInfo,sClass,sParentClass,sInstance,Properties,nResults, NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        //==============================================================
        //  Get the class definition 
        //==============================================================
        nRc = GetClassObjectAndLogErrors(pNamespace,(WCHAR*)((const WCHAR*)sClass),&pClass,wcsNamespace, NO_ERRORS_EXPECTED);
        if( SUCCESS == nRc )
        {
            //==============================================================
            // Spawn a new instance of this class.
            //==============================================================
            nRc = SpawnInstanceAndLogErrors(pClass,(WCHAR*)((const WCHAR*)sClass),&pInst,wcsNamespace,NO_ERRORS_EXPECTED);
            if( SUCCESS == nRc )
            {
                //==========================================================
		        // Set the Properties
                //==========================================================
                DWORD dwFlags = 0;
                nRc = WritePropertiesAndQualifiers(pNamespace, pInst, Properties,(WCHAR*)((const WCHAR*)sClass),
                    dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    //==========================================================
                    // Create the new instance
                    //==========================================================
                   nRc = PutInstanceAndLogErrors(pNamespace, pInst,(WCHAR*)((const WCHAR*)sClass),wcsNamespace,NO_ERRORS_EXPECTED);
                }
            }
        }
    }
    SAFE_RELEASE_PTR(pInst);
    SAFE_RELEASE_PTR(pClass);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateInstances(IWbemServices * pNamespace, CHString & sInstances, WCHAR * wcsNamespace, int nClassDefinitionSection )
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;

    //=======================================================
    //  Get the list of the instances to be created
    //=======================================================
    if( InitMasterList(sInstances,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            CHString sItemInformation;

            ItemInfo * pItemInfo    = MasterList.GetAt(i);

            if( g_Options.GetSpecificOptionForAPITest(pItemInfo->Item,sItemInformation,nClassDefinitionSection) )
            {
                nRc = CreateInstance(pNamespace,(WCHAR*)((const WCHAR*)sItemInformation),wcsNamespace);
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateInstancesForSpecificTest(IWbemServices * pNamespace,WCHAR * wcsNamespace,WCHAR * wcsSection, int nTest, 
                                   BOOL fCompare)
{
    int nRc = FATAL_ERROR;

    // =============================================================
    //  Get the list of classes to get instances for
    // =============================================================
    CHString sInstanceList;

    int nWhichTest = 0;
    CHString sClassDef;

    nRc = GetClassDefinitionSection(nTest, sClassDef, nWhichTest );
    if( SUCCESS == nRc )
    {
        if( g_Options.GetSpecificOptionForAPITest(wcsSection, sInstanceList, nTest ) )
        {
            // =========================================================
            // Create the instances in the namespace
            // =========================================================
            nRc = CreateInstances(pNamespace, sInstanceList, wcsNamespace, nWhichTest);
            if( SUCCESS == nRc && fCompare )
            {
                 // =========================================================
                 //  Get the enumeration flags
                 // =========================================================
                 ItemList FlagList;
                 nRc = GetFlags(nWhichTest, FlagList);
                 if( SUCCESS == nRc )
                 {
                     for( int i = 0; i < FlagList.Size(); i++ )
                     {
                         ItemInfo * p = FlagList.GetAt(i);
                        // =====================================================
                        //  Make sure those instances are in the namespace
                        // =====================================================
                        nRc = GetInstanceAndCompare(pNamespace, p->dwFlags, sInstanceList,nWhichTest,fCompare, wcsNamespace);
                     }
                 }
            }
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteInstancesAndCompareResults(CHString & sDeleteInstances, int nWhichTest,IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;

    //=======================================================
    //  Get the list of the instances to be deleted
    //=======================================================
    if( InitMasterList(sDeleteInstances,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pClass = MasterList.GetAt(i);
            CHString sInstance;

            if( g_Options.GetSpecificOptionForAPITest(pClass->Item, sInstance, nWhichTest ) )
            {
                nRc = DeleteInstanceAndLogErrors(pNamespace,(WCHAR*)(const WCHAR*)sInstance , wcsNamespace,NO_ERRORS_EXPECTED);
                if( nRc == SUCCESS )
                {
                    IWbemClassObject * pInst = NULL;
                    nRc = GetClassObjectAndLogErrors( pNamespace,pClass->Item, &pInst, wcsNamespace, ERRORS_CAN_BE_EXPECTED );
                    if( FAILED_AS_EXPECTED == nRc )
                    {
                        nRc = SUCCESS;
                    }
                    else
                    {
                        nRc = FATAL_ERROR;
                    }
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateAssociationAndLogErrors(  IWbemServices * pNamespace, const WCHAR * wcsKey, WCHAR * wcsClassDefinition,
                                    WCHAR * wcsNamespace )
{
    IWbemClassObject *pClass = NULL;
    
    //===========================================================
    //  Get the association definition
    //===========================================================
    CPropertyList Props;
    CHString sClass;
    int nResults = 0;

    int nRc = CrackAssociation( wcsClassDefinition, sClass, Props, nResults,NO_ERRORS_EXPECTED);
    if( nRc == SUCCESS )
    {
 	    // =================================================================
        //  Get an empty class object to work with
 	    // =================================================================
        nRc = GetClassObjectAndLogErrors(pNamespace, NULL, &pClass, wcsNamespace, NO_ERRORS_EXPECTED);
        if( nRc == SUCCESS )
        {
            //==============================================================
            //  Write out the name of the association
            //==============================================================
            DWORD dwFlags = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
            CVARIANT v;
            v.SetStr(WPTR sClass);

            nRc = PutPropertyAndLogErrors( pClass, L"__CLASS",CIM_STRING, v,WPTR sClass, dwFlags, wcsNamespace, NO_ERRORS_EXPECTED);
            if( nRc == SUCCESS )
            { 
                //==========================================================
                //  Make the class an association
                //==========================================================
                CVARIANT Var;
                Var.SetBool(TRUE);
  
                nRc = PutQualifierOnClassAndLogErrors( pClass, L"Association",&Var,WPTR sClass,dwFlags, wcsNamespace, NO_ERRORS_EXPECTED);
                if( nRc == SUCCESS )
                { 
                    //======================================================
                    //  Now, create the association endpoints
                    //======================================================
                    nRc = WritePropertiesAndQualifiers(pNamespace, pClass, Props,WPTR sClass,dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS == nRc )
                    {
                        //==============================================================
                        //  Now, create the association class
                        //==============================================================
                        nRc = PutClassAndLogErrors(pNamespace, pClass,WPTR sClass,wcsNamespace, NO_ERRORS_EXPECTED);

                    }
                }
            }
        }
    }
    SAFE_RELEASE_PTR(pClass);
    return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CompareResultsFromEnumeration(IEnumWbemClassObject * pEnum, int nExpectedResults, WCHAR * wcsClass, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;
    int nNumber = 0;
    ULONG ulNumber = 0;
    IWbemClassObject * pClass = NULL;
    
    while(TRUE)
    {
        nRc = NextClassAndLogErrors( pEnum, &pClass, wcsNamespace, NO_ERRORS_EXPECTED );
        
        SAFE_RELEASE_PTR(pClass);
        if( nRc == SUCCESS )
        {
            nNumber++;
        }
        else if( nRc == NO_MORE_DATA )
        {
            nRc = SUCCESS;
            break;
        }
        else
        {
            break;
        }
    }

    if( nRc == SUCCESS )
    {
        if( nExpectedResults != -1 ) // means we don't want to compare
        {
            if( nExpectedResults != nNumber )
            {
              gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Enumerated results not as expected for %s.  Expected %ld, received %ld", wcsClass, nExpectedResults, nNumber );
            }
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int QueryAndCompareResults( IWbemServices * pNamespace, WCHAR * wcsQuery, int nResults, WCHAR * wcsNamespace )
{
    IEnumWbemClassObject * pEnum = NULL;

    DWORD dwFlags = WBEM_FLAG_FORWARD_ONLY;
    int nRc = ExecQueryAndLogErrors( pNamespace,&pEnum, wcsQuery, dwFlags, wcsNamespace,NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        nRc = CompareResultsFromEnumeration(pEnum, nResults, wcsQuery, wcsNamespace);
    }
    SAFE_RELEASE_PTR(pEnum);
    return nRc; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int AddMethodParameters(IWbemServices * pNamespace, IWbemClassObject *& pClass, BOOL fOutputParms, CPropertyList & Props, WCHAR * wcsNamespace )
{
    WCHAR * wcsClass= L"__PARAMETERS";

    int nRc = GetClassObjectAndLogErrors(pNamespace, wcsClass, &pClass, wcsNamespace, NO_ERRORS_EXPECTED);
    if( nRc == SUCCESS )
    {
        nRc = FATAL_ERROR;

        for( int i = 0; i < Props.Size(); i++ )
        {                                
            //======================================================
            //  Get the property info
            //======================================================
            PropertyInfo *p = Props.GetAt(i); 
            if( !p )
            {
                break;
            }
            if( wcslen(p->QualifierName) > 0 )
            {
                DWORD dwFlags = 0;
                //======================================================
                //  If it is a qualifier, write the qualifier
                //======================================================
                nRc = PutQualifierOnPropertyAndLogErrors( pClass, p->Property, p->QualifierName ,
                                                          p->Var, wcsClass, dwFlags, wcsNamespace, NO_ERRORS_EXPECTED );
            }
            else
            {
                //======================================================
                //  Write out the property and if it is an input or
                //  output
                //======================================================
                nRc = PutPropertyAndLogErrors( pClass, p->Property, p->Type, p->Var, wcsClass, 0,wcsNamespace, NO_ERRORS_EXPECTED);
            }
            if( nRc != SUCCESS )
            { 
                break;
            }
         }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    //=======================================================
    //  Get the list of the methods to be created
    //=======================================================
    if( InitMasterList(sMethods,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pItemInfo    = MasterList.GetAt(i);
            CHString sObjectPath;
            if( g_Options.GetSpecificOptionForAPITest( pItemInfo->Item, sObjectPath, nWhichTest))
            {
                CHString sClass, sMethod, sInstance;
                CPropertyList InProps, OutProps;
                int nResults = 0;
                nRc = CrackMethod((WCHAR*)(const WCHAR*) sObjectPath,sClass,sInstance,sMethod,InProps,OutProps,nResults,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    IWbemClassObject * pClass = NULL;
                    IWbemClassObject * pInClass = NULL;
                    IWbemClassObject * pOutClass = NULL;

                    nRc = GetClassObjectAndLogErrors(pNamespace, WPTR sClass, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc == SUCCESS )
                    { 
                        if( InProps.Size() > 0 )
                        {
                            nRc = AddMethodParameters(pNamespace, pInClass, FALSE, InProps, wcsNamespace);
                        }
                        if( nRc == SUCCESS )
                        {
                            if( OutProps.Size() > 0 )
                            {
                                nRc = AddMethodParameters(pNamespace, pOutClass, TRUE, OutProps, wcsNamespace);
                            }
                            if( nRc == SUCCESS )
                            {
                                nRc = PutMethodAndLogErrors( pClass, pInClass, pOutClass, WPTR sMethod,
                                                             WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED);
                                if( SUCCESS == nRc )
                                {
                                    nRc = PutClassAndLogErrors(pNamespace, pClass,sClass,wcsNamespace, NO_ERRORS_EXPECTED );
                                }
                            }
                        }
                    }
                    SAFE_RELEASE_PTR(pClass);
                    SAFE_RELEASE_PTR(pInClass);
                    SAFE_RELEASE_PTR(pOutClass);

                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    //=======================================================
    //  Get the list of the methods to be created
    //=======================================================
    if( InitMasterList(sMethods,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pItemInfo    = MasterList.GetAt(i);
            CHString sObjectPath;
            if( g_Options.GetSpecificOptionForAPITest( pItemInfo->Item, sObjectPath, nWhichTest))
            {
                CHString sClass, sMethod, sInstance;
                CPropertyList InProps, OutProps;
                int nResults = 0;
                nRc = CrackMethod((WCHAR*)(const WCHAR*) sObjectPath,sClass,sInstance,sMethod,InProps,OutProps,nResults,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    IWbemClassObject * pClass = NULL;
                    nRc = GetClassObjectAndLogErrors(pNamespace, WPTR sClass, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc == SUCCESS )
                    { 
                         nRc = DeleteMethodAndLogErrors( pClass,WPTR sMethod,WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED);
                    }
                    SAFE_RELEASE_PTR(pClass);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CompareResultsFromMethodEnumeration(IWbemClassObject * pClass, int nResults, WCHAR * wcsClass, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;
    int nNumber = 0;
    ULONG ulNumber = 0;
    
    while(TRUE)
    {
        CBSTR bName;
        IWbemClassObject * pIn = NULL;
        IWbemClassObject * pOut = NULL;

        nRc = NextMethodAndLogErrors( pClass, wcsClass,(BSTR*) &bName, &pIn, &pOut, wcsNamespace, NO_ERRORS_EXPECTED );
        
        SAFE_RELEASE_PTR(pIn);
        SAFE_RELEASE_PTR(pOut);

        if( nRc == SUCCESS )
        {
            nNumber++;
        }
        else if( nRc == NO_MORE_DATA )
        {
            nRc = SUCCESS;
            break;
        }
        else
        {
            break;
        }
    }

    if( nRc == SUCCESS )
    {
        if( nResults != nNumber )
        {
          gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Enumerated methods not as expected.  Expected %ld, received %ld", nResults, nNumber );
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    //=======================================================
    //  Get the list of the methods to be created
    //=======================================================
    if( InitMasterList(sMethods,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pItemInfo    = MasterList.GetAt(i);
            CHString sObjectPath;
            if( g_Options.GetSpecificOptionForAPITest( pItemInfo->Item, sObjectPath, nWhichTest))
            {
                CHString sClass, sMethod,sInst;
                int nResults = 0;
                CPropertyList InProps, OutProps;

                nRc = CrackMethod(WPTR  sObjectPath,sClass,sInst,sMethod,InProps,OutProps, nResults,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    IWbemClassObject * pClass = NULL;
                    nRc = GetClassObjectAndLogErrors(pNamespace, WPTR sClass, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc == SUCCESS )
                    { 
                        nRc = EnumerateMethodAndLogErrors( pClass,WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED);
                        if( SUCCESS == nRc )
                        {
                            nRc = CompareResultsFromMethodEnumeration(pClass,nResults,WPTR sClass, wcsNamespace);
                        }
                    }
                    SAFE_RELEASE_PTR(pClass);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecuteMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    ItemList MasterList;
    //=======================================================
    //  Get the list of the methods to be created
    //=======================================================
    if( InitMasterList(sMethods,MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ItemInfo * pItemInfo    = MasterList.GetAt(i);
            CHString sObjectPath;
            if( g_Options.GetSpecificOptionForAPITest( pItemInfo->Item, sObjectPath, nWhichTest))
            {
                CHString sClass, sMethod, sInstance;
                int nResults = 0;
                CPropertyList InProps, OutProps;

                nRc = CrackMethod(WPTR  sObjectPath,sClass,sInstance, sMethod,InProps, OutProps, nResults,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    IWbemClassObject * pClass = NULL;
                    nRc = GetClassObjectAndLogErrors(pNamespace, WPTR sClass, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc == SUCCESS )
                    { 
                        IWbemClassObject * pIn = NULL;
                        IWbemClassObject * pOut = NULL;

                        nRc = GetMethodAndLogErrors( pClass, WPTR sMethod, &pIn, &pOut, WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED );
                        if( SUCCESS == nRc )
                        {
                            IWbemClassObject * pInInst  = NULL;
                            IWbemClassObject * pOutInst = NULL;

                            if( pIn )
                            {
                                //==============================================================
                                // Spawn a new instance of this class.
                                //==============================================================
                                nRc = SpawnInstanceAndLogErrors(pClass,L"__Parameters",&pInInst,wcsNamespace,NO_ERRORS_EXPECTED);
                                if( SUCCESS == nRc )
                                {
                                    nRc = WritePropertiesAndQualifiers( pNamespace, pInInst, InProps, L"__Parameters", 0, wcsNamespace, NO_ERRORS_EXPECTED );
                                }
                            }
                            else if(pOut)
                            {
                                nRc = SpawnInstanceAndLogErrors(pClass,L"Method Output Class",&pOutInst,wcsNamespace,NO_ERRORS_EXPECTED);
                            }

                            if( nRc == SUCCESS )
                            {
                                if( wcslen( sInstance ) > 0 )
                                {
                                    nRc = ExecuteMethodAndLogErrors( pNamespace, WPTR sMethod, WPTR sInstance, 0, pInInst, &pOutInst,
                                                                 WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED );
                                }
                                else
                                {
                                    nRc = ExecuteMethodAndLogErrors( pNamespace, WPTR sClass, WPTR sInstance, 0, pInInst, &pOutInst,
                                                                 WPTR sClass, wcsNamespace, NO_ERRORS_EXPECTED );

                                }
                            }
                            SAFE_RELEASE_PTR(pInInst);
                            SAFE_RELEASE_PTR(pOutInst);
                        }
                        SAFE_RELEASE_PTR(pIn);
                        SAFE_RELEASE_PTR(pOut);
                    }
                    SAFE_RELEASE_PTR(pClass);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtcom.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_COM_HEADER
#define _BVT_COM_HEADER

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Common functional units used among tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogTestBeginning               (int nWhich,BOOL f);
void LogTestEnding                  (int nWhich,int nRc, BOOL f);

int RunRequestedTests               (int nWhichTest, BOOL fCompareResults);
int RunTests                        (int nWhichTest,BOOL fCompareResults, BOOL fSuppressHeader);
int RunRequestedTestsAndOpenNamespace(int nWhichTest, CHString & sNamespace, IWbemServices ** ppNamespace, BOOL f);
int GetClassDefinitionSection       (int nWhichTest, CHString & sClassDefinitionSection,int & nTest );


int OpenNamespaceAndKeepOpen      ( IWbemServices ** pNamespace, const WCHAR * wcsNamespace, BOOL fCreateIfDoesntExist, BOOL fCompareResults);
int CreateClassesForSpecificTest  ( IWbemServices * pNamespace, WCHAR * wcsNamespace, WCHAR * wcsSection, int nTest);
int CreateClassAndLogErrors       ( IWbemServices * pNamespace, WCHAR * wcsClassDefinition,
                                    WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteClasses                 ( CHString & sDeleteClasses, int nWhichTest, BOOL fCompare,IWbemServices * pNamespace, WCHAR * wcsNamespace);
int GetInstanceAndCompare         ( IWbemServices * pNamespace, DWORD dwFlags, CHString & sInstanceList, 
                                    int nTest,BOOL fCompare, WCHAR * wcsNamespace );
int EnumerateClassesAndCompare    ( CHString & sClassesAfterDelete, int nWhichTest, BOOL fCompare,IWbemServices * pNamespace, WCHAR * wcsNamespace);
int EnumerateInstancesAndCompare( CHString & sInstances, int nWhichTest, BOOL fCompareResults, 
                                  IWbemServices * pNamespace, WCHAR * wcsNamespace);
int AddClasses                    ( CHString & sAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace, int nWhich);
int DeleteAndAddClasses           ( CHString & sDeleteAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace, int nWhich);
int CreateAssociationAndLogErrors ( IWbemServices * pNamespace, const WCHAR * wcsClass, WCHAR * wcsClassDefinition, WCHAR * wcsNamespace );
int CreateInstances               ( IWbemServices * pNamespace, CHString & sInstances, WCHAR * wcsNamespace, int nClassDefinitionSection );
int CreateInstance                ( IWbemServices * pNamespace,WCHAR * wcsInstanceInfo, WCHAR * wcsNamespace);
int CreateInstancesForSpecificTest(IWbemServices * pNamespace,WCHAR * wcsNamespace,WCHAR * wcsSection, int nTest, BOOL fCompare);
int QueryAndCompareResults        ( IWbemServices * pNamespace, WCHAR * wcsQueryString, int nResults, WCHAR * wcsNamespace );
int DeleteInstancesAndCompareResults ( CHString & sDeleteInstances,int nWhichTest,IWbemServices * pNamespace, WCHAR * wcsNamespace);
int GetSpecificObjects           ( CHString & sObjects, IWbemServices * pNamespace, int nWhichTest,WCHAR * wcsNamespace);
int CompareResultsFromEnumeration(IEnumWbemClassObject * pEnum, int nExpectedResults, WCHAR * wcsClass, WCHAR * wcsNamespace);

int CreateMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace );
int DeleteMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace );
int EnumerateMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace );
int ExecuteMethodsAndCompare(CHString & sMethods, IWbemServices * pNamespace, int nWhichTest, BOOL fCompare, WCHAR * wcsNamespace );


BOOL GetDefaultMatch(IniInfo Array[], const WCHAR * wcsKey, int & nWhich , int nMax);
#define BVTVALUE 512


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtini.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  The Ini file class
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CIniFileAndGlobalOptions::CIniFileAndGlobalOptions()
{
    memset( m_wcsFileName,NULL,MAX_PATH+2);
    m_fSpecificTests = FALSE;
    m_nThreads = m_nConnections = 100;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CIniFileAndGlobalOptions::~CIniFileAndGlobalOptions()
{
    DeleteList();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CIniFileAndGlobalOptions::DeleteList()
{    
    CAutoBlock Block(&m_CritSec);
    for( int i = 0; i < m_SpecificTests.Size(); i++ )
    {
        int * pPtr = (int*)m_SpecificTests[i];
        delete pPtr;
    }
    m_SpecificTests.Empty();

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::ReadIniFile( WCHAR * wcsSection, const WCHAR * wcsKey, WCHAR * wcsDefault, 
                                            CHString & sBuffer)
{
    BOOL fRc = FALSE;
    DWORD dwLen = BVTVALUE;

    while( TRUE )
    {
        WCHAR * pTmp = new WCHAR[dwLen];
        if( !pTmp )
        {
            break;
        }

        DWORD dwRc = GetPrivateProfileString(wcsSection, wcsKey, wcsDefault, pTmp, dwLen, m_wcsFileName);
        if (dwRc == 0)
        {
            fRc = FALSE;
        } 
        else if (dwRc < dwLen - sizeof(WCHAR))
        {
            fRc = TRUE;
            sBuffer = pTmp;
            SAFE_DELETE_PTR(pTmp);
            break;
        }
        dwLen += BVTVALUE;
        SAFE_DELETE_PTR(pTmp);
    }
    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetFlags(int nWhichTest, ItemList & MasterList )
{
    CHString sFlags;
    int nRc = FATAL_ERROR;

    if( g_Options.GetSpecificOptionForAPITest(L"FLAGS", sFlags, nWhichTest))
    {
         //=======================================================
         //  Parse the list of flags
         //=======================================================
         if( InitMasterList(sFlags,MasterList))
         {
             for( int i = 0; i < MasterList.Size(); i++ )
             {
                ItemInfo * p = MasterList.GetAt(i);

                if( _wcsicmp(p->Item,L"WBEM_FLAG_KEYS_ONLY") == 0 )
                {
                    p->dwFlags |= WBEM_FLAG_KEYS_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_SHALLOW") == 0 )
                {
                    p->dwFlags |= WBEM_FLAG_SHALLOW;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_DEEP") == 0 )
                {
                    p->dwFlags |= WBEM_FLAG_DEEP;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_REFS_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_REFS_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_SYSTEM_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_SYSTEM_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_NONSYSTEM_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_NONSYSTEM_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_LOCAL_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_LOCAL_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_PROPAGATED_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_PROPAGATED_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_LOCAL_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_LOCAL_ONLY;
                }
                if( _wcsicmp(p->Item,L"WBEM_FLAG_PROPAGATED_ONLY") == 0 )
                { 
                    p->dwFlags |= WBEM_FLAG_PROPAGATED_ONLY;
                }
                nRc = SUCCESS;
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassDefinitionSection(int nWhichTest, CHString & sClassDefinitionSection,int & nTest )
{
    int nRc = FATAL_ERROR;

    if( g_Options.GetSpecificOptionForAPITest(L"DEFINITION_SECTION", sClassDefinitionSection, nWhichTest))
    {
        nTest = _wtoi(sClassDefinitionSection);
        nRc = SUCCESS;
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetDefaultMatch(IniInfo Array[], const WCHAR * wcsKey, int & nWhich , int nMax)
{
    BOOL fRc = FALSE;
  
    for( int i = 0; i < nMax; i++ )
    {
        
        if( _wcsicmp(Array[i].Key, wcsKey ) == 0 )
        {
            nWhich = i;
            fRc = TRUE;
            break;
        }
    }
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtsink.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTSink.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::QueryInterface( REFIID riid, LPVOID * ppvObj  )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if (riid == IID_IWbemObjectSink)
	{
        *ppvObj = (IWbemObjectSink *)this;
	}
    else if (riid == IID_IWbemObjectSinkEx)
	{
		*ppvObj = (IWbemObjectSinkEx *)this;
	}
	else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CSinkEx::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRefCount);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CSinkEx::Release()
{
    Lock();
    if(m_lRefCount <= 0) 
    {
        delete this;
        return 0;
    }

    if (InterlockedDecrement(&m_lRefCount))
    {
        Unlock();
        return 1;
    }

    Unlock();
    delete this;
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::Indicate(  long lObjectCount,  IWbemClassObject ** pObjArray  )
{
    if(lObjectCount == 0) 
        return WBEM_NO_ERROR;

    Lock();

    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        pObj->AddRef();
        m_aObjects.Add(pObj);
    }

    Unlock();
    return WBEM_NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::Set( long lFlags,  REFIID riid,   void *pComObject)
{
	Lock();

	m_pInterfaceID=riid;
	m_pInterface=(IUnknown *)pComObject;

	Unlock();
	return WBEM_NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSinkEx::SetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam)
{
    m_hres = hResult;
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        return WBEM_NO_ERROR;
    }
    m_pErrorObj = pObjParam;

    if(pObjParam)
        pObjParam->AddRef();

    SetEvent(m_hEvent);
    return WBEM_NO_ERROR;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSinkEx::CSinkEx(LONG lStartingRefCount)
{
    m_hres = 0;
    InitializeCriticalSection(&m_cs);
    m_lRefCount = lStartingRefCount;
    m_hEvent = CreateEvent(0, FALSE, FALSE, 0);
    m_pErrorObj = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSinkEx::~CSinkEx()
{
    DeleteCriticalSection(&m_cs);
    CloseHandle(m_hEvent);

    for (int i = 0; i < m_aObjects.Size(); i++)
         ((IWbemClassObject *) m_aObjects[i])->Release();
    if(m_pErrorObj) m_pErrorObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\cmdlineconsumer.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  CmdLineConsumer.cpp
//
// Description:
//	This file defines the class behaviors for the command-line
//	event consumer application.
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "CmdLineConsumer.h"
#include "CmdLineConsumerDlg.h"
#include <objbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp

BEGIN_MESSAGE_MAP(CCmdLineConsumerApp, CWinApp)
	//{{AFX_MSG_MAP(CCmdLineConsumerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp construction

CCmdLineConsumerApp::CCmdLineConsumerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_clsReg = 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCmdLineConsumerApp object

CCmdLineConsumerApp theApp;

// {892C6A1B-266C-4699-96FA-2FF67D647FC8}
static const GUID CLSID_BVTBVTPermConsumer = 
{ 0x892c6a1b, 0x266c, 0x4699, { 0x96, 0xfa, 0x2f, 0xf6, 0x7d, 0x64, 0x7f, 0xc8 } };

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp initialization

BOOL CCmdLineConsumerApp::InitInstance()
{
	HRESULT hRes;
	BOOL regEmpty = FALSE; // did a self-unregister happen?

	// OLE initialization. This is 'lighter' than OleInitialize()
	//  which also setups DnD, etc.
	if(SUCCEEDED(CoInitialize(NULL))) 
	{
		// NOTE: This is needed to work around a security problem
		// when using IWBEMObjectSink. The sink wont normally accept
		// calls when the caller wont identify themselves. This
		// waives that process.
		hRes = CoInitializeSecurity(NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_CONNECT, 
								RPC_C_IMP_LEVEL_IDENTIFY, 
								NULL, 0, 0);
	}
	else // didnt CoInitialize()
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	} // endif OleInitialize()

	// NOTE: To advertise that we can self-register, put 'OLESelfRegister'
	// in the version resource.

	// see if this is a self-Unregister call.
	TCHAR temp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;

	_tcscpy(temp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( temp, seps );
	while( token != NULL )
	{
		/* While there are tokens in "string" */
		if(_tcscmp(token, _T("/UNREGSERVER")) == 0)
		{
			UnregisterServer();
			return FALSE;		// no use doing any more.
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

	// if we got here, the unregister didn't return out and we should
	// make sure we're registered now.
	RegisterServer();

	// creating the dlg earlier than usual so the class factory 
	//	can pass m_outputList.
	CCmdLineConsumerDlg dlg;

	m_factory = new CProviderFactory(&(dlg.m_output));

	if((hRes = CoRegisterClassObject(CLSID_BVTBVTPermConsumer,
							(IUnknown *)m_factory,
							CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
							REGCLS_MULTIPLEUSE,
							&m_clsReg)) == S_OK)
	{
		TRACE(_T("registered\n"));
	}
	else
	{
		TRACE(_T("not registered\n"));
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

//-----------------------------------------------------------
int CCmdLineConsumerApp::ExitInstance()
{
	if(m_clsReg)
	{
		HRESULT hres = CoRevokeClassObject(m_clsReg);

		CoUninitialize();
	}

	return CWinApp::ExitInstance();
}

#define TCHAR_LEN_IN_BYTES(str)	 _tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR)

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
// Note: Key setups are:
//		HKCR\CLSID\[guid]= friendly name
//		HKCR\CLSID\[guid]\LocalServer32 = exe's path.
//		HKCR\CLSID\AppID = [guid]
//		HKCR\AppID\[guid] = friendly name
//		HKCR\AppID\[guid] = 'RunAs' = "Interactive User"
//			'RunAs' is a value name; not a subkey.
//***************************************************************************
void CCmdLineConsumerApp::RegisterServer(void)
{   
	HKEY hKey1, hKey2;

	TCHAR       wcConsID[] = _T("{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    TCHAR       wcCLSID[] = _T("CLSID\\{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    TCHAR       wcAppID[] = _T("AppID\\{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    TCHAR      wcModule[128];	// this will hold the exe's path.
	TCHAR ConsumerTextForm[] = _T("Microsoft Cmd Line Consumer");

	// this will allow the server to display its windows on the active desktop instead
	// of the hidden desktop where services run.
	TCHAR Interactive[] = _T("Interactive User");


	GetModuleFileName(NULL, wcModule,  128);

	//Set the "default" text under CLSID
	//==========================
	RegCreateKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// create the LocalServer32 key so the server can be found.
	RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcModule, TCHAR_LEN_IN_BYTES(wcModule));
	RegSetValueEx(hKey1, _T("AppID"), 0, REG_SZ, (LPBYTE)wcConsID, TCHAR_LEN_IN_BYTES(wcConsID));

	CloseHandle(hKey2);
	CloseHandle(hKey1);

	// now do the AppID keys.
	RegCreateKey(HKEY_CLASSES_ROOT, wcAppID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
					(LPBYTE)ConsumerTextForm, 
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// this makes the local server run on the active desktop (the one you're seeing) 
	// instead of the hidden desktop that services run on (which doesn't have UI)
	RegSetValueEx(hKey1, _T("RunAs"), 0, REG_SZ, (LPBYTE)Interactive, TCHAR_LEN_IN_BYTES(Interactive));
	CloseHandle(hKey1);
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
void CCmdLineConsumerApp::UnregisterServer(void)
{
 
	TCHAR       wcConsID[] = _T("{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    TCHAR       wcCLSID[] = _T("CLSID\\{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    TCHAR       wcAppID[] = _T("AppID\\{892C6A1B-266C-4699-96FA-2FF67D647FC8}");
    HKEY hKey1;
	DWORD dwRet;

	// delete the keys under CLSID\[guid]
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, _T("LocalServer32"));
        CloseHandle(hKey1);
    }

	// delete CLSID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1,wcConsID);
        CloseHandle(hKey1);
    }

	// delete AppID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("AppID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, wcConsID);
        CloseHandle(hKey1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\cmdlineconsumerdlg.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  CmdLineConsumerDlg.cpp
//
// Description:
//			Implementation file for command-line event consumer dialog boxes
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "CmdLineConsumer.h"
#include "CmdLineConsumerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg dialog

CCmdLineConsumerDlg::CCmdLineConsumerDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCmdLineConsumerDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCmdLineConsumerDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CCmdLineConsumerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCmdLineConsumerDlg)
	DDX_Control(pDX, IDC_LIST, m_output);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCmdLineConsumerDlg, CDialog)
	//{{AFX_MSG_MAP(CCmdLineConsumerDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg message handlers

BOOL CCmdLineConsumerDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// this controls the app's main dialog box.
	ShowWindow(SW_MINIMIZE);

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CCmdLineConsumerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CCmdLineConsumerDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CCmdLineConsumerDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtutil.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_UTIL_HEADER
#define _BVT_UTIL_HEADER



/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Class definitions & prototypes
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT AllocateAndConvertAnsiToUnicode( char * pstr, WCHAR *& pszW);
int ExecuteScript                     ( int nTest);
void LogCLSID                         ( const char * csFile, const ULONG Line, WCHAR * wcsID, CLSID clsid);

BOOL InitMasterList                   ( const WCHAR * wcsClassesAfterDelete,ItemList & MasterList);
BOOL InitAndExpandMasterList          ( const WCHAR * wcsClassesString, int nWhichTest, ItemList & MasterList);
BOOL InitMasterListOfAddDeleteClasses ( const WCHAR * wcsClassesAddDelete,int nWhichTest,ItemList & MasterList);
int CrackClassName                    ( const WCHAR * wcsString, CHString & sClass, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int CrackAssociation                  ( const WCHAR * wcsString, CHString & sClass, CPropertyList & Properties, int & n, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int CrackClass                        ( WCHAR * wcsInClassString, CHString & sClass, CHString & sParentClass, CHString & sInstance,
                                        CPropertyList & Properties, int & nResults, BOOL fExpectedFailure,const char * csFile, const ULONG Line );
int CrackEvent                        ( WCHAR * wcsInEventString, EventInfo & Event, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int CrackNamespace                    ( WCHAR * wcsInString, CHString & sNamespace, BOOL fExpectedFailure,const char * csFile, const ULONG Line );
int CrackClassNameAndResults          ( WCHAR * wcsInString, CHString & sClass, ItemList & nResults, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int CrackMethod                       ( WCHAR * wcsInString, CHString & sClass, CHString & sInst, CHString & sMethod,CPropertyList & InProp, CPropertyList & OutProps,
                                        int & nResults, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
BOOL CompareType                      ( CVARIANT & Var1, CVARIANT & Var2,  long lType );

/////////////////////////////////////////////////////////////////////////////////////////////
class CLogAndDisplayOnScreen
{
    protected:
        WCHAR              m_wcsFileName[MAX_PATH+2];
        BOOL               m_fDisplay;
        CCriticalSection   m_CritSec;
        BOOL WriteToFile(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString);

    public:
        CLogAndDisplayOnScreen();
        ~CLogAndDisplayOnScreen();
        
        BOOL LogError(const char * csFile , const ULONG Line , int nErrorType, const WCHAR *fmt, ...);
        virtual BOOL Log(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString) { return FALSE;}

        inline void SetDisplay(BOOL fDisplay)       { CAutoBlock Block(&m_CritSec); m_fDisplay = fDisplay;}
        inline void SetFileName(WCHAR * wcsFile  )  { CAutoBlock Block(&m_CritSec); wcsncpy( m_wcsFileName, wcsFile, MAX_PATH); }
};
/////////////////////////////////////////////////////////////////////////////////////////////
class CIniFileAndGlobalOptions
{
    private:
        WCHAR              m_wcsFileName[MAX_PATH+2];
        CCriticalSection   m_CritSec;
        CFlexArray         m_SpecificTests;
        BOOL               m_fSpecificTests;
        int                m_nThreads;
        int                m_nConnections;

        BOOL ReadIniFile( WCHAR * wcsSection, const WCHAR * wcsKey, WCHAR * wcsDefault, CHString & sBuffer);
        void DeleteList();
        
    public:

        CIniFileAndGlobalOptions();
        ~CIniFileAndGlobalOptions();

        BOOL GetSpecificOptionForAPITest(const WCHAR * wcsClass, CHString & sClass, int nTest);

        void WriteDefaultIniFile();

        inline void AddToSpecificTestList(int nTest)        { int * p = new int; *p = nTest; m_SpecificTests.Add(p); }
        inline int  SpecificTestSize()                      { return m_SpecificTests.Size(); }
        inline int  GetSpecificTest(int n)                  { int * p = (int*) m_SpecificTests.GetAt(n); return *p;}
        inline void SpecificTests(BOOL f)                   { m_fSpecificTests = f;}
        inline BOOL RunSpecificTests()                      { return m_fSpecificTests;}

        inline void SetFileName(WCHAR * wcsFile  )          { CAutoBlock Block(&m_CritSec); wcsncpy( m_wcsFileName, wcsFile, MAX_PATH); }
        inline void SetThreads(int nThreads)                { m_nThreads = nThreads;}
        inline void SetConnections(int nConn)               { m_nConnections = nConn;}
        inline int  GetThreads()                            { return m_nThreads;}
        inline int  GetConnections()                        { return m_nConnections;}

};

class CSinkEx : public IWbemObjectSinkEx
{
    CFlexArray m_aObjects;
    LONG m_lRefCount;
    CRITICAL_SECTION m_cs;
    HANDLE m_hEvent;
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;
	IID m_pInterfaceID;
	IUnknown *m_pInterface;

public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hResult, BSTR strParam,   IWbemClassObject* pObjPAram);

	STDMETHOD(Set)(long lFlags, REFIID riid, void *pComObject);

    // Private to implementation.
    // ==========================

    CSinkEx(LONG lStartingRefCount = 1);
   ~CSinkEx();

    UINT WaitForSignal(DWORD dwMSec)    { return ::WbemWaitForSingleObject(m_hEvent, dwMSec); }
    CFlexArray* GetObjectArray()        { return &m_aObjects; }
    int GetNumberOfObjectsReceived()    { return m_aObjects.Size();}
 
	IUnknown *GetInterface()            { return m_pInterface; }
    HRESULT GetStatusCode(IWbemClassObject** ppErrorObj = NULL)
    {
        if(ppErrorObj) 
        {
            *ppErrorObj = m_pErrorObj;
            if(m_pErrorObj) m_pErrorObj->AddRef();
        }
        return m_hres;
    }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\cmdlineconsumer.h ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  CmdLineConsumer.h
//
// Description:
//			main header file for the CMDLINECONSUMER application
//
// History:
//
// **************************************************************************

#if !defined(AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "factory.h"

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerApp:
// See CmdLineConsumer.cpp for the implementation of this class
//

class CCmdLineConsumerApp : public CWinApp
{
public:
	CCmdLineConsumerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCmdLineConsumerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCmdLineConsumerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int ExitInstance();

private:
	DWORD m_clsReg;
	CProviderFactory *m_factory;

	void RegisterServer(void);
	void UnregisterServer(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMDLINECONSUMER_H__EF85AEB7_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvtutil.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
_CPropertyList::~_CPropertyList()
{  
    for( int i = 0; i < m_List.Size(); i++ )
    {
        PropertyInfo * pPtr = (PropertyInfo*)m_List[i];
        delete pPtr;
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _CPropertyList::PropertiesCompareAsExpectedAndLogErrors( WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                                             BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = SUCCESS;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        PropertyInfo * pPtr = (PropertyInfo*)m_List[i];
        if( !pPtr->fProcessed )
        {
            if( pPtr->QualifierName  && pPtr->Property)
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Expected Property Qualifier %s on Property %s in class %s in namespace %s - but it wasn't there",pPtr->QualifierName, pPtr->Property, wcsClass, wcsNamespace);
            }
            else if( pPtr->Property )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Expected property %s in class in namespace %s - but it wasn't there",pPtr->Property, wcsClass, wcsNamespace);
            }
            else
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Expected property ??? in class in namespace %s - but it wasn't there",wcsClass, wcsNamespace);
            }

            nRc = FATAL_ERROR;
            break;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _CPropertyList::PropertyInListAndLogErrors(PropertyInfo * pProp, WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                               BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = FATAL_ERROR;
    BOOL fLogged = FALSE;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        PropertyInfo * pPtr = (PropertyInfo*)m_List[i];

        BOOL fContinue = FALSE;
        if( pPtr->Property )
        {
            if( _wcsicmp( pPtr->Property, pProp->Property )  == 0 )
            {
                fContinue = TRUE;
            }
        }
        else if( pPtr->QualifierName)
        {
            if( _wcsicmp( pPtr->QualifierName, pProp->QualifierName )  == 0 )
            {
                fContinue = TRUE;
            }
        }
        if( fContinue )
        {
            if( pPtr->Type == pProp->Type )
            {
                if( CompareType(pPtr->Var,pProp->Var,pProp->Type) )
                {
                    if( !pPtr->fProcessed )
                    {
                        nRc = SUCCESS;
                        pPtr->fProcessed = TRUE;
                    }
                    else
                    {
                        if( !fExpectedFailure )
                        {
                            if( pPtr->QualifierName && pPtr->Property )
                            {
                                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Property Qualifier %s for Property %s for Class %s for Namespace %s, showed up in the list twice.", pPtr->QualifierName, pPtr->Property, wcsClass, wcsNamespace);
                            }
                            else if( pPtr->Property )
                            {
                                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Property showed up in the list twice.  Property %s in Class %s in namespace %s", pPtr->Property, wcsClass, wcsNamespace);
                            }
                            else
                            {
                                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Property ???? showed up in the list twice. Property ??? for Class %s in namespace %s", wcsClass, wcsNamespace);
                            }
                            fLogged = TRUE;
                        }
                    }
                    break;
                }
            }
        }
    }

    if( nRc == FATAL_ERROR )
    {
        if( !fExpectedFailure )
        {
            if( !fLogged )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Did not find expected properties in class %s in namespace %s", wcsClass, wcsNamespace);
            }
        }
    }
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
_ItemList::~_ItemList()
{  
    for( int i = 0; i < m_List.Size(); i++ )
    {
        ItemInfo * pPtr = (ItemInfo*)m_List[i];
        delete pPtr;
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _ItemList::ItemsCompareAsExpectedAndLogErrors(WCHAR * wcsNamespace, 
                                                     BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = SUCCESS;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        ItemInfo * pPtr = (ItemInfo*)m_List[i];
        if( !pPtr->fProcessed )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Expected class not in namespace. Class %s in namespace %s",pPtr->Item, wcsNamespace);
            nRc = FATAL_ERROR;
            break;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _ItemList::ItemInListAndLogErrors(WCHAR * wcsClass, WCHAR * wcsNamespace, 
                            BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = FATAL_ERROR;
    BOOL fLogged = FALSE;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        ItemInfo * pPtr = (ItemInfo*)m_List[i];
        if( _wcsicmp(pPtr->Item,wcsClass ) == 0 )
        {
            if( !pPtr->fProcessed )
            {
                nRc = SUCCESS;
                pPtr->fProcessed = TRUE;
            }
            else
            {
                if( !fExpectedFailure )
                {
                    gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Class showed up in the list twice.  Class %s in namespace %s", wcsClass, wcsNamespace);
                    fLogged = TRUE;
                }
            }
            break;
        }
    }

    if( nRc == FATAL_ERROR )
    {
        if( !fExpectedFailure )
        {
            if( !fLogged )
            {
                gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Did not find expected class %s in namespace %s", wcsClass, wcsNamespace);
            }
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  The error logging and display class
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CLogAndDisplayOnScreen::CLogAndDisplayOnScreen()
{
    memset( m_wcsFileName,NULL,MAX_PATH+2);
    m_fDisplay = TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CLogAndDisplayOnScreen::~CLogAndDisplayOnScreen()
{

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLogAndDisplayOnScreen::WriteToFile(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString)
{
    BOOL fRc = FALSE;
    //===========================================
    // Get time.
    //===========================================
    WCHAR wcsTime[MAX_PATH];

    memset(wcsTime,NULL,MAX_PATH);

    time_t now = time(0);
    struct tm *local = localtime(&now);
    if(local)
    {
        wcscpy(wcsTime, _wasctime(local));
    }
    else
    {
        wcscpy(wcsTime,L"??");
    }

    //===========================================
    //  Open the file and log the error
    //===========================================
    FILE * fp = _wfopen( m_wcsFileName, L"at");
    if (fp)
    {
        fwprintf(fp, L"(%s) : %s - [%s]\n %s", wcsTime,pwcsError,pwcsFileAndLine, wcsString);
        fRc = TRUE;
        fclose(fp);
    }
    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLogAndDisplayOnScreen::LogError(const char * csFile , const ULONG Line , int nErrorType, const WCHAR *fmt, ...)
{
    BOOL fRc = FALSE;
    CHString Buffer;
    CHString FileAndLine;
    WCHAR * pwcsWarning = L"WARNING";
    WCHAR * pwcsFatal = L"FATAL";
    WCHAR * pwcsSuccess = L"SUCCESS";
    WCHAR * pwcsError = NULL;
    WCHAR * pwcsFile = NULL;

    CAutoBlock block(&m_CritSec);

    //==================================================
    //  First of all, allocate and format the strings 
    //  Get the type of error
    //==================================================
    if( nErrorType == FATAL_ERROR )
    {
        pwcsError = pwcsFatal;
    }
    else if( nErrorType == WARNING )
    {
        pwcsError = pwcsWarning;
    }
    else
    {
        pwcsError = pwcsSuccess;
    }

    if( S_OK == AllocateAndConvertAnsiToUnicode((char *)(const char*)csFile, pwcsFile))
    {
        if( FileAndLine.GetBuffer(wcslen(pwcsFile)+25))
        {
            //==============================================
            //  Create the filename and line number string
            //==============================================
            FileAndLine.Format(L"File:%s,Line: %d",pwcsFile,Line);
            if( Buffer.GetBuffer(2048) )
            {
                va_list argptr;
                int cnt = 0;
                WCHAR * wcsPtr  = (WCHAR*)((const WCHAR*)Buffer);
                va_start(argptr, fmt);

                cnt = _vsnwprintf(wcsPtr , 2047, fmt, argptr);
                va_end(argptr);

                //==============================================
                //  a -1 indicates that the buffer was exceeded
                //==============================================
                if( cnt != -1 )
                {
                    fRc = Log(pwcsError, (WCHAR*)((const WCHAR*)FileAndLine),(WCHAR*)((const WCHAR*) Buffer));
                }
            }
        }
    }

    if( !fRc )
    {
       wprintf(L"Major error, BVT cannot run\n");
    }

    SAFE_DELETE_ARRAY(pwcsFile);
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  Misc. Functions
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    HRESULT hr = WBEM_E_FAILED;
    pszW = NULL;

    int nSize = strlen(pstr);
    if (nSize != 0 ){

        // Determine number of wide characters to be allocated for the
        // Unicode string.
        nSize++;
		pszW = new WCHAR[nSize * 2];
		if (NULL != pszW)
        {
            // Covert to Unicode.
			MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize);
            hr = S_OK;
		}
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ConvertType( CVARIANT & Var, long & lType, const WCHAR * wcsType, WCHAR * wcsValue )
{
    int nRc = SUCCESS;

    if (_wcsicmp(L"CIM_UINT8",wcsType) == 0 )
    {
        lType = CIM_UINT8;
        Var.SetByte((BYTE)_wtoi(wcsValue));  
    }
    else if (_wcsicmp(L"CIM_SINT8",wcsType) == 0 )
    {
        lType = CIM_SINT8;
        Var.SetByte((BYTE)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_BOOLEAN",wcsType) == 0 )
    {   
        lType = CIM_BOOLEAN;
        Var.SetBool((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_CHAR16",wcsType) == 0 )
    {   
        lType = CIM_CHAR16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_SINT16",wcsType) == 0 )
    {   
        lType = CIM_SINT16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_UINT16",wcsType) == 0 )
    {   
        lType = CIM_UINT16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_REAL32",wcsType) == 0 )
    {   
          lType = CIM_REAL32;

//        Var.SetLONG(_wtof(wcsValue));
    }
    else if( _wcsicmp(L"CIM_SINT32",wcsType) == 0 )
    {   
        lType = CIM_SINT32;
        Var.SetLONG(_wtol(wcsValue));
    }
    else if( _wcsicmp(L"CIM_UINT32",wcsType) == 0 )
    {   
        lType = CIM_UINT32;
        Var.SetLONG(_wtol(wcsValue));
    }
    else if( _wcsicmp(L"CIM_SINT64",wcsType) == 0 )
    {   
        lType = CIM_SINT64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_UINT64",wcsType) == 0 )
    {   
        lType = CIM_UINT64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_REAL64",wcsType) == 0 )
    {   
        lType = CIM_REAL64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_DATETIME",wcsType) == 0 )
    {   
        lType = CIM_DATETIME;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_STRING",wcsType) == 0 )
    {   
        lType = CIM_STRING;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_STRING|CIM_FLAG_ARRAY",wcsType) == 0 )
    {   
        lType = CIM_STRING|CIM_FLAG_ARRAY;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_REFERENCE",wcsType) == 0 )
    {   
        lType = CIM_REFERENCE;
        Var.SetStr(wcsValue);
    }
    else
    {
        nRc = FATAL_ERROR;
    }
        
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CompareType( CVARIANT & Var1, CVARIANT & Var2,  long lType )
{
    BOOL fRc = FALSE;

    switch( lType )
    {  
        case CIM_UINT8:
        case CIM_SINT8:
            if( Var1.GetByte() == Var2.GetByte() )
            {
                fRc = TRUE;
            }
            break;

        case CIM_BOOLEAN:
            if( Var1.GetBool() == Var2.GetBool() )
            {
                fRc = TRUE;
            }
            break;

        case CIM_CHAR16:
        case CIM_SINT16:
        case CIM_UINT16:
            if( Var1.GetShort() == Var2.GetShort() )
            {
                fRc = TRUE;
            }
            break;
    
        case CIM_SINT32:
        case CIM_UINT32:
            if( Var1.GetLONG() == Var2.GetLONG() )
            {
                fRc = TRUE;
            }
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_REAL64:
        case CIM_DATETIME:
        case CIM_STRING:
        case CIM_REFERENCE:
            if( _wcsicmp(Var1.GetStr(), Var2.GetStr()) == 0 )
            {
                fRc = TRUE;
            }
            break;
    }
          
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL GetAndCrackClassName(WCHAR * wcsKey, int nWhichTest, BOOL fAction, ItemList & MasterList)
{
   CHString sClassDefinition;
   BOOL fRc = FALSE;
   int nTest = 0;
   CHString sClassDefinitionSection;
   if( SUCCESS == GetClassDefinitionSection(nWhichTest, sClassDefinitionSection,nTest ))
   {
        //==========================================================
        //  Now, use the new test section we just got where the 
        //  definition lives.
        //==========================================================
        if( g_Options.GetSpecificOptionForAPITest(wcsKey, sClassDefinition,nTest))
        {
            CHString sClass;
            //===========================================================
            //  Get the class name
            //===========================================================
            int nRc = CrackClassName(sClassDefinition,sClass, NO_ERRORS_EXPECTED);
            if( SUCCESS == nRc )
            {   
                ItemInfo *p = new ItemInfo;
                if( p )
                {
                    p->fAction = fAction;
                    p->Item = sClass;
                    p->KeyName = wcsKey;
                    MasterList.Add(p);
                    fRc = TRUE;
                }
            }
            else
            {
                fRc = FALSE;
            }
        }
   }
   return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//  "Delete:TestClass2, Delete:TestClass9, Add:TestClass2, Delete: TestClass7, Delete: TestClass6"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitMasterListOfAddDeleteClasses(const WCHAR * wcsString,int nWhichTest, ItemList & MasterList)
{
    BOOL fRc = FALSE;
    WCHAR * wcsClassesAddDelete = (WCHAR*) wcsString;

    WCHAR * wcsToken = wcstok( wcsClassesAddDelete,L":, ");
    ItemList TempList;

    //==============================================================
    // Start looping through all of the classes
    //==============================================================
    while( wcsToken )
    {
        fRc = FALSE;
        BOOL fAction;
        //==========================================================
        //  If it is a class to be deleted
        //==========================================================
        if( _wcsicmp(L"Delete",wcsToken ) == 0 )
        {
            fAction = DELETE_CLASS;
        }
        else
        {
            fAction = ADD_CLASS;
        }
        wcsToken = wcstok( NULL, L":, ");         
        if( !wcsToken )
        {
            break;
        }
        ItemInfo *p = new ItemInfo;
        if( p )
        {
            p->fAction = fAction;
            p->Item = wcsToken;
            TempList.Add(p);
            fRc = TRUE;
        }
        wcsToken = wcstok( NULL, L",: ");         
    }

    if( fRc )
    {
        //==============================================================
        // Start looping through all of the classes
        //==============================================================
        for( int i = 0; i < TempList.Size(); i++ )
        {
            ItemInfo * pClass = TempList.GetAt(i);
            fRc = GetAndCrackClassName(WPTR pClass->Item,nWhichTest,pClass->fAction,MasterList);
            if( !fRc )
            {
                break;
            }
        }
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//    { "TestClass1,TestClass3" },
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitAndExpandMasterList(const WCHAR * wcsClassesString, int nWhichTest, ItemList & MasterList)
{
    BOOL fRc = FALSE;

    ItemList TempList;
    if( InitMasterList(wcsClassesString,TempList))
    {
        //==============================================================
        // Start looping through all of the classes
        //==============================================================
        for( int i = 0; i < TempList.Size(); i++ )
        {
            ItemInfo * pClass = TempList.GetAt(i);
            fRc = GetAndCrackClassName(WPTR pClass->Item,nWhichTest,0,MasterList);
            if( !fRc )
            {
                break;
            }
        }
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//    { "TestClass1,TestClass3" },
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitMasterList(const WCHAR * wcsClassesString,ItemList & MasterList)
{
    BOOL fRc = FALSE;

    WCHAR * wcsClassesAfterDelete = (WCHAR*) wcsClassesString;
    WCHAR * wcsToken = wcstok( wcsClassesAfterDelete,L", ");
    //==============================================================
    // Start looping through all of the classes
    //==============================================================
    while( wcsToken )
    {
        fRc = FALSE;

        ItemInfo *p = new ItemInfo;
        if( !p )
        {
            break;
        }
        p->Item = wcsToken;

        MasterList.Add(p);
        fRc = TRUE;        

        wcsToken = wcstok( NULL, L",: ");         
    }

    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Just get the class name
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackClassName( const WCHAR * wcsString, CHString & sClass, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = FATAL_ERROR;
    WCHAR wcsSeps[] = L":, ";

    //=================================================================
    // Set it on the first property before looping
    //=================================================================
    WCHAR * wcsClassString = (WCHAR *)wcsString;
    WCHAR * wcsToken = wcstok( wcsClassString,wcsSeps);

    //==============================================================
    // Just get the class
    //==============================================================
    while(wcsToken )
    {
        if( ( _wcsicmp(wcsToken, L"Class") == 0 ))
        {
            wcsToken = wcstok( NULL,wcsSeps);         
            if( wcsToken )
            {
                sClass = wcsToken;
                nRc = SUCCESS;
            }
            break;
        }
        wcsToken = wcstok( NULL,wcsSeps);         
    }
    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack the class name for this string: %s", wcsClassString );
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   Property:FirstPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test1, Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test2
//   PropertyQualifier:QualifierName:PropertyName:KeyName3:CIM_SINT32:3,      Property:PropertyName3:CIM_UINT32:3,   Property:PropertyName3B:CIM_STRING:Test" },
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackProperties( WCHAR * wcsToken, CPropertyList & Properties, CHString & sClass, CHString & sParent, CHString & sInstance, int & Results )
{
    int nRc = SUCCESS;
    WCHAR wcsSeps[] = L":, ";

    //==============================================================
    // Process all of the properties and qualifiers
    //==============================================================
    while( wcsToken )
    {
        nRc = FATAL_ERROR;

        //==========================================================
        //  Find out if it is the parent class or instance name or
        //  class
        //==========================================================
        if( ( _wcsicmp(wcsToken, L"Parent") == 0 ))
        {
            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            sParent = wcsToken;
            nRc = SUCCESS;
        }
        else if( ( _wcsicmp(wcsToken, L"InstanceName") == 0 ))
        {
            wcsToken = wcstok( NULL,L"$");         
            if( !wcsToken )
            {
                break;
            }
            sInstance = wcsToken;
            //=======================================================
            //  Now, strip out the end of the instance name
            //=======================================================
            wcsToken = wcstok( NULL,wcsSeps);         
            nRc = SUCCESS;
        }
        else if( ( _wcsicmp(wcsToken, L"Class") == 0 ))
        {
            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            sClass = wcsToken;
            nRc = SUCCESS;
        }
        else if( ( _wcsicmp(wcsToken, L"RESULTS") == 0 ))
        {
            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            Results = _wtoi(wcsToken);
            nRc = SUCCESS;
        }
        else
        {
            PropertyInfo *p = new PropertyInfo;
            if( !p )
            {
                break;
            }

            //==========================================================
            //  Find out if it is a key     
            //==========================================================
            if( ( _wcsicmp(wcsToken, L"PropertyQualifier") == 0 ))
            {
                //==================================================
                //  If it is a qualifier, get the qualifier name
                //==================================================
                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                p->QualifierName = wcsToken;
            }

            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            //==========================================================
            //  Get the name of the property
            //==========================================================
            p->Property = wcsToken;
            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            //==========================================================
            //  Get the type of the property or qualifier
            //==========================================================
            WCHAR * wcsType = wcsToken;

            wcsToken = wcstok( NULL,L",");  //note, now go to the next comma, as some string values may have embedded :  
            if( !wcsToken )
            {
                break;
            }

            //==========================================================
            //  Get the value
            //==========================================================
            nRc = ConvertType(p->Var, p->Type, wcsType, wcsToken );
            if( nRc == SUCCESS )
            {
                Properties.Add(p);
            }
        }
        wcsToken = wcstok( NULL,wcsSeps);         

        if( nRc != SUCCESS )
        {
            break;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  ( Note, there can be more than one key and more than one property )
//
//   "Property:FirstPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test1, Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test2
//   "AssocProp1:Prop1:TestClass3, Prop2:AssocProp2:TestClass4" 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackAssociation( const WCHAR * wcsString, CHString & sClass, CPropertyList & Properties, int & nResults, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;
    WCHAR wcsSeps[] = L":, ";

    //=================================================================
    // Set it on the first property before looping
    //=================================================================
    WCHAR * wcsClassString = (WCHAR *)wcsString;
    WCHAR * wcsToken = wcstok( wcsClassString,wcsSeps);
    CHString sParent;
    CHString sInstance;

    nRc = CrackProperties(wcsToken, Properties, sClass, sParent, sInstance, nResults );

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack the association info for this string: %s", wcsClassString );
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//
//  L"CLASS:TestClass1, RESULTS:5"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackClassNameAndResults(WCHAR * wcsInString, CHString & sClass, ItemList & Results, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = FATAL_ERROR;

    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsInString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {
        nRc = SUCCESS;

        while( wcsToken )
        {
            //==============================================================
            //  See if we are dealing with CLASS or RESULTS
            //==============================================================
            if( ( _wcsicmp(wcsToken, L"CLASS") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                sClass = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"RESULTS") == 0 ))
            {
                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                ItemInfo * p = new ItemInfo;
                if( p )
                {
                    p->Results = _wtoi(wcsToken);
                    Results.Add(p);
                    nRc = SUCCESS;
                }
            }
            else
            {
                nRc = FATAL_ERROR;
                break;
            }
            //==============================================================
            //  Get the next string
            //==============================================================
            wcsToken = wcstok( NULL, wcsSeps);
        }            
    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack Class and Results info for this string: %s", wcsInString );
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//
//    { L"1",   L"CLASS:TestClass1, METHOD:TestMethd,  INPUT:Property:InputArg1:CIM_UINT32:555, OUTPUT:Property:OutputArg1:CIM_UINT32:111"}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackMethod(WCHAR * wcsInString, CHString & sClass, CHString & sInst, CHString & sMethod,CPropertyList & InProps,
                CPropertyList & OutProps,int & nResults, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{

    int nRc = FATAL_ERROR;

    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsInString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {
        nRc = SUCCESS;

        while( wcsToken )
        {
            //==============================================================
            //  See if we are dealing with CLASS, METHOD, INPUT_CLASS
            //  OUTPUT_CLASS
            //==============================================================
            if( ( _wcsicmp(wcsToken, L"CLASS") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                sClass = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"InstanceName") == 0 ))
            {
                wcsToken = wcstok( NULL,L"$");         
                if( !wcsToken )
                {
                    break;
                }
                sInst = wcsToken;
                //=======================================================
                //  Now, strip out the end of the instance name
                //=======================================================
                wcsToken = wcstok( NULL,wcsSeps);         
                nRc = SUCCESS;
            }
            else if( ( _wcsicmp(wcsToken, L"RESULTS") == 0 ))
            {
                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                nResults = _wtoi(wcsToken);
                nRc = SUCCESS;
            }
            else if( ( _wcsicmp(wcsToken, L"METHOD") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                sMethod = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"INPUT") == 0 ) || ( _wcsicmp(wcsToken, L"OUTPUT") == 0 )) 
            {
                PropertyInfo *p = new PropertyInfo;
                if( !p )
                {
                    break;
                }

                BOOL fOutput = FALSE;
                if( _wcsicmp(wcsToken, L"OUTPUT") == 0 )
                {
                    fOutput = TRUE;
                }

                //==========================================================
                //  Find out if it is a qualifier
                //==========================================================

                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                if( ( _wcsicmp(wcsToken, L"PropertyQualifier") == 0 ))
                {
                    //==================================================
                    //  If it is a qualifier, get the qualifier name
                    //==================================================
                    wcsToken = wcstok( NULL,wcsSeps);         
                    if( !wcsToken )
                    {
                        break;
                    }
                    p->QualifierName = wcsToken;
                }
               //==========================================================
                //  Get the name of the property
                //==========================================================
                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                p->Property = wcsToken;
                //==========================================================
                //  Get the type of the property or qualifier
                //==========================================================
                wcsToken = wcstok( NULL,wcsSeps);         
                if( !wcsToken )
                {
                    break;
                }
                WCHAR * wcsType = wcsToken;
                //==========================================================
                //  Get the value
                //==========================================================
                wcsToken = wcstok( NULL,L" ,");  //note, now go to the next comma, as some string values may have embedded :  
                if( !wcsToken )
                {
                    break;
                }
                nRc = ConvertType(p->Var, p->Type, wcsType, wcsToken );
                if( nRc == SUCCESS )
                {
                    if( fOutput )
                    {
                        OutProps.Add(p);
                    }
                    else
                    {
                        InProps.Add(p);
                    }
                }
            }
            else
            {
                nRc = FATAL_ERROR;
                break;
            }
            //==============================================================
            //  Get the next string
            //==============================================================
            wcsToken = wcstok( NULL, wcsSeps);
        }            
    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack Method info for this string: %s", wcsInString );
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//
//    { L"NAMESPACE_CREATION",   L"LANGUAGE:WQL, QUERY:select * from __NamespaceCreationEvent, TYPE:NAMESPACE, EXECUTE_SECTION: APITEST4, RESULTS:4,NAMESPACE:ROOT"}
//    { L"INSTANCE_CREATION",    L"LANGUAGE:WQL, QUERY:select * from __InstanceCreationEvent,  TYPE:INSTANCE,  EXECUTE_SECTION: APITEST9, RESULTS:4,NAMESPACE:ROOT},
//    { L"CLASS_CREATION",       L"LANGUAGE:WQL, QUERY:select * from __ClassCreationEvent,     TYPE:CLASS,     EXECUTE_SECTION: APITEST5, RESULTS:4,NAMESPACE:ROOT}};
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackEvent(WCHAR * wcsInEventString, EventInfo & Event, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{

    int nRc = FATAL_ERROR;

    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsInEventString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {
        nRc = SUCCESS;

        while( wcsToken )
        {
            //==============================================================
            //  See if we are dealing with LANGUAGE, QUERY, TYPE or 
            //  EXECUTE_SECTION
            //==============================================================
            if( ( _wcsicmp(wcsToken, L"LANGUAGE") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                Event.Language = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"QUERY") == 0 )) 
            {
                wcsToken = wcstok( NULL,L"\"");
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }

                Event.Query = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"EXECUTE_SECTION") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                Event.Section = _wtoi(wcsToken);
            }
            else if( ( _wcsicmp(wcsToken, L"NAMESPACE") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                Event.Namespace = wcsToken;
            }
            else if( ( _wcsicmp(wcsToken, L"RESULTS") == 0 )) 
            {
                wcsToken = wcstok( NULL, wcsSeps);
                if( !wcsToken )
                {
                    nRc = FATAL_ERROR;
                    break;
                }
                Event.Results = _wtoi(wcsToken);
            }
            else
            {
                nRc = FATAL_ERROR;
                break;
            }
            //==============================================================
            //  Get the next string
            //==============================================================
            wcsToken = wcstok( NULL, wcsSeps);
        }            
    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack Event info for this string: %s", wcsInEventString );
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//
//   L"NAMESPACE:ROOT\\WMI"},
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackNamespace(WCHAR * wcsInString, CHString & sNamespace, BOOL fExpectedFailure,const char * csFile, const ULONG Line )
{
    int nRc = FATAL_ERROR;

    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsInString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {
        if( ( _wcsicmp(wcsToken, L"NAMESPACE") == 0 )) 
        {
            wcsToken = wcstok( NULL, wcsSeps);
            if( wcsToken )
            {
                sNamespace = wcsToken;
                nRc = SUCCESS;
            }
        }
    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack namespace info for this string: %s", wcsInString );
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  ( Note, there can be more than one key and more than one property )
//
// TestClass10= "Parent:TestClass9,Key:KeyName10:CIM_UINT32:10,    Property:PropertyName10:CIM_BOOLEAN:0"
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackClass(WCHAR * wcsInClassString, CHString & sClass, CHString & sParentClass, CHString & sInstance,
               CPropertyList & Properties, int & nResults, BOOL fExpectedFailure,const char * csFile, const ULONG Line )
{
    int nRc = FATAL_ERROR;

    WCHAR * wcsClassString = wcsInClassString;
    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsClassString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {
        nRc = CrackProperties(wcsToken, Properties, sClass, sParentClass, sInstance, nResults );
    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            gp_LogFile->LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack class info for this string: %s", wcsClassString );
        }
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogCLSID(const char * csFile, const ULONG Line, WCHAR * wcsID, CLSID clsid)
{
	LPOLESTR pStr = NULL;

	if (SUCCEEDED(StringFromCLSID (clsid, &pStr)))
	{
        WCHAR wcsBuffer[MAX_PATH];
        wsprintf(wcsBuffer,L"%s:%s",wcsID,pStr);
        gp_LogFile->LogError(csFile,Line,FATAL_ERROR, wcsBuffer );
		CoTaskMemFree (pStr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\consumer.h ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  Consumer.h
//
// Description:
//			Command-line event consumer class definition
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>


class CCriticalSection 
{
    public:		
        CCriticalSection()          {  Init(); }

        ~CCriticalSection() 	    {  Delete(); }
        inline void Init()          {  InitializeCriticalSection(&m_criticalsection);   }
        inline void Delete()        {  DeleteCriticalSection(&m_criticalsection); }
        inline void Enter()         {  EnterCriticalSection(&m_criticalsection); }
        inline void Leave()         {  LeaveCriticalSection(&m_criticalsection); }

    private:

	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};  

/////////////////////////////////////////////////////////////////////////////////////////////
class CAutoBlock
{
    private:

	    CCriticalSection *m_pCriticalSection;

    public:

        CAutoBlock(CCriticalSection *pCriticalSection)
        {
	        m_pCriticalSection = NULL;
	        if(pCriticalSection)
            {
		        pCriticalSection->Enter();
            }
	        m_pCriticalSection = pCriticalSection;
        }

        ~CAutoBlock()
        {
	        if(m_pCriticalSection)
		        m_pCriticalSection->Leave();

        }
};


class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer(CListBox	*pOutputList);
	~CConsumer();
    int AddEventToFile(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// This routine ultimately receives the event.
    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:

	DWORD m_cRef;
	LPCTSTR ErrorString(HRESULT hRes);
	CListBox	*m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\consumer.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  Consumer.cpp
//
// Description:
//			Event consumer class implementation
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Consumer.h"
#include <objbase.h>

DWORD m_nEvents = 0;
CCriticalSection m_CriticalSection;
CConsumer::CConsumer(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CConsumer::~CConsumer()
{
}

STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CConsumer::AddEventToFile(void)
{
    int nRc = -1;
    
    CAutoBlock((CCriticalSection *)&m_CriticalSection);
	//==========================
    // Write it to the registry
	//==========================
	TCHAR Bvt[]  = _T("SOFTWARE\\BVT");
	TCHAR Perm[] = _T("PermEvents");
    HKEY hKey;

	if( ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,Bvt, &hKey))
    {
        DWORD dwType = 0;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwNumber = 0;
        if( ERROR_SUCCESS == RegQueryValueEx( hKey, Perm, 0, &dwType,(LPBYTE) &dwNumber, &dwSize))
        {
            if( dwNumber == 0 )
            {
                m_nEvents = 0;
            }
        }
        m_nEvents++;
	    if( ERROR_SUCCESS == RegSetValueEx(hKey, Perm, 0, REG_DWORD,(LPBYTE) &m_nEvents, sizeof(REG_DWORD)))
        { 
            nRc = 0;
        }
        RegCloseKey(hKey);
    }

    return nRc;
}

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
/* for easy reference.
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
*/

	// NOTE: If this routine returns a failure code, including 
	// GPFs from called routines, CIMOM will recreate the object 
	// and call here again. If you see this routine being called 
	// twice for every indication, it means this routine is 
	// returning a failure code somehow. Especially watch the 
	// AddRef()/Release() semantics for the embedded object.
	// If they're too low, you'll return a GPF.
	CString clMyBuff;
	BSTR tgtProp = NULL;
	BSTR showProp = NULL;
	BSTR tgt = NULL;
	UINT showWindow = SW_SHOWNORMAL;
	VARIANT pVal, pVal1;

#define BUFSIZE 256
	char buffer[BUFSIZE];

	// WideCharToMultiByte wont null terminate its result so 
	// if its not initialized to nulls, you'll get junk after 
	// the converted command line and it wont run the command.
	memset(buffer, 0, BUFSIZE);

	VariantInit(&pVal);
	VariantInit(&pVal1);

	TRACE(_T("Indicate() called\n"));

	tgtProp = SysAllocString(L"cmdLine");
	showProp = SysAllocString(L"ShowWindow");

	// clear my output buffer.
	clMyBuff.Empty();

	//--------------------------------
	// NOTICE that I only call once per call, not once per object passed since
	//  I dont care what object caused the event anyway.

	// get the 'Item' property out of the embedded object.
	if((pLogicalConsumer->Get(tgtProp, 0L, &pVal, NULL, NULL) == S_OK) &&
		(pLogicalConsumer->Get(showProp, 0L, &pVal1, NULL, NULL) == S_OK))
	{
		// pull out the command.
		clMyBuff = _T("cmdLine will run: ");

		// take onto the display line.
		tgt = V_BSTR(&pVal);
		clMyBuff += tgt;

		// how to run the program.
		showWindow = (UINT)V_UI1(&pVal1);

		// convert the original to ascii for the WinExec() call.
        WideCharToMultiByte(CP_ACP, 0, 
							tgt, SysStringLen(tgt), 
							buffer, BUFSIZE,
							NULL, NULL);

		TRACE(buffer);

		// call winExec.
		UINT ret = WinExec(buffer, showWindow);

		if(ret <= 31)
		{
			WCHAR msg[100];
			wcscpy(msg, _itow(ret, &msg[0], 10));
			AfxMessageBox((LPCTSTR)&msg[0]);
		}

		// output the buffer.
		m_pOutputList->AddString(clMyBuff);
        AddEventToFile();

	}
	else
	{
		TRACE(_T("Get() cmdLine failed\n"));
	}

	SysFreeString(tgtProp);
	VariantClear(&pVal);

	TRACE(_T("walked indication list\n"));

	return S_OK;
}

// **************************************************************************
//
//	ErrorString()
//
// Description:
//		Converts an HRESULT to a displayable string.
//
// Parameters:
//		hRes (in) - HRESULT to be converted.
//
// Returns:
//		ptr to displayable string.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
LPCTSTR CConsumer::ErrorString(HRESULT hRes)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hRes) 
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	default:
        _itot(hRes, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\cmdlineconsumerdlg.h ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  CmdLineConsumerDlg.h
//
// Description:
//			Defines the class for the consumer's dialog
//
// History:
//
// **************************************************************************

#if !defined(AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CCmdLineConsumerDlg dialog

class CCmdLineConsumerDlg : public CDialog
{
// Construction
public:
	CCmdLineConsumerDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CCmdLineConsumerDlg)
	enum { IDD = IDD_CMDLINECONSUMER_DIALOG };
	CListBox	m_output;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCmdLineConsumerDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CCmdLineConsumerDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMDLINECONSUMERDLG_H__EF85AEB9_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\factory.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  File:  factory.cpp
//
//	Description :
//			Class factory implementation for the command-line event
//			consumer provider
//
//  History:	
//
//***************************************************************************

#include "stdafx.h"
#include "factory.h"
#include "Provider.h"

CProviderFactory::CProviderFactory(CListBox	*pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProviderFactory::~CProviderFactory()
{
}

//IUnknown methods
STDMETHODIMP CProviderFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProviderFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CProviderFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CProviderFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
    CProvider *pProvider = NULL;

    if (pUnkOuter)
        return E_FAIL;

	// create the provider.
    pProvider = new CProvider(m_pOutputList);

    if (pProvider == NULL)
	{
		return E_FAIL;
	}

	// get the interface asked for.
    if (pProvider)
    {
        hr = pProvider->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProviderFactory::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\provider.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  Provider.cpp
//
// Description:
//			Implementation for the command-line event consumer provider class
// 
// History:
//
// **************************************************************************

#include "stdafx.h"
#include "Provider.h"
#include "Consumer.h"
#include <objbase.h>

CProvider::CProvider(CListBox *pOutputList)
{
	m_cRef = 0L;
	m_pOutputList = pOutputList;
}

CProvider::~CProvider()
{
}

STDMETHODIMP CProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemEventConsumerProvider)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvider::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvider::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

//-----------------------------------------------------------
STDMETHODIMP CProvider::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	// create the logical consumer.
	CConsumer* pSink = new CConsumer(m_pOutputList);
    
	// return it's "sink" interface.
	return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\factory.h ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  factory.h
//
// Description:
//			Definition for command-line event consumer provider class factory
//
// History:
//
// **************************************************************************

#include <wbemcli.h>

class CProviderFactory : public IClassFactory
{
public:

	CProviderFactory(CListBox	*pOutputList);
	virtual ~CProviderFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;
	CListBox	*m_pOutputList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\provider.h ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  Provider.h
//
// Description:
//			Definition of command-line event consumer provider class
//
// History:
//
// **************************************************************************

#include <wbemcli.h>
#include <wbemprov.h>

class CProvider : public IWbemEventConsumerProvider
{
public:
	CProvider(CListBox	*pOutputList);
	~CProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// This routine allows you to map the 1 physical consumer
	// to potentially multiple logical consumers.
    STDMETHOD(FindConsumer)(
				IWbemClassObject* pLogicalConsumer,
				IWbemUnboundObjectSink** ppConsumer);

private:

	DWORD m_cRef;
	CListBox	*m_pOutputList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CmdLineConsumer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CMDLINECONSUMER_DIALOG      102
#define IDR_MAINFRAME                   128
#define IDC_LIST                        1000
#define IDC_CUSTOM1                     1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\stdafx.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EF85AEBB_6B6C_11D1_ADAD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\classfac.h ===
//===============================

// CLASSFAC.H

// CClassFactory Class Definition

//===============================



#ifndef _CLASSFAC_H_

#define _CLASSFAC_H_



class CClassFactory : public IClassFactory

{

public:



	CClassFactory();

	virtual ~CClassFactory();



    // IUnknown members

    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);

    STDMETHODIMP_(ULONG) AddRef(void);

    STDMETHODIMP_(ULONG) Release(void);

	 

	// IClassFactory members

	// =====================

	STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);

 	STDMETHODIMP LockServer(BOOL fLock);



private:

	LONG m_cRef;

	CModule *pModule;

	HWND hWnd;

};





#endif /* _CLASSFAC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtperm\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//	CmdLineConsumer.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\classfac.cpp ===
//=============

// CLASSFAC.CPP

//=============



#include "module.h"

#include "classfac.h"

#include "cimmodule_i.c"



extern HANDLE g_hEvent;



CClassFactory::CClassFactory() 

{

	m_cRef = 0L;

}



CClassFactory::~CClassFactory()

{

}





//===============

//IUknown methods

//===============



STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)

{

    *ppv=NULL;



    if (riid == IID_IUnknown || riid == IID_IClassFactory)

        *ppv=this;



    if (*ppv != NULL)

    {

        ((LPUNKNOWN)*ppv)->AddRef();

        return NOERROR;

    }



    return E_NOINTERFACE;

}





STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)

{

    return InterlockedIncrement(&m_cRef);

}





STDMETHODIMP_(ULONG) CClassFactory::Release(void)

{

    int lNewRef = InterlockedDecrement(&m_cRef);

    if(lNewRef == 0)

    {

        delete this;

    }



    return lNewRef;

}



//=====================

//IClassFactory methods

//=====================



STDMETHODIMP

CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)

{

	HRESULT hr;

   

    if (pUnkOuter)

        return E_FAIL;



	// This object doesnt support aggregation

	//=======================================

    if (pUnkOuter!=NULL)

        return CLASS_E_NOAGGREGATION;



    pModule = new CModule();



    if (pModule == NULL)

	{

		return E_FAIL;

	}



    if (pModule)

    {

		// Retrieve the requested interface.

        hr = pModule->QueryInterface(riid, ppv);

    }

    else

    {

        *ppv = NULL;

        return E_OUTOFMEMORY;

    }



    return NOERROR;

}



//***************************************************************************

//

// CClassFactory::LockServer

//

// Purpose:

//  Increments or decrements the lock count of the EXE.  If the

//  lock count goes to zero and there are no objects, the EXE

//  is allowed to unload.  

//

// Parameters:

//  fLock           BOOL specifying whether to increment or

//                  decrement the lock count.

//

// Return Value:

//  HRESULT         NOERROR always.

//***************************************************************************

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)

{

    if (fLock)

        CoAddRefServerProcess();

    else 

		if (CoReleaseServerProcess()==0)

			SetEvent(g_hEvent);

	

    return NOERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\module.cpp ===
// ================================================

// MODULE.CPP

// Module Class implementation; non-module specific

// ================================================

#define _WIN32_DCOM	


#include "module.h"
#include "comdef.h"
#include "process.h"
#include "testcode.h"	

extern HANDLE g_hEvent;


CModule::CModule():	m_pCimNotify(0),	m_cRef(0),	m_bstrParams(NULL),	m_bShouldExit(false),	m_bShouldPause(false),	m_hThread(NULL)
{

	CoAddRefServerProcess();
}


CModule::~CModule()

{
	if (m_hThread)
	{
		CloseHandle(m_hThread);
	}

	SysFreeString(m_bstrParams);

	if (CoReleaseServerProcess()==0)
    	SetEvent(g_hEvent); //shutdown server
}



STDMETHODIMP CModule::QueryInterface(REFIID riid, LPVOID *ppv)

{

	*ppv=NULL;



	if(IID_IUnknown == riid || IID_ICimModule == riid)
	{
		*ppv = (ICimModule *)this;
	}

	

	if(NULL != *ppv)

	{
		AddRef();
		return NOERROR;
	}
	else
		return E_NOINTERFACE;

}





STDMETHODIMP_(ULONG) CModule::AddRef(void)

{

   return InterlockedIncrement((long *)&m_cRef);

}



STDMETHODIMP_(ULONG) CModule::Release(void)

{

	ULONG nNewCount=InterlockedDecrement((long *)&m_cRef);

    if (nNewCount != 0)

        return nNewCount;



	delete this;



	return 0;

}


STDMETHODIMP CModule::Start(VARIANT* pvarInitOp, IUnknown* pUnknown)

{


	// The module MUST return immediately from calls to Start()
    // Non-zero error code indicates catastrophic failure! Never return that!
	//=======================================================================


	HRESULT hr;
	DWORD dwTID;


	// Get the logging interface (ICimNotify)
	//=======================================

	hr = pUnknown->QueryInterface(IID_ICimNotify, (LPVOID *)&m_pCimNotify);
	if (hr == S_OK)
	{	

		//Grab a copy of the start parameters
		//===================================

		CModule::ParseParams(pvarInitOp);

		// Start the thread and return
		//============================

		m_hThread = CreateThread(0, 0, CModule::ModuleMain, this, 0, &dwTID);
	}

	return hr;
}



STDMETHODIMP CModule::Terminate()

{

	// The module MUST return immediately from calls to Terminate()

	// Failure codes indicates catastrophic failure! Never return that!

	//=======================================================================



	m_bShouldExit=true;

	return S_OK;

}



STDMETHODIMP CModule::Pause()

{

	// The module MUST return immediately from calls to Pause()

	// Failure codes indicate catastrophic failure! Never return that!

	//=======================================================================



	m_bShouldPause=!m_bShouldPause;

	return S_OK;

}



STDMETHODIMP CModule::BonusMethod(void)

{

	// The module MUST return immediately from calls to BonusMethod()

	// Module specific (i.e. do whatever you want to here)

	// Failure codes indicate catastrophic failure! Never return that!

	//=======================================================================



	return 0;

}



void CModule::ParseParams(VARIANT *pVar)

{

	//This just stores the parameter. You could choose to actually parse it here!

	//===========================================================================



	if(VT_BSTR==pVar->vt)

	{

		m_bstrParams=SysAllocString(pVar->bstrVal);

	}

}







DWORD WINAPI CModule::ModuleMain(void *pVoid)

{

	CoInitializeEx(0, COINIT_MULTITHREADED);


	CModule *pThis = (CModule *)pVoid;



	CTestCode MyTestCode(pThis);



	MyTestCode.RunBVT();



	pThis->m_pCimNotify->Release();



	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\module.h ===
#ifndef _MODULE_H_

#define _MODULE_H_



#include "cimmodule.h"



class CModule : public ICimModule

{

public:



	CModule();

	~CModule();



    //IUnknown methods

	//================

    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);

    STDMETHODIMP_(ULONG) AddRef(void);

    STDMETHODIMP_(ULONG) Release(void);



	//IDispatch methods not supported

	//===============================

	STDMETHODIMP GetTypeInfoCount(UINT *)

	{return E_NOTIMPL;}

	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **)

	{return E_NOTIMPL;}

	STDMETHODIMP GetIDsOfNames(REFIID, LPOLESTR*, UINT, LCID, DISPID*)

	{return E_NOTIMPL;}

	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT *, EXCEPINFO*, UINT*)

	{return E_NOTIMPL;}



	//ICimModule methods

	//==================

	STDMETHODIMP Start(VARIANT* pvarInitOp, IUnknown* pIUnknown);

	STDMETHODIMP Pause(void);

	STDMETHODIMP Terminate(void);

	STDMETHODIMP BonusMethod(void);





	bool m_bShouldExit;

	bool m_bShouldPause;

	ICimNotify *m_pCimNotify;

	BSTR m_bstrParams;



protected:

	void ParseParams(VARIANT *);

	static DWORD WINAPI ModuleMain(void *pVoid);

	

	HANDLE m_hThread;

	LONG m_cRef;

};



#endif /*_MODULE_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\testcode.cpp ===
#include "testcode.h"

CLogAndDisplayOnScreen  *   gp_LogFile;
CIniFileAndGlobalOptions    g_Options;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLog::Log(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString)
{
    HRESULT hr =  m_pModule->m_pCimNotify->Log((WCHAR *)(_bstr_t(pwcsError) + pwcsFileAndLine + wcsString), 0, &m_DummyVariant, &m_DummyVariant); };
    if( hr == SUCCESS )
    {
        return TRUE;
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CTestCode::RunBVT()
{
    gp_LogFile = new CLog();
    if( gp_LogFile )
    {
      
        gp_LogFile->SetModulePtr(m_pModule);

        int argc = 0;

        WCHAR * wsTmp = m_pModule->m_bstrParams;
        while (*wsTmp!=0x0)
        {
            argc++;
        }
        if( !ParseCommandLine(argc, m_pModule->m_bstrParams) )
        {
            gp_LogFile->LogError( __FILE__,__LINE__,FATAL_ERROR, L"GetCommandLineArguments failed." );
        }
        else
        {
            nRc = ExecuteBVTTests();
        }
    }
    SAFE_DELETE_PTR(gp_LogFile);
    
    return 0;
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CTestCode::ExecuteBVTTests()
{
    int nRc = FATAL_ERROR;
    if( g_Options.RunSpecificTests())
    {
        // =================================================
        //  Execute the specific tests requested
        // =================================================
        for( int i = 0; i < g_Options.SpecificTestSize(); i++ )
        {
            int nTest = g_Options.GetSpecificTest(i);
            nRc = RunTests(nTest,TRUE,FALSE);
            if( nRc == FATAL_ERROR )
            {
                g_LogFile.LogError( __FILE__,__LINE__,FATAL_ERROR, L"Test # %d returned a FATAL ERROR",nTest );
            }
        }
    }
    else
    {
        // =================================================
        //  Execute all of the Single Threaded BVT tests
    	// =================================================
            
        int nMaxTests = sizeof(g_nDefaultTests) / sizeof(int);

        for( int i = 0; i < nMaxTests ; i++ )
        {
            nRc = RunTests(g_nDefaultTests[i],TRUE,FALSE);
        }
        // =================================================
        //  Execute all of the Multi Threaded BVT tests
    	// =================================================
        int nMax = sizeof(g_nMultiThreadTests) / sizeof(int);

        CMulti * pTest = new CMulti(nMax);
        if( pTest )
        {
            nRc = pTest->MultiThreadTest(g_Options.GetThreads(), g_Options.GetConnections());
        }
        SAFE_DELETE_PTR(pTest);
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\main.cpp ===
// TO BUILD A MODULE FROM THE SKELETON, see README.TXT

// ===================================================

// MAIN.CPP

// Module executable entry point

// ===================================================

// Project History:

//

// Date     Name	  Change

// -------- --------- ---------

// 9/17/98  a-jaker	  Created

// 10/23/98 a-jayher  Edited

// 12/14/98 marioh	  Edited [AppWizard additions]

//====================================================



#define _WIN32_DCOM	



#include "module.h"

#include "classfac.h"



HANDLE g_hEvent;



// Used to register a COM API

void RegisterServer(char *szFileName, GUID guid, char * pDesc, char * pModel, char * pProgID);







int APIENTRY WinMain(IN HINSTANCE hInstance,

                     IN HINSTANCE hPrevInstance,

                     IN LPSTR szCmdLine,

                     IN int nCmdShow)

{

	DWORD dwObject=0;

	HRESULT hr;



	// Register CLSID here if called with /REGSERVER

	//==============================================



	if(!lstrcmpi(TEXT("REGSERVER"),szCmdLine+1))

	{

		char szBuffer[MAX_PATH];

		GetModuleFileName(NULL,szBuffer,MAX_PATH);

		

		//All modules need to have the substring "WBEM TEST MODULE" in their description

		RegisterServer(szBuffer, CLSID_CimModule, "WMI Generic Framework Module - WBEM TEST MODULE", "Both", NULL);

		exit(0);

	}



	CClassFactory *pFactory=new CClassFactory();

	g_hEvent = CreateEvent(0, FALSE, FALSE, 0);



	hr=CoInitializeEx(0, COINIT_MULTITHREADED);



	if (hr==S_OK)

	{

		// Initialize DCOM Security Here (change flags as needed)

		//=======================================================



		hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, 

			RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, 0);



		if (hr==S_OK)

		{



			hr=CoRegisterClassObject(CLSID_CimModule,

								  (IUnknown *) pFactory,

								  CLSCTX_LOCAL_SERVER,

								  REGCLS_MULTIPLEUSE,

								  &dwObject);

		}

	}





	if (hr != S_OK)

		exit(hr);





	CoResumeClassObjects();



	//Wait here until all objects have been released

	//==============================================



	WaitForSingleObject(g_hEvent,INFINITE);



	CoRevokeClassObject(dwObject);

	CloseHandle(g_hEvent);

	CoUninitialize();

	return 0;



}



void RegisterServer(char *szFileName, GUID guid, char * pDesc, char * pModel,

			char * pProgID)

{

    char       szID[128];

    WCHAR      wcID[128];

    char       szCLSID[128];

    HKEY hKey1 = NULL, hKey2 = NULL;



    // Create the path.

    if(0 ==StringFromGUID2(guid, wcID, 128))

		return;



    wcstombs(szID, wcID, 128);

    lstrcpy(szCLSID, TEXT("CLSID\\"));

    lstrcat(szCLSID, szID);



    // Create entries under CLSID

    if(ERROR_SUCCESS != RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1))

		return;



    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, lstrlen(pDesc)+1);

    

    if (strstr(_strlwr(szFileName),".exe"))

	{

		if(ERROR_SUCCESS != RegCreateKey(hKey1,"LocalServer32",&hKey2))

			return;

	}

	else

	{

		if(ERROR_SUCCESS != RegCreateKey(hKey1,"InProcServer32",&hKey2))

			return;

	}



    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szFileName, 

                                        lstrlen(szFileName)+1);

  

    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 

                                       (BYTE *)pModel, lstrlen(pModel)+1);



    RegCloseKey(hKey1);

    RegCloseKey(hKey2);



    // If there is a progid, then add it too

    if(pProgID)

    {

        if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pProgID, &hKey1))

        {



            RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc , lstrlen(pDesc)+1);

            if(ERROR_SUCCESS == RegCreateKey(hKey1,"CLSID",&hKey2))

            {

                RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szID, 

                                        lstrlen(szID)+1);

                RegCloseKey(hKey2);

                hKey2 = NULL;

            }

            RegCloseKey(hKey1);

        }



    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\framework\testcode.h ===
#include <windows.h>

#include <comdef.h>

#include "CimModule.h"

#include "Module.h"


class CLog :: public CLogAndDisplayOnScreen
{
	CModule * m_pModule;

    public:
        CLog() {}
        ~CLog() {}

        void SetModulePtr(CModule * p)       { m_pModule = p; }
        BOOL Log(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString);

};

class CTestCode

{

	CModule * m_pModule;

	_variant_t m_DummyVariant;

public:

	CTestCode (CModule * pModule) : m_pModule(pModule) { m_DummyVariant.vt = VT_NULL; };

	~CTestCode() {};

	
    HRESULT ExecuteBVTTests();

	inline bool ShouldExit()  { return m_pModule->m_bShouldExit; };

	inline bool ShouldPause() { return m_pModule->m_bShouldPause; };

	HRESULT Log (BSTR bstrLog, HRESULT hrResCode) 

	{ return m_pModule->m_pCimNotify->Log(bstrLog, hrResCode, &m_DummyVariant, &m_DummyVariant); };



	inline BSTR GetParams() { return m_pModule->m_bstrParams; };

	

	HRESULT RunBVT();

	HRESULT Test002();

	HRESULT Test003();

	// ...

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\algorithms.cpp ===
#ifndef __ALGORITHMS_CPP
#define __ALGORITHMS_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <Array.h>
#include <Stack.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifdef WMI_CONTAINER_PERFORMANCE_TESTING
extern ULONG g_Compare ;
#endif

template <class WmiElement>
LONG CompareElement ( const WmiElement &a_Arg1 , const WmiElement &a_Arg2 )
{
#ifdef WMI_CONTAINER_PERFORMANCE_TESTING
	g_Compare ++ ;
#endif

	if ( a_Arg1 == a_Arg2 )
	{
		return 0 ;
	}
	else if ( a_Arg1 < a_Arg2 )
	{
		return -1 ;
	}

	return 1 ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StackElement
{
public:

	ULONG m_Lower ;
	ULONG m_Upper ;

	StackElement () {;}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiArray, class WmiElement>
WmiStatusCode QuickSort ( WmiArray &a_Array , ULONG a_Size )
{
	a_Size = a_Size == 0 ? a_Array.Size () : a_Size ;

	if ( a_Size )
	{
		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiStack <StackElement,8> t_Stack ( t_Allocator ) ;

			StackElement t_Element ;
			t_Element.m_Lower = 1 ;
			t_Element.m_Upper = a_Size - 1 ;

			t_Stack.Push ( t_Element ) ;

			while ( t_Stack.Size () )
			{
				StackElement t_Top ;

				WmiStatusCode t_StatusCode = t_Stack.Top ( t_Top ) ;
				t_StatusCode = t_Stack.Pop () ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					if ( t_Top.m_Lower <= t_Top.m_Upper )
					{
						ULONG t_LeftIndex = t_Top.m_Lower ; 
						ULONG t_RightIndex = t_Top.m_Upper ;

						WmiElement t_LeftOperand ;
						WmiElement t_RightOperand ;

						while ( true )
						{					
							while ( a_Array.Get ( t_LeftOperand , t_LeftIndex ) , a_Array.Get ( t_RightOperand , t_Top.m_Lower - 1 ) , ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( t_LeftOperand  , t_RightOperand ) <= 0 ) )
							{
								t_LeftIndex ++ ;
							}

							while ( a_Array.Get ( t_LeftOperand , t_Top.m_Lower - 1 ) , a_Array.Get ( t_RightOperand , t_RightIndex ) , ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( t_LeftOperand  , t_RightOperand ) <= 0 ) )
							{
								t_RightIndex -- ;
							}

							if ( t_LeftIndex < t_RightIndex ) 
							{
								t_StatusCode = a_Array.Get ( t_LeftOperand , t_LeftIndex ) ;
								t_StatusCode = a_Array.Get ( t_RightOperand , t_RightIndex ) ;
								t_StatusCode = a_Array.Set ( t_RightOperand , t_LeftIndex ) ;
								t_StatusCode = a_Array.Set ( t_LeftOperand , t_RightIndex ) ;
							}
							else
							{
								break ;
							}
						}

						t_StatusCode = a_Array.Get ( t_LeftOperand , t_LeftIndex ) ;
						t_StatusCode = a_Array.Get ( t_RightOperand , t_Top.m_Lower - 1 ) ;

						LONG t_Compare = CompareElement ( t_LeftOperand , t_RightOperand ) ;
						if ( t_Compare < 0 )
						{
							t_StatusCode = a_Array.Get ( t_LeftOperand , t_LeftIndex ) ;
							t_StatusCode = a_Array.Get ( t_RightOperand , t_Top.m_Lower - 1 ) ;
							t_StatusCode = a_Array.Set ( t_RightOperand , t_LeftIndex ) ;
							t_StatusCode = a_Array.Set ( t_LeftOperand , t_Top.m_Lower - 1 ) ;
						}

						StackElement t_Element ;
						t_Element.m_Lower = t_Top.m_Lower ;
						t_Element.m_Upper = t_LeftIndex - 1  ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;

						t_Element.m_Lower = t_LeftIndex + 1 ;
						t_Element.m_Upper = t_Top.m_Upper ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;
					}
				}
			}
		}
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode Flat_QuickSort ( WmiElement *a_Array , ULONG a_Size )
{
	if ( a_Size )
	{
		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiStack <StackElement,8> t_Stack ( t_Allocator ) ;

			StackElement t_Element ;
			t_Element.m_Lower = 1 ;
			t_Element.m_Upper = a_Size - 1 ;

			t_Stack.Push ( t_Element ) ;

			while ( t_Stack.Size () )
			{
				StackElement t_Top ;

				WmiStatusCode t_StatusCode = t_Stack.Top ( t_Top ) ;
				t_StatusCode = t_Stack.Pop () ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					if ( t_Top.m_Lower <= t_Top.m_Upper )
					{
						ULONG t_LeftIndex = t_Top.m_Lower  ; 
						ULONG t_RightIndex = t_Top.m_Upper ; 

						while ( true )
						{
							while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_LeftIndex ]  , a_Array [ t_Top.m_Lower - 1 ] ) <= 0 ) )
							{
								t_LeftIndex ++ ;
							}

							while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_Top.m_Lower - 1 ]  , a_Array [ t_RightIndex ] ) <= 0 ) )
							{
								t_RightIndex -- ;
							}

							if ( t_LeftIndex < t_RightIndex ) 
							{
								WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
								a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
								a_Array [ t_RightIndex ] = t_Temp ;
							}
							else
							{
								break ;
							}
						}

						LONG t_Compare = CompareElement ( a_Array [ t_LeftIndex ] , a_Array [ t_Top.m_Lower - 1 ] ) ;
						if ( t_Compare < 0 )
						{
							WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
							a_Array [ t_LeftIndex ] = a_Array [ t_Top.m_Lower - 1 ] ;
							a_Array [ t_Top.m_Lower - 1 ] = t_Temp ;
						}

						StackElement t_Element ;
						t_Element.m_Lower = t_Top.m_Lower ;
						t_Element.m_Upper = t_LeftIndex - 1  ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;

						t_Element.m_Lower = t_LeftIndex + 1 ;
						t_Element.m_Upper = t_Top.m_Upper ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;
					}
				}
			}
		}
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
void RecursiveQuickSort ( WmiElement *a_Array , ULONG a_Lower , ULONG a_Upper )
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) <= 0 ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) <= 0 ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareElement ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare < 0 )
		{
			WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode QuickSort ( WmiElement *a_Array , ULONG a_Size )
{
	RecursiveQuickSort ( a_Array , 1 , a_Size - 1 ) ;

	return e_StatusCode_Success ;
}

#endif __ALGORITHMS_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\allocator.cpp ===
#ifndef __ALLOCATOR_CPP
#define __ALLOCATOR_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <Allocator.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator :: WmiAllocator () : 

	m_Heap ( NULL ) , 
	m_Options ( e_DefaultAllocation ) ,
	m_InitialSize ( 0 ) ,
	m_MaximumSize ( 0 ) ,
	m_ReferenceCount ( 0 )
{
	m_Heap = GetProcessHeap () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
	
WmiAllocator :: WmiAllocator ( 

	AllocationOptions a_Option , 
	size_t a_InitialSize , 
	size_t a_MaximumSize
) : 
	m_Heap ( NULL ) , 
	m_Options ( a_Option ) ,
	m_InitialSize ( a_InitialSize ) ,
	m_MaximumSize ( a_MaximumSize ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator :: ~WmiAllocator ()
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiAllocator :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiAllocator :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Win32ToApi () 
{
	WmiStatusCode t_Status = e_StatusCode_Success ;

	DWORD t_LastError = GetLastError () ;
	switch ( t_LastError )
	{
		case STATUS_NO_MEMORY:
		{
			t_Status = e_StatusCode_OutOfMemory ;
		}
		break ;

		default:
		{
			t_Status = e_StatusCode_Unknown ;
		}
		break ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap == NULL )
	{
		m_Heap = HeapCreate ( 

			m_Options ,
			m_InitialSize ,
			m_MaximumSize
		) ;

		if ( m_Heap == NULL )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		if ( m_Heap != GetProcessHeap () )
		{		
			BOOL t_Status = HeapDestroy ( m_Heap ) ;
			if ( t_Status ) 
			{
				m_Heap = NULL ;
			}
			else
			{
				t_Status = Win32ToApi () ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: New ( 

	void **a_Allocation , 
	size_t a_Size
)
{
	return New ( 

		( AllocationOptions ) ( ( m_Options & ( e_GenerateException | e_NoSerialize ) ) | e_ZeroMemory ) ,
		a_Allocation , 
		a_Size
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: New ( 

	AllocationOptions a_Option , 
	void **a_Allocation , 
	size_t a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		*a_Allocation = HeapAlloc (

			m_Heap ,	
			a_Option ,
			a_Size 
		) ;

		if ( ! *a_Allocation )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: ReAlloc ( 

	void *a_Allocation , 
	void **a_ReAllocation , 
	size_t a_Size
)
{
	return ReAlloc ( 

		( AllocationOptions ) ( ( m_Options & ( e_GenerateException | e_NoSerialize ) ) ) , 
		a_Allocation , 
		a_ReAllocation , 
		a_Size
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: ReAlloc ( 

	AllocationOptions a_Option , 
	void *a_Allocation , 
	void **a_ReAllocation , 
	size_t a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		*a_ReAllocation = HeapReAlloc (

			m_Heap ,	
			a_Option ,
			a_Allocation ,
			a_Size 
		) ;

		if ( ! *a_ReAllocation )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Delete (

	void *a_Allocation
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		BOOL t_Status = HeapFree ( 

			m_Heap , 
			0 , 
			a_Allocation
		) ;

		if ( ! t_Status )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Size ( 

	void *a_Allocation ,
	size_t &a_Size
) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		a_Size = HeapSize ( 

			m_Heap ,
			m_Options & e_NoSerialize ,
			a_Allocation
		) ;

		if ( a_Size == -1 )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_AlreadyInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Compact ( 

	size_t &a_LargestFreeBlock
) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		a_LargestFreeBlock = HeapCompact ( 

			m_Heap ,
			m_Options & e_NoSerialize 
		) ;

		if ( a_LargestFreeBlock == 0 && GetLastError () != 0 )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_AlreadyInitialized ;
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Validate ( LPCVOID a_Location ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Status = HeapValidate (

		m_Heap,
		m_Options & e_NoSerialize ,
		a_Location
	) ;

	if ( ! t_Status )
	{
		t_StatusCode = e_StatusCode_InvalidHeap ;
	}

	return t_StatusCode ;
}

#endif __ALLOCATOR_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\standalone\bvtmain.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTMain.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DECLARE_GLOBALS
#include <bvt.h>
#include <string.h> 


class CLog : public CLogAndDisplayOnScreen
{

    public:
        CLog() {}
        ~CLog() {}

        BOOL Log(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString);

};

CLogAndDisplayOnScreen  *   gp_LogFile;
CIniFileAndGlobalOptions    g_Options;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLog::Log(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString)
{

    BOOL fRc = FALSE;

    //==========================================
    //  Write it to the log file
    //==========================================
    if( WriteToFile(pwcsError, pwcsFileAndLine,wcsString ))
    {
        //==========================================
        //  Display it on the screen
        //==========================================
        wprintf(L"%s: %s\n",pwcsError,wcsString);
        fRc = TRUE;
    }
    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )

{
    int nRc = FATAL_ERROR;

    gp_LogFile = new CLog();
    if( gp_LogFile )
    {
        //==============================================================
        //  Get the command line arguments
        //==============================================================
        if( !ParseCommandLine(argc, argv) )
        {
            gp_LogFile->LogError( __FILE__,__LINE__,FATAL_ERROR, L"GetCommandLineArguments failed." );
        }
        else
        {
	        // =========================================================
      	    // Initialize COM
	        // =========================================================
            HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	        if ( SUCCEEDED( hr ) )
            {
	            // =====================================================
        	    // Setup default security parameters
	            // =====================================================
        	    hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
			                               NULL, EOAC_NONE, NULL );
	            if ( SUCCEEDED( hr ) )
                {
                    if( g_Options.RunSpecificTests())
                    {
         	            // =================================================
                        //  Execute the specific tests requested
         	            // =================================================
                        for( int i = 0; i < g_Options.SpecificTestSize(); i++ )
                        {
                            int nTest = g_Options.GetSpecificTest(i);
                            nRc = RunTests(nTest,TRUE,FALSE);
                            if( nRc == FATAL_ERROR )
                            {
                                gp_LogFile->LogError( __FILE__,__LINE__,FATAL_ERROR, L"Test # %d returned a FATAL ERROR",nTest );
                            }
                        }
                    }
                    else
                    {
         	            // =================================================
                        //  Execute all of the Single Threaded BVT tests
    	                // =================================================
                        
                        int nMaxTests = sizeof(g_nDefaultTests) / sizeof(int);

                        for( int i = 0; i < nMaxTests ; i++ )
                        {
                            nRc = RunTests(g_nDefaultTests[i],TRUE,FALSE);
                        }
         	            // =================================================
                        //  Execute all of the Multi Threaded BVT tests
    	                // =================================================
                        int nMax = sizeof(g_nMultiThreadTests) / sizeof(int);

                        CMulti * pTest = new CMulti(nMax);
                        if( pTest )
                        {
                            nRc = pTest->MultiThreadTest(g_Options.GetThreads(), g_Options.GetConnections());
                        }
                        SAFE_DELETE_PTR(pTest);
                    }
                }
                else
                {
                    gp_LogFile->LogError( __FILE__,__LINE__,FATAL_ERROR, L"CoInitializeSecurity failed." );
                }

          	    CoUninitialize();
            }
            else
            {
                gp_LogFile->LogError( __FILE__,__LINE__,FATAL_ERROR, L"CoInitializeEx failed." );
            }

        }
    }

    SAFE_DELETE_PTR(gp_LogFile);
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\array.cpp ===
#ifndef __ARRAY_CPP
#define __ARRAY_CPP

/*
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ELEMENT_DIR_BIT_SIZE	12
#define INNER_DIR_BIT_SIZE		10
#define OUTER_DIR_BIT_SIZE		10

#define ELEMENT_BIT_POS			0
#define INNER_DIR_BIT_POS		ELEMENT_DIR_BIT_SIZE
#define OUTER_DIR_BIT_POS		(INNER_DIR_BIT_SIZE + ELEMENT_DIR_BIT_SIZE)

#define ELEMENT_DIR_SIZE		1 << ELEMENT_DIR_BIT_SIZE
#define INNER_DIR_SIZE			1 << ( INNER_DIR_BIT_SIZE + ELEMENT_DIR_BIT_SIZE )
#define OUTER_DIR_SIZE			1 << ( OUTER_DIR_BIT_SIZE + INNER_DIR_BIT_SIZE + ELEMENT_DIR_BIT_SIZE )

#define ELEMENT_DIR_MASK		0xFFFFFFFF >> ( OUTER_DIR_BIT_SIZE + INNER_DIR_BIT_SIZE )
#define OUTER_DIR_MASK			0xFFFFFFFF << ( INNER_DIR_BIT_SIZE + ELEMENT_DIR_BIT_SIZE )
#define	INNER_DIR_MASK			OUTER_DIR_MASK & ELEMENT_DIR_MASK
#define INNER_ELEMENT_DIR_MASK	0xFFFFFFFF >> OUTER_DIR_BIT_SIZE

#define INITIAL_OUTER_SIZE 1
#define INITIAL_INNER_SIZE 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiArray <WmiElement> :: WmiArray (

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiArray <WmiElement> :: ~WmiArray ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Initialize ( ULONG a_Size )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Size )
	{
		m_Size = a_Size ;
		t_StatusCode = Initialize_OuterDir ( m_Size ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		t_StatusCode = UnInitialize_OuterDir ( m_Size ) ;

		m_Size = 0 ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Grow ( ULONG a_Size )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		if ( m_Size < a_Size )
		{
			ULONG t_Size = m_Size ;
			m_Size = a_Size ;
			t_StatusCode = Grow_OuterDir ( t_Size , a_Size ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Shrink ( ULONG a_Size )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		if ( m_Size > a_Size )
		{
			t_StatusCode = Shrink_OuterDir ( m_Size , a_Size ) ;
			m_Size = a_Size ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Set (const WmiElement &a_Element , ULONG a_ElementIndex )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size && ( a_ElementIndex < m_Size ) )
	{
		ULONG t_OuterIndex = ( a_ElementIndex >> OUTER_DIR_BIT_POS ) ;
		ULONG t_InnerIndex = ( ( a_ElementIndex & INNER_ELEMENT_DIR_MASK ) >> INNER_DIR_BIT_POS ) ;
		ULONG t_ElementIndex = a_ElementIndex & ELEMENT_DIR_MASK ;

		WmiInnerDir *t_InnerDir = & ( m_OuterDir.m_InnerDir [ t_OuterIndex ] ) ;
		WmiElementDir *t_ElementDir = & ( t_InnerDir->m_ElementDir [ t_InnerIndex ] ) ;
		WmiElement *t_Element = & ( t_ElementDir->m_Block [ t_ElementIndex ] ) ;

		try
		{
			*t_Element = a_Element ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfBounds ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Get (

	WmiElement &a_Element ,
	ULONG a_ElementIndex
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size && ( a_ElementIndex < m_Size ) )
	{
		ULONG t_OuterIndex = ( a_ElementIndex >> OUTER_DIR_BIT_POS ) ;
		ULONG t_InnerIndex = ( ( a_ElementIndex & INNER_ELEMENT_DIR_MASK ) >> INNER_DIR_BIT_POS ) ;
		ULONG t_ElementIndex = a_ElementIndex & ELEMENT_DIR_MASK ;

		WmiInnerDir *t_InnerDir = & ( m_OuterDir.m_InnerDir [ t_OuterIndex ] ) ;
		WmiElementDir *t_ElementDir = & ( t_InnerDir->m_ElementDir [ t_InnerIndex ] ) ;
		WmiElement *t_Element = & ( t_ElementDir->m_Block [ t_ElementIndex ] ) ;

		try
		{
			a_Element = *t_Element ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfBounds ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Get (

	WmiElement *&a_Element ,
	ULONG a_ElementIndex
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size && ( a_ElementIndex < m_Size ) )
	{
		ULONG t_OuterIndex = ( a_ElementIndex >> OUTER_DIR_BIT_POS ) ;
		ULONG t_InnerIndex = ( ( a_ElementIndex & INNER_ELEMENT_DIR_MASK ) >> INNER_DIR_BIT_POS ) ;
		ULONG t_ElementIndex = a_ElementIndex & ELEMENT_DIR_MASK ;

		WmiInnerDir *t_InnerDir = & ( m_OuterDir.m_InnerDir [ t_OuterIndex ] ) ;
		WmiElementDir *t_ElementDir = & ( t_InnerDir->m_ElementDir [ t_InnerIndex ] ) ;
		WmiElement *t_Element = & ( t_ElementDir->m_Block [ t_ElementIndex ] ) ;

		a_Element = t_Element ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfBounds ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Get (

	Iterator &a_Iterator ,
	ULONG a_ElementIndex
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Iterator = Iterator ( this , a_ElementIndex ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Initialize_ElementDir (

	ULONG a_Size ,
	WmiElementDir *a_ElementDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = a_Size ;

	if ( t_Size )
	{
		t_StatusCode = m_Allocator.New (

			( void ** ) & a_ElementDir->m_Block ,
			sizeof ( WmiElement ) * a_Size
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				WmiElement *t_Element = & ( a_ElementDir->m_Block ) [ t_Index ] ;
				:: new ( ( void * ) t_Element ) WmiElement () ;
			}
		}
		else
		{
			m_Size = m_Size - a_Size ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Initialize_InnerDir (

	ULONG a_Size ,
	WmiInnerDir *a_InnerDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = ( a_Size >> INNER_DIR_BIT_POS ) + 1 ;

	if ( t_Size )
	{
		t_StatusCode = m_Allocator.New (

			( void ** ) & a_InnerDir->m_ElementDir ,
			sizeof ( WmiElementDir ) * t_Size
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				if ( t_Index == t_Size - 1 )
				{
					t_StatusCode = Initialize_ElementDir (

						a_Size & ELEMENT_DIR_MASK ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}
				else
				{
					t_StatusCode = Initialize_ElementDir (

						ELEMENT_DIR_SIZE ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}

				if ( t_StatusCode != e_StatusCode_Success )
				{
					if ( t_Index != t_Size - 1 )
					{
						ULONG t_Remainder = t_Size - t_Index - 1 ;

						if ( t_Remainder )
						{
							m_Size = m_Size - ( ( t_Remainder - 1 ) * ELEMENT_DIR_SIZE ) ;
						}

						m_Size = m_Size - ( a_Size & ELEMENT_DIR_MASK ) ;
					}
					break ;
				}
			}
		}
		else
		{
			m_Size = m_Size - t_Size ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Initialize_OuterDir ( ULONG a_Size )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = ( a_Size >> OUTER_DIR_BIT_POS ) + 1 ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & m_OuterDir.m_InnerDir ,
		sizeof ( WmiInnerDir ) * t_Size
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
		{
			if ( t_Index == t_Size - 1 )
			{
				t_StatusCode = Initialize_InnerDir (

					a_Size & INNER_ELEMENT_DIR_MASK ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = Initialize_InnerDir (

					INNER_DIR_SIZE ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}

			if ( t_StatusCode != e_StatusCode_Success )
			{
				if ( t_Index != t_Size - 1 )
				{
					ULONG t_Remainder = t_Size - t_Index - 1 ;

					if ( t_Remainder )
					{
						m_Size = m_Size - ( ( t_Remainder - 1 ) * INNER_DIR_SIZE ) ;
					}

					m_Size = m_Size - ( a_Size & INNER_ELEMENT_DIR_MASK ) ;
				}

				break ;
			}

		}
	}
	else
	{
		m_Size = m_Size - t_Size ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Grow_ElementDir (

	ULONG a_Size ,
	ULONG a_NewSize ,
	WmiElementDir *a_ElementDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_NewSize )
	{
		if ( a_Size )
		{
			WmiElement *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) a_ElementDir->m_Block ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiElement ) * a_NewSize
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				a_ElementDir->m_Block = t_Tmp ;
			}
		}
		else
		{
			t_StatusCode = m_Allocator.New (

				( void ** ) & a_ElementDir->m_Block ,
				sizeof ( WmiElement ) * a_NewSize
			) ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( ULONG t_Index = a_Size ? a_Size : 0 ; t_Index < a_NewSize ; t_Index ++ )
			{
				WmiElement *t_Element = & ( a_ElementDir->m_Block ) [ t_Index ] ;
				:: new ( ( void * ) t_Element ) WmiElement () ;
			}
		}
		else
		{
			m_Size = m_Size - ( a_NewSize - a_Size ) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Grow_InnerDir (

	ULONG a_Size ,
	ULONG a_NewSize ,
	WmiInnerDir *a_InnerDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_OldSize = ( a_Size >> INNER_DIR_BIT_POS ) + 1 ;
	ULONG t_NewSize = ( a_NewSize >> INNER_DIR_BIT_POS ) + 1 ;

	if ( t_OldSize )
	{
		if ( t_OldSize != t_NewSize )
		{
			WmiElementDir *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) a_InnerDir->m_ElementDir ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiElementDir ) * t_NewSize
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				a_InnerDir->m_ElementDir = t_Tmp ;
			}
		}
	}
	else
	{
		if ( t_NewSize )
		{
			t_StatusCode = m_Allocator.New (

				( void ** ) & a_InnerDir->m_ElementDir ,
				sizeof ( WmiElementDir ) * t_NewSize
			) ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		for ( ULONG t_Index = t_OldSize ? t_OldSize - 1 : 0 ; t_Index < t_NewSize ; t_Index ++ )
		{
			if ( t_Index == t_OldSize - 1 )
			{
				if ( t_Index == t_NewSize - 1 )
				{
					t_StatusCode = Grow_ElementDir (

						a_Size & ELEMENT_DIR_MASK ,
						a_NewSize & ELEMENT_DIR_MASK ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}
				else
				{
					t_StatusCode = Grow_ElementDir (

						a_Size & ELEMENT_DIR_MASK ,
						ELEMENT_DIR_SIZE ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}
			}
			else
			{
				if ( t_Index == t_NewSize - 1 )
				{
					t_StatusCode = Grow_ElementDir (

						a_Size & ELEMENT_DIR_MASK  ,
						a_NewSize & ELEMENT_DIR_MASK ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}
				else
				{
					t_StatusCode = Grow_ElementDir (

						0 ,
						ELEMENT_DIR_SIZE ,
						& ( a_InnerDir->m_ElementDir [ t_Index ] )
					) ;
				}
			}

			if ( t_StatusCode != e_StatusCode_Success )
			{
				if ( t_Index != t_NewSize - 1 )
				{
					ULONG t_Remainder = t_NewSize - t_Index - 1 ;

					if ( t_Remainder )
					{
						m_Size = m_Size - ( ( t_Remainder - 1 ) * ELEMENT_DIR_SIZE ) ;
					}

					m_Size = m_Size - ( a_NewSize & ELEMENT_DIR_MASK ) ;
				}

				break ;
			}
		}
	}
	else
	{
		m_Size = m_Size - ( a_NewSize - a_Size ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Grow_OuterDir ( ULONG a_Size , ULONG a_NewSize )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_OldSize = ( a_Size >> OUTER_DIR_BIT_POS ) + 1 ;
	ULONG t_NewSize = ( a_NewSize >> OUTER_DIR_BIT_POS ) + 1 ;

	if ( t_OldSize )
	{
		if ( t_OldSize != t_NewSize )
		{
			WmiInnerDir *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) m_OuterDir.m_InnerDir ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiInnerDir ) * t_NewSize
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_OuterDir.m_InnerDir = t_Tmp ;
			}
		}
	}
	else
	{
		if ( t_NewSize )
		{
			t_StatusCode = m_Allocator.New (

				( void ** ) & m_OuterDir.m_InnerDir  ,
				sizeof ( WmiInnerDir ) * t_NewSize
			) ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		for ( ULONG t_Index = t_OldSize ? t_OldSize - 1 : 0 ; t_Index < t_NewSize ; t_Index ++ )
		{
			if ( t_Index == t_OldSize - 1 )
			{
				if ( t_Index == t_NewSize - 1 )
				{
					t_StatusCode = Grow_InnerDir (

						a_Size & INNER_ELEMENT_DIR_MASK ,
						a_NewSize & INNER_ELEMENT_DIR_MASK ,
						& ( m_OuterDir.m_InnerDir [ t_Index ] )
					) ;
				}
				else
				{
					t_StatusCode = Grow_InnerDir (

						a_Size & INNER_ELEMENT_DIR_MASK ,
						INNER_DIR_SIZE ,
						& ( m_OuterDir.m_InnerDir [ t_Index ] )
					) ;
				}
			}
			else
			{
				if ( t_Index == t_NewSize - 1 )
				{
					t_StatusCode = Grow_InnerDir (

						0 ,
						a_NewSize & INNER_ELEMENT_DIR_MASK ,
						& ( m_OuterDir.m_InnerDir [ t_Index ] )
					) ;
				}
				else
				{
					t_StatusCode = Grow_InnerDir (

						0 ,
						INNER_DIR_SIZE ,
						& ( m_OuterDir.m_InnerDir [ t_Index ] )
					) ;
				}
			}

			if ( t_StatusCode != e_StatusCode_Success )
			{
				if ( t_Index != t_NewSize - 1 )
				{
					ULONG t_Remainder = t_NewSize - t_Index - 1 ;

					if ( t_Remainder )
					{
						m_Size = m_Size - ( ( t_Remainder - 1 ) * INNER_DIR_SIZE ) ;
					}

					m_Size = m_Size - ( a_NewSize & INNER_ELEMENT_DIR_MASK ) ;
				}

				break ;
			}
		}
	}
	else
	{
		m_Size = m_Size - ( a_NewSize - a_Size ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: UnInitialize_ElementDir (

	ULONG a_Size ,
	WmiElementDir *a_ElementDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = a_Size ;

	if ( t_Size )
	{
		for ( ULONG t_Index = 0 ; t_Index < a_Size ; t_Index ++ )
		{
			WmiElement *t_Element = & ( a_ElementDir->m_Block ) [ t_Index ] ;
			t_Element->WmiElement :: ~WmiElement () ;
		}

		t_StatusCode = m_Allocator.Delete (

			( void * ) a_ElementDir->m_Block
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: UnInitialize_InnerDir (

	ULONG a_Size ,
	WmiInnerDir *a_InnerDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = ( a_Size >> INNER_DIR_BIT_POS ) + 1 ;

	if ( t_Size )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
		{
			if ( t_Index == t_Size - 1 )
			{
				t_StatusCode = UnInitialize_ElementDir (

					a_Size & ELEMENT_DIR_MASK ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = UnInitialize_ElementDir (

					ELEMENT_DIR_SIZE ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
		}

		t_StatusCode = m_Allocator.Delete (

			( void * ) a_InnerDir->m_ElementDir
		) ;

	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: UnInitialize_OuterDir ( ULONG a_Size )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Size = ( a_Size >> OUTER_DIR_BIT_POS ) + 1 ;

	if ( t_Size )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
		{
			if ( t_Index == t_Size - 1 )
			{
				t_StatusCode = UnInitialize_InnerDir (

					a_Size & INNER_ELEMENT_DIR_MASK ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = UnInitialize_InnerDir (

					INNER_DIR_SIZE ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
		}

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_OuterDir.m_InnerDir
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Shrink_ElementDir (

	ULONG a_Size ,
	ULONG a_NewSize ,
	WmiElementDir *a_ElementDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Size )
	{
		for ( ULONG t_Index = a_NewSize ; t_Index < a_Size ; t_Index ++ )
		{
			WmiElement *t_Element = & ( a_ElementDir->m_Block ) [ t_Index ] ;
			( t_Element )->WmiElement :: ~WmiElement () ;
		}

		if ( a_NewSize )
		{
			WmiElement *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) a_ElementDir->m_Block ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiElement ) * a_Size
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				a_ElementDir->m_Block = t_Tmp ;
			}
		}
		else
		{
			t_StatusCode = m_Allocator.Delete (

				( void ** ) a_ElementDir->m_Block
			) ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
		}
		else
		{
			m_Size = m_Size - ( a_NewSize - a_Size ) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Unknown ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Shrink_InnerDir (

	ULONG a_Size ,
	ULONG a_NewSize ,
	WmiInnerDir *a_InnerDir
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_OldSize = ( a_Size >> INNER_DIR_BIT_POS ) + 1 ;
	ULONG t_NewSize = ( a_NewSize >> INNER_DIR_BIT_POS ) + 1 ;

	for ( ULONG t_Index = t_NewSize - 1 ; t_Index < t_OldSize ; t_Index ++ )
	{
		if ( t_Index == t_OldSize - 1 )
		{
			if ( t_Index == t_NewSize - 1 )
			{
				t_StatusCode = Shrink_ElementDir (

					a_Size & ELEMENT_DIR_MASK ,
					a_NewSize & ELEMENT_DIR_MASK ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = Shrink_ElementDir (

					a_Size & ELEMENT_DIR_MASK ,
					ELEMENT_DIR_SIZE ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
		}
		else
		{
			if ( t_Index == t_NewSize - 1 )
			{
				t_StatusCode = Shrink_ElementDir (

					a_Size & ELEMENT_DIR_MASK  ,
					a_NewSize & ELEMENT_DIR_MASK ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = Shrink_ElementDir (

					ELEMENT_DIR_SIZE ,
					0 ,
					& ( a_InnerDir->m_ElementDir [ t_Index ] )
				) ;
			}
		}

		if ( t_StatusCode != e_StatusCode_Success )
		{
			if ( t_Index != t_NewSize - 1 )
			{
				ULONG t_Remainder = t_NewSize - t_Index - 1 ;

				if ( t_Remainder )
				{
					m_Size = m_Size - ( ( t_Remainder - 1 ) * ELEMENT_DIR_SIZE ) ;
				}

				m_Size = m_Size - ( a_NewSize & ELEMENT_DIR_MASK ) ;
			}

			break ;
		}
	}

	if ( t_OldSize )
	{
		if ( t_OldSize != t_NewSize )
		{
			WmiElementDir *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) a_InnerDir->m_ElementDir ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiElementDir ) * t_NewSize
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				a_InnerDir->m_ElementDir = t_Tmp ;
			}
		}
	}
	else
	{
		if ( t_NewSize )
		{
			t_StatusCode = m_Allocator.Delete (

				( void ** ) & a_InnerDir->m_ElementDir
			) ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode WmiArray <WmiElement> :: Shrink_OuterDir ( ULONG a_Size , ULONG a_NewSize )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_OldSize = ( a_Size >> OUTER_DIR_BIT_POS ) + 1 ;
	ULONG t_NewSize = ( a_NewSize >> OUTER_DIR_BIT_POS ) + 1 ;

	for ( ULONG t_Index = t_NewSize - 1 ; t_Index < t_OldSize ; t_Index ++ )
	{
		if ( t_Index == t_OldSize - 1 )
		{
			if ( t_Index == t_NewSize - 1 )
			{
				t_StatusCode = Shrink_InnerDir (

					a_Size & INNER_ELEMENT_DIR_MASK ,
					a_NewSize & INNER_ELEMENT_DIR_MASK ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = Shrink_InnerDir (

					a_Size & INNER_ELEMENT_DIR_MASK ,
					INNER_DIR_SIZE ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
		}
		else
		{
			if ( t_Index == t_NewSize - 1 )
			{
				t_StatusCode = Shrink_InnerDir (

					a_NewSize & INNER_ELEMENT_DIR_MASK ,
					0 ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
			else
			{
				t_StatusCode = Shrink_InnerDir (

					INNER_DIR_SIZE ,
					0 ,
					& ( m_OuterDir.m_InnerDir [ t_Index ] )
				) ;
			}
		}

		if ( t_StatusCode != e_StatusCode_Success )
		{
			if ( t_Index != t_NewSize - 1 )
			{
				ULONG t_Remainder = t_NewSize - t_Index - 1 ;

				if ( t_Remainder )
				{
					m_Size = m_Size - ( ( t_Remainder - 1 ) * INNER_DIR_SIZE ) ;
				}

				m_Size = m_Size - ( a_NewSize & INNER_ELEMENT_DIR_MASK ) ;
			}

			break ;
		}
	}

	if ( t_OldSize )
	{
		if ( t_OldSize != t_NewSize )
		{
			WmiInnerDir *t_Tmp = NULL ;

			t_StatusCode = m_Allocator.ReAlloc (

				( void * ) m_OuterDir.m_InnerDir ,
				( void ** ) & t_Tmp ,
				sizeof ( WmiInnerDir ) * t_NewSize
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_OuterDir.m_InnerDir = t_Tmp ;
			}
		}
	}
	else
	{
		if ( t_NewSize )
		{
			t_StatusCode = m_Allocator.Delete (

				( void ** ) & m_OuterDir.m_InnerDir
			) ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}
	}

	return t_StatusCode ;
}

#endif __ARRAY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\avltree.cpp ===
#ifndef _AVLTREE_CPP
#define _AVLTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <AvlTree.h>

#endif

#if 1
#define INLINE_COMPARE 
#endif
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiAvlTree <WmiKey,WmiElement> :: WmiAvlTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiAvlTree <WmiKey,WmiElement> :: ~WmiAvlTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiAvlNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAvlNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiAvlNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	if ( m_Root ) 
	{
		bool t_Increased ;

		WmiAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				return e_StatusCode_AlreadyExists ;
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						WmiAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							m_Size ++ ;

							t_Increased = true ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Left = t_AllocNode ;

							t_StatusCode = Insert_LeftBalance ( 

								t_Node ,
								t_Node->m_Left ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_Node->m_Parent ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{

						WmiAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;
					
							m_Size ++ ;

							t_Increased = true ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Right = t_AllocNode ;

							t_StatusCode = Insert_RightBalance ( 

								t_Node ,
								t_Node->m_Right ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_ParentNode ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		WmiAvlNode *t_AllocNode ;
		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & t_AllocNode ,
			sizeof ( WmiAvlNode ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

			try
			{
				t_AllocNode->m_Element = a_Element ;
				t_AllocNode->m_Key = a_Key ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_Unknown ;
			}

			a_Iterator = Iterator ( t_AllocNode ) ;

			m_Root = t_AllocNode ;

			m_Size ++ ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	if ( m_Root ) 
	{
		bool t_Decreased ;

		WmiAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
				if ( t_ParentNode )
				{
					bool t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;

					WmiStatusCode t_StatusCode = DeleteFixup ( t_Node , t_Decreased ) ;

					m_Size -- ;

					while ( t_Decreased )
					{
						if ( t_ParentNode )
						{
							if ( t_LeftSide )
							{
								t_StatusCode = Delete_LeftBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Right ,
									t_Decreased 
								) ;
							}
							else
							{
								t_StatusCode = Delete_RightBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Left ,
									t_Decreased 
								) ;
							}

							t_Node = t_ParentNode ;
							t_ParentNode = t_Node->m_Parent ;
							if ( t_ParentNode )
							{
								t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;
							}
						}
						else
						{
							return e_StatusCode_Success ;
						}
					}

					return e_StatusCode_Success ;
				}
				else
				{
					m_Size -- ;

					return DeleteFixup ( t_Node , t_Decreased ) ;
				}
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		return e_StatusCode_NotFound  ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ).Increment () ;

			return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				if ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ) ;
					
					return e_StatusCode_Success ;
				}
			}
			else
			{
				if ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ).Increment () ;

					return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
				}
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Check ( ULONG & a_MaxHeight )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 0
	printf ( "\nStart Check ( %ld )" , m_Size ) ;
#endif
	if ( m_Root )
	{
		if ( m_Root->m_Parent == NULL )
		{
			ULONG t_Count = 1 ;
			ULONG t_Height = 0 ;
			a_MaxHeight = 0 ;
			t_StatusCode = RecursiveCheck ( m_Root , t_Count , t_Height , a_MaxHeight ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( t_Count != m_Size )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_Failed ;
		}
	}

#if 0
	printf ( "\nEnd Check" ) ;
#endif

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert_LeftBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Increased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_LeftHigher ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *C = A->m_Left->m_Right ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_LeftHigher ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert_RightBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Increased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_RightHigher ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *C = A->m_Right->m_Left ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						B->m_Left = C->m_Right ;
						A->m_Right = C->m_Left ;

						C->m_Right = B ;
						C->m_Left = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_RightHigher ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;		
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete_LeftBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Decreased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_RightHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_RightHigher ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_LeftHigher ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *C = A->m_Right->m_Left ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						A->m_Right = C->m_Left ;
						B->m_Left = C->m_Right ;

						C->m_Left = A ;
						C->m_Right = B ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								A->m_State = WmiAvlNode :: e_Equal ;
								B->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete_RightBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Decreased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_LeftHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_LeftHigher ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_RightHigher ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *C = A->m_Left->m_Right ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								A->m_State = WmiAvlNode :: e_Equal ;
								B->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveCheck ( 

	WmiAvlNode *a_Node ,
	ULONG &a_Count ,
	ULONG a_Height ,
	ULONG &a_MaxHeight
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Height ++ ;

#if 0
	printf ( "\n" ) ;
	for ( ULONG t_TabIndex = 0 ; t_TabIndex < a_Height ; t_TabIndex ++ ) 
	{
		printf ( "++++" ) ;
	}

	printf ( "%ld" , a_Node->m_Key ) ;

	switch ( a_Node->m_State )
	{
		case WmiAvlNode :: e_LeftHigher:
		{
			printf ( "\t LH" ) ;
		}
		break ;

		case WmiAvlNode :: e_RightHigher:
		{
			printf ( "\t RH" ) ;
		}
		break ;

		case WmiAvlNode :: e_Equal:
		{
			printf ( "\t E" ) ;
		}
		break ;
	}

#endif

	if ( t_StatusCode == e_StatusCode_Success )
	{
		ULONG t_LeftHeight = a_Height ;

		WmiAvlNode *t_Left = a_Node->m_Left ;
		if ( t_Left )
		{
			if ( t_Left->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Left , a_Count , a_Height , t_LeftHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}
	
		ULONG t_RightHeight = a_Height ;

		WmiAvlNode *t_Right = a_Node->m_Right ;
		if ( t_Right )
		{
			if ( t_Right->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Right , a_Count , a_Height , t_RightHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}

		switch ( a_Node->m_State )
		{
			case WmiAvlNode :: e_LeftHigher:
			{
				if ( t_LeftHeight <= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				if ( t_LeftHeight >= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiAvlNode :: e_Equal:
			{
				if ( t_LeftHeight != t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;
		}

		if ( t_LeftHeight < t_RightHeight )
		{
			a_MaxHeight = t_RightHeight ;
		}
		else
		{
			a_MaxHeight = t_LeftHeight ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( a_Node->m_State == WmiAvlNode :: e_Equal )
		{
			if ( ( ( a_Node->m_Left == 0 ) && ( a_Node->m_Right == 0 ) ) )
			{
			}
			else if ( ! ( a_Node->m_Left && a_Node->m_Right ) )
			{
				t_StatusCode = e_StatusCode_Failed ;
			} 
		}

		if ( a_Node->m_State == WmiAvlNode :: e_LeftHigher )
		{
			if ( a_Node->m_Left == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}

		if ( a_Node->m_State == WmiAvlNode :: e_RightHigher )
		{
			if ( a_Node->m_Right == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
	}
 	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *		case 1:
 *
 *						 N					     A
 *						/ \
 *					   A                 ->	
 *			
 *					Parent Decreased,on side based on recursion step
 *
 *		case 2:
 *
 *						 N						A
 *						/ \
 *					       A			->
 *
 *				Parent Decreased,on side based on recursion step
 *
 *		case 3:
 *						 N						B
 *						/ \					   / \
 *					   A   B            ->    A	  Y
 *                        / \
 *                           Y
 *
 *				B decreased on Right
 *
 *		case 4:
 *
 *						 N						B
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  X   Y 
 *                        \
 *                         X
 *
 *				C decreased on Left, Apply LeftBalance on C
 *				Apply RightBalance on B
 * 
 *						 N						D
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  B   Y 
 *                      / \                    / \
 *                     D   X                  E   X
 *                      \
 *                       E
 *
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: DeleteFixup ( WmiAvlNode *a_Node , bool &a_Decreased )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Decreased = true ;

	WmiAvlNode *t_Left = a_Node->m_Left ;
	WmiAvlNode *t_Right = a_Node->m_Right ;
	WmiAvlNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiAvlNode *t_Successor = t_Iterator.m_Node ;

		t_Successor->m_State = a_Node->m_State ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
/* case 4 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiAvlNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
 
			do
			{
				t_StatusCode = Delete_LeftBalance ( t_Node , t_Node->m_Right , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif

				t_Node = t_Node->m_Parent ;
			}
			while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Node != t_Successor ) ) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = Delete_RightBalance ( t_Node , t_Node->m_Left , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif
			}
		}
		else
		{
/* case 3 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;

			t_StatusCode = Delete_RightBalance ( t_Successor , t_Successor->m_Left , a_Decreased ) ;
		}
	}
	else
	{
		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}

		if ( t_Left )
		{
/* case 1 */

			t_Left->m_Parent = a_Node->m_Parent ;
			t_Left->m_State = a_Node->m_State ;

			t_StatusCode = Delete_LeftBalance ( t_Left , t_Left->m_Right , a_Decreased ) ;
		}
		else if ( t_Right )
		{
/* case 2 */

			t_Right->m_Parent = a_Node->m_Parent ;
			t_Right->m_State = a_Node->m_State ;

			t_StatusCode = Delete_RightBalance ( t_Right , t_Right->m_Left , a_Decreased ) ;
		}
	}

	a_Node->~WmiAvlNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Merge ( 

	WmiAvlTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Iterator t_Iterator = a_Tree.Root ();

	while ( ( ! t_Iterator.Null () ) && ( t_StatusCode == e_StatusCode_Success ) )
	{
		Iterator t_InsertIterator ;
		t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}


#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAvlNode *t_AllocNode = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_AllocNode ,
		sizeof ( WmiAvlNode ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

		try
		{
			t_AllocNode->m_Element = a_Element ;
			t_AllocNode->m_Key = a_Key ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_AllocNode->~WmiAvlNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			t_AllocNode->~WmiAvlNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_Unknown
		}

		a_Iterator = Iterator ( t_Node ) ;

		if ( m_Root ) 
		{
			bool a_Increased ;

			t_StatusCode = RecursiveInsert ( 

				m_Root ,
				t_AllocNode ,
				a_Increased 
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_Size ++ ;
			}
			else
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;
			}
		}
		else
		{
			m_Root = t_Node ;

			m_Size ++ ;
		}
	}
	else
	{
		a_Iterator = Iterator () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveInsert ( 

	WmiAvlNode *a_Node , 
	WmiAvlNode *a_Element ,
	bool &a_Increased 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Increased = false ;

#ifdef INLINE_COMPARE
	LONG t_Compare = CompareElement ( a_Element->m_Key  , a_Node->m_Key ) ;
	if ( t_Compare == 0 )
#else
	if ( a_Key == t_Node->m_Key )
#endif
	{
		t_StatusCode = e_StatusCode_AlreadyExists ;
	}
	else 
	{
#ifdef INLINE_COMPARE
		if ( t_Compare < 0 )
#else
		if ( a_Key < t_Node->m_Key )
#endif

		{
			if ( a_Node->m_Left )
			{
				t_StatusCode = RecursiveInsert ( a_Node->m_Left , a_Element , a_Increased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Insert_LeftBalance ( 

						a_Node ,
						a_Node->m_Left ,
						a_Increased 
					) ;
				}
			}
			else
			{
				a_Increased = true ;

				a_Element->m_Parent = a_Node ;
				a_Node->m_Left = a_Element ;

				t_StatusCode = Insert_LeftBalance ( 

					a_Node ,
					a_Node->m_Left ,
					a_Increased 
				) ;
			}
		}
		else
		{
			if ( a_Node->m_Right )
			{
				t_StatusCode = RecursiveInsert ( a_Node->m_Right , a_Element , a_Increased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Insert_RightBalance ( 

						a_Node ,
						a_Node->m_Right ,
						a_Increased 
					) ;
				}
			}
			else
			{
				a_Increased = true ;

				a_Element->m_Parent = a_Node ;
				a_Node->m_Right = a_Element ;

				t_StatusCode = Insert_RightBalance ( 

					a_Node ,
					a_Node->m_Right ,
					a_Increased 
				) ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		bool t_Decreased = false ;
		t_StatusCode = RecursiveDelete ( m_Root , a_Key , t_Decreased ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Size -- ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveDelete ( 

	WmiAvlNode *a_Node , 
	const WmiKey &a_Key ,
	bool &a_Decreased 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_NotFound ;

#ifdef INLINE_COMPARE
	LONG t_Compare = CompareElement ( a_Key , a_Node->m_Key ) ;
	if ( t_Compare == 0 )
#else
	if ( a_Key == t_Node->m_Key )
#endif
	{
		t_StatusCode = DeleteFixup ( a_Node , a_Decreased ) ;
	}
	else 
	{
#ifdef INLINE_COMPARE
		if ( t_Compare < 0 )
#else
		if ( a_Key < t_Node->m_Key )
#endif
		{
			if ( a_Node->m_Left )
			{
				t_StatusCode = RecursiveDelete ( a_Node->m_Left , a_Key , a_Decreased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Delete_LeftBalance ( a_Node , a_Node->m_Right , a_Decreased ) ;
				}
			}
		}
		else
		{
			if ( a_Node->m_Right )
			{
				t_StatusCode = RecursiveDelete ( a_Node->m_Right , a_Key , a_Decreased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Delete_RightBalance ( a_Node , a_Node->m_Left , a_Decreased ) ;
				}
			}
		}
	}

	return t_StatusCode ;
}

#endif

#endif _AVLTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\hashtable.cpp ===
#ifndef __HASHTABLE_CPP
#define __HASHTABLE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <HashTable.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiHashTable <WmiKey,WmiElement,HashSize> :: WmiHashTable ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) , m_Buckets ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiHashTable <WmiKey,WmiElement,HashSize> :: ~WmiHashTable ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_Buckets )
	{
		t_StatusCode = m_Allocator.New (

			( void ** ) & m_Buckets ,
			sizeof ( WmiBasicTree <WmiKey,WmiElement> ) * HashSize
		) ;
		
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( ULONG t_Index = 0 ; t_Index < HashSize ; t_Index ++ )
			{
				:: new ( ( void * ) & m_Buckets [ t_Index ] ) WmiBasicTree <WmiKey,WmiElement> ( m_Allocator ) ;
			}
		}
		else
		{
			m_Buckets = NULL ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		for ( ULONG t_Index = 0 ; t_Index < HashSize ; t_Index ++ )
		{
			m_Buckets [ t_Index ].WmiBasicTree <WmiKey,WmiElement> :: ~WmiBasicTree <WmiKey,WmiElement> () ;
		}

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Buckets
		) ;

		m_Buckets = NULL;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;

		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;
		t_StatusCode = t_Tree->Insert ( a_Key , a_Element ,t_Iterator ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;
		t_StatusCode = t_Tree->Delete ( a_Key ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Find (

	const WmiKey &a_Key ,
	WmiElement &a_Element 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;

		WmiBasicTree <WmiKey,WmiElement> :: Iterator a_Iterator ;		
		t_StatusCode = t_Tree->Find ( a_Key , a_Iterator ) ;
		a_Element = a_Iterator.GetElement () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}
	
	return t_StatusCode ;
}

#endif __HASHTABLE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\basictree.cpp ===
#ifndef __BasicTREE_CPP
#define __BasicTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <BasicTree.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiBasicTree <WmiKey,WmiElement> :: WmiBasicTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiBasicTree <WmiKey,WmiElement> :: ~WmiBasicTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiBasicNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiBasicNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiBasicNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiBasicNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	if ( m_Root )
	{
		WmiBasicNode *t_Node = m_Root ;
		while ( t_Node )
		{
			LONG t_Compare = CompareElement ( a_Key  , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
			{
				return e_StatusCode_AlreadyExists ;
			}
			else 
			{
				if ( t_Compare < 0 )
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						WmiBasicNode *t_AllocNode ;

						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiBasicNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Left = t_AllocNode ;

							m_Size ++ ;
						}

						return t_StatusCode ;
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{
						WmiBasicNode *t_AllocNode ;

						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiBasicNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Right = t_AllocNode ;

							m_Size ++ ;
						}

						return t_StatusCode ;
					}
				}
			}
		}
		
		return e_StatusCode_Failed ;
	}
	else
	{
		WmiBasicNode *t_AllocNode ;

		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & t_AllocNode ,
			sizeof ( WmiBasicNode ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

			try
			{
				t_AllocNode->m_Element = a_Element ;
				t_AllocNode->m_Key = a_Key ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_AllocNode->~WmiBasicNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				t_AllocNode->~WmiBasicNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_Unknown ;
			}

			a_Iterator = Iterator ( t_AllocNode ) ;

			m_Root = t_AllocNode ;

			m_Size ++ ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			m_Size -- ;
			return DeleteFixup ( t_Node ) ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			a_Iterator = Iterator ( t_Node ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			a_Iterator = Iterator ( t_Node ).Increment () ;
			return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ; ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				if ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ) ;
					
					return e_StatusCode_Success ;
				}
			}
			else
			{
				if ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ).Increment () ;
					return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
				}
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: DeleteFixup ( WmiBasicNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicNode *t_Left = a_Node->m_Left ;
	WmiBasicNode *t_Right = a_Node->m_Right ;
	WmiBasicNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiBasicNode *t_Successor = t_Iterator.m_Node ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiBasicNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
		else
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
	}
	else
	{
		if ( t_Left )
		{
			t_Left->m_Parent = a_Node->m_Parent ;
		}
		else if ( t_Right )
		{
			t_Right->m_Parent = a_Node->m_Parent ;
		}

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}
	}

	a_Node->~WmiBasicNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Merge ( 

	WmiBasicTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Iterator t_Iterator = a_Tree.Root ();

	while ( ( ! t_Iterator.Null () ) && ( t_StatusCode == e_StatusCode_Success ) )
	{
		Iterator t_InsertIterator ;
		t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}


#endif __BasicTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cache.cpp ===
#ifndef __CACHE_CPP
#define __CACHE_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Thread.cpp

Abstract:

	Enhancements to current functionality: 

		Timeout mechanism should track across waits.
		AddRef/Release on task when scheduling.
		Enhancement Ticker logic.

History:

--*/

#include <HelperFuncs.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
LONG operator == ( const WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg1 , const WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
	{
		t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
	}

	return t_Compare == 0 ? true : false ;
}

template <class WmiKey>
bool operator < ( const WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg1 , const WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
	{
		t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
	}

	return t_Compare < 0 ? true : false ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiCacheController <WmiKey> :: WmiCacheController (

	WmiAllocator &a_Allocator

) : m_Allocator ( a_Allocator ) ,
	m_Cache ( a_Allocator ) ,
	m_CacheDecay ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Counter ( 0 ),
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiCacheController <WmiKey> :: ~WmiCacheController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiCacheController <WmiKey> :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiCacheController <WmiKey> :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP WmiCacheController <WmiKey> :: QueryInterface ( REFIID , LPVOID FAR * ) 
{
	return E_NOINTERFACE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Cache.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CacheDecay.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Cache.UnInitialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CacheDecay.UnInitialize () ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Insert ( 

	WmiCacheElement &a_Element ,
	Cache_Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Lock () ;

	Cache_Iterator t_Iterator ;
	t_StatusCode = m_Cache.Insert ( a_Element.GetKey () , & a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element.InternalAddRef () ;
		a_Element.SetCached ( TRUE ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Delete ( 

	const WmiKey &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Cache.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Find ( 

	const WmiKey &a_Key , 
	Cache_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->AddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Lock ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: UnLock ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Shutdown ()
{
	Lock () ;

	ULONG t_Index = 0 ;
	while ( true )
	{
		WmiUniqueTimeout t_Key ;
		WmiCacheElement *t_Element = NULL ;

		WmiStatusCode t_StatusCode = m_CacheDecay.Top ( t_Key , t_Element ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_Index ++ ;

			t_StatusCode = m_CacheDecay.DeQueue () ;
		}
		else
		{
			break ;
		}
	}

	ULONG t_ElementCount = m_Cache.Size () ;

	WmiCacheElement **t_Elements = NULL ;
	WmiStatusCode t_StatusCode = m_Allocator.New (

		( void ** ) & t_Elements ,
		sizeof ( WmiCacheElement )  * t_ElementCount 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_ElementCount ; t_Index ++ )
		{
			t_Elements [ t_Index ] = NULL ;
		}

		ULONG t_ElementIndex = 0 ;

		Cache_Iterator t_Iterator = m_Cache.Root ();
		while ( ! t_Iterator.Null () )
		{
			if ( t_Iterator.GetElement ()->GetDecayed () == FALSE )
			{
				WmiCacheElement *t_Element = t_Iterator.GetElement () ;
				t_Elements [ t_ElementIndex ] = t_Element ;

				t_Element->SetDecayed ( TRUE ) ;
				t_Element->SetDecaying ( FALSE ) ;
				t_Element->SetCached ( FALSE ) ;

				m_Cache.Delete ( t_Iterator.GetKey () ) ;
			}
			else
			{
				m_Cache.Delete ( t_Iterator.GetKey () ) ;
			}

			t_ElementIndex ++ ;

			t_Iterator = m_Cache.Root () ;
		}
	}

	UnLock () ;

	if ( t_Elements )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_ElementCount ; t_Index ++ )
		{
			if ( t_Elements [ t_Index ] )
			{
				t_Elements [ t_Index ]->InternalRelease () ;
			}
		}

		m_Allocator.Delete ( t_Elements ) ;
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Shutdown ( const WmiKey &a_Key )
{
	Lock () ;

	Cache_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( t_Iterator.GetElement ()->GetDecayed () == FALSE )
		{
			CacheDecay_Iterator t_QueueIterator = m_CacheDecay.Begin () ;
			while ( ! t_QueueIterator.Null () ) 
			{
				WmiCacheElement *t_Element = t_QueueIterator.GetElement () ;
				if ( t_Element == t_Iterator.GetElement () )
				{
					m_CacheDecay.Delete ( t_QueueIterator.GetKey () ) ;
					break ;
				}

				t_QueueIterator.Increment () ;
			}

			WmiCacheElement *t_Element = t_Iterator.GetElement () ;
			t_Element->SetDecayed ( TRUE ) ;
			t_Element->SetDecaying ( FALSE ) ;
			t_Element->SetCached ( FALSE ) ;

			m_Cache.Delete ( a_Key ) ;

			UnLock () ;

			t_Element->InternalRelease () ;
		}
		else
		{
			m_Cache.Delete ( a_Key ) ;

			UnLock () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return e_StatusCode_Success ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: StrobeBegin ( const ULONG &a_Timeout )
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Strobe ( ULONG &a_NextStrobeDelta )
{
	while ( true )
	{
		Lock () ;

		WmiUniqueTimeout t_Key ;
		WmiCacheElement *t_Element = NULL ;

		WmiStatusCode t_StatusCode = m_CacheDecay.Top ( t_Key , t_Element ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_NextStrobeDelta = ( a_NextStrobeDelta < t_Element->GetPeriod () ) ? a_NextStrobeDelta : t_Element->GetPeriod () ;

			ULONG t_Ticks = GetTickCount () ;

#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Checking ( %lx , %lx ) " , t_Ticks , t_Element , t_Key.GetTicks () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

			if ( t_Ticks >= t_Key.GetTicks () ) 
			{
				if ( t_Element->GetDecaying () )
				{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Strobe ( %lx , %lx ) " , t_Ticks , t_Element , t_Key.GetTicks () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

					t_Element->SetDecaying ( FALSE ) ;
					t_Element->SetDecayed ( TRUE ) ; 

					t_StatusCode = m_CacheDecay.DeQueue () ;

					UnLock () ;

					t_Element->InternalRelease () ;
				}
				else
				{
					t_StatusCode = m_CacheDecay.DeQueue () ;

					UnLock () ;
				}
			}
			else
			{
				UnLock () ;
				break ;
			}
		}
		else
		{
			UnLock () ;
			break ;
		}
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Decay ( 

	WmiCacheElement &a_Element
)
{
	Lock () ;

	ULONG t_Size = m_CacheDecay.Size () ;

	Cache_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Element.GetKey () , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		BOOL t_Found = FALSE ;
		CacheDecay_Iterator t_QueueIterator = m_CacheDecay.Begin () ;
		while ( ! t_QueueIterator.Null () ) 
		{
			WmiCacheElement *t_Element = t_QueueIterator.GetElement () ;
			if ( t_Element == & a_Element )
			{
				m_CacheDecay.Delete ( t_QueueIterator.GetKey () ) ;
				break ;
			}

			t_QueueIterator.Increment () ;
		}

		ULONG t_Ticks = GetTickCount () ;
		WmiUniqueTimeout t_Key (

			t_Ticks + a_Element.GetPeriod () , 
			InterlockedIncrement ( & m_Counter )
		) ;

#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Decaying ( %lx , %lx , %lx ) " , t_Ticks , & a_Element , t_Ticks + a_Element.GetPeriod () , a_Element.GetPeriod () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

		t_StatusCode = m_CacheDecay.EnQueue ( 
	
			t_Key , 
			t_Iterator.GetElement ()
		) ;

		UnLock () ;

		if ( t_Size == 0 )
		{
			StrobeBegin ( a_Element.GetPeriod () ) ;
		}

		if ( t_StatusCode != e_StatusCode_Success )
		{
			a_Element.InternalRelease () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiContainerController <WmiKey> :: WmiContainerController (

	WmiAllocator &a_Allocator

) : m_Container ( a_Allocator ) ,
	m_ReferenceCount ( 0 ),
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiContainerController <WmiKey> :: ~WmiContainerController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiContainerController <WmiKey> :: AddRef () 
{
	return  InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiContainerController <WmiKey> :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP WmiContainerController <WmiKey> :: QueryInterface ( REFIID , LPVOID FAR * ) 
{
	return E_NOINTERFACE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Container.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Container.UnInitialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Insert ( 

	WmiContainerElement &a_Element ,
	Container_Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Lock () ;

	Container_Iterator t_Iterator ;
	t_StatusCode = m_Container.Insert ( a_Element.GetKey () , & a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element.InternalAddRef () ;
		a_Element.SetCached ( TRUE ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Delete ( 

	const WmiKey &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Find ( 

	const WmiKey &a_Key , 
	Container_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->AddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Lock ()
{
	return WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: UnLock ()
{
	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Shutdown ()
{
	Lock () ;

	Container_Iterator t_Iterator = m_Container.Root ();

	while ( ! t_Iterator.Null () )
	{
		m_Container.Delete ( t_Iterator.GetKey () ) ;

		t_Iterator = m_Container.Root () ;
	}

	UnLock () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Strobe ( ULONG &a_NextStrobeDelta )
{
	return e_StatusCode_Success ;
}

#endif __CACHE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\bptree.cpp ===
#ifndef _BPLUSTREE_CPP
#define _BPLUSTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <BPTree.h>

#endif

#if 0
#define INSERT_DEBUG
#define DELETE_DEBUG
#define FIND_DEBUG
#define COMMON_DEBUG
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiBPlusTree :: WmiBPlusTree ( 

	WmiAllocator &a_Allocator ,
	WmiBlockInterface &a_BlockAllocator ,
	GUID &a_Identifier ,
	ULONG a_BlockSize ,
	ULONG a_KeyType ,
	ULONG a_KeyTypeLength ,
	ComparatorFunction a_ComparatorFunction ,
	void *a_ComparatorOperand

) :	m_Allocator ( a_Allocator ) ,
	m_BlockAllocator ( a_BlockAllocator ) ,
	m_Size ( 0 ) ,
	m_Root ( 0 ) ,
	m_Identifier ( a_Identifier ) ,
	m_BlockSize ( a_BlockSize ) ,
	m_KeyType ( a_KeyType ) ,
	m_KeyTypeLength ( a_KeyTypeLength ) ,
	m_ComparatorFunction ( a_ComparatorFunction ) ,
	m_ComparatorOperand ( a_ComparatorOperand )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiBPlusTree :: ~WmiBPlusTree ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RecursiveUnInitialize ( WmiAbsoluteBlockOffSet &a_BlockOffSet )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiBPlusTree :: Recurse () 
{
	OutputDebugString ( L"\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) ;
	if ( m_Root )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , m_Root , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			Recurse ( t_Node , m_Root ) ;

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}
	OutputDebugString ( L"\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiBPlusTree :: Recurse ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	wchar_t t_StringBuffer [ 1024 ] ;
	swprintf ( t_StringBuffer , L"\n(%I64x)" , a_BlockOffSet ) ;
	OutputDebugString ( t_StringBuffer ) ;

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	if ( t_Leaf )
	{
		if ( a_BlockOffSet == m_Root )
		{
		}
		else
		{
			if ( a_Node->GetNodeSize () < ( MaxLeafKeys () >> 1 ) )
			{
				OutputDebugString ( L"\nInvalid Leaf Balance" ) ;
			}
		}

		for ( ULONG t_Index = t_NodeStart ; t_Index < t_NodeSize ; t_Index ++ )
		{
			BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;
			WmiBPKey t_Key ( t_Buffer , GetKeyTypeLength () ) ;

#if 0
			wchar_t t_StringBuffer [ 1024 ] ;
			swprintf ( t_StringBuffer , L"\nKey = %I64x" , * ( UINT64 * ) t_Key.GetConstData () ) ;
			OutputDebugString ( t_StringBuffer ) ;
#endif

			t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
		}	
	}
	else
	{
		if ( a_BlockOffSet == m_Root )
		{
		}
		else
		{
			if ( a_Node->GetNodeSize () < ( MaxKeys () >> 1 ) )
			{
				OutputDebugString ( L"\nInvalid Balance" ) ;
			}
		}

		for ( ULONG t_Index = t_NodeStart ; t_Index <= t_NodeSize ; t_Index ++ )
		{
			BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;

			WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

			CopyMemory (

				( BYTE * ) & t_ChildOffSet ,
				( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
				sizeof ( WmiAbsoluteBlockOffSet ) 
			) ;

			wchar_t t_StringBuffer [ 1024 ] ;
			swprintf ( t_StringBuffer , L"\t(%I64x)" , t_ChildOffSet ) ;
			OutputDebugString ( t_StringBuffer ) ;

			t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
		}	

		t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;
		for ( t_Index = t_NodeStart ; t_Index <= t_NodeSize ; t_Index ++ )
		{
			BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;

			WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

			CopyMemory (

				( BYTE * ) & t_ChildOffSet ,
				( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
				sizeof ( WmiAbsoluteBlockOffSet ) 
			) ;

			BYTE *t_Block = NULL ;
			t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ChildOffSet , t_Block ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

				Recurse (

					t_Node ,
					t_ChildOffSet
				) ;

				m_BlockAllocator.ReleaseBlock ( t_Block ) ;
			}

			if ( t_Index < t_NodeSize )
			{
#if 0
				WmiBPKey t_Key ( t_Buffer , GetKeyTypeLength () ) ;
				wchar_t t_StringBuffer [ 1024 ] ;
				swprintf ( t_StringBuffer , L"\nKey = %I64x" , * ( UINT64 * ) t_Key.GetConstData () ) ;
				OutputDebugString ( t_StringBuffer ) ;
#endif
			}

			t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
		}	
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiBPlusTree :: PrintNode (

	wchar_t *a_Prefix ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet
)
{
	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;
	ULONG t_KeyPtrOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_KeyPtrOffSet = WmiBlockKeyPointerOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	OutputDebugString ( L"\n======================================" ) ;
	OutputDebugString ( a_Prefix ) ;

	if ( t_Leaf )
	{
		OutputDebugString ( L"\nLeaf" ) ;

		if ( a_BlockOffSet == m_Root )
		{
			OutputDebugString ( L"\nRoot" ) ;
		}
		else
		{
			if ( a_Node->GetNodeSize () < ( MaxLeafKeys () >> 1 ) )
			{
				OutputDebugString ( L"\nInvalid Balance" ) ;
			}
		}
	}
	else
	{
		OutputDebugString ( L"\nInternal" ) ;
		if ( a_BlockOffSet == m_Root )
		{
			OutputDebugString ( L"\nRoot" ) ;
		}
		else
		{
			if ( a_Node->GetNodeSize () < ( MaxKeys () >> 1 ) )
			{
				OutputDebugString ( L"\nInvalid Balance" ) ;
			}
		}
	}

	wchar_t t_StringBuffer [ 1024 ] ;
	swprintf ( t_StringBuffer , L"\n%I64x" , a_BlockOffSet ) ;
	OutputDebugString ( t_StringBuffer ) ;
	OutputDebugString ( L"\n--------------------------------------" ) ;

	for ( ULONG t_Index = t_NodeStart ; t_Index < t_NodeSize ; t_Index ++ )
	{
		BYTE *t_KeyBuffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;

		if ( t_Leaf )
		{
			WmiBPElement t_Element = 0 ;

			CopyMemory (

				( BYTE * ) & t_Element ,
				( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockLeafKeyElementOffSet ,
				sizeof ( WmiAbsoluteBlockOffSet ) 
			) ;

			swprintf ( 

				t_StringBuffer , 
				L"\n(%I64x,%I64x)" , 
				* ( UINT64 * ) t_KeyBuffer ,
				t_Element 
			) ;
		}
		else
		{
			BYTE *t_LeftPointerBuffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyPtrOffSet ;
			BYTE *t_RightPointerBuffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyPtrOffSet + t_InternalKeySize ;

			WmiBPElement t_Element = 0 ;

			CopyMemory (

				( BYTE * ) & t_Element ,
				( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyElementOffSet ,
				sizeof ( WmiAbsoluteBlockOffSet ) 
			) ;

			swprintf (

				t_StringBuffer , 
				L"\n(%I64x),(%I64x,%I64x),(%I64x)" , 
				* ( UINT64 * ) t_LeftPointerBuffer ,
				* ( UINT64 * ) t_KeyBuffer ,
				t_Element ,
				* ( UINT64 * ) t_RightPointerBuffer
			) ;
		}

		OutputDebugString ( t_StringBuffer ) ;
		t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
	}

	OutputDebugString ( L"\n======================================" ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: PositionInBlock ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	ULONG &a_NodeIndex ,
	WmiRelativeBlockOffSet &a_NodeOffSet ,
	WmiAbsoluteBlockOffSet &a_ChildOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#ifdef COMMON_DEBUG
	PrintNode ( L"\nFindNextInBlock" , a_Node , a_BlockOffSet ) ;
#endif

	ULONG t_InternalKeySize = GetKeyTypeLength () ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	WmiRelativeBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;	
	t_BlockOffSet = t_BlockOffSet + t_NodeStart * t_InternalKeySize + a_NodeIndex * t_InternalKeySize ;

	if ( t_Leaf )
	{
		if ( a_NodeIndex < t_NodeSize )
		{
			a_NodeOffSet = t_BlockOffSet ;

			a_ChildOffSet = 0 ;
		}
		else
		{
			t_StatusCode = e_StatusCode_NotFound ;
		}
	}
	else
	{
		if ( a_NodeIndex <= t_NodeSize )
		{
			CopyMemory (

				( BYTE * ) & a_ChildOffSet ,
				( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
				sizeof ( WmiAbsoluteBlockOffSet ) 
			) ;

			if ( a_NodeIndex < t_NodeSize )
			{
				a_NodeOffSet = t_BlockOffSet ;
			}
			else
			{
				a_NodeOffSet = 0 ;
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_NotFound ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: GetKeyElement ( 

	WmiBPKeyNode *a_Node ,
	const WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const ULONG &a_NodeIndex ,
	Iterator &a_Iterator
)
{
	ULONG t_InternalKeySize = GetKeyTypeLength () ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}
	
	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	WmiRelativeBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;	
	t_BlockOffSet = t_BlockOffSet + t_NodeStart * t_InternalKeySize + a_NodeIndex * t_InternalKeySize ;

	if ( t_Leaf )
	{
		CopyMemory (

			( BYTE * ) & a_Iterator.GetElement () ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockLeafKeyElementOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		CopyMemory (

			( BYTE * ) a_Iterator.GetKey ().GetData () ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockLeafKeyOffSet ,
			GetKeyTypeLength () 
		) ;
	}
	else
	{
		CopyMemory (

			( BYTE * ) & a_Iterator.GetElement () ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyElementOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		CopyMemory (

			( BYTE * ) a_Iterator.GetKey ().GetData () ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyOffSet ,
			GetKeyTypeLength () 
		) ;
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: LeftMost ( 

	Iterator &a_Iterator
)
{
	WmiStack <IteratorPosition,8> &t_Stack = a_Iterator.GetStack () ;
	ULONG t_NodeIndex = a_Iterator.GetNodeIndex () ;
	WmiAbsoluteBlockOffSet t_BlockOffSet = a_Iterator.GetNodeOffSet () ;

	WmiRelativeBlockOffSet t_NodeOffSet = 0 ;
	WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	do
	{
		BYTE *t_Block = NULL ;
		t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_BlockOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			t_StatusCode = PositionInBlock ( 

				t_Node ,
				t_BlockOffSet , 
				t_NodeIndex ,
				t_NodeOffSet ,
				t_ChildOffSet
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( t_ChildOffSet )
				{
					t_StatusCode = t_Stack.Push ( IteratorPosition ( t_BlockOffSet , t_NodeIndex ) ) ;
				}
				else
				{
					a_Iterator.SetNodeIndex ( t_NodeIndex ) ;
					a_Iterator.SetNodeOffSet ( t_BlockOffSet ) ;

					t_StatusCode = GetKeyElement ( t_Node , t_BlockOffSet , t_NodeIndex , a_Iterator ) ;
				}
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;

			t_NodeIndex = 0 ;
			t_BlockOffSet = t_ChildOffSet ;
		}

	} while ( ( t_StatusCode == e_StatusCode_Success ) && t_ChildOffSet ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RightMost ( 

	Iterator &a_Iterator
)
{
	WmiStack <IteratorPosition,8> &t_Stack = a_Iterator.GetStack () ;
	ULONG t_NodeIndex = a_Iterator.GetNodeIndex () ;
	WmiAbsoluteBlockOffSet t_BlockOffSet = a_Iterator.GetNodeOffSet () ;

	WmiRelativeBlockOffSet t_NodeOffSet = 0 ;
	WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	do
	{
		BYTE *t_Block = NULL ;
		t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_BlockOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			BOOL t_Leaf = ( ( t_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
			if ( t_Leaf ) 
			{
				t_NodeIndex = t_Node->GetNodeSize () - t_Node->GetNodeStart () - 1 ;
			}
			else
			{
				t_NodeIndex = t_Node->GetNodeSize () - t_Node->GetNodeStart () ;
			}

			t_StatusCode = PositionInBlock ( 

				t_Node ,
				t_BlockOffSet , 
				t_NodeIndex ,
				t_NodeOffSet ,
				t_ChildOffSet
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( t_ChildOffSet )
				{
					t_StatusCode = t_Stack.Push ( IteratorPosition ( t_BlockOffSet , t_NodeIndex ) ) ;
				}
				else
				{
					a_Iterator.SetNodeIndex ( t_NodeIndex ) ;
					a_Iterator.SetNodeOffSet ( t_BlockOffSet ) ;

					t_StatusCode = GetKeyElement ( t_Node , t_BlockOffSet , t_NodeIndex , a_Iterator ) ;
				}
			}

			t_NodeIndex = 0 ;
			t_BlockOffSet = t_ChildOffSet ;

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}

	} while ( ( t_StatusCode == e_StatusCode_Success ) && t_ChildOffSet ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Increment (

	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiStack <IteratorPosition,8> &t_Stack = a_Iterator.GetStack () ;
	ULONG t_NodeIndex = a_Iterator.GetNodeIndex () ;
	WmiAbsoluteBlockOffSet t_BlockOffSet = a_Iterator.GetNodeOffSet () ;

	if ( t_BlockOffSet )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_BlockOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			t_NodeIndex ++ ;

			WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;
			WmiRelativeBlockOffSet t_NodeOffSet = 0 ;

			WmiStatusCode t_TempStatusCode = PositionInBlock ( 

				t_Node ,
				t_BlockOffSet , 
				t_NodeIndex ,
				t_NodeOffSet ,
				t_ChildOffSet
			) ;

			if ( t_TempStatusCode == e_StatusCode_Success )
			{
				if ( t_ChildOffSet )
				{
					t_StatusCode = t_Stack.Push ( IteratorPosition ( t_BlockOffSet , t_NodeIndex ) ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						BYTE *t_Block = NULL ;
						t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ChildOffSet , t_Block ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							WmiBPKeyNode *t_ChildNode = ( WmiBPKeyNode * ) t_Block ;

							a_Iterator.SetNodeOffSet ( t_ChildOffSet ) ;
							a_Iterator.SetNodeIndex ( t_ChildNode->GetNodeStart () ) ;

							t_StatusCode = LeftMost ( a_Iterator ) ;

							m_BlockAllocator.ReleaseBlock ( t_Block ) ;
						}
					}
				}
				else
				{
					a_Iterator.SetNodeIndex ( t_NodeIndex ) ;

					t_StatusCode = GetKeyElement ( t_Node , t_BlockOffSet , t_NodeIndex , a_Iterator ) ;
				}
			}
			else
			{
				IteratorPosition t_Position ;

				while ( ( t_TempStatusCode = t_Stack.Top ( t_Position ) ) == e_StatusCode_Success )
				{
					t_Stack.Pop () ;

					BYTE *t_Block = NULL ;
					t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_Position.GetNodeOffSet () , t_Block ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						WmiBPKeyNode *t_ParentNode = ( WmiBPKeyNode * ) t_Block ;

						if ( t_Position.GetNodeIndex () < ( t_ParentNode->GetNodeSize () - t_ParentNode->GetNodeStart () ) )
						{
							a_Iterator.SetNodeIndex ( t_Position.GetNodeIndex () ) ;
							a_Iterator.SetNodeOffSet ( t_Position.GetNodeOffSet () ) ;

							t_StatusCode = GetKeyElement ( t_ParentNode , t_Position.GetNodeOffSet () , t_Position.GetNodeIndex () , a_Iterator ) ;

							m_BlockAllocator.ReleaseBlock ( t_Block ) ;

							break ;
						}

						m_BlockAllocator.ReleaseBlock ( t_Block ) ;
					}
				}

				if ( t_TempStatusCode != e_StatusCode_Success )
				{
					a_Iterator.SetNodeIndex ( 0 ) ;
					a_Iterator.SetNodeOffSet ( 0 ) ;
				}
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Failed ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Decrement (

	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiStack <IteratorPosition,8> &t_Stack = a_Iterator.GetStack () ;
	ULONG t_NodeIndex = a_Iterator.GetNodeIndex () ;
	WmiAbsoluteBlockOffSet t_BlockOffSet = a_Iterator.GetNodeOffSet () ;

	if ( t_BlockOffSet )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_BlockOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			t_NodeIndex -- ;

			WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;
			WmiRelativeBlockOffSet t_NodeOffSet = 0 ;

			WmiStatusCode t_TempStatusCode = PositionInBlock ( 

				t_Node ,
				t_BlockOffSet , 
				t_NodeIndex ,
				t_NodeOffSet ,
				t_ChildOffSet
			) ;

			if ( t_TempStatusCode == e_StatusCode_Success )
			{
				if ( t_ChildOffSet )
				{
					t_StatusCode = t_Stack.Push ( IteratorPosition ( t_BlockOffSet , t_NodeIndex ) ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						BYTE *t_Block = NULL ;
						t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ChildOffSet , t_Block ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							WmiBPKeyNode *t_ChildNode = ( WmiBPKeyNode * ) t_Block ;

							a_Iterator.SetNodeOffSet ( t_ChildOffSet ) ;
							a_Iterator.SetNodeIndex ( t_ChildNode->GetNodeStart () + t_ChildNode->GetNodeSize () - 1 ) ;

							t_StatusCode = RightMost ( a_Iterator ) ;

							m_BlockAllocator.ReleaseBlock ( t_Block ) ;
						}
					}
				}
				else
				{
					a_Iterator.SetNodeIndex ( t_NodeIndex ) ;

					t_StatusCode = GetKeyElement ( t_Node , t_BlockOffSet , t_NodeIndex , a_Iterator ) ;
				}
			}
			else
			{
				IteratorPosition t_Position ;

				while ( ( t_TempStatusCode = t_Stack.Top ( t_Position ) ) == e_StatusCode_Success )
				{
					t_Stack.Pop () ;

					BYTE *t_Block = NULL ;
					t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_Position.GetNodeOffSet () , t_Block ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						WmiBPKeyNode *t_ParentNode = ( WmiBPKeyNode * ) t_Block ;

						if ( t_Position.GetNodeIndex () > t_ParentNode->GetNodeStart () )
						{
							a_Iterator.SetNodeIndex ( t_Position.GetNodeIndex () ) ;
							a_Iterator.SetNodeOffSet ( t_Position.GetNodeOffSet () ) ;

							t_StatusCode = GetKeyElement ( t_ParentNode , t_Position.GetNodeOffSet () , t_Position.GetNodeIndex () - 1 , a_Iterator ) ;

							m_BlockAllocator.ReleaseBlock ( t_Block ) ;

							break ;
						}

						m_BlockAllocator.ReleaseBlock ( t_Block ) ;
					}
				}

				if ( t_TempStatusCode != e_StatusCode_Success )
				{
					a_Iterator.SetNodeIndex ( 0 ) ;
					a_Iterator.SetNodeOffSet ( 0 ) ;
				}
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Failed ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiBPlusTree :: Iterator &WmiBPlusTree :: Begin (

	Iterator &a_Iterator
) 
{
	if ( m_Root )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , m_Root , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			a_Iterator.SetNodeOffSet ( m_Root ) ;
			a_Iterator.SetNodeIndex ( t_Node->GetNodeStart () ) ;

			t_StatusCode = LeftMost ( a_Iterator ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				a_Iterator.SetNodeOffSet ( 0 ) ;
				a_Iterator.SetNodeIndex ( 0 ) ;
			}
		}
		else
		{
			a_Iterator.SetNodeOffSet ( 0 ) ;
			a_Iterator.SetNodeIndex ( 0 ) ;
		}
	}
	else
	{
		a_Iterator.SetNodeOffSet ( 0 ) ;
		a_Iterator.SetNodeIndex ( 0 ) ;	
	}

	return a_Iterator ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiBPlusTree :: Iterator &WmiBPlusTree :: End (

	Iterator &a_Iterator
) 
{
	if ( m_Root )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , m_Root , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			a_Iterator.SetNodeOffSet ( m_Root ) ;
			a_Iterator.SetNodeIndex ( t_Node->GetNodeStart () + t_Node->GetNodeSize () - 1 ) ;

			t_StatusCode = RightMost ( a_Iterator ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				a_Iterator.SetNodeOffSet ( 0 ) ;
				a_Iterator.SetNodeIndex ( 0 ) ;
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
		else
		{
			a_Iterator.SetNodeOffSet ( 0 ) ;
			a_Iterator.SetNodeIndex ( 0 ) ;
		}
	}
	else
	{
		a_Iterator.SetNodeOffSet ( 0 ) ;
		a_Iterator.SetNodeIndex ( 0 ) ;	
	}

	return a_Iterator ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiBPlusTree :: Iterator &WmiBPlusTree :: Root (

	Iterator &a_Iterator
) 
{
	if ( m_Root )
	{
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , m_Root , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			a_Iterator.SetNodeOffSet ( m_Root ) ;
			a_Iterator.SetNodeIndex ( t_Node->GetNodeStart () ) ;

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
		else
		{
			a_Iterator.SetNodeOffSet ( 0 ) ;
			a_Iterator.SetNodeIndex ( 0 ) ;
		}
	}
	else
	{
		a_Iterator.SetNodeOffSet ( 0 ) ;
		a_Iterator.SetNodeIndex ( 0 ) ;	
	}

	return a_Iterator ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: FindInBlock ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const WmiBPKey &a_Key , 
	WmiAbsoluteBlockOffSet &a_ChildOffSet ,
	WmiBPElement &a_Element ,
	WmiRelativeBlockOffSet &a_NodeOffSet ,
	ULONG &a_NodeIndex 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#ifdef COMMON_DEBUG
	PrintNode ( L"\nFindInBlock" , a_Node , a_BlockOffSet ) ;
#endif

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_LowerIndex = a_Node->GetNodeStart ()  ;
	ULONG t_UpperIndex = a_Node->GetNodeSize () ;

	while ( t_LowerIndex < t_UpperIndex )
	{
		ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

		WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) + ( t_Index * t_InternalKeySize ) ;

		BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;
		WmiBPKey t_Key ( t_Buffer , GetKeyTypeLength () ) ;

		LONG t_Compare = GetComparatorFunction () ( GetComparatorOperand () , a_Key , t_Key ) ;
		if ( t_Compare == 0 ) 
		{
			if ( t_Leaf )
			{
				CopyMemory (

					( BYTE * ) & a_Element ,
					( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockLeafKeyElementOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_NodeOffSet = t_BlockOffSet ;
			}
			else
			{
				CopyMemory (

					( BYTE * ) & a_Element ,
					( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyElementOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_NodeOffSet = t_BlockOffSet ;
			}

			a_NodeIndex = t_Index ;

			return t_StatusCode ;
		}
		else 
		{
			if ( t_Compare < 0 ) 
			{
				t_UpperIndex = t_Index ;
			}
			else
			{
				t_LowerIndex = t_Index + 1 ;
			}
		}
	}	

	if ( t_Leaf )
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}
	else
	{
		WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) + ( t_UpperIndex * t_InternalKeySize ) ;

		CopyMemory (

			( BYTE * ) & a_ChildOffSet ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		a_NodeIndex = t_UpperIndex ;
	}

	return t_StatusCode ;
}

#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: FindInBlock ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const WmiBPKey &a_Key , 
	WmiAbsoluteBlockOffSet &a_ChildOffSet ,
	WmiBPElement &a_Element ,
	WmiRelativeBlockOffSet &a_NodeOffSet ,
	ULONG &a_NodeIndex 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#ifdef COMMON_DEBUG
	PrintNode ( L"\nFindInBlock" , a_Node , a_BlockOffSet ) ;
#endif

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	for ( ULONG t_Index = t_NodeStart ; t_Index < t_NodeSize ; t_Index ++ )
	{
		BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet ;
		WmiBPKey t_Key ( t_Buffer , GetKeyTypeLength () ) ;

		LONG t_Compare = GetComparatorFunction () ( GetComparatorOperand () , a_Key , t_Key ) ;
		if ( t_Compare == 0 ) 
		{
			if ( t_Leaf )
			{
				CopyMemory (

					( BYTE * ) & a_Element ,
					( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockLeafKeyElementOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_NodeOffSet = t_BlockOffSet ;
			}
			else
			{
				CopyMemory (

					( BYTE * ) & a_Element ,
					( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyElementOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_NodeOffSet = t_BlockOffSet ;
			}

			a_NodeIndex = t_Index ;

			return t_StatusCode ;
		}
		else if ( t_Compare < 0 ) 
		{
			if ( t_Leaf )
			{
				t_StatusCode = e_StatusCode_NotFound ;
			}
			else
			{
				CopyMemory (

					( BYTE * ) & a_ChildOffSet ,
					( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_NodeIndex = t_Index ;
			}

			return t_StatusCode ;
		}

		t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
	}	

	if ( t_Leaf )
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}
	else
	{
		CopyMemory (

			( BYTE * ) & a_ChildOffSet ,
			( ( BYTE * ) ( a_Node ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		a_NodeIndex = t_Index ;
	}

	return t_StatusCode ;
}

#endif
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Find (

	const WmiBPKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveFind ( m_Root , a_Key , a_Iterator ) ;
	}
	else
	{
		return e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RecursiveFind ( 

	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	const WmiBPKey &a_Key , 
	Iterator &a_Iterator
)
{
	WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;
	WmiBPElement t_Element = 0 ;

	BYTE *t_Block = NULL ;
	WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , a_BlockOffSet , t_Block ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

		WmiRelativeBlockOffSet t_NodeOffSet = 0 ;
		ULONG t_NodeIndex = 0 ;

		t_StatusCode = FindInBlock ( 

			t_Node ,
			a_BlockOffSet , 
			a_Key , 
			t_ChildOffSet ,
			t_Element ,
			t_NodeOffSet ,
			t_NodeIndex
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( t_ChildOffSet )
			{
				WmiStack <IteratorPosition,8> &t_Stack = a_Iterator.GetStack () ;

				t_StatusCode = t_Stack.Push ( IteratorPosition ( a_BlockOffSet , t_NodeIndex ) ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = RecursiveFind ( t_ChildOffSet , a_Key , a_Iterator ) ;
				}
			}
			else
			{
				a_Iterator.SetNodeOffSet ( a_BlockOffSet ) ;
				a_Iterator.SetNodeIndex ( t_NodeIndex ) ;

				a_Iterator.GetElement () = t_Element ;
				CopyMemory ( 

					a_Iterator.GetKey ().GetData () ,
					a_Key.GetConstData () ,
					GetKeyTypeLength () 
				) ;
			}
		}

		m_BlockAllocator.ReleaseBlock ( t_Block ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: SetLeafNode (

	WmiBPKeyNode *a_Node , 
	const WmiRelativeBlockOffSet &a_NodeDeltaOffSet , 
	const WmiBPKey &a_Key ,
	const WmiBPElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockLeafKeyOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) a_Key.GetConstData () ,
		a_Key.GetConstDataSize () ,
	) ;

	t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockLeafKeyElementOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) & ( a_Element ) ,
		sizeof ( a_Element ) 
	) ;

	return t_StatusCode ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: SetNode (

	WmiBPKeyNode *a_Node , 
	const WmiRelativeBlockOffSet &a_NodeDeltaOffSet , 
	const WmiBPKey &a_Key ,
	const WmiBPElement &a_Element ,
	WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockKeyOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) a_Key.GetConstData () ,
		a_Key.GetConstDataSize () ,
	) ;

	t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockKeyElementOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) & ( a_Element ) ,
		sizeof ( a_Element ) 
	) ;

	t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockKeyPointerOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) & ( a_LeftCutBlockOffSet ) ,
		sizeof ( WmiAbsoluteBlockOffSet ) 
	) ;

	t_Buffer = ( ( BYTE * ) a_Node ) + a_NodeDeltaOffSet + WmiBlockKeyOffSet + a_Key.GetConstDataSize () + WmiBlockKeyPointerOffSet ;

	CopyMemory ( 

		t_Buffer ,
		( BYTE * ) & ( a_RightCutBlockOffSet ) ,
		sizeof ( WmiAbsoluteBlockOffSet ) 
	) ;

	return t_StatusCode ;	
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: PerformInsertion ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const WmiBPKey &a_Key , 
	WmiBPElement &a_Element ,
	WmiBPKey &a_ReBalanceKey , 
	WmiBPElement &a_ReBalanceElement ,
	WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#ifdef INSERT_DEBUG
	OutputDebugString ( L"\n/**************************************" ) ;
	wchar_t t_StringBuffer [ 1024 ] ;
	swprintf ( t_StringBuffer , L"\nInsertion Key = %I64x" , * ( UINT64 * ) a_Key.GetConstData () ) ;
	OutputDebugString ( t_StringBuffer ) ;
#endif

	WmiRelativeBlockOffSet t_StartBlockOffSet = sizeof ( WmiBPKeyNode ) ;

	BOOL t_ReBalance ;
	ULONG t_PartitionPoint ;
	WmiRelativeBlockOffSet t_KeyOffSet ;
	WmiRelativeBlockOffSet t_KeyElementOffSet ;
	WmiRelativeBlockOffSet t_KeyPosition ;
	WmiRelativeBlockOffSet t_KeyPositionIncrement ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyPositionIncrement = WmiBlockLeafKeyOffSet + GetKeyTypeLength () ;

		t_ReBalance = ( a_Node->GetNodeSize () >= MaxLeafKeys () ) ? TRUE : FALSE ;
		if ( t_ReBalance )
		{
			t_PartitionPoint = MaxLeafKeys () >> 1 ;

			t_KeyPosition = t_StartBlockOffSet + ( t_PartitionPoint * t_KeyPositionIncrement ) ;
			t_KeyOffSet = t_KeyPosition + WmiBlockLeafKeyOffSet ;
			t_KeyElementOffSet = t_KeyPosition + WmiBlockLeafKeyElementOffSet ;
		}
	}
	else
	{
		t_KeyPositionIncrement = WmiBlockKeyOffSet + GetKeyTypeLength () ;

		t_ReBalance = ( a_Node->GetNodeSize () >= MaxKeys () ) ? TRUE : FALSE ;
		if ( t_ReBalance )
		{
			t_PartitionPoint = MaxKeys () >> 1 ;

			t_KeyPosition = t_StartBlockOffSet + ( t_PartitionPoint * t_KeyPositionIncrement ) ;
			t_KeyOffSet = t_KeyPosition + WmiBlockKeyOffSet ;
			t_KeyElementOffSet = t_KeyPosition + WmiBlockKeyElementOffSet;
		}
	}

	if ( t_ReBalance )
	{
		BYTE *t_PartitionData = NULL ;
		t_StatusCode = m_Allocator.New ( ( void ** ) & t_PartitionData , GetKeyTypeLength () ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiAbsoluteBlockOffSet t_BlockOffSet = 0 ;
			BYTE *t_Block = NULL ;
			WmiStatusCode t_StatusCode = m_BlockAllocator.AllocateBlock (

				1 ,	
				t_BlockOffSet ,
				t_Block
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

#ifdef INSERT_DEBUG
				PrintNode ( L"\nPre Re Balanced a_Node" , a_Node , a_BlockOffSet ) ;
				PrintNode ( L"\nPre Re Balanced t_Node" , t_Node , t_BlockOffSet ) ;
#endif

				if ( a_PositionBlockOffSet < t_KeyPosition )
				{
/* 
 *	Copy key to trickle up.
 */

					BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyOffSet - t_KeyPositionIncrement ;

					CopyMemory ( 

						( BYTE * ) t_PartitionData ,
						t_Buffer ,
						GetKeyTypeLength () ,
					) ;

					a_ReBalanceKey = WmiBPKey ( t_PartitionData , GetKeyTypeLength () , TRUE ) ;

					t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyElementOffSet - t_KeyPositionIncrement ;

					CopyMemory ( 

						( BYTE * ) & ( a_ReBalanceElement ) ,
						t_Buffer ,
						sizeof ( a_ReBalanceElement ) 
					) ;

					t_Node->SetNodeSize ( t_PartitionPoint ) ;
					t_Node->SetNodeOffSet ( t_BlockOffSet ) ;
					t_Node->SetNodeStart ( 0 ) ;

					a_Node->SetNodeSize ( t_PartitionPoint ) ;
				
/*
 *	Copy Right partition to new node
 */	
					CopyMemory (

						( ( BYTE * ) t_Node ) + t_StartBlockOffSet ,
						( ( BYTE * ) a_Node ) + t_KeyPosition ,
						( ULONG ) ( t_PartitionPoint * t_KeyPositionIncrement ) + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;
					
/*
 *	Shuffle memory for key insertion
 */
	
					WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + a_Node->GetNodeSize () * t_KeyPositionIncrement ;
					WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - a_PositionBlockOffSet ;

					MoveMemory (

						( ( BYTE * ) a_Node ) + a_PositionBlockOffSet + t_KeyPositionIncrement ,
						( ( BYTE * ) a_Node ) + a_PositionBlockOffSet ,
						( ULONG ) t_MoveSize + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;

					if ( t_Leaf )
					{
						t_StatusCode = SetLeafNode (

							a_Node ,
							a_PositionBlockOffSet , 
							a_Key ,
							a_Element
						) ;

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_LEAF ) ;
					}
					else
					{
						t_StatusCode = SetNode (

							a_Node ,
							a_PositionBlockOffSet , 
							a_Key ,
							a_Element ,
							a_LeftCutBlockOffSet ,
							a_RightCutBlockOffSet
						) ;

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_INTERNAL ) ;
					}

					t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & t_Node ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							a_LeftCutBlockOffSet = a_BlockOffSet ;
							a_RightCutBlockOffSet = t_BlockOffSet ;
						}
					}
				}
				else if ( a_PositionBlockOffSet > t_KeyPosition )
				{	
/* 
 *	Copy key to trickle up.
 */

					BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyOffSet ;

					CopyMemory ( 

						( BYTE * ) t_PartitionData ,
						t_Buffer ,
						GetKeyTypeLength () ,
					) ;

					a_ReBalanceKey = WmiBPKey ( t_PartitionData , GetKeyTypeLength () , TRUE ) ;

					t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyElementOffSet ;

					CopyMemory ( 

						( BYTE * ) & ( a_ReBalanceElement ) ,
						t_Buffer ,
						sizeof ( a_ReBalanceElement ) 
					) ;

					t_Node->SetNodeSize ( t_PartitionPoint ) ;
					t_Node->SetNodeOffSet ( t_BlockOffSet ) ;
					t_Node->SetNodeStart ( 0 ) ;

					a_Node->SetNodeSize ( t_PartitionPoint ) ;

					CopyMemory (

						( ( BYTE * ) t_Node ) + t_StartBlockOffSet ,
						( ( BYTE * ) a_Node ) + t_KeyPosition + t_KeyPositionIncrement ,
						( ULONG ) ( ( t_PartitionPoint - 1 ) * t_KeyPositionIncrement ) + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;
					
					WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + t_Node->GetNodeSize () * t_KeyPositionIncrement ;
					WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) ;

					MoveMemory (

						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) ,
						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) - t_KeyPositionIncrement ,
						( ULONG ) t_MoveSize + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;

					if ( t_Leaf )
					{
						t_StatusCode = SetLeafNode (

							t_Node ,
							( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) - t_KeyPositionIncrement , 
							a_Key ,
							a_Element
						) ;

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_LEAF ) ;
					}
					else
					{
						t_StatusCode = SetNode (

							t_Node ,
							( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) - t_KeyPositionIncrement , 
							a_Key ,
							a_Element ,
							a_LeftCutBlockOffSet ,
							a_RightCutBlockOffSet
						) ;

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_INTERNAL ) ;
					}

					t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & t_Node ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							a_LeftCutBlockOffSet = a_BlockOffSet ;
							a_RightCutBlockOffSet = t_BlockOffSet ;
						}
					}
				}
				else
				{
/* 
 *	Copy key to trickle up.
 */

					BYTE *t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyOffSet ;

					CopyMemory ( 

						( BYTE * ) t_PartitionData ,
						t_Buffer ,
						GetKeyTypeLength () ,
					) ;
					WmiBPKey t_TempKey = WmiBPKey ( t_PartitionData , GetKeyTypeLength () , TRUE ) ;

					WmiBPElement t_TempElement ;
					t_Buffer = ( ( BYTE * ) a_Node ) + t_KeyElementOffSet ;
					CopyMemory ( 

						( BYTE * ) & ( t_TempElement ) ,
						t_Buffer ,
						sizeof ( t_TempElement ) 
					) ;

					a_ReBalanceKey = t_TempKey ;
					a_ReBalanceElement = t_TempElement ;

					t_Node->SetNodeSize ( t_PartitionPoint ) ;
					t_Node->SetNodeOffSet ( t_BlockOffSet ) ;
					t_Node->SetNodeStart ( 0 ) ;

					a_Node->SetNodeSize ( t_PartitionPoint ) ;

					CopyMemory (

						( ( BYTE * ) t_Node ) + t_StartBlockOffSet ,
						( ( BYTE * ) a_Node ) + t_KeyPosition + t_KeyPositionIncrement ,
						( ULONG ) ( ( t_PartitionPoint - 1 ) * t_KeyPositionIncrement ) + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;

					WmiAbsoluteBlockOffSet t_LeftPointerBlockOffSet = 0 ;
					CopyMemory ( 

						( BYTE * ) & t_LeftPointerBlockOffSet ,
						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) ,
						sizeof ( WmiAbsoluteBlockOffSet )
					) ;

					WmiAbsoluteBlockOffSet t_RightPointerBlockOffSet = 0 ;
					CopyMemory ( 

						( BYTE * ) & t_RightPointerBlockOffSet ,
						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) + t_KeyPositionIncrement ,
						sizeof ( WmiAbsoluteBlockOffSet )
					) ;
					
					WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + t_Node->GetNodeSize () * t_KeyPositionIncrement ;
					WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) ;

					MoveMemory (

						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) + t_KeyPositionIncrement ,
						( ( BYTE * ) t_Node ) + ( t_StartBlockOffSet + a_PositionBlockOffSet - t_KeyPosition ) ,
						( ULONG ) t_MoveSize + ( t_Leaf ? 0 : t_KeyPositionIncrement )
					) ;

					LONG t_Compare = GetComparatorFunction () ( GetComparatorOperand () , a_Key , t_TempKey ) ;

					if ( t_Leaf )
					{
						if ( t_Compare < 0 ) 
						{
							t_StatusCode = SetLeafNode (

								t_Node ,
								( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) , 
								t_TempKey ,
								t_TempElement
							) ;

							CopyMemory ( 

								( BYTE * ) t_PartitionData ,
								a_Key.GetConstData () ,
								GetKeyTypeLength () ,
							) ;

							CopyMemory ( 

								( BYTE * ) & ( a_ReBalanceElement ) ,
								( BYTE * ) & a_Element ,
								sizeof ( a_ReBalanceElement ) 
							) ;
						}
						else
						{
							t_StatusCode = SetLeafNode (

								t_Node ,
								( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) , 
								a_Key ,
								a_Element
							) ;
						}

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_LEAF ) ;
					}
					else
					{
						if ( t_Compare < 0 ) 
						{
							t_StatusCode = SetNode (

								t_Node ,
								( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) , 
								t_TempKey ,
								t_TempElement ,
								a_RightCutBlockOffSet ,
								t_LeftPointerBlockOffSet
							) ;

							CopyMemory ( 

								( BYTE * ) t_PartitionData ,
								a_Key.GetConstData () ,
								GetKeyTypeLength () ,
							) ;

							CopyMemory ( 

								( BYTE * ) & ( a_ReBalanceElement ) ,
								( BYTE * ) & a_Element ,
								sizeof ( a_ReBalanceElement ) 
							) ;

							a_RightCutBlockOffSet = t_BlockOffSet ;
						}
						else
						{
							t_StatusCode = SetNode (

								t_Node ,
								( t_StartBlockOffSet + a_PositionBlockOffSet - ( t_KeyPosition ) ) , 
								a_Key ,
								a_Element ,
								a_RightCutBlockOffSet ,
								t_RightPointerBlockOffSet
							) ;

							a_RightCutBlockOffSet = a_BlockOffSet ;
						}

						t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_INTERNAL ) ;
					}

					t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & t_Node ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							a_LeftCutBlockOffSet = a_BlockOffSet ;
							a_RightCutBlockOffSet = t_BlockOffSet ;
						}
					}
				}

#ifdef INSERT_DEBUG
				OutputDebugString ( L"\n/**************************************" ) ;
				wchar_t t_StringBuffer [ 1024 ] ;
				swprintf ( t_StringBuffer , L"\nReBalance Key = %I64x" , * ( UINT64 * ) a_ReBalanceKey.GetConstData () ) ;
				OutputDebugString ( t_StringBuffer ) ;

				PrintNode ( L"\nRe Balanced a_Node" , a_Node , a_BlockOffSet ) ;
				PrintNode ( L"\nRe Balanced t_Node" , t_Node , t_BlockOffSet ) ;
#endif

			}
		}
	}
	else
	{
/* 
 *	Shuffle memory for insertion
 */

#ifdef INSERT_DEBUG
		PrintNode ( L"\nPre Shuffled a_Node" , a_Node , a_BlockOffSet ) ;
#endif

		WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + a_Node->GetNodeSize () * t_KeyPositionIncrement ;
		WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - a_PositionBlockOffSet ;

		MoveMemory (

			( ( BYTE * ) a_Node ) + a_PositionBlockOffSet + t_KeyPositionIncrement ,
			( ( BYTE * ) a_Node ) + a_PositionBlockOffSet ,
			( ULONG ) t_MoveSize + ( t_Leaf ? 0 : t_KeyPositionIncrement )
		) ;

		if ( t_Leaf )
		{
			t_StatusCode = SetLeafNode (

				a_Node ,
				a_PositionBlockOffSet , 
				a_Key ,
				a_Element
			) ;
		}
		else
		{
			t_StatusCode = SetNode (

				a_Node ,
				a_PositionBlockOffSet , 
				a_Key ,
				a_Element ,
				a_LeftCutBlockOffSet ,
				a_RightCutBlockOffSet
			) ;
		}

		a_Node->SetNodeSize ( a_Node->GetNodeSize () + 1 ) ;

#ifdef INSERT_DEBUG
		PrintNode ( L"\nShuffled a_Node" , a_Node , a_BlockOffSet ) ;
#endif

		t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;

		a_ReBalanceElement = 0 ;
		a_LeftCutBlockOffSet = 0 ;
		a_RightCutBlockOffSet = 0 ;
	}

	return t_StatusCode ;
}

#if 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: InsertInBlock ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const WmiBPKey &a_Key , 
	WmiBPElement &a_Element ,
	WmiBPKey &a_ReBalanceKey , 
	WmiBPElement &a_ReBalanceElement ,
	WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_LowerIndex = a_Node->GetNodeStart ()  ;
	ULONG t_UpperIndex = a_Node->GetNodeSize () ;

	while ( t_LowerIndex < t_UpperIndex )
	{
		ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

		WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) + ( t_Index * t_InternalKeySize ) ;

		WmiBPKey t_Key ( ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet , GetKeyTypeLength () ) ;

		LONG t_Compare = GetComparatorFunction () ( GetComparatorOperand () , a_Key , t_Key ) ;
		if ( t_Compare == 0 ) 
		{
/*
 *	Can not happen at this juncture
 */
			return e_StatusCode_AlreadyExists ;
		}
		else
		{
			if ( t_Compare < 0 ) 
			{
				t_UpperIndex = t_Index ;
			}
			else
			{
				t_LowerIndex = t_Index + 1 ;
			}
		}
	}	

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) + ( t_UpperIndex * t_InternalKeySize ) ;

	t_StatusCode = PerformInsertion (

		a_Node ,
		a_BlockOffSet , 
		a_Key , 
		a_Element ,
		a_ReBalanceKey , 
		a_ReBalanceElement ,
		a_LeftCutBlockOffSet ,
		a_RightCutBlockOffSet ,
		t_BlockOffSet
	) ;

	return t_StatusCode ;
}

#else

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: InsertInBlock ( 

	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet , 
	const WmiBPKey &a_Key , 
	WmiBPElement &a_Element ,
	WmiBPKey &a_ReBalanceKey , 
	WmiBPElement &a_ReBalanceElement ,
	WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeStart = a_Node->GetNodeStart () ;  
	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	for ( ULONG t_Index = t_NodeStart ; t_Index < t_NodeSize ; t_Index ++ )
	{
		WmiBPKey t_Key ( ( ( BYTE * ) a_Node ) + t_BlockOffSet + t_KeyOffSet , GetKeyTypeLength () ) ;

		LONG t_Compare = GetComparatorFunction () ( GetComparatorOperand () , a_Key , t_Key ) ;
		if ( t_Compare == 0 ) 
		{
/*
 *	Can not happen at this juncture
 */
			return e_StatusCode_AlreadyExists ;
		}
		else if ( t_Compare < 0 ) 
		{
/*
 *	Found slot position to insert at.
 */

			t_StatusCode = PerformInsertion (

				a_Node ,
				a_BlockOffSet , 
				a_Key , 
				a_Element ,
				a_ReBalanceKey , 
				a_ReBalanceElement ,
				a_LeftCutBlockOffSet ,
				a_RightCutBlockOffSet ,
				t_BlockOffSet
			) ;

			return t_StatusCode ;
		}

		t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
	}	

/* 
 * Found slot at end 
 */

	t_StatusCode = PerformInsertion (

		a_Node ,
		a_BlockOffSet , 
		a_Key , 
		a_Element ,
		a_ReBalanceKey , 
		a_ReBalanceElement ,
		a_LeftCutBlockOffSet ,
		a_RightCutBlockOffSet ,
		t_BlockOffSet
	) ;

	return t_StatusCode ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RecursiveInsert ( 

	WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	const WmiBPKey &a_Key ,
	const WmiBPElement &a_Element
)
{
	WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;
	WmiBPElement t_Element = 0 ;

	BYTE *t_Block = NULL ;
	WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , a_BlockOffSet , t_Block ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

		WmiRelativeBlockOffSet t_NodeOffSet = 0 ;
		ULONG t_NodeIndex = 0 ;

		t_StatusCode = FindInBlock ( 

			t_Node ,
			a_BlockOffSet , 
			a_Key , 
			t_ChildOffSet ,
			t_Element ,
			t_NodeOffSet ,
			t_NodeIndex
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( t_Element )
			{
				t_StatusCode = e_StatusCode_AlreadyExists ;
			}
			else
			{
				t_StatusCode = a_Stack.Push ( a_BlockOffSet ) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = RecursiveInsert ( 

						a_Stack ,
						t_ChildOffSet , 
						a_Key , 
						a_Element
					) ;
				}
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
		else
		{
			WmiAbsoluteBlockOffSet t_OffSet = a_BlockOffSet ;
			WmiBPKey t_Key = a_Key ;
			WmiBPElement t_Element = a_Element ;
			WmiBPKey t_ReBalanceKey ;
			WmiBPElement t_ReBalanceElement = a_Element ;

			WmiAbsoluteBlockOffSet t_LeftCutBlockOffSet = 0 ;
			WmiAbsoluteBlockOffSet t_RightCutBlockOffSet = 0 ;

			do
			{
				if ( t_ReBalanceElement )
				{
					t_Node = ( WmiBPKeyNode * ) t_Block ;

					t_StatusCode = InsertInBlock ( 

						t_Node ,
						t_OffSet , 
						t_Key , 
						t_Element ,
						t_ReBalanceKey ,
						t_ReBalanceElement ,
						t_LeftCutBlockOffSet ,
						t_RightCutBlockOffSet 
					) ;

					m_BlockAllocator.ReleaseBlock ( t_Block ) ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						WmiStatusCode t_TempStatusCode = a_Stack.Top ( t_OffSet ) ;
						if ( t_TempStatusCode != e_StatusCode_Success ) 
						{
							if ( t_ReBalanceElement	)
							{
								t_OffSet = 0 ;
								t_Block = NULL ;
								t_StatusCode = m_BlockAllocator.AllocateBlock (

									1 ,	
									t_OffSet ,
									t_Block
								) ;

								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

									t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_INTERNAL ) ;
									t_Node->SetNodeSize ( 1 ) ;
									t_Node->SetNodeOffSet ( t_OffSet ) ;
									t_Node->SetNodeStart ( 0 ) ;

									t_StatusCode = SetNode (

										t_Node ,
										sizeof ( WmiBPKeyNode ) , 
										t_ReBalanceKey ,
										t_ReBalanceElement ,
										t_LeftCutBlockOffSet ,
										t_RightCutBlockOffSet
									) ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & t_Node ) ;
										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											SetRoot ( t_OffSet ) ;

#ifdef INSERT_DEBUG
											PrintNode ( L"\nRoot Creation" , t_Node , t_OffSet ) ;
#endif
										}

										m_BlockAllocator.ReleaseBlock ( t_Block ) ;
									}
									else
									{
										m_BlockAllocator.ReleaseBlock ( t_Block ) ;

										m_BlockAllocator.FreeBlock (

											1 ,
											t_OffSet
										) ;
									}
								}
							}

							if ( t_ReBalanceKey.GetAllocated () )
							{
								m_Allocator.Delete ( t_ReBalanceKey.GetData () ) ;
							}

							return t_StatusCode ;
						}
						else
						{
							m_BlockAllocator.ReleaseBlock ( t_Block ) ;

							if ( t_ReBalanceElement )
							{
								t_Block = NULL ;
								t_StatusCode = m_BlockAllocator.ReadBlock (

									1 , 
									t_OffSet ,
									t_Block
								) ;

								if ( t_Key.GetAllocated () )
								{
									m_Allocator.Delete ( t_Key.GetData () ) ;
								}

								t_Key = t_ReBalanceKey ;
								t_Element = t_ReBalanceElement ;	
							}

							a_Stack.Pop () ;
						}
					}
				}
				else
				{
					if ( t_Key.GetAllocated () )
					{
						m_Allocator.Delete ( t_Key.GetData () ) ;
					}

					m_BlockAllocator.ReleaseBlock ( t_Block ) ;

					return e_StatusCode_Success ;				
				}

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_Key.GetAllocated () )
			{
				m_Allocator.Delete ( t_Key.GetData () ) ;
			}
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Insert ( 

	const WmiBPKey &a_Key ,
	const WmiBPElement &a_Element
)
{
#ifdef INSERT_DEBUG
	OutputDebugString ( L"\n/**************************************" ) ;
	wchar_t t_StringBuffer [ 1024 ] ;
	swprintf ( t_StringBuffer , L"\nKey = %I64x" , * ( UINT64 * ) a_Key.GetConstData () ) ;
	OutputDebugString ( t_StringBuffer ) ;
	OutputDebugString ( L"\n======================================" ) ;
#endif

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		WmiStack <WmiAbsoluteBlockOffSet,8> t_Stack ( m_Allocator ) ;

		t_StatusCode = t_Stack.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			t_StatusCode = RecursiveInsert (

				t_Stack ,
				m_Root , 
				a_Key ,
				a_Element
			) ;
		}
	}
	else
	{
		WmiAbsoluteBlockOffSet t_BlockOffSet = 0 ;
		BYTE *t_Block = NULL ;
		WmiStatusCode t_StatusCode = m_BlockAllocator.AllocateBlock (

			1 ,	
			t_BlockOffSet ,
			t_Block
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			t_Node->SetFlags ( WMIBPLUS_TREE_FLAG_LEAF ) ;
			t_Node->SetNodeSize ( 1 ) ;
			t_Node->SetNodeOffSet ( t_BlockOffSet ) ;
			t_Node->SetNodeStart ( 0 ) ;

			t_StatusCode = SetLeafNode (

				t_Node ,
				sizeof ( WmiBPKeyNode ) , 
				a_Key ,
				a_Element
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & t_Node ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					SetRoot ( t_BlockOffSet ) ;
				}

				m_BlockAllocator.ReleaseBlock ( t_Block ) ;
			}
			else
			{

				m_BlockAllocator.ReleaseBlock ( t_Block ) ;

				m_BlockAllocator.FreeBlock (

					1 ,
					t_BlockOffSet
				) ;
			}
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Size ++ ;
	}

#ifdef INSERT_DEBUG
	OutputDebugString ( L"\n**************************************\\" ) ;
#endif

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: StealSiblingNode ( 

	WmiBPKeyNode *a_ParentNode ,
	WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
	WmiBPKeyNode *a_SiblingNode ,
	WmiAbsoluteBlockOffSet &a_SiblingBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_InternalKeySize ;
 	ULONG t_KeyOffSet ;
	ULONG t_ElementOffSet ;
	ULONG t_PointerOffSet ;

#ifdef DELETE_DEBUG
	OutputDebugString ( L"\nSteal Sibling" ) ;
	PrintNode ( L"\nParent" , a_ParentNode , a_ParentBlockOffSet ) ;
	PrintNode ( L"\nNode" , a_Node , a_BlockOffSet ) ;
	PrintNode ( L"\nSibling" , a_SiblingNode , a_SiblingBlockOffSet ) ;
#endif

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_InternalKeySize = GetKeyTypeLength () + WmiBlockLeafKeyOffSet ;
 		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_ElementOffSet = WmiBlockLeafKeyElementOffSet ;
	}
	else
	{
		t_InternalKeySize = GetKeyTypeLength ()  + WmiBlockKeyOffSet ;
 		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_ElementOffSet = WmiBlockKeyElementOffSet ;
		t_PointerOffSet = WmiBlockKeyPointerOffSet ;
	}

	WmiAbsoluteBlockOffSet t_StartBlockOffSet = sizeof ( WmiBPKeyNode ) ;

	if ( a_LeftSiblingBlockOffSet )
	{

/*
 *	Shuffle node for insertion
 */

		WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize ;

		MoveMemory (

			( ( BYTE * ) a_Node ) + t_StartBlockOffSet + t_InternalKeySize ,
			( ( BYTE * ) a_Node ) + t_StartBlockOffSet ,
			( ULONG ) t_TotalSize + t_InternalKeySize
		) ;

/*
 *	Copy parent key down
 */ 

		BYTE *t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;
		BYTE *t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + t_KeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + t_ElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;
/*
 *	Copy from left
 */

		t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + ( a_SiblingNode->GetNodeSize () - 1 ) * t_InternalKeySize + t_KeyOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + ( a_SiblingNode->GetNodeSize () - 1 ) * t_InternalKeySize + t_ElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;

/*
 *	Copy pointers from sibling to node
 */

		if ( t_Leaf == FALSE )
		{
			t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + a_SiblingNode->GetNodeSize () * t_InternalKeySize + t_PointerOffSet ;
			t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + t_PointerOffSet ;

			CopyMemory ( 

				t_ToBuffer ,
				t_FromBuffer ,
				sizeof ( WmiAbsoluteBlockOffSet )
			) ;
		}
	}
	else
	{
/*
 *	Copy parent key down
 */ 

		BYTE *t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;
		BYTE *t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_KeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_ElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;

/*
 *	Copy from right
 */

		t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + t_KeyOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + t_ElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;

		if ( t_Leaf == FALSE )
		{
			t_FromBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + t_PointerOffSet ;
			t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_InternalKeySize + WmiBlockKeyPointerOffSet ;

			CopyMemory ( 

				t_ToBuffer ,
				t_FromBuffer ,
				sizeof ( WmiAbsoluteBlockOffSet )
			) ;
		}

/*
 *	Shuffle memory due to deletion
 */
		WmiRelativeBlockOffSet t_TotalSize = a_SiblingNode->GetNodeSize () * t_InternalKeySize - t_InternalKeySize ;

		MoveMemory (

			( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet ,
			( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + t_InternalKeySize ,
			( ULONG ) t_TotalSize + ( t_Leaf ? 0 : t_InternalKeySize ) 
		) ;
	}

	a_Node->SetNodeSize ( a_Node->GetNodeSize () + 1 ) ;
	a_SiblingNode->SetNodeSize ( a_SiblingNode->GetNodeSize () - 1 ) ;

#ifdef DELETE_DEBUG
	PrintNode ( L"\nParent" , a_ParentNode , a_ParentBlockOffSet ) ;
	PrintNode ( L"\nSibling" , a_SiblingNode , a_SiblingBlockOffSet ) ;
	PrintNode ( L"\nNode" , a_Node , a_BlockOffSet ) ;
#endif

	t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_SiblingNode ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_ParentNode ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: MergeSiblingNode ( 

	WmiBPKeyNode *a_ParentNode ,
	WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
	WmiBPKeyNode *a_SiblingNode ,
	WmiAbsoluteBlockOffSet &a_SiblingBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#ifdef DELETE_DEBUG
	OutputDebugString ( L"\nMerging Node and Sibling" ) ;
	PrintNode ( L"\nParent" , a_ParentNode , a_ParentBlockOffSet ) ;
	PrintNode ( L"\nNode" , a_Node , a_BlockOffSet ) ;
	PrintNode ( L"\nSibling" , a_SiblingNode , a_SiblingBlockOffSet ) ;
#endif

	ULONG t_InternalKeySize ;
 	ULONG t_KeyOffSet ;
	ULONG t_ElementOffSet ;
	ULONG t_PointerOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_InternalKeySize = GetKeyTypeLength () + WmiBlockLeafKeyOffSet ;
 		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_ElementOffSet = WmiBlockLeafKeyElementOffSet ;
	}
	else
	{
		t_InternalKeySize = GetKeyTypeLength ()  + WmiBlockKeyOffSet ;
 		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_ElementOffSet = WmiBlockKeyElementOffSet ;
		t_PointerOffSet = WmiBlockKeyPointerOffSet ;
	}

	WmiAbsoluteBlockOffSet t_StartBlockOffSet = sizeof ( WmiBPKeyNode ) ;

/* 
 * Copy sibling key up to parent
 */

	if ( a_LeftSiblingBlockOffSet )
	{
/*
 *	Copy parent key down
 */ 
	
		BYTE *t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;
		BYTE *t_ToBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + a_SiblingNode->GetNodeSize () * t_InternalKeySize + t_KeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + a_SiblingNode->GetNodeSize () * t_InternalKeySize + t_ElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;

/*
 *	Copy node into sibling
 */

		if ( t_Leaf )
		{
			WmiRelativeBlockOffSet t_TotalSize = a_Node->GetNodeSize () * t_InternalKeySize ;

			CopyMemory (

				( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + a_SiblingNode->GetNodeSize () * t_InternalKeySize + t_InternalKeySize ,
				( ( BYTE * ) a_Node ) + t_StartBlockOffSet ,
				( ULONG ) t_TotalSize
			) ;
		}
		else
		{
			WmiRelativeBlockOffSet t_TotalSize = a_Node->GetNodeSize () * t_InternalKeySize ;

			CopyMemory (

				( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet + a_SiblingNode->GetNodeSize () * t_InternalKeySize + t_InternalKeySize ,
				( ( BYTE * ) a_Node ) + t_StartBlockOffSet ,
				( ULONG ) t_TotalSize + t_InternalKeySize
			) ;
		}

/*
 *	Shuffle memory due to deletion
 */

		ULONG t_ParentInternalKeySize = WmiBlockKeyOffSet + GetKeyTypeLength () ;

		WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + ( a_ParentNode->GetNodeSize () * t_ParentInternalKeySize ) ;
		WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - a_PositionBlockOffSet ;
		
		MoveMemory (

			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet ,
			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + t_ParentInternalKeySize ,
			( ULONG ) t_MoveSize 
		) ;

		CopyMemory (

			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyPointerOffSet ,
			( BYTE * ) & a_SiblingBlockOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet )
		) ;

		a_ParentNode->SetNodeSize ( a_ParentNode->GetNodeSize () - 1 ) ;
		a_SiblingNode->SetNodeSize ( a_SiblingNode->GetNodeSize () + a_Node->GetNodeSize () + 1 ) ;

#ifdef DELETE_DEBUG
		PrintNode ( L"\nParent" , a_ParentNode , a_ParentBlockOffSet ) ;
		PrintNode ( L"\nSibling" , a_SiblingNode , a_SiblingBlockOffSet ) ;
#endif

		t_StatusCode = m_BlockAllocator.FreeBlock ( 1 , a_BlockOffSet ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_SiblingNode ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_ParentNode ) ;
			}
		}
	}
	else
	{
/*
 *	Copy parent key down
 */ 
	
		BYTE *t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;
		BYTE *t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_KeyOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			GetKeyTypeLength () ,
		) ;

		t_FromBuffer = ( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;
		t_ToBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_ElementOffSet ;

		CopyMemory ( 

			t_ToBuffer ,
			t_FromBuffer ,
			sizeof ( WmiBPElement )
		) ;

/*
 *	Copy sibling into node
 */

		if ( t_Leaf )
		{
			WmiRelativeBlockOffSet t_TotalSize = a_SiblingNode->GetNodeSize () * t_InternalKeySize ;

			CopyMemory (

				( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_InternalKeySize ,
				( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet ,
				( ULONG ) t_TotalSize 
			) ;
		}
		else
		{
			WmiRelativeBlockOffSet t_TotalSize = a_SiblingNode->GetNodeSize () * t_InternalKeySize ;

			CopyMemory (

				( ( BYTE * ) a_Node ) + t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize + t_InternalKeySize ,
				( ( BYTE * ) a_SiblingNode ) + t_StartBlockOffSet ,
				( ULONG ) t_TotalSize + t_InternalKeySize
			) ;
		}

/*
 *	Shuffle memory due to deletion
 */

		ULONG t_ParentInternalKeySize = WmiBlockKeyOffSet + GetKeyTypeLength () ;

		WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + a_ParentNode->GetNodeSize () * t_ParentInternalKeySize ;
		WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - a_PositionBlockOffSet ;
		
		MoveMemory (

			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet ,
			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + t_ParentInternalKeySize ,
			( ULONG ) t_MoveSize 
		) ;

		CopyMemory (

			( ( BYTE * ) a_ParentNode ) + a_PositionBlockOffSet + WmiBlockKeyPointerOffSet ,
			( BYTE * ) & a_BlockOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet )
		) ;

		a_ParentNode->SetNodeSize ( a_ParentNode->GetNodeSize () - 1 ) ;
		a_Node->SetNodeSize ( a_Node->GetNodeSize () + a_SiblingNode->GetNodeSize () + 1 ) ;

#ifdef DELETE_DEBUG
		PrintNode ( L"\nParent" , a_ParentNode , a_ParentBlockOffSet ) ;
		PrintNode ( L"\nNode" , a_Node , a_BlockOffSet ) ;
#endif

		t_StatusCode = m_BlockAllocator.FreeBlock ( 1 , a_SiblingBlockOffSet ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_ParentNode ) ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: LocateSuitableSibling ( 

	WmiBPKeyNode *a_ParentNode ,
	WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
	WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () + WmiBlockKeyOffSet ;

	ULONG t_NodeStart = a_ParentNode->GetNodeStart () ;  
	ULONG t_NodeSize = a_ParentNode->GetNodeSize () ;

	for ( ULONG t_Index = t_NodeStart ; t_Index <= t_NodeSize ; t_Index ++ )
	{
		WmiAbsoluteBlockOffSet t_PointerBlockOffSet ;

		CopyMemory (

			( BYTE * ) & t_PointerBlockOffSet ,
			( ( BYTE * ) ( a_ParentNode ) ) + t_BlockOffSet + WmiBlockKeyPointerOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		if ( t_PointerBlockOffSet == a_BlockOffSet )
		{
			if ( t_Index )
			{
				a_PositionBlockOffSet = t_BlockOffSet - t_InternalKeySize ;

				CopyMemory (

					( BYTE * ) & a_LeftSiblingBlockOffSet ,
					( ( BYTE * ) ( a_ParentNode ) ) + t_BlockOffSet - t_InternalKeySize + WmiBlockKeyPointerOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;

				a_RightSiblingBlockOffSet = 0 ;
			}
			else
			{
				a_PositionBlockOffSet = t_BlockOffSet ;

				a_LeftSiblingBlockOffSet = 0 ;

				CopyMemory (

					( BYTE * ) & a_RightSiblingBlockOffSet ,
					( ( BYTE * ) ( a_ParentNode ) ) + t_BlockOffSet + t_InternalKeySize + WmiBlockKeyPointerOffSet ,
					sizeof ( WmiAbsoluteBlockOffSet ) 
				) ;
			}

			return t_StatusCode ;			
		}

		t_BlockOffSet = t_BlockOffSet + t_InternalKeySize ;
	}	

	t_StatusCode = e_StatusCode_NotFound ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: DeleteReBalance ( 

	WmiBPKeyNode *a_ParentNode ,
	WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAbsoluteBlockOffSet t_StartBlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () + WmiBlockKeyOffSet ;

	WmiRelativeBlockOffSet t_PositionBlockOffSet ;
	WmiAbsoluteBlockOffSet t_LeftSiblingBlockOffSet ;
	WmiAbsoluteBlockOffSet t_RightSiblingBlockOffSet ;

	t_StatusCode = LocateSuitableSibling ( 

		a_ParentNode ,
		a_ParentBlockOffSet ,
		a_Node ,
		a_BlockOffSet ,
		t_PositionBlockOffSet ,
		t_LeftSiblingBlockOffSet ,
		t_RightSiblingBlockOffSet
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		BYTE *t_Block = NULL ;

		if ( t_LeftSiblingBlockOffSet )
		{
			t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_LeftSiblingBlockOffSet , t_Block ) ;
		}
		else
		{
			t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_RightSiblingBlockOffSet , t_Block ) ;
		}

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_SiblingNode = ( WmiBPKeyNode * ) t_Block ;

			BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
			ULONG t_Balance = t_Leaf ? MaxLeafKeys () : MaxKeys () ;

			if ( t_SiblingNode->GetNodeSize () > ( t_Balance >> 1 ) )
			{
/*
 *	Steal a key
 */

				t_StatusCode = StealSiblingNode ( 

					a_ParentNode ,
					a_ParentBlockOffSet ,
					a_Node ,
					a_BlockOffSet ,
					t_PositionBlockOffSet ,
					t_SiblingNode ,
					t_LeftSiblingBlockOffSet ? t_LeftSiblingBlockOffSet : t_RightSiblingBlockOffSet ,
					t_LeftSiblingBlockOffSet ,
					t_RightSiblingBlockOffSet
				) ;
			}
			else
			{
	/*
	 * Merge sibling nodes
	 */

				t_StatusCode = MergeSiblingNode ( 

					a_ParentNode ,
					a_ParentBlockOffSet ,
					a_Node ,
					a_BlockOffSet ,
					t_PositionBlockOffSet ,
					t_SiblingNode ,
					t_LeftSiblingBlockOffSet ? t_LeftSiblingBlockOffSet : t_RightSiblingBlockOffSet ,
					t_LeftSiblingBlockOffSet ,
					t_RightSiblingBlockOffSet
				) ;
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RecursiveDeleteFixup ( 

	WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
	WmiBPKeyNode *a_RootNode ,
	WmiAbsoluteBlockOffSet &a_RootBlockOffSet ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAbsoluteBlockOffSet t_StartBlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	if ( t_Leaf )
	{
		if ( a_RootBlockOffSet == a_BlockOffSet )
		{
/*
 *	Shuffle memory to remove deleted fixup node
 */

			WmiRelativeBlockOffSet t_TotalSize = t_StartBlockOffSet + a_Node->GetNodeSize () * t_InternalKeySize ;
			WmiRelativeBlockOffSet t_MoveSize = t_TotalSize - a_PositionBlockOffSet - t_InternalKeySize ;

			MoveMemory (

				( ( BYTE * ) a_Node ) + a_PositionBlockOffSet ,
				( ( BYTE * ) a_Node ) + a_PositionBlockOffSet + t_InternalKeySize ,
				( ULONG ) t_MoveSize + ( t_Leaf ? 0 : t_InternalKeySize )
			) ;
		}
		else
		{
/*
 *	Copy node up to place we deleted from.
 */

#ifdef DELETE_DEBUG
			PrintNode ( L"\nCopy Down a_RootNode" , a_RootNode , a_RootBlockOffSet ) ;
			PrintNode ( L"\na_Node" , a_Node , a_BlockOffSet ) ;
#endif

			BYTE *t_FromBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + WmiBlockLeafKeyOffSet ;
			BYTE *t_ToBuffer = ( ( BYTE * ) a_RootNode ) + a_PositionBlockOffSet + WmiBlockKeyOffSet ;

			CopyMemory ( 

				t_ToBuffer ,
				t_FromBuffer ,
				GetKeyTypeLength () ,
			) ;

			t_FromBuffer = ( ( BYTE * ) a_Node ) + t_StartBlockOffSet + WmiBlockLeafKeyElementOffSet ;
			t_ToBuffer = ( ( BYTE * ) a_RootNode ) + a_PositionBlockOffSet + WmiBlockKeyElementOffSet ;

			CopyMemory ( 

				t_ToBuffer ,
				t_FromBuffer ,
				sizeof ( WmiBPElement )
			) ;

/*
 *	Shuffle memory to remove deleted fixup node
 */

			WmiRelativeBlockOffSet t_TotalSize = a_Node->GetNodeSize () * t_InternalKeySize - t_InternalKeySize ;

			MoveMemory (

				( ( BYTE * ) a_Node ) + t_StartBlockOffSet ,
				( ( BYTE * ) a_Node ) + t_StartBlockOffSet + t_InternalKeySize ,
				( ULONG ) t_TotalSize + ( t_Leaf ? 0 : t_InternalKeySize )
			) ;

		}

		a_Node->SetNodeSize ( a_Node->GetNodeSize () - 1 ) ;

#ifdef DELETE_DEBUG
		PrintNode ( L"\na_Node" , a_Node , a_BlockOffSet ) ;
#endif

		t_StatusCode = m_BlockAllocator.WriteBlock ( ( BYTE * ) & a_Node ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
/*
 *	Finally re balance as required
 */

			WmiBPKeyNode *t_Node = a_Node ;
			WmiAbsoluteBlockOffSet t_BlockOffSet = a_BlockOffSet ;

			m_BlockAllocator.AddRefBlock ( ( BYTE * ) & a_Node ) ;

			do
			{
				BOOL t_ReBalance ;
				if ( t_Leaf )
				{
					t_ReBalance = t_Node->GetNodeSize () < ( MaxLeafKeys () >> 1 ) ? TRUE : FALSE ;
				}
				else
				{
					t_ReBalance = t_Node->GetNodeSize () < ( MaxKeys () >> 1 ) ? TRUE : FALSE ;
				}

				if ( t_ReBalance )
				{
					WmiAbsoluteBlockOffSet t_ParentOffSet = 0 ;
					WmiStatusCode t_TempStatusCode = a_Stack.Top ( t_ParentOffSet ) ;
					if ( t_TempStatusCode == e_StatusCode_Success ) 
					{
						m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;

						BYTE *t_Block = NULL ;
						t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ParentOffSet , t_Block ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							WmiBPKeyNode *t_ParentNode = ( WmiBPKeyNode * ) t_Block ;

							t_StatusCode = DeleteReBalance (

								t_ParentNode ,
								t_ParentOffSet ,
								t_Node ,
								t_BlockOffSet 
							) ;

							t_Node = t_ParentNode ;
							t_BlockOffSet = t_ParentOffSet ;
							t_Leaf = ( ( t_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
						}

						a_Stack.Pop () ;
					}
					else
					{
						if ( t_Leaf )
						{
							if ( t_Node->GetNodeSize () == 0 )
							{
								if ( t_BlockOffSet == GetRoot () )
								{
									SetRoot ( 0 ) ;
								}

								m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;

								m_BlockAllocator.FreeBlock (

									1 ,
									t_BlockOffSet
								) ;
							}
							else
							{
								m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;
							}
						}
						else
						{
							if ( t_Node->GetNodeSize () == 0 )
							{
								WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

								CopyMemory (

									( BYTE * ) & t_ChildOffSet ,
									( ( BYTE * ) ( t_Node ) ) + t_StartBlockOffSet + WmiBlockKeyPointerOffSet ,
									sizeof ( WmiAbsoluteBlockOffSet ) 
								) ;

								SetRoot ( t_ChildOffSet ) ;

								m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;

								m_BlockAllocator.FreeBlock (

									1 ,
									t_BlockOffSet
								) ;
							}
							else
							{
								m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;
							}
						}

						return t_StatusCode ;
					}
				}
				else
				{
					m_BlockAllocator.ReleaseBlock ( ( BYTE * ) & t_Node ) ;

					return t_StatusCode ;
				}

			} while ( t_StatusCode == e_StatusCode_Success ) ;
		}
	}
	else
	{
		WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

		CopyMemory (

			( BYTE * ) & t_ChildOffSet ,
			( ( BYTE * ) ( a_Node ) ) + t_StartBlockOffSet + WmiBlockKeyPointerOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		BYTE *t_Block = NULL ;
		t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ChildOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

			t_StatusCode = a_Stack.Push ( a_BlockOffSet ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				RecursiveDeleteFixup (

					a_Stack ,
					a_RootNode ,
					a_RootBlockOffSet ,
					t_Node ,
					t_ChildOffSet ,
					a_PositionBlockOffSet
				) ;
			}

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: DeleteFixup ( 

	WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
	WmiBPKeyNode *a_Node ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	WmiRelativeBlockOffSet &a_PositionBlockOffSet
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAbsoluteBlockOffSet t_BlockOffSet = sizeof ( WmiBPKeyNode ) ;

	ULONG t_InternalKeySize = GetKeyTypeLength () ;
	ULONG t_KeyOffSet ;

	BOOL t_Leaf = ( ( a_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
	if ( t_Leaf ) 
	{
		t_KeyOffSet = WmiBlockLeafKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockLeafKeyOffSet ;
	}
	else
	{
		t_KeyOffSet = WmiBlockKeyOffSet ;
		t_InternalKeySize = t_InternalKeySize + WmiBlockKeyOffSet ;
	}

	ULONG t_NodeSize = a_Node->GetNodeSize () ;

	if ( t_Leaf )
	{
		t_StatusCode = RecursiveDeleteFixup (

			a_Stack ,
			a_Node ,
			a_BlockOffSet ,
			a_Node ,
			a_BlockOffSet ,
			a_PositionBlockOffSet
		) ;
	}
	else
	{
/*
 *	Move right one and descend left most to get next key.
 */

		WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;

		CopyMemory (

			( BYTE * ) & t_ChildOffSet ,
			( ( BYTE * ) ( a_Node ) ) + a_PositionBlockOffSet + t_InternalKeySize + WmiBlockKeyPointerOffSet ,
			sizeof ( WmiAbsoluteBlockOffSet ) 
		) ;

		BYTE *t_Block = NULL ;
		t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , t_ChildOffSet , t_Block ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiBPKeyNode *t_ChildNode = ( WmiBPKeyNode * ) t_Block ;

			t_StatusCode = RecursiveDeleteFixup (

				a_Stack ,
				a_Node ,
				a_BlockOffSet ,
				t_ChildNode ,
				t_ChildOffSet ,
				a_PositionBlockOffSet
			) ;

			m_BlockAllocator.ReleaseBlock ( t_Block ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: RecursiveDelete ( 

	WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
	WmiAbsoluteBlockOffSet &a_BlockOffSet ,
	const WmiBPKey &a_Key ,
	WmiBPElement &a_Element
)
{
	WmiAbsoluteBlockOffSet t_ChildOffSet = 0 ;
	WmiBPElement t_Element = 0 ;

	BYTE *t_Block = NULL ;
	WmiStatusCode t_StatusCode = m_BlockAllocator.ReadBlock ( 1 , a_BlockOffSet , t_Block ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiBPKeyNode *t_Node = ( WmiBPKeyNode * ) t_Block ;

		WmiRelativeBlockOffSet t_NodeOffSet = 0 ;
		ULONG t_NodeIndex = 0 ;

		t_StatusCode = FindInBlock ( 

			t_Node ,
			a_BlockOffSet , 
			a_Key , 
			t_ChildOffSet ,
			t_Element ,
			t_NodeOffSet ,
			t_NodeIndex
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( t_Element )
			{
				BOOL t_Leaf = ( ( t_Node->GetFlags () & WMIBPLUS_TREE_FLAG_LEAF ) == WMIBPLUS_TREE_FLAG_LEAF ) ;
				if ( t_Leaf == FALSE ) 
				{
					t_StatusCode = a_Stack.Push ( a_BlockOffSet ) ;
				}

				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = DeleteFixup (

						a_Stack ,
						t_Node ,
						a_BlockOffSet ,
						t_NodeOffSet
					) ;
				}
			}
			else
			{
				t_StatusCode = a_Stack.Push ( a_BlockOffSet ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = RecursiveDelete ( 

						a_Stack ,
						t_ChildOffSet , 
						a_Key , 
						a_Element
					) ;
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_NotFound ;
		}

		m_BlockAllocator.ReleaseBlock ( t_Block ) ;
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiBPlusTree :: Delete ( 

	const WmiBPKey &a_Key ,
	WmiBPElement &a_Element
)
{
#ifdef DELETE_DEBUG
	OutputDebugString ( L"\n/**************************************" ) ;
	wchar_t t_StringBuffer [ 1024 ] ;
	swprintf ( t_StringBuffer , L"\nKey = %I64x" , * ( UINT64 * ) a_Key.GetConstData () ) ;
	OutputDebugString ( t_StringBuffer ) ;
	OutputDebugString ( L"\n======================================" ) ;
#endif

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		WmiStack <WmiAbsoluteBlockOffSet,8> t_Stack ( m_Allocator ) ;

		t_StatusCode = t_Stack.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			t_StatusCode = RecursiveDelete (

				t_Stack ,
				m_Root , 
				a_Key ,
				a_Element
			) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Size -- ;
	}

#ifdef DELETE_DEBUG
	OutputDebugString ( L"\n**************************************\\" ) ;
#endif

	return t_StatusCode ;
}

#endif _BPLUSTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\ioscheduler.cpp ===
/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <typeinfo.h>
#include <wbemcli.h>

#include <IoScheduler.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Win32ToApi ( DWORD a_Error ) 
{
	WmiStatusCode t_Status = e_StatusCode_Success ;
	switch ( a_Error )
	{
		case STATUS_NO_MEMORY:
		{
			t_Status = e_StatusCode_OutOfMemory ;
		}
		break ;

		default:
		{
			t_Status = e_StatusCode_Unknown ;
		}
		break ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Win32ToApi () 
{
	WmiStatusCode t_Status = e_StatusCode_Success ;

	DWORD t_LastError = GetLastError () ;
	t_Status = Win32ToApi ( t_LastError ) ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetSecurityDescriptor ( SECURITY_DESCRIPTOR &a_SecurityDescriptor , DWORD a_Access ) 
{
	HRESULT t_Result = S_OK ;

	BOOL t_BoolResult = InitializeSecurityDescriptor ( & a_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
	if ( t_BoolResult )
	{
		SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

		PSID t_Administrator_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
		WORD t_Administrator_ACESize = 0 ;

		BOOL t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			2 ,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_Administrator_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
			t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
			if ( t_Administrator_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
				t_Administrator_ACE->Mask = 0x1F01FF;
				t_Administrator_ACE->Header.AceType = 0 ;
				t_Administrator_ACE->Header.AceFlags = 3 ;
				t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		PSID t_System_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
		WORD t_System_ACESize = 0 ;

		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SYSTEM_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_System_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
			t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
			if ( t_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
				t_System_ACE->Mask = 0x1F01FF;
				t_System_ACE->Header.AceType = 0 ;
				t_System_ACE->Header.AceFlags = 3 ;
				t_System_ACE->Header.AceSize = t_System_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

		PSID t_Everyone_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
		USHORT t_Everyone_ACESize = 0 ;
		
		t_BoolResult = AllocateAndInitializeSid (

			& t_WorldAuthoritySid ,
			1 ,
			SECURITY_WORLD_RID ,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_Everyone_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
			t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
			if ( t_Everyone_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
				t_Everyone_ACE->Mask = a_Access ;
				t_Everyone_ACE->Header.AceType = 0 ;
				t_Everyone_ACE->Header.AceFlags = 3 ;
				t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		// Now we need to set permissions on the registry: Everyone read; Admins full.
		// We have the sid for admins from the above code.  Now get the sid for "Everyone"

		DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_System_ACESize + t_Everyone_ACESize ;
		PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
		if ( t_Dacl )
		{
			if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
			{
				DWORD t_AceIndex = 0 ;

				if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
				{
					t_AceIndex ++ ;
				}
				
				if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
				{
					t_AceIndex ++ ;
				}

				if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
				{
					t_AceIndex ++ ;
				}

				t_BoolResult = SetSecurityDescriptorDacl (

				  & a_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult == FALSE )
				{
					delete [] ( ( BYTE * ) t_Dacl ) ;

					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( t_Administrator_ACE )
		{
			delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
		}

		if ( t_System_ACE )
		{
			delete [] ( ( BYTE * ) t_System_ACE ) ;
		}

		if ( t_Everyone_ACE )
		{
			delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
		}

		if ( t_System_Sid )
		{
			FreeSid ( t_System_Sid ) ;
		}

		if ( t_Administrator_Sid )
		{
			FreeSid ( t_Administrator_Sid ) ;
		}

		if ( t_Everyone_Sid )
		{
			FreeSid ( t_Everyone_Sid ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOverlapped :: WmiOverlapped ( OverLappedType a_Type ) 
{
	ZeroMemory ( & m_Overlapped , sizeof ( m_Overlapped ) ) ;
	m_Type = a_Type ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOverlapped :: ~WmiOverlapped ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiScheduledOverlapped :: WmiScheduledOverlapped ( 

	OverLappedType a_Type , 
	WmiIoScheduler &a_Scheduler

) : WmiOverlapped ( a_Type ) , 
	m_Scheduler ( a_Scheduler )
{
	m_Scheduler.AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiScheduledOverlapped :: ~WmiScheduledOverlapped ()
{
	m_Scheduler.Release () ; 
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTerminateOverlapped :: WmiTerminateOverlapped () : WmiOverlapped ( e_OverLapped_Terminate )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTaskOverlapped :: WmiTaskOverlapped (

	WmiIoScheduler &a_Scheduler ,
	WmiTaskOperation *a_OperationFunction

)	:	WmiScheduledOverlapped ( e_OverLapped_Task , a_Scheduler ) ,
		m_Status ( 0 ) ,
		m_State ( 0 ) ,
		m_OperationFunction ( a_OperationFunction )
{
	m_Overlapped.Offset = 0 ;
	m_Overlapped.OffsetHigh = 0 ;

	if ( m_OperationFunction )
	{
		m_OperationFunction->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTaskOverlapped :: ~WmiTaskOverlapped ()
{
	if ( m_OperationFunction )
	{
		m_OperationFunction->Release () ;
	}
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiReadOverlapped :: WmiReadOverlapped (

	WmiIoScheduler &a_Scheduler ,
	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_Buffer ,
	DWORD a_BufferSize 

)	:	WmiScheduledOverlapped ( e_OverLapped_Read , a_Scheduler ) ,
		m_Buffer ( a_Buffer ) ,
		m_BufferSize ( a_BufferSize ) ,
		m_Status ( 0 ) ,
		m_State ( 0 ) ,
		m_OperationFunction ( a_OperationFunction )
{
	m_Overlapped.Offset = a_OffSet & 0xFFFFFFFF ;
	m_Overlapped.OffsetHigh = a_OffSet >> 32 ;

	if ( m_OperationFunction )
	{
		m_OperationFunction->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiReadOverlapped :: ~WmiReadOverlapped ()
{
	if ( m_OperationFunction )
	{
		m_OperationFunction->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiWriteOverlapped :: WmiWriteOverlapped (

	WmiIoScheduler &a_Scheduler ,
	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_Buffer ,
	DWORD a_BufferSize 

)	:	WmiScheduledOverlapped ( e_OverLapped_Write , a_Scheduler ) ,
		m_Buffer ( a_Buffer ) ,
		m_BufferSize ( a_BufferSize ) ,
		m_Status ( 0 ) ,
		m_State ( 0 ) ,
		m_OperationFunction ( a_OperationFunction )
{
	m_Overlapped.Offset = a_OffSet & 0xFFFFFFFF ;
	m_Overlapped.OffsetHigh = a_OffSet >> 32 ;

	if ( m_OperationFunction )
	{
		m_OperationFunction->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiWriteOverlapped :: ~WmiWriteOverlapped ()
{
	if ( m_OperationFunction )
	{
		m_OperationFunction->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiLockOverlapped :: WmiLockOverlapped (

	WmiIoScheduler &a_Scheduler ,
	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize

)	:	WmiScheduledOverlapped ( e_OverLapped_Lock , a_Scheduler ) ,
		m_OffSetSize ( a_OffSetSize ) ,
		m_Status ( 0 ) ,
		m_State ( 0 ) ,
		m_OperationFunction ( a_OperationFunction )
{
	m_Overlapped.Offset = a_OffSet & 0xFFFFFFFF ;
	m_Overlapped.OffsetHigh = a_OffSet >> 32 ;

	if ( m_OperationFunction )
	{
		m_OperationFunction->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiLockOverlapped :: ~WmiLockOverlapped ()
{
	if ( m_OperationFunction )
	{
		m_OperationFunction->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiUnLockOverlapped :: WmiUnLockOverlapped (

	WmiIoScheduler &a_Scheduler ,
	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize

)	:	WmiScheduledOverlapped ( e_OverLapped_UnLock , a_Scheduler ) ,
		m_OffSetSize ( a_OffSetSize ) ,
		m_Status ( 0 ) ,
		m_State ( 0 ) ,
		m_OperationFunction ( a_OperationFunction )
{
	m_Overlapped.Offset = a_OffSet & 0xFFFFFFFF ;
	m_Overlapped.OffsetHigh = a_OffSet >> 32 ;

	if ( m_OperationFunction )
	{
		m_OperationFunction->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiUnLockOverlapped :: ~WmiUnLockOverlapped ()
{
	if ( m_OperationFunction )
	{
		m_OperationFunction->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiCompletionPortOperation :: WmiCompletionPortOperation (

	WmiAllocator &a_Allocator ,
	WmiThreadPool *a_ThreadPool 

) : WmiTask <ULONG> ( a_Allocator ) ,
	m_ThreadPool ( a_ThreadPool ) 
{
	if ( m_ThreadPool )
	{
		m_ThreadPool->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiCompletionPortOperation :: ~WmiCompletionPortOperation ()
{
	if ( m_ThreadPool )
	{
		m_ThreadPool->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiCompletionPortOperation :: Process ( WmiThread <ULONG> &a_Thread )
{
	DWORD t_Continue = TRUE ;
	while ( t_Continue )
	{
		OVERLAPPED *t_Overlapped = NULL ;
		DWORD t_Key = 0 ;
		DWORD t_Bytes = 0 ;

		BOOL t_Status = GetQueuedCompletionStatus (

			m_ThreadPool->GetCompletionPort () ,
			& t_Bytes ,
			& t_Key ,
			& t_Overlapped ,
			INFINITE 
		) ;

		if ( t_Status )
		{
			WmiOverlapped *t_WmiOverlapped = ( WmiOverlapped * ) t_Overlapped ;
			switch ( t_WmiOverlapped->GetType () )
			{
				case WmiOverlapped :: OverLappedType :: e_OverLapped_Terminate:
				{
					WmiTerminateOverlapped *t_TerminateOverlapped = ( WmiTerminateOverlapped * ) t_Overlapped ;
					delete t_TerminateOverlapped ;
					t_Continue = FALSE ;
				}
				break ;

				case WmiOverlapped :: OverLappedType :: e_OverLapped_Task:
				{
					WmiTaskOverlapped *t_TaskOverlapped = ( WmiTaskOverlapped * ) t_Overlapped ;
					WmiIoScheduler &t_Allocator = t_TaskOverlapped->GetScheduler () ;

					t_Allocator.TaskBegin ( t_TaskOverlapped ) ;
				}
				break ;

				case WmiOverlapped :: OverLappedType :: e_OverLapped_Read:
				{
					WmiReadOverlapped *t_ReadOverlapped = ( WmiReadOverlapped * ) t_Overlapped ;
					WmiIoScheduler &t_Allocator = t_ReadOverlapped->GetScheduler () ;

					switch ( t_ReadOverlapped->GetState () )
					{
						case 0:
						{
							t_Allocator.ReadBegin ( t_ReadOverlapped , t_Bytes ) ;
						}
						break ;

						case 1:
						{
							t_Allocator.ReadComplete ( t_ReadOverlapped , t_Bytes ) ;
						}

						default:
						{
						}
						break ;
					}
				}
				break ;

				case WmiOverlapped :: OverLappedType :: e_OverLapped_Lock:
				{
					WmiLockOverlapped *t_LockOverlapped = ( WmiLockOverlapped * ) t_Overlapped ;
					WmiIoScheduler &t_Allocator = t_LockOverlapped->GetScheduler () ;

					switch ( t_LockOverlapped->GetState () )
					{
						case 0:
						{
							t_Allocator.LockBegin ( t_LockOverlapped , t_Bytes ) ;
						}
						break ;

						case 1:
						{
							t_Allocator.LockComplete ( t_LockOverlapped , t_Bytes ) ;
						}

						default:
						{
						}
						break ;
					}
				}
				break ;

				case WmiOverlapped :: OverLappedType :: e_OverLapped_UnLock:
				{
					WmiUnLockOverlapped *t_UnLockOverlapped = ( WmiUnLockOverlapped * ) t_Overlapped ;
					WmiIoScheduler &t_Allocator = t_UnLockOverlapped->GetScheduler () ;

					switch ( t_UnLockOverlapped->GetState () )
					{
						case 0:
						{
							t_Allocator.UnLockBegin ( t_UnLockOverlapped , t_Bytes ) ;
						}
						break ;

						case 1:
						{
							t_Allocator.UnLockComplete ( t_UnLockOverlapped , t_Bytes ) ;
						}

						default:
						{
						}
						break ;
					}
				}
				break ;

				case WmiOverlapped :: OverLappedType :: e_OverLapped_Write:
				{
					WmiWriteOverlapped *t_WriteOverlapped = ( WmiWriteOverlapped * ) t_Overlapped ;
					WmiIoScheduler &t_Allocator = t_WriteOverlapped->GetScheduler ()  ;

					switch ( t_WriteOverlapped->GetState () )
					{
						case 0:
						{
							t_Allocator.WriteBegin ( t_WriteOverlapped , t_Bytes ) ;
						}
						break ;

						case 1:
						{
							t_Allocator.WriteComplete ( t_WriteOverlapped , t_Bytes ) ;
						}

						default:
						{
						}
						break ;
					}
				}
				break ;

				default:
				{
					t_Continue = FALSE ;
				}
				break ;
			}
		}
		else
		{
			DWORD t_LastError = GetLastError () ;

			if ( t_Overlapped == NULL )
			{
				break ;
			}
		}
	}

	Complete () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
	
WmiThreadPool :: WmiThreadPool ( 

	WmiAllocator &a_Allocator ,
	const ULONG &a_Threads 

) : m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_ThreadPool ( NULL ) ,
	m_CompletionPort ( NULL )
{
	if ( a_Threads == 0 )
	{
		SYSTEM_INFO t_SystemInformation ;
		GetSystemInfo ( & t_SystemInformation ) ;

		m_Threads = t_SystemInformation.dwNumberOfProcessors ;
	}
	else
	{
		m_Threads = a_Threads ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiThreadPool :: ~WmiThreadPool ()
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiThreadPool :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiThreadPool :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiThreadPool :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( m_Allocator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_CompletionPort = CreateIoCompletionPort (

			INVALID_HANDLE_VALUE ,
			NULL ,
			NULL ,
			0
		) ;

		if ( m_CompletionPort == NULL )
		{
			t_StatusCode = e_StatusCode_OutOfResources ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_ThreadPool = new WmiThread <ULONG> * [ m_Threads ] ;
			if ( m_ThreadPool )
			{
				for ( ULONG t_Index = 0 ; t_Index < m_Threads ; t_Index ++ )
				{
					m_ThreadPool [ t_Index ] = new WmiThread <ULONG> ( m_Allocator ) ;
					if ( m_ThreadPool [ t_Index ] ) 
					{
						m_ThreadPool [ t_Index ]->AddRef () ;

						t_StatusCode = m_ThreadPool [ t_Index ]->Initialize () ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							WmiCompletionPortOperation *t_Operation = new WmiCompletionPortOperation ( 

								m_Allocator , 
								this
							) ;

							if ( t_Operation )
							{
								t_StatusCode = t_Operation->Initialize () ;
								if ( t_StatusCode == e_StatusCode_Success )					
								{
									m_ThreadPool [ t_Index ]->EnQueue ( 0 , *t_Operation ) ;
								}
							}
						}
					}
					else
					{
						t_StatusCode = e_StatusCode_OutOfMemory ;
					}
				}
			}
			else
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiThreadPool :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_ThreadPool )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_Threads ; t_Index ++ )
		{
			if ( m_ThreadPool [ t_Index ] ) 
			{
				WmiTerminateOverlapped *t_Terminate = new WmiTerminateOverlapped ;
				if ( t_Terminate )
				{
					BOOL t_Status = PostQueuedCompletionStatus ( 

						GetCompletionPort () ,
						0 ,
						NULL ,
						( OVERLAPPED * ) t_Terminate 
					) ;

					if ( t_Status )
					{
						HANDLE t_ThreadHandle = NULL ;

						BOOL t_Status = DuplicateHandle ( 

							GetCurrentProcess () ,
							m_ThreadPool [ t_Index ]->GetHandle () ,
							GetCurrentProcess () ,
							& t_ThreadHandle, 
							0 , 
							FALSE , 
							DUPLICATE_SAME_ACCESS
						) ;

						m_ThreadPool [ t_Index ]->Release () ;

						WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

						CloseHandle ( t_ThreadHandle ) ;
					}
					else
					{
						t_StatusCode = e_StatusCode_Failed ;
					}
				}
			}
		}

		delete [] m_ThreadPool ;
		m_ThreadPool = NULL ;
	}

	if ( m_CompletionPort )
	{
		CloseHandle ( m_CompletionPort ) ;
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
	
WmiIoScheduler :: WmiIoScheduler ( 

	WmiAllocator &a_Allocator ,
	WmiThreadPool *a_ThreadPool ,
	wchar_t *a_FileName ,
	WmiFileSize a_InitialSize , 
	WmiFileSize a_MaximumSize

) : m_Allocator ( a_Allocator ) ,
	m_InitialSize ( a_InitialSize ) ,
	m_MaximumSize ( a_MaximumSize ) ,
	m_ReferenceCount ( 0 ) ,
	m_ThreadPool ( a_ThreadPool ) ,
	m_FileHandle ( NULL ) ,
	m_FileName ( NULL )
{
	m_FileName = new wchar_t [ wcslen ( a_FileName ) + 1 ] ;
	if ( m_FileName ) 
	{
		wcscpy ( m_FileName , a_FileName ) ;
	}

	if ( m_ThreadPool )
	{
		m_ThreadPool->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiIoScheduler :: ~WmiIoScheduler ()
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiIoScheduler :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiIoScheduler :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Initialize ()
{
	WmiStatusCode t_StatusCode = Create () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		HANDLE t_CompletionPort = CreateIoCompletionPort (

			m_FileHandle ,
			m_ThreadPool->GetCompletionPort () ,
			( ULONG_PTR ) this ,
			0
		) ;

		if ( t_CompletionPort != INVALID_HANDLE_VALUE )
		{
		}
		else
		{
			t_StatusCode = Win32ToApi () ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_FileName ) 
	{
		delete [] m_FileName ;
		m_FileName = NULL ;
	}

	t_StatusCode = Close () ;

	if ( m_ThreadPool )
	{
		m_ThreadPool->Release () ;
		m_ThreadPool = NULL ;
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Task ( 

	WmiTaskOperation *a_OperationFunction
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiTaskOverlapped *t_Overlapped = new WmiTaskOverlapped (

		*this ,
		a_OperationFunction 
	) ;

	if ( t_Overlapped )
	{
		BOOL t_Status = PostQueuedCompletionStatus ( 

			m_ThreadPool->GetCompletionPort () ,
			0 ,
			( ULONG_PTR ) this ,
			( OVERLAPPED * ) t_Overlapped
		) ;

		if ( t_Status == FALSE ) 
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Read ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_ReadBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiReadOverlapped *t_Overlapped = new WmiReadOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_ReadBytes ,
		a_Bytes
	) ;

	if ( t_Overlapped )
	{
		BOOL t_Status = PostQueuedCompletionStatus ( 

			m_ThreadPool->GetCompletionPort () ,
			a_Bytes ,
			( ULONG_PTR ) this ,
			( OVERLAPPED * ) t_Overlapped
		) ;

		if ( t_Status == FALSE ) 
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Write ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_WriteBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiWriteOverlapped *t_Overlapped = new WmiWriteOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_WriteBytes ,
		a_Bytes
	) ;

	if ( t_Overlapped )
	{
		BOOL t_Status = PostQueuedCompletionStatus ( 

			m_ThreadPool->GetCompletionPort () ,
			a_Bytes ,
			( ULONG_PTR ) this ,
			( OVERLAPPED * ) t_Overlapped
		) ;

		if ( t_Status == FALSE ) 
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Lock ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiLockOverlapped *t_Overlapped = new WmiLockOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_OffSetSize
	) ;

	if ( t_Overlapped )
	{
		BOOL t_Status = PostQueuedCompletionStatus ( 

			m_ThreadPool->GetCompletionPort () ,
			0 ,
			( ULONG_PTR ) this ,
			( OVERLAPPED * ) t_Overlapped
		) ;

		if ( t_Status == FALSE ) 
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: UnLock ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiUnLockOverlapped *t_Overlapped = new WmiUnLockOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_OffSetSize
	) ;

	if ( t_Overlapped )
	{
		BOOL t_Status = PostQueuedCompletionStatus ( 

			m_ThreadPool->GetCompletionPort () ,
			0 ,
			( ULONG_PTR ) this ,
			( OVERLAPPED * ) t_Overlapped
		) ;

		if ( t_Status == FALSE ) 
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: ReadOnThread ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_ReadBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiReadOverlapped *t_Overlapped = new WmiReadOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_ReadBytes ,
		a_Bytes
	) ;

	if ( t_Overlapped )
	{
		t_Overlapped->SetState ( 1 ) ;

		t_StatusCode = ReadBegin (

			t_Overlapped ,
			0
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: WriteOnThread ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_WriteBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiWriteOverlapped *t_Overlapped = new WmiWriteOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_WriteBytes ,
		a_Bytes
	) ;

	if ( t_Overlapped )
	{
		t_Overlapped->SetState ( 1 ) ;

		t_StatusCode = WriteBegin (

			t_Overlapped ,
			0
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: LockOnThread ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiLockOverlapped *t_Overlapped = new WmiLockOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_OffSetSize
	) ;

	if ( t_Overlapped )
	{
		t_Overlapped->SetState ( 1 ) ;

		t_StatusCode = LockBegin (

			t_Overlapped ,
			0 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: TaskBegin ( 

	WmiTaskOverlapped *a_Overlapped
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Overlapped->SetState ( 1 ) ;

	a_Overlapped->GetOperationFunction ()->Operation ( 

		t_StatusCode
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: UnLockOnThread ( 

	WmiFileOperation *a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiUnLockOverlapped *t_Overlapped = new WmiUnLockOverlapped (

		*this ,
		a_OperationFunction ,
		a_OffSet ,
		a_OffSetSize
	) ;

	if ( t_Overlapped )
	{
		t_Overlapped->SetState ( 1 ) ;

		t_StatusCode = UnLockBegin (

			t_Overlapped ,
			0 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: ReadBegin ( 

	WmiReadOverlapped *a_Overlapped , 
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Overlapped->SetState ( 1 ) ;

	DWORD t_Bytes = 0 ;

	t_StatusCode = Read (

		a_Overlapped->GetBuffer () ,
		a_Overlapped->GetBufferSize () ,
		& t_Bytes ,
		( OVERLAPPED * ) a_Overlapped 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Overlapped->GetOperationFunction ()->Operation ( 

			t_StatusCode ,
			a_Overlapped->GetBuffer () ,
			a_Overlapped->GetBufferSize ()
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: WriteBegin ( 

	WmiWriteOverlapped *a_Overlapped , 
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Overlapped->SetState ( 1 ) ;

	DWORD t_Bytes = 0 ;

	t_StatusCode = Write (

		a_Overlapped->GetBuffer () ,
		a_Overlapped->GetBufferSize () ,
		& t_Bytes ,
		( OVERLAPPED * ) a_Overlapped 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Overlapped->GetOperationFunction ()->Operation ( 

			t_StatusCode ,
			a_Overlapped->GetBuffer () ,
			a_Overlapped->GetBufferSize ()
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: LockBegin ( 

	WmiLockOverlapped *a_Overlapped , 
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Overlapped->SetState ( 1 ) ;

	t_StatusCode = Lock (

		LOCKFILE_EXCLUSIVE_LOCK ,
		a_Overlapped->GetOffSetSize () & 0xFFFFFFFF ,
		a_Overlapped->GetOffSetSize () >> 32 ,
		( OVERLAPPED * ) a_Overlapped 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Overlapped->GetOperationFunction ()->Operation ( 

			t_StatusCode ,
			NULL ,
			0
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: UnLockBegin ( 

	WmiUnLockOverlapped *a_Overlapped , 
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Overlapped->SetState ( 1 ) ;

	t_StatusCode = UnLock (

		a_Overlapped->GetOffSetSize () & 0xFFFFFFFF ,
		a_Overlapped->GetOffSetSize () >> 32 ,
		( OVERLAPPED * ) a_Overlapped 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		t_StatusCode = Win32ToApi () ;

		a_Overlapped->GetOperationFunction ()->Operation ( 

			t_StatusCode ,
			NULL ,
			0
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiIoScheduler :: ReadComplete ( WmiReadOverlapped *a_Overlapped , DWORD a_Bytes )
{
	a_Overlapped->GetOperationFunction ()->Operation ( 

		a_Overlapped->GetStatus () ,
		a_Overlapped->GetBuffer () ,
		a_Overlapped->GetBufferSize ()
	) ;

	delete a_Overlapped ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiIoScheduler :: WriteComplete ( WmiWriteOverlapped *a_Overlapped , DWORD a_Bytes )
{
	a_Overlapped->GetOperationFunction ()->Operation ( 

		a_Overlapped->GetStatus () ,
		a_Overlapped->GetBuffer () ,
		a_Overlapped->GetBufferSize ()
	) ;

	delete a_Overlapped ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiIoScheduler :: LockComplete ( WmiLockOverlapped *a_Overlapped , DWORD a_Bytes )
{
	a_Overlapped->GetOperationFunction ()->Operation ( 

		a_Overlapped->GetStatus () ,
		NULL ,
		0
	) ;

	delete a_Overlapped ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiIoScheduler :: UnLockComplete ( WmiUnLockOverlapped *a_Overlapped , DWORD a_Bytes )
{
	a_Overlapped->GetOperationFunction ()->Operation ( 

		a_Overlapped->GetStatus () ,
		NULL ,
		0
	) ;

	delete a_Overlapped ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: SetFileExtent (

	const WmiFileOffSet &a_FileOffSet 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	LARGE_INTEGER t_Integer ;
	t_Integer.QuadPart = a_FileOffSet ;

	BOOL t_Status = SetFilePointerEx ( 

		GetFileHandle () ,
		t_Integer ,
		NULL ,
		FILE_END 
	) ;

	if ( t_Status )
	{
		t_Status = SetEndOfFile ( GetFileHandle () ) ;
		if ( t_Status == FALSE )
		{
			t_StatusCode = e_StatusCode_OutOfResources ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Create ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_FileName ) 
	{
		SECURITY_DESCRIPTOR t_SecurityDescriptor ;

		HRESULT t_Result = GetSecurityDescriptor ( t_SecurityDescriptor , 0 ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			SECURITY_ATTRIBUTES t_SecurityAttributes ;

			t_SecurityAttributes.nLength = sizeof ( SECURITY_ATTRIBUTES ) ; 
			t_SecurityAttributes.lpSecurityDescriptor = & t_SecurityDescriptor ; 
			t_SecurityAttributes.bInheritHandle = FALSE ; 

#if 0
			m_FileHandle = CreateFile ( 

				m_FileName ,
				GENERIC_READ | GENERIC_WRITE | MAXIMUM_ALLOWED ,
				0 ,
				& t_SecurityAttributes ,
				OPEN_ALWAYS ,
				FILE_FLAG_OVERLAPPED | FILE_FLAG_RANDOM_ACCESS ,
				NULL 
			) ;
#else
			m_FileHandle = CreateFile ( 

				m_FileName ,
				GENERIC_READ | GENERIC_WRITE | MAXIMUM_ALLOWED ,
				FILE_SHARE_READ | FILE_SHARE_WRITE ,
				NULL ,
				OPEN_ALWAYS ,
				FILE_FLAG_OVERLAPPED | FILE_FLAG_RANDOM_ACCESS ,
				NULL 
			) ;

#endif
			if ( m_FileHandle != INVALID_HANDLE_VALUE )
			{
			}
			else
			{
				t_StatusCode = Win32ToApi () ;
			}

			delete [] t_SecurityDescriptor.Dacl ;
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_InvalidArgs ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Close ()
{
	if ( m_FileHandle ) 
	{
		CloseHandle ( m_FileHandle ) ;
		m_FileHandle = 0 ;
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Read (

	LPVOID a_Buffer ,
	DWORD a_NumberOfBytesToRead ,
	LPDWORD a_NumberOfBytesRead ,
	LPOVERLAPPED a_Overlapped
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	DWORD t_Bytes = 0 ;

	BOOL t_Status = ReadFile (

		m_FileHandle ,
		a_Buffer ,
		a_NumberOfBytesToRead ,
		a_NumberOfBytesRead ,
		( OVERLAPPED * ) a_Overlapped 
	) ;

	if ( t_Status ) 
	{
	}
	else
	{
		t_StatusCode = Win32ToApi () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Write (

	LPVOID a_Buffer ,
	DWORD a_NumberOfBytesToWrite ,
	LPDWORD a_NumberOfBytesWritten ,
	LPOVERLAPPED a_Overlapped
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Status = WriteFile (

		m_FileHandle ,
		a_Buffer ,
		a_NumberOfBytesToWrite ,
		a_NumberOfBytesWritten ,
		a_Overlapped
	) ;

	if ( t_Status ) 
	{
	}
	else
	{
		t_StatusCode = Win32ToApi () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: Lock (

	DWORD a_Flags ,
	DWORD a_NumberOfBytesToLockLow ,
	DWORD a_NumberOfBytesToLockHigh ,
	LPOVERLAPPED a_Overlapped       
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Status = LockFileEx (

		m_FileHandle ,
		a_Flags ,
		0 ,
		a_NumberOfBytesToLockLow ,
		a_NumberOfBytesToLockHigh ,
		a_Overlapped       
	) ;

	if ( t_Status ) 
	{
	}
	else
	{
		t_StatusCode = Win32ToApi () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiIoScheduler :: UnLock (

	DWORD a_NumberOfBytesToUnlockLow ,
	DWORD a_NumberOfBytesToUnlockHigh ,
	LPOVERLAPPED a_Overlapped
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Status = UnlockFileEx (

		m_FileHandle ,
		0 ,
		a_NumberOfBytesToUnlockLow ,
		a_NumberOfBytesToUnlockHigh ,
		a_Overlapped 
	) ;

	if ( t_Status ) 
	{
	}
	else
	{
		t_StatusCode = Win32ToApi () ;
	}

	return t_StatusCode ;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\keyedarray.cpp ===
#ifndef __KEYEDARRAY_CPP
#define __KEYEDARRAY_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <KeyedArray.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: WmiKeyedArray <WmiKey,WmiElement,GrowSize> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_AllocatedSize ( 0 ) ,
	m_Block ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: ~WmiKeyedArray <WmiKey,WmiElement,GrowSize> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Block )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_Size ; t_Index ++ )
		{
			WmiArrayNode *t_Node = & m_Block [ t_Index ] ;
			t_Node->~WmiArrayNode () ;
		}

		WmiStatusCode t_StatusCode = m_Allocator.Delete (

			( void * ) m_Block
		) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	ULONG t_LowerIndex = 0 ;
	ULONG t_UpperIndex = m_Size ;

	while ( t_LowerIndex < t_UpperIndex )
	{
		ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

#if 0
		LONG t_Compare = CompareElement ( a_Key , m_Block [ t_Index ].m_Key ) ;
		if ( t_Compare == 0 ) 
#else
		if ( a_Key == m_Block [ t_Index ].m_Key )
#endif
		{
			return e_StatusCode_AlreadyExists ;
		}
		else 
		{
#if 0
			if ( t_Compare < 0 ) 
#else
			if ( a_Key < m_Block [ t_Index ].m_Key )
#endif
			{
				t_UpperIndex = t_Index ;
			}
			else
			{
				t_LowerIndex = t_Index + 1 ;
			}
		}
	}	

	WmiStatusCode t_StatusCode ;
	WmiArrayNode *t_Block ;

	if ( m_Block )
	{
		if ( m_Size == m_AllocatedSize )
		{
			t_StatusCode = m_Allocator.ReAlloc (

				( void ** ) m_Block ,
				( void ** ) &t_Block ,
				( m_Size + GrowSize ) * sizeof ( WmiArrayNode ) 
			) ;	

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_Block = t_Block ;

				MoveMemory ( & m_Block [ t_LowerIndex + 1 ] , & m_Block [ t_LowerIndex ] , ( m_Size - t_LowerIndex ) * sizeof ( WmiArrayNode ) ) ;

				WmiArrayNode *t_Node = & m_Block [ t_LowerIndex ] ;

				::  new ( ( void* ) t_Node ) WmiArrayNode () ;

				t_Node->m_Element = a_Element ;
				t_Node->m_Key = a_Key ;

				a_Iterator = Iterator ( this , t_LowerIndex ) ;

				m_Size ++ ;
				m_AllocatedSize = m_AllocatedSize + GrowSize ;
			}

			return t_StatusCode ;
		}
		else
		{
			MoveMemory ( & m_Block [ t_LowerIndex + 1 ] , & m_Block [ t_LowerIndex ] , ( m_Size - t_LowerIndex ) * sizeof ( WmiArrayNode ) ) ;

			WmiArrayNode *t_Node = & m_Block [ t_LowerIndex ] ;

			::  new ( ( void* ) t_Node ) WmiArrayNode () ;

			t_Node->m_Element = a_Element ;
			t_Node->m_Key = a_Key ;

			a_Iterator = Iterator ( this , t_LowerIndex ) ;

			m_Size ++ ;

			return e_StatusCode_Success ;
		}
	}
	else
	{
		t_StatusCode = m_Allocator.New (

			( void ** ) & t_Block ,
			GrowSize * sizeof ( WmiArrayNode ) 
		) ;	

		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Block = t_Block ;

			WmiArrayNode *t_Node = & m_Block [ 0 ] ;

			::  new ( ( void* ) t_Node ) WmiArrayNode () ;

			t_Node->m_Element = a_Element ;
			t_Node->m_Key = a_Key ;

			a_Iterator = Iterator ( this , t_LowerIndex ) ;

			m_Size ++ ;
			m_AllocatedSize = m_AllocatedSize + GrowSize ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: Delete ( 

	const WmiKey &a_Key
)
{
	if ( m_Block )
	{
		ULONG t_LowerIndex = 0 ;
		ULONG t_UpperIndex = m_Size ;

		while ( t_LowerIndex < t_UpperIndex )
		{
			ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

#if 0
			LONG t_Compare = CompareElement ( a_Key , m_Block [ t_Index ].m_Key ) ;
			if ( t_Compare == 0 ) 
#else
			if ( a_Key == m_Block [ t_Index ].m_Key )
#endif
			{
				MoveMemory ( & m_Block [ t_Index ] , & m_Block [ t_Index + 1 ] , ( m_Size - 1 - t_Index ) * sizeof ( WmiArrayNode ) ) ;

				if ( m_Size == m_AllocatedSize - GrowSize )
				{
					WmiStatusCode t_StatusCode ;
					WmiArrayNode *t_Block ;

					t_StatusCode = m_Allocator.ReAlloc (

						( void ** ) m_Block ,
						( void ** ) &t_Block ,
						( m_Size - 1 ) * sizeof ( WmiArrayNode ) 
					) ;	

					if ( t_StatusCode == e_StatusCode_Success )
					{
						m_Block = t_Block ;

						m_Size -- ;
						m_AllocatedSize = m_AllocatedSize - GrowSize ;

						return t_StatusCode ;
					}
				}
				else
				{
					m_Size -- ;

					return e_StatusCode_Success ;
				}
			}
			else 
			{
#if 0
				if ( t_Compare < 0 ) 
#else
				if ( a_Key < m_Block [ t_Index ].m_Key )
#endif
				{
					t_UpperIndex = t_Index ;
				}
				else
				{
					t_LowerIndex = t_Index + 1 ;
				}
			}
		}	
	}

	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	ULONG t_LowerIndex = 0 ;
	ULONG t_UpperIndex = m_Size ;

	while ( t_LowerIndex < t_UpperIndex )
	{
		ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

#if 0
		LONG t_Compare = CompareElement ( a_Key , m_Block [ t_Index ].m_Key ) ;
		if ( t_Compare == 0 ) 
#else
		if ( a_Key == m_Block [ t_Index ].m_Key ) 
#endif
		{
			a_Iterator = Iterator ( this , t_Index ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
#if 0
			if ( t_Compare < 0 ) 
#else
			if ( a_Key < m_Block [ t_Index ].m_Key ) 
#endif
			{
				t_UpperIndex = t_Index ;
			}
			else
			{
				t_LowerIndex = t_Index + 1 ;
			}
		}
	}	

	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	if ( m_Size )
	{
		ULONG t_LowerIndex = 0 ;
		ULONG t_UpperIndex = m_Size ;

		while ( t_LowerIndex < t_UpperIndex )
		{
			ULONG t_Index = ( t_LowerIndex + t_UpperIndex ) >> 1 ;

#if 0
			LONG t_Compare = CompareElement ( a_Key , m_Block [ t_Index ].m_Key ) ;
			if ( t_Compare == 0 ) 
#else
			if ( a_Key == m_Block [ t_Index ].m_Key ) 
#endif
			{
				a_Iterator = Iterator ( this , t_Index ).Increment () ;
				return e_StatusCode_Success ;
			}
			else 
			{
#if 0
				if ( t_Compare < 0 ) 
#else
				if ( a_Key < m_Block [ t_Index ].m_Key ) 
#endif
				{
					t_UpperIndex = t_Index ;
				}
				else
				{
					t_LowerIndex = t_Index + 1 ;
				}
			}
		}	

		a_Iterator = Iterator ( this , t_Lower ).Increment () ;

		return e_StatusCode_Success ;
	}
	else
	{
		return e_StatusCode_NotFound ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG GrowSize>
WmiStatusCode WmiKeyedArray <WmiKey,WmiElement,GrowSize> :: Merge ( 

	WmiKeyedArray <WmiKey,WmiElement,GrowSize> &a_Tree
)
{
#if 0
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;


	Iterator t_Iterator = a_Tree.Root ();

	while ( ! t_Iterator.Null () )
	{
		Iterator t_InsertIterator ;
		WmiStatusCode t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
#else
	return e_StatusCode_NotFound ;
#endif
}

#endif __KEYEDARRAY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\logging.cpp ===
//***************************************************************************

//

//  PROVLOG.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <stdio.h>
#include <string.h>
#include <Allocator.h>
#include <Algorithms.h>
#include <RedBlackTree.h>
#include <Logging.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define LOG_KEY				    L"Software\\Microsoft\\WBEM\\CIMOM\\Logging"
#define LOG_KEY_SLASH           L"Software\\Microsoft\\WBEM\\CIMOM\\Logging\\"
#define LOGGING_ON				L"Logging"
#define BACKSLASH_STRING		L"\\"
#define DEFAULT_FILE_EXT		L".log"
#define LOGGING_DIR_VALUE		L"Logging Directory"
#define LOGGING_DIR_KEY			L"Software\\Microsoft\\WBEM\\CIMOM"
#define DEFAULT_PATH			L"C:\\"
#define DEFAULT_FILE_SIZE		0x100000
#define MIN_FILE_SIZE			1024
#define MAX_MESSAGE_SIZE		1024

#define LOG_FILE_NAME               L"File"
#define LOG_LEVEL_NAME				L"Level"
#define LOG_FILE_SIZE				L"MaxFileSize"
#define LOG_TYPE_NAME               L"Type"
#define LOG_TYPE_FILE_STRING		L"File"
#define LOG_TYPE_DEBUG_STRING		L"Debugger"

long WmiDebugLog :: s_ReferenceCount = 0 ;

typedef WmiBasicTree <WmiDebugLog *,WmiDebugLog *> LogContainer ;
typedef WmiBasicTree <WmiDebugLog *,WmiDebugLog *> :: Iterator LogContainerIterator ;

LogContainer *g_LogContainer = NULL ;

CriticalSection g_WmiDebugLogMapCriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiDebugTaskObject : public WmiTask <ULONG>
{
private:

	HKEY m_LogKey ;

protected:
public:

	WmiDebugTaskObject ( WmiAllocator &a_Allocator ) ;
	~WmiDebugTaskObject () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	void SetRegistryNotification () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject :: WmiDebugTaskObject (

	WmiAllocator &a_Allocator 

) : WmiTask <ULONG> ( a_Allocator ) , 
	m_LogKey ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject :: ~WmiDebugTaskObject ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugTaskObject :: Process ( WmiThread <ULONG> &a_Thread )
{
	WmiDebugLog *t_WmiDebugLog = NULL ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		LogContainerIterator t_Iterator = g_LogContainer->Begin () ;
		while ( ! t_Iterator.Null () )
		{
			t_Iterator.GetElement ()->LoadRegistry () ;
			t_Iterator.GetElement ()->SetRegistry () ;

			t_Iterator.Increment () ;
		}

		WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	}

	SetRegistryNotification () ;

	Complete () ;

	return e_StatusCode_EnQueue ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef LONG ( *FuncRegNotifyChangeKeyValue ) (

	HKEY hKey,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter,
	HANDLE hEvent,
	BOOL fAsynchronous
) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugTaskObject :: SetRegistryNotification ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_LogKey )
		{
			RegCloseKey ( m_LogKey ) ;
			m_LogKey = NULL ;
		}

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			LOGGING_DIR_KEY , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&m_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			OSVERSIONINFO t_OS;
			t_OS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
			if ( ! GetVersionEx ( & t_OS ) )
			{
				WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
				return ;
			}

			if ( ! ( t_OS.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && t_OS.dwMinorVersion == 0 ) )
			{
				HINSTANCE t_Library = LoadLibrary( L"ADVAPI32.DLL" );
				if ( t_Library )
				{
					FuncRegNotifyChangeKeyValue t_RegNotifyChangeKeyValue = ( FuncRegNotifyChangeKeyValue ) GetProcAddress ( t_Library , "RegNotifyChangeKeyValue" ) ;

					t_Status = t_RegNotifyChangeKeyValue ( 

						m_LogKey , 
						TRUE , 
						REG_NOTIFY_CHANGE_LAST_SET , 
						GetEvent () , 
						TRUE 
					) ; 

					if ( t_Status == ERROR_SUCCESS )
					{
					}

					FreeLibrary ( t_Library ) ;
				}
			}
		}

		WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiDebugThreadObject : public WmiThread <ULONG> 
{
private:

	WmiDebugTaskObject *m_WmiDebugTaskObject ;
	WmiAllocator &m_Allocator ;
		
public:

	WmiDebugThreadObject ( WmiAllocator &a_Allocator , const wchar_t *a_Thread ) ;
	~WmiDebugThreadObject () ;

	WmiStatusCode Initialize () ;

	WmiDebugTaskObject *GetTaskObject () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject *g_WmiDebugLogThread = NULL ;

WmiDebugLog *WmiDebugLog :: s_WmiDebugLog = NULL ;
BOOL WmiDebugLog :: s_Initialised = FALSE ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject :: WmiDebugThreadObject (

	WmiAllocator &a_Allocator , 
	const wchar_t *a_Thread

) :	WmiThread <ULONG> ( a_Allocator , a_Thread ) ,
	m_WmiDebugTaskObject ( NULL ) ,
	m_Allocator ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject :: ~WmiDebugThreadObject ()
{
	delete WmiDebugLog :: s_WmiDebugLog ;
	WmiDebugLog :: s_WmiDebugLog = NULL ;

	if ( m_WmiDebugTaskObject )
	{
		delete m_WmiDebugTaskObject ;
	}

	WmiHelper :: DeleteCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;

	delete g_LogContainer ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugThreadObject :: Initialize ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		g_LogContainer = new LogContainer ( m_Allocator ) ; 
		if ( g_LogContainer )
		{
			m_WmiDebugTaskObject = new WmiDebugTaskObject ( m_Allocator ) ;
			if ( m_WmiDebugTaskObject )
			{
				WmiDebugLog :: s_WmiDebugLog = new WmiDebugLog ( m_Allocator ) ;
				if ( WmiDebugLog :: s_WmiDebugLog )
				{
					t_StatusCode = WmiDebugLog :: s_WmiDebugLog->Initialize ( L"ProviderSubSystem" ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						EnQueueAlertable ( GetTickCount () , *m_WmiDebugTaskObject ) ;
						m_WmiDebugTaskObject->Exec () ;
					}
					else
					{
						delete WmiDebugLog :: s_WmiDebugLog ;
						WmiDebugLog :: s_WmiDebugLog = NULL ;

						delete m_WmiDebugTaskObject ;
						m_WmiDebugTaskObject = NULL ;

						delete g_LogContainer ;
						g_LogContainer = NULL ;

						t_StatusCode = e_StatusCode_OutOfMemory ;
					}
				}
				else
				{
					delete m_WmiDebugTaskObject ;
					m_WmiDebugTaskObject = NULL ;

					delete g_LogContainer ;
					g_LogContainer = NULL ;

					t_StatusCode = e_StatusCode_OutOfMemory ;
				}
			}
			else
			{
				delete g_LogContainer ;
				g_LogContainer = NULL ;

				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = WmiThread <ULONG> :: Initialize () ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject *WmiDebugThreadObject :: GetTaskObject ()
{
	return m_WmiDebugTaskObject ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugLog :: WmiDebugLog ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Logging ( FALSE ) ,
	m_Verbose ( FALSE ) ,
	m_DebugLevel ( 0 ) ,
	m_DebugFileSize ( DEFAULT_FILE_SIZE ),
	m_DebugContext ( WmiDebugContext :: FILE ) ,
	m_DebugFile ( NULL ) ,
	m_DebugFileHandle (  INVALID_HANDLE_VALUE ) ,
	m_DebugComponent ( NULL ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: Initialize ( const wchar_t *a_DebugComponent )
{
	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		LogContainerIterator t_Iterator ;

		t_StatusCode = WmiHelper :: EnterCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = g_LogContainer->Insert ( this , this , t_Iterator ) ;

			WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
		}

		if ( a_DebugComponent )
		{
			m_DebugComponent = _wcsdup ( a_DebugComponent ) ;
			if ( m_DebugComponent == NULL )
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
		}

		LoadRegistry () ;
		SetRegistry () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugLog :: ~WmiDebugLog ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = g_LogContainer->Delete ( this ) ;

		WmiHelper :: LeaveCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
	}

	CloseOutput () ;

	if ( m_DebugComponent )
	{
		free ( m_DebugComponent ) ;
	}

	if ( m_DebugFile )
	{
		free ( m_DebugFile ) ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetDefaultFile ( )
{
	HKEY hkey;

	LONG result =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								LOGGING_DIR_KEY, 0, KEY_READ, &hkey);

	if (result == ERROR_SUCCESS)
	{
		wchar_t t_path [MAX_PATH + 1];
		DWORD t_ValueType = REG_SZ;
		DWORD t_ValueLength = MAX_PATH + 1;

		result = RegQueryValueEx( 
			hkey , 
			LOGGING_DIR_VALUE , 
			0, 
			&t_ValueType ,
			( LPBYTE ) t_path , 
			&t_ValueLength 
		) ;

		if ((result == ERROR_SUCCESS) && (t_ValueType == REG_SZ || t_ValueType == REG_EXPAND_SZ))
		{
			wcscat(t_path, BACKSLASH_STRING);
			wcscat(t_path, m_DebugComponent);
			wcscat(t_path, DEFAULT_FILE_EXT);
			SetFile (t_path);
		}

		RegCloseKey(hkey);
	}

	if (m_DebugFile == NULL)
	{
		wchar_t path[MAX_PATH + 1];
		swprintf(path, L"%s%s%s", DEFAULT_PATH, m_DebugComponent, DEFAULT_FILE_EXT);
		SetFile (path);
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SwapFileOver()
{
	Flush();
	CloseOutput();

	//prepend a character to the log file name
	wchar_t* buff = new wchar_t[wcslen(m_DebugFile) + 2];
	if (buff==0)
		return;


	//find the last occurrence of \ for dir
	wchar_t* tmp = wcsrchr(m_DebugFile, '\\');

	if (tmp != NULL)
	{
		tmp++;
		wcsncpy(buff, m_DebugFile, wcslen(m_DebugFile) - wcslen(tmp));
		buff[wcslen(m_DebugFile) - wcslen(tmp)] = L'\0';
		wcscat(buff, L"~");
		wcscat(buff, tmp);
	}
	else
	{
		wcscpy(buff, L"~");
		wcscat(buff, m_DebugFile);
	}

	//move the file and reopen...
	if (!MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))
	{
#if 0
		DWORD x = GetLastError();
		wchar_t* buff2;

		if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
								NULL, x, 0, (LPWSTR) &buff2, 80, NULL))
		{
			DWORD dwErr = GetLastError();
		}
		else
		{
			LocalFree(buff2);
		}
#endif
		//try deleting the file and then moving it
		DeleteFile(buff);
		MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
		DeleteFile(m_DebugFile);
	}

	//open file regardless of whether move file worked...
	OpenOutput();
	delete [] buff;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: WriteOutput ( const wchar_t *a_OutputDebugString )
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
			{
				CloseOutput();
				OpenOutput();
			}

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				DWORD dwToWrite = sizeof ( wchar_t ) * ( wcslen ( a_OutputDebugString ) );
				LPCVOID thisWrite = ( LPCVOID ) a_OutputDebugString;
				BOOL t_Status = TRUE;

				while ((dwToWrite != 0) && (t_Status))
				{
					DWORD dwSize;
					dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END ); 

					//if the file is too big swap it...
#ifdef _UNICODE
					//only whole (2byte) characters written to file
					if ((m_DebugFileSize > 0) && (dwSize >= (m_DebugFileSize - 1)))
#else
					if ((m_DebugFileSize > 0) && (dwSize >= m_DebugFileSize))
#endif
					{
						SwapFileOver();

						if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
						{
							break;
						}

						if (m_DebugFileSize > 0)
						{
							dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END );  
						}
					}

					if (dwSize ==  0xFFFFFFFF)
					{
						break;
					}

					DWORD t_BytesWritten = 0 ;
					DWORD dwThisWrite;

					if ((m_DebugFileSize > 0) && (dwToWrite + dwSize > m_DebugFileSize))
					{
						dwThisWrite = m_DebugFileSize - dwSize;
#ifdef _UNICODE
						if ((dwThisWrite > 1) && (dwThisWrite%2))
						{
							dwThisWrite--;
						}
#endif
					}
					else
					{
						dwThisWrite = dwToWrite;
					}

					LockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0); 
					t_Status = WriteFile ( 
			
						m_DebugFileHandle ,
						thisWrite ,
						dwThisWrite ,
						& t_BytesWritten ,
						NULL 
					) ;
					UnlockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0);

					//get ready for next write...
					dwToWrite -= t_BytesWritten;
					thisWrite = (LPCVOID)((UCHAR*)thisWrite + t_BytesWritten);
				}
			}
		}
		break ;

		case DEBUG:
		{
			OutputDebugString ( a_OutputDebugString ) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: OpenFileForOutput ()
{
	if ( m_DebugFile )
	{
		m_DebugFileHandle = CreateFile (
			
			m_DebugFile ,
			GENERIC_WRITE ,
#ifdef _UNICODE 
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
			FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
			NULL ,
			OPEN_EXISTING ,
			FILE_ATTRIBUTE_NORMAL ,
			NULL 
		) ;

		if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
		{
			m_DebugFileHandle = CreateFile (

				m_DebugFile ,
				GENERIC_WRITE ,
#ifdef _UNICODE 
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
				FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
				NULL ,
				OPEN_ALWAYS ,
				FILE_ATTRIBUTE_NORMAL ,
				NULL 
			) ;

#ifdef _UNICODE 

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				UCHAR t_UnicodeBytes [ 2 ] ;
				t_UnicodeBytes [ 0 ] = 0xFF ;
				t_UnicodeBytes [ 1 ] = 0xFE ;

				DWORD t_BytesWritten = 0 ;

				LockFile(m_DebugFileHandle, 0, 0, 2, 0); 

				WriteFile ( 
			
					m_DebugFileHandle ,
					( LPCVOID ) & t_UnicodeBytes ,
					sizeof ( t_UnicodeBytes ) ,
					& t_BytesWritten ,
					NULL 
				) ;

				UnlockFile(m_DebugFileHandle, 0, 0, 2, 0); 
			}
#endif

		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: OpenOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			OpenFileForOutput () ;
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: FlushOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				FlushFileBuffers ( m_DebugFileHandle ) ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: CloseOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE ) 
			{
				CloseHandle ( m_DebugFileHandle ) ;
				m_DebugFileHandle =  INVALID_HANDLE_VALUE ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Write ( const wchar_t *a_DebugFormatString , ... )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_Logging )
		{
			wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
			va_list t_VarArgList ;

			va_start(t_VarArgList,a_DebugFormatString);
			int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE - 1 , a_DebugFormatString , t_VarArgList );
			t_OutputDebugString [ t_Length ] = ( wchar_t ) 0 ;
			va_end(t_VarArgList);

			WriteOutput ( t_OutputDebugString ) ;
		}

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Write ( const wchar_t *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_Logging )
		{
#ifdef BUILD_WITH_FILE_AND_LINE

			wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

			_snwprintf ( t_OutputDebugString , MAX_MESSAGE_SIZE >> 1 , L"\r\n(%s):(%lu):" , a_File , a_Line ) ;
			WriteOutput ( t_OutputDebugString ) ;

			va_list t_VarArgList ;
			va_start(t_VarArgList,a_DebugFormatString);
			int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE - 1 , a_DebugFormatString , t_VarArgList );
			t_OutputDebugString [ t_Length ] = ( wchar_t ) 0 ;
			va_end(t_VarArgList);

			WriteOutput ( t_OutputDebugString ) ;

#else

			wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

			_snwprintf ( t_OutputDebugString , MAX_MESSAGE_SIZE >> 1 , L"\r\n" ) ;
			WriteOutput ( t_OutputDebugString ) ;

			va_list t_VarArgList ;
			va_start(t_VarArgList,a_DebugFormatString);
			int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE - 1 , a_DebugFormatString , t_VarArgList );
			t_OutputDebugString [ t_Length ] = ( wchar_t ) 0 ;
			va_end(t_VarArgList);

			WriteOutput ( t_OutputDebugString ) ;

#endif

		}

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Flush ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		FlushOutput () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetLogging ( BOOL a_Logging )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Logging = a_Logging ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetLevel ( const DWORD &a_DebugLevel ) 
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_DebugLevel = a_DebugLevel ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetContext ( const enum WmiDebugContext &a_DebugContext ) 
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_DebugContext = a_DebugContext ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiDebugLog :: WmiDebugContext WmiDebugLog :: GetContext () 
{
	WmiDebugContext t_Context = m_DebugContext ;

	return t_Context ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog ::CommitContext ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		CloseOutput () ;
		OpenOutput () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog ::SetFile ( const wchar_t *a_File )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if (m_DebugFile)
		{
			free ( m_DebugFile ) ;
		}

		m_DebugFile = _wcsdup ( a_File ) ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		LoadRegistry_Logging  () ;
		LoadRegistry_Level () ;
		LoadRegistry_File () ;
		LoadRegistry_Type () ;
		LoadRegistry_FileSize ();
		CommitContext () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOGGING_DIR_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_SZ ;
		wchar_t t_ValueString [ 2 ] ;
		DWORD t_ValueLength = sizeof ( t_ValueString ) ;

		ZeroMemory ( t_ValueString , t_ValueLength ) ;

		t_Status = RegQueryValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			&t_ValueType ,
			( LPBYTE ) t_ValueString , 
			&t_ValueLength 
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			switch ( t_ValueString [ 0 ] )
			{
				case L'0':
				{
					m_Logging = FALSE ;
				}
				break ;

				case L'1':
				{
					m_Logging = TRUE ;
					m_Verbose = FALSE ;
				}
				break ;

				case L'2':
				{
					m_Verbose = TRUE ;
					m_Logging = TRUE ;
				}
				break ;
			}
		}

		RegCloseKey ( t_LogKey ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Size ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Size , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugFileSize = t_Size ;

				if (m_DebugFileSize < MIN_FILE_SIZE)
				{
					m_DebugFileSize = MIN_FILE_SIZE ;
				}
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Level , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugLevel = t_Level ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_File ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			wchar_t *t_File = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_File , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				t_File = new wchar_t [ t_ValueLength ] ;

				t_Status = RegQueryValueEx( 

					t_LogKey , 
					LOG_FILE_NAME , 
					0, 
					&t_ValueType ,
					( LPBYTE ) t_File , 
					&t_ValueLength 
				) ;

				if ( (t_Status == ERROR_SUCCESS) && t_File && (*t_File != L'\0' ) )
				{
					SetFile ( t_File ) ;
				}
				else
				{
					SetDefaultFile();
				}

				delete [] t_File ;
			}
			else
			{
				SetDefaultFile();
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			wchar_t *t_Type = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_Type , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				t_Type = new wchar_t [ t_ValueLength ] ;

				t_Status = RegQueryValueEx( 

					t_LogKey , 
					LOG_TYPE_NAME , 
					0, 
					&t_ValueType ,
					( LPBYTE ) t_Type , 
					&t_ValueLength 
				) ;

				if ( t_Status == ERROR_SUCCESS )
				{
					if ( wcscmp ( t_Type , LOG_TYPE_DEBUG_STRING ) == 0 )
					{
						SetContext ( DEBUG ) ;
					}
					else
					{
						SetContext ( FILE ) ;
					}
				}

				delete [] t_Type;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		SetRegistry_Logging  () ;
		SetRegistry_Level () ;
		SetRegistry_File () ;
		SetRegistry_FileSize () ;
		SetRegistry_Type () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOGGING_DIR_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;
			
	if ( t_Status == ERROR_SUCCESS )
	{
		wchar_t t_ValueString [ 2 ] ;
		DWORD t_ValueLength = sizeof ( t_ValueString ) ;
		DWORD t_ValueType = REG_SZ ;

		t_ValueString [ 1 ] = 0 ;

		if ( m_Logging ) 
		{
			if ( m_Verbose )
			{
				t_ValueString [ 0 ] = L'2' ;
			}
			else
			{
				t_ValueString [ 0 ] = L'1' ;
			}
		}
		else
		{
			t_ValueString [ 0 ] = L'0' ;
		}

		t_Status = RegSetValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			t_ValueType ,
			( LPBYTE ) t_ValueString , 
			t_ValueLength 
		) ;

		RegCloseKey ( t_LogKey ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}
		
		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugFileSize ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugLevel ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_File ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			if ( m_DebugFile )
			{
				wchar_t *t_File = m_DebugFile ;
				DWORD t_ValueType = REG_SZ ;
				DWORD t_ValueLength = ( wcslen ( t_File ) + 1 ) * sizeof ( wchar_t ) ;

				t_Status = RegSetValueEx( 

					t_LogKey , 
					LOG_FILE_NAME , 
					0, 
					t_ValueType ,
					( LPBYTE ) t_File , 
					t_ValueLength 
				) ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		wchar_t *t_ComponentKeyString = ( wchar_t * ) malloc ( 

			( wcslen ( LOG_KEY_SLASH ) + wcslen ( m_DebugComponent ) + 1 ) * sizeof ( wchar_t ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		wcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			wchar_t *t_Debugger = LOG_TYPE_DEBUG_STRING ;
			wchar_t *t_File = LOG_TYPE_FILE_STRING ;
			wchar_t *t_Type = ( m_DebugContext == DEBUG ) ? t_Debugger : t_File ; 
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = ( wcslen ( t_Type ) + 1 ) * sizeof ( wchar_t ) ;

			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) t_Type , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetEventNotification ()
{
	g_WmiDebugLogThread->GetTaskObject ()->SetRegistryNotification () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: Initialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedIncrement ( & s_ReferenceCount ) == 1 )
	{
		if ( ! s_Initialised )
		{
#if DBG
			t_StatusCode =  WmiThread <ULONG> :: Static_Initialize ( a_Allocator ) ;

			g_WmiDebugLogThread = new WmiDebugThreadObject ( a_Allocator , L"WmiDebugLogThread" ) ;
			if ( g_WmiDebugLogThread )
			{
				g_WmiDebugLogThread->AddRef () ;

				t_StatusCode = g_WmiDebugLogThread->Initialize () ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					SetEventNotification () ;

					s_Initialised = TRUE ;
				}
				else
				{
					g_WmiDebugLogThread->Release () ;
					g_WmiDebugLogThread = NULL ;
				}
			}
			else
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
#else
			s_Initialised = TRUE ;
#endif
		}
	}
	
	return e_StatusCode_Success  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: UnInitialize ( WmiAllocator &a_Allocator )
{
	if ( InterlockedDecrement ( & s_ReferenceCount ) == 0 )
	{
#if DBG
		HANDLE t_ThreadHandle = NULL ; 

		BOOL t_Status = DuplicateHandle ( 

			GetCurrentProcess () ,
			g_WmiDebugLogThread->GetHandle () ,
			GetCurrentProcess () ,
			& t_ThreadHandle, 
			0 , 
			FALSE , 
			DUPLICATE_SAME_ACCESS
		) ;

		if ( t_Status )
		{
			g_WmiDebugLogThread->Release () ;
	
			WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

			CloseHandle ( t_ThreadHandle ) ;

			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( a_Allocator );

			s_Initialised = FALSE ;
		}
#else
		s_Initialised = FALSE ;
#endif
	}

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\helperfuncs.cpp ===
#ifndef __HELPERFUNCS_CPP
#define __HELPERFUNCS_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <Windows.h>
#include <assert.h>
#include <Allocator.h>
#include <pssException.h>
#include <HelperFuncs.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
#if 0
WmiStatusCode WmiHelper :: InitializeCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	SetStructuredExceptionHandler t_StructuredException ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	try
	{
		:: InitializeCriticalSection ( a_CriticalSection ) ;
	}
	catch ( Structured_Exception & t_StructuredException )
	{
		if ( t_StructuredException.GetExceptionCode () == STATUS_NO_MEMORY )
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
			assert ( FALSE ) ; 
#endif
		}
	}
	catch ( ... )
	{
		t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
		assert ( FALSE ) ; 
#endif
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DeleteCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	:: DeleteCriticalSection ( a_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: EnterCriticalSection ( CRITICAL_SECTION *a_CriticalSection , BOOL a_WaitCritical )
{
	SetStructuredExceptionHandler t_StructuredException ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Do ;

	do 
	{
		try
		{
			:: EnterCriticalSection ( a_CriticalSection ) ;

			t_Do = FALSE ;
		}
		catch ( Structured_Exception & t_StructuredException )
		{
			t_Do = a_WaitCritical ;

			if ( t_Do )
			{
				Sleep ( 1000 ) ;
			}

			if ( t_StructuredException.GetExceptionCode () == STATUS_NO_MEMORY )
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
				assert ( FALSE ) ; 
#endif
				t_Do = FALSE ;
			}
		}
		catch ( ... )
		{
#ifdef DBG
			assert ( FALSE ) ; 
#endif
			t_Do = FALSE ;

			t_StatusCode = e_StatusCode_Unknown ;
		}
	}
	while ( t_Do ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: LeaveCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	:: LeaveCriticalSection ( a_CriticalSection ) ;

	return t_StatusCode ;
}

#endif

WmiStatusCode WmiHelper :: InitializeCriticalSection ( CriticalSection *a_CriticalSection )
{
	return a_CriticalSection->valid() ? e_StatusCode_Success : e_StatusCode_OutOfMemory;
}

WmiStatusCode WmiHelper :: DeleteCriticalSection ( CriticalSection *a_CriticalSection )
{
	return e_StatusCode_Success ;
}

WmiStatusCode WmiHelper :: EnterCriticalSection ( CriticalSection *a_CriticalSection,  BOOL a_WaitCritical  )
{
	if (a_CriticalSection->valid())
		{
		if (a_CriticalSection->acquire())
			return e_StatusCode_Success;
		if (a_WaitCritical == FALSE )
			return e_StatusCode_OutOfMemory;
		while (!a_CriticalSection->acquire())
			Sleep(1000);
		return e_StatusCode_Success;
		}
	else
		return e_StatusCode_OutOfMemory  ;
}

WmiStatusCode WmiHelper :: LeaveCriticalSection ( CriticalSection *a_CriticalSection )
{
	a_CriticalSection->release();
	return e_StatusCode_Success ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DuplicateString ( WmiAllocator &a_Allocator , const wchar_t *a_String , wchar_t *&a_DuplicatedString ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_String )
	{
		t_StatusCode = a_Allocator.New ( 

			( void ** ) & a_DuplicatedString ,
			sizeof ( wchar_t ) * ( wcslen ( a_String ) + 1 ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			wcscpy ( a_DuplicatedString , a_String ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: CreateUnNamedEvent ( HANDLE &a_Event , BOOL a_ManualReset , BOOL a_InitialState ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Event = CreateEvent ( NULL , a_ManualReset , a_InitialState , NULL ) ;
	if ( ! a_Event )		
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: CreateNamedEvent ( wchar_t *a_Name , HANDLE &a_Event , BOOL a_ManualReset , BOOL a_InitialState ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Event = CreateEvent (

			NULL ,
			a_ManualReset ,
			a_InitialState ,
			a_Name 
		) ;

		if ( a_Event == NULL )
		{
			if ( GetLastError () == ERROR_ALREADY_EXISTS )
			{
				a_Event = OpenEvent (

					EVENT_ALL_ACCESS ,
					FALSE , 
					a_Name
				) ;

				if ( a_Event == NULL )
				{
					t_StatusCode = e_StatusCode_Unknown ;
				}
			}
			else
			{
				t_StatusCode = e_StatusCode_OutOfResources ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DuplicateHandle ( HANDLE a_Handle , HANDLE &a_DuplicatedHandle ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_ProcessHandle = GetCurrentProcess ();

	BOOL t_Status = :: DuplicateHandle ( 

		t_ProcessHandle ,
		a_Handle ,
		t_ProcessHandle ,
		& a_DuplicatedHandle ,
		0 ,
		FALSE ,
		DUPLICATE_SAME_ACCESS
	) ;

	if ( ! t_Status )		
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: ConcatenateStrings ( ULONG a_ArgCount , BSTR *a_AllocatedString , ... )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	va_list t_VarArgList ;
	va_start ( t_VarArgList , a_AllocatedString );

	ULONG t_AllocatedStringLength = 0 ;
	ULONG t_ArgIndex = 0 ;
	while ( t_ArgIndex < a_ArgCount )
	{
		LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
		if ( t_CurrentArg )
		{
			t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
		}

		t_ArgIndex ++ ;
	}

	va_end ( t_VarArgList ) ;
	va_start ( t_VarArgList , a_AllocatedString );

	*a_AllocatedString = SysAllocStringLen ( NULL , t_AllocatedStringLength + 1 ) ;
	if ( *a_AllocatedString )
	{
		t_ArgIndex = 0 ;
		t_AllocatedStringLength = 0 ;
		while ( t_ArgIndex < a_ArgCount )
		{
			LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
			if ( t_CurrentArg )
			{
				wcscpy ( & ( ( * a_AllocatedString ) [ t_AllocatedStringLength ] ) , t_CurrentArg ) ;

				t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
			}

			t_ArgIndex ++ ;
		}

		( ( *a_AllocatedString ) [ t_AllocatedStringLength ] ) = NULL ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	va_end ( t_VarArgList ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: ConcatenateStrings_Wchar ( ULONG a_ArgCount , wchar_t **a_AllocatedString , ... )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	va_list t_VarArgList ;
	va_start ( t_VarArgList , a_AllocatedString );

	ULONG t_AllocatedStringLength = 0 ;
	ULONG t_ArgIndex = 0 ;
	while ( t_ArgIndex < a_ArgCount )
	{
		LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
		if ( t_CurrentArg )
		{
			t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
		}

		t_ArgIndex ++ ;
	}

	va_end ( t_VarArgList ) ;
	va_start ( t_VarArgList , a_AllocatedString );

	*a_AllocatedString = new wchar_t [ t_AllocatedStringLength + 1 ] ;
	if ( *a_AllocatedString )
	{
		t_ArgIndex = 0 ;
		t_AllocatedStringLength = 0 ;
		while ( t_ArgIndex < a_ArgCount )
		{
			LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
			if ( t_CurrentArg )
			{
				wcscpy ( & ( ( * a_AllocatedString ) [ t_AllocatedStringLength ] ) , t_CurrentArg ) ;

				t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
			}

			t_ArgIndex ++ ;
		}

		( ( *a_AllocatedString ) [ t_AllocatedStringLength ] ) = NULL ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	va_end ( t_VarArgList ) ;

	return t_StatusCode ;
}
#endif __HELPERFUNCS_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\pqueue.cpp ===
#ifndef __PRIORITYQUEUE_CPP
#define __PRIORITYQUEUE_CPP

template <class WmiKey,class WmiElement,ULONG ElementSize> 
BOOL operator< ( 

	const WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: WmiKeyElementPair &a_Arg1 , 
	const WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: WmiKeyElementPair &a_Arg2
)
{
	if ( a_Arg1.m_Key < a_Arg2.m_Key )
	{
		return TRUE ;
	}

	return FALSE ;	
}

template <class WmiKey,class WmiElement,ULONG ElementSize> 
BOOL operator== ( 

	const WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: WmiKeyElementPair &a_Arg1 , 
	const WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: WmiKeyElementPair &a_Arg2
)
{
	if ( a_Arg1.m_Key == a_Arg2.m_Key )
	{
		return TRUE ;
	}

	return FALSE ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: WmiPriorityQueue ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Array ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: ~WmiPriorityQueue ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Array.Initialize ( 1 << ElementSize ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Array.UnInitialize () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: ShuffleDown ( 

	ULONG a_Index
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size > 1 )
	{
		WmiKeyElementPair t_KeyElementPair ;
		t_StatusCode = m_Array.Get ( t_KeyElementPair , a_Index ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ULONG t_LargestIndex = a_Index ;
			ULONG t_LeftIndex = LEFT ( a_Index ) ;
			ULONG t_RightIndex = RIGHT ( a_Index ) ;

			if ( t_LeftIndex < m_Size - 1 )
			{
				WmiKeyElementPair t_Compare ;
				t_StatusCode = m_Array.Get ( t_Compare , t_LeftIndex ) ;

				if ( CompareElement ( t_Compare.m_Key , t_KeyElementPair.m_Key ) > 0 )
				{
					t_LargestIndex = t_LeftIndex ;
				}
				else
				{
					t_LargestIndex = a_Index ;
				}
			}
			
			if ( t_RightIndex < m_Size - 1 )
			{
				WmiKeyElementPair t_CompareKeyElementPair ;
				WmiKeyElementPair t_LargestKeyElementPair ;

				t_StatusCode = m_Array.Get ( t_CompareKeyElementPair , t_RightIndex ) ;
				t_StatusCode = m_Array.Get ( t_LargestKeyElementPair , t_LargestIndex ) ;

				if ( CompareElement ( t_CompareKeyElementPair.m_Key , t_LargestKeyElementPair.m_Key ) > 0 )
				{
					t_LargestIndex = t_RightIndex ;
				}
			}

			if ( t_LargestIndex != a_Index )
			{
				WmiKeyElementPair t_KeyElementPair ;
				WmiKeyElementPair t_LargestKeyElementPair ;

				t_StatusCode = m_Array.Get ( t_KeyElementPair , a_Index ) ;
				t_StatusCode = m_Array.Get ( t_LargestKeyElementPair , t_LargestIndex ) ;

				t_StatusCode = m_Array.Set ( t_KeyElementPair , t_LargestIndex ) ;
				t_StatusCode = m_Array.Set ( t_LargestKeyElementPair , a_Index  ) ;

				t_StatusCode = ShuffleDown ( t_LargestIndex ) ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: ShuffleUp  ( 

	const WmiKeyElementPair &a_KeyElementPair ,
	ULONG a_Index
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	ULONG t_Index = a_Index ;

	do
	{
		if ( t_Index > 0 )
		{
			WmiKeyElementPair t_Compare ;

			t_StatusCode = m_Array.Get ( t_Compare , PARENT ( t_Index ) ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( CompareElement ( t_Compare.m_Key , a_KeyElementPair.m_Key ) < 0 )
				{
					t_StatusCode = m_Array.Set ( t_Compare , t_Index ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_Index = PARENT ( t_Index ) ;
					}
					else
					{
						break ;
					}
				}
				else
				{
					break ;
				}
			}
			else
			{
				break ;
			}
		}
		else
		{
			break ;
		}
	}
	while ( TRUE ) ;

	if ( t_StatusCode ==  e_StatusCode_Success )
	{
		t_StatusCode = m_Array.Set ( a_KeyElementPair , t_Index ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: EnQueue ( 

	const WmiKey &a_Key , 
	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size >= m_Array.Size () )
	{
		t_StatusCode = m_Array.Grow ( m_Size + ( 1 << ElementSize ) ) ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Size ++ ;

		WmiKeyElementPair t_KeyElementPair ;

		try
		{		
			t_KeyElementPair.m_Key = a_Key , 
			t_KeyElementPair.m_Element = a_Element , 
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			m_Size -- ;

			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			m_Size -- ;

			return e_StatusCode_Unknown ;
		}

		t_StatusCode = ShuffleUp ( t_KeyElementPair , m_Size - 1 ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: Top (

	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		a_Iterator = Iterator ( this , 0 ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: Top (

	WmiKey &a_Key , 
	WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		WmiArray <WmiKeyElementPair> :: Iterator t_Iterator ;
		t_StatusCode = m_Array.Get ( t_Iterator , 0 ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			WmiKeyElementPair &t_KeyElementPair = t_Iterator.GetElement () ;

			try
			{
				a_Key = t_KeyElementPair.m_Key ;
				a_Element = t_KeyElementPair.m_Element ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				return e_StatusCode_Unknown ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: DeQueue ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		m_Size -- ;

		WmiKeyElementPair t_KeyElementPair ;

		t_StatusCode = m_Array.Get ( t_KeyElementPair , m_Size ) ;
		if t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_Array.Set ( t_KeyElementPair , 0 ) ;
		}

		if t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = ShuffleDown ( 0 ) ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG ElementSize>
WmiStatusCode WmiPriorityQueue <WmiKey,WmiElement,ElementSize> :: Sort ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size )
	{
		t_StatusCode = QuickSort <WmiArray<WmiKeyElementPair>,WmiKeyElementPair> ( m_Array , m_Size ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

#endif __PRIORITYQUEUE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\thread.cpp ===
#ifndef __THREAD_CPP
#define __THREAD_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Thread.cpp

Abstract:

	Enhancements to current functionality: 

		Timeout mechanism should track across waits.
		AddRef/Release on task when scheduling.
		Enhancement Ticker logic.

History:

--*/

#include <HelperFuncs.h>
#include <tchar.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> :: ThreadContainer *WmiThread <WmiKey> :: s_ThreadContainer = NULL ;

template <class WmiKey>
WmiThread <WmiKey> :: TaskContainer *WmiThread <WmiKey> :: s_TaskContainer = NULL ;

template <class WmiKey>
CriticalSection WmiThread <WmiKey> :: s_CriticalSection(FALSE) ;

template <class WmiKey>
LONG WmiThread <WmiKey> :: s_InitializeReferenceCount = 0 ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Initialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedIncrement ( & s_InitializeReferenceCount ) == 1 )
	{
		t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( s_ThreadContainer == NULL )
			{
				t_StatusCode = a_Allocator.New ( 

					( void ** ) & s_ThreadContainer ,
					sizeof ( ThreadContainer ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) s_ThreadContainer ) WmiThread <WmiKey> :: ThreadContainer ( a_Allocator ) ;
				}
			}
			else
			{
			}

			if ( s_TaskContainer == NULL )
			{
				t_StatusCode = a_Allocator.New ( 

					( void ** ) & s_TaskContainer ,
					sizeof ( TaskContainer ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) s_TaskContainer ) WmiThread <WmiKey> :: TaskContainer ( a_Allocator ) ;
				}
			}
			else
			{
			}
		}
	}

	return t_StatusCode	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_UnInitialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedDecrement ( & s_InitializeReferenceCount ) == 0 )
	{
		if ( s_ThreadContainer )
		{
			s_ThreadContainer->~WmiBasicTree () ;

			t_StatusCode = a_Allocator.Delete ( 

				( void * ) s_ThreadContainer 
			) ;

			s_ThreadContainer = NULL ;
		}

		if ( s_TaskContainer )
		{
			s_TaskContainer->~WmiBasicTree () ;

			t_StatusCode = a_Allocator.Delete ( 

				( void * ) s_TaskContainer 
			) ;

			s_TaskContainer = NULL ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection );
	}

	return t_StatusCode	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiTask <WmiKey> :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiTask <WmiKey> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: WmiTask ( 

	WmiAllocator &a_Allocator ,
	const wchar_t *a_Name ,
	const wchar_t *a_CompletionName

) : m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Event ( NULL ) ,
	m_CompletionEvent ( NULL ) ,
	m_Name ( NULL ) ,
	m_CompletionName ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) ,
	m_TaskState ( e_WmiTask_UnInitialized )
{
	if ( a_Name ) 
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		if ( a_CompletionName ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_CompletionName , m_CompletionName ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateNamedEvent ( m_Name , m_Event ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateNamedEvent ( m_CompletionName , m_CompletionEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: WmiTask ( 

	WmiAllocator &a_Allocator ,
	HANDLE a_Event ,
	HANDLE a_CompletionEvent ,
	const wchar_t *a_Name ,
	const wchar_t *a_CompletionName

) : m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Event ( NULL ) ,
	m_CompletionEvent ( NULL ) ,
	m_Name ( NULL ) ,
	m_CompletionName ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) ,
	m_TaskState ( e_WmiTask_UnInitialized )
{
	if ( a_Name )
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		if ( a_CompletionName )
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_CompletionName , m_CompletionName ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( a_Event ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateHandle ( a_Event , m_Event ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( a_CompletionEvent ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateHandle ( a_CompletionEvent , m_CompletionEvent ) ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: ~WmiTask ()
{
	if ( m_Name )
	{
		m_Allocator.Delete ( ( void * ) m_Name ) ;
	}

	if ( m_CompletionName )
	{
		m_Allocator.Delete ( ( void * ) m_CompletionName ) ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_CompletionEvent )
	{
		CloseHandle ( m_CompletionEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Initialize ()
{
	m_TaskState = e_WmiTask_Initialized ;

	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Process ( WmiThread <WmiKey> &a_Thread )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		return Complete () ;
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Exec ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( m_Event ) 
		{
			BOOL t_Status = SetEvent ( m_Event ) ;
			if ( ! t_Status )
			{
				t_StatusCode = e_StatusCode_Unknown ;		

			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Complete ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		BOOL t_Status = SetEvent ( m_CompletionEvent ) ;
		if ( ! t_Status )
		{
			t_StatusCode = e_StatusCode_Unknown ;		
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Wait ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_Dispatch ( 

			*this ,
			a_Timeout
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// call static GetEvents on WmiThread to determine list of tasks to execute.

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: WaitAlertable ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_AlertableDispatch ( 

			*this ,
			a_Timeout 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: WaitInterruptable ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_InterruptableDispatch ( 

			*this ,
			a_Timeout 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
LONG operator == ( const WmiThread <WmiKey> :: QueueKey &a_Arg1 , const WmiThread <WmiKey> :: QueueKey &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
	{
		t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
	}

	return t_Compare == 0 ? true : false ;
}

template <class WmiKey>
bool operator < ( const WmiThread <WmiKey> :: QueueKey &a_Arg1 , const WmiThread <WmiKey> :: QueueKey &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
	{
		t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
	}

	return t_Compare < 0 ? true : false ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: PostShutdown ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	SetEvent ( m_Terminate ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: ThreadProc ( void *a_Thread )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = ( WmiThread * ) a_Thread ;

	if ( t_Thread )
	{
		t_StatusCode = t_Thread->Initialize_Callback () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SetEvent ( t_Thread->m_Initialized ) ;

			t_StatusCode = t_Thread->ThreadDispatch () ;
		}

		WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

		t_StatusCode = t_Thread->UnInitialize_Callback () ;

		t_Thread->InternalRelease () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return ( ULONG ) t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		CallBackRelease () ;

		PostShutdown () ;

		return InternalRelease () ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		WmiStatusCode t_StatusCode = s_ThreadContainer->Delete ( m_Identifier ) ;

		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: CreateThread ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	InternalAddRef () ;

	m_Thread = :: CreateThread (

	  NULL ,
	  m_StackSize ,
	  ( LPTHREAD_START_ROUTINE ) ThreadProc ,
	  ( void * ) this ,
	  0 ,
	  & m_Identifier 
	) ;

	if ( m_Thread )
	{
		ThreadContainerIterator t_Iterator ;

		WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

		if ( ( t_StatusCode = s_ThreadContainer->Insert ( m_Identifier , this , t_Iterator ) ) == e_StatusCode_Success )
		{
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}
	else
	{
		InternalRelease () ;

		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> :: WmiThread ( 

	WmiAllocator &a_Allocator ,
	const wchar_t *a_Name ,
	ULONG a_Timeout ,
	DWORD a_StackSize 

) : m_Allocator ( a_Allocator ) ,
	m_TaskQueue ( a_Allocator ) ,
	m_AlertableTaskQueue ( a_Allocator ) ,
	m_InterruptableTaskQueue ( a_Allocator ) ,
	m_Thread ( NULL ) ,
	m_Initialized ( NULL ) ,
	m_Terminate ( NULL ) ,
	m_QueueChange ( NULL ) ,
	m_Identifier ( 0 ) ,
	m_Name ( NULL ) ,
	m_Timeout ( a_Timeout ) ,
	m_StackSize ( a_StackSize ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ),
	m_CriticalSection(NOTHROW_LOCK)
{
	m_InitializationStatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_TaskQueue.Initialize () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_InterruptableTaskQueue.Initialize () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_AlertableTaskQueue.Initialize () ;
	}

	if ( a_Name ) 
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_Terminate ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_Initialized ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_QueueChange ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> :: ~WmiThread ()
{
	if ( m_Name )
	{
		m_Allocator.Delete ( ( void * ) m_Name ) ;
	}

	if ( m_Initialized )
	{
		CloseHandle ( m_Initialized ) ;
	}

	if ( m_Terminate )
	{
		CloseHandle ( m_Terminate ) ;
	}

	if ( m_QueueChange )
	{
		CloseHandle ( m_QueueChange ) ;
	}

	if ( m_Thread ) 
	{
		CloseHandle ( m_Thread ) ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Initialize ( const ULONG &a_Timeout )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = CreateThread () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		ULONG t_Status = WaitForSingleObject ( m_Initialized , a_Timeout ) ;
		switch ( t_Status )
		{
			case WAIT_TIMEOUT:
			{
				m_InitializationStatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				m_InitializationStatusCode = e_StatusCode_Success ;
			}
			break ;

			default :
			{
				m_InitializationStatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}

	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_TaskQueue.UnInitialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = m_InterruptableTaskQueue.UnInitialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = m_AlertableTaskQueue.UnInitialize () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: TimedOut ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication in Queue status will not execute
// newly queued tasks.

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueue ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;

		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_TaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_Enqueue ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueueAlertable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;
		
		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_EnqueueAlertable ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection , TRUE ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication of Queue status change will execute
// newly queued tasks. This is used for STA based execution where we need to interrupt the wait
// to execute a dependant request.
// 

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueueInterruptable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;

		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_InterruptableTaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_EnqueueInterruptable ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueue ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueueAlertable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueueInterruptable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> *WmiThread <WmiKey> :: GetThread ()
{
	WmiThread *t_Thread = NULL ;

	ULONG t_CurrentThreadId = GetCurrentThreadId () ;

	ThreadContainerIterator	t_Iterator ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	WmiStatusCode t_StatusCode = s_ThreadContainer->Find ( t_CurrentThreadId , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_Thread = t_Iterator.GetElement () ;
	}

	WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

	return t_Thread ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> *WmiThread <WmiKey> :: GetServicingThread ( WmiTask <WmiKey> &a_Task )
{
	WmiThread *t_Thread = NULL ;

	TaskContainerIterator t_Iterator ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	WmiStatusCode t_StatusCode = s_TaskContainer->Find ( &a_Task, t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_Thread = t_Iterator.GetElement () ;
	}

	WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

	return t_Thread ;
}

/*

	Scheduling Action

Task None

	Dispatch nothing 

	On Thread

		Wait on Completion
		Wait on Thread Termination

		Wait on Servicing Thread Termination


	Off Thread

		Wait on Completion

		Wait on Servicing Thread Termination


Task Altertable	

	Dispatch Alertable Queue

	On Thread

		MsgWait on Completion
		MsgWait on Thread Termination

		MsgWait on Servicing Thread Termination

	Off Thread

		MsgWait on Completion

		MsgWait on Servicing Thread Termination

Task Interruptable	

	Dispatch Alertable Queue

	Dispatch Normal Queue

	On Thread

		MsgWait on Completion
		MsgWait on Thread Termination

		MsgWait on Servicing Thread Termination
		MsgWait on Alertables

	Off Thread

		MsgWait on Completion

		MsgWait on Servicing Thread Termination

Thread	Alertable

	Dispatch Alertable Queue

	Dispatch Normal Queue

	MsgWait on Thread Termination

	MsgWait on Alertables

*/

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Dispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	ULONG t_Event = WaitForMultipleObjects (

		3 ,
		t_Handles ,
		FALSE ,
		a_Timeout 
	) ;	

	switch ( t_Event )
	{
		case WAIT_TIMEOUT:
		{
			t_StatusCode = e_StatusCode_Success_Timeout ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
			t_StatusCode = e_StatusCode_Success ;
		}
		break ;

		case WAIT_OBJECT_0+1:
		case WAIT_OBJECT_0+2:
		{
			t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif
		}
		break ;

		default:
		{
			t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif
		}
		break ;
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Dispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->Dispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_Dispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Dispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	do
	{
	}
	while ( ( t_StatusCode = Wait ( a_Task , a_Timeout ) ) == e_StatusCode_Success ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Wait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ 4 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;

		ULONG t_Event = WaitForMultipleObjects (

			4 ,
			t_Handles ,
			FALSE ,
			a_Timeout 
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;

			case WAIT_OBJECT_0+2:
			case WAIT_OBJECT_0+3:
			{
				t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_InterruptableDispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	bool t_Continuing = true ;

	while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjects (

			3 ,
			t_Handles ,
			FALSE ,
			a_Timeout ,
			QS_ALLINPUT
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
				t_Continuing = false ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			case WAIT_OBJECT_0+2:
			{
				t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;

			case WAIT_OBJECT_0+3:
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}
				}

				ULONG t_Event = WaitForMultipleObjects (

					3 ,
					t_Handles ,
					FALSE ,
					0
				) ;

				switch ( t_Event )
				{
					case WAIT_TIMEOUT:
					{
						t_StatusCode = e_StatusCode_Success_Timeout ;
					}
					break ;

					case WAIT_OBJECT_0:
					{
						t_StatusCode = e_StatusCode_Success ;
						t_Continuing = true ;
					}
					break ;

					case WAIT_OBJECT_0+1:
					case WAIT_OBJECT_0+2:
					{
						t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_InterruptableDispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->InterruptableDispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_InterruptableDispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: InterruptableDispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = InterruptableWait ( a_Task , a_Timeout ) ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: InterruptableWait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ 5 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;
		t_Handles [ 4 ] = t_ServicingThread->GetQueueChangeEvent () ;

		bool t_Continuing = true ;

		while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
		{
			ULONG t_Event = MsgWaitForMultipleObjects (

				5 ,
				t_Handles ,
				FALSE ,
				a_Timeout ,
				QS_ALLINPUT
			) ;	

			switch ( t_Event )
			{
				case WAIT_TIMEOUT:
				{
					t_StatusCode = e_StatusCode_Success_Timeout ;
				}
				break ;

				case WAIT_OBJECT_0:
				{
					t_StatusCode = e_StatusCode_Success ;
					t_Continuing = false ;
				}
				break ;

				case WAIT_OBJECT_0+1:
				{
					t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
				break ;

				case WAIT_OBJECT_0+2:
				case WAIT_OBJECT_0+3:
				{
					t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
				break ;

				case WAIT_OBJECT_0+4:
				{
					t_StatusCode = e_StatusCode_Change ;
				}
				break ;

				case WAIT_OBJECT_0+5:
				{
					BOOL t_DispatchStatus ;
					MSG t_Msg ;

					while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
					{
						if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
						{
							TranslateMessage ( & t_Msg ) ;
							DispatchMessage ( & t_Msg ) ;
						}
					}

					ULONG t_Event = WaitForMultipleObjects (

						5 ,
						t_Handles ,
						FALSE ,
						0
					) ;

					switch ( t_Event )
					{
						case WAIT_TIMEOUT:
						{
							t_StatusCode = e_StatusCode_Success_Timeout ;
						}
						break ;

						case WAIT_OBJECT_0:
						{
							t_StatusCode = e_StatusCode_Success ;
							t_Continuing = false ;
						}
						break ;

						case WAIT_OBJECT_0+1:
						{
							t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

						}
						break ;

						case WAIT_OBJECT_0+2:
						case WAIT_OBJECT_0+3:
						{
							t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

						}
						break ;

						case WAIT_OBJECT_0+4:
						{
							t_StatusCode = e_StatusCode_Change ;
						}
						break ;

						default:
						{
							t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

						}
						break ;
					}
				}
				break ;

				default:
				{
					t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
				break ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	
		
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_AlertableDispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	bool t_Continuing = true ;

	while ( t_StatusCode == e_StatusCode_Success && t_Continuing ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjects (

			3 ,
			t_Handles ,
			FALSE ,
			a_Timeout ,
			QS_ALLINPUT
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
				t_Continuing = false ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			case WAIT_OBJECT_0+2:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;

			case WAIT_OBJECT_0+3:
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}
				}

				ULONG t_Event = WaitForMultipleObjects (

					3 ,
					t_Handles ,
					FALSE ,
					0
				) ;

				switch ( t_Event )
				{
					case WAIT_TIMEOUT:
					{
						t_StatusCode = e_StatusCode_Success_Timeout ;
					}
					break ;

					case WAIT_OBJECT_0:
					{
						t_StatusCode = e_StatusCode_Success ;
						t_Continuing = false ;
					}
					break ;

					case WAIT_OBJECT_0+1:
					case WAIT_OBJECT_0+2:
					{
						t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_AlertableDispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->AlertableDispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_AlertableDispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: AlertableDispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					do
					{
						t_StatusCode = Execute ( m_TaskQueue , t_EnQueue ) ;
		
					} while ( t_StatusCode == e_StatusCode_Success ) ;
				}
			}

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_TaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = AlertableWait ( a_Task , a_Timeout ) ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Execute ( QueueContainer &a_Queue , QueueContainer &a_EnQueue )
{
	QueueKey t_TopKey ;
	WmiTask < WmiKey > *t_TopTask ;

	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	WmiStatusCode t_StatusCode = a_Queue.Top ( t_TopKey , t_TopTask  ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = a_Queue.DeQueue () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			if ( t_TopTask->TaskState () == WmiTask < WmiKey > :: e_WmiTask_EnQueued )
			{
				t_StatusCode = t_TopTask->Process ( *this ) ;
				if ( t_StatusCode != e_StatusCode_EnQueue ) 
				{
					WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

					if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
					{
						WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

						t_StatusCode = e_StatusCode_Success ;
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

						t_TopTask->Release () ;
					}
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

					switch ( t_TopTask->EnqueuedAs () )
					{
						case WmiTask <WmiKey> :: e_WmiTask_Enqueue:
						{
							t_StatusCode = a_EnQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						case WmiTask <WmiKey> :: e_WmiTask_EnqueueAlertable:
						{
							t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						case WmiTask <WmiKey> :: e_WmiTask_EnqueueInterruptable:
						{
							t_StatusCode = m_InterruptableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						default:
						{
						}
						break ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

					SetEvent ( m_QueueChange ) ;
				}
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

				if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
				{
					WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

					t_StatusCode = e_StatusCode_Success ;
				}
				else
				{
					WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
				}

				t_TopTask->Complete () ;
				t_TopTask->Release () ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ShuffleTask (

	const HANDLE &a_Event
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	ULONG t_Index = m_AlertableTaskQueue.Size () ;

	while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Index ) )
	{
		QueueKey t_TopKey ;
		WmiTask < WmiKey > *t_TopTask ;

		t_StatusCode = m_AlertableTaskQueue.Top ( t_TopKey , t_TopTask  ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			t_StatusCode = m_AlertableTaskQueue.DeQueue () ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				if ( t_TopTask->GetEvent () == a_Event )
				{
					if ( t_TopTask->TaskState () == WmiTask < WmiKey > :: e_WmiTask_EnQueued )
					{
						t_StatusCode = m_TaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							SetEvent ( m_QueueChange ) ;

							break ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

						if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
						{
							WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

							t_StatusCode = e_StatusCode_Success ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
						}

						t_TopTask->Complete () ;
						t_TopTask->Release () ; 
					}
				}
				else
				{
					t_TopKey.SetTick ( m_Key++ ) ;
					t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
					}
				}
			}
		}

		t_Index -- ;
	}

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: FillHandleTable (

	HANDLE *a_HandleTable , 
	ULONG &a_Capacity
)
{
	ULONG t_Index = 0 ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success  ;
	
	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	QueueContainerIterator t_Iterator ;
	t_Iterator = m_AlertableTaskQueue.End () ;

	while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Index < a_Capacity ) && ! t_Iterator.Null () )
	{
		if ( t_Iterator.GetElement ()->GetEvent () )
		{
			a_HandleTable [ t_Index ] = t_Iterator.GetElement ()->GetEvent () ;
		}
		else
		{
			t_StatusCode = e_StatusCode_InvalidArgs ;
		}

		t_Iterator.Decrement () ;

		t_Index ++ ;
	}

	if ( t_StatusCode == e_StatusCode_NotInitialized )
	{
		t_StatusCode = e_StatusCode_Success ;
	}

	a_Capacity = t_Index ;

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: AlertableWait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ MAXIMUM_WAIT_OBJECTS - 1 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;
		t_Handles [ 4 ] = t_ServicingThread->GetQueueChangeEvent () ;

		ULONG t_Capacity = MAXIMUM_WAIT_OBJECTS - 6 ;
		t_StatusCode = FillHandleTable ( & t_Handles [ 5 ] , t_Capacity ) ;

		bool t_Continuing = true ;

		while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
		{
			ULONG t_Event = MsgWaitForMultipleObjects (

				5 + t_Capacity ,
				t_Handles ,
				FALSE ,
				a_Timeout ,
				QS_ALLINPUT
			) ;	

			switch ( t_Event )
			{
				case WAIT_TIMEOUT:
				{
					t_StatusCode = e_StatusCode_Success_Timeout ;
				}
				break ;

				case WAIT_OBJECT_0:
				{
					t_StatusCode = e_StatusCode_Success ;
					t_Continuing = false ;
				}
				break ;

				case WAIT_OBJECT_0+1:
				{
					t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
				break ;

				case WAIT_OBJECT_0+2:
				case WAIT_OBJECT_0+3:
				{
					t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
				break ;

				case WAIT_OBJECT_0+4:
				{
					t_StatusCode = e_StatusCode_Change ;
				}
				break ;

				default:
				{
					if ( t_Event == t_Capacity + 5 )
					{
						BOOL t_DispatchStatus ;
						MSG t_Msg ;

						while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
						{
							if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
							{
								TranslateMessage ( & t_Msg ) ;
								DispatchMessage ( & t_Msg ) ;
							}
						}

						ULONG t_Event = WaitForMultipleObjects (

							5 + t_Capacity ,
							t_Handles ,
							FALSE ,
							0
						) ;

						switch ( t_Event )
						{
							case WAIT_TIMEOUT:
							{
								t_StatusCode = e_StatusCode_Success_Timeout ;
							}
							break ;

							case WAIT_OBJECT_0:
							{
								t_StatusCode = e_StatusCode_Success ;
								t_Continuing = false ;
							}
							break ;

							case WAIT_OBJECT_0+1:
							{
								t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

							}
							break ;

							case WAIT_OBJECT_0+2:
							case WAIT_OBJECT_0+3:
							{
								t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

							}
							break ;

							case WAIT_OBJECT_0+4:
							{
								t_StatusCode = e_StatusCode_Change ;
							}
							break ;

							default:
							{
								if ( t_Event < t_Capacity + 5 )
								{
									t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
								}
								else
								{
									t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

								}
							}
						}
					}
					else if ( t_Event < t_Capacity + 5 )
					{
						t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
					}
					else
					{
						t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

					}
				}
				break ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	
		
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ThreadDispatch ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue  ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					do
					{
						t_StatusCode = Execute ( m_TaskQueue , t_EnQueue ) ;

					} while ( t_StatusCode == e_StatusCode_Success ) ;
				}
			}

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_TaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = ThreadWait () ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ThreadWait ()
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ MAXIMUM_WAIT_OBJECTS - 1 ] ;

	t_Handles [ 0 ] = GetTerminationEvent () ;
	t_Handles [ 1 ] = GetQueueChangeEvent () ;

	ULONG t_Capacity = MAXIMUM_WAIT_OBJECTS - 3 ;
	t_StatusCode = FillHandleTable ( & t_Handles [ 2 ] , t_Capacity ) ;

	bool t_Continuing = true ;

	while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjectsEx (

			2 + t_Capacity ,
			t_Handles ,
			m_Timeout ,
			QS_ALLINPUT ,
			MWMO_ALERTABLE
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = TimedOut () ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
				OutputDebugString ( _T("\nWmiThread - Thread Terminating") ) ;
#endif
			}
			break ;

			case WAIT_OBJECT_0+1:
			{
				t_StatusCode = e_StatusCode_Change ;
			}
			break ;

			case WAIT_IO_COMPLETION:
			{
				t_StatusCode = e_StatusCode_Success;
			}
			break ;

			default:
			{
				if ( t_Event == t_Capacity + 2 )
				{
					BOOL t_DispatchStatus ;
					MSG t_Msg ;

					while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
					{
						if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
						{
							TranslateMessage ( & t_Msg ) ;
							DispatchMessage ( & t_Msg ) ;
						}
					}

					ULONG t_Event = WaitForMultipleObjects (

						2 + t_Capacity ,
						t_Handles ,
						FALSE ,
						0
					) ;

					switch ( t_Event )
					{
						case WAIT_TIMEOUT:
						{
							t_StatusCode = TimedOut () ;
						}
						break ;

						case WAIT_OBJECT_0:
						{
							t_StatusCode = e_StatusCode_HostingThreadTerminated ;


#if DBG
							OutputDebugString ( _T("\nWmiThread - Thread Terminating")) ;
#endif
						}
						break ;

						case WAIT_OBJECT_0+1:
						{
							t_StatusCode = e_StatusCode_Change ;
						}
						break ;

						default:
						{
							if ( t_Event < t_Capacity + 2 )
							{
								t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
							}
							else if (t_Event == WAIT_FAILED && GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
							{
							  Sleep(sleep_duration?10:0);
							  sleep_duration^=1;
							  continue;
							}
							else
							{
								t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

							}
						}
					}
				}
				else if ( t_Event < t_Capacity + 2 )
				{
					t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
				}
				else if (t_Event == WAIT_FAILED && GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
				{
					Sleep(sleep_duration?10:0);
					sleep_duration^=1;
					continue;
				}
				else
				{
					t_StatusCode = e_StatusCode_InvalidArgs ;


#if DBG
#ifdef _X86_
__asm 
{
	int 3 ;
}
#endif
#endif

				}
			}
			break ;
		}
	}
		
	return t_StatusCode ;
}

#endif __THREAD_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\queue.cpp ===
#ifndef __QUEUE_CPP
#define __QUEUE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiQueue <WmiElement,ElementSize> :: WmiQueue <WmiElement,ElementSize> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Top ( NULL ) ,
	m_Tail ( NULL ) ,
	m_TopIndex ( NULL ) ,
	m_TailIndex ( NULL ) ,
	m_AllocatedSize ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiQueue <WmiElement,ElementSize > :: ~WmiQueue <WmiElement,ElementSize> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ElementSize < 31 )
	{
		t_StatusCode = Grow_ElementDir () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_InvalidArgs ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_AllocatedSize )
	{
		t_StatusCode = UnInitialize_ElementDir ( m_AllocatedSize ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: EnQueue ( 

	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_AllocatedSize )
	{
		t_StatusCode = Initialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_TailIndex ++ ;

		if ( m_TailIndex == ( QUEUE_ELEMENT_DIR_SIZE ) )
		{
			WmiElementDir *t_Tail = m_Tail ;
			ULONG t_TailIndex = m_TailIndex ;

			t_StatusCode = Grow_ElementDir () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				m_TailIndex -- ;
			}
			else
			{
				try
				{
					t_Tail->m_Block [ t_TailIndex - 1 ] = a_Element ;
					m_Size ++ ;
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					m_TailIndex -- ;

					return e_StatusCode_OutOfMemory ;
				}
				catch ( ... )
				{
					m_TailIndex -- ;

					return e_StatusCode_Unknown ;
				}
			}
		}
		else
		{	
			try
			{
				m_Tail->m_Block [ m_TailIndex - 1 ] = a_Element ;
				m_Size ++ ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				m_TailIndex -- ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				m_TailIndex -- ;

				return e_StatusCode_Unknown ;
			}
		}
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Top ( WmiElement &a_Element )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! ( ( m_Top == m_Tail ) && ( m_TopIndex == m_TailIndex ) ) )
	{
		try
		{
			a_Element = m_Top->m_Block [ m_TopIndex ] ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: DeQueue ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! ( ( m_Top == m_Tail ) && ( m_TopIndex == m_TailIndex ) ) )
	{
		m_TopIndex ++ ;

		if ( m_TopIndex == ( QUEUE_ELEMENT_DIR_SIZE ) )
		{
			t_StatusCode = Shrink_ElementDir () ;
			m_TopIndex = 0 ;
		}

		m_Size -- ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: UnInitialize_ElementDir ( 

	ULONG a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Current = m_Tail ;

	while ( t_Current )
	{
		WmiElementDir *t_Next = t_Current->m_Next ;

		t_Current->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) t_Current 
		) ;

		t_Current = t_Next ;
	}

	m_Size = m_AllocatedSize = 0 ;
	m_Top = m_Tail = NULL ;
	m_TopIndex = m_TailIndex = 0 ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Grow_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Tail = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_Tail ,
		sizeof ( WmiElementDir ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		:: new ( ( void * ) t_Tail ) WmiElementDir ;

		if ( m_Tail )
		{
			m_Tail->m_Next = t_Tail ;
		}
		else
		{
			m_Top = t_Tail ;
		}

		m_Tail = t_Tail ;

		m_TailIndex = 0 ;

		m_AllocatedSize = m_AllocatedSize + ( QUEUE_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Shrink_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Top )
	{
		WmiElementDir *t_Next = m_Top->m_Next ;

		m_Top->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Top
		) ;

		m_Top = t_Next ;

		m_AllocatedSize = m_AllocatedSize - ( QUEUE_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

#endif __QUEUE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\tpqueue.cpp ===
#ifndef __TREEPRIORITYQUEUE_CPP
#define __TREEPRIORITYQUEUE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <TPQueue.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiTreePriorityQueue <WmiKey,WmiElement> :: WmiTreePriorityQueue ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Tree ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiTreePriorityQueue <WmiKey,WmiElement> :: ~WmiTreePriorityQueue ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.Initialize () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.UnInitialize () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: EnQueue ( 

	const WmiKey &a_Key , 
	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;

	t_StatusCode = m_Tree.Insert ( a_Key , a_Element , t_Iterator ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Top (

	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		a_Iterator = m_Tree.Begin () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Top (

	WmiKey &a_Key , 
	WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;

		t_Iterator = m_Tree.Begin () ;

		try
		{
			a_Key = t_Iterator.GetKey () ;
			a_Element = t_Iterator.GetElement () ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: DeQueue ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;
		t_Iterator = m_Tree.Begin () ;

		t_StatusCode = m_Tree.Delete ( t_Iterator.GetKey () ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = m_Tree.Delete ( a_Key ) ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Merge (

	WmiTreePriorityQueue <WmiKey,WmiElement> &a_Queue
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.Merge ( a_Queue.m_Tree ) ;

	return t_StatusCode ;
}


#endif __TREEPRIORITYQUEUE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\stack.cpp ===
#ifndef __STACK_CPP
#define __STACK_CPP
/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <Allocator.h>
#include <Stack.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStack <WmiElement,ElementSize > :: WmiStack <WmiElement,ElementSize > ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0xFFFFFFFF ) ,
	m_AllocatedSize ( 0 ) ,
	m_Top ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStack <WmiElement,ElementSize > :: ~WmiStack <WmiElement,ElementSize > ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ElementSize < 31 )
	{
		t_StatusCode = Grow_ElementDir () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_InvalidArgs ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_AllocatedSize )
	{
		t_StatusCode = UnInitialize_ElementDir ( m_AllocatedSize ) ;

		m_Size = 0 ;
		m_AllocatedSize = 0 ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Top ( WmiElement &a_Element )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size != 0xFFFFFFFF )
	{
		ULONG t_Index = ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ;

		try
		{
			a_Element = m_Top->m_Block [ t_Index ] ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Push ( 

	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_AllocatedSize )
	{
		t_StatusCode = Initialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Size ++ ;

		if ( m_Size == m_AllocatedSize )
		{
			t_StatusCode = Grow_ElementDir () ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			ULONG t_Index = ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ;

			try
			{
				m_Top->m_Block [ t_Index ] = a_Element ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				m_Size -- ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				m_Size -- ;

				return e_StatusCode_Unknown ;
			}
		}
		else
		{
			m_Size -- ;
		}
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Pop ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size != 0xFFFFFFFF )
	{
		if ( ( ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ) == 0 )
		{
			t_StatusCode = Shrink_ElementDir () ;
		}

		m_Size -- ;

	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: UnInitialize_ElementDir ( 

	ULONG a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	bool t_RoundUp = ( a_Size & STACK_ELEMENT_DIR_MASK ) != 0 ;

	ULONG t_Size = ( a_Size >> STACK_ELEMENT_DIR_BIT_SIZE ) + ( t_RoundUp ? 1 : 0 ) ;

	WmiElementDir *t_Previous = NULL ;

	for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		if ( m_Top )
		{
			t_Previous = m_Top->m_Previous ;

			t_StatusCode = m_Allocator.Delete (

				( void * ) m_Top 
			) ;

			m_Top = t_Previous ;
		}
		else
		{
			break ;
		}
	}

	m_AllocatedSize = 0 ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Grow_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Top = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_Top ,
		sizeof ( WmiElementDir ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		:: new ( ( void * ) t_Top ) WmiElementDir ;

		t_Top->m_Previous = m_Top ;

		m_Top = t_Top ;

		m_AllocatedSize = m_AllocatedSize + ( STACK_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Shrink_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Top )
	{
		WmiElementDir *t_Previous = m_Top->m_Previous ;

		m_Top->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Top 
		) ;

		m_Top = t_Previous ;

		m_AllocatedSize = m_AllocatedSize - ( STACK_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

#endif __STACK_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\threadedavltree.cpp ===
#ifndef _ThreadedAvlTREE_CPP
#define _ThreadedAvlTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <ThreadedAvlTree.h>

#endif

#if 1
#define INLINE_COMPARE 
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiThreadedAvlTree <WmiKey,WmiElement> :: WmiThreadedAvlTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL ) ,
	m_Head ( NULL ) ,
	m_Tail ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiThreadedAvlTree <WmiKey,WmiElement> :: ~WmiThreadedAvlTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = m_Head = m_Tail = NULL;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiThreadedAvlNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThreadedAvlNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiThreadedAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiThreadedAvlNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiThreadedAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiThreadedAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE 
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiThreadedAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ).Increment () ;
			return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ; ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				if ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ) ;
					
					return e_StatusCode_Success ;
				}
			}
			else
			{
				if ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ).Increment () ;

					return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
				}
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	if ( m_Root ) 
	{
		bool t_Increased ;

		WmiThreadedAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				return e_StatusCode_AlreadyExists ;
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						WmiThreadedAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiThreadedAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiThreadedAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiThreadedAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiThreadedAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							m_Size ++ ;

							t_Increased = true ;

							WmiThreadedAvlNode *t_PreviousNode = t_Node->m_Previous ;
							t_AllocNode->m_Previous = t_PreviousNode ;
							t_AllocNode->m_Next = t_Node ;
							t_Node->m_Previous = t_AllocNode ;
							
							if ( t_PreviousNode )
							{
								t_PreviousNode->m_Next = t_AllocNode ;
							}
							else
							{
								m_Head = t_AllocNode ;
							}

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Left = t_AllocNode ;

							t_StatusCode = Insert_LeftBalance ( 

								t_Node ,
								t_Node->m_Left ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiThreadedAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_Node->m_Parent ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{

						WmiThreadedAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiThreadedAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiThreadedAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiThreadedAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiThreadedAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;
					
							m_Size ++ ;

							t_Increased = true ;

							WmiThreadedAvlNode *t_NextNode = t_Node->m_Next ;
							t_AllocNode->m_Previous = t_Node ;
							t_AllocNode->m_Next = t_NextNode ;
							t_Node->m_Next = t_AllocNode ;
							
							if ( t_NextNode )
							{
								t_NextNode->m_Previous = t_AllocNode ;
							}
							else
							{
								m_Tail = t_AllocNode ;
							}

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Right = t_AllocNode ;

							t_StatusCode = Insert_RightBalance ( 

								t_Node ,
								t_Node->m_Right ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiThreadedAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_ParentNode ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		WmiThreadedAvlNode *t_AllocNode ;
		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & t_AllocNode ,
			sizeof ( WmiThreadedAvlNode ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			::  new ( ( void* ) t_AllocNode ) WmiThreadedAvlNode () ;

			try
			{
				t_AllocNode->m_Element = a_Element ;
				t_AllocNode->m_Key = a_Key ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_AllocNode->~WmiThreadedAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				t_AllocNode->~WmiThreadedAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_Unknown ;
			}

			a_Iterator = Iterator ( t_AllocNode ) ;
	
			m_Root = m_Head = m_Tail = t_AllocNode ;

			m_Size ++ ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	if ( m_Root ) 
	{
		bool t_Decreased ;

		WmiThreadedAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				WmiThreadedAvlNode *t_ParentNode = t_Node->m_Parent ;
				if ( t_ParentNode )
				{
					bool t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;

					WmiThreadedAvlNode *t_PreviousNode = t_Node->m_Previous ;
					WmiThreadedAvlNode *t_NextNode = t_Node->m_Next ;

					if ( t_PreviousNode )
					{
						t_PreviousNode->m_Next = t_NextNode;
					}
					else
					{
						m_Head = t_NextNode ;
					}

					if ( t_NextNode )
					{
						t_NextNode->m_Previous = t_PreviousNode ;
					}
					else
					{
						m_Tail = t_PreviousNode ;
					}

					WmiStatusCode t_StatusCode = DeleteFixup ( t_Node , t_Decreased ) ;

					m_Size -- ;

					while ( t_Decreased )
					{
						if ( t_ParentNode )
						{
							if ( t_LeftSide )
							{
								t_StatusCode = Delete_LeftBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Right ,
									t_Decreased 
								) ;
							}
							else
							{
								t_StatusCode = Delete_RightBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Left ,
									t_Decreased 
								) ;
							}

							t_Node = t_ParentNode ;
							t_ParentNode = t_Node->m_Parent ;
							if ( t_ParentNode )
							{
								t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;
							}
						}
						else
						{
							return e_StatusCode_Success ;
						}
					}

					return e_StatusCode_Success ;
				}
				else
				{
					WmiThreadedAvlNode *t_PreviousNode = t_Node->m_Previous ;
					WmiThreadedAvlNode *t_NextNode = t_Node->m_Next ;

					if ( t_PreviousNode )
					{
						t_PreviousNode->m_Next = t_NextNode;
					}
					else
					{
						m_Head = t_NextNode ;
					}

					if ( t_NextNode )
					{
						t_NextNode->m_Previous = t_PreviousNode ;
					}
					else
					{
						m_Tail = t_PreviousNode ;
					}

					m_Size -- ;

					return DeleteFixup ( t_Node , t_Decreased ) ;
				}
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )			
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		return e_StatusCode_NotFound  ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *		case 1:
 *
 *						 N					     A
 *						/ \
 *					   A                 ->	
 *			
 *					Parent Decreased,on side based on recursion step
 *
 *		case 2:
 *
 *						 N						A
 *						/ \
 *					       A			->
 *
 *				Parent Decreased,on side based on recursion step
 *
 *		case 3:
 *						 N						B
 *						/ \					   / \
 *					   A   B            ->    A	  Y
 *                        / \
 *                           Y
 *
 *				B decreased on Right
 *
 *		case 4:
 *
 *						 N						B
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  X   Y 
 *                        \
 *                         X
 *
 *				C decreased on Left, Apply LeftBalance on C
 *				Apply RightBalance on B
 * 
 *						 N						D
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  B   Y 
 *                      / \                    / \
 *                     D   X                  E   X
 *                      \
 *                       E
 *
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: DeleteFixup ( WmiThreadedAvlNode *a_Node , bool &a_Decreased )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Decreased = true ;

	WmiThreadedAvlNode *t_Left = a_Node->m_Left ;
	WmiThreadedAvlNode *t_Right = a_Node->m_Right ;
	WmiThreadedAvlNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiThreadedAvlNode *t_Successor = t_Iterator.m_Node ;

		t_Successor->m_State = a_Node->m_State ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
/* case 4 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiThreadedAvlNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
 
			do
			{
				t_StatusCode = Delete_LeftBalance ( t_Node , t_Node->m_Right , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif

				t_Node = t_Node->m_Parent ;
			}
			while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Node != t_Successor ) ) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = Delete_RightBalance ( t_Node , t_Node->m_Left , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif
			}
		}
		else
		{
/* case 3 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;

			t_StatusCode = Delete_RightBalance ( t_Successor , t_Successor->m_Left , a_Decreased ) ;
		}
	}
	else
	{
		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}

		if ( t_Left )
		{
/* case 1 */

			t_Left->m_Parent = a_Node->m_Parent ;
			t_Left->m_State = a_Node->m_State ;

			t_StatusCode = Delete_LeftBalance ( t_Left , t_Left->m_Right , a_Decreased ) ;
		}
		else if ( t_Right )
		{
/* case 2 */

			t_Right->m_Parent = a_Node->m_Parent ;
			t_Right->m_State = a_Node->m_State ;

			t_StatusCode = Delete_RightBalance ( t_Right , t_Right->m_Left , a_Decreased ) ;
		}
	}

	a_Node->~WmiThreadedAvlNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Insert_LeftBalance ( 

	WmiThreadedAvlNode *&A , 
	WmiThreadedAvlNode *B , 
	bool &a_Increased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiThreadedAvlNode :: e_Equal:
			{
				A->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
			}
			break ;

			case WmiThreadedAvlNode :: e_RightHigher:
			{
				A->m_State = WmiThreadedAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiThreadedAvlNode :: e_LeftHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiThreadedAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiThreadedAvlNode :: e_LeftHigher:
					{
						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_RightHigher:
					{
						WmiThreadedAvlNode *C = A->m_Left->m_Right ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiThreadedAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_RightHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							case WmiThreadedAvlNode :: e_Equal:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiThreadedAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Insert_RightBalance ( 

	WmiThreadedAvlNode *&A , 
	WmiThreadedAvlNode *B , 
	bool &a_Increased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiThreadedAvlNode :: e_Equal:
			{
				A->m_State = WmiThreadedAvlNode :: e_RightHigher ;
			}
			break ;

			case WmiThreadedAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiThreadedAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiThreadedAvlNode :: e_RightHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiThreadedAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiThreadedAvlNode :: e_RightHigher:
					{
						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_LeftHigher:
					{
						WmiThreadedAvlNode *C = A->m_Right->m_Left ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						B->m_Left = C->m_Right ;
						A->m_Right = C->m_Left ;

						C->m_Right = B ;
						C->m_Left = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiThreadedAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_RightHigher ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							case WmiThreadedAvlNode :: e_RightHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_Equal:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;		
							}
							break ;
						}

						C->m_State = WmiThreadedAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Delete_LeftBalance ( 

	WmiThreadedAvlNode *&A , 
	WmiThreadedAvlNode *B , 
	bool &a_Decreased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiThreadedAvlNode :: e_Equal:
			{
				A->m_State = WmiThreadedAvlNode :: e_RightHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiThreadedAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiThreadedAvlNode :: e_Equal ;
			}
			break ;

			case WmiThreadedAvlNode :: e_RightHigher:
			{
				switch ( B->m_State )	
				{
					case WmiThreadedAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_RightHigher ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_RightHigher:
					{
						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_LeftHigher:
					{
						WmiThreadedAvlNode *C = A->m_Right->m_Left ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						A->m_Right = C->m_Left ;
						B->m_Left = C->m_Right ;

						C->m_Left = A ;
						C->m_Right = B ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiThreadedAvlNode :: e_LeftHigher:
							{
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
								B->m_State = WmiThreadedAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_RightHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_Equal:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiThreadedAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Delete_RightBalance ( 

	WmiThreadedAvlNode *&A , 
	WmiThreadedAvlNode *B , 
	bool &a_Decreased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiThreadedAvlNode :: e_Equal:
			{
				A->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiThreadedAvlNode :: e_RightHigher:
			{
				A->m_State = WmiThreadedAvlNode :: e_Equal ;
			}
			break ;

			case WmiThreadedAvlNode :: e_LeftHigher:
			{
				switch ( B->m_State )	
				{
					case WmiThreadedAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_RightHigher ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_LeftHigher:
					{
						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiThreadedAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiThreadedAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiThreadedAvlNode :: e_RightHigher:
					{
						WmiThreadedAvlNode *C = A->m_Left->m_Right ;

						WmiThreadedAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiThreadedAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_RightHigher:
							{
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
								B->m_State = WmiThreadedAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiThreadedAvlNode :: e_Equal:
							{
								B->m_State = WmiThreadedAvlNode :: e_Equal ;
								A->m_State = WmiThreadedAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiThreadedAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Merge ( 

	WmiThreadedAvlTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Iterator t_Iterator = a_Tree.Root ();

	while ( ( ! t_Iterator.Null () ) && ( t_StatusCode == e_StatusCode_Success ) )
	{
		Iterator t_InsertIterator ;
		t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: Check ( ULONG & a_MaxHeight )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 0
	printf ( "\nStart Check ( %ld )" , m_Size ) ;
#endif
	if ( m_Root )
	{
		if ( m_Root->m_Parent == NULL )
		{
			ULONG t_Count = 1 ;
			ULONG t_Height = 0 ;
			a_MaxHeight = 0 ;
			t_StatusCode = RecursiveCheck ( m_Root , t_Count , t_Height , a_MaxHeight ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( t_Count != m_Size )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_Failed ;
		}
	}

#if 0
	printf ( "\nEnd Check" ) ;
#endif

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiThreadedAvlTree <WmiKey,WmiElement> :: RecursiveCheck ( 

	WmiThreadedAvlNode *a_Node ,
	ULONG &a_Count ,
	ULONG a_Height ,
	ULONG &a_MaxHeight
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Height ++ ;

#if 0
	printf ( "\n" ) ;
	for ( ULONG t_TabIndex = 0 ; t_TabIndex < a_Height ; t_TabIndex ++ ) 
	{
		printf ( "++++" ) ;
	}

	printf ( "%ld" , a_Node->m_Key ) ;

	switch ( a_Node->m_State )
	{
		case WmiThreadedAvlNode :: e_LeftHigher:
		{
			printf ( "\t LH" ) ;
		}
		break ;

		case WmiThreadedAvlNode :: e_RightHigher:
		{
			printf ( "\t RH" ) ;
		}
		break ;

		case WmiThreadedAvlNode :: e_Equal:
		{
			printf ( "\t E" ) ;
		}
		break ;
	}

#endif

	if ( t_StatusCode == e_StatusCode_Success )
	{
		ULONG t_LeftHeight = a_Height ;

		WmiThreadedAvlNode *t_Left = a_Node->m_Left ;
		if ( t_Left )
		{
			if ( t_Left->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Left , a_Count , a_Height , t_LeftHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}
	
		ULONG t_RightHeight = a_Height ;

		WmiThreadedAvlNode *t_Right = a_Node->m_Right ;
		if ( t_Right )
		{
			if ( t_Right->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Right , a_Count , a_Height , t_RightHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}

		switch ( a_Node->m_State )
		{
			case WmiThreadedAvlNode :: e_LeftHigher:
			{
				if ( t_LeftHeight <= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiThreadedAvlNode :: e_RightHigher:
			{
				if ( t_LeftHeight >= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiThreadedAvlNode :: e_Equal:
			{
				if ( t_LeftHeight != t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;
		}

		if ( t_LeftHeight < t_RightHeight )
		{
			a_MaxHeight = t_RightHeight ;
		}
		else
		{
			a_MaxHeight = t_LeftHeight ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( a_Node->m_State == WmiThreadedAvlNode :: e_Equal )
		{
			if ( ( ( a_Node->m_Left == 0 ) && ( a_Node->m_Right == 0 ) ) )
			{
			}
			else if ( ! ( a_Node->m_Left && a_Node->m_Right ) )
			{
				t_StatusCode = e_StatusCode_Failed ;
			} 
		}

		if ( a_Node->m_State == WmiThreadedAvlNode :: e_LeftHigher )
		{
			if ( a_Node->m_Left == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}

		if ( a_Node->m_State == WmiThreadedAvlNode :: e_RightHigher )
		{
			if ( a_Node->m_Right == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
	}
 	
	return t_StatusCode ;
}

#endif _ThreadedAvlTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\readerwriter.cpp ===
#ifndef __READERWRITER_CPP
#define __READERWRITER_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ReaderWriter.cpp

Abstract:

	Enhancements to current functionality: 

		Timeout mechanism should track across waits.
		AddRef/Release on task when scheduling.
		Enhancement Ticker logic.

History:

--*/

#include <windows.h>
#include <ReaderWriter.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiMultiReaderSingleWriter :: WmiMultiReaderSingleWriter ( 

	const LONG &a_ReaderSize 

) : m_ReaderSize ( a_ReaderSize ) ,
	m_ReaderSemaphore ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) ,
	m_WriterCriticalSection (NOTHROW_LOCK)
{
	m_InitializationStatusCode = WmiHelper :: InitializeCriticalSection ( & m_WriterCriticalSection ) ;
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_ReaderSemaphore = CreateSemaphore ( NULL , m_ReaderSize , m_ReaderSize , NULL ) ;
		if ( ! m_ReaderSemaphore )
		{
			m_InitializationStatusCode = e_StatusCode_OutOfResources ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiMultiReaderSingleWriter :: ~WmiMultiReaderSingleWriter ()
{
	WmiHelper :: DeleteCriticalSection ( & m_WriterCriticalSection ) ;

	if ( m_ReaderSemaphore )
	{
		CloseHandle ( m_ReaderSemaphore ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: Initialize ()
{
	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: EnterRead ()
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_WriterCriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			LONG t_Reason = WaitForSingleObject ( m_ReaderSemaphore , INFINITE ) ;
			if ( t_Reason != WAIT_OBJECT_0 )
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}

			WmiHelper :: LeaveCriticalSection ( & m_WriterCriticalSection ) ;
		}

		return t_StatusCode ;
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: EnterWrite ()
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_WriterCriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			bool t_Waiting = true ;

			while ( t_Waiting )
			{
				LONG t_Reason = WaitForSingleObject ( m_ReaderSemaphore , INFINITE ) ;
				if ( t_Reason != WAIT_OBJECT_0 )
				{
					WmiHelper :: LeaveCriticalSection ( & m_WriterCriticalSection ) ;
					return e_StatusCode_Unknown ;
				}

				LONG t_SemaphoreCount = 0 ;
				BOOL t_Status = ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) ;
				if ( t_Status )
				{
					if ( t_SemaphoreCount == m_ReaderSize - 1 )
					{
						t_Waiting = false ;
					}
					else
					{
						SwitchToThread () ; 
					}
				}
				else
				{
					WmiHelper :: LeaveCriticalSection ( & m_WriterCriticalSection ) ;
					return e_StatusCode_Unknown ;
				}
			}

			return t_StatusCode ;
		}
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: LeaveRead ()
{
	LONG t_SemaphoreCount = 0 ;
	BOOL t_Status = ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) ;
	if ( t_Status )
	{
		return e_StatusCode_Success ;
	}

	return e_StatusCode_Unknown ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderSingleWriter :: LeaveWrite ()
{
	return WmiHelper :: LeaveCriticalSection ( & m_WriterCriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiMultiReaderMultiWriter :: WmiMultiReaderMultiWriter ( 

	const LONG &a_ReaderSize ,
	const LONG &a_WriterSize 

) : m_ReaderSize ( a_ReaderSize ) ,
	m_ReaderSemaphore ( NULL ) ,
	m_WriterSize ( a_WriterSize ) ,
	m_WriterSemaphore ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) 
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_ReaderSemaphore = CreateSemaphore ( NULL , m_ReaderSize , m_ReaderSize , NULL ) ;
		if ( ! m_ReaderSemaphore )
		{
			m_InitializationStatusCode = e_StatusCode_OutOfResources ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_WriterSemaphore = CreateSemaphore ( NULL , m_WriterSize , m_WriterSize , NULL ) ;
		if ( ! m_ReaderSemaphore )
		{
			m_InitializationStatusCode = e_StatusCode_OutOfResources ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiMultiReaderMultiWriter :: ~WmiMultiReaderMultiWriter ()
{
	if ( m_ReaderSemaphore )
	{
		CloseHandle ( m_ReaderSemaphore ) ;
	}

	if ( m_WriterSemaphore )
	{
		CloseHandle ( m_WriterSemaphore ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: Initialize ()
{
	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: EnterRead ( const LONG &a_Timeout )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		LONG t_Reason = WaitForSingleObject ( m_WriterSemaphore , INFINITE ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return e_StatusCode_Unknown ;
		}

		t_Reason = WaitForSingleObject ( m_ReaderSemaphore , INFINITE ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}

		LONG t_SemaphoreCount = 0 ;
		BOOL t_Status = ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;
		if ( ! t_Status )
		{
			t_StatusCode = e_StatusCode_Unknown ;
		}

		return t_StatusCode ;
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: EnterWrite ( const LONG &a_Timeout )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ; 

		LONG t_Reason = WaitForSingleObject ( m_WriterSemaphore , INFINITE ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return e_StatusCode_Unknown ;
		}

		bool t_Waiting = true ;

		while ( t_Waiting )
		{
			LONG t_Reason = WaitForSingleObject ( m_ReaderSemaphore , INFINITE ) ;
			if ( t_Reason != WAIT_OBJECT_0 )
			{
				LONG t_SemaphoreCount = 0 ;
				BOOL t_Status = ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;
				if ( ! t_Status )
				{
					t_StatusCode = e_StatusCode_Unknown ;
				}

				return e_StatusCode_Unknown ;
			}

			LONG t_SemaphoreCount = 0 ;
			BOOL t_Status = ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) ;
			if ( t_Status )
			{
				if ( t_SemaphoreCount == m_ReaderSize - 1 )
				{
					t_Waiting = false ;
				}
				else
				{
					SwitchToThread () ;
				}
			}
			else
			{
				LONG t_SemaphoreCount = 0 ;
				BOOL t_Status = ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;
				if ( ! t_Status )
				{
					t_StatusCode = e_StatusCode_Unknown ;
				}

				return e_StatusCode_Unknown ;
			}
		}

		return t_StatusCode ;
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: LeaveRead ()
{
	LONG t_SemaphoreCount = 0 ;
	BOOL t_Status = ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) ;
	if ( t_Status )
	{
		return e_StatusCode_Success ;
	}

	return e_StatusCode_Unknown ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiMultiReaderMultiWriter :: LeaveWrite ()
{
	LONG t_SemaphoreCount = 0 ;
	BOOL t_Status = ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;
	if ( t_Status )
	{
		return e_StatusCode_Success ;
	}

	return e_StatusCode_Unknown ;
}

#endif __READERWRITER_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\redblacktree.cpp ===
#ifndef __REDBLACKTREE_CPP
#define __REDBLACKTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <RedBlackTree.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiRedBlackTree <WmiKey,WmiElement> :: WmiRedBlackTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiRedBlackTree <WmiKey,WmiElement> :: ~WmiRedBlackTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiRedBlackNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiRedBlackNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiRedBlackNode () ;

		WmiStatusCode t_StatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiRedBlackNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiRedBlackNode () ;

		WmiStatusCode t_StatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiRedBlackNode *t_AllocNode = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_AllocNode ,
		sizeof ( WmiRedBlackNode ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		::  new ( ( void* ) t_AllocNode ) WmiRedBlackNode () ;

		try
		{
			t_AllocNode->m_Element = a_Element ;
			t_AllocNode->m_Key = a_Key ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_AllocNode->~WmiRedBlackNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			t_AllocNode->~WmiRedBlackNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_Unknown ;
		}


		a_Iterator = Iterator ( t_AllocNode ) ;

		if ( m_Root ) 
		{
			t_StatusCode = RecursiveInsert ( 

				m_Root ,
				t_AllocNode
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_Size ++ ;
			}
			else
			{
				t_AllocNode->~WmiRedBlackNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;
			}
		}
		else
		{
			m_Root = t_AllocNode ;

			m_Size ++ ;
		}
	}
	else
	{
		a_Iterator = Iterator () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveDelete ( m_Root , a_Key ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Size -- ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveFind ( m_Root , a_Key , a_Iterator ) ;
	}
	else
	{
		return e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveFindNext ( m_Root , a_Key , a_Iterator ) ;
	}
	else
	{
		return e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RecursiveDelete ( 

	WmiRedBlackNode *a_Node , 
	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_NotFound ;

	LONG t_Compare = CompareElement ( a_Key , a_Node->m_Key ) ;

	if ( t_Compare == 0 )
	{
		t_StatusCode = DeleteFixup ( a_Node ) ;
	}
	else 
	{
		if ( t_Compare < 0 )
		{
			WmiRedBlackNode *t_Left = a_Node->m_Left ;
			if ( t_Left )
			{
				t_StatusCode = RecursiveDelete ( t_Left , a_Key ) ;
			}
		}
		else
		{
			WmiRedBlackNode *t_Right = a_Node->m_Right ;
			if ( t_Right )
			{
				t_StatusCode = RecursiveDelete ( t_Right , a_Key ) ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RecursiveInsert ( 

	WmiRedBlackNode *a_Node , 
	WmiRedBlackNode *a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	LONG t_Compare = CompareElement ( a_Element->m_Key  , a_Node->m_Key ) ;

	if ( t_Compare == 0 )
	{
		t_StatusCode = e_StatusCode_AlreadyExists ;
	}
	else 
	{
		if ( t_Compare < 0 )
		{
			WmiRedBlackNode *t_Left = a_Node->m_Left ;
			if ( t_Left )
			{
				t_StatusCode = RecursiveInsert ( t_Left , a_Element ) ;
			}
			else
			{
				a_Element->m_Parent = a_Node ;
				a_Node->m_Left = a_Element ;
			}
		}
		else
		{
			WmiRedBlackNode *t_Right = a_Node->m_Right ;
			if ( t_Right )
			{
				t_StatusCode = RecursiveInsert ( t_Right , a_Element ) ;
			}
			else
			{
				a_Element->m_Parent = a_Node ;
				a_Node->m_Right = a_Element ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RecursiveFind ( 

	WmiRedBlackNode *a_Node , 
	const WmiKey &a_Key , 
	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_NotFound ;

	LONG t_Compare = CompareElement ( a_Key , a_Node->m_Key ) ;

	if ( t_Compare == 0 )
	{
		a_Iterator = Iterator ( a_Node ) ;

		t_StatusCode = e_StatusCode_Success ;
	}
	else 
	{
		if ( t_Compare < 0 )
		{
			WmiRedBlackNode *t_Left = a_Node->m_Left ;
			if ( t_Left )
			{
				t_StatusCode = RecursiveFind ( t_Left , a_Key , a_Iterator ) ;
			}
		}
		else
		{
			WmiRedBlackNode *t_Right = a_Node->m_Right ;
			if ( t_Right )
			{
				t_StatusCode = RecursiveFind ( t_Right , a_Key , a_Iterator ) ;
			}
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RecursiveFindNext ( 

	WmiRedBlackNode *a_Node , 
	const WmiKey &a_Key , 
	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_NotFound ;

	LONG t_Compare = CompareElement ( a_Key , a_Node->m_Key ) ;

	if ( t_Compare == 0 )
	{
		a_Iterator = Iterator ( a_Node ).Increment () ;

		t_StatusCode = e_StatusCode_Success ;
	}
	else 
	{
		if ( t_Compare < 0 )
		{
			WmiRedBlackNode *t_Left = a_Node->m_Left ;
			if ( t_Left )
			{
				t_StatusCode = RecursiveFindNext ( t_Left , a_Key , a_Iterator ) ;
			}
			else
			{
				a_Iterator = Iterator ( a_Node ).Increment () ;
		
				t_StatusCode = e_StatusCode_Success ;
			}
		}
		else
		{
			WmiRedBlackNode *t_Right = a_Node->m_Right ;
			if ( t_Right )
			{
				t_StatusCode = RecursiveFindNext ( t_Right , a_Key , a_Iterator ) ;
			}
			else
			{
				a_Iterator = Iterator ( a_Node ).Increment () ;

				t_StatusCode = e_StatusCode_Success ;
			}
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: LeftRotate ( WmiRedBlackNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: RightRotate ( WmiRedBlackNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: DeleteFixup ( WmiRedBlackNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiRedBlackNode *t_Left = a_Node->m_Left ;
	WmiRedBlackNode *t_Right = a_Node->m_Right ;
	WmiRedBlackNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiRedBlackNode *t_Successor = t_Iterator.m_Node ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiRedBlackNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
		else
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
	}
	else
	{
		if ( t_Left )
		{
			t_Left->m_Parent = a_Node->m_Parent ;
		}
		else if ( t_Right )
		{
			t_Right->m_Parent = a_Node->m_Parent ;
		}

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}
	}

	a_Node->~WmiRedBlackNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiRedBlackTree <WmiKey,WmiElement> :: Merge ( 

	WmiRedBlackTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;


	Iterator t_Iterator = a_Tree.Root ();

	while ( ! t_Iterator.Null () )
	{
		Iterator t_InsertIterator ;
		WmiStatusCode t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}


#endif __REDBLACKTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\client.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <stdio.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Allocator.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "Task.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifndef _WIN64

#include <malloc.h>

struct HEAP_ENTRY {
	WORD Size;
	WORD PrevSize;
	BYTE SegmentIndex;
	BYTE Flags;
    BYTE UnusedBytes;
	BYTE SmallTagIndex;
};

FARPROC Real_RtlAlloc;
FARPROC Real_RtlFree;

#define SIZE_JUMP_ADR 5
#define SIZE_RET_0C 3

DWORD __RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{
	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));

	if (pBlock)
	{
		HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;
		//DWORD Size = pEntry->Size * sizeof(HEAP_ENTRY) - sizeof(HEAP_ENTRY);
		DWORD Size = pEntry->Size * sizeof(HEAP_ENTRY) - pEntry->UnusedBytes;
		
		memset(pBlock,0x00,Size);		
		
		//if (pEntry->Size & 0xF000)
		//{
		//    // too big, warn the user
		//    DebugBreak();
		//}
		
		if (pEntry->Size >=4)
		{		    
		    RtlCaptureStackBackTrace (1,
        		                      (4 == pEntry->Size)?4:6,
                		              (PVOID *)(pEntry+2),
                        		      pLong);		
		}

	}

	return 0;
}

void __declspec(naked) Foo()
{
	_asm {
	    // 3 bytes comes from 'ret c'
	    // two bytes for getting up to 5, this is 'push ebp' ; mov ebp,esp'; 'push ff'
		nop
		nop
		;
		nop // here is the space for JUMP rel32
        nop
		nop
		nop
		nop
	}
}

DWORD intercept()
{
    Real_RtlAlloc = GetProcAddress(GetModuleHandleW(L"ntdll.dll"),"RtlAllocateHeap");
	Real_RtlFree  = GetProcAddress(GetModuleHandleW(L"ntdll.dll"),"RtlFreeHeap");

	MEMORY_BASIC_INFORMATION MemBI;
	DWORD dwOldProtect;
	BOOL bRet;

	DWORD dwRet = VirtualQuery(Real_RtlFree,&MemBI,sizeof(MemBI));

	bRet = VirtualProtect(MemBI.BaseAddress,
		                  MemBI.RegionSize,
		                  PAGE_EXECUTE_WRITECOPY,
				          &dwOldProtect);
	if (bRet)
	{
		//__RtlFreeHeap
		VirtualQuery(__RtlFreeHeap,&MemBI,sizeof(MemBI));

		bRet = VirtualProtect(MemBI.BaseAddress,
		                  MemBI.RegionSize,
		                  PAGE_EXECUTE_WRITECOPY,
				          &dwOldProtect);
		if (bRet)
		{
			VOID * pToJump = (VOID *)__RtlFreeHeap;
			BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
			BYTE StorageFree[SIZE_JUMP_ADR];
			LONG * pOffset = (LONG *)&Arr[1];
			* pOffset = (LONG)__RtlFreeHeap - (LONG)Real_RtlFree - SIZE_JUMP_ADR ;        
			// save the old code
			memcpy(StorageFree,Real_RtlFree,SIZE_JUMP_ADR);		
			// put the new code
			memcpy(Real_RtlFree,Arr,SIZE_JUMP_ADR);

			// prepare the exit code of the interceptor to call back the old code

            BYTE * pRestore = (BYTE *)Foo-SIZE_RET_0C;
			memcpy(pRestore,StorageFree,SIZE_JUMP_ADR);
            pRestore[SIZE_JUMP_ADR] = 0xe9;
			pOffset = (LONG *)&pRestore[SIZE_JUMP_ADR+1];
			*pOffset = (LONG)Real_RtlFree + SIZE_JUMP_ADR - (LONG)pRestore - SIZE_JUMP_ADR - SIZE_JUMP_ADR;
		   
		}
	}
	else
	{
		//printf("VirtualProtect err %d\n",GetLastError());
		DebugBreak();
	}
	return 0;

}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

IntegerCacheController *g_CacheController = NULL ;

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_MultiThread ( ULONG a_OperationCount )
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

		ClientThread **t_ThreadContainer = new ClientThread * [ 4 ] ;
		if ( t_ThreadContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < 4 ; t_Index ++ )
			{
				t_ThreadContainer [ t_Index ] = new ClientThread ( t_Allocator , a_OperationCount ) ;
				ClientThread *t_Thread = t_ThreadContainer [ t_Index ] ;
				if ( t_Thread )
				{
					t_Thread->AddRef () ;

					t_StatusCode = t_Thread->Initialize () ;

					t_Thread->EnQueue ( 0 , *t_Thread->GetTask () ) ;
				}
			}

			for ( t_Index = 0 ; t_Index < 4 ; t_Index ++ )
			{
				ClientThread *t_Thread = t_ThreadContainer [ t_Index ] ;
				t_Thread->GetTask ()->WaitInterruptable () ;
			}

			for ( t_Index = 0 ; t_Index < 4 ; t_Index ++ )
			{
				ClientThread *t_Thread = t_ThreadContainer [ t_Index ] ;

				HANDLE t_ThreadHandle = NULL ;

				BOOL t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread->GetHandle () ,
					GetCurrentProcess () ,
					& t_ThreadHandle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread->Release () ;

				WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

				CloseHandle ( t_ThreadHandle ) ;
			}

			delete [] t_ThreadContainer ;
		}

		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process ( ULONG a_OperationCount )
{
	HRESULT t_Result = Process_MultiThread ( a_OperationCount );
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
//	intercept();

	srand ( GetTickCount () ) ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		g_CacheController = new IntegerCacheController (
		
			t_Allocator
		) ;

		if ( g_CacheController )
		{
			g_CacheController->AddRef () ;

			if ( g_CacheController->Initialize () == e_StatusCode_Success )
			{
				ULONG t_OperationCount = 0x30000000 ;

				Process ( t_OperationCount ) ;

				g_CacheController->UnInitialize () ;
			}

			g_CacheController->Release () ;
		}
	}
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\include\cthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _CThread_H
#define _CThread_H

#include <Thread.h>
#include <Task.h>

class ClientThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;
	Task_Execute *m_Task ;

protected:

public:	/* Internal */

    ClientThread ( 

		WmiAllocator & a_Allocator ,
		ULONG a_OperationCount
	) ;

    ~ClientThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	Task_Execute *GetTask () 
	{
		return m_Task ;
	}
};

#endif // _CThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\include\task.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Task_H
#define _Task_H

#include <Thread.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_Execute : public WmiTask < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;
	ULONG m_Count ;

protected:

	WmiStatusCode Choose ( IntegerCacheElement *&a_Element ) ;

	WmiStatusCode Run () ;
	WmiStatusCode Strobe () ;
	WmiStatusCode Shutdown () ;
	WmiStatusCode Insert () ;

public:	/* Internal */

    Task_Execute ( WmiAllocator & a_Allocator , ULONG a_Count ) ;
    ~Task_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
};

#endif // _Task_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>
#include <Cache.h>

#endif // _Globals_H


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiCacheController <ULONG>					IntegerCacheController ;
typedef IntegerCacheController :: Cache				IntegerCacheController_Cache ;
typedef IntegerCacheController :: Cache_Iterator	IntegerCacheController_Cache_Iterator ;
typedef IntegerCacheController :: WmiCacheElement	IntegerCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <ULONG>								IntegerContainerController ;
typedef IntegerContainerController :: Container						IntegerContainerController_Container ;
typedef IntegerContainerController :: Container_Iterator			IntegerContainerController_Container_Iterator ;
typedef IntegerContainerController :: WmiContainerElement			IntegerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

class ContainerElement :	public IntegerContainerElement
{
private:
protected:
public:

	ContainerElement (

		IntegerContainerController *a_Controller

	) : IntegerContainerElement ( 

			a_Controller ,
			( ULONG ) this
		) 
	{
	}

	~ContainerElement ()
	{
	}

	STDMETHODIMP QueryInterface (

		REFIID a_Riid , 
		LPVOID FAR *a_Void
	) 
	{
		*a_Void = NULL ;

		if ( a_Riid == IID_IUnknown )
		{
			*a_Void = ( LPVOID ) this ;
		}

		if ( *a_Void )
		{
			( ( LPUNKNOWN ) *a_Void )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return IntegerContainerElement :: AddRef () ;
	}

	STDMETHODIMP_( ULONG ) Release ()
	{
		return IntegerContainerElement :: Release () ;
	}

	WmiStatusCode Shutdown ()
	{
		return e_StatusCode_Success ;
	}

} ;

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CacheElement :	public IntegerCacheElement , 
						public IntegerContainerController 
{
private:
protected:
public:

	CacheElement ( 
	
		WmiAllocator &a_Allocator ,
		IntegerCacheController *a_Controller ,
		ULONG a_Key 
		
	) : IntegerContainerController ( a_Allocator ) ,
		IntegerCacheElement ( 

			a_Controller ,
			a_Key ,
			1000
		)
	{
		IntegerContainerController :: Initialize () ;
	}

	~CacheElement () 
	{
		IntegerContainerController :: UnInitialize () ;
	}

	STDMETHODIMP QueryInterface (

		REFIID a_Riid , 
		LPVOID FAR *a_Void
	) 
	{
		*a_Void = NULL ;

		if ( a_Riid == IID_IUnknown )
		{
			*a_Void = ( LPVOID ) this ;
		}

		if ( *a_Void )
		{
			( ( LPUNKNOWN ) *a_Void )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return IntegerCacheElement :: AddRef () ;
	}

	STDMETHODIMP_( ULONG ) Release ()
	{
		return IntegerCacheElement :: Release () ;
	}

	WmiStatusCode Run ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		ContainerElement *t_ContainerElement = new ContainerElement ( this ) ;
		if ( t_ContainerElement )
		{
			t_ContainerElement->AddRef () ;

			IntegerContainerController_Container_Iterator t_Iterator ;

			Lock () ;

			t_StatusCode = Insert (

				*t_ContainerElement ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
			}
			else
			{
				DebugBreak () ;
			}

			UnLock () ;

			t_ContainerElement->Release () ;
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode Shutdown ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		IntegerContainerController_Container *t_Container = NULL ;
		GetContainer ( t_Container ) ;

		Lock () ;

		ContainerElement **t_ShutdownElements = new ContainerElement * [ t_Container->Size () ] ;
		if ( t_ShutdownElements )
		{
			IntegerContainerController_Container_Iterator t_Iterator = t_Container->Begin ();

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IUnknown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;
				if ( FAILED ( t_Result ) )
				{
					DebugBreak () ;
				}

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ShutdownElements [ t_Index ] ) 
				{
					t_StatusCode = t_ShutdownElements [ t_Index ]->Shutdown () ;

					t_ShutdownElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ShutdownElements ;
		}
		else
		{	
			UnLock () ;

			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		IntegerContainerController :: Shutdown () ;
		
		return t_StatusCode ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern IntegerCacheController *g_CacheController ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\cthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: Initialize_Callback ()
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: UnInitialize_Callback () 
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread :: ClientThread (

	WmiAllocator &a_Allocator ,
	ULONG a_OperationCount 

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_Task ( NULL )
{
	m_Task = new Task_Execute ( m_Allocator , a_OperationCount ) ;
	m_Task->AddRef () ;
	m_Task->Initialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread::~ClientThread ()
{
	m_Task->Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\cachetest\task.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <wmiutils.h>

#include "Globals.h"
#include "Task.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: Task_Execute (

	WmiAllocator &a_Allocator ,
	ULONG a_Count

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_Count ( a_Count )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: ~Task_Execute ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Insert ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	IntegerCacheController_Cache *t_Cache = NULL ;
	
	g_CacheController->GetCache ( t_Cache ) ;

	if ( t_Cache->Size () < 20 )
	{ 
		CacheElement *t_CacheElement = new CacheElement ( 

			m_Allocator ,
			g_CacheController ,
			rand () 			
		) ;

		if ( t_CacheElement )
		{
			t_CacheElement->AddRef () ;

			IntegerCacheController_Cache_Iterator t_Iterator ;

			g_CacheController->Lock () ;

			t_StatusCode = g_CacheController->Insert (

				*t_CacheElement ,
				t_Iterator
			) ;

			g_CacheController->UnLock () ;

			t_CacheElement->Release () ;
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Choose ( IntegerCacheElement *&a_Element )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Element = NULL ;

	IntegerCacheController_Cache *t_Cache = NULL ;	
	g_CacheController->GetCache ( t_Cache ) ;

	g_CacheController->Lock () ;

	LONG t_Rand = rand () % ( t_Cache->Size () + 1 ) ;

	IntegerCacheController_Cache_Iterator t_Iterator = t_Cache->Begin () ;

	for ( LONG t_Index = 0 ; t_Index < t_Rand ; t_Index ++ )
	{
		t_Iterator.Increment () ;
	}

	if ( ! t_Iterator.Null () )
	{
		a_Element = t_Iterator.GetElement () ;
		a_Element->AddRef () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}

	g_CacheController->UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Strobe ()
{
	ULONG t_NextStrobeDelta = 0xFFFFFFFF ;
	
	WmiStatusCode t_StatusCode = g_CacheController->Strobe ( t_NextStrobeDelta ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Shutdown ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	IntegerCacheController_Cache *t_Cache = NULL ;
	g_CacheController->GetCache ( t_Cache ) ;

	g_CacheController->Lock () ;

	CacheElement **t_ShutdownElements = new CacheElement * [ t_Cache->Size () ] ;
	if ( t_ShutdownElements )
	{
		IntegerCacheController_Cache_Iterator t_Iterator = t_Cache->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IUnknown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;
			if ( FAILED ( t_Result ) )
			{
				DebugBreak () ;
			}

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		g_CacheController->UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_StatusCode = t_ShutdownElements [ t_Index ]->Shutdown () ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		g_CacheController->UnLock () ;

		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Run ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	IntegerCacheElement *t_Element = NULL ;

	t_StatusCode = Choose ( t_Element ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		CacheElement *t_CacheElement = NULL ;
		HRESULT t_Result = t_Element->QueryInterface ( IID_IUnknown , ( void ** ) & t_CacheElement ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_CacheElement->Run () ;
			t_CacheElement->Release () ;
		}

		t_Element->Release () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
	for ( ULONG t_Index = 0 ; t_Index < m_Count ; t_Index ++ )
	{
		LONG t_Rand = rand () ;
		t_Rand = ( t_Rand % 99 ) ;

		if ( t_Rand > 60 )
		{
			WmiStatusCode t_StatusCode = Run () ;
		}
		else if ( t_Rand > 40 )
		{
			WmiStatusCode t_StatusCode = Strobe () ;
		}
		else if ( t_Rand > 20 )
		{
			WmiStatusCode t_StatusCode = Shutdown () ;
		}
		else 
		{
			WmiStatusCode t_StatusCode = Insert () ;
		}
	}

	Complete () ;

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\algorithms.h ===
#ifndef _ALGORITHMS_H
#define _ALGORITHMS_H

#include "Allocator.h"
#include "Array.h"
#include "Stack.h"

template <class WmiElement>
LONG CompareElement ( const WmiElement &a_Arg1 , const WmiElement &a_Arg2 ) ;

template <class WmiArray, class WmiElement >
WmiStatusCode QuickSort ( WmiArray &a_Array , ULONG a_Size ) ;

template <class WmiElement>
WmiStatusCode QuickSort ( WmiElement *a_Array , ULONG a_Size ) ;

#include <Algorithms.cpp>

#endif _ALGORITHMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\avltree.h ===
#ifndef _AVLTREE_H
#define _AVLTREE_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "AvlTree.h"

template <class WmiKey,class WmiElement>
class WmiAvlTree
{
public:

	class WmiAvlNode
	{
	public:

		enum WmAvlState
		{
			e_Equal,
			e_LeftHigher ,
			e_RightHigher
		} ;

		WmiKey m_Key ;

		WmiAvlNode *m_Left ;
		WmiAvlNode *m_Right ;
		WmiAvlNode *m_Parent ;

		WmAvlState m_State ;

		WmiElement m_Element ;

		WmiAvlNode () 
		{
			m_Left = m_Right = m_Parent = NULL ;
			m_State = e_Equal ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiAvlTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiAvlTree <WmiKey,WmiElement>;
	private:

		WmiAvlNode *m_Node ;

		WmiAvlNode *LeftMost ( WmiAvlNode *a_Node ) 
		{
			WmiAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiAvlNode *RightMost ( WmiAvlNode *a_Node )
		{
			WmiAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiAvlNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiAvlNode *m_Root ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode DeleteFixup ( WmiAvlNode *a_Node , bool &a_Decreased ) ;

	WmiStatusCode RecursiveCheck ( WmiAvlNode *a_Root , ULONG &a_Count , ULONG a_Height , ULONG &a_MaxHeight ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiAvlNode *a_Node ) ;

	WmiStatusCode Insert_LeftBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Insert_RightBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Right , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_LeftBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_RightBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Right , 
		bool &a_Increased
	) ;

#if 0
	WmiStatusCode RecursiveDelete ( WmiAvlNode *a_Root , const WmiKey &a_Key , 	bool &a_Decreased ) ;

	WmiStatusCode RecursiveInsert ( WmiAvlNode *a_Root , WmiAvlNode *a_Node , bool &a_Increased ) ;
#endif

public:

	WmiAvlTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiAvlTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiAvlTree <WmiKey,WmiElement> &a_Tree
	) ;

	WmiStatusCode Check ( ULONG &a_MaxHeight ) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator End () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <AvlTree.cpp>

#endif _AVLTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\bptree.h ===
#ifndef _BPLUSTREE_H
#define _BPLUSTREE_H

#include "Allocator.h"
#include "Algorithms.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define WmiAbsoluteBlockOffSet UINT64
#define WmiRelativeBlockOffSet UINT64
#define WmiBPElement WmiAbsoluteBlockOffSet
#define WmiBPElementSize (sizeof(WmiBPElement))

#define WmiBlockKeyPointerOffSet 0
#define WmiBlockKeyElementOffSet (WmiBlockKeyPointerOffSet+sizeof(WmiAbsoluteBlockOffSet))
#define WmiBlockKeyOffSet (WmiBlockKeyPointerOffSet+sizeof(WmiAbsoluteBlockOffSet)+ WmiBPElementSize)

#define WmiBlockLeafKeyElementOffSet 0
#define WmiBlockLeafKeyOffSet (WmiBlockLeafKeyElementOffSet+WmiBPElementSize)

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiBlock
{
private:
protected:
public:


	WmiBlock ( BYTE *a_Data , ULONG a_DataLength ) ;
	WmiBlock () ;

	virtual ~WmiBlock () ;

	virtual BYTE *GetData () ;
	virtual ULONG GetDataLength () ;

};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiBlockInterface
{
private:

	ULONG m_BlockSize ;

public:

	WmiBlockInterface (

		ULONG a_BlockSize

	) : m_BlockSize ( a_BlockSize ) 
	{ ; }

	virtual ~WmiBlockInterface () { ; }

	virtual WmiStatusCode AllocateBlock (

		ULONG a_BlockCount , 
		WmiAbsoluteBlockOffSet &a_OffSet , 
		BYTE *&a_Block
	)
	{
		return e_StatusCode_Success ;
	}

	virtual WmiStatusCode FreeBlock ( 

		ULONG a_BlockCount , 
		WmiAbsoluteBlockOffSet &a_OffSet
	)
	{
		return e_StatusCode_Success ;
	}

	virtual WmiStatusCode ReadBlock (

		ULONG a_BlockCount , 
		WmiAbsoluteBlockOffSet &a_OffSet ,
		BYTE *&a_Block
	)
	{
		return e_StatusCode_Success ;
	}

	virtual WmiStatusCode WriteBlock (

		BYTE *a_Block
	)
	{
		return e_StatusCode_Success ;
	}

	virtual ULONG AddRefBlock (

		BYTE *a_Block
	)
	{
		return 0 ;
	}

	virtual ULONG ReleaseBlock (

		BYTE *a_Block
	)
	{
		return 0 ;
	}

	ULONG GetBlockSize () { return m_BlockSize ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiMemoryBlockInterface : public WmiBlockInterface
{
private:

	WmiAllocator m_Allocator ;

public:

	WmiMemoryBlockInterface (

		ULONG a_BlockSize

	) : WmiBlockInterface ( a_BlockSize ) ,
		m_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 24 )
	{ ; }

	~WmiMemoryBlockInterface ()
	{
		UnInitialize () ;
	}

	WmiStatusCode Initialize () 
	{
		return m_Allocator.Initialize () ;
	}

	WmiStatusCode UnInitialize () 
	{
		return m_Allocator.UnInitialize () ;
	}

	WmiStatusCode AllocateBlock (

		ULONG a_BlockCount ,
		WmiAbsoluteBlockOffSet &a_OffSet ,
		BYTE *&a_Block
	)
	{
		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & a_Block ,
			a_BlockCount * GetBlockSize () 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_OffSet = ( WmiAbsoluteBlockOffSet ) a_Block ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode FreeBlock (

		ULONG a_BlockCount ,
		WmiAbsoluteBlockOffSet &a_OffSet
	)
	{
		return m_Allocator.Delete ( ( void * ) a_OffSet ) ;
	}

	WmiStatusCode ReadBlock (

		ULONG a_BlockCount ,
		WmiAbsoluteBlockOffSet &a_OffSet ,
		BYTE *&a_Block
	)
	{
		a_Block = ( BYTE * ) a_OffSet ;

		return e_StatusCode_Success ;
	}

	WmiStatusCode WriteBlock (

		BYTE *a_Block
	)
	{
		return e_StatusCode_Success ;
	}

	ULONG AddRefBlock (

		BYTE *a_Block
	)
	{
		return 0 ;
	}

	ULONG ReleaseBlock (

		BYTE *a_Block
	)
	{
		return 0 ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiBPKey
{
private:

	ULONG m_DataSize ;
	BYTE *m_Data ;
	BOOL m_Allocated ;

public:

	WmiBPKey ( 

		BYTE *a_Data , 
		ULONG a_DataSize ,
		BOOL a_Allocated = FALSE

	) :	m_Data ( a_Data ) , 
		m_DataSize ( a_DataSize ) ,
		m_Allocated ( a_Allocated )
	{
	}

	WmiBPKey () :	m_Data ( NULL ) , 
					m_DataSize ( 0 ) , 
					m_Allocated ( FALSE ) 
	{
	}


	BYTE *GetData () { return m_Data ; }
	ULONG GetDataSize () { return m_DataSize ; }

	BYTE *GetConstData () const { return m_Data ; }
	ULONG GetConstDataSize () const { return m_DataSize ; }

	BOOL GetAllocated () { return m_Allocated ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef LONG ( * ComparatorFunction ) ( void *a_ComparatorOperand , const WmiBPKey &a_Key1 , const WmiBPKey &a_Key2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define WMIBPLUS_TREE_FLAG_INTERNAL 0 
#define WMIBPLUS_TREE_FLAG_LEAF		1

class WmiBPlusTree
{
public:

	class WmiBPKeyNode
	{
	public:

		ULONG m_Flags ;
		ULONG m_NodeStart ;	
		ULONG m_NodeSize ;
		WmiAbsoluteBlockOffSet m_NodeOffSet ;

		WmiBPKeyNode (

			ULONG a_Flags ,
			WmiAbsoluteBlockOffSet &a_NodeOffSet ,
			ULONG a_NodeStart ,
			ULONG a_NodeSize

		) :	m_Flags ( a_Flags ) ,
			m_NodeOffSet ( a_NodeOffSet ) , 
			m_NodeStart ( a_NodeStart ) ,
			m_NodeSize ( a_NodeSize )
		{
		}

		ULONG GetFlags () { return m_Flags ; }
		WmiAbsoluteBlockOffSet &GetNodeOffSet () { return m_NodeOffSet ; }
		ULONG GetNodeStart () { return m_NodeStart ; }		
		ULONG GetNodeSize () { return m_NodeSize ; }

		void SetFlags ( ULONG a_Flags ) { m_Flags = a_Flags ; }
		void SetNodeOffSet ( WmiAbsoluteBlockOffSet &a_NodeOffSet ) { m_NodeOffSet = a_NodeOffSet ; }
		void SetNodeStart ( ULONG a_NodeStart ) { m_NodeStart = a_NodeStart ; }		
		void SetNodeSize ( ULONG a_NodeSize ) { m_NodeSize = a_NodeSize ; }
	} ;

	class IteratorPosition
	{
	private:

		WmiAbsoluteBlockOffSet m_NodeOffSet ;
		ULONG m_NodeIndex ;

	public:

		IteratorPosition () :	m_NodeOffSet ( 0 ) , 
								m_NodeIndex ( 0 ) 
		{
		}

		IteratorPosition (

			const WmiAbsoluteBlockOffSet &a_NodeOffSet , 
			ULONG a_NodeIndex

		) : m_NodeOffSet ( a_NodeOffSet ) , 
			m_NodeIndex ( a_NodeIndex ) 
		{
		}

		WmiAbsoluteBlockOffSet &GetNodeOffSet () { return m_NodeOffSet ; }
		ULONG &GetNodeIndex () { return m_NodeIndex ; }
	} ;

	class Iterator
	{
	friend WmiBPlusTree;
	private:

		WmiBPlusTree *m_Tree ;
		WmiStack <IteratorPosition,8> m_Stack ;
		WmiAbsoluteBlockOffSet m_NodeOffSet ;
		ULONG m_NodeIndex ;
		WmiBPKey &m_Key ;
		WmiBPElement &m_Element ;

	public:

		Iterator ( 

			WmiBPlusTree *a_Tree ,
			WmiBPKey &a_Key ,
			WmiBPElement &a_Element

		) : m_Tree ( a_Tree ) ,
			m_Stack ( m_Tree->m_Allocator ) ,
			m_NodeOffSet ( 0 ) , 
			m_NodeIndex ( 0 ) ,
			m_Key ( a_Key ) ,
			m_Element ( a_Element )
		{ ; }

		Iterator ( const Iterator &a_Iterator ) :	m_Tree ( a_Iterator.m_Tree ) ,
													m_Stack ( a_Iterator.m_Stack ) ,
													m_NodeOffSet ( a_Iterator.m_NodeOffSet ) , 
													m_NodeIndex ( a_Iterator.m_NodeIndex ) ,
													m_Key ( a_Iterator.m_Key ) ,
													m_Element ( a_Iterator.m_Element )
		{ ; }

		Iterator &LeftMost ()
		{
			m_Tree->LeftMost ( *this ) ;

			return *this ;
		}

		Iterator &RightMost ()
		{
			m_Tree->RightMost ( *this ) ;

			return *this ;
		}

		Iterator &Decrement ()
		{
			m_Tree->Decrement ( *this ) ;

			return *this ;
		}

		Iterator &Increment () 
		{
			m_Tree->Increment ( *this ) ;

			return *this ;
		}

		Iterator &Begin () 
		{
			return m_Tree->Begin ( *this ) ;
		}

		Iterator &End () 
		{
			return m_Tree->End ( *this ) ;
		}

		Iterator &Root () 
		{
			return m_Tree->Root ( *this ) ;
		}

		void SetNodeOffSet ( const WmiAbsoluteBlockOffSet &a_NodeOffSet ) { m_NodeOffSet = a_NodeOffSet ; }
		void SetNodeIndex ( const ULONG &a_NodeIndex ) { m_NodeIndex = a_NodeIndex ; }

		WmiAbsoluteBlockOffSet &GetNodeOffSet () { return m_NodeOffSet ; }
		ULONG &GetNodeIndex () { return m_NodeIndex ; }
		WmiStack <IteratorPosition,8> &GetStack () { return m_Stack ; }

		bool Null () { return m_NodeOffSet == 0 ; }

		WmiBPKey &GetKey () { return m_Key ; }
		WmiBPElement &GetElement () { return m_Element ; } 
	} ;

friend class Iterator ;

protected:

	WmiAbsoluteBlockOffSet m_Root ;
	ULONG m_Size ;

	ComparatorFunction m_ComparatorFunction ;
	void *m_ComparatorOperand ;

	WmiBlockInterface &m_BlockAllocator ;
	WmiAllocator &m_Allocator ;

	ULONG m_BlockSize ;
	ULONG m_KeyType ;
	ULONG m_KeyTypeLength ;

	GUID m_Identifier ;

	ULONG MaxKeyPointers ()
	{
		return MaxKeys () + 1 ;
	}

	ULONG MaxKeys ()
	{
		ULONG t_Size = GetBlockSize	() - ( sizeof WmiBPKeyNode ) ;
		t_Size = ( t_Size - ( WmiBlockKeyOffSet + GetKeyTypeLength () ) ) / ( WmiBlockKeyOffSet + GetKeyTypeLength () ) ;
		t_Size = ( t_Size >> 1 ) << 1 ;

		return t_Size ;
	}

	ULONG MaxLeafKeys ()
	{
		ULONG t_Size = GetBlockSize	() - ( sizeof WmiBPKeyNode ) ;
		t_Size = t_Size / ( WmiBlockLeafKeyOffSet + GetKeyTypeLength () ) ;
		t_Size = ( t_Size >> 1 ) << 1 ;

		return t_Size ;
	}

	WmiStatusCode GetKeyElement (

		WmiBPKeyNode *a_Node , 
		const WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		const ULONG &a_NodeIndex ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode SetNode (

		WmiBPKeyNode *a_Node , 
		const WmiRelativeBlockOffSet &a_NodeDeltaOffSet , 
		const WmiBPKey &a_Key ,
		const WmiBPElement &a_Element ,
		WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet
	) ;

	WmiStatusCode SetLeafNode (

		WmiBPKeyNode *a_Node , 
		const WmiRelativeBlockOffSet &a_NodeDeltaOffSet , 
		const WmiBPKey &a_Key ,
		const WmiBPElement &a_Element
	) ;

	WmiStatusCode RecursiveDelete ( 

		WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		const WmiBPKey &a_Key ,
		WmiBPElement &a_Element
	) ;

	WmiStatusCode RecursiveInsert (

		WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		const WmiBPKey &a_Key ,
		const WmiBPElement &a_Element
	) ;

	WmiStatusCode RecursiveFind (

		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		const WmiBPKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode RecursiveFindNext (

		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		const WmiBPKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode RecursiveUnInitialize (

		WmiAbsoluteBlockOffSet &a_BlockOffSet
	) ;

	WmiStatusCode PositionInBlock ( 

		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		ULONG &a_NodeIndex ,
		WmiRelativeBlockOffSet &a_NodeOffSet ,
		WmiAbsoluteBlockOffSet &a_ChildOffSet
	) ;

	WmiStatusCode LeftMost (

		Iterator &a_Iterator
	) ;

	WmiStatusCode Increment (

		Iterator &a_Iterator
	) ;

	WmiStatusCode RightMost (

		Iterator &a_Iterator
	) ;

	WmiStatusCode Decrement (

		Iterator &a_Iterator
	) ;

	WmiStatusCode FindInBlock ( 

		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		const WmiBPKey &a_Key , 
		WmiAbsoluteBlockOffSet &a_ChildOffSet ,
		WmiBPElement &a_Element ,
		WmiRelativeBlockOffSet &a_NodeOffSet ,
		ULONG &a_NodeIndex
	) ;

	WmiStatusCode PerformInsertion ( 

		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		const WmiBPKey &a_Key , 
		WmiBPElement &a_Element ,
		WmiBPKey &a_ReBalanceKey , 
		WmiBPElement &a_ReBalanceElement ,
		WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet
	) ;

	WmiStatusCode InsertInBlock ( 

		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet , 
		const WmiBPKey &a_Key , 
		WmiBPElement &a_Element ,
		WmiBPKey &a_ReBalanceKey , 
		WmiBPElement &a_ReBalanceElement ,
		WmiAbsoluteBlockOffSet &a_LeftCutBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightCutBlockOffSet 
	) ;

	WmiStatusCode StealSiblingNode ( 

		WmiBPKeyNode *a_ParentNode ,
		WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
		WmiBPKeyNode *a_SiblingNode ,
		WmiAbsoluteBlockOffSet &a_SiblingBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
	) ;

	WmiStatusCode MergeSiblingNode ( 

		WmiBPKeyNode *a_ParentNode ,
		WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
		WmiBPKeyNode *a_SiblingNode ,
		WmiAbsoluteBlockOffSet &a_SiblingBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
	) ;

	WmiStatusCode LocateSuitableSibling ( 

		WmiBPKeyNode *a_ParentNode ,
		WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_LeftSiblingBlockOffSet ,
		WmiAbsoluteBlockOffSet &a_RightSiblingBlockOffSet
	) ;

	WmiStatusCode DeleteReBalance ( 

		WmiBPKeyNode *a_ParentNode ,
		WmiAbsoluteBlockOffSet &a_ParentBlockOffSet ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet
	) ;

	WmiStatusCode DeleteFixup ( 

		WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet
	) ;

	WmiStatusCode RecursiveDeleteFixup ( 

		WmiStack <WmiAbsoluteBlockOffSet,8> &a_Stack ,
		WmiBPKeyNode *a_RootNode ,
		WmiAbsoluteBlockOffSet &a_RootBlockOffSet ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet ,
		WmiRelativeBlockOffSet &a_PositionBlockOffSet
	) ;

	void PrintNode (

		wchar_t *a_Prefix ,
		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet
	) ;

	void Recurse ( 

		WmiBPKeyNode *a_Node ,
		WmiAbsoluteBlockOffSet &a_BlockOffSet
	) ;

public:

	WmiBPlusTree ( 

		WmiAllocator &a_Allocator ,
		WmiBlockInterface &a_BlockAllocator ,
		GUID &a_Identifier ,
		ULONG a_BlockSize ,
		ULONG a_KeyType ,
		ULONG a_KeyTypeLength ,
		ComparatorFunction a_ComparatorFunction ,
		void *a_ComparatorOperand 
	) ;

	~WmiBPlusTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiBPKey &a_Key ,
		const WmiBPElement &a_Element
	) ;

	WmiStatusCode Delete ( 

		const WmiBPKey &a_Key ,
		WmiBPElement &a_Element
	) ;

	WmiStatusCode Find (
	
		const WmiBPKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiBPKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiBPlusTree &a_Tree
	) ;

	void Recurse () ;
	
	void SetRoot ( const WmiAbsoluteBlockOffSet &a_Root ) { m_Root = a_Root ; }

	WmiAbsoluteBlockOffSet GetRoot () { return m_Root ; }

	ULONG Size () { return m_Size ; } ;
	GUID &GetIdentifier () { return m_Identifier ; }
	ULONG GetBlockSize () { return m_BlockSize ; }
	ULONG GetKeyType () { return m_KeyType ; }
	ULONG GetKeyTypeLength () { return m_KeyTypeLength ; }
	ComparatorFunction GetComparatorFunction () { return m_ComparatorFunction ; }
	void *GetComparatorOperand () { return m_ComparatorOperand ; }
	ULONG GetBlockHeaderSize () { return sizeof ( WmiBPKeyNode ) ; }

	Iterator &Begin ( Iterator &a_Iterator ) ;
	Iterator &End ( Iterator &a_Iterator ) ;
	Iterator &Root ( Iterator &a_Iterator ) ;
} ;

#endif _BPLUSTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\array.h ===
#ifndef _ARRAY_H
#define _ARRAY_H

#include "Allocator.h"

template <class WmiElement>
class WmiArray
{
private:

	struct WmiElementDir
	{
	public:

		WmiElement *m_Block ;
	} ;

	struct WmiInnerDir
	{
	public:

		WmiElementDir *m_ElementDir ;
	} ;

	class WmiOuterDir
	{
	public:

		WmiInnerDir *m_InnerDir ;
	} ;

	WmiOuterDir m_OuterDir ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode Initialize_ElementDir ( ULONG a_Size , WmiElementDir *a_ElementDir ) ;
	WmiStatusCode UnInitialize_ElementDir ( ULONG a_Size , WmiElementDir *a_ElementDir ) ;
	WmiStatusCode Grow_ElementDir ( ULONG a_Size , ULONG a_NewSize , WmiElementDir *a_ElementDir ) ;
	WmiStatusCode Shrink_ElementDir ( ULONG a_Size , ULONG a_NewSize , WmiElementDir *a_ElementDir ) ;

	WmiStatusCode Initialize_InnerDir ( ULONG a_Size , WmiInnerDir *a_InnerDir ) ;
	WmiStatusCode UnInitialize_InnerDir ( ULONG a_Size , WmiInnerDir *a_InnerDir ) ;
	WmiStatusCode Grow_InnerDir ( ULONG a_Size , ULONG a_NewSize , WmiInnerDir *a_InnerDir ) ;
	WmiStatusCode Shrink_InnerDir ( ULONG a_Size , ULONG a_NewSize , WmiInnerDir *a_InnerDir ) ;

	WmiStatusCode Initialize_OuterDir ( ULONG a_Size ) ;
	WmiStatusCode UnInitialize_OuterDir ( ULONG a_Size ) ;
	WmiStatusCode Grow_OuterDir ( ULONG a_Size , ULONG a_NewSize ) ;
	WmiStatusCode Shrink_OuterDir ( ULONG a_Size , ULONG a_NewSize ) ;

	WmiStatusCode Get ( 

		WmiElement *&a_Element , 
		ULONG a_ElementIndex
	) ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiArray :: Iterator &a_Iterator ) ;

friend Iterator ;

	class Iterator
	{
	private:

		WmiArray *m_Array ;
		ULONG m_Node ;

	public:

		Iterator () : m_Array ( NULL ) , m_Node ( NULL ) { ; }
		Iterator ( WmiArray *a_Array , ULONG a_Node ) { m_Array = a_Array ; m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Array = a_Iterator.m_Array ; m_Node = a_Iterator.m_Node ; }

		ULONG LeftMost ( ULONG a_Node ) 
		{
			ULONG t_Node = 0 ;

			return t_Node ;
		}

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		ULONG RightMost ( ULONG a_Node )
		{
			ULONG t_Node = m_Array->Size () 
			if ( t_Node )
			{
				t_Node -- ;
			}

			return t_Node ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			ULONG t_Node = m_Node ;

			if ( t_Node < m_Array->Size () )
			{
				if ( t_Node )
				{
					t_Node -- ;
				}
				else
				{
					t_Node = m_Array->Size () 
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			ULONG t_Node = m_Node ;

			if ( t_Node < m_Array->Size () )
			{
				t_Node ++ ;
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Array ? ( m_Node >= m_Array->Size () ) : true ; }

		WmiElement &GetElement ()
		{
			WmiElement *t_Element ;
			WmiStatusCode t_StatusCode = m_Array->Get ( t_Element , m_Node ) ;
			return *t_Element ; 
		}
	} ;

public:

	WmiArray ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiArray () ;

	WmiStatusCode Initialize ( ULONG a_Size ) ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Grow ( ULONG a_Size ) ;

	WmiStatusCode Shrink ( ULONG a_Size ) ;

	WmiStatusCode Set ( 

		const WmiElement &a_Element , 
		ULONG a_ElementIndex
	) ;

	WmiStatusCode Get ( 

		Iterator &a_Iterator , 
		ULONG a_ElementIndex
	) ;

	WmiStatusCode Get ( 

		WmiElement &a_Element , 
		ULONG a_ElementIndex
	) ;

	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( this , 0 ).LeftMost () ; };
	Iterator End () { return Iterator ( this , 0 ).RightMost () ; }
	
} ;

#include <Array.cpp>

#endif _ARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\hashtable.h ===
#ifndef _HASHTABLE_H
#define _HASHTABLE_H

#include "Allocator.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement,ULONG HashSize>
class WmiHashTable
{
private:

	WmiBasicTree <WmiKey,WmiElement> *m_Buckets ;

	WmiAllocator &m_Allocator ;

public:

	WmiHashTable ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiHashTable () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (

		const WmiKey &a_Key	,
		WmiElement &a_Element 
	) ;
	
	ULONG Size () { return m_Root.Size () ; } ;
	
} ;

#include <HashTable.cpp>

#endif _HASHTABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\allocator.h ===
#ifndef __Allocator_H
#define __Allocator_H

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

enum WmiStatusCode
{
	e_StatusCode_Success = 0 ,
	e_StatusCode_Success_Timeout ,
	e_StatusCode_EnQueue,
	e_StatusCode_OutOfMemory = 0x80000000 ,
	e_StatusCode_OutOfResources ,
	e_StatusCode_NotInitialized ,
	e_StatusCode_AlreadyInitialized ,
	e_StatusCode_InvalidArgs ,
	e_StatusCode_OutOfBounds ,
	e_StatusCode_OutOfQuota ,
	e_StatusCode_Unknown ,
	e_StatusCode_NotFound ,
	e_StatusCode_AlreadyExists ,
	e_StatusCode_Failed ,
	e_StatusCode_ServicingThreadTerminated ,
	e_StatusCode_HostingThreadTerminated ,
	e_StatusCode_Change ,
	e_StatusCode_InvalidHeap
} ;

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new ( size_t a_Size , void *a_Ptr ) { return a_Ptr ; }
inline void __cdecl operator delete ( void * , void * ) { ; }
#endif

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiAllocator
{
public:

	enum AllocationOptions 
	{
		e_GenerateException = HEAP_GENERATE_EXCEPTIONS ,
		e_NoSerialize = HEAP_NO_SERIALIZE ,
		e_ZeroMemory = HEAP_ZERO_MEMORY ,
		e_ReallocInPlace = HEAP_REALLOC_IN_PLACE_ONLY ,
		e_DefaultAllocation = 0 
	} ;

private:


	LONG m_ReferenceCount ;

	HANDLE m_Heap ;
	AllocationOptions m_Options ;
	size_t m_InitialSize ;
	size_t m_MaximumSize ;

	WmiStatusCode Win32ToApi () ;

public:

	WmiAllocator () ;
		
	WmiAllocator ( 

		AllocationOptions a_Option , 
		size_t a_InitialSize , 
		size_t a_MaximumSize

	) ;

	~WmiAllocator () ;

	ULONG AddRef () ;

	ULONG Release () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode New ( 

		void **a_Allocation , 
		size_t a_Size
	) ;

	WmiStatusCode New ( 

		AllocationOptions a_Option , 
		void **a_Allocation , 
		size_t a_Size
	) ;

	WmiStatusCode ReAlloc ( 

		void *a_Allocation , 
		void **a_ReAllocation , 
		size_t a_Size
	) ;

	WmiStatusCode ReAlloc ( 

		AllocationOptions a_Option , 
		void *a_Allocation , 
		void **a_ReAllocation , 
		size_t a_Size
	) ;

	WmiStatusCode Delete (

		void *a_Allocation
	) ;

	WmiStatusCode Size ( 

		void *a_Allocation ,
		size_t &a_Size
	) ;

	WmiStatusCode Compact ( 

		size_t &a_LargestFreeBlock
	) ;

	WmiStatusCode Validate (

		LPCVOID a_Location = NULL 
	) ;

} ;

#endif // __Allocator_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\basictree.h ===
#ifndef _BasicTree_H
#define _BasicTree_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement>
class WmiBasicTree
{
protected:

	class WmiBasicNode
	{
	public:

		WmiElement m_Element ;
		WmiKey m_Key ;

		WmiBasicNode *m_Left ;
		WmiBasicNode *m_Right ;
		WmiBasicNode *m_Parent ;

		WmiBasicNode () 
		{
			m_Left = m_Right = m_Parent = NULL ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiBasicTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiBasicTree <WmiKey,WmiElement>;
	private:

		WmiBasicNode *m_Node ;

		WmiBasicNode *LeftMost ( WmiBasicNode *a_Node ) 
		{
			WmiBasicNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiBasicNode *RightMost ( WmiBasicNode *a_Node )
		{
			WmiBasicNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiBasicNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiBasicNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiBasicNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiBasicNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiBasicNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiBasicNode *m_Root ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode DeleteFixup ( WmiBasicNode *a_Node ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiBasicNode *a_Node ) ;

public:

	WmiBasicTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiBasicTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiBasicTree <WmiKey,WmiElement> &a_Tree
	) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator End () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <BasicTree.cpp>

#endif _BasicTree_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\cache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Cache_H
#define _Cache_H

#include <Allocator.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <TPQueue.h>
#include <AvlTree.h>
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
class WmiCacheController : public IUnknown
{
public:

	class WmiUniqueTimeout
	{
	private:

		ULONG m_Ticks ;
		LONG m_Counter ;

	public:

		WmiUniqueTimeout () : m_Ticks ( 0 ) , m_Counter ( 0 ) { ; }
		WmiUniqueTimeout (

			const ULONG &a_Ticks ,
			const LONG &a_Counter

		) : m_Ticks ( a_Ticks ) , 
			m_Counter ( a_Counter )
		{ ; }

		ULONG GetTicks () const { return m_Ticks ; }
		LONG GetCounter () const { return m_Counter ; }
	} ;

	class WmiCacheElement : public IUnknown
	{
	private:

		LONG m_ReferenceCount ;
		LONG m_InternalReferenceCount ;
		LONG m_NonCylicReferenceCount ;
		BOOL m_Decaying ;
		BOOL m_Cached ;
		BOOL m_Decayed ;
		ULONG m_CallBackInternalRelease ;

		WmiCacheController <WmiKey> *m_Controller ;
		WmiKey m_Key ;
		ULONG m_Period ;

	public:

		WmiCacheElement () :
								m_ReferenceCount ( 0 ) ,
								m_InternalReferenceCount ( 0 ) ,
								m_NonCylicReferenceCount ( 0 ) ,
								m_Controller ( NULL ) ,
								m_Period ( 0 ) ,
								m_Decaying ( FALSE ) ,
								m_Decayed ( FALSE ) ,
								m_Cached ( FALSE ) ,
								m_CallBackInternalRelease ( 1 ) 
		{
		}

		WmiCacheElement ( 

			WmiCacheController <WmiKey> *a_Controller ,
			const WmiKey &a_Key , 
			const ULONG &a_Period

		) :	m_ReferenceCount ( 0 ) ,
			m_InternalReferenceCount ( 0 ) ,
			m_NonCylicReferenceCount ( 0 ) ,
			m_Controller ( a_Controller ) ,
			m_Period ( a_Period ) ,
			m_Decaying ( FALSE ) ,
			m_Decayed ( FALSE ) ,
			m_Cached ( FALSE ) ,
			m_CallBackInternalRelease ( 1 ) 
		{
			m_Key = a_Key ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		virtual ~WmiCacheElement ()
		{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~WmiCacheElement ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif
		
#ifdef DBG
			if ( m_ReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_InternalReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_NonCylicReferenceCount != 0 )
			{
				DebugBreak () ;
			}
#endif

			if ( m_Controller )
			{
				m_Controller->Release () ;
			}
		}

		virtual void CallBackRelease () {} ;
		virtual void CallBackInternalRelease () {} ;

		virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) 
		{
			return E_NOINTERFACE ;
		}

		virtual STDMETHODIMP_( ULONG ) AddRef ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				InternalAddRef () ;

				SetDecaying ( FALSE ) ; 
			}

			if ( m_Controller ) 
			{
				m_Controller->UnLock () ;
			}
			
			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) Release ()
		{
			if ( m_Controller )
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				CallBackRelease () ;

				if ( m_Controller )
				{
					if ( GetCached () )
					{
						if ( GetDecayed () == FALSE )
						{
							if ( GetDecaying () == FALSE ) 
							{
								WmiStatusCode t_StatusCode = m_Controller->Decay ( *this ) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									SetDecaying ( TRUE ) ;
								}
							}
						}

						t_ReferenceCount = UnLockedInternalRelease () ;
					}
					else
					{
						t_ReferenceCount = UnLockedInternalRelease () ;
					}
				}
				else
				{
					t_ReferenceCount = UnLockedInternalRelease () ;
				}
			}
			else 
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) InternalAddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				NonCyclicAddRef () ;
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) UnLockedInternalRelease ()
		{
			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( GetCached () )
				{
					m_Controller->Delete ( m_Key ) ;

					SetCached ( FALSE ) ;
				}

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) InternalRelease ()
		{
			if ( m_Controller )
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				BOOL t_Cached = GetCached () ;
				if ( t_Cached )
				{
					m_Controller->Delete ( m_Key ) ;
					SetCached ( FALSE ) ;
				}

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) NonCyclicAddRef ()
		{
			return InterlockedIncrement ( & m_NonCylicReferenceCount ) ;
		}

		STDMETHODIMP_( ULONG ) NonCyclicRelease ()
		{
			ULONG t_ReferenceCount = InterlockedDecrement ( & m_NonCylicReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				delete this ;
			}

			return t_ReferenceCount ;
		}

		ULONG GetPeriod ()
		{
			return m_Period ;
		}

		void SetPeriod ( const ULONG &a_Period )
		{
			m_Period = a_Period ;
		}

		WmiKey &GetKey ()
		{
			return m_Key ;
		}

		void SetKey ( const WmiKey &a_Key )
		{
			m_Key = a_Key ;
		}

		BOOL GetDecaying ()
		{
			return m_Decaying ;
		}
	
		BOOL GetDecayed () 
		{
			return m_Decayed ;
		}

		BOOL GetCached () 
		{
			return m_Cached ;
		}

		void SetDecayed ( BOOL a_Decayed )
		{	
			m_Decayed = a_Decayed ;
		}

		void SetDecaying ( BOOL a_Decay )
		{	
			m_Decaying = a_Decay ;
		}

		void SetCached ( BOOL a_Cached ) 
		{
			m_Cached = a_Cached ;
		}

		void SetController ( WmiCacheController <WmiKey> *a_Controller )
		{
			if ( m_Controller )
			{
				m_Controller->Release () ;
			}

			m_Controller = a_Controller ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		WmiCacheController <WmiKey> *GetController ()
		{
			return m_Controller ;
		}
	} ;

typedef WmiAvlTree	<WmiKey,WmiCacheElement *>	Cache ;
typedef Cache :: Iterator Cache_Iterator ;

private:

typedef WmiTreePriorityQueue <WmiUniqueTimeout,WmiCacheElement *> CacheDecay ;
typedef CacheDecay :: Iterator CacheDecay_Iterator ;

	WmiAllocator &m_Allocator ;
	CriticalSection m_CriticalSection ;

	LONG m_ReferenceCount ;

	Cache m_Cache ;
	CacheDecay m_CacheDecay ;
	LONG m_Counter ;

protected:
public:

	WmiCacheController ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiCacheController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		WmiCacheElement &a_Element , 
		Cache_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( const WmiKey &a_Key , Cache_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Shutdown () ;

	virtual WmiStatusCode Shutdown ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode StrobeBegin ( const ULONG &a_Timeout ) ;

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	virtual WmiStatusCode Delete ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode Decay (

		WmiCacheElement &a_Element
	) ;

	WmiStatusCode GetCache ( Cache *&a_Cache )
	{
		a_Cache = & m_Cache ;
		return e_StatusCode_Success ;
	}

	CriticalSection* GetCriticalSection ()
	{
		return &m_CriticalSection ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
class WmiContainerController : public IUnknown
{
public:

	class WmiContainerElement : public IUnknown
	{
	private:

		LONG m_ReferenceCount ;
		LONG m_InternalReferenceCount ;
		LONG m_NonCylicReferenceCount ;
		BOOL m_Cached ;

		WmiContainerController <WmiKey> *m_Controller ;
		WmiKey m_Key ;
		ULONG m_CallBackInternalRelease ;

	public:

		WmiContainerElement () :
								m_ReferenceCount ( 0 ) ,
								m_InternalReferenceCount ( 0 ) ,
								m_NonCylicReferenceCount ( 0 ) ,
								m_Cached ( FALSE ) ,
								m_Controller ( NULL ) ,
								m_CallBackInternalRelease ( 1 )
		{
		}

		WmiContainerElement ( 

			WmiContainerController <WmiKey> *a_Controller ,
			const WmiKey &a_Key 

		) :	m_ReferenceCount ( 0 ) ,
			m_InternalReferenceCount ( 0 ) ,
			m_NonCylicReferenceCount ( 0 ) ,
			m_Cached ( FALSE ) ,
			m_Controller ( a_Controller ) ,
			m_Key ( a_Key ) ,
			m_CallBackInternalRelease ( 1 )
		{
			if ( m_Controller ) 
			{
				m_Controller->AddRef () ;
			}
		}

		virtual ~WmiContainerElement ()
		{
#ifdef DBG
			if ( m_ReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_InternalReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_NonCylicReferenceCount != 0 )
			{
				DebugBreak () ;
			}
#endif

			if ( m_Controller )
			{
				m_Controller->Release () ;
			}
		}

		virtual void CallBackRelease () {} ;
		virtual void CallBackInternalRelease () {} ;

		virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) 
		{
			return E_NOINTERFACE ;
		}

		virtual STDMETHODIMP_( ULONG ) AddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				InternalAddRef () ;
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) Release ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				CallBackRelease () ;

				if ( GetCached () )
				{
					LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
				}

				UnLockedInternalRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif
				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) InternalAddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				NonCyclicAddRef () ;
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) UnLockedInternalRelease ()
		{
			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( m_Controller )
				{
					m_Controller->Delete ( m_Key ) ;

					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) InternalRelease ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( m_Controller )
				{
					m_Controller->Delete ( m_Key ) ;

					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) NonCyclicAddRef ()
		{
			return InterlockedIncrement ( & m_NonCylicReferenceCount ) ;
		}

		virtual STDMETHODIMP_( ULONG ) NonCyclicRelease ()
		{
			ULONG t_ReferenceCount = InterlockedDecrement ( & m_NonCylicReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				delete this ;
			}
			
			return t_ReferenceCount ;
		}

		BOOL GetCached () 
		{
			return m_Cached ;
		}

		void SetCached ( BOOL a_Cached ) 
		{
			m_Cached = a_Cached ;
		}

		WmiKey &GetKey ()
		{
			return m_Key ;
		}

		void SetKey ( const WmiKey &a_Key )
		{
			m_Key = a_Key ;
		}

		void SetController ( WmiContainerController <WmiKey> *a_Controller )
		{
			if ( m_Controller )
			{
				m_Controller->Release () ;
			}

			m_Controller = a_Controller ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		WmiContainerController <WmiKey> *GetController ()
		{
			return m_Controller ;
		}

	} ;

typedef WmiAvlTree	<WmiKey,WmiContainerElement *> Container ;
typedef Container :: Iterator Container_Iterator ;

private:

	LONG m_ReferenceCount ;

	CriticalSection m_CriticalSection ;

	Container m_Container ;

protected:
public:

	WmiContainerController ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiContainerController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		WmiContainerElement &a_Element , 
		Container_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( const WmiKey &a_Key , Container_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Shutdown () ;

	virtual WmiStatusCode Delete ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode GetContainer ( Container *&a_Container )
	{
		a_Container = & m_Container ;
		return e_StatusCode_Success ;
	}

	CriticalSection* GetCriticalSection ()
	{
		return &m_CriticalSection ;
	}

} ;

#include <Cache.cpp>

#endif _Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\helperfuncs.h ===
#ifndef _HELPERFUNCS_H
#define _HELPERFUNCS_H

#include <Allocator.H>
#include <lockst.h>
class WmiHelper
{
public:

	static WmiStatusCode DuplicateString ( 

		WmiAllocator &a_Allocator , 
		const wchar_t *a_String , 
		wchar_t *&a_DuplicatedString
	) ;

	static WmiStatusCode CreateUnNamedEvent (

		HANDLE &a_Event , 
		BOOL a_ManualReset = FALSE ,
		BOOL a_InitialState = FALSE 
	) ;

	static WmiStatusCode CreateNamedEvent (

		wchar_t *a_Name , 
		HANDLE &a_Event , 
		BOOL a_ManualReset = FALSE ,
		BOOL a_InitialState = FALSE 
	) ;

	static WmiStatusCode DuplicateHandle (

		HANDLE a_Handle , 
		HANDLE &a_DuplicatedHandle
	) ;


	static WmiStatusCode ConcatenateStrings (

		ULONG a_ArgCount , 
		BSTR *a_AllocatedString ,
		...
	) ;

	static WmiStatusCode ConcatenateStrings_Wchar (

		ULONG a_ArgCount , 
		wchar_t **a_AllocatedString ,
		...
	) ;

	static WmiStatusCode InitializeCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode DeleteCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode EnterCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection ,
		BOOL a_WaitCritical = TRUE
	) ;

	static WmiStatusCode LeaveCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode EnterCriticalSection ( 
	
		CriticalSection* a_CriticalSection ,
		BOOL a_WaitCritical = TRUE
	) ;

	static WmiStatusCode LeaveCriticalSection ( 
	
		CriticalSection *a_CriticalSection
	) ;
	static WmiStatusCode InitializeCriticalSection ( 
	
		CriticalSection *a_CriticalSection
	) ;

	static WmiStatusCode DeleteCriticalSection ( 
		CriticalSection *a_CriticalSection
	) ;
	

} ;

#endif _HELPERFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\pqueue.h ===
#ifndef _PQUEUE_H
#define _PQUEUE_H

#include "Allocator.h"
#include "Algorithms.h"
#include "Array.h"

#define PARENT(Index)			(((Index+1)>>1)-1)
#define LEFT(Index)				(((Index+1)<<1)-1)
#define RIGHT(Index)			(((Index+1)<<1))

template <class WmiKey,class WmiElement,ULONG ElementSize>
class WmiPriorityQueue
{
public:

	class WmiKeyElementPair 
	{
	public:

		WmiKey m_Key ;
		WmiElement m_Element ;
	} ;

private:

	WmiArray <WmiKeyElementPair> m_Array ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode ShuffleDown ( ULONG a_Index ) ;

	WmiStatusCode ShuffleUp ( const WmiKeyElementPair &a_KeyElementPair , ULONG a_Index ) ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiPriorityQueue :: Iterator &a_Iterator ) ;

friend Iterator ;
	class Iterator
	{
	private:

		WmiPriorityQueue *m_Queue ;
		ULONG m_Node ;

	public:

		Iterator () : m_Queue ( NULL ) , m_Node ( NULL ) { ; }
		Iterator ( WmiPriorityQueue *a_Queue , ULONG a_Node ) { m_Queue = a_Queue ; m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Queue = a_Iterator.m_Queue ; m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node < m_Queue->Size () ? LEFT ( m_Node ) : m_Queue->Size () ; return *this ; }
		Iterator &Right () { m_Node = m_Node < m_Queue->Size () ? RIGHT ( m_Node ) : m_Queue->Size () ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : m_Queue->Size () ; return *this ; }

		ULONG LeftMost ( ULONG a_Node ) 
		{
			ULONG t_Node = 0 ;

			return t_Node ;
		}

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		ULONG RightMost ( ULONG a_Node )
		{
			ULONG t_Node = m_Queue->Size () 
			if ( t_Node )
			{
				t_Node -- ;
			}

			return t_Node ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			ULONG t_Node = m_Node ;

			if ( t_Node < m_Queue->Size () )
			{
				if ( t_Node )
				{
					t_Node -- ;
				}
				else
				{
					t_Node = m_Queue->Size () 
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			ULONG t_Node = m_Node ;

			if ( t_Node < m_Queue->Size () )
			{
				t_Node ++ ;
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Queue ? ( m_Node >= m_Queue->Size () ) : true ; }

		WmiKey &GetKey ()
		{
			WmiArray <WmiKeyElementPair> :: Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Queue->m_Array.Get ( t_Iterator , m_Node ) ;

			return t_Iterator.GetElement ().m_Key ; 
		}

		WmiElement &GetElement ()
		{
			WmiArray <WmiKeyElementPair> :: Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Queue->m_Array.Get ( t_Iterator , m_Node ) ;

			return t_Iterator.GetElement ().m_Element ; 
		}
	} ;

public:

	WmiPriorityQueue ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiPriorityQueue () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode EnQueue ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiKey &a_Key ,
		WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		Iterator &a_Iterator 
	) ;

	WmiStatusCode DeQueue () ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( this , 0 ).LeftMost () ; };
	Iterator End () { return Iterator ( this , 0 ).RightMost () ; }
	Iterator Root () { return Iterator ( this , 0 ) ; }
	
	WmiStatusCode Sort () ;
} ;

#include <PQueue.cpp>

#endif _PQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\ioscheduler.h ===
#ifndef __IO_SCHEDULER_H
#define __IO_SCHEDULER_H

#include <Allocator.h>
#include <Thread.h>

typedef UINT64 WmiFileOffSet ;
typedef UINT64 WmiFileSize ;

WmiStatusCode Win32ToApi () ;
WmiStatusCode Win32ToApi ( DWORD a_Error ) ;

class WmiIoScheduler ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiFileOperation
{
public:

	virtual ULONG AddRef () = 0 ;

	virtual ULONG Release () = 0 ;

	virtual void Operation ( DWORD a_Status , BYTE *a_OperationBytes , DWORD a_Bytes ) = 0 ;
} ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiTaskOperation
{
public:

	virtual ULONG AddRef () = 0 ;

	virtual ULONG Release () = 0 ;

	virtual void Operation ( DWORD a_Status ) = 0 ;
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

struct WmiOverlapped 
{
public:

	OVERLAPPED m_Overlapped ;

	enum OverLappedType
	{
		e_OverLapped_Read ,
		e_OverLapped_Write ,
		e_OverLapped_Lock ,
		e_OverLapped_UnLock ,
		e_OverLapped_Terminate ,
		e_OverLapped_Task ,
		e_OverLapped_Unknown
	} ;

	OverLappedType m_Type ;

public:

	WmiOverlapped ( OverLappedType a_Type ) ;
	~WmiOverlapped () ;

	OverLappedType GetType () { return m_Type ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiTerminateOverlapped : public WmiOverlapped
{
private:

public:

	WmiTerminateOverlapped () ;
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiScheduledOverlapped : public WmiOverlapped
{
private:

	WmiIoScheduler &m_Scheduler ;

public:

	WmiScheduledOverlapped ( OverLappedType a_Type , WmiIoScheduler &m_Scheduler ) ;
	~WmiScheduledOverlapped () ;

	WmiIoScheduler &GetScheduler () { return m_Scheduler ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiReadOverlapped : public WmiScheduledOverlapped
{
private:

	DWORD m_State ;
	DWORD m_Status ;
	BYTE *m_Buffer ;
	DWORD m_BufferSize ;
	WmiFileOperation *m_OperationFunction ;

public:

	WmiReadOverlapped (

		WmiIoScheduler &a_Scheduler ,
		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_Buffer ,
		DWORD a_BufferSize
	) ;

	~WmiReadOverlapped () ;

	BYTE *GetBuffer () { return m_Buffer ; }
	DWORD GetBufferSize () { return m_BufferSize ; }
	DWORD GetStatus () { return m_Status ; }

	void SetState ( DWORD a_State ) { m_State = a_State ; }
	DWORD GetState () { return m_State ; }
	WmiFileOperation *GetOperationFunction () { return m_OperationFunction ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiWriteOverlapped : public WmiScheduledOverlapped
{
private:

	DWORD m_State ;
	DWORD m_Status ;
	BYTE *m_Buffer ;
	DWORD m_BufferSize ;
	WmiFileOperation *m_OperationFunction ;

public:

	WmiWriteOverlapped (

		WmiIoScheduler &a_Scheduler ,
		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_Buffer ,
		DWORD a_BufferSize
	) ;

	~WmiWriteOverlapped () ;

	BYTE *GetBuffer () { return m_Buffer ; }
	DWORD GetBufferSize () { return m_BufferSize ; }
	DWORD GetStatus () { return m_Status ; }

	void SetState ( DWORD a_State ) { m_State = a_State ; }
	DWORD GetState () { return m_State ; }
	WmiFileOperation *GetOperationFunction () { return m_OperationFunction ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiLockOverlapped : public WmiScheduledOverlapped
{
private:

	DWORD m_State ;
	DWORD m_Status ;
	WmiFileOffSet m_OffSetSize ;

	WmiFileOperation *m_OperationFunction ;

public:

	WmiLockOverlapped (

		WmiIoScheduler &a_Scheduler ,
		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	~WmiLockOverlapped () ;

	DWORD GetStatus () { return m_Status ; }

	void SetState ( DWORD a_State ) { m_State = a_State ; }
	DWORD GetState () { return m_State ; }
	WmiFileOperation *GetOperationFunction () { return m_OperationFunction ; }
	WmiFileOffSet GetOffSetSize () { return m_OffSetSize ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiUnLockOverlapped : public WmiScheduledOverlapped
{
private:

	DWORD m_State ;
	DWORD m_Status ;
	WmiFileOffSet m_OffSetSize ;

	WmiFileOperation *m_OperationFunction ;

public:

	WmiUnLockOverlapped (

		WmiIoScheduler &a_Scheduler ,
		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	~WmiUnLockOverlapped () ;

	DWORD GetStatus () { return m_Status ; }

	void SetState ( DWORD a_State ) { m_State = a_State ; }
	DWORD GetState () { return m_State ; }
	WmiFileOperation *GetOperationFunction () { return m_OperationFunction ; }
	WmiFileOffSet GetOffSetSize () { return m_OffSetSize ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiTaskOverlapped : public WmiScheduledOverlapped
{
private:

	DWORD m_State ;
	DWORD m_Status ;
	WmiTaskOperation *m_OperationFunction ;

public:

	WmiTaskOverlapped (

		WmiIoScheduler &a_Scheduler ,
		WmiTaskOperation *a_OperationFunction
	) ;

	~WmiTaskOverlapped () ;

	DWORD GetStatus () { return m_Status ; }

	void SetState ( DWORD a_State ) { m_State = a_State ; }
	DWORD GetState () { return m_State ; }
	WmiTaskOperation *GetOperationFunction () { return m_OperationFunction ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiThreadPool 
{
private:

	LONG m_ReferenceCount ;

	WmiThread <ULONG> **m_ThreadPool ;
	ULONG m_Threads ;
	WmiAllocator &m_Allocator ;

	HANDLE m_CompletionPort ;

public:

	WmiThreadPool ( 

		WmiAllocator &a_Allocator ,
		const ULONG &a_Threads = 0 
	) ;

	~WmiThreadPool () ;

	ULONG AddRef () ;

	ULONG Release () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	HANDLE GetCompletionPort () { return m_CompletionPort ; }
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiCompletionPortOperation : public WmiTask <ULONG>
{
private:

	WmiThreadPool *m_ThreadPool ;

public:

	WmiCompletionPortOperation ( 

		WmiAllocator &a_Allocator , 
		WmiThreadPool *a_ThreadPool
	) ;

	~WmiCompletionPortOperation () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
} ;

/* 
 *	Class:
 *
 *		WmiIoScheduler
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiIoScheduler
{
public:
private:

	LONG m_ReferenceCount ;
	wchar_t *m_FileName ;

	WmiThreadPool *m_ThreadPool ;
	WmiAllocator &m_Allocator ;

	WmiFileSize m_UseSize ;
	WmiFileSize m_AllocatedSize ;
	WmiFileSize m_InitialSize ;
	WmiFileSize m_MaximumSize ;

protected:

	HANDLE m_FileHandle ;

public:

	WmiIoScheduler ( 

		WmiAllocator &a_Allocator ,
		WmiThreadPool *a_ThreadPool ,
		wchar_t *a_FileName ,
		WmiFileSize a_InitialSize , 
		WmiFileSize a_MaximumSize
	) ;

	~WmiIoScheduler () ;

	ULONG AddRef () ;

	ULONG Release () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Task (

		WmiTaskOperation *a_OperationFunction
	) ;

	virtual WmiStatusCode Read ( 

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_ReadBytes ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode Write (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_WriteBytes ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode Lock (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	virtual WmiStatusCode UnLock (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	virtual WmiStatusCode ReadOnThread ( 

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_ReadBytes ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode WriteOnThread (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_WriteBytes ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode LockOnThread (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_EndOffSet
	) ;

	virtual WmiStatusCode UnLockOnThread (

		WmiFileOperation *a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	virtual WmiStatusCode TaskBegin (

		WmiTaskOverlapped *a_Overlapped
	) ;

	virtual WmiStatusCode ReadBegin ( 

		WmiReadOverlapped *a_Overlapped , 
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode WriteBegin (

		WmiWriteOverlapped *a_Overlapped ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode LockBegin ( 

		WmiLockOverlapped *a_Overlapped , 
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode UnLockBegin ( 

		WmiUnLockOverlapped *a_Overlapped , 
		DWORD a_Bytes
	) ;

	virtual void ReadComplete ( 

		WmiReadOverlapped *a_Overlapped , 
		DWORD a_Bytes
	) ;

	virtual void WriteComplete (

		WmiWriteOverlapped *a_Overlapped ,
		DWORD a_Bytes
	) ;

	virtual void LockComplete (

		WmiLockOverlapped *a_Overlapped ,
		DWORD a_Bytes
	) ;

	virtual void UnLockComplete (

		WmiUnLockOverlapped *a_Overlapped ,
		DWORD a_Bytes
	) ;

	virtual WmiStatusCode SetFileExtent (

		const WmiFileOffSet &a_FileOffSet 
	) ;

	virtual WmiStatusCode Create () ;

	virtual WmiStatusCode Close () ;

	virtual WmiStatusCode Read (

		LPVOID a_Buffer ,
		DWORD a_NumberOfBytesToRead ,
		LPDWORD a_NumberOfBytesRead ,
		LPOVERLAPPED a_Overlapped
	) ;

	virtual WmiStatusCode Write (

		LPVOID a_Buffer ,
		DWORD a_NumberOfBytesToWrite ,
		LPDWORD a_NumberOfBytesWritten ,
		LPOVERLAPPED a_Overlapped
	) ;

	virtual WmiStatusCode Lock (

		DWORD a_Flags ,
		DWORD a_NumberOfBytesToLockLow ,
		DWORD a_NumberOfBytesToLockHigh ,
		LPOVERLAPPED a_Overlapped       
	) ;

	virtual WmiStatusCode UnLock (

		DWORD a_NumberOfBytesToUnlockLow ,
		DWORD a_NumberOfBytesToUnlockHigh ,
		LPOVERLAPPED a_Overlapped
	) ;

	HANDLE GetFileHandle () { return m_FileHandle ; }
	wchar_t *GetFileName () { return m_FileName ; }
} ;

#endif __IO_SCHEDULER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\queue.h ===
#ifndef _QUEUE_H
#define _QUEUE_H

#include "PssException.h"
#include "Allocator.h"

#define QUEUE_ELEMENT_DIR_BIT_SIZE	ElementSize
#define QUEUE_ELEMENT_DIR_SIZE		1 << QUEUE_ELEMENT_DIR_BIT_SIZE 
#define QUEUE_ELEMENT_DIR_MASK		0xFFFFFFFF >> ( 32 - QUEUE_ELEMENT_DIR_BIT_SIZE )

template <class WmiElement, ULONG ElementSize >
class WmiQueue
{
private:

	class WmiElementDir 
	{
	public:

		WmiElementDir *m_Next ;

		WmiElement m_Block [ QUEUE_ELEMENT_DIR_SIZE ] ;

		WmiElementDir () { m_Next = NULL ; } ;
		~WmiElementDir () { ; } ;
	} ;

	WmiElementDir *m_Top ;
	WmiElementDir *m_Tail ;

	ULONG m_TopIndex ;
	ULONG m_TailIndex ;

	ULONG m_Size ;
	ULONG m_AllocatedSize ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode UnInitialize_ElementDir ( ULONG a_Size ) ;
	WmiStatusCode Grow_ElementDir () ;
	WmiStatusCode Shrink_ElementDir () ;

public:

	WmiQueue ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiQueue () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode EnQueue ( 

		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiElement &a_Element
	) ;

	WmiStatusCode DeQueue () ;
	
	ULONG Size () { return m_Size ; } ;
	
} ;

#include <Queue.cpp>

#endif _QUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\logging.h ===
/* 
 *	Class:
 *
 *		WmiDebugLog
 *
 *	Description:
 *
 *		
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */



#ifndef __WMILOG_H
#define __WMILOG_H

#include <locks.h>
#if 0
#ifdef LOGGINGDEBUG_INIT
class __declspec ( dllexport ) WmiDebugLog
#else
class __declspec ( dllimport ) WmiDebugLog
#endif
#else
class WmiDebugLog
#endif
{
public:

	enum WmiDebugContext
	{
		FILE = 0 ,
		DEBUG = 1 
	} ;

private:

	CriticalSection m_CriticalSection ;

	static long s_ReferenceCount ;

	WmiAllocator &m_Allocator ;
	enum WmiDebugContext m_DebugContext ;
	BOOL m_Logging ;
	BOOL m_Verbose ;
	DWORD m_DebugLevel ;
	DWORD m_DebugFileSize;
	wchar_t *m_DebugComponent ;
	wchar_t *m_DebugFile ;
	HANDLE m_DebugFileHandle ;
	static BOOL s_Initialised ;

	static void SetEventNotification () ;

	void LoadRegistry_Logging  () ;
	void LoadRegistry_Level () ;
	void LoadRegistry_File () ;
	void LoadRegistry_FileSize () ;
	void LoadRegistry_Type () ;

	void SetRegistry_Logging  () ;
	void SetRegistry_Level () ;
	void SetRegistry_File () ;
	void SetRegistry_FileSize () ;
	void SetRegistry_Type () ;
	void SetDefaultFile () ;

	void OpenFileForOutput () ;
	void OpenOutput () ;
	void CloseOutput () ;
	void FlushOutput () ;
	void SwapFileOver () ;
	void WriteOutput ( const WCHAR *a_DebugOutput ) ;

protected:
public:

	WmiDebugLog ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiDebugLog () ;

	WmiStatusCode Initialize ( const wchar_t *a_DebugComponent ) ;

	/*************************************************************************
	* There are 3 functions to write to a log file, which may be used in accordance with the following rules:
	*
	*	1. The user always knows whether he is writing to an ANSI file or a Unicode file, and he
	*		has to make sure this holds good in the rules 2, 3 and 4 below. This will be changed later to
	*		make it more flowxible to the user.
	*	2. Write() takes wchar_t arguments and the function will write and ANSI or Unicode string
	*		to the log file depending on what wchar_t maps to, in the compilation.
	*	3. WriteW() takes WCHAR arguments only, and expects that the file being written to is a Unicode file.
	*	4. WriteA() takes char arguments only, and expects that the file being written to is an ANSI file.
	*
	****************************************************************/
	void Write ( const wchar_t *a_DebugFormatString , ... ) ;
	void Write ( const wchar_t *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... ) ;
	void Flush () ;

	void LoadRegistry () ;
	void SetRegistry () ;

	void SetLevel ( const DWORD &a_DebugLevel ) ;
	DWORD GetLevel () ;

	void SetContext ( const enum WmiDebugContext &a_DebugContext ) ;
	enum WmiDebugContext GetContext () ;

	void SetFile ( const wchar_t *a_File ) ;
	wchar_t *GetFile () ;

	void SetLogging ( BOOL a_Logging = TRUE ) ;
	BOOL GetLogging () ;

	void SetVerbose ( BOOL a_Verbose = TRUE ) ;
	BOOL GetVerbose () ;

	void CommitContext () ;

	static WmiDebugLog *s_WmiDebugLog ;

	static WmiStatusCode Initialize ( WmiAllocator &a_Allocator ) ;
	static WmiStatusCode UnInitialize ( WmiAllocator &a_Allocator ) ;

public:

} ;

inline DWORD WmiDebugLog :: GetLevel ()
{
	DWORD t_Level = m_DebugLevel ;
	return t_Level ;
}

inline wchar_t *WmiDebugLog :: GetFile ()
{
	wchar_t *t_File = m_DebugFile ;
	return t_File ;
}

inline BOOL WmiDebugLog :: GetLogging () 
{
	return m_Logging ;
}

inline void WmiDebugLog :: SetVerbose ( BOOL a_Verbose ) 
{
	m_Verbose = a_Verbose ;
}

inline BOOL WmiDebugLog :: GetVerbose ()
{
	return m_Verbose ;
}

#define DebugMacro(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro0(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 1 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro1(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 2 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro2(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 4 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro3(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 8 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro4(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 16 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro5(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 32 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro6(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 64 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro7(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 128 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro8(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 256 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro9(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 512 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro10(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 1024 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro11(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 2048 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro12(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 4096 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro13(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 8192 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro14(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 16384 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro15(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 32768 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#endif __WMILOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\readerwriter.h ===
#ifndef __READERWRITER_H
#define __READERWRITER_H

#include "Allocator.h"
#include <locks.h>
/* 
 *	Class:
 *
 *		WmiMultiReaderSingleWrite
 *
 *	Description:
 *
 *		Provides 
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiMultiReaderSingleWriter
{
private:

	HANDLE m_ReaderSemaphore ;
	LONG m_ReaderSize ;

	CriticalSection m_WriterCriticalSection ;

	WmiStatusCode m_InitializationStatusCode ;

public:

	WmiMultiReaderSingleWriter ( 

		const LONG &a_ReaderSize 
	) ;

	~WmiMultiReaderSingleWriter () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode EnterRead () ;

	virtual WmiStatusCode EnterWrite () ;

	virtual WmiStatusCode LeaveRead () ;

	virtual WmiStatusCode LeaveWrite () ;
} ;

/* 
 *	Class:
 *
 *		WmiMultiReaderMultiWriter
 *
 *	Description:
 *
 *		Provides 
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiMultiReaderMultiWriter
{
private:

	HANDLE m_ReaderSemaphore ;
	LONG m_ReaderSize ;

	HANDLE m_WriterSemaphore ;
	LONG m_WriterSize ;

	WmiStatusCode m_InitializationStatusCode ;

public:

	WmiMultiReaderMultiWriter ( 

		const LONG &a_ReaderSize ,
		const LONG &a_WriterSize 
	) ;

	~WmiMultiReaderMultiWriter () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode EnterRead ( const LONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode EnterWrite ( const LONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode LeaveRead () ;

	virtual WmiStatusCode LeaveWrite () ;
} ;

#endif __READERWRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\keyedarray.h ===
#ifndef __KEYEDARRAY_H
#define __KEYEDARRAY_H

#include "Allocator.h"
#include "Algorithms.h"
#include "KeyedArray.h"

template <class WmiKey,class WmiElement,ULONG GrowSize>
class WmiKeyedArray
{
protected:

	class WmiArrayNode
	{
	public:

		WmiElement m_Element ;
		WmiKey m_Key ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiKeyedArray :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiKeyedArray <WmiKey,WmiElement,GrowSize>;
	private:

		WmiKeyedArray *m_Array ;
		ULONG m_Node ;

	public:

		Iterator () : m_Array ( NULL ) , m_Node ( 0xFFFFFFFF ) { ; }
		Iterator ( WmiKeyedArray *a_Array , ULONG a_Node ) { m_Array = a_Array ; m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Array = a_Iterator.m_Array ; m_Node = a_Iterator.m_Node ; }

		Iterator &Decrement ()
		{
			if ( m_Node != 0xFFFFFFFF )
			{
				m_Node -- ;
			}
			else
			{
				m_Node = 0xFFFFFFFF ;
			}

			return *this ;
		}

		Iterator &Increment () 
		{
			if ( m_Node < m_Array->m_Size - 1 )
			{
				m_Node ++ ;
			}
			else
			{
				m_Node = 0xFFFFFFFF ;
			}

			return *this ;
		}

		bool Null () { return m_Node == 0xFFFFFFFF ; }

		WmiKey &GetKey () { return m_Array->m_Block [ m_Node ].m_Key ; }
		WmiElement &GetElement () { return m_Array->m_Block [ m_Node ].m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiArrayNode *m_Block ;

	ULONG m_Size ;
	ULONG m_AllocatedSize ;

	WmiAllocator &m_Allocator ;

public:

	WmiKeyedArray ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiKeyedArray () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiKeyedArray <WmiKey,WmiElement,GrowSize> &a_Array
	) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( this , 0 ) ; };
	Iterator End () { return Iterator ( this , m_Size - 1 ) ; }
} ;

#include <KeyedArray.cpp>

#endif __KEYEDARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\pssexception.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _EXCEPTIONS_H
#define _EXCEPTIONS_H

#include <eh.h>
#include <Allocator.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_Structured_Exception
{
private:

    UINT m_ExceptionCode ;
	EXCEPTION_POINTERS *m_ExceptionInformation ;

public:

    Wmi_Structured_Exception () {}

    Wmi_Structured_Exception ( 

		UINT a_ExceptionCode , 
		EXCEPTION_POINTERS *a_ExceptionInformation

	) : m_ExceptionCode ( a_ExceptionCode ) , 
		m_ExceptionInformation ( a_ExceptionInformation ) 
	{}

    ~Wmi_Structured_Exception () {}

    UINT GetExceptionCode () 
	{
		return m_ExceptionCode ;
	}

	EXCEPTION_POINTERS *GetExtendedInformation () 
	{
		return m_ExceptionInformation ;
	}
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_SetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc;

public:

	static void __cdecl s_Trans_Func ( 

		UINT a_ExceptionNumber , 
		EXCEPTION_POINTERS *a_ExceptionInformation
	)
	{
		throw Wmi_Structured_Exception ( a_ExceptionNumber , a_ExceptionInformation ) ;
	}

	Wmi_SetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		m_PrevFunc = _set_se_translator ( s_Trans_Func ) ;
	}

	~Wmi_SetStructuredExceptionHandler ()
	{
		_set_se_translator ( m_PrevFunc ) ;
	}
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_Heap_Exception
{
public:
	
	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error ;

public:

	Wmi_Heap_Exception ( HEAP_ERROR a_Error ) : m_Error ( a_Error ) {}

	~Wmi_Heap_Exception () {}

	HEAP_ERROR GetError ()
	{
		return m_Error;
	}
};


#endif // _EXCEPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\stack.h ===
#ifndef _STACK_H
#define _STACK_H

#include "PssException.h"
#include "Allocator.h"

#define STACK_ELEMENT_DIR_BIT_SIZE	ElementSize
#define STACK_ELEMENT_DIR_SIZE		1 << STACK_ELEMENT_DIR_BIT_SIZE 
#define STACK_ELEMENT_DIR_MASK		0xFFFFFFFF >> ( 32 - STACK_ELEMENT_DIR_BIT_SIZE )

template <class WmiElement, ULONG ElementSize >
class WmiStack
{
private:

	class WmiElementDir 
	{
	public:

		WmiElementDir *m_Previous ;
		WmiElement m_Block [ STACK_ELEMENT_DIR_SIZE ] ;

		WmiElementDir () { m_Previous = NULL ; } ;
		~WmiElementDir () { ; } ;
	} ;

	WmiElementDir *m_Top ;
	ULONG m_Size ;
	ULONG m_AllocatedSize ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode UnInitialize_ElementDir ( ULONG a_Size ) ;
	WmiStatusCode Grow_ElementDir () ;
	WmiStatusCode Shrink_ElementDir () ;

public:

	WmiStack ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiStack () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Push ( 

		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiElement &a_Element
	) ;

	WmiStatusCode Pop () ;
	
	ULONG Size () { return m_Size + 1 ; } ;
	
} ;

#include "..\Stack.cpp"

#endif _STACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\redblacktree.h ===
#ifndef _REDBLACKTREE_H
#define _REDBLACKTREE_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "RedBlackTree.h"

template <class WmiKey,class WmiElement>
class WmiRedBlackTree
{
protected:

	class WmiRedBlackNode
	{
	public:

		enum WmiRedBlackColor
		{
			e_Red ,
			e_Black 
		} ;

		WmiElement m_Element ;
		WmiKey m_Key ;

		WmiRedBlackNode *m_Left ;
		WmiRedBlackNode *m_Right ;
		WmiRedBlackNode *m_Parent ;
		WmiRedBlackColor m_Color ;

		WmiRedBlackNode () 
		{
			m_Left = m_Right = m_Parent = NULL ;
			m_Color = e_Black ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiRedBlackTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiRedBlackTree <WmiKey,WmiElement>;
	private:

		WmiRedBlackNode *m_Node ;

		WmiRedBlackNode *LeftMost ( WmiRedBlackNode *a_Node ) 
		{
			WmiRedBlackNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiRedBlackNode *RightMost ( WmiRedBlackNode *a_Node )
		{
			WmiRedBlackNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiRedBlackNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiRedBlackNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiRedBlackNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiRedBlackNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiRedBlackNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiRedBlackNode *m_Root ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode LeftRotate ( WmiRedBlackNode *a_Node ) ;

	WmiStatusCode RightRotate ( WmiRedBlackNode *a_Node ) ;

	WmiStatusCode DeleteFixup ( WmiRedBlackNode *a_Node ) ;

	WmiStatusCode RecursiveDelete ( WmiRedBlackNode *a_Root , const WmiKey &a_Key ) ;

	WmiStatusCode RecursiveInsert ( WmiRedBlackNode *a_Root , WmiRedBlackNode *a_Node ) ;

	WmiStatusCode RecursiveFind ( WmiRedBlackNode *a_Root , const WmiKey &a_Key , Iterator &a_Iterator ) ;

	WmiStatusCode RecursiveFindNext ( WmiRedBlackNode *a_Root , const WmiKey &a_Key , Iterator &a_Iterator ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiRedBlackNode *a_Node ) ;

public:

	WmiRedBlackTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiRedBlackTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiRedBlackTree <WmiKey,WmiElement> &a_Tree
	) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator End () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <RedBlackTree.cpp>

#endif _REDBLACKTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test\globals.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <HashTable.h>
#include <BpTree.h>
#include <KeyedArray.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <ReaderWriter.cpp>
#include <BpTree.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\threadedavltree.h ===
#ifndef _ThreadedAvlTREE_H
#define _ThreadedAvlTREE_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "ThreadedAvlTree.h"

template <class WmiKey,class WmiElement>
class WmiThreadedAvlTree
{
public:

	class WmiThreadedAvlNode
	{
	public:

		enum WmThreadedAvlState
		{
			e_Equal,
			e_LeftHigher ,
			e_RightHigher
		} ;

		WmiThreadedAvlNode *m_Previous ;
		WmiThreadedAvlNode *m_Next ;

		WmiKey m_Key ;

		WmiThreadedAvlNode *m_Left ;
		WmiThreadedAvlNode *m_Right ;
		WmiThreadedAvlNode *m_Parent ;

		WmThreadedAvlState m_State ;

		WmiElement m_Element ;

		WmiThreadedAvlNode () 
		{
			m_Left = m_Right = m_Parent = m_Previous = m_Next = NULL ;
			m_State = e_Equal ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiThreadedAvlTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiThreadedAvlTree <WmiKey,WmiElement>;
	private:

		WmiThreadedAvlNode *m_Node ;

		WmiThreadedAvlNode *LeftMost ( WmiThreadedAvlNode *a_Node ) 
		{
			WmiThreadedAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiThreadedAvlNode *RightMost ( WmiThreadedAvlNode *a_Node )
		{
			WmiThreadedAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiThreadedAvlNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiThreadedAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				t_Node = t_Node->m_Previous ;
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiThreadedAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				t_Node = t_Node->m_Next ;
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &TreeDecrement ()
		{
			WmiThreadedAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiThreadedAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &TreeIncrement () 
		{
			WmiThreadedAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiThreadedAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiThreadedAvlNode *m_Root ;
	WmiThreadedAvlNode *m_Head ;
	WmiThreadedAvlNode *m_Tail ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode DeleteFixup ( WmiThreadedAvlNode *a_Node , bool &a_Decreased ) ;

	WmiStatusCode RecursiveCheck ( WmiThreadedAvlNode *a_Root , ULONG &a_Count , ULONG a_Height , ULONG &a_MaxHeight ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiThreadedAvlNode *a_Node ) ;

	WmiStatusCode Insert_LeftBalance ( 

		WmiThreadedAvlNode *&a_Node , 
		WmiThreadedAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Insert_RightBalance ( 

		WmiThreadedAvlNode *&a_Node , 
		WmiThreadedAvlNode *a_Right , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_LeftBalance ( 

		WmiThreadedAvlNode *&a_Node , 
		WmiThreadedAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_RightBalance ( 

		WmiThreadedAvlNode *&a_Node , 
		WmiThreadedAvlNode *a_Right , 
		bool &a_Increased
	) ;

#if 0
	WmiStatusCode RecursiveDelete ( WmiThreadedAvlNode *a_Root , const WmiKey &a_Key , 	bool &a_Decreased ) ;

	WmiStatusCode RecursiveInsert ( WmiThreadedAvlNode *a_Root , WmiThreadedAvlNode *a_Node , bool &a_Increased ) ;
#endif

public:

	WmiThreadedAvlTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiThreadedAvlTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiThreadedAvlTree <WmiKey,WmiElement> &a_Tree
	) ;

	WmiStatusCode Check ( ULONG &a_MaxHeight ) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Head ) ; };
	Iterator End () { return Iterator ( m_Tail ) ; }

	Iterator TreeBegin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator TreeEnd () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <ThreadedAvlTree.cpp>

#endif _ThreadedAvlTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test2\globals.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <HashTable.h>
#include <BpTree.h>
#include <KeyedArray.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <ReaderWriter.cpp>
#include <BpTree.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\thread.h ===
#ifndef __THREAD_H
#define __THREAD_H

#include "Allocator.h"
#include "TPQueue.h"
#include "BasicTree.h"
#include <lockst.h>
/* 
 *	Forwards:
 *
 *		WmiTask
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey> class WmiTask ;
template <class WmiKey> class WmiThread ;

/* 
 *	Class:
 *
 *		WmiTask
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey> 
class WmiTask
{
friend WmiThread <WmiKey>;

public:

	enum WmiTaskEnqueueType 
	{
		e_WmiTask_Enqueue ,
		e_WmiTask_EnqueueAlertable ,
		e_WmiTask_EnqueueInterruptable 
	} ;

	enum WmiTaskState
	{
		e_WmiTask_UnInitialized ,
		e_WmiTask_Initialized ,
		e_WmiTask_EnQueued ,
		e_WmiTask_DeQueued 
	} ;

private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	wchar_t *m_Name ;
	wchar_t *m_CompletionName ;

	HANDLE m_Event ;
	HANDLE m_CompletionEvent ;

	WmiStatusCode m_InitializationStatusCode ;

	WmiTaskEnqueueType m_EnqueueType ;
	WmiTaskState m_TaskState ;

private:

	void SetTaskState ( WmiTaskState a_TaskState ) { m_TaskState = a_TaskState ; }

public:

	WmiTask ( 

		WmiAllocator &a_Allocator ,
		const wchar_t *a_Name = NULL ,
		const wchar_t *a_CompletionName = NULL
	) ;

	WmiTask ( 

		WmiAllocator &a_Allocator ,
		HANDLE a_Event ,
		HANDLE a_CompletionEvent ,
		const wchar_t *a_Name = NULL ,
		const wchar_t *a_CompletionName = NULL 
	) ;

	virtual ~WmiTask () ;

	virtual ULONG STDMETHODCALLTYPE AddRef () ;

	virtual ULONG STDMETHODCALLTYPE Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Process ( WmiThread <WmiKey> &a_Thread ) ;

	virtual WmiStatusCode Exec () ;

	virtual WmiStatusCode Complete () ;

	virtual WmiStatusCode Wait ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode WaitInterruptable ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode WaitAlertable ( const ULONG &a_Timeout = INFINITE ) ;

	wchar_t *GetName () { return m_Name ; }
	wchar_t *GetCompletionName () { return m_CompletionName ; }

	HANDLE GetEvent () { return m_Event ; }
	HANDLE GetCompletionEvent () { return m_CompletionEvent ; }

	WmiAllocator &GetAllocator () { return m_Allocator ; } 

	WmiTaskState TaskState () { return m_TaskState ; }

	WmiTaskEnqueueType EnqueuedAs () { return m_EnqueueType ; }
	void EnqueueAs ( WmiTaskEnqueueType a_EnqueueType ) { m_EnqueueType = a_EnqueueType ; }
} ;

/* 
 *	Class:
 *
 *		WmiThread
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey>
class WmiThread
{
friend class WmiTask <WmiKey> ;
public:

	class QueueKey
	{
	public:

		WmiKey m_Key ;
		INT64 m_Tick ;

		QueueKey () { ; } ;

		QueueKey ( const INT64 &a_Tick , const WmiKey &a_Key ) :

			m_Key ( a_Key ) ,
			m_Tick ( a_Tick ) 
		{
			
		}

		~QueueKey () { ; }

		INT64 GetTick () { return m_Tick ; }
		void SetTick ( const INT64 &a_Tick ) { m_Tick = a_Tick ; }
		WmiKey &GetKey () { return m_Key ; }
	} ;

typedef WmiBasicTree <WmiTask <WmiKey> * , WmiThread <WmiKey> *> TaskContainer ;
typedef TaskContainer :: Iterator TaskContainerIterator ;
typedef WmiBasicTree <ULONG , WmiThread <WmiKey> *> ThreadContainer ;
typedef ThreadContainer :: Iterator ThreadContainerIterator ;
typedef WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> QueueContainer ;
typedef WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> :: Iterator QueueContainerIterator ;

private:

	static ULONG ThreadProc ( void *a_Thread ) ;

	static ThreadContainer *s_ThreadContainer ;
	static TaskContainer *s_TaskContainer ;
	static CriticalSection s_CriticalSection ;
	static LONG s_InitializeReferenceCount ;

	INT64 m_Key;
	LONG m_ReferenceCount ;
	LONG m_InternalReferenceCount ;
	
	CriticalSection m_CriticalSection ;

	WmiStatusCode m_InitializationStatusCode ;

// Determine change in queue state.

	HANDLE m_Initialized ;

	HANDLE m_QueueChange ;
	
	HANDLE m_Terminate ;

// All allocations done via allocator

	WmiAllocator &m_Allocator ;

// Useful debug information

	wchar_t *m_Name ;
	HANDLE m_Thread ;
	ULONG m_Identifier ;

// Timeout period for internal event dispatch

	ULONG m_Timeout ;

// Stack Size

	DWORD m_StackSize ;

// All runnable tasks are placed in the queue in priority order,
// as task are executed, task can re-schedule itself, otherwise it is discarded.
// Priority is based on key compounded with insertion order ( ticks ), this implies
// tasks with same key are scheduled in FIFO order.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_TaskQueue ;

// All runnable tasks are placed in the queue in priority order,
// as task are executed, task can re-schedule itself, otherwise it is discarded.
// Priority is based on key compounded with insertion order ( ticks ), this implies
// tasks with same key are scheduled in FIFO order.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_InterruptableTaskQueue ;

// Alertable events are placed on the queue, as event is signalled they are transferred onto
// the regular queue where they are priority dispatched based on priority as inserted.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_AlertableTaskQueue ;

// a_EventCount [in] = Number of Predefined Dispatchable Events 

	static WmiStatusCode Static_Dispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_Dispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode Dispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode Wait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;


	static WmiStatusCode Static_InterruptableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_InterruptableDispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode InterruptableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode InterruptableWait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;


	WmiStatusCode Execute ( QueueContainer &a_Queue , QueueContainer &t_EnQueue ) ;

	WmiStatusCode ShuffleTask (

		const HANDLE &a_Event
	) ;

	WmiStatusCode FillHandleTable (

		HANDLE *a_HandleTable , 
		ULONG &a_Capacity
	) ;

	static WmiStatusCode Static_AlertableDispatch ( WmiTask <WmiKey> &a_Task  , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_AlertableDispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode AlertableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode AlertableWait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

// Dispatch code

	WmiStatusCode ThreadDispatch () ;
	WmiStatusCode ThreadWait () ;

	WmiStatusCode CreateThread () ;

	static WmiThread *GetThread () ;

	static WmiThread *GetServicingThread ( WmiTask <WmiKey> &a_Task ) ;

	HANDLE GetTerminateHandle () ;

public:

	WmiThread ( 

		WmiAllocator &a_Allocator ,
		const wchar_t *a_Name = NULL ,
		ULONG a_Timeout = INFINITE ,
		DWORD a_StackSize = 0 
	) ;

	virtual ~WmiThread () ;

	virtual ULONG STDMETHODCALLTYPE AddRef () ;

	virtual ULONG STDMETHODCALLTYPE Release () ;

	virtual ULONG STDMETHODCALLTYPE InternalAddRef () ;

	virtual ULONG STDMETHODCALLTYPE InternalRelease () ;

	virtual WmiStatusCode Initialize_Callback () { return e_StatusCode_Success ; } ;

	virtual WmiStatusCode UnInitialize_Callback () { return e_StatusCode_Success ; } ;

	virtual void CallBackRelease () {} ;

	virtual WmiStatusCode Initialize ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode PostShutdown () ;

	virtual WmiStatusCode TimedOut () ;

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication in Queue status will not execute
// newly queued tasks.

	virtual WmiStatusCode EnQueue ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode EnQueueAlertable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication of Queue status change will execute
// newly queued tasks. This is used for STA based execution where we need to interrupt the wait
// to execute a dependant request.
// 

	virtual WmiStatusCode EnQueueInterruptable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueue ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueueAlertable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueueInterruptable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	wchar_t *GetName () { return m_Name ; }
	ULONG GetIdentifier () { return m_Identifier ; }
	HANDLE GetHandle () { return m_Thread ; }
	ULONG GetTimeout () { return m_Timeout ; }
	DWORD GetStackSize () { return m_StackSize ; }

	void SetTimeout ( const ULONG &a_Timeout ) { m_Timeout = a_Timeout ; }
	void SetStackSize ( const DWORD &a_StackSize ) { m_StackSize = a_StackSize ; }

	HANDLE GetTerminationEvent () { return m_Terminate ; }
	HANDLE GetQueueChangeEvent () { return m_QueueChange ; }

	WmiAllocator &GetAllocator () { return m_Allocator ; } 

	static WmiStatusCode Static_Initialize ( WmiAllocator &a_Allocator ) ;
	static WmiStatusCode Static_UnInitialize ( WmiAllocator &a_Allocator ) ;

} ;

#include <Thread.cpp>
#include <tpwrap.h>

#endif __THREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test\main.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#undef _CRTIMP
#define POLARITY __declspec( dllexport )
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <map>


#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <AvlTree.h>
#include <ThreadedAvlTree.h>
#include <TPQueue.h>
#include <HashTable.h>
#include <Thread.h>
#include <BpTree.h>
#include <BasicTree.h>
#include <KeyedArray.h>

std::_Lockit::_Lockit()
{
}

std::_Lockit::~_Lockit()
{
}
  


UINT64 g_Array [] = {

#if 0
	0x00007f9b ,	0x000018e5 ,	0x00007485 ,	0x0000781c ,
	0x00004328 ,	0x000054fb ,	0x00002948 ,	0x00002702 ,
	0x00003623 ,	0x00004744 ,	0x00001209 ,	0x00004a32 ,
	0x00005f7d ,	0x000010b5 ,	0x00006a73 ,	0x000012f6 ,
	0x00003e6b ,	0x00003a85 ,	0x00004277 ,	0x00000ecf ,
	0x00003274 ,	0x00004ded ,	0x00006404 ,	0x00000029 ,
	0x00004823 ,	0x000018be ,	0x00006784 ,	0x00004ae1 ,
	0x00003d6c ,	0x00002cd6 ,	0x000072ae ,	0x00006952 ,
	0x00005f90 ,	0x00001649 ,	0x00006df1 ,	0x00005af1 ,
	0x000041bb ,	0x000026e9 ,	0x000001eb ,	0x00000bb3 ,
	0x00002ea6 ,	0x000012db ,	0x0000153c ,	0x00007e87 ,
	0x0000390c ,	0x00000f3e ,	0x00000099 ,	0x00000124 ,
	0x0000305e ,	0x0000440d ,	0x0000491c ,	0x00004d06 ,
	0x00004db7 ,	0x00001547 ,	0x000054de ,	0x000039b3 ,
	0x00002d12 ,	0x0000074d ,	0x00004dc8 ,	0x00006443 ,
	0x000066bb ,	0x0000428b ,	0x000026a6 ,	0x0000701f ,
	0x00005d03 ,	0x00007a5a ,	0x0000767d ,	0x00004509 ,
	0x00001238 ,	0x00003b25 ,	0x00001e1f ,	0x00006e5d ,
	0x00001ad4 ,	0x000063cb ,	0x00006bfc ,	0x00007f96 ,
	0x00007ff5 ,	0x00004e45 ,	0x0000323b ,	0x00002213 ,
	0x0000260d ,	0x00006b89 ,	0x0000030a ,	0x0000301c ,
	0x00000bdb ,	0x000056ae ,	0x00000732 ,	0x00000120 ,
	0x0000759a ,	0x00002350 ,	0x000022ee ,	0x00004b40 ,
	0x00005878 ,	0x00006b36 ,	0x00005cfd ,	0x00003e12 ,
	0x00001a49 ,	0x00005f32 ,	0x00003bf6 ,	0x00003a9e ,
	0x0000797d ,	0x00005f49 ,	0x00000ddc ,	0x00004cad ,
	0x0000314f ,	0x00005e14 ,	0x00004df2 ,	0x00004944 ,
	0x00002e40 ,	0x00001366 ,	0x00001cd0 ,	0x0000366b ,
	0x000066c4 ,	0x00004230 ,	0x00007eb7 ,	0x00006032 ,
	0x00002c3b ,	0x000015a1 ,	0x00005422 ,	0x00003ef6 ,
	0x00000822 ,	0x00005991 ,	0x0000409d ,    0x00001101 ,

	0x00017f9b ,	0x000118e5 ,	0x00017485 ,	0x0001781c ,
	0x00014328 ,	0x000154fb ,	0x00012948 ,	0x00012702 ,
	0x00013623 ,	0x00014744 ,	0x00011209 ,	0x00014a32 ,
	0x00015f7d ,	0x000110b5 ,	0x00016a73 ,	0x000112f6 ,
	0x00013e6b ,	0x00013a85 ,	0x00014277 ,	0x00010ecf ,
	0x00013274 ,	0x00014ded ,	0x00016404 ,	0x00010029 ,
	0x00014823 ,	0x000118be ,	0x00016784 ,	0x00014ae1 ,
	0x00013d6c ,	0x00012cd6 ,	0x000172ae ,	0x00016952 ,
	0x00015f90 ,	0x00011649 ,	0x00016df1 ,	0x00015af1 ,
	0x000141bb ,	0x000126e9 ,	0x000101eb ,	0x00010bb3 ,
	0x00012ea6 ,	0x000112db ,	0x0001153c ,	0x00017e87 ,
	0x0001390c ,	0x00010f3e ,	0x00010099 ,	0x00010124 ,
	0x0001305e ,	0x0001440d ,	0x0001491c ,	0x00014d06 ,
	0x00014db7 ,	0x00011547 ,	0x000154de ,	0x000139b3 ,
	0x00012d12 ,	0x0001074d ,	0x00014dc8 ,	0x00016443 ,
	0x000166bb ,	0x0001428b ,	0x000126a6 ,	0x0001701f ,
	0x00015d03 ,	0x00017a5a ,	0x0001767d ,	0x00014509 ,
	0x00011238 ,	0x00013b25 ,	0x00011e1f ,	0x00016e5d ,
	0x00011ad4 ,	0x000163cb ,	0x00016bfc ,	0x00017f96 ,
	0x00017ff5 ,	0x00014e45 ,	0x0001323b ,	0x00012213 ,
	0x0001260d ,	0x00016b89 ,	0x0001030a ,	0x0001301c ,
	0x00010bdb ,	0x000156ae ,	0x00010732 ,	0x00010120 ,
	0x0001759a ,	0x00012350 ,	0x000122ee ,	0x00014b40 ,
	0x00015878 ,	0x00016b36 ,	0x00015cfd ,	0x00013e12 ,
	0x00011a49 ,	0x00015f32 ,	0x00013bf6 ,	0x00013a9e ,
	0x0001797d ,	0x00015f49 ,	0x00010ddc ,	0x00014cad ,
	0x0001314f ,	0x00015e14 ,	0x00014df2 ,	0x00014944 ,
	0x00012e40 ,	0x00011366 ,	0x00011cd0 ,	0x0001366b ,
	0x000166c4 ,	0x00014230 ,	0x00017eb7 ,	0x00016032 ,
	0x00012c3b ,	0x000115a1 ,	0x00015422 ,	0x00013ef6 ,
	0x00010822 ,	0x00015991 ,	0x0001409d ,    0x00011101 ,

	0x00027f9b ,	0x000218e5 ,	0x00027485 ,	0x0002781c ,
	0x00024328 ,	0x000254fb ,	0x00022948 ,	0x00022702 ,
	0x00023623 ,	0x00024744 ,	0x00021209 ,	0x00024a32 ,
	0x00025f7d ,	0x000210b5 ,	0x00026a73 ,	0x000212f6 ,
	0x00023e6b ,	0x00023a85 ,	0x00024277 ,	0x00020ecf ,
	0x00023274 ,	0x00024ded ,	0x00026404 ,	0x00020029 ,
	0x00024823 ,	0x000218be ,	0x00026784 ,	0x00024ae1 ,
	0x00023d6c ,	0x00022cd6 ,	0x000272ae ,	0x00026952 ,
	0x00025f90 ,	0x00021649 ,	0x00026df1 ,	0x00025af1 ,
	0x000241bb ,	0x000226e9 ,	0x000201eb ,	0x00020bb3 ,
	0x00022ea6 ,	0x000212db ,	0x0002153c ,	0x00027e87 ,
	0x0002390c ,	0x00020f3e ,	0x00020099 ,	0x00020124 ,
	0x0002305e ,	0x0002440d ,	0x0002491c ,	0x00024d06 ,
	0x00024db7 ,	0x00021547 ,	0x000254de ,	0x000239b3 ,
	0x00022d12 ,	0x0002074d ,	0x00024dc8 ,	0x00026443 ,
	0x000266bb ,	0x0002428b ,	0x000226a6 ,	0x0002701f ,
	0x00025d03 ,	0x00027a5a ,	0x0002767d ,	0x00024509 ,
	0x00021238 ,	0x00023b25 ,	0x00021e1f ,	0x00026e5d ,
	0x00021ad4 ,	0x000263cb ,	0x00026bfc ,	0x00027f96 ,
	0x00027ff5 ,	0x00024e45 ,	0x0002323b ,	0x00022213 ,
	0x0002260d ,	0x00026b89 ,	0x0002030a ,	0x0002301c ,
	0x00020bdb ,	0x000256ae ,	0x00020732 ,	0x00020120 ,
	0x0002759a ,	0x00022350 ,	0x000222ee ,	0x00024b40 ,
	0x00025878 ,	0x00026b36 ,	0x00025cfd ,	0x00023e12 ,
	0x00021a49 ,	0x00025f32 ,	0x00023bf6 ,	0x00023a9e ,
	0x0002797d ,	0x00025f49 ,	0x00020ddc ,	0x00024cad ,
	0x0002314f ,	0x00025e14 ,	0x00024df2 ,	0x00024944 ,
	0x00022e40 ,	0x00021366 ,	0x00021cd0 ,	0x0002366b ,
	0x000266c4 ,	0x00024230 ,	0x00027eb7 ,	0x00026032 ,
	0x00022c3b ,	0x000215a1 ,	0x00025422 ,	0x00023ef6 ,
	0x00020822 ,	0x00025991 ,	0x0002409d ,    0x00021101 ,

	0x00037f9b ,	0x000318e5 ,	0x00037485 ,	0x0003781c ,
	0x00034328 ,	0x000354fb ,	0x00032948 ,	0x00032702 ,
	0x00033623 ,	0x00034744 ,	0x00031209 ,	0x00034a32 ,
	0x00035f7d ,	0x000310b5 ,	0x00036a73 ,	0x000312f6 ,
	0x00033e6b ,	0x00033a85 ,	0x00034277 ,	0x00030ecf ,
	0x00033274 ,	0x00034ded ,	0x00036404 ,	0x00030029 ,
	0x00034823 ,	0x000318be ,	0x00036784 ,	0x00034ae1 ,
	0x00033d6c ,	0x00032cd6 ,	0x000372ae ,	0x00036952 ,
	0x00035f90 ,	0x00031649 ,	0x00036df1 ,	0x00035af1 ,
	0x000341bb ,	0x000326e9 ,	0x000301eb ,	0x00030bb3 ,
	0x00032ea6 ,	0x000312db ,	0x0003153c ,	0x00037e87 ,
	0x0003390c ,	0x00030f3e ,	0x00030099 ,	0x00030124 ,
	0x0003305e ,	0x0003440d ,	0x0003491c ,	0x00034d06 ,
	0x00034db7 ,	0x00031547 ,	0x000354de ,	0x000339b3 ,
	0x00032d12 ,	0x0003074d ,	0x00034dc8 ,	0x00036443 ,
	0x000366bb ,	0x0003428b ,	0x000326a6 ,	0x0003701f ,
	0x00035d03 ,	0x00037a5a ,	0x0003767d ,	0x00034509 ,
	0x00031238 ,	0x00033b25 ,	0x00031e1f ,	0x00036e5d ,
	0x00031ad4 ,	0x000363cb ,	0x00036bfc ,	0x00037f96 ,
	0x00037ff5 ,	0x00034e45 ,	0x0003323b ,	0x00032213 ,
	0x0003260d ,	0x00036b89 ,	0x0003030a ,	0x0003301c ,
	0x00030bdb ,	0x000356ae ,	0x00030732 ,	0x00030120 ,
	0x0003759a ,	0x00032350 ,	0x000322ee ,	0x00034b40 ,
	0x00035878 ,	0x00036b36 ,	0x00035cfd ,	0x00033e12 ,
	0x00031a49 ,	0x00035f32 ,	0x00033bf6 ,	0x00033a9e ,
	0x0003797d ,	0x00035f49 ,	0x00030ddc ,	0x00034cad ,
	0x0003314f ,	0x00035e14 ,	0x00034df2 ,	0x00034944 ,
	0x00032e40 ,	0x00031366 ,	0x00031cd0 ,	0x0003366b ,
	0x000366c4 ,	0x00034230 ,	0x00037eb7 ,	0x00036032 ,
	0x00032c3b ,	0x000315a1 ,	0x00035422 ,	0x00033ef6 ,
	0x00030822 ,	0x00035991 ,	0x0003409d ,    0x00031101 ,

	0x00047f9b ,	0x000418e5 ,	0x00047485 ,	0x0004781c ,
	0x00044328 ,	0x000454fb ,	0x00042948 ,	0x00042702 ,
	0x00043623 ,	0x00044744 ,	0x00041209 ,	0x00044a32 ,
	0x00045f7d ,	0x000410b5 ,	0x00046a73 ,	0x000412f6 ,
	0x00043e6b ,	0x00043a85 ,	0x00044277 ,	0x00040ecf ,
	0x00043274 ,	0x00044ded ,	0x00046404 ,	0x00040029 ,
	0x00044823 ,	0x000418be ,	0x00046784 ,	0x00044ae1 ,
	0x00043d6c ,	0x00042cd6 ,	0x000472ae ,	0x00046952 ,
	0x00045f90 ,	0x00041649 ,	0x00046df1 ,	0x00045af1 ,
	0x000441bb ,	0x000426e9 ,	0x000401eb ,	0x00040bb3 ,
	0x00042ea6 ,	0x000412db ,	0x0004153c ,	0x00047e87 ,
	0x0004390c ,	0x00040f3e ,	0x00040099 ,	0x00040124 ,
	0x0004305e ,	0x0004440d ,	0x0004491c ,	0x00044d06 ,
	0x00044db7 ,	0x00041547 ,	0x000454de ,	0x000439b3 ,
	0x00042d12 ,	0x0004074d ,	0x00044dc8 ,	0x00046443 ,
	0x000466bb ,	0x0004428b ,	0x000426a6 ,	0x0004701f ,
	0x00045d03 ,	0x00047a5a ,	0x0004767d ,	0x00044509 ,
	0x00041238 ,	0x00043b25 ,	0x00041e1f ,	0x00046e5d ,
	0x00041ad4 ,	0x000463cb ,	0x00046bfc ,	0x00047f96 ,
	0x00047ff5 ,	0x00044e45 ,	0x0004323b ,	0x00042213 ,
	0x0004260d ,	0x00046b89 ,	0x0004030a ,	0x0004301c ,
	0x00040bdb ,	0x000456ae ,	0x00040732 ,	0x00040120 ,
	0x0004759a ,	0x00042350 ,	0x000422ee ,	0x00044b40 ,
	0x00045878 ,	0x00046b36 ,	0x00045cfd ,	0x00043e12 ,
	0x00041a49 ,	0x00045f32 ,	0x00043bf6 ,	0x00043a9e ,
	0x0004797d ,	0x00045f49 ,	0x00040ddc ,	0x00044cad ,
	0x0004314f ,	0x00045e14 ,	0x00044df2 ,	0x00044944 ,
	0x00042e40 ,	0x00041366 ,	0x00041cd0 ,	0x0004366b ,
	0x000466c4 ,	0x00044230 ,	0x00047eb7 ,	0x00046032 ,
	0x00042c3b ,	0x000415a1 ,	0x00045422 ,	0x00043ef6 ,
	0x00040822 ,	0x00045991 ,	0x0004409d ,    0x00041101 ,

	0x00057f9b ,	0x000518e5 ,	0x00057485 ,	0x0005781c ,
	0x00054328 ,	0x000554fb ,	0x00052948 ,	0x00052702 ,
	0x00053623 ,	0x00054744 ,	0x00051209 ,	0x00054a32 ,
	0x00055f7d ,	0x000510b5 ,	0x00056a73 ,	0x000512f6 ,
	0x00053e6b ,	0x00053a85 ,	0x00054277 ,	0x00050ecf ,
	0x00053274 ,	0x00054ded ,	0x00056404 ,	0x00050029 ,
	0x00054823 ,	0x000518be ,	0x00056784 ,	0x00054ae1 ,
	0x00053d6c ,	0x00052cd6 ,	0x000572ae ,	0x00056952 ,
	0x00055f90 ,	0x00051649 ,	0x00056df1 ,	0x00055af1 ,
	0x000541bb ,	0x000526e9 ,	0x000501eb ,	0x00050bb3 ,
	0x00052ea6 ,	0x000512db ,	0x0005153c ,	0x00057e87 ,
	0x0005390c ,	0x00050f3e ,	0x00050099 ,	0x00050124 ,
	0x0005305e ,	0x0005440d ,	0x0005491c ,	0x00054d06 ,
	0x00054db7 ,	0x00051547 ,	0x000554de ,	0x000539b3 ,
	0x00052d12 ,	0x0005074d ,	0x00054dc8 ,	0x00056443 ,
	0x000566bb ,	0x0005428b ,	0x000526a6 ,	0x0005701f ,
	0x00055d03 ,	0x00057a5a ,	0x0005767d ,	0x00054509 ,
	0x00051238 ,	0x00053b25 ,	0x00051e1f ,	0x00056e5d ,
	0x00051ad4 ,	0x000563cb ,	0x00056bfc ,	0x00057f96 ,
	0x00057ff5 ,	0x00054e45 ,	0x0005323b ,	0x00052213 ,
	0x0005260d ,	0x00056b89 ,	0x0005030a ,	0x0005301c ,
	0x00050bdb ,	0x000556ae ,	0x00050732 ,	0x00050120 ,
	0x0005759a ,	0x00052350 ,	0x000522ee ,	0x00054b40 ,
	0x00055878 ,	0x00056b36 ,	0x00055cfd ,	0x00053e12 ,
	0x00051a49 ,	0x00055f32 ,	0x00053bf6 ,	0x00053a9e ,
	0x0005797d ,	0x00055f49 ,	0x00050ddc ,	0x00054cad ,
	0x0005314f ,	0x00055e14 ,	0x00054df2 ,	0x00054944 ,
	0x00052e40 ,	0x00051366 ,	0x00051cd0 ,	0x0005366b ,
	0x000566c4 ,	0x00054230 ,	0x00057eb7 ,	0x00056032 ,
	0x00052c3b ,	0x000515a1 ,	0x00055422 ,	0x00053ef6 ,
	0x00050822 ,	0x00055991 ,	0x0005409d ,    0x00051101 ,

	0x00067f9b ,	0x000618e5 ,	0x00067485 ,	0x0006781c ,
	0x00064328 ,	0x000654fb ,	0x00062948 ,	0x00062702 ,
	0x00063623 ,	0x00064744 ,	0x00061209 ,	0x00064a32 ,
	0x00065f7d ,	0x000610b5 ,	0x00066a73 ,	0x000612f6 ,
	0x00063e6b ,	0x00063a85 ,	0x00064277 ,	0x00060ecf ,
	0x00063274 ,	0x00064ded ,	0x00066404 ,	0x00060029 ,
	0x00064823 ,	0x000618be ,	0x00066784 ,	0x00064ae1 ,
	0x00063d6c ,	0x00062cd6 ,	0x000672ae ,	0x00066952 ,
	0x00065f90 ,	0x00061649 ,	0x00066df1 ,	0x00065af1 ,
	0x000641bb ,	0x000626e9 ,	0x000601eb ,	0x00060bb3 ,
	0x00062ea6 ,	0x000612db ,	0x0006153c ,	0x00067e87 ,
	0x0006390c ,	0x00060f3e ,	0x00060099 ,	0x00060124 ,
	0x0006305e ,	0x0006440d ,	0x0006491c ,	0x00064d06 ,
	0x00064db7 ,	0x00061547 ,	0x000654de ,	0x000639b3 ,
	0x00062d12 ,	0x0006074d ,	0x00064dc8 ,	0x00066443 ,
	0x000666bb ,	0x0006428b ,	0x000626a6 ,	0x0006701f ,
	0x00065d03 ,	0x00067a5a ,	0x0006767d ,	0x00064509 ,
	0x00061238 ,	0x00063b25 ,	0x00061e1f ,	0x00066e5d ,
	0x00061ad4 ,	0x000663cb ,	0x00066bfc ,	0x00067f96 ,
	0x00067ff5 ,	0x00064e45 ,	0x0006323b ,	0x00062213 ,
	0x0006260d ,	0x00066b89 ,	0x0006030a ,	0x0006301c ,
	0x00060bdb ,	0x000656ae ,	0x00060732 ,	0x00060120 ,
	0x0006759a ,	0x00062350 ,	0x000622ee ,	0x00064b40 ,
	0x00065878 ,	0x00066b36 ,	0x00065cfd ,	0x00063e12 ,
	0x00061a49 ,	0x00065f32 ,	0x00063bf6 ,	0x00063a9e ,
	0x0006797d ,	0x00065f49 ,	0x00060ddc ,	0x00064cad ,
	0x0006314f ,	0x00065e14 ,	0x00064df2 ,	0x00064944 ,
	0x00062e40 ,	0x00061366 ,	0x00061cd0 ,	0x0006366b ,
	0x000666c4 ,	0x00064230 ,	0x00067eb7 ,	0x00066032 ,
	0x00062c3b ,	0x000615a1 ,	0x00065422 ,	0x00063ef6 ,
	0x00060822 ,	0x00065991 ,	0x0006409d ,    0x00061101 ,

	0x00077f9b ,	0x000718e5 ,	0x00077485 ,	0x0007781c ,
	0x00074328 ,	0x000754fb ,	0x00072948 ,	0x00072702 ,
	0x00073623 ,	0x00074744 ,	0x00071209 ,	0x00074a32 ,
	0x00075f7d ,	0x000710b5 ,	0x00076a73 ,	0x000712f6 ,
	0x00073e6b ,	0x00073a85 ,	0x00074277 ,	0x00070ecf ,
	0x00073274 ,	0x00074ded ,	0x00076404 ,	0x00070029 ,
	0x00074823 ,	0x000718be ,	0x00076784 ,	0x00074ae1 ,
	0x00073d6c ,	0x00072cd6 ,	0x000772ae ,	0x00076952 ,
	0x00075f90 ,	0x00071649 ,	0x00076df1 ,	0x00075af1 ,
	0x000741bb ,	0x000726e9 ,	0x000701eb ,	0x00070bb3 ,
	0x00072ea6 ,	0x000712db ,	0x0007153c ,	0x00077e87 ,
	0x0007390c ,	0x00070f3e ,	0x00070099 ,	0x00070124 ,
	0x0007305e ,	0x0007440d ,	0x0007491c ,	0x00074d06 ,
	0x00074db7 ,	0x00071547 ,	0x000754de ,	0x000739b3 ,
	0x00072d12 ,	0x0007074d ,	0x00074dc8 ,	0x00076443 ,
	0x000766bb ,	0x0007428b ,	0x000726a6 ,	0x0007701f ,
	0x00075d03 ,	0x00077a5a ,	0x0007767d ,	0x00074509 ,
	0x00071238 ,	0x00073b25 ,	0x00071e1f ,	0x00076e5d ,
	0x00071ad4 ,	0x000763cb ,	0x00076bfc ,	0x00077f96 ,
	0x00077ff5 ,	0x00074e45 ,	0x0007323b ,	0x00072213 ,
	0x0007260d ,	0x00076b89 ,	0x0007030a ,	0x0007301c ,
	0x00070bdb ,	0x000756ae ,	0x00070732 ,	0x00070120 ,
	0x0007759a ,	0x00072350 ,	0x000722ee ,	0x00074b40 ,
	0x00075878 ,	0x00076b36 ,	0x00075cfd ,	0x00073e12 ,
	0x00071a49 ,	0x00075f32 ,	0x00073bf6 ,	0x00073a9e ,
	0x0007797d ,	0x00075f49 ,	0x00070ddc ,	0x00074cad ,
	0x0007314f ,	0x00075e14 ,	0x00074df2 ,	0x00074944 ,
	0x00072e40 ,	0x00071366 ,	0x00071cd0 ,	0x0007366b ,
	0x000766c4 ,	0x00074230 ,	0x00077eb7 ,	0x00076032 ,
	0x00072c3b ,	0x000715a1 ,	0x00075422 ,	0x00073ef6 ,
	0x00070822 ,	0x00075991 ,	0x0007409d ,    0x00071101 ,

	0x00087f9b ,	0x000818e5 ,	0x00087485 ,	0x0008781c ,
	0x00084328 ,	0x000854fb ,	0x00082948 ,	0x00082702 ,
	0x00083623 ,	0x00084744 ,	0x00081209 ,	0x00084a32 ,
	0x00085f7d ,	0x000810b5 ,	0x00086a73 ,	0x000812f6 ,
	0x00083e6b ,	0x00083a85 ,	0x00084277 ,	0x00080ecf ,
	0x00083274 ,	0x00084ded ,	0x00086404 ,	0x00080029 ,
	0x00084823 ,	0x000818be ,	0x00086784 ,	0x00084ae1 ,
	0x00083d6c ,	0x00082cd6 ,	0x000872ae ,	0x00086952 ,
	0x00085f90 ,	0x00081649 ,	0x00086df1 ,	0x00085af1 ,
	0x000841bb ,	0x000826e9 ,	0x000801eb ,	0x00080bb3 ,
	0x00082ea6 ,	0x000812db ,	0x0008153c ,	0x00087e87 ,
	0x0008390c ,	0x00080f3e ,	0x00080099 ,	0x00080124 ,
	0x0008305e ,	0x0008440d ,	0x0008491c ,	0x00084d06 ,
	0x00084db7 ,	0x00081547 ,	0x000854de ,	0x000839b3 ,
	0x00082d12 ,	0x0008074d ,	0x00084dc8 ,	0x00086443 ,
	0x000866bb ,	0x0008428b ,	0x000826a6 ,	0x0008701f ,
	0x00085d03 ,	0x00087a5a ,	0x0008767d ,	0x00084509 ,
	0x00081238 ,	0x00083b25 ,	0x00081e1f ,	0x00086e5d ,
	0x00081ad4 ,	0x000863cb ,	0x00086bfc ,	0x00087f96 ,
	0x00087ff5 ,	0x00084e45 ,	0x0008323b ,	0x00082213 ,
	0x0008260d ,	0x00086b89 ,	0x0008030a ,	0x0008301c ,
	0x00080bdb ,	0x000856ae ,	0x00080732 ,	0x00080120 ,
	0x0008759a ,	0x00082350 ,	0x000822ee ,	0x00084b40 ,
	0x00085878 ,	0x00086b36 ,	0x00085cfd ,	0x00083e12 ,
	0x00081a49 ,	0x00085f32 ,	0x00083bf6 ,	0x00083a9e ,
	0x0008797d ,	0x00085f49 ,	0x00080ddc ,	0x00084cad ,
	0x0008314f ,	0x00085e14 ,	0x00084df2 ,	0x00084944 ,
	0x00082e40 ,	0x00081366 ,	0x00081cd0 ,	0x0008366b ,
	0x000866c4 ,	0x00084230 ,	0x00087eb7 ,	0x00086032 ,
	0x00082c3b ,	0x000815a1 ,	0x00085422 ,	0x00083ef6 ,
	0x00080822 ,	0x00085991 ,	0x0008409d ,    0x00081101 ,

	0x00097f9b ,	0x000918e5 ,	0x00097485 ,	0x0009781c ,
	0x00094328 ,	0x000954fb ,	0x00092948 ,	0x00092702 ,
	0x00093623 ,	0x00094744 ,	0x00091209 ,	0x00094a32 ,
	0x00095f7d ,	0x000910b5 ,	0x00096a73 ,	0x000912f6 ,
	0x00093e6b ,	0x00093a85 ,	0x00094277 ,	0x00090ecf ,
	0x00093274 ,	0x00094ded ,	0x00096404 ,	0x00090029 ,
	0x00094823 ,	0x000918be ,	0x00096784 ,	0x00094ae1 ,
	0x00093d6c ,	0x00092cd6 ,	0x000972ae ,	0x00096952 ,
	0x00095f90 ,	0x00091649 ,	0x00096df1 ,	0x00095af1 ,
	0x000941bb ,	0x000926e9 ,	0x000901eb ,	0x00090bb3 ,
	0x00092ea6 ,	0x000912db ,	0x0009153c ,	0x00097e87 ,
	0x0009390c ,	0x00090f3e ,	0x00090099 ,	0x00090124 ,
	0x0009305e ,	0x0009440d ,	0x0009491c ,	0x00094d06 ,
	0x00094db7 ,	0x00091547 ,	0x000954de ,	0x000939b3 ,
	0x00092d12 ,	0x0009074d ,	0x00094dc8 ,	0x00096443 ,
	0x000966bb ,	0x0009428b ,	0x000926a6 ,	0x0009701f ,
	0x00095d03 ,	0x00097a5a ,	0x0009767d ,	0x00094509 ,
	0x00091238 ,	0x00093b25 ,	0x00091e1f ,	0x00096e5d ,
	0x00091ad4 ,	0x000963cb ,	0x00096bfc ,	0x00097f96 ,
	0x00097ff5 ,	0x00094e45 ,	0x0009323b ,	0x00092213 ,
	0x0009260d ,	0x00096b89 ,	0x0009030a ,	0x0009301c ,
	0x00090bdb ,	0x000956ae ,	0x00090732 ,	0x00090120 ,
	0x0009759a ,	0x00092350 ,	0x000922ee ,	0x00094b40 ,
	0x00095878 ,	0x00096b36 ,	0x00095cfd ,	0x00093e12 ,
	0x00091a49 ,	0x00095f32 ,	0x00093bf6 ,	0x00093a9e ,
	0x0009797d ,	0x00095f49 ,	0x00090ddc ,	0x00094cad ,
	0x0009314f ,	0x00095e14 ,	0x00094df2 ,	0x00094944 ,
	0x00092e40 ,	0x00091366 ,	0x00091cd0 ,	0x0009366b ,
	0x000966c4 ,	0x00094230 ,	0x00097eb7 ,	0x00096032 ,
	0x00092c3b ,	0x000915a1 ,	0x00095422 ,	0x00093ef6 ,
	0x00090822 ,	0x00095991 ,	0x0009409d ,    0x00091101 ,

	0x00107f9b ,	0x001018e5 ,	0x00107485 ,	0x0010781c ,
	0x00104328 ,	0x001054fb ,	0x00102948 ,	0x00102702 ,
	0x00103623 ,	0x00104744 ,	0x00101209 ,	0x00104a32 ,
	0x00105f7d ,	0x001010b5 ,	0x00106a73 ,	0x001012f6 ,
	0x00103e6b ,	0x00103a85 ,	0x00104277 ,	0x00100ecf ,
	0x00103274 ,	0x00104ded ,	0x00106404 ,	0x00100029 ,
	0x00104823 ,	0x001018be ,	0x00106784 ,	0x00104ae1 ,
	0x00103d6c ,	0x00102cd6 ,	0x001072ae ,	0x00106952 ,
	0x00105f90 ,	0x00101649 ,	0x00106df1 ,	0x00105af1 ,
	0x001041bb ,	0x001026e9 ,	0x001001eb ,	0x00100bb3 ,
	0x00102ea6 ,	0x001012db ,	0x0010153c ,	0x00107e87 ,
	0x0010390c ,	0x00100f3e ,	0x00100099 ,	0x00100124 ,
	0x0010305e ,	0x0010440d ,	0x0010491c ,	0x00104d06 ,
	0x00104db7 ,	0x00101547 ,	0x001054de ,	0x001039b3 ,
	0x00102d12 ,	0x0010074d ,	0x00104dc8 ,	0x00106443 ,
	0x001066bb ,	0x0010428b ,	0x001026a6 ,	0x0010701f ,
	0x00105d03 ,	0x00107a5a ,	0x0010767d ,	0x00104509 ,
	0x00101238 ,	0x00103b25 ,	0x00101e1f ,	0x00106e5d ,
	0x00101ad4 ,	0x001063cb ,	0x00106bfc ,	0x00107f96 ,
	0x00107ff5 ,	0x00104e45 ,	0x0010323b ,	0x00102213 ,
	0x0010260d ,	0x00106b89 ,	0x0010030a ,	0x0010301c ,
	0x00100bdb ,	0x001056ae ,	0x00100732 ,	0x00100120 ,
	0x0010759a ,	0x00102350 ,	0x001022ee ,	0x00104b40 ,
	0x00105878 ,	0x00106b36 ,	0x00105cfd ,	0x00103e12 ,
	0x00101a49 ,	0x00105f32 ,	0x00103bf6 ,	0x00103a9e ,
	0x0010797d ,	0x00105f49 ,	0x00100ddc ,	0x00104cad ,
	0x0010314f ,	0x00105e14 ,	0x00104df2 ,	0x00104944 ,
	0x00102e40 ,	0x00101366 ,	0x00101cd0 ,	0x0010366b ,
	0x001066c4 ,	0x00104230 ,	0x00107eb7 ,	0x00106032 ,
	0x00102c3b ,	0x001015a1 ,	0x00105422 ,	0x00103ef6 ,
	0x00100822 ,	0x00105991 ,	0x0010409d ,    0x00101101 ,

	0x00117f9b ,	0x001118e5 ,	0x00117485 ,	0x0011781c ,
	0x00114328 ,	0x001154fb ,	0x00112948 ,	0x00112702 ,
	0x00113623 ,	0x00114744 ,	0x00111209 ,	0x00114a32 ,
	0x00115f7d ,	0x001110b5 ,	0x00116a73 ,	0x001112f6 ,
	0x00113e6b ,	0x00113a85 ,	0x00114277 ,	0x00110ecf ,
	0x00113274 ,	0x00114ded ,	0x00116404 ,	0x00110029 ,
	0x00114823 ,	0x001118be ,	0x00116784 ,	0x00114ae1 ,
	0x00113d6c ,	0x00112cd6 ,	0x001172ae ,	0x00116952 ,
	0x00115f90 ,	0x00111649 ,	0x00116df1 ,	0x00115af1 ,
	0x001141bb ,	0x001126e9 ,	0x001101eb ,	0x00110bb3 ,
	0x00112ea6 ,	0x001112db ,	0x0011153c ,	0x00117e87 ,
	0x0011390c ,	0x00110f3e ,	0x00110099 ,	0x00110124 ,
	0x0011305e ,	0x0011440d ,	0x0011491c ,	0x00114d06 ,
	0x00114db7 ,	0x00111547 ,	0x001154de ,	0x001139b3 ,
	0x00112d12 ,	0x0011074d ,	0x00114dc8 ,	0x00116443 ,
	0x001166bb ,	0x0011428b ,	0x001126a6 ,	0x0011701f ,
	0x00115d03 ,	0x00117a5a ,	0x0011767d ,	0x00114509 ,
	0x00111238 ,	0x00113b25 ,	0x00111e1f ,	0x00116e5d ,
	0x00111ad4 ,	0x001163cb ,	0x00116bfc ,	0x00117f96 ,
	0x00117ff5 ,	0x00114e45 ,	0x0011323b ,	0x00112213 ,
	0x0011260d ,	0x00116b89 ,	0x0011030a ,	0x0011301c ,
	0x00110bdb ,	0x001156ae ,	0x00110732 ,	0x00110120 ,
	0x0011759a ,	0x00112350 ,	0x001122ee ,	0x00114b40 ,
	0x00115878 ,	0x00116b36 ,	0x00115cfd ,	0x00113e12 ,
	0x00111a49 ,	0x00115f32 ,	0x00113bf6 ,	0x00113a9e ,
	0x0011797d ,	0x00115f49 ,	0x00110ddc ,	0x00114cad ,
	0x0011314f ,	0x00115e14 ,	0x00114df2 ,	0x00114944 ,
	0x00112e40 ,	0x00111366 ,	0x00111cd0 ,	0x0011366b ,
	0x001166c4 ,	0x00114230 ,	0x00117eb7 ,	0x00116032 ,
	0x00112c3b ,	0x001115a1 ,	0x00115422 ,	0x00113ef6 ,
	0x00110822 ,	0x00115991 ,	0x0011409d ,    0x00111101 ,

	0x00127f9b ,	0x001218e5 ,	0x00127485 ,	0x0012781c ,
	0x00124328 ,	0x001254fb ,	0x00122948 ,	0x00122702 ,
	0x00123623 ,	0x00124744 ,	0x00121209 ,	0x00124a32 ,
	0x00125f7d ,	0x001210b5 ,	0x00126a73 ,	0x001212f6 ,
	0x00123e6b ,	0x00123a85 ,	0x00124277 ,	0x00120ecf ,
	0x00123274 ,	0x00124ded ,	0x00126404 ,	0x00120029 ,
	0x00124823 ,	0x001218be ,	0x00126784 ,	0x00124ae1 ,
	0x00123d6c ,	0x00122cd6 ,	0x001272ae ,	0x00126952 ,
	0x00125f90 ,	0x00121649 ,	0x00126df1 ,	0x00125af1 ,
	0x001241bb ,	0x001226e9 ,	0x001201eb ,	0x00120bb3 ,
	0x00122ea6 ,	0x001212db ,	0x0012153c ,	0x00127e87 ,
	0x0012390c ,	0x00120f3e ,	0x00120099 ,	0x00120124 ,
	0x0012305e ,	0x0012440d ,	0x0012491c ,	0x00124d06 ,
	0x00124db7 ,	0x00121547 ,	0x001254de ,	0x001239b3 ,
	0x00122d12 ,	0x0012074d ,	0x00124dc8 ,	0x00126443 ,
	0x001266bb ,	0x0012428b ,	0x001226a6 ,	0x0012701f ,
	0x00125d03 ,	0x00127a5a ,	0x0012767d ,	0x00124509 ,
	0x00121238 ,	0x00123b25 ,	0x00121e1f ,	0x00126e5d ,
	0x00121ad4 ,	0x001263cb ,	0x00126bfc ,	0x00127f96 ,
	0x00127ff5 ,	0x00124e45 ,	0x0012323b ,	0x00122213 ,
	0x0012260d ,	0x00126b89 ,	0x0012030a ,	0x0012301c ,
	0x00120bdb ,	0x001256ae ,	0x00120732 ,	0x00120120 ,
	0x0012759a ,	0x00122350 ,	0x001222ee ,	0x00124b40 ,
	0x00125878 ,	0x00126b36 ,	0x00125cfd ,	0x00123e12 ,
	0x00121a49 ,	0x00125f32 ,	0x00123bf6 ,	0x00123a9e ,
	0x0012797d ,	0x00125f49 ,	0x00120ddc ,	0x00124cad ,
	0x0012314f ,	0x00125e14 ,	0x00124df2 ,	0x00124944 ,
	0x00122e40 ,	0x00121366 ,	0x00121cd0 ,	0x0012366b ,
	0x001266c4 ,	0x00124230 ,	0x00127eb7 ,	0x00126032 ,
	0x00122c3b ,	0x001215a1 ,	0x00125422 ,	0x00123ef6 ,
	0x00120822 ,	0x00125991 ,	0x0012409d ,    0x00121101 ,

	0x00137f9b ,	0x001318e5 ,	0x00137485 ,	0x0013781c ,
	0x00134328 ,	0x001354fb ,	0x00132948 ,	0x00132702 ,
	0x00133623 ,	0x00134744 ,	0x00131209 ,	0x00134a32 ,
	0x00135f7d ,	0x001310b5 ,	0x00136a73 ,	0x001312f6 ,
	0x00133e6b ,	0x00133a85 ,	0x00134277 ,	0x00130ecf ,
	0x00133274 ,	0x00134ded ,	0x00136404 ,	0x00130029 ,
	0x00134823 ,	0x001318be ,	0x00136784 ,	0x00134ae1 ,
	0x00133d6c ,	0x00132cd6 ,	0x001372ae ,	0x00136952 ,
	0x00135f90 ,	0x00131649 ,	0x00136df1 ,	0x00135af1 ,
	0x001341bb ,	0x001326e9 ,	0x001301eb ,	0x00130bb3 ,
	0x00132ea6 ,	0x001312db ,	0x0013153c ,	0x00137e87 ,
	0x0013390c ,	0x00130f3e ,	0x00130099 ,	0x00130124 ,
	0x0013305e ,	0x0013440d ,	0x0013491c ,	0x00134d06 ,
	0x00134db7 ,	0x00131547 ,	0x001354de ,	0x001339b3 ,
	0x00132d12 ,	0x0013074d ,	0x00134dc8 ,	0x00136443 ,
	0x001366bb ,	0x0013428b ,	0x001326a6 ,	0x0013701f ,
	0x00135d03 ,	0x00137a5a ,	0x0013767d ,	0x00134509 ,
	0x00131238 ,	0x00133b25 ,	0x00131e1f ,	0x00136e5d ,
	0x00131ad4 ,	0x001363cb ,	0x00136bfc ,	0x00137f96 ,
	0x00137ff5 ,	0x00134e45 ,	0x0013323b ,	0x00132213 ,
	0x0013260d ,	0x00136b89 ,	0x0013030a ,	0x0013301c ,
	0x00130bdb ,	0x001356ae ,	0x00130732 ,	0x00130120 ,
	0x0013759a ,	0x00132350 ,	0x001322ee ,	0x00134b40 ,
	0x00135878 ,	0x00136b36 ,	0x00135cfd ,	0x00133e12 ,
	0x00131a49 ,	0x00135f32 ,	0x00133bf6 ,	0x00133a9e ,
	0x0013797d ,	0x00135f49 ,	0x00130ddc ,	0x00134cad ,
	0x0013314f ,	0x00135e14 ,	0x00134df2 ,	0x00134944 ,
	0x00132e40 ,	0x00131366 ,	0x00131cd0 ,	0x0013366b ,
	0x001366c4 ,	0x00134230 ,	0x00137eb7 ,	0x00136032 ,
	0x00132c3b ,	0x001315a1 ,	0x00135422 ,	0x00133ef6 ,
	0x00130822 ,	0x00135991 ,	0x0013409d ,    0x00131101 ,

	0x00147f9b ,	0x001418e5 ,	0x00147485 ,	0x0014781c ,
	0x00144328 ,	0x001454fb ,	0x00142948 ,	0x00142702 ,
	0x00143623 ,	0x00144744 ,	0x00141209 ,	0x00144a32 ,
	0x00145f7d ,	0x001410b5 ,	0x00146a73 ,	0x001412f6 ,
	0x00143e6b ,	0x00143a85 ,	0x00144277 ,	0x00140ecf ,
	0x00143274 ,	0x00144ded ,	0x00146404 ,	0x00140029 ,
	0x00144823 ,	0x001418be ,	0x00146784 ,	0x00144ae1 ,
	0x00143d6c ,	0x00142cd6 ,	0x001472ae ,	0x00146952 ,
	0x00145f90 ,	0x00141649 ,	0x00146df1 ,	0x00145af1 ,
	0x001441bb ,	0x001426e9 ,	0x001401eb ,	0x00140bb3 ,
	0x00142ea6 ,	0x001412db ,	0x0014153c ,	0x00147e87 ,
	0x0014390c ,	0x00140f3e ,	0x00140099 ,	0x00140124 ,
	0x0014305e ,	0x0014440d ,	0x0014491c ,	0x00144d06 ,
	0x00144db7 ,	0x00141547 ,	0x001454de ,	0x001439b3 ,
	0x00142d12 ,	0x0014074d ,	0x00144dc8 ,	0x00146443 ,
	0x001466bb ,	0x0014428b ,	0x001426a6 ,	0x0014701f ,
	0x00145d03 ,	0x00147a5a ,	0x0014767d ,	0x00144509 ,
	0x00141238 ,	0x00143b25 ,	0x00141e1f ,	0x00146e5d ,
	0x00141ad4 ,	0x001463cb ,	0x00146bfc ,	0x00147f96 ,
	0x00147ff5 ,	0x00144e45 ,	0x0014323b ,	0x00142213 ,
	0x0014260d ,	0x00146b89 ,	0x0014030a ,	0x0014301c ,
	0x00140bdb ,	0x001456ae ,	0x00140732 ,	0x00140120 ,
	0x0014759a ,	0x00142350 ,	0x001422ee ,	0x00144b40 ,
	0x00145878 ,	0x00146b36 ,	0x00145cfd ,	0x00143e12 ,
	0x00141a49 ,	0x00145f32 ,	0x00143bf6 ,	0x00143a9e ,
	0x0014797d ,	0x00145f49 ,	0x00140ddc ,	0x00144cad ,
	0x0014314f ,	0x00145e14 ,	0x00144df2 ,	0x00144944 ,
	0x00142e40 ,	0x00141366 ,	0x00141cd0 ,	0x0014366b ,
	0x001466c4 ,	0x00144230 ,	0x00147eb7 ,	0x00146032 ,
	0x00142c3b ,	0x001415a1 ,	0x00145422 ,	0x00143ef6 ,
	0x00140822 ,	0x00145991 ,	0x0014409d ,    0x00141101 ,

	0x00157f9b ,	0x001518e5 ,	0x00157485 ,	0x0015781c ,
	0x00154328 ,	0x001554fb ,	0x00152948 ,	0x00152702 ,
	0x00153623 ,	0x00154744 ,	0x00151209 ,	0x00154a32 ,
	0x00155f7d ,	0x001510b5 ,	0x00156a73 ,	0x001512f6 ,
	0x00153e6b ,	0x00153a85 ,	0x00154277 ,	0x00150ecf ,
	0x00153274 ,	0x00154ded ,	0x00156404 ,	0x00150029 ,
	0x00154823 ,	0x001518be ,	0x00156784 ,	0x00154ae1 ,
	0x00153d6c ,	0x00152cd6 ,	0x001572ae ,	0x00156952 ,
	0x00155f90 ,	0x00151649 ,	0x00156df1 ,	0x00155af1 ,
	0x001541bb ,	0x001526e9 ,	0x001501eb ,	0x00150bb3 ,
	0x00152ea6 ,	0x001512db ,	0x0015153c ,	0x00157e87 ,
	0x0015390c ,	0x00150f3e ,	0x00150099 ,	0x00150124 ,
	0x0015305e ,	0x0015440d ,	0x0015491c ,	0x00154d06 ,
	0x00154db7 ,	0x00151547 ,	0x001554de ,	0x001539b3 ,
	0x00152d12 ,	0x0015074d ,	0x00154dc8 ,	0x00156443 ,
	0x001566bb ,	0x0015428b ,	0x001526a6 ,	0x0015701f ,
	0x00155d03 ,	0x00157a5a ,	0x0015767d ,	0x00154509 ,
	0x00151238 ,	0x00153b25 ,	0x00151e1f ,	0x00156e5d ,
	0x00151ad4 ,	0x001563cb ,	0x00156bfc ,	0x00157f96 ,
	0x00157ff5 ,	0x00154e45 ,	0x0015323b ,	0x00152213 ,
	0x0015260d ,	0x00156b89 ,	0x0015030a ,	0x0015301c ,
	0x00150bdb ,	0x001556ae ,	0x00150732 ,	0x00150120 ,
	0x0015759a ,	0x00152350 ,	0x001522ee ,	0x00154b40 ,
	0x00155878 ,	0x00156b36 ,	0x00155cfd ,	0x00153e12 ,
	0x00151a49 ,	0x00155f32 ,	0x00153bf6 ,	0x00153a9e ,
	0x0015797d ,	0x00155f49 ,	0x00150ddc ,	0x00154cad ,
	0x0015314f ,	0x00155e14 ,	0x00154df2 ,	0x00154944 ,
	0x00152e40 ,	0x00151366 ,	0x00151cd0 ,	0x0015366b ,
	0x001566c4 ,	0x00154230 ,	0x00157eb7 ,	0x00156032 ,
	0x00152c3b ,	0x001515a1 ,	0x00155422 ,	0x00153ef6 ,
	0x00150822 ,	0x00155991 ,	0x0015409d ,    0x00151101 ,

	0x00167f9b ,	0x001618e5 ,	0x00167485 ,	0x0016781c ,
	0x00164328 ,	0x001654fb ,	0x00162948 ,	0x00162702 ,
	0x00163623 ,	0x00164744 ,	0x00161209 ,	0x00164a32 ,
	0x00165f7d ,	0x001610b5 ,	0x00166a73 ,	0x001612f6 ,
	0x00163e6b ,	0x00163a85 ,	0x00164277 ,	0x00160ecf ,
	0x00163274 ,	0x00164ded ,	0x00166404 ,	0x00160029 ,
	0x00164823 ,	0x001618be ,	0x00166784 ,	0x00164ae1 ,
	0x00163d6c ,	0x00162cd6 ,	0x001672ae ,	0x00166952 ,
	0x00165f90 ,	0x00161649 ,	0x00166df1 ,	0x00165af1 ,
	0x001641bb ,	0x001626e9 ,	0x001601eb ,	0x00160bb3 ,
	0x00162ea6 ,	0x001612db ,	0x0016153c ,	0x00167e87 ,
	0x0016390c ,	0x00160f3e ,	0x00160099 ,	0x00160124 ,
	0x0016305e ,	0x0016440d ,	0x0016491c ,	0x00164d06 ,
	0x00164db7 ,	0x00161547 ,	0x001654de ,	0x001639b3 ,
	0x00162d12 ,	0x0016074d ,	0x00164dc8 ,	0x00166443 ,
	0x001666bb ,	0x0016428b ,	0x001626a6 ,	0x0016701f ,
	0x00165d03 ,	0x00167a5a ,	0x0016767d ,	0x00164509 ,
	0x00161238 ,	0x00163b25 ,	0x00161e1f ,	0x00166e5d ,
	0x00161ad4 ,	0x001663cb ,	0x00166bfc ,	0x00167f96 ,
	0x00167ff5 ,	0x00164e45 ,	0x0016323b ,	0x00162213 ,
	0x0016260d ,	0x00166b89 ,	0x0016030a ,	0x0016301c ,
	0x00160bdb ,	0x001656ae ,	0x00160732 ,	0x00160120 ,
	0x0016759a ,	0x00162350 ,	0x001622ee ,	0x00164b40 ,
	0x00165878 ,	0x00166b36 ,	0x00165cfd ,	0x00163e12 ,
	0x00161a49 ,	0x00165f32 ,	0x00163bf6 ,	0x00163a9e ,
	0x0016797d ,	0x00165f49 ,	0x00160ddc ,	0x00164cad ,
	0x0016314f ,	0x00165e14 ,	0x00164df2 ,	0x00164944 ,
	0x00162e40 ,	0x00161366 ,	0x00161cd0 ,	0x0016366b ,
	0x001666c4 ,	0x00164230 ,	0x00167eb7 ,	0x00166032 ,
	0x00162c3b ,	0x001615a1 ,	0x00165422 ,	0x00163ef6 ,
	0x00160822 ,	0x00165991 ,	0x0016409d ,    0x00161101 ,

	0x00177f9b ,	0x001718e5 ,	0x00177485 ,	0x0017781c ,
	0x00174328 ,	0x001754fb ,	0x00172948 ,	0x00172702 ,
	0x00173623 ,	0x00174744 ,	0x00171209 ,	0x00174a32 ,
	0x00175f7d ,	0x001710b5 ,	0x00176a73 ,	0x001712f6 ,
	0x00173e6b ,	0x00173a85 ,	0x00174277 ,	0x00170ecf ,
	0x00173274 ,	0x00174ded ,	0x00176404 ,	0x00170029 ,
	0x00174823 ,	0x001718be ,	0x00176784 ,	0x00174ae1 ,
	0x00173d6c ,	0x00172cd6 ,	0x001772ae ,	0x00176952 ,
	0x00175f90 ,	0x00171649 ,	0x00176df1 ,	0x00175af1 ,
	0x001741bb ,	0x001726e9 ,	0x001701eb ,	0x00170bb3 ,
	0x00172ea6 ,	0x001712db ,	0x0017153c ,	0x00177e87 ,
	0x0017390c ,	0x00170f3e ,	0x00170099 ,	0x00170124 ,
	0x0017305e ,	0x0017440d ,	0x0017491c ,	0x00174d06 ,
	0x00174db7 ,	0x00171547 ,	0x001754de ,	0x001739b3 ,
	0x00172d12 ,	0x0017074d ,	0x00174dc8 ,	0x00176443 ,
	0x001766bb ,	0x0017428b ,	0x001726a6 ,	0x0017701f ,
	0x00175d03 ,	0x00177a5a ,	0x0017767d ,	0x00174509 ,
	0x00171238 ,	0x00173b25 ,	0x00171e1f ,	0x00176e5d ,
	0x00171ad4 ,	0x001763cb ,	0x00176bfc ,	0x00177f96 ,
	0x00177ff5 ,	0x00174e45 ,	0x0017323b ,	0x00172213 ,
	0x0017260d ,	0x00176b89 ,	0x0017030a ,	0x0017301c ,
	0x00170bdb ,	0x001756ae ,	0x00170732 ,	0x00170120 ,
	0x0017759a ,	0x00172350 ,	0x001722ee ,	0x00174b40 ,
	0x00175878 ,	0x00176b36 ,	0x00175cfd ,	0x00173e12 ,
	0x00171a49 ,	0x00175f32 ,	0x00173bf6 ,	0x00173a9e ,
	0x0017797d ,	0x00175f49 ,	0x00170ddc ,	0x00174cad ,
	0x0017314f ,	0x00175e14 ,	0x00174df2 ,	0x00174944 ,
	0x00172e40 ,	0x00171366 ,	0x00171cd0 ,	0x0017366b ,
	0x001766c4 ,	0x00174230 ,	0x00177eb7 ,	0x00176032 ,
	0x00172c3b ,	0x001715a1 ,	0x00175422 ,	0x00173ef6 ,
	0x00170822 ,	0x00175991 ,	0x0017409d ,    0x00171101 ,

	0x00187f9b ,	0x001818e5 ,	0x00187485 ,	0x0018781c ,
	0x00184328 ,	0x001854fb ,	0x00182948 ,	0x00182702 ,
	0x00183623 ,	0x00184744 ,	0x00181209 ,	0x00184a32 ,
	0x00185f7d ,	0x001810b5 ,	0x00186a73 ,	0x001812f6 ,
	0x00183e6b ,	0x00183a85 ,	0x00184277 ,	0x00180ecf ,
	0x00183274 ,	0x00184ded ,	0x00186404 ,	0x00180029 ,
	0x00184823 ,	0x001818be ,	0x00186784 ,	0x00184ae1 ,
	0x00183d6c ,	0x00182cd6 ,	0x001872ae ,	0x00186952 ,
	0x00185f90 ,	0x00181649 ,	0x00186df1 ,	0x00185af1 ,
	0x001841bb ,	0x001826e9 ,	0x001801eb ,	0x00180bb3 ,
	0x00182ea6 ,	0x001812db ,	0x0018153c ,	0x00187e87 ,
	0x0018390c ,	0x00180f3e ,	0x00180099 ,	0x00180124 ,
	0x0018305e ,	0x0018440d ,	0x0018491c ,	0x00184d06 ,
	0x00184db7 ,	0x00181547 ,	0x001854de ,	0x001839b3 ,
	0x00182d12 ,	0x0018074d ,	0x00184dc8 ,	0x00186443 ,
	0x001866bb ,	0x0018428b ,	0x001826a6 ,	0x0018701f ,
	0x00185d03 ,	0x00187a5a ,	0x0018767d ,	0x00184509 ,
	0x00181238 ,	0x00183b25 ,	0x00181e1f ,	0x00186e5d ,
	0x00181ad4 ,	0x001863cb ,	0x00186bfc ,	0x00187f96 ,
	0x00187ff5 ,	0x00184e45 ,	0x0018323b ,	0x00182213 ,
	0x0018260d ,	0x00186b89 ,	0x0018030a ,	0x0018301c ,
	0x00180bdb ,	0x001856ae ,	0x00180732 ,	0x00180120 ,
	0x0018759a ,	0x00182350 ,	0x001822ee ,	0x00184b40 ,
	0x00185878 ,	0x00186b36 ,	0x00185cfd ,	0x00183e12 ,
	0x00181a49 ,	0x00185f32 ,	0x00183bf6 ,	0x00183a9e ,
	0x0018797d ,	0x00185f49 ,	0x00180ddc ,	0x00184cad ,
	0x0018314f ,	0x00185e14 ,	0x00184df2 ,	0x00184944 ,
	0x00182e40 ,	0x00181366 ,	0x00181cd0 ,	0x0018366b ,
	0x001866c4 ,	0x00184230 ,	0x00187eb7 ,	0x00186032 ,
	0x00182c3b ,	0x001815a1 ,	0x00185422 ,	0x00183ef6 ,
	0x00180822 ,	0x00185991 ,	0x0018409d ,    0x00181101 ,

	0x00197f9b ,	0x001918e5 ,	0x00197485 ,	0x0019781c ,
	0x00194328 ,	0x001954fb ,	0x00192948 ,	0x00192702 ,
	0x00193623 ,	0x00194744 ,	0x00191209 ,	0x00194a32 ,
	0x00195f7d ,	0x001910b5 ,	0x00196a73 ,	0x001912f6 ,
	0x00193e6b ,	0x00193a85 ,	0x00194277 ,	0x00190ecf ,
	0x00193274 ,	0x00194ded ,	0x00196404 ,	0x00190029 ,
	0x00194823 ,	0x001918be ,	0x00196784 ,	0x00194ae1 ,
	0x00193d6c ,	0x00192cd6 ,	0x001972ae ,	0x00196952 ,
	0x00195f90 ,	0x00191649 ,	0x00196df1 ,	0x00195af1 ,
	0x001941bb ,	0x001926e9 ,	0x001901eb ,	0x00190bb3 ,
	0x00192ea6 ,	0x001912db ,	0x0019153c ,	0x00197e87 ,
	0x0019390c ,	0x00190f3e ,	0x00190099 ,	0x00190124 ,
	0x0019305e ,	0x0019440d ,	0x0019491c ,	0x00194d06 ,
	0x00194db7 ,	0x00191547 ,	0x001954de ,	0x001939b3 ,
	0x00192d12 ,	0x0019074d ,	0x00194dc8 ,	0x00196443 ,
	0x001966bb ,	0x0019428b ,	0x001926a6 ,	0x0019701f ,
	0x00195d03 ,	0x00197a5a ,	0x0019767d ,	0x00194509 ,
	0x00191238 ,	0x00193b25 ,	0x00191e1f ,	0x00196e5d ,
	0x00191ad4 ,	0x001963cb ,	0x00196bfc ,	0x00197f96 ,
	0x00197ff5 ,	0x00194e45 ,	0x0019323b ,	0x00192213 ,
	0x0019260d ,	0x00196b89 ,	0x0019030a ,	0x0019301c ,
	0x00190bdb ,	0x001956ae ,	0x00190732 ,	0x00190120 ,
	0x0019759a ,	0x00192350 ,	0x001922ee ,	0x00194b40 ,
	0x00195878 ,	0x00196b36 ,	0x00195cfd ,	0x00193e12 ,
	0x00191a49 ,	0x00195f32 ,	0x00193bf6 ,	0x00193a9e ,
	0x0019797d ,	0x00195f49 ,	0x00190ddc ,	0x00194cad ,
	0x0019314f ,	0x00195e14 ,	0x00194df2 ,	0x00194944 ,
	0x00192e40 ,	0x00191366 ,	0x00191cd0 ,	0x0019366b ,
	0x001966c4 ,	0x00194230 ,	0x00197eb7 ,	0x00196032 ,
	0x00192c3b ,	0x001915a1 ,	0x00195422 ,	0x00193ef6 ,
	0x00190822 ,	0x00195991 ,	0x0019409d ,    0x00191101 ,

	0x00207f9b ,	0x002018e5 ,	0x00207485 ,	0x0020781c ,
	0x00204328 ,	0x002054fb ,	0x00202948 ,	0x00202702 ,
	0x00203623 ,	0x00204744 ,	0x00201209 ,	0x00204a32 ,
	0x00205f7d ,	0x002010b5 ,	0x00206a73 ,	0x002012f6 ,
	0x00203e6b ,	0x00203a85 ,	0x00204277 ,	0x00200ecf ,
	0x00203274 ,	0x00204ded ,	0x00206404 ,	0x00200029 ,
	0x00204823 ,	0x002018be ,	0x00206784 ,	0x00204ae1 ,
	0x00203d6c ,	0x00202cd6 ,	0x002072ae ,	0x00206952 ,
	0x00205f90 ,	0x00201649 ,	0x00206df1 ,	0x00205af1 ,
	0x002041bb ,	0x002026e9 ,	0x002001eb ,	0x00200bb3 ,
	0x00202ea6 ,	0x002012db ,	0x0020153c ,	0x00207e87 ,
	0x0020390c ,	0x00200f3e ,	0x00200099 ,	0x00200124 ,
	0x0020305e ,	0x0020440d ,	0x0020491c ,	0x00204d06 ,
	0x00204db7 ,	0x00201547 ,	0x002054de ,	0x002039b3 ,
	0x00202d12 ,	0x0020074d ,	0x00204dc8 ,	0x00206443 ,
	0x002066bb ,	0x0020428b ,	0x002026a6 ,	0x0020701f ,
	0x00205d03 ,	0x00207a5a ,	0x0020767d ,	0x00204509 ,
	0x00201238 ,	0x00203b25 ,	0x00201e1f ,	0x00206e5d ,
	0x00201ad4 ,	0x002063cb ,	0x00206bfc ,	0x00207f96 ,
	0x00207ff5 ,	0x00204e45 ,	0x0020323b ,	0x00202213 ,
	0x0020260d ,	0x00206b89 ,	0x0020030a ,	0x0020301c ,
	0x00200bdb ,	0x002056ae ,	0x00200732 ,	0x00200120 ,
	0x0020759a ,	0x00202350 ,	0x002022ee ,	0x00204b40 ,
	0x00205878 ,	0x00206b36 ,	0x00205cfd ,	0x00203e12 ,
	0x00201a49 ,	0x00205f32 ,	0x00203bf6 ,	0x00203a9e ,
	0x0020797d ,	0x00205f49 ,	0x00200ddc ,	0x00204cad ,
	0x0020314f ,	0x00205e14 ,	0x00204df2 ,	0x00204944 ,
	0x00202e40 ,	0x00201366 ,	0x00201cd0 ,	0x0020366b ,
	0x002066c4 ,	0x00204230 ,	0x00207eb7 ,	0x00206032 ,
	0x00202c3b ,	0x002015a1 ,	0x00205422 ,	0x00203ef6 ,
	0x00200822 ,	0x00205991 ,	0x0020409d ,    0x00201101 ,

	0x00217f9b ,	0x002118e5 ,	0x00217485 ,	0x0021781c ,
	0x00214328 ,	0x002154fb ,	0x00212948 ,	0x00212702 ,
	0x00213623 ,	0x00214744 ,	0x00211209 ,	0x00214a32 ,
	0x00215f7d ,	0x002110b5 ,	0x00216a73 ,	0x002112f6 ,
	0x00213e6b ,	0x00213a85 ,	0x00214277 ,	0x00210ecf ,
	0x00213274 ,	0x00214ded ,	0x00216404 ,	0x00210029 ,
	0x00214823 ,	0x002118be ,	0x00216784 ,	0x00214ae1 ,
	0x00213d6c ,	0x00212cd6 ,	0x002172ae ,	0x00216952 ,
	0x00215f90 ,	0x00211649 ,	0x00216df1 ,	0x00215af1 ,
	0x002141bb ,	0x002126e9 ,	0x002101eb ,	0x00210bb3 ,
	0x00212ea6 ,	0x002112db ,	0x0021153c ,	0x00217e87 ,
	0x0021390c ,	0x00210f3e ,	0x00210099 ,	0x00210124 ,
	0x0021305e ,	0x0021440d ,	0x0021491c ,	0x00214d06 ,
	0x00214db7 ,	0x00211547 ,	0x002154de ,	0x002139b3 ,
	0x00212d12 ,	0x0021074d ,	0x00214dc8 ,	0x00216443 ,
	0x002166bb ,	0x0021428b ,	0x002126a6 ,	0x0021701f ,
	0x00215d03 ,	0x00217a5a ,	0x0021767d ,	0x00214509 ,
	0x00211238 ,	0x00213b25 ,	0x00211e1f ,	0x00216e5d ,
	0x00211ad4 ,	0x002163cb ,	0x00216bfc ,	0x00217f96 ,
	0x00217ff5 ,	0x00214e45 ,	0x0021323b ,	0x00212213 ,
	0x0021260d ,	0x00216b89 ,	0x0021030a ,	0x0021301c ,
	0x00210bdb ,	0x002156ae ,	0x00210732 ,	0x00210120 ,
	0x0021759a ,	0x00212350 ,	0x002122ee ,	0x00214b40 ,
	0x00215878 ,	0x00216b36 ,	0x00215cfd ,	0x00213e12 ,
	0x00211a49 ,	0x00215f32 ,	0x00213bf6 ,	0x00213a9e ,
	0x0021797d ,	0x00215f49 ,	0x00210ddc ,	0x00214cad ,
	0x0021314f ,	0x00215e14 ,	0x00214df2 ,	0x00214944 ,
	0x00212e40 ,	0x00211366 ,	0x00211cd0 ,	0x0021366b ,
	0x002166c4 ,	0x00214230 ,	0x00217eb7 ,	0x00216032 ,
	0x00212c3b ,	0x002115a1 ,	0x00215422 ,	0x00213ef6 ,
	0x00210822 ,	0x00215991 ,	0x0021409d ,    0x00211101 ,

	0x00227f9b ,	0x002218e5 ,	0x00227485 ,	0x0022781c ,
	0x00224328 ,	0x002254fb ,	0x00222948 ,	0x00222702 ,
	0x00223623 ,	0x00224744 ,	0x00221209 ,	0x00224a32 ,
	0x00225f7d ,	0x002210b5 ,	0x00226a73 ,	0x002212f6 ,
	0x00223e6b ,	0x00223a85 ,	0x00224277 ,	0x00220ecf ,
	0x00223274 ,	0x00224ded ,	0x00226404 ,	0x00220029 ,
	0x00224823 ,	0x002218be ,	0x00226784 ,	0x00224ae1 ,
	0x00223d6c ,	0x00222cd6 ,	0x002272ae ,	0x00226952 ,
	0x00225f90 ,	0x00221649 ,	0x00226df1 ,	0x00225af1 ,
	0x002241bb ,	0x002226e9 ,	0x002201eb ,	0x00220bb3 ,
	0x00222ea6 ,	0x002212db ,	0x0022153c ,	0x00227e87 ,
	0x0022390c ,	0x00220f3e ,	0x00220099 ,	0x00220124 ,
	0x0022305e ,	0x0022440d ,	0x0022491c ,	0x00224d06 ,
	0x00224db7 ,	0x00221547 ,	0x002254de ,	0x002239b3 ,
	0x00222d12 ,	0x0022074d ,	0x00224dc8 ,	0x00226443 ,
	0x002266bb ,	0x0022428b ,	0x002226a6 ,	0x0022701f ,
	0x00225d03 ,	0x00227a5a ,	0x0022767d ,	0x00224509 ,
	0x00221238 ,	0x00223b25 ,	0x00221e1f ,	0x00226e5d ,
	0x00221ad4 ,	0x002263cb ,	0x00226bfc ,	0x00227f96 ,
	0x00227ff5 ,	0x00224e45 ,	0x0022323b ,	0x00222213 ,
	0x0022260d ,	0x00226b89 ,	0x0022030a ,	0x0022301c ,
	0x00220bdb ,	0x002256ae ,	0x00220732 ,	0x00220120 ,
	0x0022759a ,	0x00222350 ,	0x002222ee ,	0x00224b40 ,
	0x00225878 ,	0x00226b36 ,	0x00225cfd ,	0x00223e12 ,
	0x00221a49 ,	0x00225f32 ,	0x00223bf6 ,	0x00223a9e ,
	0x0022797d ,	0x00225f49 ,	0x00220ddc ,	0x00224cad ,
	0x0022314f ,	0x00225e14 ,	0x00224df2 ,	0x00224944 ,
	0x00222e40 ,	0x00221366 ,	0x00221cd0 ,	0x0022366b ,
	0x002266c4 ,	0x00224230 ,	0x00227eb7 ,	0x00226032 ,
	0x00222c3b ,	0x002215a1 ,	0x00225422 ,	0x00223ef6 ,
	0x00220822 ,	0x00225991 ,	0x0022409d ,    0x00221101 ,

	0x00237f9b ,	0x002318e5 ,	0x00237485 ,	0x0023781c ,
	0x00234328 ,	0x002354fb ,	0x00232948 ,	0x00232702 ,
	0x00233623 ,	0x00234744 ,	0x00231209 ,	0x00234a32 ,
	0x00235f7d ,	0x002310b5 ,	0x00236a73 ,	0x002312f6 ,
	0x00233e6b ,	0x00233a85 ,	0x00234277 ,	0x00230ecf ,
	0x00233274 ,	0x00234ded ,	0x00236404 ,	0x00230029 ,
	0x00234823 ,	0x002318be ,	0x00236784 ,	0x00234ae1 ,
	0x00233d6c ,	0x00232cd6 ,	0x002372ae ,	0x00236952 ,
	0x00235f90 ,	0x00231649 ,	0x00236df1 ,	0x00235af1 ,
	0x002341bb ,	0x002326e9 ,	0x002301eb ,	0x00230bb3 ,
	0x00232ea6 ,	0x002312db ,	0x0023153c ,	0x00237e87 ,
	0x0023390c ,	0x00230f3e ,	0x00230099 ,	0x00230124 ,
	0x0023305e ,	0x0023440d ,	0x0023491c ,	0x00234d06 ,
	0x00234db7 ,	0x00231547 ,	0x002354de ,	0x002339b3 ,
	0x00232d12 ,	0x0023074d ,	0x00234dc8 ,	0x00236443 ,
	0x002366bb ,	0x0023428b ,	0x002326a6 ,	0x0023701f ,
	0x00235d03 ,	0x00237a5a ,	0x0023767d ,	0x00234509 ,
	0x00231238 ,	0x00233b25 ,	0x00231e1f ,	0x00236e5d ,
	0x00231ad4 ,	0x002363cb ,	0x00236bfc ,	0x00237f96 ,
	0x00237ff5 ,	0x00234e45 ,	0x0023323b ,	0x00232213 ,
	0x0023260d ,	0x00236b89 ,	0x0023030a ,	0x0023301c ,
	0x00230bdb ,	0x002356ae ,	0x00230732 ,	0x00230120 ,
	0x0023759a ,	0x00232350 ,	0x002322ee ,	0x00234b40 ,
	0x00235878 ,	0x00236b36 ,	0x00235cfd ,	0x00233e12 ,
	0x00231a49 ,	0x00235f32 ,	0x00233bf6 ,	0x00233a9e ,
	0x0023797d ,	0x00235f49 ,	0x00230ddc ,	0x00234cad ,
	0x0023314f ,	0x00235e14 ,	0x00234df2 ,	0x00234944 ,
	0x00232e40 ,	0x00231366 ,	0x00231cd0 ,	0x0023366b ,
	0x002366c4 ,	0x00234230 ,	0x00237eb7 ,	0x00236032 ,
	0x00232c3b ,	0x002315a1 ,	0x00235422 ,	0x00233ef6 ,
	0x00230822 ,	0x00235991 ,	0x0023409d ,    0x00231101 ,

	0x00247f9b ,	0x002418e5 ,	0x00247485 ,	0x0024781c ,
	0x00244328 ,	0x002454fb ,	0x00242948 ,	0x00242702 ,
	0x00243623 ,	0x00244744 ,	0x00241209 ,	0x00244a32 ,
	0x00245f7d ,	0x002410b5 ,	0x00246a73 ,	0x002412f6 ,
	0x00243e6b ,	0x00243a85 ,	0x00244277 ,	0x00240ecf ,
	0x00243274 ,	0x00244ded ,	0x00246404 ,	0x00240029 ,
	0x00244823 ,	0x002418be ,	0x00246784 ,	0x00244ae1 ,
	0x00243d6c ,	0x00242cd6 ,	0x002472ae ,	0x00246952 ,
	0x00245f90 ,	0x00241649 ,	0x00246df1 ,	0x00245af1 ,
	0x002441bb ,	0x002426e9 ,	0x002401eb ,	0x00240bb3 ,
	0x00242ea6 ,	0x002412db ,	0x0024153c ,	0x00247e87 ,
	0x0024390c ,	0x00240f3e ,	0x00240099 ,	0x00240124 ,
	0x0024305e ,	0x0024440d ,	0x0024491c ,	0x00244d06 ,
	0x00244db7 ,	0x00241547 ,	0x002454de ,	0x002439b3 ,
	0x00242d12 ,	0x0024074d ,	0x00244dc8 ,	0x00246443 ,
	0x002466bb ,	0x0024428b ,	0x002426a6 ,	0x0024701f ,
	0x00245d03 ,	0x00247a5a ,	0x0024767d ,	0x00244509 ,
	0x00241238 ,	0x00243b25 ,	0x00241e1f ,	0x00246e5d ,
	0x00241ad4 ,	0x002463cb ,	0x00246bfc ,	0x00247f96 ,
	0x00247ff5 ,	0x00244e45 ,	0x0024323b ,	0x00242213 ,
	0x0024260d ,	0x00246b89 ,	0x0024030a ,	0x0024301c ,
	0x00240bdb ,	0x002456ae ,	0x00240732 ,	0x00240120 ,
	0x0024759a ,	0x00242350 ,	0x002422ee ,	0x00244b40 ,
	0x00245878 ,	0x00246b36 ,	0x00245cfd ,	0x00243e12 ,
	0x00241a49 ,	0x00245f32 ,	0x00243bf6 ,	0x00243a9e ,
	0x0024797d ,	0x00245f49 ,	0x00240ddc ,	0x00244cad ,
	0x0024314f ,	0x00245e14 ,	0x00244df2 ,	0x00244944 ,
	0x00242e40 ,	0x00241366 ,	0x00241cd0 ,	0x0024366b ,
	0x002466c4 ,	0x00244230 ,	0x00247eb7 ,	0x00246032 ,
	0x00242c3b ,	0x002415a1 ,	0x00245422 ,	0x00243ef6 ,
	0x00240822 ,	0x00245991 ,	0x0024409d ,    0x00241101 ,

	0x00257f9b ,	0x002518e5 ,	0x00257485 ,	0x0025781c ,
	0x00254328 ,	0x002554fb ,	0x00252948 ,	0x00252702 ,
	0x00253623 ,	0x00254744 ,	0x00251209 ,	0x00254a32 ,
	0x00255f7d ,	0x002510b5 ,	0x00256a73 ,	0x002512f6 ,
	0x00253e6b ,	0x00253a85 ,	0x00254277 ,	0x00250ecf ,
	0x00253274 ,	0x00254ded ,	0x00256404 ,	0x00250029 ,
	0x00254823 ,	0x002518be ,	0x00256784 ,	0x00254ae1 ,
	0x00253d6c ,	0x00252cd6 ,	0x002572ae ,	0x00256952 ,
	0x00255f90 ,	0x00251649 ,	0x00256df1 ,	0x00255af1 ,
	0x002541bb ,	0x002526e9 ,	0x002501eb ,	0x00250bb3 ,
	0x00252ea6 ,	0x002512db ,	0x0025153c ,	0x00257e87 ,
	0x0025390c ,	0x00250f3e ,	0x00250099 ,	0x00250124 ,
	0x0025305e ,	0x0025440d ,	0x0025491c ,	0x00254d06 ,
	0x00254db7 ,	0x00251547 ,	0x002554de ,	0x002539b3 ,
	0x00252d12 ,	0x0025074d ,	0x00254dc8 ,	0x00256443 ,
	0x002566bb ,	0x0025428b ,	0x002526a6 ,	0x0025701f ,
	0x00255d03 ,	0x00257a5a ,	0x0025767d ,	0x00254509 ,
	0x00251238 ,	0x00253b25 ,	0x00251e1f ,	0x00256e5d ,
	0x00251ad4 ,	0x002563cb ,	0x00256bfc ,	0x00257f96 ,
	0x00257ff5 ,	0x00254e45 ,	0x0025323b ,	0x00252213 ,
	0x0025260d ,	0x00256b89 ,	0x0025030a ,	0x0025301c ,
	0x00250bdb ,	0x002556ae ,	0x00250732 ,	0x00250120 ,
	0x0025759a ,	0x00252350 ,	0x002522ee ,	0x00254b40 ,
	0x00255878 ,	0x00256b36 ,	0x00255cfd ,	0x00253e12 ,
	0x00251a49 ,	0x00255f32 ,	0x00253bf6 ,	0x00253a9e ,
	0x0025797d ,	0x00255f49 ,	0x00250ddc ,	0x00254cad ,
	0x0025314f ,	0x00255e14 ,	0x00254df2 ,	0x00254944 ,
	0x00252e40 ,	0x00251366 ,	0x00251cd0 ,	0x0025366b ,
	0x002566c4 ,	0x00254230 ,	0x00257eb7 ,	0x00256032 ,
	0x00252c3b ,	0x002515a1 ,	0x00255422 ,	0x00253ef6 ,
	0x00250822 ,	0x00255991 ,	0x0025409d ,    0x00251101 ,

	0x00267f9b ,	0x002618e5 ,	0x00267485 ,	0x0026781c ,
	0x00264328 ,	0x002654fb ,	0x00262948 ,	0x00262702 ,
	0x00263623 ,	0x00264744 ,	0x00261209 ,	0x00264a32 ,
	0x00265f7d ,	0x002610b5 ,	0x00266a73 ,	0x002612f6 ,
	0x00263e6b ,	0x00263a85 ,	0x00264277 ,	0x00260ecf ,
	0x00263274 ,	0x00264ded ,	0x00266404 ,	0x00260029 ,
	0x00264823 ,	0x002618be ,	0x00266784 ,	0x00264ae1 ,
	0x00263d6c ,	0x00262cd6 ,	0x002672ae ,	0x00266952 ,
	0x00265f90 ,	0x00261649 ,	0x00266df1 ,	0x00265af1 ,
	0x002641bb ,	0x002626e9 ,	0x002601eb ,	0x00260bb3 ,
	0x00262ea6 ,	0x002612db ,	0x0026153c ,	0x00267e87 ,
	0x0026390c ,	0x00260f3e ,	0x00260099 ,	0x00260124 ,
	0x0026305e ,	0x0026440d ,	0x0026491c ,	0x00264d06 ,
	0x00264db7 ,	0x00261547 ,	0x002654de ,	0x002639b3 ,
	0x00262d12 ,	0x0026074d ,	0x00264dc8 ,	0x00266443 ,
	0x002666bb ,	0x0026428b ,	0x002626a6 ,	0x0026701f ,
	0x00265d03 ,	0x00267a5a ,	0x0026767d ,	0x00264509 ,
	0x00261238 ,	0x00263b25 ,	0x00261e1f ,	0x00266e5d ,
	0x00261ad4 ,	0x002663cb ,	0x00266bfc ,	0x00267f96 ,
	0x00267ff5 ,	0x00264e45 ,	0x0026323b ,	0x00262213 ,
	0x0026260d ,	0x00266b89 ,	0x0026030a ,	0x0026301c ,
	0x00260bdb ,	0x002656ae ,	0x00260732 ,	0x00260120 ,
	0x0026759a ,	0x00262350 ,	0x002622ee ,	0x00264b40 ,
	0x00265878 ,	0x00266b36 ,	0x00265cfd ,	0x00263e12 ,
	0x00261a49 ,	0x00265f32 ,	0x00263bf6 ,	0x00263a9e ,
	0x0026797d ,	0x00265f49 ,	0x00260ddc ,	0x00264cad ,
	0x0026314f ,	0x00265e14 ,	0x00264df2 ,	0x00264944 ,
	0x00262e40 ,	0x00261366 ,	0x00261cd0 ,	0x0026366b ,
	0x002666c4 ,	0x00264230 ,	0x00267eb7 ,	0x00266032 ,
	0x00262c3b ,	0x002615a1 ,	0x00265422 ,	0x00263ef6 ,
	0x00260822 ,	0x00265991 ,	0x0026409d ,    0x00261101 ,

	0x00277f9b ,	0x002718e5 ,	0x00277485 ,	0x0027781c ,
	0x00274328 ,	0x002754fb ,	0x00272948 ,	0x00272702 ,
	0x00273623 ,	0x00274744 ,	0x00271209 ,	0x00274a32 ,
	0x00275f7d ,	0x002710b5 ,	0x00276a73 ,	0x002712f6 ,
	0x00273e6b ,	0x00273a85 ,	0x00274277 ,	0x00270ecf ,
	0x00273274 ,	0x00274ded ,	0x00276404 ,	0x00270029 ,
	0x00274823 ,	0x002718be ,	0x00276784 ,	0x00274ae1 ,
	0x00273d6c ,	0x00272cd6 ,	0x002772ae ,	0x00276952 ,
	0x00275f90 ,	0x00271649 ,	0x00276df1 ,	0x00275af1 ,
	0x002741bb ,	0x002726e9 ,	0x002701eb ,	0x00270bb3 ,
	0x00272ea6 ,	0x002712db ,	0x0027153c ,	0x00277e87 ,
	0x0027390c ,	0x00270f3e ,	0x00270099 ,	0x00270124 ,
	0x0027305e ,	0x0027440d ,	0x0027491c ,	0x00274d06 ,
	0x00274db7 ,	0x00271547 ,	0x002754de ,	0x002739b3 ,
	0x00272d12 ,	0x0027074d ,	0x00274dc8 ,	0x00276443 ,
	0x002766bb ,	0x0027428b ,	0x002726a6 ,	0x0027701f ,
	0x00275d03 ,	0x00277a5a ,	0x0027767d ,	0x00274509 ,
	0x00271238 ,	0x00273b25 ,	0x00271e1f ,	0x00276e5d ,
	0x00271ad4 ,	0x002763cb ,	0x00276bfc ,	0x00277f96 ,
	0x00277ff5 ,	0x00274e45 ,	0x0027323b ,	0x00272213 ,
	0x0027260d ,	0x00276b89 ,	0x0027030a ,	0x0027301c ,
	0x00270bdb ,	0x002756ae ,	0x00270732 ,	0x00270120 ,
	0x0027759a ,	0x00272350 ,	0x002722ee ,	0x00274b40 ,
	0x00275878 ,	0x00276b36 ,	0x00275cfd ,	0x00273e12 ,
	0x00271a49 ,	0x00275f32 ,	0x00273bf6 ,	0x00273a9e ,
	0x0027797d ,	0x00275f49 ,	0x00270ddc ,	0x00274cad ,
	0x0027314f ,	0x00275e14 ,	0x00274df2 ,	0x00274944 ,
	0x00272e40 ,	0x00271366 ,	0x00271cd0 ,	0x0027366b ,
	0x002766c4 ,	0x00274230 ,	0x00277eb7 ,	0x00276032 ,
	0x00272c3b ,	0x002715a1 ,	0x00275422 ,	0x00273ef6 ,
	0x00270822 ,	0x00275991 ,	0x0027409d ,    0x00271101 ,

	0x00287f9b ,	0x002818e5 ,	0x00287485 ,	0x0028781c ,
	0x00284328 ,	0x002854fb ,	0x00282948 ,	0x00282702 ,
	0x00283623 ,	0x00284744 ,	0x00281209 ,	0x00284a32 ,
	0x00285f7d ,	0x002810b5 ,	0x00286a73 ,	0x002812f6 ,
	0x00283e6b ,	0x00283a85 ,	0x00284277 ,	0x00280ecf ,
	0x00283274 ,	0x00284ded ,	0x00286404 ,	0x00280029 ,
	0x00284823 ,	0x002818be ,	0x00286784 ,	0x00284ae1 ,
	0x00283d6c ,	0x00282cd6 ,	0x002872ae ,	0x00286952 ,
	0x00285f90 ,	0x00281649 ,	0x00286df1 ,	0x00285af1 ,
	0x002841bb ,	0x002826e9 ,	0x002801eb ,	0x00280bb3 ,
	0x00282ea6 ,	0x002812db ,	0x0028153c ,	0x00287e87 ,
	0x0028390c ,	0x00280f3e ,	0x00280099 ,	0x00280124 ,
	0x0028305e ,	0x0028440d ,	0x0028491c ,	0x00284d06 ,
	0x00284db7 ,	0x00281547 ,	0x002854de ,	0x002839b3 ,
	0x00282d12 ,	0x0028074d ,	0x00284dc8 ,	0x00286443 ,
	0x002866bb ,	0x0028428b ,	0x002826a6 ,	0x0028701f ,
	0x00285d03 ,	0x00287a5a ,	0x0028767d ,	0x00284509 ,
	0x00281238 ,	0x00283b25 ,	0x00281e1f ,	0x00286e5d ,
	0x00281ad4 ,	0x002863cb ,	0x00286bfc ,	0x00287f96 ,
	0x00287ff5 ,	0x00284e45 ,	0x0028323b ,	0x00282213 ,
	0x0028260d ,	0x00286b89 ,	0x0028030a ,	0x0028301c ,
	0x00280bdb ,	0x002856ae ,	0x00280732 ,	0x00280120 ,
	0x0028759a ,	0x00282350 ,	0x002822ee ,	0x00284b40 ,
	0x00285878 ,	0x00286b36 ,	0x00285cfd ,	0x00283e12 ,
	0x00281a49 ,	0x00285f32 ,	0x00283bf6 ,	0x00283a9e ,
	0x0028797d ,	0x00285f49 ,	0x00280ddc ,	0x00284cad ,
	0x0028314f ,	0x00285e14 ,	0x00284df2 ,	0x00284944 ,
	0x00282e40 ,	0x00281366 ,	0x00281cd0 ,	0x0028366b ,
	0x002866c4 ,	0x00284230 ,	0x00287eb7 ,	0x00286032 ,
	0x00282c3b ,	0x002815a1 ,	0x00285422 ,	0x00283ef6 ,
	0x00280822 ,	0x00285991 ,	0x0028409d ,    0x00281101 ,

	0x00297f9b ,	0x002918e5 ,	0x00297485 ,	0x0029781c ,
	0x00294328 ,	0x002954fb ,	0x00292948 ,	0x00292702 ,
	0x00293623 ,	0x00294744 ,	0x00291209 ,	0x00294a32 ,
	0x00295f7d ,	0x002910b5 ,	0x00296a73 ,	0x002912f6 ,
	0x00293e6b ,	0x00293a85 ,	0x00294277 ,	0x00290ecf ,
	0x00293274 ,	0x00294ded ,	0x00296404 ,	0x00290029 ,
	0x00294823 ,	0x002918be ,	0x00296784 ,	0x00294ae1 ,
	0x00293d6c ,	0x00292cd6 ,	0x002972ae ,	0x00296952 ,
	0x00295f90 ,	0x00291649 ,	0x00296df1 ,	0x00295af1 ,
	0x002941bb ,	0x002926e9 ,	0x002901eb ,	0x00290bb3 ,
	0x00292ea6 ,	0x002912db ,	0x0029153c ,	0x00297e87 ,
	0x0029390c ,	0x00290f3e ,	0x00290099 ,	0x00290124 ,
	0x0029305e ,	0x0029440d ,	0x0029491c ,	0x00294d06 ,
	0x00294db7 ,	0x00291547 ,	0x002954de ,	0x002939b3 ,
	0x00292d12 ,	0x0029074d ,	0x00294dc8 ,	0x00296443 ,
	0x002966bb ,	0x0029428b ,	0x002926a6 ,	0x0029701f ,
	0x00295d03 ,	0x00297a5a ,	0x0029767d ,	0x00294509 ,
	0x00291238 ,	0x00293b25 ,	0x00291e1f ,	0x00296e5d ,
	0x00291ad4 ,	0x002963cb ,	0x00296bfc ,	0x00297f96 ,
	0x00297ff5 ,	0x00294e45 ,	0x0029323b ,	0x00292213 ,
	0x0029260d ,	0x00296b89 ,	0x0029030a ,	0x0029301c ,
	0x00290bdb ,	0x002956ae ,	0x00290732 ,	0x00290120 ,
	0x0029759a ,	0x00292350 ,	0x002922ee ,	0x00294b40 ,
	0x00295878 ,	0x00296b36 ,	0x00295cfd ,	0x00293e12 ,
	0x00291a49 ,	0x00295f32 ,	0x00293bf6 ,	0x00293a9e ,
	0x0029797d ,	0x00295f49 ,	0x00290ddc ,	0x00294cad ,
	0x0029314f ,	0x00295e14 ,	0x00294df2 ,	0x00294944 ,
	0x00292e40 ,	0x00291366 ,	0x00291cd0 ,	0x0029366b ,
	0x002966c4 ,	0x00294230 ,	0x00297eb7 ,	0x00296032 ,
	0x00292c3b ,	0x002915a1 ,	0x00295422 ,	0x00293ef6 ,
	0x00290822 ,	0x00295991 ,	0x0029409d ,    0x00291101 ,

	0x00307f9b ,	0x003018e5 ,	0x00307485 ,	0x0030781c ,
	0x00304328 ,	0x003054fb ,	0x00302948 ,	0x00302702 ,
	0x00303623 ,	0x00304744 ,	0x00301209 ,	0x00304a32 ,
	0x00305f7d ,	0x003010b5 ,	0x00306a73 ,	0x003012f6 ,
	0x00303e6b ,	0x00303a85 ,	0x00304277 ,	0x00300ecf ,
	0x00303274 ,	0x00304ded ,	0x00306404 ,	0x00300029 ,
	0x00304823 ,	0x003018be ,	0x00306784 ,	0x00304ae1 ,
	0x00303d6c ,	0x00302cd6 ,	0x003072ae ,	0x00306952 ,
	0x00305f90 ,	0x00301649 ,	0x00306df1 ,	0x00305af1 ,
	0x003041bb ,	0x003026e9 ,	0x003001eb ,	0x00300bb3 ,
	0x00302ea6 ,	0x003012db ,	0x0030153c ,	0x00307e87 ,
	0x0030390c ,	0x00300f3e ,	0x00300099 ,	0x00300124 ,
	0x0030305e ,	0x0030440d ,	0x0030491c ,	0x00304d06 ,
	0x00304db7 ,	0x00301547 ,	0x003054de ,	0x003039b3 ,
	0x00302d12 ,	0x0030074d ,	0x00304dc8 ,	0x00306443 ,
	0x003066bb ,	0x0030428b ,	0x003026a6 ,	0x0030701f ,
	0x00305d03 ,	0x00307a5a ,	0x0030767d ,	0x00304509 ,
	0x00301238 ,	0x00303b25 ,	0x00301e1f ,	0x00306e5d ,
	0x00301ad4 ,	0x003063cb ,	0x00306bfc ,	0x00307f96 ,
	0x00307ff5 ,	0x00304e45 ,	0x0030323b ,	0x00302213 ,
	0x0030260d ,	0x00306b89 ,	0x0030030a ,	0x0030301c ,
	0x00300bdb ,	0x003056ae ,	0x00300732 ,	0x00300120 ,
	0x0030759a ,	0x00302350 ,	0x003022ee ,	0x00304b40 ,
	0x00305878 ,	0x00306b36 ,	0x00305cfd ,	0x00303e12 ,
	0x00301a49 ,	0x00305f32 ,	0x00303bf6 ,	0x00303a9e ,
	0x0030797d ,	0x00305f49 ,	0x00300ddc ,	0x00304cad ,
	0x0030314f ,	0x00305e14 ,	0x00304df2 ,	0x00304944 ,
	0x00302e40 ,	0x00301366 ,	0x00301cd0 ,	0x0030366b ,
	0x003066c4 ,	0x00304230 ,	0x00307eb7 ,	0x00306032 ,
	0x00302c3b ,	0x003015a1 ,	0x00305422 ,	0x00303ef6 ,
	0x00300822 ,	0x00305991 ,	0x0030409d ,    0x00301101 ,

	0x00317f9b ,	0x003118e5 ,	0x00317485 ,	0x0031781c ,
	0x00314328 ,	0x003154fb ,	0x00312948 ,	0x00312702 ,
	0x00313623 ,	0x00314744 ,	0x00311209 ,	0x00314a32 ,
	0x00315f7d ,	0x003110b5 ,	0x00316a73 ,	0x003112f6 ,
	0x00313e6b ,	0x00313a85 ,	0x00314277 ,	0x00310ecf ,
	0x00313274 ,	0x00314ded ,	0x00316404 ,	0x00310029 ,
	0x00314823 ,	0x003118be ,	0x00316784 ,	0x00314ae1 ,
	0x00313d6c ,	0x00312cd6 ,	0x003172ae ,	0x00316952 ,
	0x00315f90 ,	0x00311649 ,	0x00316df1 ,	0x00315af1 ,
	0x003141bb ,	0x003126e9 ,	0x003101eb ,	0x00310bb3 ,
	0x00312ea6 ,	0x003112db ,	0x0031153c ,	0x00317e87 ,
	0x0031390c ,	0x00310f3e ,	0x00310099 ,	0x00310124 ,
	0x0031305e ,	0x0031440d ,	0x0031491c ,	0x00314d06 ,
	0x00314db7 ,	0x00311547 ,	0x003154de ,	0x003139b3 ,
	0x00312d12 ,	0x0031074d ,	0x00314dc8 ,	0x00316443 ,
	0x003166bb ,	0x0031428b ,	0x003126a6 ,	0x0031701f ,
	0x00315d03 ,	0x00317a5a ,	0x0031767d ,	0x00314509 ,
	0x00311238 ,	0x00313b25 ,	0x00311e1f ,	0x00316e5d ,
	0x00311ad4 ,	0x003163cb ,	0x00316bfc ,	0x00317f96 ,
	0x00317ff5 ,	0x00314e45 ,	0x0031323b ,	0x00312213 ,
	0x0031260d ,	0x00316b89 ,	0x0031030a ,	0x0031301c ,
	0x00310bdb ,	0x003156ae ,	0x00310732 ,	0x00310120 ,
	0x0031759a ,	0x00312350 ,	0x003122ee ,	0x00314b40 ,
	0x00315878 ,	0x00316b36 ,	0x00315cfd ,	0x00313e12 ,
	0x00311a49 ,	0x00315f32 ,	0x00313bf6 ,	0x00313a9e ,
	0x0031797d ,	0x00315f49 ,	0x00310ddc ,	0x00314cad ,
	0x0031314f ,	0x00315e14 ,	0x00314df2 ,	0x00314944 ,
	0x00312e40 ,	0x00311366 ,	0x00311cd0 ,	0x0031366b ,
	0x003166c4 ,	0x00314230 ,	0x00317eb7 ,	0x00316032 ,
	0x00312c3b ,	0x003115a1 ,	0x00315422 ,	0x00313ef6 ,
	0x00310822 ,	0x00315991 ,	0x0031409d ,    0x00311101 ,

	0x00327f9b ,	0x003218e5 ,	0x00327485 ,	0x0032781c ,
	0x00324328 ,	0x003254fb ,	0x00322948 ,	0x00322702 ,
	0x00323623 ,	0x00324744 ,	0x00321209 ,	0x00324a32 ,
	0x00325f7d ,	0x003210b5 ,	0x00326a73 ,	0x003212f6 ,
	0x00323e6b ,	0x00323a85 ,	0x00324277 ,	0x00320ecf ,
	0x00323274 ,	0x00324ded ,	0x00326404 ,	0x00320029 ,
	0x00324823 ,	0x003218be ,	0x00326784 ,	0x00324ae1 ,
	0x00323d6c ,	0x00322cd6 ,	0x003272ae ,	0x00326952 ,
	0x00325f90 ,	0x00321649 ,	0x00326df1 ,	0x00325af1 ,
	0x003241bb ,	0x003226e9 ,	0x003201eb ,	0x00320bb3 ,
	0x00322ea6 ,	0x003212db ,	0x0032153c ,	0x00327e87 ,
	0x0032390c ,	0x00320f3e ,	0x00320099 ,	0x00320124 ,
	0x0032305e ,	0x0032440d ,	0x0032491c ,	0x00324d06 ,
	0x00324db7 ,	0x00321547 ,	0x003254de ,	0x003239b3 ,
	0x00322d12 ,	0x0032074d ,	0x00324dc8 ,	0x00326443 ,
	0x003266bb ,	0x0032428b ,	0x003226a6 ,	0x0032701f ,
	0x00325d03 ,	0x00327a5a ,	0x0032767d ,	0x00324509 ,
	0x00321238 ,	0x00323b25 ,	0x00321e1f ,	0x00326e5d ,
	0x00321ad4 ,	0x003263cb ,	0x00326bfc ,	0x00327f96 ,
	0x00327ff5 ,	0x00324e45 ,	0x0032323b ,	0x00322213 ,
	0x0032260d ,	0x00326b89 ,	0x0032030a ,	0x0032301c ,
	0x00320bdb ,	0x003256ae ,	0x00320732 ,	0x00320120 ,
	0x0032759a ,	0x00322350 ,	0x003222ee ,	0x00324b40 ,
	0x00325878 ,	0x00326b36 ,	0x00325cfd ,	0x00323e12 ,
	0x00321a49 ,	0x00325f32 ,	0x00323bf6 ,	0x00323a9e ,
	0x0032797d ,	0x00325f49 ,	0x00320ddc ,	0x00324cad ,
	0x0032314f ,	0x00325e14 ,	0x00324df2 ,	0x00324944 ,
	0x00322e40 ,	0x00321366 ,	0x00321cd0 ,	0x0032366b ,
	0x003266c4 ,	0x00324230 ,	0x00327eb7 ,	0x00326032 ,
	0x00322c3b ,	0x003215a1 ,	0x00325422 ,	0x00323ef6 ,
	0x00320822 ,	0x00325991 ,	0x0032409d ,    0x00321101 ,

	0x00337f9b ,	0x003318e5 ,	0x00337485 ,	0x0033781c ,
	0x00334328 ,	0x003354fb ,	0x00332948 ,	0x00332702 ,
	0x00333623 ,	0x00334744 ,	0x00331209 ,	0x00334a32 ,
	0x00335f7d ,	0x003310b5 ,	0x00336a73 ,	0x003312f6 ,
	0x00333e6b ,	0x00333a85 ,	0x00334277 ,	0x00330ecf ,
	0x00333274 ,	0x00334ded ,	0x00336404 ,	0x00330029 ,
	0x00334823 ,	0x003318be ,	0x00336784 ,	0x00334ae1 ,
	0x00333d6c ,	0x00332cd6 ,	0x003372ae ,	0x00336952 ,
	0x00335f90 ,	0x00331649 ,	0x00336df1 ,	0x00335af1 ,
	0x003341bb ,	0x003326e9 ,	0x003301eb ,	0x00330bb3 ,
	0x00332ea6 ,	0x003312db ,	0x0033153c ,	0x00337e87 ,
	0x0033390c ,	0x00330f3e ,	0x00330099 ,	0x00330124 ,
	0x0033305e ,	0x0033440d ,	0x0033491c ,	0x00334d06 ,
	0x00334db7 ,	0x00331547 ,	0x003354de ,	0x003339b3 ,
	0x00332d12 ,	0x0033074d ,	0x00334dc8 ,	0x00336443 ,
	0x003366bb ,	0x0033428b ,	0x003326a6 ,	0x0033701f ,
	0x00335d03 ,	0x00337a5a ,	0x0033767d ,	0x00334509 ,
	0x00331238 ,	0x00333b25 ,	0x00331e1f ,	0x00336e5d ,
	0x00331ad4 ,	0x003363cb ,	0x00336bfc ,	0x00337f96 ,
	0x00337ff5 ,	0x00334e45 ,	0x0033323b ,	0x00332213 ,
	0x0033260d ,	0x00336b89 ,	0x0033030a ,	0x0033301c ,
	0x00330bdb ,	0x003356ae ,	0x00330732 ,	0x00330120 ,
	0x0033759a ,	0x00332350 ,	0x003322ee ,	0x00334b40 ,
	0x00335878 ,	0x00336b36 ,	0x00335cfd ,	0x00333e12 ,
	0x00331a49 ,	0x00335f32 ,	0x00333bf6 ,	0x00333a9e ,
	0x0033797d ,	0x00335f49 ,	0x00330ddc ,	0x00334cad ,
	0x0033314f ,	0x00335e14 ,	0x00334df2 ,	0x00334944 ,
	0x00332e40 ,	0x00331366 ,	0x00331cd0 ,	0x0033366b ,
	0x003366c4 ,	0x00334230 ,	0x00337eb7 ,	0x00336032 ,
	0x00332c3b ,	0x003315a1 ,	0x00335422 ,	0x00333ef6 ,
	0x00330822 ,	0x00335991 ,	0x0033409d ,    0x00331101 ,

	0x00347f9b ,	0x003418e5 ,	0x00347485 ,	0x0034781c ,
	0x00344328 ,	0x003454fb ,	0x00342948 ,	0x00342702 ,
	0x00343623 ,	0x00344744 ,	0x00341209 ,	0x00344a32 ,
	0x00345f7d ,	0x003410b5 ,	0x00346a73 ,	0x003412f6 ,
	0x00343e6b ,	0x00343a85 ,	0x00344277 ,	0x00340ecf ,
	0x00343274 ,	0x00344ded ,	0x00346404 ,	0x00340029 ,
	0x00344823 ,	0x003418be ,	0x00346784 ,	0x00344ae1 ,
	0x00343d6c ,	0x00342cd6 ,	0x003472ae ,	0x00346952 ,
	0x00345f90 ,	0x00341649 ,	0x00346df1 ,	0x00345af1 ,
	0x003441bb ,	0x003426e9 ,	0x003401eb ,	0x00340bb3 ,
	0x00342ea6 ,	0x003412db ,	0x0034153c ,	0x00347e87 ,
	0x0034390c ,	0x00340f3e ,	0x00340099 ,	0x00340124 ,
	0x0034305e ,	0x0034440d ,	0x0034491c ,	0x00344d06 ,
	0x00344db7 ,	0x00341547 ,	0x003454de ,	0x003439b3 ,
	0x00342d12 ,	0x0034074d ,	0x00344dc8 ,	0x00346443 ,
	0x003466bb ,	0x0034428b ,	0x003426a6 ,	0x0034701f ,
	0x00345d03 ,	0x00347a5a ,	0x0034767d ,	0x00344509 ,
	0x00341238 ,	0x00343b25 ,	0x00341e1f ,	0x00346e5d ,
	0x00341ad4 ,	0x003463cb ,	0x00346bfc ,	0x00347f96 ,
	0x00347ff5 ,	0x00344e45 ,	0x0034323b ,	0x00342213 ,
	0x0034260d ,	0x00346b89 ,	0x0034030a ,	0x0034301c ,
	0x00340bdb ,	0x003456ae ,	0x00340732 ,	0x00340120 ,
	0x0034759a ,	0x00342350 ,	0x003422ee ,	0x00344b40 ,
	0x00345878 ,	0x00346b36 ,	0x00345cfd ,	0x00343e12 ,
	0x00341a49 ,	0x00345f32 ,	0x00343bf6 ,	0x00343a9e ,
	0x0034797d ,	0x00345f49 ,	0x00340ddc ,	0x00344cad ,
	0x0034314f ,	0x00345e14 ,	0x00344df2 ,	0x00344944 ,
	0x00342e40 ,	0x00341366 ,	0x00341cd0 ,	0x0034366b ,
	0x003466c4 ,	0x00344230 ,	0x00347eb7 ,	0x00346032 ,
	0x00342c3b ,	0x003415a1 ,	0x00345422 ,	0x00343ef6 ,
	0x00340822 ,	0x00345991 ,	0x0034409d ,    0x00341101 ,

	0x00357f9b ,	0x003518e5 ,	0x00357485 ,	0x0035781c ,
	0x00354328 ,	0x003554fb ,	0x00352948 ,	0x00352702 ,
	0x00353623 ,	0x00354744 ,	0x00351209 ,	0x00354a32 ,
	0x00355f7d ,	0x003510b5 ,	0x00356a73 ,	0x003512f6 ,
	0x00353e6b ,	0x00353a85 ,	0x00354277 ,	0x00350ecf ,
	0x00353274 ,	0x00354ded ,	0x00356404 ,	0x00350029 ,
	0x00354823 ,	0x003518be ,	0x00356784 ,	0x00354ae1 ,
	0x00353d6c ,	0x00352cd6 ,	0x003572ae ,	0x00356952 ,
	0x00355f90 ,	0x00351649 ,	0x00356df1 ,	0x00355af1 ,
	0x003541bb ,	0x003526e9 ,	0x003501eb ,	0x00350bb3 ,
	0x00352ea6 ,	0x003512db ,	0x0035153c ,	0x00357e87 ,
	0x0035390c ,	0x00350f3e ,	0x00350099 ,	0x00350124 ,
	0x0035305e ,	0x0035440d ,	0x0035491c ,	0x00354d06 ,
	0x00354db7 ,	0x00351547 ,	0x003554de ,	0x003539b3 ,
	0x00352d12 ,	0x0035074d ,	0x00354dc8 ,	0x00356443 ,
	0x003566bb ,	0x0035428b ,	0x003526a6 ,	0x0035701f ,
	0x00355d03 ,	0x00357a5a ,	0x0035767d ,	0x00354509 ,
	0x00351238 ,	0x00353b25 ,	0x00351e1f ,	0x00356e5d ,
	0x00351ad4 ,	0x003563cb ,	0x00356bfc ,	0x00357f96 ,
	0x00357ff5 ,	0x00354e45 ,	0x0035323b ,	0x00352213 ,
	0x0035260d ,	0x00356b89 ,	0x0035030a ,	0x0035301c ,
	0x00350bdb ,	0x003556ae ,	0x00350732 ,	0x00350120 ,
	0x0035759a ,	0x00352350 ,	0x003522ee ,	0x00354b40 ,
	0x00355878 ,	0x00356b36 ,	0x00355cfd ,	0x00353e12 ,
	0x00351a49 ,	0x00355f32 ,	0x00353bf6 ,	0x00353a9e ,
	0x0035797d ,	0x00355f49 ,	0x00350ddc ,	0x00354cad ,
	0x0035314f ,	0x00355e14 ,	0x00354df2 ,	0x00354944 ,
	0x00352e40 ,	0x00351366 ,	0x00351cd0 ,	0x0035366b ,
	0x003566c4 ,	0x00354230 ,	0x00357eb7 ,	0x00356032 ,
	0x00352c3b ,	0x003515a1 ,	0x00355422 ,	0x00353ef6 ,
	0x00350822 ,	0x00355991 ,	0x0035409d ,    0x00351101 ,

	0x00367f9b ,	0x003618e5 ,	0x00367485 ,	0x0036781c ,
	0x00364328 ,	0x003654fb ,	0x00362948 ,	0x00362702 ,
	0x00363623 ,	0x00364744 ,	0x00361209 ,	0x00364a32 ,
	0x00365f7d ,	0x003610b5 ,	0x00366a73 ,	0x003612f6 ,
	0x00363e6b ,	0x00363a85 ,	0x00364277 ,	0x00360ecf ,
	0x00363274 ,	0x00364ded ,	0x00366404 ,	0x00360029 ,
	0x00364823 ,	0x003618be ,	0x00366784 ,	0x00364ae1 ,
	0x00363d6c ,	0x00362cd6 ,	0x003672ae ,	0x00366952 ,
	0x00365f90 ,	0x00361649 ,	0x00366df1 ,	0x00365af1 ,
	0x003641bb ,	0x003626e9 ,	0x003601eb ,	0x00360bb3 ,
	0x00362ea6 ,	0x003612db ,	0x0036153c ,	0x00367e87 ,
	0x0036390c ,	0x00360f3e ,	0x00360099 ,	0x00360124 ,
	0x0036305e ,	0x0036440d ,	0x0036491c ,	0x00364d06 ,
	0x00364db7 ,	0x00361547 ,	0x003654de ,	0x003639b3 ,
	0x00362d12 ,	0x0036074d ,	0x00364dc8 ,	0x00366443 ,
	0x003666bb ,	0x0036428b ,	0x003626a6 ,	0x0036701f ,
	0x00365d03 ,	0x00367a5a ,	0x0036767d ,	0x00364509 ,
	0x00361238 ,	0x00363b25 ,	0x00361e1f ,	0x00366e5d ,
	0x00361ad4 ,	0x003663cb ,	0x00366bfc ,	0x00367f96 ,
	0x00367ff5 ,	0x00364e45 ,	0x0036323b ,	0x00362213 ,
	0x0036260d ,	0x00366b89 ,	0x0036030a ,	0x0036301c ,
	0x00360bdb ,	0x003656ae ,	0x00360732 ,	0x00360120 ,
	0x0036759a ,	0x00362350 ,	0x003622ee ,	0x00364b40 ,
	0x00365878 ,	0x00366b36 ,	0x00365cfd ,	0x00363e12 ,
	0x00361a49 ,	0x00365f32 ,	0x00363bf6 ,	0x00363a9e ,
	0x0036797d ,	0x00365f49 ,	0x00360ddc ,	0x00364cad ,
	0x0036314f ,	0x00365e14 ,	0x00364df2 ,	0x00364944 ,
	0x00362e40 ,	0x00361366 ,	0x00361cd0 ,	0x0036366b ,
	0x003666c4 ,	0x00364230 ,	0x00367eb7 ,	0x00366032 ,
	0x00362c3b ,	0x003615a1 ,	0x00365422 ,	0x00363ef6 ,
	0x00360822 ,	0x00365991 ,	0x0036409d ,    0x00361101 ,

	0x00377f9b ,	0x003718e5 ,	0x00377485 ,	0x0037781c ,
	0x00374328 ,	0x003754fb ,	0x00372948 ,	0x00372702 ,
	0x00373623 ,	0x00374744 ,	0x00371209 ,	0x00374a32 ,
	0x00375f7d ,	0x003710b5 ,	0x00376a73 ,	0x003712f6 ,
	0x00373e6b ,	0x00373a85 ,	0x00374277 ,	0x00370ecf ,
	0x00373274 ,	0x00374ded ,	0x00376404 ,	0x00370029 ,
	0x00374823 ,	0x003718be ,	0x00376784 ,	0x00374ae1 ,
	0x00373d6c ,	0x00372cd6 ,	0x003772ae ,	0x00376952 ,
	0x00375f90 ,	0x00371649 ,	0x00376df1 ,	0x00375af1 ,
	0x003741bb ,	0x003726e9 ,	0x003701eb ,	0x00370bb3 ,
	0x00372ea6 ,	0x003712db ,	0x0037153c ,	0x00377e87 ,
	0x0037390c ,	0x00370f3e ,	0x00370099 ,	0x00370124 ,
	0x0037305e ,	0x0037440d ,	0x0037491c ,	0x00374d06 ,
	0x00374db7 ,	0x00371547 ,	0x003754de ,	0x003739b3 ,
	0x00372d12 ,	0x0037074d ,	0x00374dc8 ,	0x00376443 ,
	0x003766bb ,	0x0037428b ,	0x003726a6 ,	0x0037701f ,
	0x00375d03 ,	0x00377a5a ,	0x0037767d ,	0x00374509 ,
	0x00371238 ,	0x00373b25 ,	0x00371e1f ,	0x00376e5d ,
	0x00371ad4 ,	0x003763cb ,	0x00376bfc ,	0x00377f96 ,
	0x00377ff5 ,	0x00374e45 ,	0x0037323b ,	0x00372213 ,
	0x0037260d ,	0x00376b89 ,	0x0037030a ,	0x0037301c ,
	0x00370bdb ,	0x003756ae ,	0x00370732 ,	0x00370120 ,
	0x0037759a ,	0x00372350 ,	0x003722ee ,	0x00374b40 ,
	0x00375878 ,	0x00376b36 ,	0x00375cfd ,	0x00373e12 ,
	0x00371a49 ,	0x00375f32 ,	0x00373bf6 ,	0x00373a9e ,
	0x0037797d ,	0x00375f49 ,	0x00370ddc ,	0x00374cad ,
	0x0037314f ,	0x00375e14 ,	0x00374df2 ,	0x00374944 ,
	0x00372e40 ,	0x00371366 ,	0x00371cd0 ,	0x0037366b ,
	0x003766c4 ,	0x00374230 ,	0x00377eb7 ,	0x00376032 ,
	0x00372c3b ,	0x003715a1 ,	0x00375422 ,	0x00373ef6 ,
	0x00370822 ,	0x00375991 ,	0x0037409d ,    0x00371101 ,

	0x00387f9b ,	0x003818e5 ,	0x00387485 ,	0x0038781c ,
	0x00384328 ,	0x003854fb ,	0x00382948 ,	0x00382702 ,
	0x00383623 ,	0x00384744 ,	0x00381209 ,	0x00384a32 ,
	0x00385f7d ,	0x003810b5 ,	0x00386a73 ,	0x003812f6 ,
	0x00383e6b ,	0x00383a85 ,	0x00384277 ,	0x00380ecf ,
	0x00383274 ,	0x00384ded ,	0x00386404 ,	0x00380029 ,
	0x00384823 ,	0x003818be ,	0x00386784 ,	0x00384ae1 ,
	0x00383d6c ,	0x00382cd6 ,	0x003872ae ,	0x00386952 ,
	0x00385f90 ,	0x00381649 ,	0x00386df1 ,	0x00385af1 ,
	0x003841bb ,	0x003826e9 ,	0x003801eb ,	0x00380bb3 ,
	0x00382ea6 ,	0x003812db ,	0x0038153c ,	0x00387e87 ,
	0x0038390c ,	0x00380f3e ,	0x00380099 ,	0x00380124 ,
	0x0038305e ,	0x0038440d ,	0x0038491c ,	0x00384d06 ,
	0x00384db7 ,	0x00381547 ,	0x003854de ,	0x003839b3 ,
	0x00382d12 ,	0x0038074d ,	0x00384dc8 ,	0x00386443 ,
	0x003866bb ,	0x0038428b ,	0x003826a6 ,	0x0038701f ,
	0x00385d03 ,	0x00387a5a ,	0x0038767d ,	0x00384509 ,
	0x00381238 ,	0x00383b25 ,	0x00381e1f ,	0x00386e5d ,
	0x00381ad4 ,	0x003863cb ,	0x00386bfc ,	0x00387f96 ,
	0x00387ff5 ,	0x00384e45 ,	0x0038323b ,	0x00382213 ,
	0x0038260d ,	0x00386b89 ,	0x0038030a ,	0x0038301c ,
	0x00380bdb ,	0x003856ae ,	0x00380732 ,	0x00380120 ,
	0x0038759a ,	0x00382350 ,	0x003822ee ,	0x00384b40 ,
	0x00385878 ,	0x00386b36 ,	0x00385cfd ,	0x00383e12 ,
	0x00381a49 ,	0x00385f32 ,	0x00383bf6 ,	0x00383a9e ,
	0x0038797d ,	0x00385f49 ,	0x00380ddc ,	0x00384cad ,
	0x0038314f ,	0x00385e14 ,	0x00384df2 ,	0x00384944 ,
	0x00382e40 ,	0x00381366 ,	0x00381cd0 ,	0x0038366b ,
	0x003866c4 ,	0x00384230 ,	0x00387eb7 ,	0x00386032 ,
	0x00382c3b ,	0x003815a1 ,	0x00385422 ,	0x00383ef6 ,
	0x00380822 ,	0x00385991 ,	0x0038409d ,    0x00381101 ,

	0x00397f9b ,	0x003918e5 ,	0x00397485 ,	0x0039781c ,
	0x00394328 ,	0x003954fb ,	0x00392948 ,	0x00392702 ,
	0x00393623 ,	0x00394744 ,	0x00391209 ,	0x00394a32 ,
	0x00395f7d ,	0x003910b5 ,	0x00396a73 ,	0x003912f6 ,
	0x00393e6b ,	0x00393a85 ,	0x00394277 ,	0x00390ecf ,
	0x00393274 ,	0x00394ded ,	0x00396404 ,	0x00390029 ,
	0x00394823 ,	0x003918be ,	0x00396784 ,	0x00394ae1 ,
	0x00393d6c ,	0x00392cd6 ,	0x003972ae ,	0x00396952 ,
	0x00395f90 ,	0x00391649 ,	0x00396df1 ,	0x00395af1 ,
	0x003941bb ,	0x003926e9 ,	0x003901eb ,	0x00390bb3 ,
	0x00392ea6 ,	0x003912db ,	0x0039153c ,	0x00397e87 ,
	0x0039390c ,	0x00390f3e ,	0x00390099 ,	0x00390124 ,
	0x0039305e ,	0x0039440d ,	0x0039491c ,	0x00394d06 ,
	0x00394db7 ,	0x00391547 ,	0x003954de ,	0x003939b3 ,
	0x00392d12 ,	0x0039074d ,	0x00394dc8 ,	0x00396443 ,
	0x003966bb ,	0x0039428b ,	0x003926a6 ,	0x0039701f ,
	0x00395d03 ,	0x00397a5a ,	0x0039767d ,	0x00394509 ,
	0x00391238 ,	0x00393b25 ,	0x00391e1f ,	0x00396e5d ,
	0x00391ad4 ,	0x003963cb ,	0x00396bfc ,	0x00397f96 ,
	0x00397ff5 ,	0x00394e45 ,	0x0039323b ,	0x00392213 ,
	0x0039260d ,	0x00396b89 ,	0x0039030a ,	0x0039301c ,
	0x00390bdb ,	0x003956ae ,	0x00390732 ,	0x00390120 ,
	0x0039759a ,	0x00392350 ,	0x003922ee ,	0x00394b40 ,
	0x00395878 ,	0x00396b36 ,	0x00395cfd ,	0x00393e12 ,
	0x00391a49 ,	0x00395f32 ,	0x00393bf6 ,	0x00393a9e ,
	0x0039797d ,	0x00395f49 ,	0x00390ddc ,	0x00394cad ,
	0x0039314f ,	0x00395e14 ,	0x00394df2 ,	0x00394944 ,
	0x00392e40 ,	0x00391366 ,	0x00391cd0 ,	0x0039366b ,
	0x003966c4 ,	0x00394230 ,	0x00397eb7 ,	0x00396032 ,
	0x00392c3b ,	0x003915a1 ,	0x00395422 ,	0x00393ef6 ,
	0x00390822 ,	0x00395991 ,	0x0039409d ,    0x00391101 ,

	0x00407f9b ,	0x004018e5 ,	0x00407485 ,	0x0040781c ,
	0x00404328 ,	0x004054fb ,	0x00402948 ,	0x00402702 ,
	0x00403623 ,	0x00404744 ,	0x00401209 ,	0x00404a32 ,
	0x00405f7d ,	0x004010b5 ,	0x00406a73 ,	0x004012f6 ,
	0x00403e6b ,	0x00403a85 ,	0x00404277 ,	0x00400ecf ,
	0x00403274 ,	0x00404ded ,	0x00406404 ,	0x00400029 ,
	0x00404823 ,	0x004018be ,	0x00406784 ,	0x00404ae1 ,
	0x00403d6c ,	0x00402cd6 ,	0x004072ae ,	0x00406952 ,
	0x00405f90 ,	0x00401649 ,	0x00406df1 ,	0x00405af1 ,
	0x004041bb ,	0x004026e9 ,	0x004001eb ,	0x00400bb3 ,
	0x00402ea6 ,	0x004012db ,	0x0040153c ,	0x00407e87 ,
	0x0040390c ,	0x00400f3e ,	0x00400099 ,	0x00400124 ,
	0x0040305e ,	0x0040440d ,	0x0040491c ,	0x00404d06 ,
	0x00404db7 ,	0x00401547 ,	0x004054de ,	0x004039b3 ,
	0x00402d12 ,	0x0040074d ,	0x00404dc8 ,	0x00406443 ,
	0x004066bb ,	0x0040428b ,	0x004026a6 ,	0x0040701f ,
	0x00405d03 ,	0x00407a5a ,	0x0040767d ,	0x00404509 ,
	0x00401238 ,	0x00403b25 ,	0x00401e1f ,	0x00406e5d ,
	0x00401ad4 ,	0x004063cb ,	0x00406bfc ,	0x00407f96 ,
	0x00407ff5 ,	0x00404e45 ,	0x0040323b ,	0x00402213 ,
	0x0040260d ,	0x00406b89 ,	0x0040030a ,	0x0040301c ,
	0x00400bdb ,	0x004056ae ,	0x00400732 ,	0x00400120 ,
	0x0040759a ,	0x00402350 ,	0x004022ee ,	0x00404b40 ,
	0x00405878 ,	0x00406b36 ,	0x00405cfd ,	0x00403e12 ,
	0x00401a49 ,	0x00405f32 ,	0x00403bf6 ,	0x00403a9e ,
	0x0040797d ,	0x00405f49 ,	0x00400ddc ,	0x00404cad ,
	0x0040314f ,	0x00405e14 ,	0x00404df2 ,	0x00404944 ,
	0x00402e40 ,	0x00401366 ,	0x00401cd0 ,	0x0040366b ,
	0x004066c4 ,	0x00404230 ,	0x00407eb7 ,	0x00406032 ,
	0x00402c3b ,	0x004015a1 ,	0x00405422 ,	0x00403ef6 ,
	0x00400822 ,	0x00405991 ,	0x0040409d ,    0x00401101 ,

	0x00417f9b ,	0x004118e5 ,	0x00417485 ,	0x0041781c ,
	0x00414328 ,	0x004154fb ,	0x00412948 ,	0x00412702 ,
	0x00413623 ,	0x00414744 ,	0x00411209 ,	0x00414a32 ,
	0x00415f7d ,	0x004110b5 ,	0x00416a73 ,	0x004112f6 ,
	0x00413e6b ,	0x00413a85 ,	0x00414277 ,	0x00410ecf ,
	0x00413274 ,	0x00414ded ,	0x00416404 ,	0x00410029 ,
	0x00414823 ,	0x004118be ,	0x00416784 ,	0x00414ae1 ,
	0x00413d6c ,	0x00412cd6 ,	0x004172ae ,	0x00416952 ,
	0x00415f90 ,	0x00411649 ,	0x00416df1 ,	0x00415af1 ,
	0x004141bb ,	0x004126e9 ,	0x004101eb ,	0x00410bb3 ,
	0x00412ea6 ,	0x004112db ,	0x0041153c ,	0x00417e87 ,
	0x0041390c ,	0x00410f3e ,	0x00410099 ,	0x00410124 ,
	0x0041305e ,	0x0041440d ,	0x0041491c ,	0x00414d06 ,
	0x00414db7 ,	0x00411547 ,	0x004154de ,	0x004139b3 ,
	0x00412d12 ,	0x0041074d ,	0x00414dc8 ,	0x00416443 ,
	0x004166bb ,	0x0041428b ,	0x004126a6 ,	0x0041701f ,
	0x00415d03 ,	0x00417a5a ,	0x0041767d ,	0x00414509 ,
	0x00411238 ,	0x00413b25 ,	0x00411e1f ,	0x00416e5d ,
	0x00411ad4 ,	0x004163cb ,	0x00416bfc ,	0x00417f96 ,
	0x00417ff5 ,	0x00414e45 ,	0x0041323b ,	0x00412213 ,
	0x0041260d ,	0x00416b89 ,	0x0041030a ,	0x0041301c ,
	0x00410bdb ,	0x004156ae ,	0x00410732 ,	0x00410120 ,
	0x0041759a ,	0x00412350 ,	0x004122ee ,	0x00414b40 ,
	0x00415878 ,	0x00416b36 ,	0x00415cfd ,	0x00413e12 ,
	0x00411a49 ,	0x00415f32 ,	0x00413bf6 ,	0x00413a9e ,
	0x0041797d ,	0x00415f49 ,	0x00410ddc ,	0x00414cad ,
	0x0041314f ,	0x00415e14 ,	0x00414df2 ,	0x00414944 ,
	0x00412e40 ,	0x00411366 ,	0x00411cd0 ,	0x0041366b ,
	0x004166c4 ,	0x00414230 ,	0x00417eb7 ,	0x00416032 ,
	0x00412c3b ,	0x004115a1 ,	0x00415422 ,	0x00413ef6 ,
	0x00410822 ,	0x00415991 ,	0x0041409d ,    0x00411101 ,

	0x00427f9b ,	0x004218e5 ,	0x00427485 ,	0x0042781c ,
	0x00424328 ,	0x004254fb ,	0x00422948 ,	0x00422702 ,
	0x00423623 ,	0x00424744 ,	0x00421209 ,	0x00424a32 ,
	0x00425f7d ,	0x004210b5 ,	0x00426a73 ,	0x004212f6 ,
	0x00423e6b ,	0x00423a85 ,	0x00424277 ,	0x00420ecf ,
	0x00423274 ,	0x00424ded ,	0x00426404 ,	0x00420029 ,
	0x00424823 ,	0x004218be ,	0x00426784 ,	0x00424ae1 ,
	0x00423d6c ,	0x00422cd6 ,	0x004272ae ,	0x00426952 ,
	0x00425f90 ,	0x00421649 ,	0x00426df1 ,	0x00425af1 ,
	0x004241bb ,	0x004226e9 ,	0x004201eb ,	0x00420bb3 ,
	0x00422ea6 ,	0x004212db ,	0x0042153c ,	0x00427e87 ,
	0x0042390c ,	0x00420f3e ,	0x00420099 ,	0x00420124 ,
	0x0042305e ,	0x0042440d ,	0x0042491c ,	0x00424d06 ,
	0x00424db7 ,	0x00421547 ,	0x004254de ,	0x004239b3 ,
	0x00422d12 ,	0x0042074d ,	0x00424dc8 ,	0x00426443 ,
	0x004266bb ,	0x0042428b ,	0x004226a6 ,	0x0042701f ,
	0x00425d03 ,	0x00427a5a ,	0x0042767d ,	0x00424509 ,
	0x00421238 ,	0x00423b25 ,	0x00421e1f ,	0x00426e5d ,
	0x00421ad4 ,	0x004263cb ,	0x00426bfc ,	0x00427f96 ,
	0x00427ff5 ,	0x00424e45 ,	0x0042323b ,	0x00422213 ,
	0x0042260d ,	0x00426b89 ,	0x0042030a ,	0x0042301c ,
	0x00420bdb ,	0x004256ae ,	0x00420732 ,	0x00420120 ,
	0x0042759a ,	0x00422350 ,	0x004222ee ,	0x00424b40 ,
	0x00425878 ,	0x00426b36 ,	0x00425cfd ,	0x00423e12 ,
	0x00421a49 ,	0x00425f32 ,	0x00423bf6 ,	0x00423a9e ,
	0x0042797d ,	0x00425f49 ,	0x00420ddc ,	0x00424cad ,
	0x0042314f ,	0x00425e14 ,	0x00424df2 ,	0x00424944 ,
	0x00422e40 ,	0x00421366 ,	0x00421cd0 ,	0x0042366b ,
	0x004266c4 ,	0x00424230 ,	0x00427eb7 ,	0x00426032 ,
	0x00422c3b ,	0x004215a1 ,	0x00425422 ,	0x00423ef6 ,
	0x00420822 ,	0x00425991 ,	0x0042409d ,    0x00421101 ,

	0x00437f9b ,	0x004318e5 ,	0x00437485 ,	0x0043781c ,
	0x00434328 ,	0x004354fb ,	0x00432948 ,	0x00432702 ,
	0x00433623 ,	0x00434744 ,	0x00431209 ,	0x00434a32 ,
	0x00435f7d ,	0x004310b5 ,	0x00436a73 ,	0x004312f6 ,
	0x00433e6b ,	0x00433a85 ,	0x00434277 ,	0x00430ecf ,
	0x00433274 ,	0x00434ded ,	0x00436404 ,	0x00430029 ,
	0x00434823 ,	0x004318be ,	0x00436784 ,	0x00434ae1 ,
	0x00433d6c ,	0x00432cd6 ,	0x004372ae ,	0x00436952 ,
	0x00435f90 ,	0x00431649 ,	0x00436df1 ,	0x00435af1 ,
	0x004341bb ,	0x004326e9 ,	0x004301eb ,	0x00430bb3 ,
	0x00432ea6 ,	0x004312db ,	0x0043153c ,	0x00437e87 ,
	0x0043390c ,	0x00430f3e ,	0x00430099 ,	0x00430124 ,
	0x0043305e ,	0x0043440d ,	0x0043491c ,	0x00434d06 ,
	0x00434db7 ,	0x00431547 ,	0x004354de ,	0x004339b3 ,
	0x00432d12 ,	0x0043074d ,	0x00434dc8 ,	0x00436443 ,
	0x004366bb ,	0x0043428b ,	0x004326a6 ,	0x0043701f ,
	0x00435d03 ,	0x00437a5a ,	0x0043767d ,	0x00434509 ,
	0x00431238 ,	0x00433b25 ,	0x00431e1f ,	0x00436e5d ,
	0x00431ad4 ,	0x004363cb ,	0x00436bfc ,	0x00437f96 ,
	0x00437ff5 ,	0x00434e45 ,	0x0043323b ,	0x00432213 ,
	0x0043260d ,	0x00436b89 ,	0x0043030a ,	0x0043301c ,
	0x00430bdb ,	0x004356ae ,	0x00430732 ,	0x00430120 ,
	0x0043759a ,	0x00432350 ,	0x004322ee ,	0x00434b40 ,
	0x00435878 ,	0x00436b36 ,	0x00435cfd ,	0x00433e12 ,
	0x00431a49 ,	0x00435f32 ,	0x00433bf6 ,	0x00433a9e ,
	0x0043797d ,	0x00435f49 ,	0x00430ddc ,	0x00434cad ,
	0x0043314f ,	0x00435e14 ,	0x00434df2 ,	0x00434944 ,
	0x00432e40 ,	0x00431366 ,	0x00431cd0 ,	0x0043366b ,
	0x004366c4 ,	0x00434230 ,	0x00437eb7 ,	0x00436032 ,
	0x00432c3b ,	0x004315a1 ,	0x00435422 ,	0x00433ef6 ,
	0x00430822 ,	0x00435991 ,	0x0043409d ,    0x00431101 ,

	0x00447f9b ,	0x004418e5 ,	0x00447485 ,	0x0044781c ,
	0x00444328 ,	0x004454fb ,	0x00442948 ,	0x00442702 ,
	0x00443623 ,	0x00444744 ,	0x00441209 ,	0x00444a32 ,
	0x00445f7d ,	0x004410b5 ,	0x00446a73 ,	0x004412f6 ,
	0x00443e6b ,	0x00443a85 ,	0x00444277 ,	0x00440ecf ,
	0x00443274 ,	0x00444ded ,	0x00446404 ,	0x00440029 ,
	0x00444823 ,	0x004418be ,	0x00446784 ,	0x00444ae1 ,
	0x00443d6c ,	0x00442cd6 ,	0x004472ae ,	0x00446952 ,
	0x00445f90 ,	0x00441649 ,	0x00446df1 ,	0x00445af1 ,
	0x004441bb ,	0x004426e9 ,	0x004401eb ,	0x00440bb3 ,
	0x00442ea6 ,	0x004412db ,	0x0044153c ,	0x00447e87 ,
	0x0044390c ,	0x00440f3e ,	0x00440099 ,	0x00440124 ,
	0x0044305e ,	0x0044440d ,	0x0044491c ,	0x00444d06 ,
	0x00444db7 ,	0x00441547 ,	0x004454de ,	0x004439b3 ,
	0x00442d12 ,	0x0044074d ,	0x00444dc8 ,	0x00446443 ,
	0x004466bb ,	0x0044428b ,	0x004426a6 ,	0x0044701f ,
	0x00445d03 ,	0x00447a5a ,	0x0044767d ,	0x00444509 ,
	0x00441238 ,	0x00443b25 ,	0x00441e1f ,	0x00446e5d ,
	0x00441ad4 ,	0x004463cb ,	0x00446bfc ,	0x00447f96 ,
	0x00447ff5 ,	0x00444e45 ,	0x0044323b ,	0x00442213 ,
	0x0044260d ,	0x00446b89 ,	0x0044030a ,	0x0044301c ,
	0x00440bdb ,	0x004456ae ,	0x00440732 ,	0x00440120 ,
	0x0044759a ,	0x00442350 ,	0x004422ee ,	0x00444b40 ,
	0x00445878 ,	0x00446b36 ,	0x00445cfd ,	0x00443e12 ,
	0x00441a49 ,	0x00445f32 ,	0x00443bf6 ,	0x00443a9e ,
	0x0044797d ,	0x00445f49 ,	0x00440ddc ,	0x00444cad ,
	0x0044314f ,	0x00445e14 ,	0x00444df2 ,	0x00444944 ,
	0x00442e40 ,	0x00441366 ,	0x00441cd0 ,	0x0044366b ,
	0x004466c4 ,	0x00444230 ,	0x00447eb7 ,	0x00446032 ,
	0x00442c3b ,	0x004415a1 ,	0x00445422 ,	0x00443ef6 ,
	0x00440822 ,	0x00445991 ,	0x0044409d ,    0x00441101 ,

	0x00457f9b ,	0x004518e5 ,	0x00457485 ,	0x0045781c ,
	0x00454328 ,	0x004554fb ,	0x00452948 ,	0x00452702 ,
	0x00453623 ,	0x00454744 ,	0x00451209 ,	0x00454a32 ,
	0x00455f7d ,	0x004510b5 ,	0x00456a73 ,	0x004512f6 ,
	0x00453e6b ,	0x00453a85 ,	0x00454277 ,	0x00450ecf ,
	0x00453274 ,	0x00454ded ,	0x00456404 ,	0x00450029 ,
	0x00454823 ,	0x004518be ,	0x00456784 ,	0x00454ae1 ,
	0x00453d6c ,	0x00452cd6 ,	0x004572ae ,	0x00456952 ,
	0x00455f90 ,	0x00451649 ,	0x00456df1 ,	0x00455af1 ,
	0x004541bb ,	0x004526e9 ,	0x004501eb ,	0x00450bb3 ,
	0x00452ea6 ,	0x004512db ,	0x0045153c ,	0x00457e87 ,
	0x0045390c ,	0x00450f3e ,	0x00450099 ,	0x00450124 ,
	0x0045305e ,	0x0045440d ,	0x0045491c ,	0x00454d06 ,
	0x00454db7 ,	0x00451547 ,	0x004554de ,	0x004539b3 ,
	0x00452d12 ,	0x0045074d ,	0x00454dc8 ,	0x00456443 ,
	0x004566bb ,	0x0045428b ,	0x004526a6 ,	0x0045701f ,
	0x00455d03 ,	0x00457a5a ,	0x0045767d ,	0x00454509 ,
	0x00451238 ,	0x00453b25 ,	0x00451e1f ,	0x00456e5d ,
	0x00451ad4 ,	0x004563cb ,	0x00456bfc ,	0x00457f96 ,
	0x00457ff5 ,	0x00454e45 ,	0x0045323b ,	0x00452213 ,
	0x0045260d ,	0x00456b89 ,	0x0045030a ,	0x0045301c ,
	0x00450bdb ,	0x004556ae ,	0x00450732 ,	0x00450120 ,
	0x0045759a ,	0x00452350 ,	0x004522ee ,	0x00454b40 ,
	0x00455878 ,	0x00456b36 ,	0x00455cfd ,	0x00453e12 ,
	0x00451a49 ,	0x00455f32 ,	0x00453bf6 ,	0x00453a9e ,
	0x0045797d ,	0x00455f49 ,	0x00450ddc ,	0x00454cad ,
	0x0045314f ,	0x00455e14 ,	0x00454df2 ,	0x00454944 ,
	0x00452e40 ,	0x00451366 ,	0x00451cd0 ,	0x0045366b ,
	0x004566c4 ,	0x00454230 ,	0x00457eb7 ,	0x00456032 ,
	0x00452c3b ,	0x004515a1 ,	0x00455422 ,	0x00453ef6 ,
	0x00450822 ,	0x00455991 ,	0x0045409d ,    0x00451101 ,

	0x00467f9b ,	0x004618e5 ,	0x00467485 ,	0x0046781c ,
	0x00464328 ,	0x004654fb ,	0x00462948 ,	0x00462702 ,
	0x00463623 ,	0x00464744 ,	0x00461209 ,	0x00464a32 ,
	0x00465f7d ,	0x004610b5 ,	0x00466a73 ,	0x004612f6 ,
	0x00463e6b ,	0x00463a85 ,	0x00464277 ,	0x00460ecf ,
	0x00463274 ,	0x00464ded ,	0x00466404 ,	0x00460029 ,
	0x00464823 ,	0x004618be ,	0x00466784 ,	0x00464ae1 ,
	0x00463d6c ,	0x00462cd6 ,	0x004672ae ,	0x00466952 ,
	0x00465f90 ,	0x00461649 ,	0x00466df1 ,	0x00465af1 ,
	0x004641bb ,	0x004626e9 ,	0x004601eb ,	0x00460bb3 ,
	0x00462ea6 ,	0x004612db ,	0x0046153c ,	0x00467e87 ,
	0x0046390c ,	0x00460f3e ,	0x00460099 ,	0x00460124 ,
	0x0046305e ,	0x0046440d ,	0x0046491c ,	0x00464d06 ,
	0x00464db7 ,	0x00461547 ,	0x004654de ,	0x004639b3 ,
	0x00462d12 ,	0x0046074d ,	0x00464dc8 ,	0x00466443 ,
	0x004666bb ,	0x0046428b ,	0x004626a6 ,	0x0046701f ,
	0x00465d03 ,	0x00467a5a ,	0x0046767d ,	0x00464509 ,
	0x00461238 ,	0x00463b25 ,	0x00461e1f ,	0x00466e5d ,
	0x00461ad4 ,	0x004663cb ,	0x00466bfc ,	0x00467f96 ,
	0x00467ff5 ,	0x00464e45 ,	0x0046323b ,	0x00462213 ,
	0x0046260d ,	0x00466b89 ,	0x0046030a ,	0x0046301c ,
	0x00460bdb ,	0x004656ae ,	0x00460732 ,	0x00460120 ,
	0x0046759a ,	0x00462350 ,	0x004622ee ,	0x00464b40 ,
	0x00465878 ,	0x00466b36 ,	0x00465cfd ,	0x00463e12 ,
	0x00461a49 ,	0x00465f32 ,	0x00463bf6 ,	0x00463a9e ,
	0x0046797d ,	0x00465f49 ,	0x00460ddc ,	0x00464cad ,
	0x0046314f ,	0x00465e14 ,	0x00464df2 ,	0x00464944 ,
	0x00462e40 ,	0x00461366 ,	0x00461cd0 ,	0x0046366b ,
	0x004666c4 ,	0x00464230 ,	0x00467eb7 ,	0x00466032 ,
	0x00462c3b ,	0x004615a1 ,	0x00465422 ,	0x00463ef6 ,
	0x00460822 ,	0x00465991 ,	0x0046409d ,    0x00461101 ,

	0x00477f9b ,	0x004718e5 ,	0x00477485 ,	0x0047781c ,
	0x00474328 ,	0x004754fb ,	0x00472948 ,	0x00472702 ,
	0x00473623 ,	0x00474744 ,	0x00471209 ,	0x00474a32 ,
	0x00475f7d ,	0x004710b5 ,	0x00476a73 ,	0x004712f6 ,
	0x00473e6b ,	0x00473a85 ,	0x00474277 ,	0x00470ecf ,
	0x00473274 ,	0x00474ded ,	0x00476404 ,	0x00470029 ,
	0x00474823 ,	0x004718be ,	0x00476784 ,	0x00474ae1 ,
	0x00473d6c ,	0x00472cd6 ,	0x004772ae ,	0x00476952 ,
	0x00475f90 ,	0x00471649 ,	0x00476df1 ,	0x00475af1 ,
	0x004741bb ,	0x004726e9 ,	0x004701eb ,	0x00470bb3 ,
	0x00472ea6 ,	0x004712db ,	0x0047153c ,	0x00477e87 ,
	0x0047390c ,	0x00470f3e ,	0x00470099 ,	0x00470124 ,
	0x0047305e ,	0x0047440d ,	0x0047491c ,	0x00474d06 ,
	0x00474db7 ,	0x00471547 ,	0x004754de ,	0x004739b3 ,
	0x00472d12 ,	0x0047074d ,	0x00474dc8 ,	0x00476443 ,
	0x004766bb ,	0x0047428b ,	0x004726a6 ,	0x0047701f ,
	0x00475d03 ,	0x00477a5a ,	0x0047767d ,	0x00474509 ,
	0x00471238 ,	0x00473b25 ,	0x00471e1f ,	0x00476e5d ,
	0x00471ad4 ,	0x004763cb ,	0x00476bfc ,	0x00477f96 ,
	0x00477ff5 ,	0x00474e45 ,	0x0047323b ,	0x00472213 ,
	0x0047260d ,	0x00476b89 ,	0x0047030a ,	0x0047301c ,
	0x00470bdb ,	0x004756ae ,	0x00470732 ,	0x00470120 ,
	0x0047759a ,	0x00472350 ,	0x004722ee ,	0x00474b40 ,
	0x00475878 ,	0x00476b36 ,	0x00475cfd ,	0x00473e12 ,
	0x00471a49 ,	0x00475f32 ,	0x00473bf6 ,	0x00473a9e ,
	0x0047797d ,	0x00475f49 ,	0x00470ddc ,	0x00474cad ,
	0x0047314f ,	0x00475e14 ,	0x00474df2 ,	0x00474944 ,
	0x00472e40 ,	0x00471366 ,	0x00471cd0 ,	0x0047366b ,
	0x004766c4 ,	0x00474230 ,	0x00477eb7 ,	0x00476032 ,
	0x00472c3b ,	0x004715a1 ,	0x00475422 ,	0x00473ef6 ,
	0x00470822 ,	0x00475991 ,	0x0047409d ,    0x00471101 ,

	0x00487f9b ,	0x004818e5 ,	0x00487485 ,	0x0048781c ,
	0x00484328 ,	0x004854fb ,	0x00482948 ,	0x00482702 ,
	0x00483623 ,	0x00484744 ,	0x00481209 ,	0x00484a32 ,
	0x00485f7d ,	0x004810b5 ,	0x00486a73 ,	0x004812f6 ,
	0x00483e6b ,	0x00483a85 ,	0x00484277 ,	0x00480ecf ,
	0x00483274 ,	0x00484ded ,	0x00486404 ,	0x00480029 ,
	0x00484823 ,	0x004818be ,	0x00486784 ,	0x00484ae1 ,
	0x00483d6c ,	0x00482cd6 ,	0x004872ae ,	0x00486952 ,
	0x00485f90 ,	0x00481649 ,	0x00486df1 ,	0x00485af1 ,
	0x004841bb ,	0x004826e9 ,	0x004801eb ,	0x00480bb3 ,
	0x00482ea6 ,	0x004812db ,	0x0048153c ,	0x00487e87 ,
	0x0048390c ,	0x00480f3e ,	0x00480099 ,	0x00480124 ,
	0x0048305e ,	0x0048440d ,	0x0048491c ,	0x00484d06 ,
	0x00484db7 ,	0x00481547 ,	0x004854de ,	0x004839b3 ,
	0x00482d12 ,	0x0048074d ,	0x00484dc8 ,	0x00486443 ,
	0x004866bb ,	0x0048428b ,	0x004826a6 ,	0x0048701f ,
	0x00485d03 ,	0x00487a5a ,	0x0048767d ,	0x00484509 ,
	0x00481238 ,	0x00483b25 ,	0x00481e1f ,	0x00486e5d ,
	0x00481ad4 ,	0x004863cb ,	0x00486bfc ,	0x00487f96 ,
	0x00487ff5 ,	0x00484e45 ,	0x0048323b ,	0x00482213 ,
	0x0048260d ,	0x00486b89 ,	0x0048030a ,	0x0048301c ,
	0x00480bdb ,	0x004856ae ,	0x00480732 ,	0x00480120 ,
	0x0048759a ,	0x00482350 ,	0x004822ee ,	0x00484b40 ,
	0x00485878 ,	0x00486b36 ,	0x00485cfd ,	0x00483e12 ,
	0x00481a49 ,	0x00485f32 ,	0x00483bf6 ,	0x00483a9e ,
	0x0048797d ,	0x00485f49 ,	0x00480ddc ,	0x00484cad ,
	0x0048314f ,	0x00485e14 ,	0x00484df2 ,	0x00484944 ,
	0x00482e40 ,	0x00481366 ,	0x00481cd0 ,	0x0048366b ,
	0x004866c4 ,	0x00484230 ,	0x00487eb7 ,	0x00486032 ,
	0x00482c3b ,	0x004815a1 ,	0x00485422 ,	0x00483ef6 ,
	0x00480822 ,	0x00485991 ,	0x0048409d ,    0x00481101 ,

	0x00497f9b ,	0x004918e5 ,	0x00497485 ,	0x0049781c ,
	0x00494328 ,	0x004954fb ,	0x00492948 ,	0x00492702 ,
	0x00493623 ,	0x00494744 ,	0x00491209 ,	0x00494a32 ,
	0x00495f7d ,	0x004910b5 ,	0x00496a73 ,	0x004912f6 ,
	0x00493e6b ,	0x00493a85 ,	0x00494277 ,	0x00490ecf ,
	0x00493274 ,	0x00494ded ,	0x00496404 ,	0x00490029 ,
	0x00494823 ,	0x004918be ,	0x00496784 ,	0x00494ae1 ,
	0x00493d6c ,	0x00492cd6 ,	0x004972ae ,	0x00496952 ,
	0x00495f90 ,	0x00491649 ,	0x00496df1 ,	0x00495af1 ,
	0x004941bb ,	0x004926e9 ,	0x004901eb ,	0x00490bb3 ,
	0x00492ea6 ,	0x004912db ,	0x0049153c ,	0x00497e87 ,
	0x0049390c ,	0x00490f3e ,	0x00490099 ,	0x00490124 ,
	0x0049305e ,	0x0049440d ,	0x0049491c ,	0x00494d06 ,
	0x00494db7 ,	0x00491547 ,	0x004954de ,	0x004939b3 ,
	0x00492d12 ,	0x0049074d ,	0x00494dc8 ,	0x00496443 ,
	0x004966bb ,	0x0049428b ,	0x004926a6 ,	0x0049701f ,
	0x00495d03 ,	0x00497a5a ,	0x0049767d ,	0x00494509 ,
	0x00491238 ,	0x00493b25 ,	0x00491e1f ,	0x00496e5d ,
	0x00491ad4 ,	0x004963cb ,	0x00496bfc ,	0x00497f96 ,
	0x00497ff5 ,	0x00494e45 ,	0x0049323b ,	0x00492213 ,
	0x0049260d ,	0x00496b89 ,	0x0049030a ,	0x0049301c ,
	0x00490bdb ,	0x004956ae ,	0x00490732 ,	0x00490120 ,
	0x0049759a ,	0x00492350 ,	0x004922ee ,	0x00494b40 ,
	0x00495878 ,	0x00496b36 ,	0x00495cfd ,	0x00493e12 ,
	0x00491a49 ,	0x00495f32 ,	0x00493bf6 ,	0x00493a9e ,
	0x0049797d ,	0x00495f49 ,	0x00490ddc ,	0x00494cad ,
	0x0049314f ,	0x00495e14 ,	0x00494df2 ,	0x00494944 ,
	0x00492e40 ,	0x00491366 ,	0x00491cd0 ,	0x0049366b ,
	0x004966c4 ,	0x00494230 ,	0x00497eb7 ,	0x00496032 ,
	0x00492c3b ,	0x004915a1 ,	0x00495422 ,	0x00493ef6 ,
	0x00490822 ,	0x00495991 ,	0x0049409d ,    0x00491101 ,

#endif

	0x00507f9b ,	0x005018e5 ,	0x00507485 ,	0x0050781c ,
	0x00504328 ,	0x005054fb ,	0x00502948 ,	0x00502702 ,
	0x00503623 ,	0x00504744 ,	0x00501209 ,	0x00504a32 ,
	0x00505f7d ,	0x005010b5 ,	0x00506a73 ,	0x005012f6 ,
	0x00503e6b ,	0x00503a85 ,	0x00504277 ,	0x00500ecf ,
	0x00503274 ,	0x00504ded ,	0x00506404 ,	0x00500029 ,
	0x00504823 ,	0x005018be ,	0x00506784 ,	0x00504ae1 ,
	0x00503d6c ,	0x00502cd6 ,	0x005072ae ,	0x00506952 ,
	0x00505f90 ,	0x00501649 ,	0x00506df1 ,	0x00505af1 ,
	0x005041bb ,	0x005026e9 ,	0x005001eb ,	0x00500bb3 ,
	0x00502ea6 ,	0x005012db ,	0x0050153c ,	0x00507e87 ,
	0x0050390c ,	0x00500f3e ,	0x00500099 ,	0x00500124 ,
	0x0050305e ,	0x0050440d ,	0x0050491c ,	0x00504d06 ,
	0x00504db7 ,	0x00501547 ,	0x005054de ,	0x005039b3 ,
	0x00502d12 ,	0x0050074d ,	0x00504dc8 ,	0x00506443 ,
	0x005066bb ,	0x0050428b ,	0x005026a6 ,	0x0050701f ,
	0x00505d03 ,	0x00507a5a ,	0x0050767d ,	0x00504509 ,
	0x00501238 ,	0x00503b25 ,	0x00501e1f ,	0x00506e5d ,
	0x00501ad4 ,	0x005063cb ,	0x00506bfc ,	0x00507f96 ,
	0x00507ff5 ,	0x00504e45 ,	0x0050323b ,	0x00502213 ,
	0x0050260d ,	0x00506b89 ,	0x0050030a ,	0x0050301c ,
	0x00500bdb ,	0x005056ae ,	0x00500732 ,	0x00500120 ,
	0x0050759a ,	0x00502350 ,	0x005022ee ,	0x00504b40 ,
	0x00505878 ,	0x00506b36 ,	0x00505cfd ,	0x00503e12 ,
	0x00501a49 ,	0x00505f32 ,	0x00503bf6 ,	0x00503a9e ,
	0x0050797d ,	0x00505f49 ,	0x00500ddc ,	0x00504cad ,
	0x0050314f ,	0x00505e14 ,	0x00504df2 ,	0x00504944 ,
	0x00502e40 ,	0x00501366 ,	0x00501cd0 ,	0x0050366b ,
	0x005066c4 ,	0x00504230 ,	0x00507eb7 ,	0x00506032 ,
	0x00502c3b ,	0x005015a1 ,	0x00505422 ,	0x00503ef6 ,
	0x00500822 ,	0x00505991 ,	0x0050409d ,    0x00501101 ,

	0x00517f9b ,	0x005118e5 ,	0x00517485 ,	0x0051781c ,
	0x00514328 ,	0x005154fb ,	0x00512948 ,	0x00512702 ,
	0x00513623 ,	0x00514744 ,	0x00511209 ,	0x00514a32 ,
	0x00515f7d ,	0x005110b5 ,	0x00516a73 ,	0x005112f6 ,
	0x00513e6b ,	0x00513a85 ,	0x00514277 ,	0x00510ecf ,
	0x00513274 ,	0x00514ded ,	0x00516404 ,	0x00510029 ,
	0x00514823 ,	0x005118be ,	0x00516784 ,	0x00514ae1 ,
	0x00513d6c ,	0x00512cd6 ,	0x005172ae ,	0x00516952 ,
	0x00515f90 ,	0x00511649 ,	0x00516df1 ,	0x00515af1 ,
	0x005141bb ,	0x005126e9 ,	0x005101eb ,	0x00510bb3 ,
	0x00512ea6 ,	0x005112db ,	0x0051153c ,	0x00517e87 ,
	0x0051390c ,	0x00510f3e ,	0x00510099 ,	0x00510124 ,
	0x0051305e ,	0x0051440d ,	0x0051491c ,	0x00514d06 ,
	0x00514db7 ,	0x00511547 ,	0x005154de ,	0x005139b3 ,
	0x00512d12 ,	0x0051074d ,	0x00514dc8 ,	0x00516443 ,
	0x005166bb ,	0x0051428b ,	0x005126a6 ,	0x0051701f ,
	0x00515d03 ,	0x00517a5a ,	0x0051767d ,	0x00514509 ,
	0x00511238 ,	0x00513b25 ,	0x00511e1f ,	0x00516e5d ,
	0x00511ad4 ,	0x005163cb ,	0x00516bfc ,	0x00517f96 ,
	0x00517ff5 ,	0x00514e45 ,	0x0051323b ,	0x00512213 ,
	0x0051260d ,	0x00516b89 ,	0x0051030a ,	0x0051301c ,
	0x00510bdb ,	0x005156ae ,	0x00510732 ,	0x00510120 ,
	0x0051759a ,	0x00512350 ,	0x005122ee ,	0x00514b40 ,
	0x00515878 ,	0x00516b36 ,	0x00515cfd ,	0x00513e12 ,
	0x00511a49 ,	0x00515f32 ,	0x00513bf6 ,	0x00513a9e ,
	0x0051797d ,	0x00515f49 ,	0x00510ddc ,	0x00514cad ,
	0x0051314f ,	0x00515e14 ,	0x00514df2 ,	0x00514944 ,
	0x00512e40 ,	0x00511366 ,	0x00511cd0 ,	0x0051366b ,
	0x005166c4 ,	0x00514230 ,	0x00517eb7 ,	0x00516032 ,
	0x00512c3b ,	0x005115a1 ,	0x00515422 ,	0x00513ef6 ,
	0x00510822 ,	0x00515991 ,	0x0051409d ,    0x00511101 ,

	0x00527f9b ,	0x005218e5 ,	0x00527485 ,	0x0052781c ,
	0x00524328 ,	0x005254fb ,	0x00522948 ,	0x00522702 ,
	0x00523623 ,	0x00524744 ,	0x00521209 ,	0x00524a32 ,
	0x00525f7d ,	0x005210b5 ,	0x00526a73 ,	0x005212f6 ,
	0x00523e6b ,	0x00523a85 ,	0x00524277 ,	0x00520ecf ,
	0x00523274 ,	0x00524ded ,	0x00526404 ,	0x00520029 ,
	0x00524823 ,	0x005218be ,	0x00526784 ,	0x00524ae1 ,
	0x00523d6c ,	0x00522cd6 ,	0x005272ae ,	0x00526952 ,
	0x00525f90 ,	0x00521649 ,	0x00526df1 ,	0x00525af1 ,
	0x005241bb ,	0x005226e9 ,	0x005201eb ,	0x00520bb3 ,
	0x00522ea6 ,	0x005212db ,	0x0052153c ,	0x00527e87 ,
	0x0052390c ,	0x00520f3e ,	0x00520099 ,	0x00520124 ,
	0x0052305e ,	0x0052440d ,	0x0052491c ,	0x00524d06 ,
	0x00524db7 ,	0x00521547 ,	0x005254de ,	0x005239b3 ,
	0x00522d12 ,	0x0052074d ,	0x00524dc8 ,	0x00526443 ,
	0x005266bb ,	0x0052428b ,	0x005226a6 ,	0x0052701f ,
	0x00525d03 ,	0x00527a5a ,	0x0052767d ,	0x00524509 ,
	0x00521238 ,	0x00523b25 ,	0x00521e1f ,	0x00526e5d ,
	0x00521ad4 ,	0x005263cb ,	0x00526bfc ,	0x00527f96 ,
	0x00527ff5 ,	0x00524e45 ,	0x0052323b ,	0x00522213 ,
	0x0052260d ,	0x00526b89 ,	0x0052030a ,	0x0052301c ,
	0x00520bdb ,	0x005256ae ,	0x00520732 ,	0x00520120 ,
	0x0052759a ,	0x00522350 ,	0x005222ee ,	0x00524b40 ,
	0x00525878 ,	0x00526b36 ,	0x00525cfd ,	0x00523e12 ,
	0x00521a49 ,	0x00525f32 ,	0x00523bf6 ,	0x00523a9e ,
	0x0052797d ,	0x00525f49 ,	0x00520ddc ,	0x00524cad ,
	0x0052314f ,	0x00525e14 ,	0x00524df2 ,	0x00524944 ,
	0x00522e40 ,	0x00521366 ,	0x00521cd0 ,	0x0052366b ,
	0x005266c4 ,	0x00524230 ,	0x00527eb7 ,	0x00526032 ,
	0x00522c3b ,	0x005215a1 ,	0x00525422 ,	0x00523ef6 ,
	0x00520822 ,	0x00525991 ,	0x0052409d ,    0x00521101 ,

	0x00537f9b ,	0x005318e5 ,	0x00537485 ,	0x0053781c ,
	0x00534328 ,	0x005354fb ,	0x00532948 ,	0x00532702 ,
	0x00533623 ,	0x00534744 ,	0x00531209 ,	0x00534a32 ,
	0x00535f7d ,	0x005310b5 ,	0x00536a73 ,	0x005312f6 ,
	0x00533e6b ,	0x00533a85 ,	0x00534277 ,	0x00530ecf ,
	0x00533274 ,	0x00534ded ,	0x00536404 ,	0x00530029 ,
	0x00534823 ,	0x005318be ,	0x00536784 ,	0x00534ae1 ,
	0x00533d6c ,	0x00532cd6 ,	0x005372ae ,	0x00536952 ,
	0x00535f90 ,	0x00531649 ,	0x00536df1 ,	0x00535af1 ,
	0x005341bb ,	0x005326e9 ,	0x005301eb ,	0x00530bb3 ,
	0x00532ea6 ,	0x005312db ,	0x0053153c ,	0x00537e87 ,
	0x0053390c ,	0x00530f3e ,	0x00530099 ,	0x00530124 ,
	0x0053305e ,	0x0053440d ,	0x0053491c ,	0x00534d06 ,
	0x00534db7 ,	0x00531547 ,	0x005354de ,	0x005339b3 ,
	0x00532d12 ,	0x0053074d ,	0x00534dc8 ,	0x00536443 ,
	0x005366bb ,	0x0053428b ,	0x005326a6 ,	0x0053701f ,
	0x00535d03 ,	0x00537a5a ,	0x0053767d ,	0x00534509 ,
	0x00531238 ,	0x00533b25 ,	0x00531e1f ,	0x00536e5d ,
	0x00531ad4 ,	0x005363cb ,	0x00536bfc ,	0x00537f96 ,
	0x00537ff5 ,	0x00534e45 ,	0x0053323b ,	0x00532213 ,
	0x0053260d ,	0x00536b89 ,	0x0053030a ,	0x0053301c ,
	0x00530bdb ,	0x005356ae ,	0x00530732 ,	0x00530120 ,
	0x0053759a ,	0x00532350 ,	0x005322ee ,	0x00534b40 ,
	0x00535878 ,	0x00536b36 ,	0x00535cfd ,	0x00533e12 ,
	0x00531a49 ,	0x00535f32 ,	0x00533bf6 ,	0x00533a9e ,
	0x0053797d ,	0x00535f49 ,	0x00530ddc ,	0x00534cad ,
	0x0053314f ,	0x00535e14 ,	0x00534df2 ,	0x00534944 ,
	0x00532e40 ,	0x00531366 ,	0x00531cd0 ,	0x0053366b ,
	0x005366c4 ,	0x00534230 ,	0x00537eb7 ,	0x00536032 ,
	0x00532c3b ,	0x005315a1 ,	0x00535422 ,	0x00533ef6 ,
	0x00530822 ,	0x00535991 ,	0x0053409d ,    0x00531101 ,

	0x00547f9b ,	0x005418e5 ,	0x00547485 ,	0x0054781c ,
	0x00544328 ,	0x005454fb ,	0x00542948 ,	0x00542702 ,
	0x00543623 ,	0x00544744 ,	0x00541209 ,	0x00544a32 ,
	0x00545f7d ,	0x005410b5 ,	0x00546a73 ,	0x005412f6 ,
	0x00543e6b ,	0x00543a85 ,	0x00544277 ,	0x00540ecf ,
	0x00543274 ,	0x00544ded ,	0x00546404 ,	0x00540029 ,
	0x00544823 ,	0x005418be ,	0x00546784 ,	0x00544ae1 ,
	0x00543d6c ,	0x00542cd6 ,	0x005472ae ,	0x00546952 ,
	0x00545f90 ,	0x00541649 ,	0x00546df1 ,	0x00545af1 ,
	0x005441bb ,	0x005426e9 ,	0x005401eb ,	0x00540bb3 ,
	0x00542ea6 ,	0x005412db ,	0x0054153c ,	0x00547e87 ,
	0x0054390c ,	0x00540f3e ,	0x00540099 ,	0x00540124 ,
	0x0054305e ,	0x0054440d ,	0x0054491c ,	0x00544d06 ,
	0x00544db7 ,	0x00541547 ,	0x005454de ,	0x005439b3 ,
	0x00542d12 ,	0x0054074d ,	0x00544dc8 ,	0x00546443 ,
	0x005466bb ,	0x0054428b ,	0x005426a6 ,	0x0054701f ,
	0x00545d03 ,	0x00547a5a ,	0x0054767d ,	0x00544509 ,
	0x00541238 ,	0x00543b25 ,	0x00541e1f ,	0x00546e5d ,
	0x00541ad4 ,	0x005463cb ,	0x00546bfc ,	0x00547f96 ,
	0x00547ff5 ,	0x00544e45 ,	0x0054323b ,	0x00542213 ,
	0x0054260d ,	0x00546b89 ,	0x0054030a ,	0x0054301c ,
	0x00540bdb ,	0x005456ae ,	0x00540732 ,	0x00540120 ,
	0x0054759a ,	0x00542350 ,	0x005422ee ,	0x00544b40 ,
	0x00545878 ,	0x00546b36 ,	0x00545cfd ,	0x00543e12 ,
	0x00541a49 ,	0x00545f32 ,	0x00543bf6 ,	0x00543a9e ,
	0x0054797d ,	0x00545f49 ,	0x00540ddc ,	0x00544cad ,
	0x0054314f ,	0x00545e14 ,	0x00544df2 ,	0x00544944 ,
	0x00542e40 ,	0x00541366 ,	0x00541cd0 ,	0x0054366b ,
	0x005466c4 ,	0x00544230 ,	0x00547eb7 ,	0x00546032 ,
	0x00542c3b ,	0x005415a1 ,	0x00545422 ,	0x00543ef6 ,
	0x00540822 ,	0x00545991 ,	0x0054409d ,    0x00541101 ,

	0x00557f9b ,	0x005518e5 ,	0x00557485 ,	0x0055781c ,
	0x00554328 ,	0x005554fb ,	0x00552948 ,	0x00552702 ,
	0x00553623 ,	0x00554744 ,	0x00551209 ,	0x00554a32 ,
	0x00555f7d ,	0x005510b5 ,	0x00556a73 ,	0x005512f6 ,
	0x00553e6b ,	0x00553a85 ,	0x00554277 ,	0x00550ecf ,
	0x00553274 ,	0x00554ded ,	0x00556404 ,	0x00550029 ,
	0x00554823 ,	0x005518be ,	0x00556784 ,	0x00554ae1 ,
	0x00553d6c ,	0x00552cd6 ,	0x005572ae ,	0x00556952 ,
	0x00555f90 ,	0x00551649 ,	0x00556df1 ,	0x00555af1 ,
	0x005541bb ,	0x005526e9 ,	0x005501eb ,	0x00550bb3 ,
	0x00552ea6 ,	0x005512db ,	0x0055153c ,	0x00557e87 ,
	0x0055390c ,	0x00550f3e ,	0x00550099 ,	0x00550124 ,
	0x0055305e ,	0x0055440d ,	0x0055491c ,	0x00554d06 ,
	0x00554db7 ,	0x00551547 ,	0x005554de ,	0x005539b3 ,
	0x00552d12 ,	0x0055074d ,	0x00554dc8 ,	0x00556443 ,
	0x005566bb ,	0x0055428b ,	0x005526a6 ,	0x0055701f ,
	0x00555d03 ,	0x00557a5a ,	0x0055767d ,	0x00554509 ,
	0x00551238 ,	0x00553b25 ,	0x00551e1f ,	0x00556e5d ,
	0x00551ad4 ,	0x005563cb ,	0x00556bfc ,	0x00557f96 ,
	0x00557ff5 ,	0x00554e45 ,	0x0055323b ,	0x00552213 ,
	0x0055260d ,	0x00556b89 ,	0x0055030a ,	0x0055301c ,
	0x00550bdb ,	0x005556ae ,	0x00550732 ,	0x00550120 ,
	0x0055759a ,	0x00552350 ,	0x005522ee ,	0x00554b40 ,
	0x00555878 ,	0x00556b36 ,	0x00555cfd ,	0x00553e12 ,
	0x00551a49 ,	0x00555f32 ,	0x00553bf6 ,	0x00553a9e ,
	0x0055797d ,	0x00555f49 ,	0x00550ddc ,	0x00554cad ,
	0x0055314f ,	0x00555e14 ,	0x00554df2 ,	0x00554944 ,
	0x00552e40 ,	0x00551366 ,	0x00551cd0 ,	0x0055366b ,
	0x005566c4 ,	0x00554230 ,	0x00557eb7 ,	0x00556032 ,
	0x00552c3b ,	0x005515a1 ,	0x00555422 ,	0x00553ef6 ,
	0x00550822 ,	0x00555991 ,	0x0055409d ,    0x00551101 ,

	0x00567f9b ,	0x005618e5 ,	0x00567485 ,	0x0056781c ,
	0x00564328 ,	0x005654fb ,	0x00562948 ,	0x00562702 ,
	0x00563623 ,	0x00564744 ,	0x00561209 ,	0x00564a32 ,
	0x00565f7d ,	0x005610b5 ,	0x00566a73 ,	0x005612f6 ,
	0x00563e6b ,	0x00563a85 ,	0x00564277 ,	0x00560ecf ,
	0x00563274 ,	0x00564ded ,	0x00566404 ,	0x00560029 ,
	0x00564823 ,	0x005618be ,	0x00566784 ,	0x00564ae1 ,
	0x00563d6c ,	0x00562cd6 ,	0x005672ae ,	0x00566952 ,
	0x00565f90 ,	0x00561649 ,	0x00566df1 ,	0x00565af1 ,
	0x005641bb ,	0x005626e9 ,	0x005601eb ,	0x00560bb3 ,
	0x00562ea6 ,	0x005612db ,	0x0056153c ,	0x00567e87 ,
	0x0056390c ,	0x00560f3e ,	0x00560099 ,	0x00560124 ,
	0x0056305e ,	0x0056440d ,	0x0056491c ,	0x00564d06 ,
	0x00564db7 ,	0x00561547 ,	0x005654de ,	0x005639b3 ,
	0x00562d12 ,	0x0056074d ,	0x00564dc8 ,	0x00566443 ,
	0x005666bb ,	0x0056428b ,	0x005626a6 ,	0x0056701f ,
	0x00565d03 ,	0x00567a5a ,	0x0056767d ,	0x00564509 ,
	0x00561238 ,	0x00563b25 ,	0x00561e1f ,	0x00566e5d ,
	0x00561ad4 ,	0x005663cb ,	0x00566bfc ,	0x00567f96 ,
	0x00567ff5 ,	0x00564e45 ,	0x0056323b ,	0x00562213 ,
	0x0056260d ,	0x00566b89 ,	0x0056030a ,	0x0056301c ,
	0x00560bdb ,	0x005656ae ,	0x00560732 ,	0x00560120 ,
	0x0056759a ,	0x00562350 ,	0x005622ee ,	0x00564b40 ,
	0x00565878 ,	0x00566b36 ,	0x00565cfd ,	0x00563e12 ,
	0x00561a49 ,	0x00565f32 ,	0x00563bf6 ,	0x00563a9e ,
	0x0056797d ,	0x00565f49 ,	0x00560ddc ,	0x00564cad ,
	0x0056314f ,	0x00565e14 ,	0x00564df2 ,	0x00564944 ,
	0x00562e40 ,	0x00561366 ,	0x00561cd0 ,	0x0056366b ,
	0x005666c4 ,	0x00564230 ,	0x00567eb7 ,	0x00566032 ,
	0x00562c3b ,	0x005615a1 ,	0x00565422 ,	0x00563ef6 ,
	0x00560822 ,	0x00565991 ,	0x0056409d ,    0x00561101 ,

	0x00577f9b ,	0x005718e5 ,	0x00577485 ,	0x0057781c ,
	0x00574328 ,	0x005754fb ,	0x00572948 ,	0x00572702 ,
	0x00573623 ,	0x00574744 ,	0x00571209 ,	0x00574a32 ,
	0x00575f7d ,	0x005710b5 ,	0x00576a73 ,	0x005712f6 ,
	0x00573e6b ,	0x00573a85 ,	0x00574277 ,	0x00570ecf ,
	0x00573274 ,	0x00574ded ,	0x00576404 ,	0x00570029 ,
	0x00574823 ,	0x005718be ,	0x00576784 ,	0x00574ae1 ,
	0x00573d6c ,	0x00572cd6 ,	0x005772ae ,	0x00576952 ,
	0x00575f90 ,	0x00571649 ,	0x00576df1 ,	0x00575af1 ,
	0x005741bb ,	0x005726e9 ,	0x005701eb ,	0x00570bb3 ,
	0x00572ea6 ,	0x005712db ,	0x0057153c ,	0x00577e87 ,
	0x0057390c ,	0x00570f3e ,	0x00570099 ,	0x00570124 ,
	0x0057305e ,	0x0057440d ,	0x0057491c ,	0x00574d06 ,
	0x00574db7 ,	0x00571547 ,	0x005754de ,	0x005739b3 ,
	0x00572d12 ,	0x0057074d ,	0x00574dc8 ,	0x00576443 ,
	0x005766bb ,	0x0057428b ,	0x005726a6 ,	0x0057701f ,
	0x00575d03 ,	0x00577a5a ,	0x0057767d ,	0x00574509 ,
	0x00571238 ,	0x00573b25 ,	0x00571e1f ,	0x00576e5d ,
	0x00571ad4 ,	0x005763cb ,	0x00576bfc ,	0x00577f96 ,
	0x00577ff5 ,	0x00574e45 ,	0x0057323b ,	0x00572213 ,
	0x0057260d ,	0x00576b89 ,	0x0057030a ,	0x0057301c ,
	0x00570bdb ,	0x005756ae ,	0x00570732 ,	0x00570120 ,
	0x0057759a ,	0x00572350 ,	0x005722ee ,	0x00574b40 ,
	0x00575878 ,	0x00576b36 ,	0x00575cfd ,	0x00573e12 ,
	0x00571a49 ,	0x00575f32 ,	0x00573bf6 ,	0x00573a9e ,
	0x0057797d ,	0x00575f49 ,	0x00570ddc ,	0x00574cad ,
	0x0057314f ,	0x00575e14 ,	0x00574df2 ,	0x00574944 ,
	0x00572e40 ,	0x00571366 ,	0x00571cd0 ,	0x0057366b ,
	0x005766c4 ,	0x00574230 ,	0x00577eb7 ,	0x00576032 ,
	0x00572c3b ,	0x005715a1 ,	0x00575422 ,	0x00573ef6 ,
	0x00570822 ,	0x00575991 ,	0x0057409d ,    0x00571101 ,

	0x00587f9b ,	0x005818e5 ,	0x00587485 ,	0x0058781c ,
	0x00584328 ,	0x005854fb ,	0x00582948 ,	0x00582702 ,
	0x00583623 ,	0x00584744 ,	0x00581209 ,	0x00584a32 ,
	0x00585f7d ,	0x005810b5 ,	0x00586a73 ,	0x005812f6 ,
	0x00583e6b ,	0x00583a85 ,	0x00584277 ,	0x00580ecf ,
	0x00583274 ,	0x00584ded ,	0x00586404 ,	0x00580029 ,
	0x00584823 ,	0x005818be ,	0x00586784 ,	0x00584ae1 ,
	0x00583d6c ,	0x00582cd6 ,	0x005872ae ,	0x00586952 ,
	0x00585f90 ,	0x00581649 ,	0x00586df1 ,	0x00585af1 ,
	0x005841bb ,	0x005826e9 ,	0x005801eb ,	0x00580bb3 ,
	0x00582ea6 ,	0x005812db ,	0x0058153c ,	0x00587e87 ,
	0x0058390c ,	0x00580f3e ,	0x00580099 ,	0x00580124 ,
	0x0058305e ,	0x0058440d ,	0x0058491c ,	0x00584d06 ,
	0x00584db7 ,	0x00581547 ,	0x005854de ,	0x005839b3 ,
	0x00582d12 ,	0x0058074d ,	0x00584dc8 ,	0x00586443 ,
	0x005866bb ,	0x0058428b ,	0x005826a6 ,	0x0058701f ,
	0x00585d03 ,	0x00587a5a ,	0x0058767d ,	0x00584509 ,
	0x00581238 ,	0x00583b25 ,	0x00581e1f ,	0x00586e5d ,
	0x00581ad4 ,	0x005863cb ,	0x00586bfc ,	0x00587f96 ,
	0x00587ff5 ,	0x00584e45 ,	0x0058323b ,	0x00582213 ,
	0x0058260d ,	0x00586b89 ,	0x0058030a ,	0x0058301c ,
	0x00580bdb ,	0x005856ae ,	0x00580732 ,	0x00580120 ,
	0x0058759a ,	0x00582350 ,	0x005822ee ,	0x00584b40 ,
	0x00585878 ,	0x00586b36 ,	0x00585cfd ,	0x00583e12 ,
	0x00581a49 ,	0x00585f32 ,	0x00583bf6 ,	0x00583a9e ,
	0x0058797d ,	0x00585f49 ,	0x00580ddc ,	0x00584cad ,
	0x0058314f ,	0x00585e14 ,	0x00584df2 ,	0x00584944 ,
	0x00582e40 ,	0x00581366 ,	0x00581cd0 ,	0x0058366b ,
	0x005866c4 ,	0x00584230 ,	0x00587eb7 ,	0x00586032 ,
	0x00582c3b ,	0x005815a1 ,	0x00585422 ,	0x00583ef6 ,
	0x00580822 ,	0x00585991 ,	0x0058409d ,    0x00581101 ,

	0x00597f9b ,	0x005918e5 ,	0x00597485 ,	0x0059781c ,
	0x00594328 ,	0x005954fb ,	0x00592948 ,	0x00592702 ,
	0x00593623 ,	0x00594744 ,	0x00591209 ,	0x00594a32 ,
	0x00595f7d ,	0x005910b5 ,	0x00596a73 ,	0x005912f6 ,
	0x00593e6b ,	0x00593a85 ,	0x00594277 ,	0x00590ecf ,
	0x00593274 ,	0x00594ded ,	0x00596404 ,	0x00590029 ,
	0x00594823 ,	0x005918be ,	0x00596784 ,	0x00594ae1 ,
	0x00593d6c ,	0x00592cd6 ,	0x005972ae ,	0x00596952 ,
	0x00595f90 ,	0x00591649 ,	0x00596df1 ,	0x00595af1 ,
	0x005941bb ,	0x005926e9 ,	0x005901eb ,	0x00590bb3 ,
	0x00592ea6 ,	0x005912db ,	0x0059153c ,	0x00597e87 ,
	0x0059390c ,	0x00590f3e ,	0x00590099 ,	0x00590124 ,
	0x0059305e ,	0x0059440d ,	0x0059491c ,	0x00594d06 ,
	0x00594db7 ,	0x00591547 ,	0x005954de ,	0x005939b3 ,
	0x00592d12 ,	0x0059074d ,	0x00594dc8 ,	0x00596443 ,
	0x005966bb ,	0x0059428b ,	0x005926a6 ,	0x0059701f ,
	0x00595d03 ,	0x00597a5a ,	0x0059767d ,	0x00594509 ,
	0x00591238 ,	0x00593b25 ,	0x00591e1f ,	0x00596e5d ,
	0x00591ad4 ,	0x005963cb ,	0x00596bfc ,	0x00597f96 ,
	0x00597ff5 ,	0x00594e45 ,	0x0059323b ,	0x00592213 ,
	0x0059260d ,	0x00596b89 ,	0x0059030a ,	0x0059301c ,
	0x00590bdb ,	0x005956ae ,	0x00590732 ,	0x00590120 ,
	0x0059759a ,	0x00592350 ,	0x005922ee ,	0x00594b40 ,
	0x00595878 ,	0x00596b36 ,	0x00595cfd ,	0x00593e12 ,
	0x00591a49 ,	0x00595f32 ,	0x00593bf6 ,	0x00593a9e ,
	0x0059797d ,	0x00595f49 ,	0x00590ddc ,	0x00594cad ,
	0x0059314f ,	0x00595e14 ,	0x00594df2 ,	0x00594944 ,
	0x00592e40 ,	0x00591366 ,	0x00591cd0 ,	0x0059366b ,
	0x005966c4 ,	0x00594230 ,	0x00597eb7 ,	0x00596032 ,
	0x00592c3b ,	0x005915a1 ,	0x00595422 ,	0x00593ef6 ,
	0x00590822 ,	0x00595991 ,	0x0059409d ,    0x00591101 ,

	0x00607f9b ,	0x006018e5 ,	0x00607485 ,	0x0060781c ,
	0x00604328 ,	0x006054fb ,	0x00602948 ,	0x00602702 ,
	0x00603623 ,	0x00604744 ,	0x00601209 ,	0x00604a32 ,
	0x00605f7d ,	0x006010b5 ,	0x00606a73 ,	0x006012f6 ,
	0x00603e6b ,	0x00603a85 ,	0x00604277 ,	0x00600ecf ,
	0x00603274 ,	0x00604ded ,	0x00606404 ,	0x00600029 ,
	0x00604823 ,	0x006018be ,	0x00606784 ,	0x00604ae1 ,
	0x00603d6c ,	0x00602cd6 ,	0x006072ae ,	0x00606952 ,
	0x00605f90 ,	0x00601649 ,	0x00606df1 ,	0x00605af1 ,
	0x006041bb ,	0x006026e9 ,	0x006001eb ,	0x00600bb3 ,
	0x00602ea6 ,	0x006012db ,	0x0060153c ,	0x00607e87 ,
	0x0060390c ,	0x00600f3e ,	0x00600099 ,	0x00600124 ,
	0x0060305e ,	0x0060440d ,	0x0060491c ,	0x00604d06 ,
	0x00604db7 ,	0x00601547 ,	0x006054de ,	0x006039b3 ,
	0x00602d12 ,	0x0060074d ,	0x00604dc8 ,	0x00606443 ,
	0x006066bb ,	0x0060428b ,	0x006026a6 ,	0x0060701f ,
	0x00605d03 ,	0x00607a5a ,	0x0060767d ,	0x00604509 ,
	0x00601238 ,	0x00603b25 ,	0x00601e1f ,	0x00606e5d ,
	0x00601ad4 ,	0x006063cb ,	0x00606bfc ,	0x00607f96 ,
	0x00607ff5 ,	0x00604e45 ,	0x0060323b ,	0x00602213 ,
	0x0060260d ,	0x00606b89 ,	0x0060030a ,	0x0060301c ,
	0x00600bdb ,	0x006056ae ,	0x00600732 ,	0x00600120 ,
	0x0060759a ,	0x00602350 ,	0x006022ee ,	0x00604b40 ,
	0x00605878 ,	0x00606b36 ,	0x00605cfd ,	0x00603e12 ,
	0x00601a49 ,	0x00605f32 ,	0x00603bf6 ,	0x00603a9e ,
	0x0060797d ,	0x00605f49 ,	0x00600ddc ,	0x00604cad ,
	0x0060314f ,	0x00605e14 ,	0x00604df2 ,	0x00604944 ,
	0x00602e40 ,	0x00601366 ,	0x00601cd0 ,	0x0060366b ,
	0x006066c4 ,	0x00604230 ,	0x00607eb7 ,	0x00606032 ,
	0x00602c3b ,	0x006015a1 ,	0x00605422 ,	0x00603ef6 ,
	0x00600822 ,	0x00605991 ,	0x0060409d ,    0x00601101 ,

	0x00617f9b ,	0x006118e5 ,	0x00617485 ,	0x0061781c ,
	0x00614328 ,	0x006154fb ,	0x00612948 ,	0x00612702 ,
	0x00613623 ,	0x00614744 ,	0x00611209 ,	0x00614a32 ,
	0x00615f7d ,	0x006110b5 ,	0x00616a73 ,	0x006112f6 ,
	0x00613e6b ,	0x00613a85 ,	0x00614277 ,	0x00610ecf ,
	0x00613274 ,	0x00614ded ,	0x00616404 ,	0x00610029 ,
	0x00614823 ,	0x006118be ,	0x00616784 ,	0x00614ae1 ,
	0x00613d6c ,	0x00612cd6 ,	0x006172ae ,	0x00616952 ,
	0x00615f90 ,	0x00611649 ,	0x00616df1 ,	0x00615af1 ,
	0x006141bb ,	0x006126e9 ,	0x006101eb ,	0x00610bb3 ,
	0x00612ea6 ,	0x006112db ,	0x0061153c ,	0x00617e87 ,
	0x0061390c ,	0x00610f3e ,	0x00610099 ,	0x00610124 ,
	0x0061305e ,	0x0061440d ,	0x0061491c ,	0x00614d06 ,
	0x00614db7 ,	0x00611547 ,	0x006154de ,	0x006139b3 ,
	0x00612d12 ,	0x0061074d ,	0x00614dc8 ,	0x00616443 ,
	0x006166bb ,	0x0061428b ,	0x006126a6 ,	0x0061701f ,
	0x00615d03 ,	0x00617a5a ,	0x0061767d ,	0x00614509 ,
	0x00611238 ,	0x00613b25 ,	0x00611e1f ,	0x00616e5d ,
	0x00611ad4 ,	0x006163cb ,	0x00616bfc ,	0x00617f96 ,
	0x00617ff5 ,	0x00614e45 ,	0x0061323b ,	0x00612213 ,
	0x0061260d ,	0x00616b89 ,	0x0061030a ,	0x0061301c ,
	0x00610bdb ,	0x006156ae ,	0x00610732 ,	0x00610120 ,
	0x0061759a ,	0x00612350 ,	0x006122ee ,	0x00614b40 ,
	0x00615878 ,	0x00616b36 ,	0x00615cfd ,	0x00613e12 ,
	0x00611a49 ,	0x00615f32 ,	0x00613bf6 ,	0x00613a9e ,
	0x0061797d ,	0x00615f49 ,	0x00610ddc ,	0x00614cad ,
	0x0061314f ,	0x00615e14 ,	0x00614df2 ,	0x00614944 ,
	0x00612e40 ,	0x00611366 ,	0x00611cd0 ,	0x0061366b ,
	0x006166c4 ,	0x00614230 ,	0x00617eb7 ,	0x00616032 ,
	0x00612c3b ,	0x006115a1 ,	0x00615422 ,	0x00613ef6 ,
	0x00610822 ,	0x00615991 ,	0x0061409d ,    0x00611101 ,

	0x00627f9b ,	0x006218e5 ,	0x00627485 ,	0x0062781c ,
	0x00624328 ,	0x006254fb ,	0x00622948 ,	0x00622702 ,
	0x00623623 ,	0x00624744 ,	0x00621209 ,	0x00624a32 ,
	0x00625f7d ,	0x006210b5 ,	0x00626a73 ,	0x006212f6 ,
	0x00623e6b ,	0x00623a85 ,	0x00624277 ,	0x00620ecf ,
	0x00623274 ,	0x00624ded ,	0x00626404 ,	0x00620029 ,
	0x00624823 ,	0x006218be ,	0x00626784 ,	0x00624ae1 ,
	0x00623d6c ,	0x00622cd6 ,	0x006272ae ,	0x00626952 ,
	0x00625f90 ,	0x00621649 ,	0x00626df1 ,	0x00625af1 ,
	0x006241bb ,	0x006226e9 ,	0x006201eb ,	0x00620bb3 ,
	0x00622ea6 ,	0x006212db ,	0x0062153c ,	0x00627e87 ,
	0x0062390c ,	0x00620f3e ,	0x00620099 ,	0x00620124 ,
	0x0062305e ,	0x0062440d ,	0x0062491c ,	0x00624d06 ,
	0x00624db7 ,	0x00621547 ,	0x006254de ,	0x006239b3 ,
	0x00622d12 ,	0x0062074d ,	0x00624dc8 ,	0x00626443 ,
	0x006266bb ,	0x0062428b ,	0x006226a6 ,	0x0062701f ,
	0x00625d03 ,	0x00627a5a ,	0x0062767d ,	0x00624509 ,
	0x00621238 ,	0x00623b25 ,	0x00621e1f ,	0x00626e5d ,
	0x00621ad4 ,	0x006263cb ,	0x00626bfc ,	0x00627f96 ,
	0x00627ff5 ,	0x00624e45 ,	0x0062323b ,	0x00622213 ,
	0x0062260d ,	0x00626b89 ,	0x0062030a ,	0x0062301c ,
	0x00620bdb ,	0x006256ae ,	0x00620732 ,	0x00620120 ,
	0x0062759a ,	0x00622350 ,	0x006222ee ,	0x00624b40 ,
	0x00625878 ,	0x00626b36 ,	0x00625cfd ,	0x00623e12 ,
	0x00621a49 ,	0x00625f32 ,	0x00623bf6 ,	0x00623a9e ,
	0x0062797d ,	0x00625f49 ,	0x00620ddc ,	0x00624cad ,
	0x0062314f ,	0x00625e14 ,	0x00624df2 ,	0x00624944 ,
	0x00622e40 ,	0x00621366 ,	0x00621cd0 ,	0x0062366b ,
	0x006266c4 ,	0x00624230 ,	0x00627eb7 ,	0x00626032 ,
	0x00622c3b ,	0x006215a1 ,	0x00625422 ,	0x00623ef6 ,
	0x00620822 ,	0x00625991 ,	0x0062409d ,    0x00621101 ,

	0x00637f9b ,	0x006318e5 ,	0x00637485 ,	0x0063781c ,
	0x00634328 ,	0x006354fb ,	0x00632948 ,	0x00632702 ,
	0x00633623 ,	0x00634744 ,	0x00631209 ,	0x00634a32 ,
	0x00635f7d ,	0x006310b5 ,	0x00636a73 ,	0x006312f6 ,
	0x00633e6b ,	0x00633a85 ,	0x00634277 ,	0x00630ecf ,
	0x00633274 ,	0x00634ded ,	0x00636404 ,	0x00630029 ,
	0x00634823 ,	0x006318be ,	0x00636784 ,	0x00634ae1 ,
	0x00633d6c ,	0x00632cd6 ,	0x006372ae ,	0x00636952 ,
	0x00635f90 ,	0x00631649 ,	0x00636df1 ,	0x00635af1 ,
	0x006341bb ,	0x006326e9 ,	0x006301eb ,	0x00630bb3 ,
	0x00632ea6 ,	0x006312db ,	0x0063153c ,	0x00637e87 ,
	0x0063390c ,	0x00630f3e ,	0x00630099 ,	0x00630124 ,
	0x0063305e ,	0x0063440d ,	0x0063491c ,	0x00634d06 ,
	0x00634db7 ,	0x00631547 ,	0x006354de ,	0x006339b3 ,
	0x00632d12 ,	0x0063074d ,	0x00634dc8 ,	0x00636443 ,
	0x006366bb ,	0x0063428b ,	0x006326a6 ,	0x0063701f ,
	0x00635d03 ,	0x00637a5a ,	0x0063767d ,	0x00634509 ,
	0x00631238 ,	0x00633b25 ,	0x00631e1f ,	0x00636e5d ,
	0x00631ad4 ,	0x006363cb ,	0x00636bfc ,	0x00637f96 ,
	0x00637ff5 ,	0x00634e45 ,	0x0063323b ,	0x00632213 ,
	0x0063260d ,	0x00636b89 ,	0x0063030a ,	0x0063301c ,
	0x00630bdb ,	0x006356ae ,	0x00630732 ,	0x00630120 ,
	0x0063759a ,	0x00632350 ,	0x006322ee ,	0x00634b40 ,
	0x00635878 ,	0x00636b36 ,	0x00635cfd ,	0x00633e12 ,
	0x00631a49 ,	0x00635f32 ,	0x00633bf6 ,	0x00633a9e ,
	0x0063797d ,	0x00635f49 ,	0x00630ddc ,	0x00634cad ,
	0x0063314f ,	0x00635e14 ,	0x00634df2 ,	0x00634944 ,
	0x00632e40 ,	0x00631366 ,	0x00631cd0 ,	0x0063366b ,
	0x006366c4 ,	0x00634230 ,	0x00637eb7 ,	0x00636032 ,
	0x00632c3b ,	0x006315a1 ,	0x00635422 ,	0x00633ef6 ,
	0x00630822 ,	0x00635991 ,	0x0063409d ,    0x00631101 ,

	0x00647f9b ,	0x006418e5 ,	0x00647485 ,	0x0064781c ,
	0x00644328 ,	0x006454fb ,	0x00642948 ,	0x00642702 ,
	0x00643623 ,	0x00644744 ,	0x00641209 ,	0x00644a32 ,
	0x00645f7d ,	0x006410b5 ,	0x00646a73 ,	0x006412f6 ,
	0x00643e6b ,	0x00643a85 ,	0x00644277 ,	0x00640ecf ,
	0x00643274 ,	0x00644ded ,	0x00646404 ,	0x00640029 ,
	0x00644823 ,	0x006418be ,	0x00646784 ,	0x00644ae1 ,
	0x00643d6c ,	0x00642cd6 ,	0x006472ae ,	0x00646952 ,
	0x00645f90 ,	0x00641649 ,	0x00646df1 ,	0x00645af1 ,
	0x006441bb ,	0x006426e9 ,	0x006401eb ,	0x00640bb3 ,
	0x00642ea6 ,	0x006412db ,	0x0064153c ,	0x00647e87 ,
	0x0064390c ,	0x00640f3e ,	0x00640099 ,	0x00640124 ,
	0x0064305e ,	0x0064440d ,	0x0064491c ,	0x00644d06 ,
	0x00644db7 ,	0x00641547 ,	0x006454de ,	0x006439b3 ,
	0x00642d12 ,	0x0064074d ,	0x00644dc8 ,	0x00646443 ,
	0x006466bb ,	0x0064428b ,	0x006426a6 ,	0x0064701f ,
	0x00645d03 ,	0x00647a5a ,	0x0064767d ,	0x00644509 ,
	0x00641238 ,	0x00643b25 ,	0x00641e1f ,	0x00646e5d ,
	0x00641ad4 ,	0x006463cb ,	0x00646bfc ,	0x00647f96 ,
	0x00647ff5 ,	0x00644e45 ,	0x0064323b ,	0x00642213 ,
	0x0064260d ,	0x00646b89 ,	0x0064030a ,	0x0064301c ,
	0x00640bdb ,	0x006456ae ,	0x00640732 ,	0x00640120 ,
	0x0064759a ,	0x00642350 ,	0x006422ee ,	0x00644b40 ,
	0x00645878 ,	0x00646b36 ,	0x00645cfd ,	0x00643e12 ,
	0x00641a49 ,	0x00645f32 ,	0x00643bf6 ,	0x00643a9e ,
	0x0064797d ,	0x00645f49 ,	0x00640ddc ,	0x00644cad ,
	0x0064314f ,	0x00645e14 ,	0x00644df2 ,	0x00644944 ,
	0x00642e40 ,	0x00641366 ,	0x00641cd0 ,	0x0064366b ,
	0x006466c4 ,	0x00644230 ,	0x00647eb7 ,	0x00646032 ,
	0x00642c3b ,	0x006415a1 ,	0x00645422 ,	0x00643ef6 ,
	0x00640822 ,	0x00645991 ,	0x0064409d ,    0x00641101 ,

	0x00657f9b ,	0x006518e5 ,	0x00657485 ,	0x0065781c ,
	0x00654328 ,	0x006554fb ,	0x00652948 ,	0x00652702 ,
	0x00653623 ,	0x00654744 ,	0x00651209 ,	0x00654a32 ,
	0x00655f7d ,	0x006510b5 ,	0x00656a73 ,	0x006512f6 ,
	0x00653e6b ,	0x00653a85 ,	0x00654277 ,	0x00650ecf ,
	0x00653274 ,	0x00654ded ,	0x00656404 ,	0x00650029 ,
	0x00654823 ,	0x006518be ,	0x00656784 ,	0x00654ae1 ,
	0x00653d6c ,	0x00652cd6 ,	0x006572ae ,	0x00656952 ,
	0x00655f90 ,	0x00651649 ,	0x00656df1 ,	0x00655af1 ,
	0x006541bb ,	0x006526e9 ,	0x006501eb ,	0x00650bb3 ,
	0x00652ea6 ,	0x006512db ,	0x0065153c ,	0x00657e87 ,
	0x0065390c ,	0x00650f3e ,	0x00650099 ,	0x00650124 ,
	0x0065305e ,	0x0065440d ,	0x0065491c ,	0x00654d06 ,
	0x00654db7 ,	0x00651547 ,	0x006554de ,	0x006539b3 ,
	0x00652d12 ,	0x0065074d ,	0x00654dc8 ,	0x00656443 ,
	0x006566bb ,	0x0065428b ,	0x006526a6 ,	0x0065701f ,
	0x00655d03 ,	0x00657a5a ,	0x0065767d ,	0x00654509 ,
	0x00651238 ,	0x00653b25 ,	0x00651e1f ,	0x00656e5d ,
	0x00651ad4 ,	0x006563cb ,	0x00656bfc ,	0x00657f96 ,
	0x00657ff5 ,	0x00654e45 ,	0x0065323b ,	0x00652213 ,
	0x0065260d ,	0x00656b89 ,	0x0065030a ,	0x0065301c ,
	0x00650bdb ,	0x006556ae ,	0x00650732 ,	0x00650120 ,
	0x0065759a ,	0x00652350 ,	0x006522ee ,	0x00654b40 ,
	0x00655878 ,	0x00656b36 ,	0x00655cfd ,	0x00653e12 ,
	0x00651a49 ,	0x00655f32 ,	0x00653bf6 ,	0x00653a9e ,
	0x0065797d ,	0x00655f49 ,	0x00650ddc ,	0x00654cad ,
	0x0065314f ,	0x00655e14 ,	0x00654df2 ,	0x00654944 ,
	0x00652e40 ,	0x00651366 ,	0x00651cd0 ,	0x0065366b ,
	0x006566c4 ,	0x00654230 ,	0x00657eb7 ,	0x00656032 ,
	0x00652c3b ,	0x006515a1 ,	0x00655422 ,	0x00653ef6 ,
	0x00650822 ,	0x00655991 ,	0x0065409d ,    0x00651101 ,

	0x00667f9b ,	0x006618e5 ,	0x00667485 ,	0x0066781c ,
	0x00664328 ,	0x006654fb ,	0x00662948 ,	0x00662702 ,
	0x00663623 ,	0x00664744 ,	0x00661209 ,	0x00664a32 ,
	0x00665f7d ,	0x006610b5 ,	0x00666a73 ,	0x006612f6 ,
	0x00663e6b ,	0x00663a85 ,	0x00664277 ,	0x00660ecf ,
	0x00663274 ,	0x00664ded ,	0x00666404 ,	0x00660029 ,
	0x00664823 ,	0x006618be ,	0x00666784 ,	0x00664ae1 ,
	0x00663d6c ,	0x00662cd6 ,	0x006672ae ,	0x00666952 ,
	0x00665f90 ,	0x00661649 ,	0x00666df1 ,	0x00665af1 ,
	0x006641bb ,	0x006626e9 ,	0x006601eb ,	0x00660bb3 ,
	0x00662ea6 ,	0x006612db ,	0x0066153c ,	0x00667e87 ,
	0x0066390c ,	0x00660f3e ,	0x00660099 ,	0x00660124 ,
	0x0066305e ,	0x0066440d ,	0x0066491c ,	0x00664d06 ,
	0x00664db7 ,	0x00661547 ,	0x006654de ,	0x006639b3 ,
	0x00662d12 ,	0x0066074d ,	0x00664dc8 ,	0x00666443 ,
	0x006666bb ,	0x0066428b ,	0x006626a6 ,	0x0066701f ,
	0x00665d03 ,	0x00667a5a ,	0x0066767d ,	0x00664509 ,
	0x00661238 ,	0x00663b25 ,	0x00661e1f ,	0x00666e5d ,
	0x00661ad4 ,	0x006663cb ,	0x00666bfc ,	0x00667f96 ,
	0x00667ff5 ,	0x00664e45 ,	0x0066323b ,	0x00662213 ,
	0x0066260d ,	0x00666b89 ,	0x0066030a ,	0x0066301c ,
	0x00660bdb ,	0x006656ae ,	0x00660732 ,	0x00660120 ,
	0x0066759a ,	0x00662350 ,	0x006622ee ,	0x00664b40 ,
	0x00665878 ,	0x00666b36 ,	0x00665cfd ,	0x00663e12 ,
	0x00661a49 ,	0x00665f32 ,	0x00663bf6 ,	0x00663a9e ,
	0x0066797d ,	0x00665f49 ,	0x00660ddc ,	0x00664cad ,
	0x0066314f ,	0x00665e14 ,	0x00664df2 ,	0x00664944 ,
	0x00662e40 ,	0x00661366 ,	0x00661cd0 ,	0x0066366b ,
	0x006666c4 ,	0x00664230 ,	0x00667eb7 ,	0x00666032 ,
	0x00662c3b ,	0x006615a1 ,	0x00665422 ,	0x00663ef6 ,
	0x00660822 ,	0x00665991 ,	0x0066409d ,    0x00661101 ,

	0x00677f9b ,	0x006718e5 ,	0x00677485 ,	0x0067781c ,
	0x00674328 ,	0x006754fb ,	0x00672948 ,	0x00672702 ,
	0x00673623 ,	0x00674744 ,	0x00671209 ,	0x00674a32 ,
	0x00675f7d ,	0x006710b5 ,	0x00676a73 ,	0x006712f6 ,
	0x00673e6b ,	0x00673a85 ,	0x00674277 ,	0x00670ecf ,
	0x00673274 ,	0x00674ded ,	0x00676404 ,	0x00670029 ,
	0x00674823 ,	0x006718be ,	0x00676784 ,	0x00674ae1 ,
	0x00673d6c ,	0x00672cd6 ,	0x006772ae ,	0x00676952 ,
	0x00675f90 ,	0x00671649 ,	0x00676df1 ,	0x00675af1 ,
	0x006741bb ,	0x006726e9 ,	0x006701eb ,	0x00670bb3 ,
	0x00672ea6 ,	0x006712db ,	0x0067153c ,	0x00677e87 ,
	0x0067390c ,	0x00670f3e ,	0x00670099 ,	0x00670124 ,
	0x0067305e ,	0x0067440d ,	0x0067491c ,	0x00674d06 ,
	0x00674db7 ,	0x00671547 ,	0x006754de ,	0x006739b3 ,
	0x00672d12 ,	0x0067074d ,	0x00674dc8 ,	0x00676443 ,
	0x006766bb ,	0x0067428b ,	0x006726a6 ,	0x0067701f ,
	0x00675d03 ,	0x00677a5a ,	0x0067767d ,	0x00674509 ,
	0x00671238 ,	0x00673b25 ,	0x00671e1f ,	0x00676e5d ,
	0x00671ad4 ,	0x006763cb ,	0x00676bfc ,	0x00677f96 ,
	0x00677ff5 ,	0x00674e45 ,	0x0067323b ,	0x00672213 ,
	0x0067260d ,	0x00676b89 ,	0x0067030a ,	0x0067301c ,
	0x00670bdb ,	0x006756ae ,	0x00670732 ,	0x00670120 ,
	0x0067759a ,	0x00672350 ,	0x006722ee ,	0x00674b40 ,
	0x00675878 ,	0x00676b36 ,	0x00675cfd ,	0x00673e12 ,
	0x00671a49 ,	0x00675f32 ,	0x00673bf6 ,	0x00673a9e ,
	0x0067797d ,	0x00675f49 ,	0x00670ddc ,	0x00674cad ,
	0x0067314f ,	0x00675e14 ,	0x00674df2 ,	0x00674944 ,
	0x00672e40 ,	0x00671366 ,	0x00671cd0 ,	0x0067366b ,
	0x006766c4 ,	0x00674230 ,	0x00677eb7 ,	0x00676032 ,
	0x00672c3b ,	0x006715a1 ,	0x00675422 ,	0x00673ef6 ,
	0x00670822 ,	0x00675991 ,	0x0067409d ,    0x00671101 ,

	0x00687f9b ,	0x006818e5 ,	0x00687485 ,	0x0068781c ,
	0x00684328 ,	0x006854fb ,	0x00682948 ,	0x00682702 ,
	0x00683623 ,	0x00684744 ,	0x00681209 ,	0x00684a32 ,
	0x00685f7d ,	0x006810b5 ,	0x00686a73 ,	0x006812f6 ,
	0x00683e6b ,	0x00683a85 ,	0x00684277 ,	0x00680ecf ,
	0x00683274 ,	0x00684ded ,	0x00686404 ,	0x00680029 ,
	0x00684823 ,	0x006818be ,	0x00686784 ,	0x00684ae1 ,
	0x00683d6c ,	0x00682cd6 ,	0x006872ae ,	0x00686952 ,
	0x00685f90 ,	0x00681649 ,	0x00686df1 ,	0x00685af1 ,
	0x006841bb ,	0x006826e9 ,	0x006801eb ,	0x00680bb3 ,
	0x00682ea6 ,	0x006812db ,	0x0068153c ,	0x00687e87 ,
	0x0068390c ,	0x00680f3e ,	0x00680099 ,	0x00680124 ,
	0x0068305e ,	0x0068440d ,	0x0068491c ,	0x00684d06 ,
	0x00684db7 ,	0x00681547 ,	0x006854de ,	0x006839b3 ,
	0x00682d12 ,	0x0068074d ,	0x00684dc8 ,	0x00686443 ,
	0x006866bb ,	0x0068428b ,	0x006826a6 ,	0x0068701f ,
	0x00685d03 ,	0x00687a5a ,	0x0068767d ,	0x00684509 ,
	0x00681238 ,	0x00683b25 ,	0x00681e1f ,	0x00686e5d ,
	0x00681ad4 ,	0x006863cb ,	0x00686bfc ,	0x00687f96 ,
	0x00687ff5 ,	0x00684e45 ,	0x0068323b ,	0x00682213 ,
	0x0068260d ,	0x00686b89 ,	0x0068030a ,	0x0068301c ,
	0x00680bdb ,	0x006856ae ,	0x00680732 ,	0x00680120 ,
	0x0068759a ,	0x00682350 ,	0x006822ee ,	0x00684b40 ,
	0x00685878 ,	0x00686b36 ,	0x00685cfd ,	0x00683e12 ,
	0x00681a49 ,	0x00685f32 ,	0x00683bf6 ,	0x00683a9e ,
	0x0068797d ,	0x00685f49 ,	0x00680ddc ,	0x00684cad ,
	0x0068314f ,	0x00685e14 ,	0x00684df2 ,	0x00684944 ,
	0x00682e40 ,	0x00681366 ,	0x00681cd0 ,	0x0068366b ,
	0x006866c4 ,	0x00684230 ,	0x00687eb7 ,	0x00686032 ,
	0x00682c3b ,	0x006815a1 ,	0x00685422 ,	0x00683ef6 ,
	0x00680822 ,	0x00685991 ,	0x0068409d ,    0x00681101 ,

	0x00697f9b ,	0x006918e5 ,	0x00697485 ,	0x0069781c ,
	0x00694328 ,	0x006954fb ,	0x00692948 ,	0x00692702 ,
	0x00693623 ,	0x00694744 ,	0x00691209 ,	0x00694a32 ,
	0x00695f7d ,	0x006910b5 ,	0x00696a73 ,	0x006912f6 ,
	0x00693e6b ,	0x00693a85 ,	0x00694277 ,	0x00690ecf ,
	0x00693274 ,	0x00694ded ,	0x00696404 ,	0x00690029 ,
	0x00694823 ,	0x006918be ,	0x00696784 ,	0x00694ae1 ,
	0x00693d6c ,	0x00692cd6 ,	0x006972ae ,	0x00696952 ,
	0x00695f90 ,	0x00691649 ,	0x00696df1 ,	0x00695af1 ,
	0x006941bb ,	0x006926e9 ,	0x006901eb ,	0x00690bb3 ,
	0x00692ea6 ,	0x006912db ,	0x0069153c ,	0x00697e87 ,
	0x0069390c ,	0x00690f3e ,	0x00690099 ,	0x00690124 ,
	0x0069305e ,	0x0069440d ,	0x0069491c ,	0x00694d06 ,
	0x00694db7 ,	0x00691547 ,	0x006954de ,	0x006939b3 ,
	0x00692d12 ,	0x0069074d ,	0x00694dc8 ,	0x00696443 ,
	0x006966bb ,	0x0069428b ,	0x006926a6 ,	0x0069701f ,
	0x00695d03 ,	0x00697a5a ,	0x0069767d ,	0x00694509 ,
	0x00691238 ,	0x00693b25 ,	0x00691e1f ,	0x00696e5d ,
	0x00691ad4 ,	0x006963cb ,	0x00696bfc ,	0x00697f96 ,
	0x00697ff5 ,	0x00694e45 ,	0x0069323b ,	0x00692213 ,
	0x0069260d ,	0x00696b89 ,	0x0069030a ,	0x0069301c ,
	0x00690bdb ,	0x006956ae ,	0x00690732 ,	0x00690120 ,
	0x0069759a ,	0x00692350 ,	0x006922ee ,	0x00694b40 ,
	0x00695878 ,	0x00696b36 ,	0x00695cfd ,	0x00693e12 ,
	0x00691a49 ,	0x00695f32 ,	0x00693bf6 ,	0x00693a9e ,
	0x0069797d ,	0x00695f49 ,	0x00690ddc ,	0x00694cad ,
	0x0069314f ,	0x00695e14 ,	0x00694df2 ,	0x00694944 ,
	0x00692e40 ,	0x00691366 ,	0x00691cd0 ,	0x0069366b ,
	0x006966c4 ,	0x00694230 ,	0x00697eb7 ,	0x00696032 ,
	0x00692c3b ,	0x006915a1 ,	0x00695422 ,	0x00693ef6 ,
	0x00690822 ,	0x00695991 ,	0x0069409d ,    0x00691101 ,

	0x00707f9b ,	0x007018e5 ,	0x00707485 ,	0x0070781c ,
	0x00704328 ,	0x007054fb ,	0x00702948 ,	0x00702702 ,
	0x00703623 ,	0x00704744 ,	0x00701209 ,	0x00704a32 ,
	0x00705f7d ,	0x007010b5 ,	0x00706a73 ,	0x007012f6 ,
	0x00703e6b ,	0x00703a85 ,	0x00704277 ,	0x00700ecf ,
	0x00703274 ,	0x00704ded ,	0x00706404 ,	0x00700029 ,
	0x00704823 ,	0x007018be ,	0x00706784 ,	0x00704ae1 ,
	0x00703d6c ,	0x00702cd6 ,	0x007072ae ,	0x00706952 ,
	0x00705f90 ,	0x00701649 ,	0x00706df1 ,	0x00705af1 ,
	0x007041bb ,	0x007026e9 ,	0x007001eb ,	0x00700bb3 ,
	0x00702ea6 ,	0x007012db ,	0x0070153c ,	0x00707e87 ,
	0x0070390c ,	0x00700f3e ,	0x00700099 ,	0x00700124 ,
	0x0070305e ,	0x0070440d ,	0x0070491c ,	0x00704d06 ,
	0x00704db7 ,	0x00701547 ,	0x007054de ,	0x007039b3 ,
	0x00702d12 ,	0x0070074d ,	0x00704dc8 ,	0x00706443 ,
	0x007066bb ,	0x0070428b ,	0x007026a6 ,	0x0070701f ,
	0x00705d03 ,	0x00707a5a ,	0x0070767d ,	0x00704509 ,
	0x00701238 ,	0x00703b25 ,	0x00701e1f ,	0x00706e5d ,
	0x00701ad4 ,	0x007063cb ,	0x00706bfc ,	0x00707f96 ,
	0x00707ff5 ,	0x00704e45 ,	0x0070323b ,	0x00702213 ,
	0x0070260d ,	0x00706b89 ,	0x0070030a ,	0x0070301c ,
	0x00700bdb ,	0x007056ae ,	0x00700732 ,	0x00700120 ,
	0x0070759a ,	0x00702350 ,	0x007022ee ,	0x00704b40 ,
	0x00705878 ,	0x00706b36 ,	0x00705cfd ,	0x00703e12 ,
	0x00701a49 ,	0x00705f32 ,	0x00703bf6 ,	0x00703a9e ,
	0x0070797d ,	0x00705f49 ,	0x00700ddc ,	0x00704cad ,
	0x0070314f ,	0x00705e14 ,	0x00704df2 ,	0x00704944 ,
	0x00702e40 ,	0x00701366 ,	0x00701cd0 ,	0x0070366b ,
	0x007066c4 ,	0x00704230 ,	0x00707eb7 ,	0x00706032 ,
	0x00702c3b ,	0x007015a1 ,	0x00705422 ,	0x00703ef6 ,
	0x00700822 ,	0x00705991 ,	0x0070409d ,    0x00701101 ,

	0x00717f9b ,	0x007118e5 ,	0x00717485 ,	0x0071781c ,
	0x00714328 ,	0x007154fb ,	0x00712948 ,	0x00712702 ,
	0x00713623 ,	0x00714744 ,	0x00711209 ,	0x00714a32 ,
	0x00715f7d ,	0x007110b5 ,	0x00716a73 ,	0x007112f6 ,
	0x00713e6b ,	0x00713a85 ,	0x00714277 ,	0x00710ecf ,
	0x00713274 ,	0x00714ded ,	0x00716404 ,	0x00710029 ,
	0x00714823 ,	0x007118be ,	0x00716784 ,	0x00714ae1 ,
	0x00713d6c ,	0x00712cd6 ,	0x007172ae ,	0x00716952 ,
	0x00715f90 ,	0x00711649 ,	0x00716df1 ,	0x00715af1 ,
	0x007141bb ,	0x007126e9 ,	0x007101eb ,	0x00710bb3 ,
	0x00712ea6 ,	0x007112db ,	0x0071153c ,	0x00717e87 ,
	0x0071390c ,	0x00710f3e ,	0x00710099 ,	0x00710124 ,
	0x0071305e ,	0x0071440d ,	0x0071491c ,	0x00714d06 ,
	0x00714db7 ,	0x00711547 ,	0x007154de ,	0x007139b3 ,
	0x00712d12 ,	0x0071074d ,	0x00714dc8 ,	0x00716443 ,
	0x007166bb ,	0x0071428b ,	0x007126a6 ,	0x0071701f ,
	0x00715d03 ,	0x00717a5a ,	0x0071767d ,	0x00714509 ,
	0x00711238 ,	0x00713b25 ,	0x00711e1f ,	0x00716e5d ,
	0x00711ad4 ,	0x007163cb ,	0x00716bfc ,	0x00717f96 ,
	0x00717ff5 ,	0x00714e45 ,	0x0071323b ,	0x00712213 ,
	0x0071260d ,	0x00716b89 ,	0x0071030a ,	0x0071301c ,
	0x00710bdb ,	0x007156ae ,	0x00710732 ,	0x00710120 ,
	0x0071759a ,	0x00712350 ,	0x007122ee ,	0x00714b40 ,
	0x00715878 ,	0x00716b36 ,	0x00715cfd ,	0x00713e12 ,
	0x00711a49 ,	0x00715f32 ,	0x00713bf6 ,	0x00713a9e ,
	0x0071797d ,	0x00715f49 ,	0x00710ddc ,	0x00714cad ,
	0x0071314f ,	0x00715e14 ,	0x00714df2 ,	0x00714944 ,
	0x00712e40 ,	0x00711366 ,	0x00711cd0 ,	0x0071366b ,
	0x007166c4 ,	0x00714230 ,	0x00717eb7 ,	0x00716032 ,
	0x00712c3b ,	0x007115a1 ,	0x00715422 ,	0x00713ef6 ,
	0x00710822 ,	0x00715991 ,	0x0071409d ,    0x00711101 ,

	0x00727f9b ,	0x007218e5 ,	0x00727485 ,	0x0072781c ,
	0x00724328 ,	0x007254fb ,	0x00722948 ,	0x00722702 ,
	0x00723623 ,	0x00724744 ,	0x00721209 ,	0x00724a32 ,
	0x00725f7d ,	0x007210b5 ,	0x00726a73 ,	0x007212f6 ,
	0x00723e6b ,	0x00723a85 ,	0x00724277 ,	0x00720ecf ,
	0x00723274 ,	0x00724ded ,	0x00726404 ,	0x00720029 ,
	0x00724823 ,	0x007218be ,	0x00726784 ,	0x00724ae1 ,
	0x00723d6c ,	0x00722cd6 ,	0x007272ae ,	0x00726952 ,
	0x00725f90 ,	0x00721649 ,	0x00726df1 ,	0x00725af1 ,
	0x007241bb ,	0x007226e9 ,	0x007201eb ,	0x00720bb3 ,
	0x00722ea6 ,	0x007212db ,	0x0072153c ,	0x00727e87 ,
	0x0072390c ,	0x00720f3e ,	0x00720099 ,	0x00720124 ,
	0x0072305e ,	0x0072440d ,	0x0072491c ,	0x00724d06 ,
	0x00724db7 ,	0x00721547 ,	0x007254de ,	0x007239b3 ,
	0x00722d12 ,	0x0072074d ,	0x00724dc8 ,	0x00726443 ,
	0x007266bb ,	0x0072428b ,	0x007226a6 ,	0x0072701f ,
	0x00725d03 ,	0x00727a5a ,	0x0072767d ,	0x00724509 ,
	0x00721238 ,	0x00723b25 ,	0x00721e1f ,	0x00726e5d ,
	0x00721ad4 ,	0x007263cb ,	0x00726bfc ,	0x00727f96 ,
	0x00727ff5 ,	0x00724e45 ,	0x0072323b ,	0x00722213 ,
	0x0072260d ,	0x00726b89 ,	0x0072030a ,	0x0072301c ,
	0x00720bdb ,	0x007256ae ,	0x00720732 ,	0x00720120 ,
	0x0072759a ,	0x00722350 ,	0x007222ee ,	0x00724b40 ,
	0x00725878 ,	0x00726b36 ,	0x00725cfd ,	0x00723e12 ,
	0x00721a49 ,	0x00725f32 ,	0x00723bf6 ,	0x00723a9e ,
	0x0072797d ,	0x00725f49 ,	0x00720ddc ,	0x00724cad ,
	0x0072314f ,	0x00725e14 ,	0x00724df2 ,	0x00724944 ,
	0x00722e40 ,	0x00721366 ,	0x00721cd0 ,	0x0072366b ,
	0x007266c4 ,	0x00724230 ,	0x00727eb7 ,	0x00726032 ,
	0x00722c3b ,	0x007215a1 ,	0x00725422 ,	0x00723ef6 ,
	0x00720822 ,	0x00725991 ,	0x0072409d ,    0x00721101 ,

	0x00737f9b ,	0x007318e5 ,	0x00737485 ,	0x0073781c ,
	0x00734328 ,	0x007354fb ,	0x00732948 ,	0x00732702 ,
	0x00733623 ,	0x00734744 ,	0x00731209 ,	0x00734a32 ,
	0x00735f7d ,	0x007310b5 ,	0x00736a73 ,	0x007312f6 ,
	0x00733e6b ,	0x00733a85 ,	0x00734277 ,	0x00730ecf ,
	0x00733274 ,	0x00734ded ,	0x00736404 ,	0x00730029 ,
	0x00734823 ,	0x007318be ,	0x00736784 ,	0x00734ae1 ,
	0x00733d6c ,	0x00732cd6 ,	0x007372ae ,	0x00736952 ,
	0x00735f90 ,	0x00731649 ,	0x00736df1 ,	0x00735af1 ,
	0x007341bb ,	0x007326e9 ,	0x007301eb ,	0x00730bb3 ,
	0x00732ea6 ,	0x007312db ,	0x0073153c ,	0x00737e87 ,
	0x0073390c ,	0x00730f3e ,	0x00730099 ,	0x00730124 ,
	0x0073305e ,	0x0073440d ,	0x0073491c ,	0x00734d06 ,
	0x00734db7 ,	0x00731547 ,	0x007354de ,	0x007339b3 ,
	0x00732d12 ,	0x0073074d ,	0x00734dc8 ,	0x00736443 ,
	0x007366bb ,	0x0073428b ,	0x007326a6 ,	0x0073701f ,
	0x00735d03 ,	0x00737a5a ,	0x0073767d ,	0x00734509 ,
	0x00731238 ,	0x00733b25 ,	0x00731e1f ,	0x00736e5d ,
	0x00731ad4 ,	0x007363cb ,	0x00736bfc ,	0x00737f96 ,
	0x00737ff5 ,	0x00734e45 ,	0x0073323b ,	0x00732213 ,
	0x0073260d ,	0x00736b89 ,	0x0073030a ,	0x0073301c ,
	0x00730bdb ,	0x007356ae ,	0x00730732 ,	0x00730120 ,
	0x0073759a ,	0x00732350 ,	0x007322ee ,	0x00734b40 ,
	0x00735878 ,	0x00736b36 ,	0x00735cfd ,	0x00733e12 ,
	0x00731a49 ,	0x00735f32 ,	0x00733bf6 ,	0x00733a9e ,
	0x0073797d ,	0x00735f49 ,	0x00730ddc ,	0x00734cad ,
	0x0073314f ,	0x00735e14 ,	0x00734df2 ,	0x00734944 ,
	0x00732e40 ,	0x00731366 ,	0x00731cd0 ,	0x0073366b ,
	0x007366c4 ,	0x00734230 ,	0x00737eb7 ,	0x00736032 ,
	0x00732c3b ,	0x007315a1 ,	0x00735422 ,	0x00733ef6 ,
	0x00730822 ,	0x00735991 ,	0x0073409d ,    0x00731101 ,

	0x00747f9b ,	0x007418e5 ,	0x00747485 ,	0x0074781c ,
	0x00744328 ,	0x007454fb ,	0x00742948 ,	0x00742702 ,
	0x00743623 ,	0x00744744 ,	0x00741209 ,	0x00744a32 ,
	0x00745f7d ,	0x007410b5 ,	0x00746a73 ,	0x007412f6 ,
	0x00743e6b ,	0x00743a85 ,	0x00744277 ,	0x00740ecf ,
	0x00743274 ,	0x00744ded ,	0x00746404 ,	0x00740029 ,
	0x00744823 ,	0x007418be ,	0x00746784 ,	0x00744ae1 ,
	0x00743d6c ,	0x00742cd6 ,	0x007472ae ,	0x00746952 ,
	0x00745f90 ,	0x00741649 ,	0x00746df1 ,	0x00745af1 ,
	0x007441bb ,	0x007426e9 ,	0x007401eb ,	0x00740bb3 ,
	0x00742ea6 ,	0x007412db ,	0x0074153c ,	0x00747e87 ,
	0x0074390c ,	0x00740f3e ,	0x00740099 ,	0x00740124 ,
	0x0074305e ,	0x0074440d ,	0x0074491c ,	0x00744d06 ,
	0x00744db7 ,	0x00741547 ,	0x007454de ,	0x007439b3 ,
	0x00742d12 ,	0x0074074d ,	0x00744dc8 ,	0x00746443 ,
	0x007466bb ,	0x0074428b ,	0x007426a6 ,	0x0074701f ,
	0x00745d03 ,	0x00747a5a ,	0x0074767d ,	0x00744509 ,
	0x00741238 ,	0x00743b25 ,	0x00741e1f ,	0x00746e5d ,
	0x00741ad4 ,	0x007463cb ,	0x00746bfc ,	0x00747f96 ,
	0x00747ff5 ,	0x00744e45 ,	0x0074323b ,	0x00742213 ,
	0x0074260d ,	0x00746b89 ,	0x0074030a ,	0x0074301c ,
	0x00740bdb ,	0x007456ae ,	0x00740732 ,	0x00740120 ,
	0x0074759a ,	0x00742350 ,	0x007422ee ,	0x00744b40 ,
	0x00745878 ,	0x00746b36 ,	0x00745cfd ,	0x00743e12 ,
	0x00741a49 ,	0x00745f32 ,	0x00743bf6 ,	0x00743a9e ,
	0x0074797d ,	0x00745f49 ,	0x00740ddc ,	0x00744cad ,
	0x0074314f ,	0x00745e14 ,	0x00744df2 ,	0x00744944 ,
	0x00742e40 ,	0x00741366 ,	0x00741cd0 ,	0x0074366b ,
	0x007466c4 ,	0x00744230 ,	0x00747eb7 ,	0x00746032 ,
	0x00742c3b ,	0x007415a1 ,	0x00745422 ,	0x00743ef6 ,
	0x00740822 ,	0x00745991 ,	0x0074409d ,    0x00741101 ,

	0x00757f9b ,	0x007518e5 ,	0x00757485 ,	0x0075781c ,
	0x00754328 ,	0x007554fb ,	0x00752948 ,	0x00752702 ,
	0x00753623 ,	0x00754744 ,	0x00751209 ,	0x00754a32 ,
	0x00755f7d ,	0x007510b5 ,	0x00756a73 ,	0x007512f6 ,
	0x00753e6b ,	0x00753a85 ,	0x00754277 ,	0x00750ecf ,
	0x00753274 ,	0x00754ded ,	0x00756404 ,	0x00750029 ,
	0x00754823 ,	0x007518be ,	0x00756784 ,	0x00754ae1 ,
	0x00753d6c ,	0x00752cd6 ,	0x007572ae ,	0x00756952 ,
	0x00755f90 ,	0x00751649 ,	0x00756df1 ,	0x00755af1 ,
	0x007541bb ,	0x007526e9 ,	0x007501eb ,	0x00750bb3 ,
	0x00752ea6 ,	0x007512db ,	0x0075153c ,	0x00757e87 ,
	0x0075390c ,	0x00750f3e ,	0x00750099 ,	0x00750124 ,
	0x0075305e ,	0x0075440d ,	0x0075491c ,	0x00754d06 ,
	0x00754db7 ,	0x00751547 ,	0x007554de ,	0x007539b3 ,
	0x00752d12 ,	0x0075074d ,	0x00754dc8 ,	0x00756443 ,
	0x007566bb ,	0x0075428b ,	0x007526a6 ,	0x0075701f ,
	0x00755d03 ,	0x00757a5a ,	0x0075767d ,	0x00754509 ,
	0x00751238 ,	0x00753b25 ,	0x00751e1f ,	0x00756e5d ,
	0x00751ad4 ,	0x007563cb ,	0x00756bfc ,	0x00757f96 ,
	0x00757ff5 ,	0x00754e45 ,	0x0075323b ,	0x00752213 ,
	0x0075260d ,	0x00756b89 ,	0x0075030a ,	0x0075301c ,
	0x00750bdb ,	0x007556ae ,	0x00750732 ,	0x00750120 ,
	0x0075759a ,	0x00752350 ,	0x007522ee ,	0x00754b40 ,
	0x00755878 ,	0x00756b36 ,	0x00755cfd ,	0x00753e12 ,
	0x00751a49 ,	0x00755f32 ,	0x00753bf6 ,	0x00753a9e ,
	0x0075797d ,	0x00755f49 ,	0x00750ddc ,	0x00754cad ,
	0x0075314f ,	0x00755e14 ,	0x00754df2 ,	0x00754944 ,
	0x00752e40 ,	0x00751366 ,	0x00751cd0 ,	0x0075366b ,
	0x007566c4 ,	0x00754230 ,	0x00757eb7 ,	0x00756032 ,
	0x00752c3b ,	0x007515a1 ,	0x00755422 ,	0x00753ef6 ,
	0x00750822 ,	0x00755991 ,	0x0075409d ,    0x00751101 ,

	0x00767f9b ,	0x007618e5 ,	0x00767485 ,	0x0076781c ,
	0x00764328 ,	0x007654fb ,	0x00762948 ,	0x00762702 ,
	0x00763623 ,	0x00764744 ,	0x00761209 ,	0x00764a32 ,
	0x00765f7d ,	0x007610b5 ,	0x00766a73 ,	0x007612f6 ,
	0x00763e6b ,	0x00763a85 ,	0x00764277 ,	0x00760ecf ,
	0x00763274 ,	0x00764ded ,	0x00766404 ,	0x00760029 ,
	0x00764823 ,	0x007618be ,	0x00766784 ,	0x00764ae1 ,
	0x00763d6c ,	0x00762cd6 ,	0x007672ae ,	0x00766952 ,
	0x00765f90 ,	0x00761649 ,	0x00766df1 ,	0x00765af1 ,
	0x007641bb ,	0x007626e9 ,	0x007601eb ,	0x00760bb3 ,
	0x00762ea6 ,	0x007612db ,	0x0076153c ,	0x00767e87 ,
	0x0076390c ,	0x00760f3e ,	0x00760099 ,	0x00760124 ,
	0x0076305e ,	0x0076440d ,	0x0076491c ,	0x00764d06 ,
	0x00764db7 ,	0x00761547 ,	0x007654de ,	0x007639b3 ,
	0x00762d12 ,	0x0076074d ,	0x00764dc8 ,	0x00766443 ,
	0x007666bb ,	0x0076428b ,	0x007626a6 ,	0x0076701f ,
	0x00765d03 ,	0x00767a5a ,	0x0076767d ,	0x00764509 ,
	0x00761238 ,	0x00763b25 ,	0x00761e1f ,	0x00766e5d ,
	0x00761ad4 ,	0x007663cb ,	0x00766bfc ,	0x00767f96 ,
	0x00767ff5 ,	0x00764e45 ,	0x0076323b ,	0x00762213 ,
	0x0076260d ,	0x00766b89 ,	0x0076030a ,	0x0076301c ,
	0x00760bdb ,	0x007656ae ,	0x00760732 ,	0x00760120 ,
	0x0076759a ,	0x00762350 ,	0x007622ee ,	0x00764b40 ,
	0x00765878 ,	0x00766b36 ,	0x00765cfd ,	0x00763e12 ,
	0x00761a49 ,	0x00765f32 ,	0x00763bf6 ,	0x00763a9e ,
	0x0076797d ,	0x00765f49 ,	0x00760ddc ,	0x00764cad ,
	0x0076314f ,	0x00765e14 ,	0x00764df2 ,	0x00764944 ,
	0x00762e40 ,	0x00761366 ,	0x00761cd0 ,	0x0076366b ,
	0x007666c4 ,	0x00764230 ,	0x00767eb7 ,	0x00766032 ,
	0x00762c3b ,	0x007615a1 ,	0x00765422 ,	0x00763ef6 ,
	0x00760822 ,	0x00765991 ,	0x0076409d ,    0x00761101 ,

	0x00777f9b ,	0x007718e5 ,	0x00777485 ,	0x0077781c ,
	0x00774328 ,	0x007754fb ,	0x00772948 ,	0x00772702 ,
	0x00773623 ,	0x00774744 ,	0x00771209 ,	0x00774a32 ,
	0x00775f7d ,	0x007710b5 ,	0x00776a73 ,	0x007712f6 ,
	0x00773e6b ,	0x00773a85 ,	0x00774277 ,	0x00770ecf ,
	0x00773274 ,	0x00774ded ,	0x00776404 ,	0x00770029 ,
	0x00774823 ,	0x007718be ,	0x00776784 ,	0x00774ae1 ,
	0x00773d6c ,	0x00772cd6 ,	0x007772ae ,	0x00776952 ,
	0x00775f90 ,	0x00771649 ,	0x00776df1 ,	0x00775af1 ,
	0x007741bb ,	0x007726e9 ,	0x007701eb ,	0x00770bb3 ,
	0x00772ea6 ,	0x007712db ,	0x0077153c ,	0x00777e87 ,
	0x0077390c ,	0x00770f3e ,	0x00770099 ,	0x00770124 ,
	0x0077305e ,	0x0077440d ,	0x0077491c ,	0x00774d06 ,
	0x00774db7 ,	0x00771547 ,	0x007754de ,	0x007739b3 ,
	0x00772d12 ,	0x0077074d ,	0x00774dc8 ,	0x00776443 ,
	0x007766bb ,	0x0077428b ,	0x007726a6 ,	0x0077701f ,
	0x00775d03 ,	0x00777a5a ,	0x0077767d ,	0x00774509 ,
	0x00771238 ,	0x00773b25 ,	0x00771e1f ,	0x00776e5d ,
	0x00771ad4 ,	0x007763cb ,	0x00776bfc ,	0x00777f96 ,
	0x00777ff5 ,	0x00774e45 ,	0x0077323b ,	0x00772213 ,
	0x0077260d ,	0x00776b89 ,	0x0077030a ,	0x0077301c ,
	0x00770bdb ,	0x007756ae ,	0x00770732 ,	0x00770120 ,
	0x0077759a ,	0x00772350 ,	0x007722ee ,	0x00774b40 ,
	0x00775878 ,	0x00776b36 ,	0x00775cfd ,	0x00773e12 ,
	0x00771a49 ,	0x00775f32 ,	0x00773bf6 ,	0x00773a9e ,
	0x0077797d ,	0x00775f49 ,	0x00770ddc ,	0x00774cad ,
	0x0077314f ,	0x00775e14 ,	0x00774df2 ,	0x00774944 ,
	0x00772e40 ,	0x00771366 ,	0x00771cd0 ,	0x0077366b ,
	0x007766c4 ,	0x00774230 ,	0x00777eb7 ,	0x00776032 ,
	0x00772c3b ,	0x007715a1 ,	0x00775422 ,	0x00773ef6 ,
	0x00770822 ,	0x00775991 ,	0x0077409d ,    0x00771101 ,

	0x00787f9b ,	0x007818e5 ,	0x00787485 ,	0x0078781c ,
	0x00784328 ,	0x007854fb ,	0x00782948 ,	0x00782702 ,
	0x00783623 ,	0x00784744 ,	0x00781209 ,	0x00784a32 ,
	0x00785f7d ,	0x007810b5 ,	0x00786a73 ,	0x007812f6 ,
	0x00783e6b ,	0x00783a85 ,	0x00784277 ,	0x00780ecf ,
	0x00783274 ,	0x00784ded ,	0x00786404 ,	0x00780029 ,
	0x00784823 ,	0x007818be ,	0x00786784 ,	0x00784ae1 ,
	0x00783d6c ,	0x00782cd6 ,	0x007872ae ,	0x00786952 ,
	0x00785f90 ,	0x00781649 ,	0x00786df1 ,	0x00785af1 ,
	0x007841bb ,	0x007826e9 ,	0x007801eb ,	0x00780bb3 ,
	0x00782ea6 ,	0x007812db ,	0x0078153c ,	0x00787e87 ,
	0x0078390c ,	0x00780f3e ,	0x00780099 ,	0x00780124 ,
	0x0078305e ,	0x0078440d ,	0x0078491c ,	0x00784d06 ,
	0x00784db7 ,	0x00781547 ,	0x007854de ,	0x007839b3 ,
	0x00782d12 ,	0x0078074d ,	0x00784dc8 ,	0x00786443 ,
	0x007866bb ,	0x0078428b ,	0x007826a6 ,	0x0078701f ,
	0x00785d03 ,	0x00787a5a ,	0x0078767d ,	0x00784509 ,
	0x00781238 ,	0x00783b25 ,	0x00781e1f ,	0x00786e5d ,
	0x00781ad4 ,	0x007863cb ,	0x00786bfc ,	0x00787f96 ,
	0x00787ff5 ,	0x00784e45 ,	0x0078323b ,	0x00782213 ,
	0x0078260d ,	0x00786b89 ,	0x0078030a ,	0x0078301c ,
	0x00780bdb ,	0x007856ae ,	0x00780732 ,	0x00780120 ,
	0x0078759a ,	0x00782350 ,	0x007822ee ,	0x00784b40 ,
	0x00785878 ,	0x00786b36 ,	0x00785cfd ,	0x00783e12 ,
	0x00781a49 ,	0x00785f32 ,	0x00783bf6 ,	0x00783a9e ,
	0x0078797d ,	0x00785f49 ,	0x00780ddc ,	0x00784cad ,
	0x0078314f ,	0x00785e14 ,	0x00784df2 ,	0x00784944 ,
	0x00782e40 ,	0x00781366 ,	0x00781cd0 ,	0x0078366b ,
	0x007866c4 ,	0x00784230 ,	0x00787eb7 ,	0x00786032 ,
	0x00782c3b ,	0x007815a1 ,	0x00785422 ,	0x00783ef6 ,
	0x00780822 ,	0x00785991 ,	0x0078409d ,    0x00781101 ,

	0x00797f9b ,	0x007918e5 ,	0x00797485 ,	0x0079781c ,
	0x00794328 ,	0x007954fb ,	0x00792948 ,	0x00792702 ,
	0x00793623 ,	0x00794744 ,	0x00791209 ,	0x00794a32 ,
	0x00795f7d ,	0x007910b5 ,	0x00796a73 ,	0x007912f6 ,
	0x00793e6b ,	0x00793a85 ,	0x00794277 ,	0x00790ecf ,
	0x00793274 ,	0x00794ded ,	0x00796404 ,	0x00790029 ,
	0x00794823 ,	0x007918be ,	0x00796784 ,	0x00794ae1 ,
	0x00793d6c ,	0x00792cd6 ,	0x007972ae ,	0x00796952 ,
	0x00795f90 ,	0x00791649 ,	0x00796df1 ,	0x00795af1 ,
	0x007941bb ,	0x007926e9 ,	0x007901eb ,	0x00790bb3 ,
	0x00792ea6 ,	0x007912db ,	0x0079153c ,	0x00797e87 ,
	0x0079390c ,	0x00790f3e ,	0x00790099 ,	0x00790124 ,
	0x0079305e ,	0x0079440d ,	0x0079491c ,	0x00794d06 ,
	0x00794db7 ,	0x00791547 ,	0x007954de ,	0x007939b3 ,
	0x00792d12 ,	0x0079074d ,	0x00794dc8 ,	0x00796443 ,
	0x007966bb ,	0x0079428b ,	0x007926a6 ,	0x0079701f ,
	0x00795d03 ,	0x00797a5a ,	0x0079767d ,	0x00794509 ,
	0x00791238 ,	0x00793b25 ,	0x00791e1f ,	0x00796e5d ,
	0x00791ad4 ,	0x007963cb ,	0x00796bfc ,	0x00797f96 ,
	0x00797ff5 ,	0x00794e45 ,	0x0079323b ,	0x00792213 ,
	0x0079260d ,	0x00796b89 ,	0x0079030a ,	0x0079301c ,
	0x00790bdb ,	0x007956ae ,	0x00790732 ,	0x00790120 ,
	0x0079759a ,	0x00792350 ,	0x007922ee ,	0x00794b40 ,
	0x00795878 ,	0x00796b36 ,	0x00795cfd ,	0x00793e12 ,
	0x00791a49 ,	0x00795f32 ,	0x00793bf6 ,	0x00793a9e ,
	0x0079797d ,	0x00795f49 ,	0x00790ddc ,	0x00794cad ,
	0x0079314f ,	0x00795e14 ,	0x00794df2 ,	0x00794944 ,
	0x00792e40 ,	0x00791366 ,	0x00791cd0 ,	0x0079366b ,
	0x007966c4 ,	0x00794230 ,	0x00797eb7 ,	0x00796032 ,
	0x00792c3b ,	0x007915a1 ,	0x00795422 ,	0x00793ef6 ,
	0x00790822 ,	0x00795991 ,	0x0079409d ,    0x00791101 ,

	0x00807f9b ,	0x008018e5 ,	0x00807485 ,	0x0080781c ,
	0x00804328 ,	0x008054fb ,	0x00802948 ,	0x00802702 ,
	0x00803623 ,	0x00804744 ,	0x00801209 ,	0x00804a32 ,
	0x00805f7d ,	0x008010b5 ,	0x00806a73 ,	0x008012f6 ,
	0x00803e6b ,	0x00803a85 ,	0x00804277 ,	0x00800ecf ,
	0x00803274 ,	0x00804ded ,	0x00806404 ,	0x00800029 ,
	0x00804823 ,	0x008018be ,	0x00806784 ,	0x00804ae1 ,
	0x00803d6c ,	0x00802cd6 ,	0x008072ae ,	0x00806952 ,
	0x00805f90 ,	0x00801649 ,	0x00806df1 ,	0x00805af1 ,
	0x008041bb ,	0x008026e9 ,	0x008001eb ,	0x00800bb3 ,
	0x00802ea6 ,	0x008012db ,	0x0080153c ,	0x00807e87 ,
	0x0080390c ,	0x00800f3e ,	0x00800099 ,	0x00800124 ,
	0x0080305e ,	0x0080440d ,	0x0080491c ,	0x00804d06 ,
	0x00804db7 ,	0x00801547 ,	0x008054de ,	0x008039b3 ,
	0x00802d12 ,	0x0080074d ,	0x00804dc8 ,	0x00806443 ,
	0x008066bb ,	0x0080428b ,	0x008026a6 ,	0x0080701f ,
	0x00805d03 ,	0x00807a5a ,	0x0080767d ,	0x00804509 ,
	0x00801238 ,	0x00803b25 ,	0x00801e1f ,	0x00806e5d ,
	0x00801ad4 ,	0x008063cb ,	0x00806bfc ,	0x00807f96 ,
	0x00807ff5 ,	0x00804e45 ,	0x0080323b ,	0x00802213 ,
	0x0080260d ,	0x00806b89 ,	0x0080030a ,	0x0080301c ,
	0x00800bdb ,	0x008056ae ,	0x00800732 ,	0x00800120 ,
	0x0080759a ,	0x00802350 ,	0x008022ee ,	0x00804b40 ,
	0x00805878 ,	0x00806b36 ,	0x00805cfd ,	0x00803e12 ,
	0x00801a49 ,	0x00805f32 ,	0x00803bf6 ,	0x00803a9e ,
	0x0080797d ,	0x00805f49 ,	0x00800ddc ,	0x00804cad ,
	0x0080314f ,	0x00805e14 ,	0x00804df2 ,	0x00804944 ,
	0x00802e40 ,	0x00801366 ,	0x00801cd0 ,	0x0080366b ,
	0x008066c4 ,	0x00804230 ,	0x00807eb7 ,	0x00806032 ,
	0x00802c3b ,	0x008015a1 ,	0x00805422 ,	0x00803ef6 ,
	0x00800822 ,	0x00805991 ,	0x0080409d ,    0x00801101 ,

	0x00817f9b ,	0x008118e5 ,	0x00817485 ,	0x0081781c ,
	0x00814328 ,	0x008154fb ,	0x00812948 ,	0x00812702 ,
	0x00813623 ,	0x00814744 ,	0x00811209 ,	0x00814a32 ,
	0x00815f7d ,	0x008110b5 ,	0x00816a73 ,	0x008112f6 ,
	0x00813e6b ,	0x00813a85 ,	0x00814277 ,	0x00810ecf ,
	0x00813274 ,	0x00814ded ,	0x00816404 ,	0x00810029 ,
	0x00814823 ,	0x008118be ,	0x00816784 ,	0x00814ae1 ,
	0x00813d6c ,	0x00812cd6 ,	0x008172ae ,	0x00816952 ,
	0x00815f90 ,	0x00811649 ,	0x00816df1 ,	0x00815af1 ,
	0x008141bb ,	0x008126e9 ,	0x008101eb ,	0x00810bb3 ,
	0x00812ea6 ,	0x008112db ,	0x0081153c ,	0x00817e87 ,
	0x0081390c ,	0x00810f3e ,	0x00810099 ,	0x00810124 ,
	0x0081305e ,	0x0081440d ,	0x0081491c ,	0x00814d06 ,
	0x00814db7 ,	0x00811547 ,	0x008154de ,	0x008139b3 ,
	0x00812d12 ,	0x0081074d ,	0x00814dc8 ,	0x00816443 ,
	0x008166bb ,	0x0081428b ,	0x008126a6 ,	0x0081701f ,
	0x00815d03 ,	0x00817a5a ,	0x0081767d ,	0x00814509 ,
	0x00811238 ,	0x00813b25 ,	0x00811e1f ,	0x00816e5d ,
	0x00811ad4 ,	0x008163cb ,	0x00816bfc ,	0x00817f96 ,
	0x00817ff5 ,	0x00814e45 ,	0x0081323b ,	0x00812213 ,
	0x0081260d ,	0x00816b89 ,	0x0081030a ,	0x0081301c ,
	0x00810bdb ,	0x008156ae ,	0x00810732 ,	0x00810120 ,
	0x0081759a ,	0x00812350 ,	0x008122ee ,	0x00814b40 ,
	0x00815878 ,	0x00816b36 ,	0x00815cfd ,	0x00813e12 ,
	0x00811a49 ,	0x00815f32 ,	0x00813bf6 ,	0x00813a9e ,
	0x0081797d ,	0x00815f49 ,	0x00810ddc ,	0x00814cad ,
	0x0081314f ,	0x00815e14 ,	0x00814df2 ,	0x00814944 ,
	0x00812e40 ,	0x00811366 ,	0x00811cd0 ,	0x0081366b ,
	0x008166c4 ,	0x00814230 ,	0x00817eb7 ,	0x00816032 ,
	0x00812c3b ,	0x008115a1 ,	0x00815422 ,	0x00813ef6 ,
	0x00810822 ,	0x00815991 ,	0x0081409d ,    0x00811101 ,

	0x00827f9b ,	0x008218e5 ,	0x00827485 ,	0x0082781c ,
	0x00824328 ,	0x008254fb ,	0x00822948 ,	0x00822702 ,
	0x00823623 ,	0x00824744 ,	0x00821209 ,	0x00824a32 ,
	0x00825f7d ,	0x008210b5 ,	0x00826a73 ,	0x008212f6 ,
	0x00823e6b ,	0x00823a85 ,	0x00824277 ,	0x00820ecf ,
	0x00823274 ,	0x00824ded ,	0x00826404 ,	0x00820029 ,
	0x00824823 ,	0x008218be ,	0x00826784 ,	0x00824ae1 ,
	0x00823d6c ,	0x00822cd6 ,	0x008272ae ,	0x00826952 ,
	0x00825f90 ,	0x00821649 ,	0x00826df1 ,	0x00825af1 ,
	0x008241bb ,	0x008226e9 ,	0x008201eb ,	0x00820bb3 ,
	0x00822ea6 ,	0x008212db ,	0x0082153c ,	0x00827e87 ,
	0x0082390c ,	0x00820f3e ,	0x00820099 ,	0x00820124 ,
	0x0082305e ,	0x0082440d ,	0x0082491c ,	0x00824d06 ,
	0x00824db7 ,	0x00821547 ,	0x008254de ,	0x008239b3 ,
	0x00822d12 ,	0x0082074d ,	0x00824dc8 ,	0x00826443 ,
	0x008266bb ,	0x0082428b ,	0x008226a6 ,	0x0082701f ,
	0x00825d03 ,	0x00827a5a ,	0x0082767d ,	0x00824509 ,
	0x00821238 ,	0x00823b25 ,	0x00821e1f ,	0x00826e5d ,
	0x00821ad4 ,	0x008263cb ,	0x00826bfc ,	0x00827f96 ,
	0x00827ff5 ,	0x00824e45 ,	0x0082323b ,	0x00822213 ,
	0x0082260d ,	0x00826b89 ,	0x0082030a ,	0x0082301c ,
	0x00820bdb ,	0x008256ae ,	0x00820732 ,	0x00820120 ,
	0x0082759a ,	0x00822350 ,	0x008222ee ,	0x00824b40 ,
	0x00825878 ,	0x00826b36 ,	0x00825cfd ,	0x00823e12 ,
	0x00821a49 ,	0x00825f32 ,	0x00823bf6 ,	0x00823a9e ,
	0x0082797d ,	0x00825f49 ,	0x00820ddc ,	0x00824cad ,
	0x0082314f ,	0x00825e14 ,	0x00824df2 ,	0x00824944 ,
	0x00822e40 ,	0x00821366 ,	0x00821cd0 ,	0x0082366b ,
	0x008266c4 ,	0x00824230 ,	0x00827eb7 ,	0x00826032 ,
	0x00822c3b ,	0x008215a1 ,	0x00825422 ,	0x00823ef6 ,
	0x00820822 ,	0x00825991 ,	0x0082409d ,    0x00821101 ,

	0x00837f9b ,	0x008318e5 ,	0x00837485 ,	0x0083781c ,
	0x00834328 ,	0x008354fb ,	0x00832948 ,	0x00832702 ,
	0x00833623 ,	0x00834744 ,	0x00831209 ,	0x00834a32 ,
	0x00835f7d ,	0x008310b5 ,	0x00836a73 ,	0x008312f6 ,
	0x00833e6b ,	0x00833a85 ,	0x00834277 ,	0x00830ecf ,
	0x00833274 ,	0x00834ded ,	0x00836404 ,	0x00830029 ,
	0x00834823 ,	0x008318be ,	0x00836784 ,	0x00834ae1 ,
	0x00833d6c ,	0x00832cd6 ,	0x008372ae ,	0x00836952 ,
	0x00835f90 ,	0x00831649 ,	0x00836df1 ,	0x00835af1 ,
	0x008341bb ,	0x008326e9 ,	0x008301eb ,	0x00830bb3 ,
	0x00832ea6 ,	0x008312db ,	0x0083153c ,	0x00837e87 ,
	0x0083390c ,	0x00830f3e ,	0x00830099 ,	0x00830124 ,
	0x0083305e ,	0x0083440d ,	0x0083491c ,	0x00834d06 ,
	0x00834db7 ,	0x00831547 ,	0x008354de ,	0x008339b3 ,
	0x00832d12 ,	0x0083074d ,	0x00834dc8 ,	0x00836443 ,
	0x008366bb ,	0x0083428b ,	0x008326a6 ,	0x0083701f ,
	0x00835d03 ,	0x00837a5a ,	0x0083767d ,	0x00834509 ,
	0x00831238 ,	0x00833b25 ,	0x00831e1f ,	0x00836e5d ,
	0x00831ad4 ,	0x008363cb ,	0x00836bfc ,	0x00837f96 ,
	0x00837ff5 ,	0x00834e45 ,	0x0083323b ,	0x00832213 ,
	0x0083260d ,	0x00836b89 ,	0x0083030a ,	0x0083301c ,
	0x00830bdb ,	0x008356ae ,	0x00830732 ,	0x00830120 ,
	0x0083759a ,	0x00832350 ,	0x008322ee ,	0x00834b40 ,
	0x00835878 ,	0x00836b36 ,	0x00835cfd ,	0x00833e12 ,
	0x00831a49 ,	0x00835f32 ,	0x00833bf6 ,	0x00833a9e ,
	0x0083797d ,	0x00835f49 ,	0x00830ddc ,	0x00834cad ,
	0x0083314f ,	0x00835e14 ,	0x00834df2 ,	0x00834944 ,
	0x00832e40 ,	0x00831366 ,	0x00831cd0 ,	0x0083366b ,
	0x008366c4 ,	0x00834230 ,	0x00837eb7 ,	0x00836032 ,
	0x00832c3b ,	0x008315a1 ,	0x00835422 ,	0x00833ef6 ,
	0x00830822 ,	0x00835991 ,	0x0083409d ,    0x00831101 ,

	0x00847f9b ,	0x008418e5 ,	0x00847485 ,	0x0084781c ,
	0x00844328 ,	0x008454fb ,	0x00842948 ,	0x00842702 ,
	0x00843623 ,	0x00844744 ,	0x00841209 ,	0x00844a32 ,
	0x00845f7d ,	0x008410b5 ,	0x00846a73 ,	0x008412f6 ,
	0x00843e6b ,	0x00843a85 ,	0x00844277 ,	0x00840ecf ,
	0x00843274 ,	0x00844ded ,	0x00846404 ,	0x00840029 ,
	0x00844823 ,	0x008418be ,	0x00846784 ,	0x00844ae1 ,
	0x00843d6c ,	0x00842cd6 ,	0x008472ae ,	0x00846952 ,
	0x00845f90 ,	0x00841649 ,	0x00846df1 ,	0x00845af1 ,
	0x008441bb ,	0x008426e9 ,	0x008401eb ,	0x00840bb3 ,
	0x00842ea6 ,	0x008412db ,	0x0084153c ,	0x00847e87 ,
	0x0084390c ,	0x00840f3e ,	0x00840099 ,	0x00840124 ,
	0x0084305e ,	0x0084440d ,	0x0084491c ,	0x00844d06 ,
	0x00844db7 ,	0x00841547 ,	0x008454de ,	0x008439b3 ,
	0x00842d12 ,	0x0084074d ,	0x00844dc8 ,	0x00846443 ,
	0x008466bb ,	0x0084428b ,	0x008426a6 ,	0x0084701f ,
	0x00845d03 ,	0x00847a5a ,	0x0084767d ,	0x00844509 ,
	0x00841238 ,	0x00843b25 ,	0x00841e1f ,	0x00846e5d ,
	0x00841ad4 ,	0x008463cb ,	0x00846bfc ,	0x00847f96 ,
	0x00847ff5 ,	0x00844e45 ,	0x0084323b ,	0x00842213 ,
	0x0084260d ,	0x00846b89 ,	0x0084030a ,	0x0084301c ,
	0x00840bdb ,	0x008456ae ,	0x00840732 ,	0x00840120 ,
	0x0084759a ,	0x00842350 ,	0x008422ee ,	0x00844b40 ,
	0x00845878 ,	0x00846b36 ,	0x00845cfd ,	0x00843e12 ,
	0x00841a49 ,	0x00845f32 ,	0x00843bf6 ,	0x00843a9e ,
	0x0084797d ,	0x00845f49 ,	0x00840ddc ,	0x00844cad ,
	0x0084314f ,	0x00845e14 ,	0x00844df2 ,	0x00844944 ,
	0x00842e40 ,	0x00841366 ,	0x00841cd0 ,	0x0084366b ,
	0x008466c4 ,	0x00844230 ,	0x00847eb7 ,	0x00846032 ,
	0x00842c3b ,	0x008415a1 ,	0x00845422 ,	0x00843ef6 ,
	0x00840822 ,	0x00845991 ,	0x0084409d ,    0x00841101 ,

	0x00857f9b ,	0x008518e5 ,	0x00857485 ,	0x0085781c ,
	0x00854328 ,	0x008554fb ,	0x00852948 ,	0x00852702 ,
	0x00853623 ,	0x00854744 ,	0x00851209 ,	0x00854a32 ,
	0x00855f7d ,	0x008510b5 ,	0x00856a73 ,	0x008512f6 ,
	0x00853e6b ,	0x00853a85 ,	0x00854277 ,	0x00850ecf ,
	0x00853274 ,	0x00854ded ,	0x00856404 ,	0x00850029 ,
	0x00854823 ,	0x008518be ,	0x00856784 ,	0x00854ae1 ,
	0x00853d6c ,	0x00852cd6 ,	0x008572ae ,	0x00856952 ,
	0x00855f90 ,	0x00851649 ,	0x00856df1 ,	0x00855af1 ,
	0x008541bb ,	0x008526e9 ,	0x008501eb ,	0x00850bb3 ,
	0x00852ea6 ,	0x008512db ,	0x0085153c ,	0x00857e87 ,
	0x0085390c ,	0x00850f3e ,	0x00850099 ,	0x00850124 ,
	0x0085305e ,	0x0085440d ,	0x0085491c ,	0x00854d06 ,
	0x00854db7 ,	0x00851547 ,	0x008554de ,	0x008539b3 ,
	0x00852d12 ,	0x0085074d ,	0x00854dc8 ,	0x00856443 ,
	0x008566bb ,	0x0085428b ,	0x008526a6 ,	0x0085701f ,
	0x00855d03 ,	0x00857a5a ,	0x0085767d ,	0x00854509 ,
	0x00851238 ,	0x00853b25 ,	0x00851e1f ,	0x00856e5d ,
	0x00851ad4 ,	0x008563cb ,	0x00856bfc ,	0x00857f96 ,
	0x00857ff5 ,	0x00854e45 ,	0x0085323b ,	0x00852213 ,
	0x0085260d ,	0x00856b89 ,	0x0085030a ,	0x0085301c ,
	0x00850bdb ,	0x008556ae ,	0x00850732 ,	0x00850120 ,
	0x0085759a ,	0x00852350 ,	0x008522ee ,	0x00854b40 ,
	0x00855878 ,	0x00856b36 ,	0x00855cfd ,	0x00853e12 ,
	0x00851a49 ,	0x00855f32 ,	0x00853bf6 ,	0x00853a9e ,
	0x0085797d ,	0x00855f49 ,	0x00850ddc ,	0x00854cad ,
	0x0085314f ,	0x00855e14 ,	0x00854df2 ,	0x00854944 ,
	0x00852e40 ,	0x00851366 ,	0x00851cd0 ,	0x0085366b ,
	0x008566c4 ,	0x00854230 ,	0x00857eb7 ,	0x00856032 ,
	0x00852c3b ,	0x008515a1 ,	0x00855422 ,	0x00853ef6 ,
	0x00850822 ,	0x00855991 ,	0x0085409d ,    0x00851101 ,

	0x00867f9b ,	0x008618e5 ,	0x00867485 ,	0x0086781c ,
	0x00864328 ,	0x008654fb ,	0x00862948 ,	0x00862702 ,
	0x00863623 ,	0x00864744 ,	0x00861209 ,	0x00864a32 ,
	0x00865f7d ,	0x008610b5 ,	0x00866a73 ,	0x008612f6 ,
	0x00863e6b ,	0x00863a85 ,	0x00864277 ,	0x00860ecf ,
	0x00863274 ,	0x00864ded ,	0x00866404 ,	0x00860029 ,
	0x00864823 ,	0x008618be ,	0x00866784 ,	0x00864ae1 ,
	0x00863d6c ,	0x00862cd6 ,	0x008672ae ,	0x00866952 ,
	0x00865f90 ,	0x00861649 ,	0x00866df1 ,	0x00865af1 ,
	0x008641bb ,	0x008626e9 ,	0x008601eb ,	0x00860bb3 ,
	0x00862ea6 ,	0x008612db ,	0x0086153c ,	0x00867e87 ,
	0x0086390c ,	0x00860f3e ,	0x00860099 ,	0x00860124 ,
	0x0086305e ,	0x0086440d ,	0x0086491c ,	0x00864d06 ,
	0x00864db7 ,	0x00861547 ,	0x008654de ,	0x008639b3 ,
	0x00862d12 ,	0x0086074d ,	0x00864dc8 ,	0x00866443 ,
	0x008666bb ,	0x0086428b ,	0x008626a6 ,	0x0086701f ,
	0x00865d03 ,	0x00867a5a ,	0x0086767d ,	0x00864509 ,
	0x00861238 ,	0x00863b25 ,	0x00861e1f ,	0x00866e5d ,
	0x00861ad4 ,	0x008663cb ,	0x00866bfc ,	0x00867f96 ,
	0x00867ff5 ,	0x00864e45 ,	0x0086323b ,	0x00862213 ,
	0x0086260d ,	0x00866b89 ,	0x0086030a ,	0x0086301c ,
	0x00860bdb ,	0x008656ae ,	0x00860732 ,	0x00860120 ,
	0x0086759a ,	0x00862350 ,	0x008622ee ,	0x00864b40 ,
	0x00865878 ,	0x00866b36 ,	0x00865cfd ,	0x00863e12 ,
	0x00861a49 ,	0x00865f32 ,	0x00863bf6 ,	0x00863a9e ,
	0x0086797d ,	0x00865f49 ,	0x00860ddc ,	0x00864cad ,
	0x0086314f ,	0x00865e14 ,	0x00864df2 ,	0x00864944 ,
	0x00862e40 ,	0x00861366 ,	0x00861cd0 ,	0x0086366b ,
	0x008666c4 ,	0x00864230 ,	0x00867eb7 ,	0x00866032 ,
	0x00862c3b ,	0x008615a1 ,	0x00865422 ,	0x00863ef6 ,
	0x00860822 ,	0x00865991 ,	0x0086409d ,    0x00861101 ,

	0x00877f9b ,	0x008718e5 ,	0x00877485 ,	0x0087781c ,
	0x00874328 ,	0x008754fb ,	0x00872948 ,	0x00872702 ,
	0x00873623 ,	0x00874744 ,	0x00871209 ,	0x00874a32 ,
	0x00875f7d ,	0x008710b5 ,	0x00876a73 ,	0x008712f6 ,
	0x00873e6b ,	0x00873a85 ,	0x00874277 ,	0x00870ecf ,
	0x00873274 ,	0x00874ded ,	0x00876404 ,	0x00870029 ,
	0x00874823 ,	0x008718be ,	0x00876784 ,	0x00874ae1 ,
	0x00873d6c ,	0x00872cd6 ,	0x008772ae ,	0x00876952 ,
	0x00875f90 ,	0x00871649 ,	0x00876df1 ,	0x00875af1 ,
	0x008741bb ,	0x008726e9 ,	0x008701eb ,	0x00870bb3 ,
	0x00872ea6 ,	0x008712db ,	0x0087153c ,	0x00877e87 ,
	0x0087390c ,	0x00870f3e ,	0x00870099 ,	0x00870124 ,
	0x0087305e ,	0x0087440d ,	0x0087491c ,	0x00874d06 ,
	0x00874db7 ,	0x00871547 ,	0x008754de ,	0x008739b3 ,
	0x00872d12 ,	0x0087074d ,	0x00874dc8 ,	0x00876443 ,
	0x008766bb ,	0x0087428b ,	0x008726a6 ,	0x0087701f ,
	0x00875d03 ,	0x00877a5a ,	0x0087767d ,	0x00874509 ,
	0x00871238 ,	0x00873b25 ,	0x00871e1f ,	0x00876e5d ,
	0x00871ad4 ,	0x008763cb ,	0x00876bfc ,	0x00877f96 ,
	0x00877ff5 ,	0x00874e45 ,	0x0087323b ,	0x00872213 ,
	0x0087260d ,	0x00876b89 ,	0x0087030a ,	0x0087301c ,
	0x00870bdb ,	0x008756ae ,	0x00870732 ,	0x00870120 ,
	0x0087759a ,	0x00872350 ,	0x008722ee ,	0x00874b40 ,
	0x00875878 ,	0x00876b36 ,	0x00875cfd ,	0x00873e12 ,
	0x00871a49 ,	0x00875f32 ,	0x00873bf6 ,	0x00873a9e ,
	0x0087797d ,	0x00875f49 ,	0x00870ddc ,	0x00874cad ,
	0x0087314f ,	0x00875e14 ,	0x00874df2 ,	0x00874944 ,
	0x00872e40 ,	0x00871366 ,	0x00871cd0 ,	0x0087366b ,
	0x008766c4 ,	0x00874230 ,	0x00877eb7 ,	0x00876032 ,
	0x00872c3b ,	0x008715a1 ,	0x00875422 ,	0x00873ef6 ,
	0x00870822 ,	0x00875991 ,	0x0087409d ,    0x00871101 ,

	0x00887f9b ,	0x008818e5 ,	0x00887485 ,	0x0088781c ,
	0x00884328 ,	0x008854fb ,	0x00882948 ,	0x00882702 ,
	0x00883623 ,	0x00884744 ,	0x00881209 ,	0x00884a32 ,
	0x00885f7d ,	0x008810b5 ,	0x00886a73 ,	0x008812f6 ,
	0x00883e6b ,	0x00883a85 ,	0x00884277 ,	0x00880ecf ,
	0x00883274 ,	0x00884ded ,	0x00886404 ,	0x00880029 ,
	0x00884823 ,	0x008818be ,	0x00886784 ,	0x00884ae1 ,
	0x00883d6c ,	0x00882cd6 ,	0x008872ae ,	0x00886952 ,
	0x00885f90 ,	0x00881649 ,	0x00886df1 ,	0x00885af1 ,
	0x008841bb ,	0x008826e9 ,	0x008801eb ,	0x00880bb3 ,
	0x00882ea6 ,	0x008812db ,	0x0088153c ,	0x00887e87 ,
	0x0088390c ,	0x00880f3e ,	0x00880099 ,	0x00880124 ,
	0x0088305e ,	0x0088440d ,	0x0088491c ,	0x00884d06 ,
	0x00884db7 ,	0x00881547 ,	0x008854de ,	0x008839b3 ,
	0x00882d12 ,	0x0088074d ,	0x00884dc8 ,	0x00886443 ,
	0x008866bb ,	0x0088428b ,	0x008826a6 ,	0x0088701f ,
	0x00885d03 ,	0x00887a5a ,	0x0088767d ,	0x00884509 ,
	0x00881238 ,	0x00883b25 ,	0x00881e1f ,	0x00886e5d ,
	0x00881ad4 ,	0x008863cb ,	0x00886bfc ,	0x00887f96 ,
	0x00887ff5 ,	0x00884e45 ,	0x0088323b ,	0x00882213 ,
	0x0088260d ,	0x00886b89 ,	0x0088030a ,	0x0088301c ,
	0x00880bdb ,	0x008856ae ,	0x00880732 ,	0x00880120 ,
	0x0088759a ,	0x00882350 ,	0x008822ee ,	0x00884b40 ,
	0x00885878 ,	0x00886b36 ,	0x00885cfd ,	0x00883e12 ,
	0x00881a49 ,	0x00885f32 ,	0x00883bf6 ,	0x00883a9e ,
	0x0088797d ,	0x00885f49 ,	0x00880ddc ,	0x00884cad ,
	0x0088314f ,	0x00885e14 ,	0x00884df2 ,	0x00884944 ,
	0x00882e40 ,	0x00881366 ,	0x00881cd0 ,	0x0088366b ,
	0x008866c4 ,	0x00884230 ,	0x00887eb7 ,	0x00886032 ,
	0x00882c3b ,	0x008815a1 ,	0x00885422 ,	0x00883ef6 ,
	0x00880822 ,	0x00885991 ,	0x0088409d ,    0x00881101 ,

	0x00897f9b ,	0x008918e5 ,	0x00897485 ,	0x0089781c ,
	0x00894328 ,	0x008954fb ,	0x00892948 ,	0x00892702 ,
	0x00893623 ,	0x00894744 ,	0x00891209 ,	0x00894a32 ,
	0x00895f7d ,	0x008910b5 ,	0x00896a73 ,	0x008912f6 ,
	0x00893e6b ,	0x00893a85 ,	0x00894277 ,	0x00890ecf ,
	0x00893274 ,	0x00894ded ,	0x00896404 ,	0x00890029 ,
	0x00894823 ,	0x008918be ,	0x00896784 ,	0x00894ae1 ,
	0x00893d6c ,	0x00892cd6 ,	0x008972ae ,	0x00896952 ,
	0x00895f90 ,	0x00891649 ,	0x00896df1 ,	0x00895af1 ,
	0x008941bb ,	0x008926e9 ,	0x008901eb ,	0x00890bb3 ,
	0x00892ea6 ,	0x008912db ,	0x0089153c ,	0x00897e87 ,
	0x0089390c ,	0x00890f3e ,	0x00890099 ,	0x00890124 ,
	0x0089305e ,	0x0089440d ,	0x0089491c ,	0x00894d06 ,
	0x00894db7 ,	0x00891547 ,	0x008954de ,	0x008939b3 ,
	0x00892d12 ,	0x0089074d ,	0x00894dc8 ,	0x00896443 ,
	0x008966bb ,	0x0089428b ,	0x008926a6 ,	0x0089701f ,
	0x00895d03 ,	0x00897a5a ,	0x0089767d ,	0x00894509 ,
	0x00891238 ,	0x00893b25 ,	0x00891e1f ,	0x00896e5d ,
	0x00891ad4 ,	0x008963cb ,	0x00896bfc ,	0x00897f96 ,
	0x00897ff5 ,	0x00894e45 ,	0x0089323b ,	0x00892213 ,
	0x0089260d ,	0x00896b89 ,	0x0089030a ,	0x0089301c ,
	0x00890bdb ,	0x008956ae ,	0x00890732 ,	0x00890120 ,
	0x0089759a ,	0x00892350 ,	0x008922ee ,	0x00894b40 ,
	0x00895878 ,	0x00896b36 ,	0x00895cfd ,	0x00893e12 ,
	0x00891a49 ,	0x00895f32 ,	0x00893bf6 ,	0x00893a9e ,
	0x0089797d ,	0x00895f49 ,	0x00890ddc ,	0x00894cad ,
	0x0089314f ,	0x00895e14 ,	0x00894df2 ,	0x00894944 ,
	0x00892e40 ,	0x00891366 ,	0x00891cd0 ,	0x0089366b ,
	0x008966c4 ,	0x00894230 ,	0x00897eb7 ,	0x00896032 ,
	0x00892c3b ,	0x008915a1 ,	0x00895422 ,	0x00893ef6 ,
	0x00890822 ,	0x00895991 ,	0x0089409d ,    0x00891101 ,

	0x00907f9b ,	0x009018e5 ,	0x00907485 ,	0x0090781c ,
	0x00904328 ,	0x009054fb ,	0x00902948 ,	0x00902702 ,
	0x00903623 ,	0x00904744 ,	0x00901209 ,	0x00904a32 ,
	0x00905f7d ,	0x009010b5 ,	0x00906a73 ,	0x009012f6 ,
	0x00903e6b ,	0x00903a85 ,	0x00904277 ,	0x00900ecf ,
	0x00903274 ,	0x00904ded ,	0x00906404 ,	0x00900029 ,
	0x00904823 ,	0x009018be ,	0x00906784 ,	0x00904ae1 ,
	0x00903d6c ,	0x00902cd6 ,	0x009072ae ,	0x00906952 ,
	0x00905f90 ,	0x00901649 ,	0x00906df1 ,	0x00905af1 ,
	0x009041bb ,	0x009026e9 ,	0x009001eb ,	0x00900bb3 ,
	0x00902ea6 ,	0x009012db ,	0x0090153c ,	0x00907e87 ,
	0x0090390c ,	0x00900f3e ,	0x00900099 ,	0x00900124 ,
	0x0090305e ,	0x0090440d ,	0x0090491c ,	0x00904d06 ,
	0x00904db7 ,	0x00901547 ,	0x009054de ,	0x009039b3 ,
	0x00902d12 ,	0x0090074d ,	0x00904dc8 ,	0x00906443 ,
	0x009066bb ,	0x0090428b ,	0x009026a6 ,	0x0090701f ,
	0x00905d03 ,	0x00907a5a ,	0x0090767d ,	0x00904509 ,
	0x00901238 ,	0x00903b25 ,	0x00901e1f ,	0x00906e5d ,
	0x00901ad4 ,	0x009063cb ,	0x00906bfc ,	0x00907f96 ,
	0x00907ff5 ,	0x00904e45 ,	0x0090323b ,	0x00902213 ,
	0x0090260d ,	0x00906b89 ,	0x0090030a ,	0x0090301c ,
	0x00900bdb ,	0x009056ae ,	0x00900732 ,	0x00900120 ,
	0x0090759a ,	0x00902350 ,	0x009022ee ,	0x00904b40 ,
	0x00905878 ,	0x00906b36 ,	0x00905cfd ,	0x00903e12 ,
	0x00901a49 ,	0x00905f32 ,	0x00903bf6 ,	0x00903a9e ,
	0x0090797d ,	0x00905f49 ,	0x00900ddc ,	0x00904cad ,
	0x0090314f ,	0x00905e14 ,	0x00904df2 ,	0x00904944 ,
	0x00902e40 ,	0x00901366 ,	0x00901cd0 ,	0x0090366b ,
	0x009066c4 ,	0x00904230 ,	0x00907eb7 ,	0x00906032 ,
	0x00902c3b ,	0x009015a1 ,	0x00905422 ,	0x00903ef6 ,
	0x00900822 ,	0x00905991 ,	0x0090409d ,    0x00901101 ,

	0x00917f9b ,	0x009118e5 ,	0x00917485 ,	0x0091781c ,
	0x00914328 ,	0x009154fb ,	0x00912948 ,	0x00912702 ,
	0x00913623 ,	0x00914744 ,	0x00911209 ,	0x00914a32 ,
	0x00915f7d ,	0x009110b5 ,	0x00916a73 ,	0x009112f6 ,
	0x00913e6b ,	0x00913a85 ,	0x00914277 ,	0x00910ecf ,
	0x00913274 ,	0x00914ded ,	0x00916404 ,	0x00910029 ,
	0x00914823 ,	0x009118be ,	0x00916784 ,	0x00914ae1 ,
	0x00913d6c ,	0x00912cd6 ,	0x009172ae ,	0x00916952 ,
	0x00915f90 ,	0x00911649 ,	0x00916df1 ,	0x00915af1 ,
	0x009141bb ,	0x009126e9 ,	0x009101eb ,	0x00910bb3 ,
	0x00912ea6 ,	0x009112db ,	0x0091153c ,	0x00917e87 ,
	0x0091390c ,	0x00910f3e ,	0x00910099 ,	0x00910124 ,
	0x0091305e ,	0x0091440d ,	0x0091491c ,	0x00914d06 ,
	0x00914db7 ,	0x00911547 ,	0x009154de ,	0x009139b3 ,
	0x00912d12 ,	0x0091074d ,	0x00914dc8 ,	0x00916443 ,
	0x009166bb ,	0x0091428b ,	0x009126a6 ,	0x0091701f ,
	0x00915d03 ,	0x00917a5a ,	0x0091767d ,	0x00914509 ,
	0x00911238 ,	0x00913b25 ,	0x00911e1f ,	0x00916e5d ,
	0x00911ad4 ,	0x009163cb ,	0x00916bfc ,	0x00917f96 ,
	0x00917ff5 ,	0x00914e45 ,	0x0091323b ,	0x00912213 ,
	0x0091260d ,	0x00916b89 ,	0x0091030a ,	0x0091301c ,
	0x00910bdb ,	0x009156ae ,	0x00910732 ,	0x00910120 ,
	0x0091759a ,	0x00912350 ,	0x009122ee ,	0x00914b40 ,
	0x00915878 ,	0x00916b36 ,	0x00915cfd ,	0x00913e12 ,
	0x00911a49 ,	0x00915f32 ,	0x00913bf6 ,	0x00913a9e ,
	0x0091797d ,	0x00915f49 ,	0x00910ddc ,	0x00914cad ,
	0x0091314f ,	0x00915e14 ,	0x00914df2 ,	0x00914944 ,
	0x00912e40 ,	0x00911366 ,	0x00911cd0 ,	0x0091366b ,
	0x009166c4 ,	0x00914230 ,	0x00917eb7 ,	0x00916032 ,
	0x00912c3b ,	0x009115a1 ,	0x00915422 ,	0x00913ef6 ,
	0x00910822 ,	0x00915991 ,	0x0091409d ,    0x00911101 ,

	0x00927f9b ,	0x009218e5 ,	0x00927485 ,	0x0092781c ,
	0x00924328 ,	0x009254fb ,	0x00922948 ,	0x00922702 ,
	0x00923623 ,	0x00924744 ,	0x00921209 ,	0x00924a32 ,
	0x00925f7d ,	0x009210b5 ,	0x00926a73 ,	0x009212f6 ,
	0x00923e6b ,	0x00923a85 ,	0x00924277 ,	0x00920ecf ,
	0x00923274 ,	0x00924ded ,	0x00926404 ,	0x00920029 ,
	0x00924823 ,	0x009218be ,	0x00926784 ,	0x00924ae1 ,
	0x00923d6c ,	0x00922cd6 ,	0x009272ae ,	0x00926952 ,
	0x00925f90 ,	0x00921649 ,	0x00926df1 ,	0x00925af1 ,
	0x009241bb ,	0x009226e9 ,	0x009201eb ,	0x00920bb3 ,
	0x00922ea6 ,	0x009212db ,	0x0092153c ,	0x00927e87 ,
	0x0092390c ,	0x00920f3e ,	0x00920099 ,	0x00920124 ,
	0x0092305e ,	0x0092440d ,	0x0092491c ,	0x00924d06 ,
	0x00924db7 ,	0x00921547 ,	0x009254de ,	0x009239b3 ,
	0x00922d12 ,	0x0092074d ,	0x00924dc8 ,	0x00926443 ,
	0x009266bb ,	0x0092428b ,	0x009226a6 ,	0x0092701f ,
	0x00925d03 ,	0x00927a5a ,	0x0092767d ,	0x00924509 ,
	0x00921238 ,	0x00923b25 ,	0x00921e1f ,	0x00926e5d ,
	0x00921ad4 ,	0x009263cb ,	0x00926bfc ,	0x00927f96 ,
	0x00927ff5 ,	0x00924e45 ,	0x0092323b ,	0x00922213 ,
	0x0092260d ,	0x00926b89 ,	0x0092030a ,	0x0092301c ,
	0x00920bdb ,	0x009256ae ,	0x00920732 ,	0x00920120 ,
	0x0092759a ,	0x00922350 ,	0x009222ee ,	0x00924b40 ,
	0x00925878 ,	0x00926b36 ,	0x00925cfd ,	0x00923e12 ,
	0x00921a49 ,	0x00925f32 ,	0x00923bf6 ,	0x00923a9e ,
	0x0092797d ,	0x00925f49 ,	0x00920ddc ,	0x00924cad ,
	0x0092314f ,	0x00925e14 ,	0x00924df2 ,	0x00924944 ,
	0x00922e40 ,	0x00921366 ,	0x00921cd0 ,	0x0092366b ,
	0x009266c4 ,	0x00924230 ,	0x00927eb7 ,	0x00926032 ,
	0x00922c3b ,	0x009215a1 ,	0x00925422 ,	0x00923ef6 ,
	0x00920822 ,	0x00925991 ,	0x0092409d ,    0x00921101 ,

	0x00937f9b ,	0x009318e5 ,	0x00937485 ,	0x0093781c ,
	0x00934328 ,	0x009354fb ,	0x00932948 ,	0x00932702 ,
	0x00933623 ,	0x00934744 ,	0x00931209 ,	0x00934a32 ,
	0x00935f7d ,	0x009310b5 ,	0x00936a73 ,	0x009312f6 ,
	0x00933e6b ,	0x00933a85 ,	0x00934277 ,	0x00930ecf ,
	0x00933274 ,	0x00934ded ,	0x00936404 ,	0x00930029 ,
	0x00934823 ,	0x009318be ,	0x00936784 ,	0x00934ae1 ,
	0x00933d6c ,	0x00932cd6 ,	0x009372ae ,	0x00936952 ,
	0x00935f90 ,	0x00931649 ,	0x00936df1 ,	0x00935af1 ,
	0x009341bb ,	0x009326e9 ,	0x009301eb ,	0x00930bb3 ,
	0x00932ea6 ,	0x009312db ,	0x0093153c ,	0x00937e87 ,
	0x0093390c ,	0x00930f3e ,	0x00930099 ,	0x00930124 ,
	0x0093305e ,	0x0093440d ,	0x0093491c ,	0x00934d06 ,
	0x00934db7 ,	0x00931547 ,	0x009354de ,	0x009339b3 ,
	0x00932d12 ,	0x0093074d ,	0x00934dc8 ,	0x00936443 ,
	0x009366bb ,	0x0093428b ,	0x009326a6 ,	0x0093701f ,
	0x00935d03 ,	0x00937a5a ,	0x0093767d ,	0x00934509 ,
	0x00931238 ,	0x00933b25 ,	0x00931e1f ,	0x00936e5d ,
	0x00931ad4 ,	0x009363cb ,	0x00936bfc ,	0x00937f96 ,
	0x00937ff5 ,	0x00934e45 ,	0x0093323b ,	0x00932213 ,
	0x0093260d ,	0x00936b89 ,	0x0093030a ,	0x0093301c ,
	0x00930bdb ,	0x009356ae ,	0x00930732 ,	0x00930120 ,
	0x0093759a ,	0x00932350 ,	0x009322ee ,	0x00934b40 ,
	0x00935878 ,	0x00936b36 ,	0x00935cfd ,	0x00933e12 ,
	0x00931a49 ,	0x00935f32 ,	0x00933bf6 ,	0x00933a9e ,
	0x0093797d ,	0x00935f49 ,	0x00930ddc ,	0x00934cad ,
	0x0093314f ,	0x00935e14 ,	0x00934df2 ,	0x00934944 ,
	0x00932e40 ,	0x00931366 ,	0x00931cd0 ,	0x0093366b ,
	0x009366c4 ,	0x00934230 ,	0x00937eb7 ,	0x00936032 ,
	0x00932c3b ,	0x009315a1 ,	0x00935422 ,	0x00933ef6 ,
	0x00930822 ,	0x00935991 ,	0x0093409d ,    0x00931101 ,

	0x00947f9b ,	0x009418e5 ,	0x00947485 ,	0x0094781c ,
	0x00944328 ,	0x009454fb ,	0x00942948 ,	0x00942702 ,
	0x00943623 ,	0x00944744 ,	0x00941209 ,	0x00944a32 ,
	0x00945f7d ,	0x009410b5 ,	0x00946a73 ,	0x009412f6 ,
	0x00943e6b ,	0x00943a85 ,	0x00944277 ,	0x00940ecf ,
	0x00943274 ,	0x00944ded ,	0x00946404 ,	0x00940029 ,
	0x00944823 ,	0x009418be ,	0x00946784 ,	0x00944ae1 ,
	0x00943d6c ,	0x00942cd6 ,	0x009472ae ,	0x00946952 ,
	0x00945f90 ,	0x00941649 ,	0x00946df1 ,	0x00945af1 ,
	0x009441bb ,	0x009426e9 ,	0x009401eb ,	0x00940bb3 ,
	0x00942ea6 ,	0x009412db ,	0x0094153c ,	0x00947e87 ,
	0x0094390c ,	0x00940f3e ,	0x00940099 ,	0x00940124 ,
	0x0094305e ,	0x0094440d ,	0x0094491c ,	0x00944d06 ,
	0x00944db7 ,	0x00941547 ,	0x009454de ,	0x009439b3 ,
	0x00942d12 ,	0x0094074d ,	0x00944dc8 ,	0x00946443 ,
	0x009466bb ,	0x0094428b ,	0x009426a6 ,	0x0094701f ,
	0x00945d03 ,	0x00947a5a ,	0x0094767d ,	0x00944509 ,
	0x00941238 ,	0x00943b25 ,	0x00941e1f ,	0x00946e5d ,
	0x00941ad4 ,	0x009463cb ,	0x00946bfc ,	0x00947f96 ,
	0x00947ff5 ,	0x00944e45 ,	0x0094323b ,	0x00942213 ,
	0x0094260d ,	0x00946b89 ,	0x0094030a ,	0x0094301c ,
	0x00940bdb ,	0x009456ae ,	0x00940732 ,	0x00940120 ,
	0x0094759a ,	0x00942350 ,	0x009422ee ,	0x00944b40 ,
	0x00945878 ,	0x00946b36 ,	0x00945cfd ,	0x00943e12 ,
	0x00941a49 ,	0x00945f32 ,	0x00943bf6 ,	0x00943a9e ,
	0x0094797d ,	0x00945f49 ,	0x00940ddc ,	0x00944cad ,
	0x0094314f ,	0x00945e14 ,	0x00944df2 ,	0x00944944 ,
	0x00942e40 ,	0x00941366 ,	0x00941cd0 ,	0x0094366b ,
	0x009466c4 ,	0x00944230 ,	0x00947eb7 ,	0x00946032 ,
	0x00942c3b ,	0x009415a1 ,	0x00945422 ,	0x00943ef6 ,
	0x00940822 ,	0x00945991 ,	0x0094409d ,    0x00941101 ,

	0x00957f9b ,	0x009518e5 ,	0x00957485 ,	0x0095781c ,
	0x00954328 ,	0x009554fb ,	0x00952948 ,	0x00952702 ,
	0x00953623 ,	0x00954744 ,	0x00951209 ,	0x00954a32 ,
	0x00955f7d ,	0x009510b5 ,	0x00956a73 ,	0x009512f6 ,
	0x00953e6b ,	0x00953a85 ,	0x00954277 ,	0x00950ecf ,
	0x00953274 ,	0x00954ded ,	0x00956404 ,	0x00950029 ,
	0x00954823 ,	0x009518be ,	0x00956784 ,	0x00954ae1 ,
	0x00953d6c ,	0x00952cd6 ,	0x009572ae ,	0x00956952 ,
	0x00955f90 ,	0x00951649 ,	0x00956df1 ,	0x00955af1 ,
	0x009541bb ,	0x009526e9 ,	0x009501eb ,	0x00950bb3 ,
	0x00952ea6 ,	0x009512db ,	0x0095153c ,	0x00957e87 ,
	0x0095390c ,	0x00950f3e ,	0x00950099 ,	0x00950124 ,
	0x0095305e ,	0x0095440d ,	0x0095491c ,	0x00954d06 ,
	0x00954db7 ,	0x00951547 ,	0x009554de ,	0x009539b3 ,
	0x00952d12 ,	0x0095074d ,	0x00954dc8 ,	0x00956443 ,
	0x009566bb ,	0x0095428b ,	0x009526a6 ,	0x0095701f ,
	0x00955d03 ,	0x00957a5a ,	0x0095767d ,	0x00954509 ,
	0x00951238 ,	0x00953b25 ,	0x00951e1f ,	0x00956e5d ,
	0x00951ad4 ,	0x009563cb ,	0x00956bfc ,	0x00957f96 ,
	0x00957ff5 ,	0x00954e45 ,	0x0095323b ,	0x00952213 ,
	0x0095260d ,	0x00956b89 ,	0x0095030a ,	0x0095301c ,
	0x00950bdb ,	0x009556ae ,	0x00950732 ,	0x00950120 ,
	0x0095759a ,	0x00952350 ,	0x009522ee ,	0x00954b40 ,
	0x00955878 ,	0x00956b36 ,	0x00955cfd ,	0x00953e12 ,
	0x00951a49 ,	0x00955f32 ,	0x00953bf6 ,	0x00953a9e ,
	0x0095797d ,	0x00955f49 ,	0x00950ddc ,	0x00954cad ,
	0x0095314f ,	0x00955e14 ,	0x00954df2 ,	0x00954944 ,
	0x00952e40 ,	0x00951366 ,	0x00951cd0 ,	0x0095366b ,
	0x009566c4 ,	0x00954230 ,	0x00957eb7 ,	0x00956032 ,
	0x00952c3b ,	0x009515a1 ,	0x00955422 ,	0x00953ef6 ,
	0x00950822 ,	0x00955991 ,	0x0095409d ,    0x00951101 ,

	0x00967f9b ,	0x009618e5 ,	0x00967485 ,	0x0096781c ,
	0x00964328 ,	0x009654fb ,	0x00962948 ,	0x00962702 ,
	0x00963623 ,	0x00964744 ,	0x00961209 ,	0x00964a32 ,
	0x00965f7d ,	0x009610b5 ,	0x00966a73 ,	0x009612f6 ,
	0x00963e6b ,	0x00963a85 ,	0x00964277 ,	0x00960ecf ,
	0x00963274 ,	0x00964ded ,	0x00966404 ,	0x00960029 ,
	0x00964823 ,	0x009618be ,	0x00966784 ,	0x00964ae1 ,
	0x00963d6c ,	0x00962cd6 ,	0x009672ae ,	0x00966952 ,
	0x00965f90 ,	0x00961649 ,	0x00966df1 ,	0x00965af1 ,
	0x009641bb ,	0x009626e9 ,	0x009601eb ,	0x00960bb3 ,
	0x00962ea6 ,	0x009612db ,	0x0096153c ,	0x00967e87 ,
	0x0096390c ,	0x00960f3e ,	0x00960099 ,	0x00960124 ,
	0x0096305e ,	0x0096440d ,	0x0096491c ,	0x00964d06 ,
	0x00964db7 ,	0x00961547 ,	0x009654de ,	0x009639b3 ,
	0x00962d12 ,	0x0096074d ,	0x00964dc8 ,	0x00966443 ,
	0x009666bb ,	0x0096428b ,	0x009626a6 ,	0x0096701f ,
	0x00965d03 ,	0x00967a5a ,	0x0096767d ,	0x00964509 ,
	0x00961238 ,	0x00963b25 ,	0x00961e1f ,	0x00966e5d ,
	0x00961ad4 ,	0x009663cb ,	0x00966bfc ,	0x00967f96 ,
	0x00967ff5 ,	0x00964e45 ,	0x0096323b ,	0x00962213 ,
	0x0096260d ,	0x00966b89 ,	0x0096030a ,	0x0096301c ,
	0x00960bdb ,	0x009656ae ,	0x00960732 ,	0x00960120 ,
	0x0096759a ,	0x00962350 ,	0x009622ee ,	0x00964b40 ,
	0x00965878 ,	0x00966b36 ,	0x00965cfd ,	0x00963e12 ,
	0x00961a49 ,	0x00965f32 ,	0x00963bf6 ,	0x00963a9e ,
	0x0096797d ,	0x00965f49 ,	0x00960ddc ,	0x00964cad ,
	0x0096314f ,	0x00965e14 ,	0x00964df2 ,	0x00964944 ,
	0x00962e40 ,	0x00961366 ,	0x00961cd0 ,	0x0096366b ,
	0x009666c4 ,	0x00964230 ,	0x00967eb7 ,	0x00966032 ,
	0x00962c3b ,	0x009615a1 ,	0x00965422 ,	0x00963ef6 ,
	0x00960822 ,	0x00965991 ,	0x0096409d ,    0x00961101 ,

	0x00977f9b ,	0x009718e5 ,	0x00977485 ,	0x0097781c ,
	0x00974328 ,	0x009754fb ,	0x00972948 ,	0x00972702 ,
	0x00973623 ,	0x00974744 ,	0x00971209 ,	0x00974a32 ,
	0x00975f7d ,	0x009710b5 ,	0x00976a73 ,	0x009712f6 ,
	0x00973e6b ,	0x00973a85 ,	0x00974277 ,	0x00970ecf ,
	0x00973274 ,	0x00974ded ,	0x00976404 ,	0x00970029 ,
	0x00974823 ,	0x009718be ,	0x00976784 ,	0x00974ae1 ,
	0x00973d6c ,	0x00972cd6 ,	0x009772ae ,	0x00976952 ,
	0x00975f90 ,	0x00971649 ,	0x00976df1 ,	0x00975af1 ,
	0x009741bb ,	0x009726e9 ,	0x009701eb ,	0x00970bb3 ,
	0x00972ea6 ,	0x009712db ,	0x0097153c ,	0x00977e87 ,
	0x0097390c ,	0x00970f3e ,	0x00970099 ,	0x00970124 ,
	0x0097305e ,	0x0097440d ,	0x0097491c ,	0x00974d06 ,
	0x00974db7 ,	0x00971547 ,	0x009754de ,	0x009739b3 ,
	0x00972d12 ,	0x0097074d ,	0x00974dc8 ,	0x00976443 ,
	0x009766bb ,	0x0097428b ,	0x009726a6 ,	0x0097701f ,
	0x00975d03 ,	0x00977a5a ,	0x0097767d ,	0x00974509 ,
	0x00971238 ,	0x00973b25 ,	0x00971e1f ,	0x00976e5d ,
	0x00971ad4 ,	0x009763cb ,	0x00976bfc ,	0x00977f96 ,
	0x00977ff5 ,	0x00974e45 ,	0x0097323b ,	0x00972213 ,
	0x0097260d ,	0x00976b89 ,	0x0097030a ,	0x0097301c ,
	0x00970bdb ,	0x009756ae ,	0x00970732 ,	0x00970120 ,
	0x0097759a ,	0x00972350 ,	0x009722ee ,	0x00974b40 ,
	0x00975878 ,	0x00976b36 ,	0x00975cfd ,	0x00973e12 ,
	0x00971a49 ,	0x00975f32 ,	0x00973bf6 ,	0x00973a9e ,
	0x0097797d ,	0x00975f49 ,	0x00970ddc ,	0x00974cad ,
	0x0097314f ,	0x00975e14 ,	0x00974df2 ,	0x00974944 ,
	0x00972e40 ,	0x00971366 ,	0x00971cd0 ,	0x0097366b ,
	0x009766c4 ,	0x00974230 ,	0x00977eb7 ,	0x00976032 ,
	0x00972c3b ,	0x009715a1 ,	0x00975422 ,	0x00973ef6 ,
	0x00970822 ,	0x00975991 ,	0x0097409d ,    0x00971101 ,

	0x00987f9b ,	0x009818e5 ,	0x00987485 ,	0x0098781c ,
	0x00984328 ,	0x009854fb ,	0x00982948 ,	0x00982702 ,
	0x00983623 ,	0x00984744 ,	0x00981209 ,	0x00984a32 ,
	0x00985f7d ,	0x009810b5 ,	0x00986a73 ,	0x009812f6 ,
	0x00983e6b ,	0x00983a85 ,	0x00984277 ,	0x00980ecf ,
	0x00983274 ,	0x00984ded ,	0x00986404 ,	0x00980029 ,
	0x00984823 ,	0x009818be ,	0x00986784 ,	0x00984ae1 ,
	0x00983d6c ,	0x00982cd6 ,	0x009872ae ,	0x00986952 ,
	0x00985f90 ,	0x00981649 ,	0x00986df1 ,	0x00985af1 ,
	0x009841bb ,	0x009826e9 ,	0x009801eb ,	0x00980bb3 ,
	0x00982ea6 ,	0x009812db ,	0x0098153c ,	0x00987e87 ,
	0x0098390c ,	0x00980f3e ,	0x00980099 ,	0x00980124 ,
	0x0098305e ,	0x0098440d ,	0x0098491c ,	0x00984d06 ,
	0x00984db7 ,	0x00981547 ,	0x009854de ,	0x009839b3 ,
	0x00982d12 ,	0x0098074d ,	0x00984dc8 ,	0x00986443 ,
	0x009866bb ,	0x0098428b ,	0x009826a6 ,	0x0098701f ,
	0x00985d03 ,	0x00987a5a ,	0x0098767d ,	0x00984509 ,
	0x00981238 ,	0x00983b25 ,	0x00981e1f ,	0x00986e5d ,
	0x00981ad4 ,	0x009863cb ,	0x00986bfc ,	0x00987f96 ,
	0x00987ff5 ,	0x00984e45 ,	0x0098323b ,	0x00982213 ,
	0x0098260d ,	0x00986b89 ,	0x0098030a ,	0x0098301c ,
	0x00980bdb ,	0x009856ae ,	0x00980732 ,	0x00980120 ,
	0x0098759a ,	0x00982350 ,	0x009822ee ,	0x00984b40 ,
	0x00985878 ,	0x00986b36 ,	0x00985cfd ,	0x00983e12 ,
	0x00981a49 ,	0x00985f32 ,	0x00983bf6 ,	0x00983a9e ,
	0x0098797d ,	0x00985f49 ,	0x00980ddc ,	0x00984cad ,
	0x0098314f ,	0x00985e14 ,	0x00984df2 ,	0x00984944 ,
	0x00982e40 ,	0x00981366 ,	0x00981cd0 ,	0x0098366b ,
	0x009866c4 ,	0x00984230 ,	0x00987eb7 ,	0x00986032 ,
	0x00982c3b ,	0x009815a1 ,	0x00985422 ,	0x00983ef6 ,
	0x00980822 ,	0x00985991 ,	0x0098409d ,    0x00981101 ,

	0x00997f9b ,	0x009918e5 ,	0x00997485 ,	0x0099781c ,
	0x00994328 ,	0x009954fb ,	0x00992948 ,	0x00992702 ,
	0x00993623 ,	0x00994744 ,	0x00991209 ,	0x00994a32 ,
	0x00995f7d ,	0x009910b5 ,	0x00996a73 ,	0x009912f6 ,
	0x00993e6b ,	0x00993a85 ,	0x00994277 ,	0x00990ecf ,
	0x00993274 ,	0x00994ded ,	0x00996404 ,	0x00990029 ,
	0x00994823 ,	0x009918be ,	0x00996784 ,	0x00994ae1 ,
	0x00993d6c ,	0x00992cd6 ,	0x009972ae ,	0x00996952 ,
	0x00995f90 ,	0x00991649 ,	0x00996df1 ,	0x00995af1 ,
	0x009941bb ,	0x009926e9 ,	0x009901eb ,	0x00990bb3 ,
	0x00992ea6 ,	0x009912db ,	0x0099153c ,	0x00997e87 ,
	0x0099390c ,	0x00990f3e ,	0x00990099 ,	0x00990124 ,
	0x0099305e ,	0x0099440d ,	0x0099491c ,	0x00994d06 ,
	0x00994db7 ,	0x00991547 ,	0x009954de ,	0x009939b3 ,
	0x00992d12 ,	0x0099074d ,	0x00994dc8 ,	0x00996443 ,
	0x009966bb ,	0x0099428b ,	0x009926a6 ,	0x0099701f ,
	0x00995d03 ,	0x00997a5a ,	0x0099767d ,	0x00994509 ,
	0x00991238 ,	0x00993b25 ,	0x00991e1f ,	0x00996e5d ,
	0x00991ad4 ,	0x009963cb ,	0x00996bfc ,	0x00997f96 ,
	0x00997ff5 ,	0x00994e45 ,	0x0099323b ,	0x00992213 ,
	0x0099260d ,	0x00996b89 ,	0x0099030a ,	0x0099301c ,
	0x00990bdb ,	0x009956ae ,	0x00990732 ,	0x00990120 ,
	0x0099759a ,	0x00992350 ,	0x009922ee ,	0x00994b40 ,
	0x00995878 ,	0x00996b36 ,	0x00995cfd ,	0x00993e12 ,
	0x00991a49 ,	0x00995f32 ,	0x00993bf6 ,	0x00993a9e ,
	0x0099797d ,	0x00995f49 ,	0x00990ddc ,	0x00994cad ,
	0x0099314f ,	0x00995e14 ,	0x00994df2 ,	0x00994944 ,
	0x00992e40 ,	0x00991366 ,	0x00991cd0 ,	0x0099366b ,
	0x009966c4 ,	0x00994230 ,	0x00997eb7 ,	0x00996032 ,
	0x00992c3b ,	0x009915a1 ,	0x00995422 ,	0x00993ef6 ,
	0x00990822 ,	0x00995991 ,	0x0099409d ,    0x00991101 ,

	0x01007f9b ,	0x010018e5 ,	0x01007485 ,	0x0100781c ,
	0x01004328 ,	0x010054fb ,	0x01002948 ,	0x01002702 ,
	0x01003623 ,	0x01004744 ,	0x01001209 ,	0x01004a32 ,
	0x01005f7d ,	0x010010b5 ,	0x01006a73 ,	0x010012f6 ,
	0x01003e6b ,	0x01003a85 ,	0x01004277 ,	0x01000ecf ,
	0x01003274 ,	0x01004ded ,	0x01006404 ,	0x01000029 ,
	0x01004823 ,	0x010018be ,	0x01006784 ,	0x01004ae1 ,
	0x01003d6c ,	0x01002cd6 ,	0x010072ae ,	0x01006952 ,
	0x01005f90 ,	0x01001649 ,	0x01006df1 ,	0x01005af1 ,
	0x010041bb ,	0x010026e9 ,	0x010001eb ,	0x01000bb3 ,
	0x01002ea6 ,	0x010012db ,	0x0100153c ,	0x01007e87 ,
	0x0100390c ,	0x01000f3e ,	0x01000099 ,	0x01000124 ,
	0x0100305e ,	0x0100440d ,	0x0100491c ,	0x01004d06 ,
	0x01004db7 ,	0x01001547 ,	0x010054de ,	0x010039b3 ,
	0x01002d12 ,	0x0100074d ,	0x01004dc8 ,	0x01006443 ,
	0x010066bb ,	0x0100428b ,	0x010026a6 ,	0x0100701f ,
	0x01005d03 ,	0x01007a5a ,	0x0100767d ,	0x01004509 ,
	0x01001238 ,	0x01003b25 ,	0x01001e1f ,	0x01006e5d ,
	0x01001ad4 ,	0x010063cb ,	0x01006bfc ,	0x01007f96 ,
	0x01007ff5 ,	0x01004e45 ,	0x0100323b ,	0x01002213 ,
	0x0100260d ,	0x01006b89 ,	0x0100030a ,	0x0100301c ,
	0x01000bdb ,	0x010056ae ,	0x01000732 ,	0x01000120 ,
	0x0100759a ,	0x01002350 ,	0x010022ee ,	0x01004b40 ,
	0x01005878 ,	0x01006b36 ,	0x01005cfd ,	0x01003e12 ,
	0x01001a49 ,	0x01005f32 ,	0x01003bf6 ,	0x01003a9e ,
	0x0100797d ,	0x01005f49 ,	0x01000ddc ,	0x01004cad ,
	0x0100314f ,	0x01005e14 ,	0x01004df2 ,	0x01004944 ,
	0x01002e40 ,	0x01001366 ,	0x01001cd0 ,	0x0100366b ,
	0x010066c4 ,	0x01004230 ,	0x01007eb7 ,	0x01006032 ,
	0x01002c3b ,	0x010015a1 ,	0x01005422 ,	0x01003ef6 ,
	0x01000822 ,	0x01005991 ,	0x0100409d ,    0x01001101 ,

	0x01017f9b ,	0x010118e5 ,	0x01017485 ,	0x0101781c ,
	0x01014328 ,	0x010154fb ,	0x01012948 ,	0x01012702 ,
	0x01013623 ,	0x01014744 ,	0x01011209 ,	0x01014a32 ,
	0x01015f7d ,	0x010110b5 ,	0x01016a73 ,	0x010112f6 ,
	0x01013e6b ,	0x01013a85 ,	0x01014277 ,	0x01010ecf ,
	0x01013274 ,	0x01014ded ,	0x01016404 ,	0x01010029 ,
	0x01014823 ,	0x010118be ,	0x01016784 ,	0x01014ae1 ,
	0x01013d6c ,	0x01012cd6 ,	0x010172ae ,	0x01016952 ,
	0x01015f90 ,	0x01011649 ,	0x01016df1 ,	0x01015af1 ,
	0x010141bb ,	0x010126e9 ,	0x010101eb ,	0x01010bb3 ,
	0x01012ea6 ,	0x010112db ,	0x0101153c ,	0x01017e87 ,
	0x0101390c ,	0x01010f3e ,	0x01010099 ,	0x01010124 ,
	0x0101305e ,	0x0101440d ,	0x0101491c ,	0x01014d06 ,
	0x01014db7 ,	0x01011547 ,	0x010154de ,	0x010139b3 ,
	0x01012d12 ,	0x0101074d ,	0x01014dc8 ,	0x01016443 ,
	0x010166bb ,	0x0101428b ,	0x010126a6 ,	0x0101701f ,
	0x01015d03 ,	0x01017a5a ,	0x0101767d ,	0x01014509 ,
	0x01011238 ,	0x01013b25 ,	0x01011e1f ,	0x01016e5d ,
	0x01011ad4 ,	0x010163cb ,	0x01016bfc ,	0x01017f96 ,
	0x01017ff5 ,	0x01014e45 ,	0x0101323b ,	0x01012213 ,
	0x0101260d ,	0x01016b89 ,	0x0101030a ,	0x0101301c ,
	0x01010bdb ,	0x010156ae ,	0x01010732 ,	0x01010120 ,
	0x0101759a ,	0x01012350 ,	0x010122ee ,	0x01014b40 ,
	0x01015878 ,	0x01016b36 ,	0x01015cfd ,	0x01013e12 ,
	0x01011a49 ,	0x01015f32 ,	0x01013bf6 ,	0x01013a9e ,
	0x0101797d ,	0x01015f49 ,	0x01010ddc ,	0x01014cad ,
	0x0101314f ,	0x01015e14 ,	0x01014df2 ,	0x01014944 ,
	0x01012e40 ,	0x01011366 ,	0x01011cd0 ,	0x0101366b ,
	0x010166c4 ,	0x01014230 ,	0x01017eb7 ,	0x01016032 ,
	0x01012c3b ,	0x010115a1 ,	0x01015422 ,	0x01013ef6 ,
	0x01010822 ,	0x01015991 ,	0x0101409d ,    0x01011101 ,

	0x01027f9b ,	0x010218e5 ,	0x01027485 ,	0x0102781c ,
	0x01024328 ,	0x010254fb ,	0x01022948 ,	0x01022702 ,
	0x01023623 ,	0x01024744 ,	0x01021209 ,	0x01024a32 ,
	0x01025f7d ,	0x010210b5 ,	0x01026a73 ,	0x010212f6 ,
	0x01023e6b ,	0x01023a85 ,	0x01024277 ,	0x01020ecf ,
	0x01023274 ,	0x01024ded ,	0x01026404 ,	0x01020029 ,
	0x01024823 ,	0x010218be ,	0x01026784 ,	0x01024ae1 ,
	0x01023d6c ,	0x01022cd6 ,	0x010272ae ,	0x01026952 ,
	0x01025f90 ,	0x01021649 ,	0x01026df1 ,	0x01025af1 ,
	0x010241bb ,	0x010226e9 ,	0x010201eb ,	0x01020bb3 ,
	0x01022ea6 ,	0x010212db ,	0x0102153c ,	0x01027e87 ,
	0x0102390c ,	0x01020f3e ,	0x01020099 ,	0x01020124 ,
	0x0102305e ,	0x0102440d ,	0x0102491c ,	0x01024d06 ,
	0x01024db7 ,	0x01021547 ,	0x010254de ,	0x010239b3 ,
	0x01022d12 ,	0x0102074d ,	0x01024dc8 ,	0x01026443 ,
	0x010266bb ,	0x0102428b ,	0x010226a6 ,	0x0102701f ,
	0x01025d03 ,	0x01027a5a ,	0x0102767d ,	0x01024509 ,
	0x01021238 ,	0x01023b25 ,	0x01021e1f ,	0x01026e5d ,
	0x01021ad4 ,	0x010263cb ,	0x01026bfc ,	0x01027f96 ,
	0x01027ff5 ,	0x01024e45 ,	0x0102323b ,	0x01022213 ,
	0x0102260d ,	0x01026b89 ,	0x0102030a ,	0x0102301c ,
	0x01020bdb ,	0x010256ae ,	0x01020732 ,	0x01020120 ,
	0x0102759a ,	0x01022350 ,	0x010222ee ,	0x01024b40 ,
	0x01025878 ,	0x01026b36 ,	0x01025cfd ,	0x01023e12 ,
	0x01021a49 ,	0x01025f32 ,	0x01023bf6 ,	0x01023a9e ,
	0x0102797d ,	0x01025f49 ,	0x01020ddc ,	0x01024cad ,
	0x0102314f ,	0x01025e14 ,	0x01024df2 ,	0x01024944 ,
	0x01022e40 ,	0x01021366 ,	0x01021cd0 ,	0x0102366b ,
	0x010266c4 ,	0x01024230 ,	0x01027eb7 ,	0x01026032 ,
	0x01022c3b ,	0x010215a1 ,	0x01025422 ,	0x01023ef6 ,
	0x01020822 ,	0x01025991 ,	0x0102409d ,    0x01021101 ,

	0x01037f9b ,	0x010318e5 ,	0x01037485 ,	0x0103781c ,
	0x01034328 ,	0x010354fb ,	0x01032948 ,	0x01032702 ,
	0x01033623 ,	0x01034744 ,	0x01031209 ,	0x01034a32 ,
	0x01035f7d ,	0x010310b5 ,	0x01036a73 ,	0x010312f6 ,
	0x01033e6b ,	0x01033a85 ,	0x01034277 ,	0x01030ecf ,
	0x01033274 ,	0x01034ded ,	0x01036404 ,	0x01030029 ,
	0x01034823 ,	0x010318be ,	0x01036784 ,	0x01034ae1 ,
	0x01033d6c ,	0x01032cd6 ,	0x010372ae ,	0x01036952 ,
	0x01035f90 ,	0x01031649 ,	0x01036df1 ,	0x01035af1 ,
	0x010341bb ,	0x010326e9 ,	0x010301eb ,	0x01030bb3 ,
	0x01032ea6 ,	0x010312db ,	0x0103153c ,	0x01037e87 ,
	0x0103390c ,	0x01030f3e ,	0x01030099 ,	0x01030124 ,
	0x0103305e ,	0x0103440d ,	0x0103491c ,	0x01034d06 ,
	0x01034db7 ,	0x01031547 ,	0x010354de ,	0x010339b3 ,
	0x01032d12 ,	0x0103074d ,	0x01034dc8 ,	0x01036443 ,
	0x010366bb ,	0x0103428b ,	0x010326a6 ,	0x0103701f ,
	0x01035d03 ,	0x01037a5a ,	0x0103767d ,	0x01034509 ,
	0x01031238 ,	0x01033b25 ,	0x01031e1f ,	0x01036e5d ,
	0x01031ad4 ,	0x010363cb ,	0x01036bfc ,	0x01037f96 ,
	0x01037ff5 ,	0x01034e45 ,	0x0103323b ,	0x01032213 ,
	0x0103260d ,	0x01036b89 ,	0x0103030a ,	0x0103301c ,
	0x01030bdb ,	0x010356ae ,	0x01030732 ,	0x01030120 ,
	0x0103759a ,	0x01032350 ,	0x010322ee ,	0x01034b40 ,
	0x01035878 ,	0x01036b36 ,	0x01035cfd ,	0x01033e12 ,
	0x01031a49 ,	0x01035f32 ,	0x01033bf6 ,	0x01033a9e ,
	0x0103797d ,	0x01035f49 ,	0x01030ddc ,	0x01034cad ,
	0x0103314f ,	0x01035e14 ,	0x01034df2 ,	0x01034944 ,
	0x01032e40 ,	0x01031366 ,	0x01031cd0 ,	0x0103366b ,
	0x010366c4 ,	0x01034230 ,	0x01037eb7 ,	0x01036032 ,
	0x01032c3b ,	0x010315a1 ,	0x01035422 ,	0x01033ef6 ,
	0x01030822 ,	0x01035991 ,	0x0103409d ,    0x01031101 ,

	0x01047f9b ,	0x010418e5 ,	0x01047485 ,	0x0104781c ,
	0x01044328 ,	0x010454fb ,	0x01042948 ,	0x01042702 ,
	0x01043623 ,	0x01044744 ,	0x01041209 ,	0x01044a32 ,
	0x01045f7d ,	0x010410b5 ,	0x01046a73 ,	0x010412f6 ,
	0x01043e6b ,	0x01043a85 ,	0x01044277 ,	0x01040ecf ,
	0x01043274 ,	0x01044ded ,	0x01046404 ,	0x01040029 ,
	0x01044823 ,	0x010418be ,	0x01046784 ,	0x01044ae1 ,
	0x01043d6c ,	0x01042cd6 ,	0x010472ae ,	0x01046952 ,
	0x01045f90 ,	0x01041649 ,	0x01046df1 ,	0x01045af1 ,
	0x010441bb ,	0x010426e9 ,	0x010401eb ,	0x01040bb3 ,
	0x01042ea6 ,	0x010412db ,	0x0104153c ,	0x01047e87 ,
	0x0104390c ,	0x01040f3e ,	0x01040099 ,	0x01040124 ,
	0x0104305e ,	0x0104440d ,	0x0104491c ,	0x01044d06 ,
	0x01044db7 ,	0x01041547 ,	0x010454de ,	0x010439b3 ,
	0x01042d12 ,	0x0104074d ,	0x01044dc8 ,	0x01046443 ,
	0x010466bb ,	0x0104428b ,	0x010426a6 ,	0x0104701f ,
	0x01045d03 ,	0x01047a5a ,	0x0104767d ,	0x01044509 ,
	0x01041238 ,	0x01043b25 ,	0x01041e1f ,	0x01046e5d ,
	0x01041ad4 ,	0x010463cb ,	0x01046bfc ,	0x01047f96 ,
	0x01047ff5 ,	0x01044e45 ,	0x0104323b ,	0x01042213 ,
	0x0104260d ,	0x01046b89 ,	0x0104030a ,	0x0104301c ,
	0x01040bdb ,	0x010456ae ,	0x01040732 ,	0x01040120 ,
	0x0104759a ,	0x01042350 ,	0x010422ee ,	0x01044b40 ,
	0x01045878 ,	0x01046b36 ,	0x01045cfd ,	0x01043e12 ,
	0x01041a49 ,	0x01045f32 ,	0x01043bf6 ,	0x01043a9e ,
	0x0104797d ,	0x01045f49 ,	0x01040ddc ,	0x01044cad ,
	0x0104314f ,	0x01045e14 ,	0x01044df2 ,	0x01044944 ,
	0x01042e40 ,	0x01041366 ,	0x01041cd0 ,	0x0104366b ,
	0x010466c4 ,	0x01044230 ,	0x01047eb7 ,	0x01046032 ,
	0x01042c3b ,	0x010415a1 ,	0x01045422 ,	0x01043ef6 ,
	0x01040822 ,	0x01045991 ,	0x0104409d ,    0x01041101 ,

	0x01057f9b ,	0x010518e5 ,	0x01057485 ,	0x0105781c ,
	0x01054328 ,	0x010554fb ,	0x01052948 ,	0x01052702 ,
	0x01053623 ,	0x01054744 ,	0x01051209 ,	0x01054a32 ,
	0x01055f7d ,	0x010510b5 ,	0x01056a73 ,	0x010512f6 ,
	0x01053e6b ,	0x01053a85 ,	0x01054277 ,	0x01050ecf ,
	0x01053274 ,	0x01054ded ,	0x01056404 ,	0x01050029 ,
	0x01054823 ,	0x010518be ,	0x01056784 ,	0x01054ae1 ,
	0x01053d6c ,	0x01052cd6 ,	0x010572ae ,	0x01056952 ,
	0x01055f90 ,	0x01051649 ,	0x01056df1 ,	0x01055af1 ,
	0x010541bb ,	0x010526e9 ,	0x010501eb ,	0x01050bb3 ,
	0x01052ea6 ,	0x010512db ,	0x0105153c ,	0x01057e87 ,
	0x0105390c ,	0x01050f3e ,	0x01050099 ,	0x01050124 ,
	0x0105305e ,	0x0105440d ,	0x0105491c ,	0x01054d06 ,
	0x01054db7 ,	0x01051547 ,	0x010554de ,	0x010539b3 ,
	0x01052d12 ,	0x0105074d ,	0x01054dc8 ,	0x01056443 ,
	0x010566bb ,	0x0105428b ,	0x010526a6 ,	0x0105701f ,
	0x01055d03 ,	0x01057a5a ,	0x0105767d ,	0x01054509 ,
	0x01051238 ,	0x01053b25 ,	0x01051e1f ,	0x01056e5d ,
	0x01051ad4 ,	0x010563cb ,	0x01056bfc ,	0x01057f96 ,
	0x01057ff5 ,	0x01054e45 ,	0x0105323b ,	0x01052213 ,
	0x0105260d ,	0x01056b89 ,	0x0105030a ,	0x0105301c ,
	0x01050bdb ,	0x010556ae ,	0x01050732 ,	0x01050120 ,
	0x0105759a ,	0x01052350 ,	0x010522ee ,	0x01054b40 ,
	0x01055878 ,	0x01056b36 ,	0x01055cfd ,	0x01053e12 ,
	0x01051a49 ,	0x01055f32 ,	0x01053bf6 ,	0x01053a9e ,
	0x0105797d ,	0x01055f49 ,	0x01050ddc ,	0x01054cad ,
	0x0105314f ,	0x01055e14 ,	0x01054df2 ,	0x01054944 ,
	0x01052e40 ,	0x01051366 ,	0x01051cd0 ,	0x0105366b ,
	0x010566c4 ,	0x01054230 ,	0x01057eb7 ,	0x01056032 ,
	0x01052c3b ,	0x010515a1 ,	0x01055422 ,	0x01053ef6 ,
	0x01050822 ,	0x01055991 ,	0x0105409d ,    0x01051101 ,

	0x01067f9b ,	0x010618e5 ,	0x01067485 ,	0x0106781c ,
	0x01064328 ,	0x010654fb ,	0x01062948 ,	0x01062702 ,
	0x01063623 ,	0x01064744 ,	0x01061209 ,	0x01064a32 ,
	0x01065f7d ,	0x010610b5 ,	0x01066a73 ,	0x010612f6 ,
	0x01063e6b ,	0x01063a85 ,	0x01064277 ,	0x01060ecf ,
	0x01063274 ,	0x01064ded ,	0x01066404 ,	0x01060029 ,
	0x01064823 ,	0x010618be ,	0x01066784 ,	0x01064ae1 ,
	0x01063d6c ,	0x01062cd6 ,	0x010672ae ,	0x01066952 ,
	0x01065f90 ,	0x01061649 ,	0x01066df1 ,	0x01065af1 ,
	0x010641bb ,	0x010626e9 ,	0x010601eb ,	0x01060bb3 ,
	0x01062ea6 ,	0x010612db ,	0x0106153c ,	0x01067e87 ,
	0x0106390c ,	0x01060f3e ,	0x01060099 ,	0x01060124 ,
	0x0106305e ,	0x0106440d ,	0x0106491c ,	0x01064d06 ,
	0x01064db7 ,	0x01061547 ,	0x010654de ,	0x010639b3 ,
	0x01062d12 ,	0x0106074d ,	0x01064dc8 ,	0x01066443 ,
	0x010666bb ,	0x0106428b ,	0x010626a6 ,	0x0106701f ,
	0x01065d03 ,	0x01067a5a ,	0x0106767d ,	0x01064509 ,
	0x01061238 ,	0x01063b25 ,	0x01061e1f ,	0x01066e5d ,
	0x01061ad4 ,	0x010663cb ,	0x01066bfc ,	0x01067f96 ,
	0x01067ff5 ,	0x01064e45 ,	0x0106323b ,	0x01062213 ,
	0x0106260d ,	0x01066b89 ,	0x0106030a ,	0x0106301c ,
	0x01060bdb ,	0x010656ae ,	0x01060732 ,	0x01060120 ,
	0x0106759a ,	0x01062350 ,	0x010622ee ,	0x01064b40 ,
	0x01065878 ,	0x01066b36 ,	0x01065cfd ,	0x01063e12 ,
	0x01061a49 ,	0x01065f32 ,	0x01063bf6 ,	0x01063a9e ,
	0x0106797d ,	0x01065f49 ,	0x01060ddc ,	0x01064cad ,
	0x0106314f ,	0x01065e14 ,	0x01064df2 ,	0x01064944 ,
	0x01062e40 ,	0x01061366 ,	0x01061cd0 ,	0x0106366b ,
	0x010666c4 ,	0x01064230 ,	0x01067eb7 ,	0x01066032 ,
	0x01062c3b ,	0x010615a1 ,	0x01065422 ,	0x01063ef6 ,
	0x01060822 ,	0x01065991 ,	0x0106409d ,    0x01061101 ,

	0x01077f9b ,	0x010718e5 ,	0x01077485 ,	0x0107781c ,
	0x01074328 ,	0x010754fb ,	0x01072948 ,	0x01072702 ,
	0x01073623 ,	0x01074744 ,	0x01071209 ,	0x01074a32 ,
	0x01075f7d ,	0x010710b5 ,	0x01076a73 ,	0x010712f6 ,
	0x01073e6b ,	0x01073a85 ,	0x01074277 ,	0x01070ecf ,
	0x01073274 ,	0x01074ded ,	0x01076404 ,	0x01070029 ,
	0x01074823 ,	0x010718be ,	0x01076784 ,	0x01074ae1 ,
	0x01073d6c ,	0x01072cd6 ,	0x010772ae ,	0x01076952 ,
	0x01075f90 ,	0x01071649 ,	0x01076df1 ,	0x01075af1 ,
	0x010741bb ,	0x010726e9 ,	0x010701eb ,	0x01070bb3 ,
	0x01072ea6 ,	0x010712db ,	0x0107153c ,	0x01077e87 ,
	0x0107390c ,	0x01070f3e ,	0x01070099 ,	0x01070124 ,
	0x0107305e ,	0x0107440d ,	0x0107491c ,	0x01074d06 ,
	0x01074db7 ,	0x01071547 ,	0x010754de ,	0x010739b3 ,
	0x01072d12 ,	0x0107074d ,	0x01074dc8 ,	0x01076443 ,
	0x010766bb ,	0x0107428b ,	0x010726a6 ,	0x0107701f ,
	0x01075d03 ,	0x01077a5a ,	0x0107767d ,	0x01074509 ,
	0x01071238 ,	0x01073b25 ,	0x01071e1f ,	0x01076e5d ,
	0x01071ad4 ,	0x010763cb ,	0x01076bfc ,	0x01077f96 ,
	0x01077ff5 ,	0x01074e45 ,	0x0107323b ,	0x01072213 ,
	0x0107260d ,	0x01076b89 ,	0x0107030a ,	0x0107301c ,
	0x01070bdb ,	0x010756ae ,	0x01070732 ,	0x01070120 ,
	0x0107759a ,	0x01072350 ,	0x010722ee ,	0x01074b40 ,
	0x01075878 ,	0x01076b36 ,	0x01075cfd ,	0x01073e12 ,
	0x01071a49 ,	0x01075f32 ,	0x01073bf6 ,	0x01073a9e ,
	0x0107797d ,	0x01075f49 ,	0x01070ddc ,	0x01074cad ,
	0x0107314f ,	0x01075e14 ,	0x01074df2 ,	0x01074944 ,
	0x01072e40 ,	0x01071366 ,	0x01071cd0 ,	0x0107366b ,
	0x010766c4 ,	0x01074230 ,	0x01077eb7 ,	0x01076032 ,
	0x01072c3b ,	0x010715a1 ,	0x01075422 ,	0x01073ef6 ,
	0x01070822 ,	0x01075991 ,	0x0107409d ,    0x01071101 ,

	0x01087f9b ,	0x010818e5 ,	0x01087485 ,	0x0108781c ,
	0x01084328 ,	0x010854fb ,	0x01082948 ,	0x01082702 ,
	0x01083623 ,	0x01084744 ,	0x01081209 ,	0x01084a32 ,
	0x01085f7d ,	0x010810b5 ,	0x01086a73 ,	0x010812f6 ,
	0x01083e6b ,	0x01083a85 ,	0x01084277 ,	0x01080ecf ,
	0x01083274 ,	0x01084ded ,	0x01086404 ,	0x01080029 ,
	0x01084823 ,	0x010818be ,	0x01086784 ,	0x01084ae1 ,
	0x01083d6c ,	0x01082cd6 ,	0x010872ae ,	0x01086952 ,
	0x01085f90 ,	0x01081649 ,	0x01086df1 ,	0x01085af1 ,
	0x010841bb ,	0x010826e9 ,	0x010801eb ,	0x01080bb3 ,
	0x01082ea6 ,	0x010812db ,	0x0108153c ,	0x01087e87 ,
	0x0108390c ,	0x01080f3e ,	0x01080099 ,	0x01080124 ,
	0x0108305e ,	0x0108440d ,	0x0108491c ,	0x01084d06 ,
	0x01084db7 ,	0x01081547 ,	0x010854de ,	0x010839b3 ,
	0x01082d12 ,	0x0108074d ,	0x01084dc8 ,	0x01086443 ,
	0x010866bb ,	0x0108428b ,	0x010826a6 ,	0x0108701f ,
	0x01085d03 ,	0x01087a5a ,	0x0108767d ,	0x01084509 ,
	0x01081238 ,	0x01083b25 ,	0x01081e1f ,	0x01086e5d ,
	0x01081ad4 ,	0x010863cb ,	0x01086bfc ,	0x01087f96 ,
	0x01087ff5 ,	0x01084e45 ,	0x0108323b ,	0x01082213 ,
	0x0108260d ,	0x01086b89 ,	0x0108030a ,	0x0108301c ,
	0x01080bdb ,	0x010856ae ,	0x01080732 ,	0x01080120 ,
	0x0108759a ,	0x01082350 ,	0x010822ee ,	0x01084b40 ,
	0x01085878 ,	0x01086b36 ,	0x01085cfd ,	0x01083e12 ,
	0x01081a49 ,	0x01085f32 ,	0x01083bf6 ,	0x01083a9e ,
	0x0108797d ,	0x01085f49 ,	0x01080ddc ,	0x01084cad ,
	0x0108314f ,	0x01085e14 ,	0x01084df2 ,	0x01084944 ,
	0x01082e40 ,	0x01081366 ,	0x01081cd0 ,	0x0108366b ,
	0x010866c4 ,	0x01084230 ,	0x01087eb7 ,	0x01086032 ,
	0x01082c3b ,	0x010815a1 ,	0x01085422 ,	0x01083ef6 ,
	0x01080822 ,	0x01085991 ,	0x0108409d ,    0x01081101 ,

	0x01097f9b ,	0x010918e5 ,	0x01097485 ,	0x0109781c ,
	0x01094328 ,	0x010954fb ,	0x01092948 ,	0x01092702 ,
	0x01093623 ,	0x01094744 ,	0x01091209 ,	0x01094a32 ,
	0x01095f7d ,	0x010910b5 ,	0x01096a73 ,	0x010912f6 ,
	0x01093e6b ,	0x01093a85 ,	0x01094277 ,	0x01090ecf ,
	0x01093274 ,	0x01094ded ,	0x01096404 ,	0x01090029 ,
	0x01094823 ,	0x010918be ,	0x01096784 ,	0x01094ae1 ,
	0x01093d6c ,	0x01092cd6 ,	0x010972ae ,	0x01096952 ,
	0x01095f90 ,	0x01091649 ,	0x01096df1 ,	0x01095af1 ,
	0x010941bb ,	0x010926e9 ,	0x010901eb ,	0x01090bb3 ,
	0x01092ea6 ,	0x010912db ,	0x0109153c ,	0x01097e87 ,
	0x0109390c ,	0x01090f3e ,	0x01090099 ,	0x01090124 ,
	0x0109305e ,	0x0109440d ,	0x0109491c ,	0x01094d06 ,
	0x01094db7 ,	0x01091547 ,	0x010954de ,	0x010939b3 ,
	0x01092d12 ,	0x0109074d ,	0x01094dc8 ,	0x01096443 ,
	0x010966bb ,	0x0109428b ,	0x010926a6 ,	0x0109701f ,
	0x01095d03 ,	0x01097a5a ,	0x0109767d ,	0x01094509 ,
	0x01091238 ,	0x01093b25 ,	0x01091e1f ,	0x01096e5d ,
	0x01091ad4 ,	0x010963cb ,	0x01096bfc ,	0x01097f96 ,
	0x01097ff5 ,	0x01094e45 ,	0x0109323b ,	0x01092213 ,
	0x0109260d ,	0x01096b89 ,	0x0109030a ,	0x0109301c ,
	0x01090bdb ,	0x010956ae ,	0x01090732 ,	0x01090120 ,
	0x0109759a ,	0x01092350 ,	0x010922ee ,	0x01094b40 ,
	0x01095878 ,	0x01096b36 ,	0x01095cfd ,	0x01093e12 ,
	0x01091a49 ,	0x01095f32 ,	0x01093bf6 ,	0x01093a9e ,
	0x0109797d ,	0x01095f49 ,	0x01090ddc ,	0x01094cad ,
	0x0109314f ,	0x01095e14 ,	0x01094df2 ,	0x01094944 ,
	0x01092e40 ,	0x01091366 ,	0x01091cd0 ,	0x0109366b ,
	0x010966c4 ,	0x01094230 ,	0x01097eb7 ,	0x01096032 ,
	0x01092c3b ,	0x010915a1 ,	0x01095422 ,	0x01093ef6 ,
	0x01090822 ,	0x01095991 ,	0x0109409d ,    0x01091101 ,

	0x01107f9b ,	0x011018e5 ,	0x01107485 ,	0x0110781c ,
	0x01104328 ,	0x011054fb ,	0x01102948 ,	0x01102702 ,
	0x01103623 ,	0x01104744 ,	0x01101209 ,	0x01104a32 ,
	0x01105f7d ,	0x011010b5 ,	0x01106a73 ,	0x011012f6 ,
	0x01103e6b ,	0x01103a85 ,	0x01104277 ,	0x01100ecf ,
	0x01103274 ,	0x01104ded ,	0x01106404 ,	0x01100029 ,
	0x01104823 ,	0x011018be ,	0x01106784 ,	0x01104ae1 ,
	0x01103d6c ,	0x01102cd6 ,	0x011072ae ,	0x01106952 ,
	0x01105f90 ,	0x01101649 ,	0x01106df1 ,	0x01105af1 ,
	0x011041bb ,	0x011026e9 ,	0x011001eb ,	0x01100bb3 ,
	0x01102ea6 ,	0x011012db ,	0x0110153c ,	0x01107e87 ,
	0x0110390c ,	0x01100f3e ,	0x01100099 ,	0x01100124 ,
	0x0110305e ,	0x0110440d ,	0x0110491c ,	0x01104d06 ,
	0x01104db7 ,	0x01101547 ,	0x011054de ,	0x011039b3 ,
	0x01102d12 ,	0x0110074d ,	0x01104dc8 ,	0x01106443 ,
	0x011066bb ,	0x0110428b ,	0x011026a6 ,	0x0110701f ,
	0x01105d03 ,	0x01107a5a ,	0x0110767d ,	0x01104509 ,
	0x01101238 ,	0x01103b25 ,	0x01101e1f ,	0x01106e5d ,
	0x01101ad4 ,	0x011063cb ,	0x01106bfc ,	0x01107f96 ,
	0x01107ff5 ,	0x01104e45 ,	0x0110323b ,	0x01102213 ,
	0x0110260d ,	0x01106b89 ,	0x0110030a ,	0x0110301c ,
	0x01100bdb ,	0x011056ae ,	0x01100732 ,	0x01100120 ,
	0x0110759a ,	0x01102350 ,	0x011022ee ,	0x01104b40 ,
	0x01105878 ,	0x01106b36 ,	0x01105cfd ,	0x01103e12 ,
	0x01101a49 ,	0x01105f32 ,	0x01103bf6 ,	0x01103a9e ,
	0x0110797d ,	0x01105f49 ,	0x01100ddc ,	0x01104cad ,
	0x0110314f ,	0x01105e14 ,	0x01104df2 ,	0x01104944 ,
	0x01102e40 ,	0x01101366 ,	0x01101cd0 ,	0x0110366b ,
	0x011066c4 ,	0x01104230 ,	0x01107eb7 ,	0x01106032 ,
	0x01102c3b ,	0x011015a1 ,	0x01105422 ,	0x01103ef6 ,
	0x01100822 ,	0x01105991 ,	0x0110409d ,    0x01101101 ,

	0x01117f9b ,	0x011118e5 ,	0x01117485 ,	0x0111781c ,
	0x01114328 ,	0x011154fb ,	0x01112948 ,	0x01112702 ,
	0x01113623 ,	0x01114744 ,	0x01111209 ,	0x01114a32 ,
	0x01115f7d ,	0x011110b5 ,	0x01116a73 ,	0x011112f6 ,
	0x01113e6b ,	0x01113a85 ,	0x01114277 ,	0x01110ecf ,
	0x01113274 ,	0x01114ded ,	0x01116404 ,	0x01110029 ,
	0x01114823 ,	0x011118be ,	0x01116784 ,	0x01114ae1 ,
	0x01113d6c ,	0x01112cd6 ,	0x011172ae ,	0x01116952 ,
	0x01115f90 ,	0x01111649 ,	0x01116df1 ,	0x01115af1 ,
	0x011141bb ,	0x011126e9 ,	0x011101eb ,	0x01110bb3 ,
	0x01112ea6 ,	0x011112db ,	0x0111153c ,	0x01117e87 ,
	0x0111390c ,	0x01110f3e ,	0x01110099 ,	0x01110124 ,
	0x0111305e ,	0x0111440d ,	0x0111491c ,	0x01114d06 ,
	0x01114db7 ,	0x01111547 ,	0x011154de ,	0x011139b3 ,
	0x01112d12 ,	0x0111074d ,	0x01114dc8 ,	0x01116443 ,
	0x011166bb ,	0x0111428b ,	0x011126a6 ,	0x0111701f ,
	0x01115d03 ,	0x01117a5a ,	0x0111767d ,	0x01114509 ,
	0x01111238 ,	0x01113b25 ,	0x01111e1f ,	0x01116e5d ,
	0x01111ad4 ,	0x011163cb ,	0x01116bfc ,	0x01117f96 ,
	0x01117ff5 ,	0x01114e45 ,	0x0111323b ,	0x01112213 ,
	0x0111260d ,	0x01116b89 ,	0x0111030a ,	0x0111301c ,
	0x01110bdb ,	0x011156ae ,	0x01110732 ,	0x01110120 ,
	0x0111759a ,	0x01112350 ,	0x011122ee ,	0x01114b40 ,
	0x01115878 ,	0x01116b36 ,	0x01115cfd ,	0x01113e12 ,
	0x01111a49 ,	0x01115f32 ,	0x01113bf6 ,	0x01113a9e ,
	0x0111797d ,	0x01115f49 ,	0x01110ddc ,	0x01114cad ,
	0x0111314f ,	0x01115e14 ,	0x01114df2 ,	0x01114944 ,
	0x01112e40 ,	0x01111366 ,	0x01111cd0 ,	0x0111366b ,
	0x011166c4 ,	0x01114230 ,	0x01117eb7 ,	0x01116032 ,
	0x01112c3b ,	0x011115a1 ,	0x01115422 ,	0x01113ef6 ,
	0x01110822 ,	0x01115991 ,	0x0111409d ,    0x01111101 ,

	0x01127f9b ,	0x011218e5 ,	0x01127485 ,	0x0112781c ,
	0x01124328 ,	0x011254fb ,	0x01122948 ,	0x01122702 ,
	0x01123623 ,	0x01124744 ,	0x01121209 ,	0x01124a32 ,
	0x01125f7d ,	0x011210b5 ,	0x01126a73 ,	0x011212f6 ,
	0x01123e6b ,	0x01123a85 ,	0x01124277 ,	0x01120ecf ,
	0x01123274 ,	0x01124ded ,	0x01126404 ,	0x01120029 ,
	0x01124823 ,	0x011218be ,	0x01126784 ,	0x01124ae1 ,
	0x01123d6c ,	0x01122cd6 ,	0x011272ae ,	0x01126952 ,
	0x01125f90 ,	0x01121649 ,	0x01126df1 ,	0x01125af1 ,
	0x011241bb ,	0x011226e9 ,	0x011201eb ,	0x01120bb3 ,
	0x01122ea6 ,	0x011212db ,	0x0112153c ,	0x01127e87 ,
	0x0112390c ,	0x01120f3e ,	0x01120099 ,	0x01120124 ,
	0x0112305e ,	0x0112440d ,	0x0112491c ,	0x01124d06 ,
	0x01124db7 ,	0x01121547 ,	0x011254de ,	0x011239b3 ,
	0x01122d12 ,	0x0112074d ,	0x01124dc8 ,	0x01126443 ,
	0x011266bb ,	0x0112428b ,	0x011226a6 ,	0x0112701f ,
	0x01125d03 ,	0x01127a5a ,	0x0112767d ,	0x01124509 ,
	0x01121238 ,	0x01123b25 ,	0x01121e1f ,	0x01126e5d ,
	0x01121ad4 ,	0x011263cb ,	0x01126bfc ,	0x01127f96 ,
	0x01127ff5 ,	0x01124e45 ,	0x0112323b ,	0x01122213 ,
	0x0112260d ,	0x01126b89 ,	0x0112030a ,	0x0112301c ,
	0x01120bdb ,	0x011256ae ,	0x01120732 ,	0x01120120 ,
	0x0112759a ,	0x01122350 ,	0x011222ee ,	0x01124b40 ,
	0x01125878 ,	0x01126b36 ,	0x01125cfd ,	0x01123e12 ,
	0x01121a49 ,	0x01125f32 ,	0x01123bf6 ,	0x01123a9e ,
	0x0112797d ,	0x01125f49 ,	0x01120ddc ,	0x01124cad ,
	0x0112314f ,	0x01125e14 ,	0x01124df2 ,	0x01124944 ,
	0x01122e40 ,	0x01121366 ,	0x01121cd0 ,	0x0112366b ,
	0x011266c4 ,	0x01124230 ,	0x01127eb7 ,	0x01126032 ,
	0x01122c3b ,	0x011215a1 ,	0x01125422 ,	0x01123ef6 ,
	0x01120822 ,	0x01125991 ,	0x0112409d ,    0x01121101 ,

	0x01137f9b ,	0x011318e5 ,	0x01137485 ,	0x0113781c ,
	0x01134328 ,	0x011354fb ,	0x01132948 ,	0x01132702 ,
	0x01133623 ,	0x01134744 ,	0x01131209 ,	0x01134a32 ,
	0x01135f7d ,	0x011310b5 ,	0x01136a73 ,	0x011312f6 ,
	0x01133e6b ,	0x01133a85 ,	0x01134277 ,	0x01130ecf ,
	0x01133274 ,	0x01134ded ,	0x01136404 ,	0x01130029 ,
	0x01134823 ,	0x011318be ,	0x01136784 ,	0x01134ae1 ,
	0x01133d6c ,	0x01132cd6 ,	0x011372ae ,	0x01136952 ,
	0x01135f90 ,	0x01131649 ,	0x01136df1 ,	0x01135af1 ,
	0x011341bb ,	0x011326e9 ,	0x011301eb ,	0x01130bb3 ,
	0x01132ea6 ,	0x011312db ,	0x0113153c ,	0x01137e87 ,
	0x0113390c ,	0x01130f3e ,	0x01130099 ,	0x01130124 ,
	0x0113305e ,	0x0113440d ,	0x0113491c ,	0x01134d06 ,
	0x01134db7 ,	0x01131547 ,	0x011354de ,	0x011339b3 ,
	0x01132d12 ,	0x0113074d ,	0x01134dc8 ,	0x01136443 ,
	0x011366bb ,	0x0113428b ,	0x011326a6 ,	0x0113701f ,
	0x01135d03 ,	0x01137a5a ,	0x0113767d ,	0x01134509 ,
	0x01131238 ,	0x01133b25 ,	0x01131e1f ,	0x01136e5d ,
	0x01131ad4 ,	0x011363cb ,	0x01136bfc ,	0x01137f96 ,
	0x01137ff5 ,	0x01134e45 ,	0x0113323b ,	0x01132213 ,
	0x0113260d ,	0x01136b89 ,	0x0113030a ,	0x0113301c ,
	0x01130bdb ,	0x011356ae ,	0x01130732 ,	0x01130120 ,
	0x0113759a ,	0x01132350 ,	0x011322ee ,	0x01134b40 ,
	0x01135878 ,	0x01136b36 ,	0x01135cfd ,	0x01133e12 ,
	0x01131a49 ,	0x01135f32 ,	0x01133bf6 ,	0x01133a9e ,
	0x0113797d ,	0x01135f49 ,	0x01130ddc ,	0x01134cad ,
	0x0113314f ,	0x01135e14 ,	0x01134df2 ,	0x01134944 ,
	0x01132e40 ,	0x01131366 ,	0x01131cd0 ,	0x0113366b ,
	0x011366c4 ,	0x01134230 ,	0x01137eb7 ,	0x01136032 ,
	0x01132c3b ,	0x011315a1 ,	0x01135422 ,	0x01133ef6 ,
	0x01130822 ,	0x01135991 ,	0x0113409d ,    0x01131101 ,

	0x01147f9b ,	0x011418e5 ,	0x01147485 ,	0x0114781c ,
	0x01144328 ,	0x011454fb ,	0x01142948 ,	0x01142702 ,
	0x01143623 ,	0x01144744 ,	0x01141209 ,	0x01144a32 ,
	0x01145f7d ,	0x011410b5 ,	0x01146a73 ,	0x011412f6 ,
	0x01143e6b ,	0x01143a85 ,	0x01144277 ,	0x01140ecf ,
	0x01143274 ,	0x01144ded ,	0x01146404 ,	0x01140029 ,
	0x01144823 ,	0x011418be ,	0x01146784 ,	0x01144ae1 ,
	0x01143d6c ,	0x01142cd6 ,	0x011472ae ,	0x01146952 ,
	0x01145f90 ,	0x01141649 ,	0x01146df1 ,	0x01145af1 ,
	0x011441bb ,	0x011426e9 ,	0x011401eb ,	0x01140bb3 ,
	0x01142ea6 ,	0x011412db ,	0x0114153c ,	0x01147e87 ,
	0x0114390c ,	0x01140f3e ,	0x01140099 ,	0x01140124 ,
	0x0114305e ,	0x0114440d ,	0x0114491c ,	0x01144d06 ,
	0x01144db7 ,	0x01141547 ,	0x011454de ,	0x011439b3 ,
	0x01142d12 ,	0x0114074d ,	0x01144dc8 ,	0x01146443 ,
	0x011466bb ,	0x0114428b ,	0x011426a6 ,	0x0114701f ,
	0x01145d03 ,	0x01147a5a ,	0x0114767d ,	0x01144509 ,
	0x01141238 ,	0x01143b25 ,	0x01141e1f ,	0x01146e5d ,
	0x01141ad4 ,	0x011463cb ,	0x01146bfc ,	0x01147f96 ,
	0x01147ff5 ,	0x01144e45 ,	0x0114323b ,	0x01142213 ,
	0x0114260d ,	0x01146b89 ,	0x0114030a ,	0x0114301c ,
	0x01140bdb ,	0x011456ae ,	0x01140732 ,	0x01140120 ,
	0x0114759a ,	0x01142350 ,	0x011422ee ,	0x01144b40 ,
	0x01145878 ,	0x01146b36 ,	0x01145cfd ,	0x01143e12 ,
	0x01141a49 ,	0x01145f32 ,	0x01143bf6 ,	0x01143a9e ,
	0x0114797d ,	0x01145f49 ,	0x01140ddc ,	0x01144cad ,
	0x0114314f ,	0x01145e14 ,	0x01144df2 ,	0x01144944 ,
	0x01142e40 ,	0x01141366 ,	0x01141cd0 ,	0x0114366b ,
	0x011466c4 ,	0x01144230 ,	0x01147eb7 ,	0x01146032 ,
	0x01142c3b ,	0x011415a1 ,	0x01145422 ,	0x01143ef6 ,
	0x01140822 ,	0x01145991 ,	0x0114409d ,    0x01141101 ,

	0x01157f9b ,	0x011518e5 ,	0x01157485 ,	0x0115781c ,
	0x01154328 ,	0x011554fb ,	0x01152948 ,	0x01152702 ,
	0x01153623 ,	0x01154744 ,	0x01151209 ,	0x01154a32 ,
	0x01155f7d ,	0x011510b5 ,	0x01156a73 ,	0x011512f6 ,
	0x01153e6b ,	0x01153a85 ,	0x01154277 ,	0x01150ecf ,
	0x01153274 ,	0x01154ded ,	0x01156404 ,	0x01150029 ,
	0x01154823 ,	0x011518be ,	0x01156784 ,	0x01154ae1 ,
	0x01153d6c ,	0x01152cd6 ,	0x011572ae ,	0x01156952 ,
	0x01155f90 ,	0x01151649 ,	0x01156df1 ,	0x01155af1 ,
	0x011541bb ,	0x011526e9 ,	0x011501eb ,	0x01150bb3 ,
	0x01152ea6 ,	0x011512db ,	0x0115153c ,	0x01157e87 ,
	0x0115390c ,	0x01150f3e ,	0x01150099 ,	0x01150124 ,
	0x0115305e ,	0x0115440d ,	0x0115491c ,	0x01154d06 ,
	0x01154db7 ,	0x01151547 ,	0x011554de ,	0x011539b3 ,
	0x01152d12 ,	0x0115074d ,	0x01154dc8 ,	0x01156443 ,
	0x011566bb ,	0x0115428b ,	0x011526a6 ,	0x0115701f ,
	0x01155d03 ,	0x01157a5a ,	0x0115767d ,	0x01154509 ,
	0x01151238 ,	0x01153b25 ,	0x01151e1f ,	0x01156e5d ,
	0x01151ad4 ,	0x011563cb ,	0x01156bfc ,	0x01157f96 ,
	0x01157ff5 ,	0x01154e45 ,	0x0115323b ,	0x01152213 ,
	0x0115260d ,	0x01156b89 ,	0x0115030a ,	0x0115301c ,
	0x01150bdb ,	0x011556ae ,	0x01150732 ,	0x01150120 ,
	0x0115759a ,	0x01152350 ,	0x011522ee ,	0x01154b40 ,
	0x01155878 ,	0x01156b36 ,	0x01155cfd ,	0x01153e12 ,
	0x01151a49 ,	0x01155f32 ,	0x01153bf6 ,	0x01153a9e ,
	0x0115797d ,	0x01155f49 ,	0x01150ddc ,	0x01154cad ,
	0x0115314f ,	0x01155e14 ,	0x01154df2 ,	0x01154944 ,
	0x01152e40 ,	0x01151366 ,	0x01151cd0 ,	0x0115366b ,
	0x011566c4 ,	0x01154230 ,	0x01157eb7 ,	0x01156032 ,
	0x01152c3b ,	0x011515a1 ,	0x01155422 ,	0x01153ef6 ,
	0x01150822 ,	0x01155991 ,	0x0115409d ,    0x01151101 ,

	0x01167f9b ,	0x011618e5 ,	0x01167485 ,	0x0116781c ,
	0x01164328 ,	0x011654fb ,	0x01162948 ,	0x01162702 ,
	0x01163623 ,	0x01164744 ,	0x01161209 ,	0x01164a32 ,
	0x01165f7d ,	0x011610b5 ,	0x01166a73 ,	0x011612f6 ,
	0x01163e6b ,	0x01163a85 ,	0x01164277 ,	0x01160ecf ,
	0x01163274 ,	0x01164ded ,	0x01166404 ,	0x01160029 ,
	0x01164823 ,	0x011618be ,	0x01166784 ,	0x01164ae1 ,
	0x01163d6c ,	0x01162cd6 ,	0x011672ae ,	0x01166952 ,
	0x01165f90 ,	0x01161649 ,	0x01166df1 ,	0x01165af1 ,
	0x011641bb ,	0x011626e9 ,	0x011601eb ,	0x01160bb3 ,
	0x01162ea6 ,	0x011612db ,	0x0116153c ,	0x01167e87 ,
	0x0116390c ,	0x01160f3e ,	0x01160099 ,	0x01160124 ,
	0x0116305e ,	0x0116440d ,	0x0116491c ,	0x01164d06 ,
	0x01164db7 ,	0x01161547 ,	0x011654de ,	0x011639b3 ,
	0x01162d12 ,	0x0116074d ,	0x01164dc8 ,	0x01166443 ,
	0x011666bb ,	0x0116428b ,	0x011626a6 ,	0x0116701f ,
	0x01165d03 ,	0x01167a5a ,	0x0116767d ,	0x01164509 ,
	0x01161238 ,	0x01163b25 ,	0x01161e1f ,	0x01166e5d ,
	0x01161ad4 ,	0x011663cb ,	0x01166bfc ,	0x01167f96 ,
	0x01167ff5 ,	0x01164e45 ,	0x0116323b ,	0x01162213 ,
	0x0116260d ,	0x01166b89 ,	0x0116030a ,	0x0116301c ,
	0x01160bdb ,	0x011656ae ,	0x01160732 ,	0x01160120 ,
	0x0116759a ,	0x01162350 ,	0x011622ee ,	0x01164b40 ,
	0x01165878 ,	0x01166b36 ,	0x01165cfd ,	0x01163e12 ,
	0x01161a49 ,	0x01165f32 ,	0x01163bf6 ,	0x01163a9e ,
	0x0116797d ,	0x01165f49 ,	0x01160ddc ,	0x01164cad ,
	0x0116314f ,	0x01165e14 ,	0x01164df2 ,	0x01164944 ,
	0x01162e40 ,	0x01161366 ,	0x01161cd0 ,	0x0116366b ,
	0x011666c4 ,	0x01164230 ,	0x01167eb7 ,	0x01166032 ,
	0x01162c3b ,	0x011615a1 ,	0x01165422 ,	0x01163ef6 ,
	0x01160822 ,	0x01165991 ,	0x0116409d ,    0x01161101 ,

	0x01177f9b ,	0x011718e5 ,	0x01177485 ,	0x0117781c ,
	0x01174328 ,	0x011754fb ,	0x01172948 ,	0x01172702 ,
	0x01173623 ,	0x01174744 ,	0x01171209 ,	0x01174a32 ,
	0x01175f7d ,	0x011710b5 ,	0x01176a73 ,	0x011712f6 ,
	0x01173e6b ,	0x01173a85 ,	0x01174277 ,	0x01170ecf ,
	0x01173274 ,	0x01174ded ,	0x01176404 ,	0x01170029 ,
	0x01174823 ,	0x011718be ,	0x01176784 ,	0x01174ae1 ,
	0x01173d6c ,	0x01172cd6 ,	0x011772ae ,	0x01176952 ,
	0x01175f90 ,	0x01171649 ,	0x01176df1 ,	0x01175af1 ,
	0x011741bb ,	0x011726e9 ,	0x011701eb ,	0x01170bb3 ,
	0x01172ea6 ,	0x011712db ,	0x0117153c ,	0x01177e87 ,
	0x0117390c ,	0x01170f3e ,	0x01170099 ,	0x01170124 ,
	0x0117305e ,	0x0117440d ,	0x0117491c ,	0x01174d06 ,
	0x01174db7 ,	0x01171547 ,	0x011754de ,	0x011739b3 ,
	0x01172d12 ,	0x0117074d ,	0x01174dc8 ,	0x01176443 ,
	0x011766bb ,	0x0117428b ,	0x011726a6 ,	0x0117701f ,
	0x01175d03 ,	0x01177a5a ,	0x0117767d ,	0x01174509 ,
	0x01171238 ,	0x01173b25 ,	0x01171e1f ,	0x01176e5d ,
	0x01171ad4 ,	0x011763cb ,	0x01176bfc ,	0x01177f96 ,
	0x01177ff5 ,	0x01174e45 ,	0x0117323b ,	0x01172213 ,
	0x0117260d ,	0x01176b89 ,	0x0117030a ,	0x0117301c ,
	0x01170bdb ,	0x011756ae ,	0x01170732 ,	0x01170120 ,
	0x0117759a ,	0x01172350 ,	0x011722ee ,	0x01174b40 ,
	0x01175878 ,	0x01176b36 ,	0x01175cfd ,	0x01173e12 ,
	0x01171a49 ,	0x01175f32 ,	0x01173bf6 ,	0x01173a9e ,
	0x0117797d ,	0x01175f49 ,	0x01170ddc ,	0x01174cad ,
	0x0117314f ,	0x01175e14 ,	0x01174df2 ,	0x01174944 ,
	0x01172e40 ,	0x01171366 ,	0x01171cd0 ,	0x0117366b ,
	0x011766c4 ,	0x01174230 ,	0x01177eb7 ,	0x01176032 ,
	0x01172c3b ,	0x011715a1 ,	0x01175422 ,	0x01173ef6 ,
	0x01170822 ,	0x01175991 ,	0x0117409d ,    0x01171101 ,

	0x01187f9b ,	0x011818e5 ,	0x01187485 ,	0x0118781c ,
	0x01184328 ,	0x011854fb ,	0x01182948 ,	0x01182702 ,
	0x01183623 ,	0x01184744 ,	0x01181209 ,	0x01184a32 ,
	0x01185f7d ,	0x011810b5 ,	0x01186a73 ,	0x011812f6 ,
	0x01183e6b ,	0x01183a85 ,	0x01184277 ,	0x01180ecf ,
	0x01183274 ,	0x01184ded ,	0x01186404 ,	0x01180029 ,
	0x01184823 ,	0x011818be ,	0x01186784 ,	0x01184ae1 ,
	0x01183d6c ,	0x01182cd6 ,	0x011872ae ,	0x01186952 ,
	0x01185f90 ,	0x01181649 ,	0x01186df1 ,	0x01185af1 ,
	0x011841bb ,	0x011826e9 ,	0x011801eb ,	0x01180bb3 ,
	0x01182ea6 ,	0x011812db ,	0x0118153c ,	0x01187e87 ,
	0x0118390c ,	0x01180f3e ,	0x01180099 ,	0x01180124 ,
	0x0118305e ,	0x0118440d ,	0x0118491c ,	0x01184d06 ,
	0x01184db7 ,	0x01181547 ,	0x011854de ,	0x011839b3 ,
	0x01182d12 ,	0x0118074d ,	0x01184dc8 ,	0x01186443 ,
	0x011866bb ,	0x0118428b ,	0x011826a6 ,	0x0118701f ,
	0x01185d03 ,	0x01187a5a ,	0x0118767d ,	0x01184509 ,
	0x01181238 ,	0x01183b25 ,	0x01181e1f ,	0x01186e5d ,
	0x01181ad4 ,	0x011863cb ,	0x01186bfc ,	0x01187f96 ,
	0x01187ff5 ,	0x01184e45 ,	0x0118323b ,	0x01182213 ,
	0x0118260d ,	0x01186b89 ,	0x0118030a ,	0x0118301c ,
	0x01180bdb ,	0x011856ae ,	0x01180732 ,	0x01180120 ,
	0x0118759a ,	0x01182350 ,	0x011822ee ,	0x01184b40 ,
	0x01185878 ,	0x01186b36 ,	0x01185cfd ,	0x01183e12 ,
	0x01181a49 ,	0x01185f32 ,	0x01183bf6 ,	0x01183a9e ,
	0x0118797d ,	0x01185f49 ,	0x01180ddc ,	0x01184cad ,
	0x0118314f ,	0x01185e14 ,	0x01184df2 ,	0x01184944 ,
	0x01182e40 ,	0x01181366 ,	0x01181cd0 ,	0x0118366b ,
	0x011866c4 ,	0x01184230 ,	0x01187eb7 ,	0x01186032 ,
	0x01182c3b ,	0x011815a1 ,	0x01185422 ,	0x01183ef6 ,
	0x01180822 ,	0x01185991 ,	0x0118409d ,    0x01181101 ,

	0x01197f9b ,	0x011918e5 ,	0x01197485 ,	0x0119781c ,
	0x01194328 ,	0x011954fb ,	0x01192948 ,	0x01192702 ,
	0x01193623 ,	0x01194744 ,	0x01191209 ,	0x01194a32 ,
	0x01195f7d ,	0x011910b5 ,	0x01196a73 ,	0x011912f6 ,
	0x01193e6b ,	0x01193a85 ,	0x01194277 ,	0x01190ecf ,
	0x01193274 ,	0x01194ded ,	0x01196404 ,	0x01190029 ,
	0x01194823 ,	0x011918be ,	0x01196784 ,	0x01194ae1 ,
	0x01193d6c ,	0x01192cd6 ,	0x011972ae ,	0x01196952 ,
	0x01195f90 ,	0x01191649 ,	0x01196df1 ,	0x01195af1 ,
	0x011941bb ,	0x011926e9 ,	0x011901eb ,	0x01190bb3 ,
	0x01192ea6 ,	0x011912db ,	0x0119153c ,	0x01197e87 ,
	0x0119390c ,	0x01190f3e ,	0x01190099 ,	0x01190124 ,
	0x0119305e ,	0x0119440d ,	0x0119491c ,	0x01194d06 ,
	0x01194db7 ,	0x01191547 ,	0x011954de ,	0x011939b3 ,
	0x01192d12 ,	0x0119074d ,	0x01194dc8 ,	0x01196443 ,
	0x011966bb ,	0x0119428b ,	0x011926a6 ,	0x0119701f ,
	0x01195d03 ,	0x01197a5a ,	0x0119767d ,	0x01194509 ,
	0x01191238 ,	0x01193b25 ,	0x01191e1f ,	0x01196e5d ,
	0x01191ad4 ,	0x011963cb ,	0x01196bfc ,	0x01197f96 ,
	0x01197ff5 ,	0x01194e45 ,	0x0119323b ,	0x01192213 ,
	0x0119260d ,	0x01196b89 ,	0x0119030a ,	0x0119301c ,
	0x01190bdb ,	0x011956ae ,	0x01190732 ,	0x01190120 ,
	0x0119759a ,	0x01192350 ,	0x011922ee ,	0x01194b40 ,
	0x01195878 ,	0x01196b36 ,	0x01195cfd ,	0x01193e12 ,
	0x01191a49 ,	0x01195f32 ,	0x01193bf6 ,	0x01193a9e ,
	0x0119797d ,	0x01195f49 ,	0x01190ddc ,	0x01194cad ,
	0x0119314f ,	0x01195e14 ,	0x01194df2 ,	0x01194944 ,
	0x01192e40 ,	0x01191366 ,	0x01191cd0 ,	0x0119366b ,
	0x011966c4 ,	0x01194230 ,	0x01197eb7 ,	0x01196032 ,
	0x01192c3b ,	0x011915a1 ,	0x01195422 ,	0x01193ef6 ,
	0x01190822 ,	0x01195991 ,	0x0119409d ,    0x01191101 ,

	0x01207f9b ,	0x012018e5 ,	0x01207485 ,	0x0120781c ,
	0x01204328 ,	0x012054fb ,	0x01202948 ,	0x01202702 ,
	0x01203623 ,	0x01204744 ,	0x01201209 ,	0x01204a32 ,
	0x01205f7d ,	0x012010b5 ,	0x01206a73 ,	0x012012f6 ,
	0x01203e6b ,	0x01203a85 ,	0x01204277 ,	0x01200ecf ,
	0x01203274 ,	0x01204ded ,	0x01206404 ,	0x01200029 ,
	0x01204823 ,	0x012018be ,	0x01206784 ,	0x01204ae1 ,
	0x01203d6c ,	0x01202cd6 ,	0x012072ae ,	0x01206952 ,
	0x01205f90 ,	0x01201649 ,	0x01206df1 ,	0x01205af1 ,
	0x012041bb ,	0x012026e9 ,	0x012001eb ,	0x01200bb3 ,
	0x01202ea6 ,	0x012012db ,	0x0120153c ,	0x01207e87 ,
	0x0120390c ,	0x01200f3e ,	0x01200099 ,	0x01200124 ,
	0x0120305e ,	0x0120440d ,	0x0120491c ,	0x01204d06 ,
	0x01204db7 ,	0x01201547 ,	0x012054de ,	0x012039b3 ,
	0x01202d12 ,	0x0120074d ,	0x01204dc8 ,	0x01206443 ,
	0x012066bb ,	0x0120428b ,	0x012026a6 ,	0x0120701f ,
	0x01205d03 ,	0x01207a5a ,	0x0120767d ,	0x01204509 ,
	0x01201238 ,	0x01203b25 ,	0x01201e1f ,	0x01206e5d ,
	0x01201ad4 ,	0x012063cb ,	0x01206bfc ,	0x01207f96 ,
	0x01207ff5 ,	0x01204e45 ,	0x0120323b ,	0x01202213 ,
	0x0120260d ,	0x01206b89 ,	0x0120030a ,	0x0120301c ,
	0x01200bdb ,	0x012056ae ,	0x01200732 ,	0x01200120 ,
	0x0120759a ,	0x01202350 ,	0x012022ee ,	0x01204b40 ,
	0x01205878 ,	0x01206b36 ,	0x01205cfd ,	0x01203e12 ,
	0x01201a49 ,	0x01205f32 ,	0x01203bf6 ,	0x01203a9e ,
	0x0120797d ,	0x01205f49 ,	0x01200ddc ,	0x01204cad ,
	0x0120314f ,	0x01205e14 ,	0x01204df2 ,	0x01204944 ,
	0x01202e40 ,	0x01201366 ,	0x01201cd0 ,	0x0120366b ,
	0x012066c4 ,	0x01204230 ,	0x01207eb7 ,	0x01206032 ,
	0x01202c3b ,	0x012015a1 ,	0x01205422 ,	0x01203ef6 ,
	0x01200822 ,	0x01205991 ,	0x0120409d ,    0x01201101 ,

	0x01217f9b ,	0x012118e5 ,	0x01217485 ,	0x0121781c ,
	0x01214328 ,	0x012154fb ,	0x01212948 ,	0x01212702 ,
	0x01213623 ,	0x01214744 ,	0x01211209 ,	0x01214a32 ,
	0x01215f7d ,	0x012110b5 ,	0x01216a73 ,	0x012112f6 ,
	0x01213e6b ,	0x01213a85 ,	0x01214277 ,	0x01210ecf ,
	0x01213274 ,	0x01214ded ,	0x01216404 ,	0x01210029 ,
	0x01214823 ,	0x012118be ,	0x01216784 ,	0x01214ae1 ,
	0x01213d6c ,	0x01212cd6 ,	0x012172ae ,	0x01216952 ,
	0x01215f90 ,	0x01211649 ,	0x01216df1 ,	0x01215af1 ,
	0x012141bb ,	0x012126e9 ,	0x012101eb ,	0x01210bb3 ,
	0x01212ea6 ,	0x012112db ,	0x0121153c ,	0x01217e87 ,
	0x0121390c ,	0x01210f3e ,	0x01210099 ,	0x01210124 ,
	0x0121305e ,	0x0121440d ,	0x0121491c ,	0x01214d06 ,
	0x01214db7 ,	0x01211547 ,	0x012154de ,	0x012139b3 ,
	0x01212d12 ,	0x0121074d ,	0x01214dc8 ,	0x01216443 ,
	0x012166bb ,	0x0121428b ,	0x012126a6 ,	0x0121701f ,
	0x01215d03 ,	0x01217a5a ,	0x0121767d ,	0x01214509 ,
	0x01211238 ,	0x01213b25 ,	0x01211e1f ,	0x01216e5d ,
	0x01211ad4 ,	0x012163cb ,	0x01216bfc ,	0x01217f96 ,
	0x01217ff5 ,	0x01214e45 ,	0x0121323b ,	0x01212213 ,
	0x0121260d ,	0x01216b89 ,	0x0121030a ,	0x0121301c ,
	0x01210bdb ,	0x012156ae ,	0x01210732 ,	0x01210120 ,
	0x0121759a ,	0x01212350 ,	0x012122ee ,	0x01214b40 ,
	0x01215878 ,	0x01216b36 ,	0x01215cfd ,	0x01213e12 ,
	0x01211a49 ,	0x01215f32 ,	0x01213bf6 ,	0x01213a9e ,
	0x0121797d ,	0x01215f49 ,	0x01210ddc ,	0x01214cad ,
	0x0121314f ,	0x01215e14 ,	0x01214df2 ,	0x01214944 ,
	0x01212e40 ,	0x01211366 ,	0x01211cd0 ,	0x0121366b ,
	0x012166c4 ,	0x01214230 ,	0x01217eb7 ,	0x01216032 ,
	0x01212c3b ,	0x012115a1 ,	0x01215422 ,	0x01213ef6 ,
	0x01210822 ,	0x01215991 ,	0x0121409d ,    0x01211101 ,

	0x01227f9b ,	0x012218e5 ,	0x01227485 ,	0x0122781c ,
	0x01224328 ,	0x012254fb ,	0x01222948 ,	0x01222702 ,
	0x01223623 ,	0x01224744 ,	0x01221209 ,	0x01224a32 ,
	0x01225f7d ,	0x012210b5 ,	0x01226a73 ,	0x012212f6 ,
	0x01223e6b ,	0x01223a85 ,	0x01224277 ,	0x01220ecf ,
	0x01223274 ,	0x01224ded ,	0x01226404 ,	0x01220029 ,
	0x01224823 ,	0x012218be ,	0x01226784 ,	0x01224ae1 ,
	0x01223d6c ,	0x01222cd6 ,	0x012272ae ,	0x01226952 ,
	0x01225f90 ,	0x01221649 ,	0x01226df1 ,	0x01225af1 ,
	0x012241bb ,	0x012226e9 ,	0x012201eb ,	0x01220bb3 ,
	0x01222ea6 ,	0x012212db ,	0x0122153c ,	0x01227e87 ,
	0x0122390c ,	0x01220f3e ,	0x01220099 ,	0x01220124 ,
	0x0122305e ,	0x0122440d ,	0x0122491c ,	0x01224d06 ,
	0x01224db7 ,	0x01221547 ,	0x012254de ,	0x012239b3 ,
	0x01222d12 ,	0x0122074d ,	0x01224dc8 ,	0x01226443 ,
	0x012266bb ,	0x0122428b ,	0x012226a6 ,	0x0122701f ,
	0x01225d03 ,	0x01227a5a ,	0x0122767d ,	0x01224509 ,
	0x01221238 ,	0x01223b25 ,	0x01221e1f ,	0x01226e5d ,
	0x01221ad4 ,	0x012263cb ,	0x01226bfc ,	0x01227f96 ,
	0x01227ff5 ,	0x01224e45 ,	0x0122323b ,	0x01222213 ,
	0x0122260d ,	0x01226b89 ,	0x0122030a ,	0x0122301c ,
	0x01220bdb ,	0x012256ae ,	0x01220732 ,	0x01220120 ,
	0x0122759a ,	0x01222350 ,	0x012222ee ,	0x01224b40 ,
	0x01225878 ,	0x01226b36 ,	0x01225cfd ,	0x01223e12 ,
	0x01221a49 ,	0x01225f32 ,	0x01223bf6 ,	0x01223a9e ,
	0x0122797d ,	0x01225f49 ,	0x01220ddc ,	0x01224cad ,
	0x0122314f ,	0x01225e14 ,	0x01224df2 ,	0x01224944 ,
	0x01222e40 ,	0x01221366 ,	0x01221cd0 ,	0x0122366b ,
	0x012266c4 ,	0x01224230 ,	0x01227eb7 ,	0x01226032 ,
	0x01222c3b ,	0x012215a1 ,	0x01225422 ,	0x01223ef6 ,
	0x01220822 ,	0x01225991 ,	0x0122409d ,    0x01221101 ,

	0x01237f9b ,	0x012318e5 ,	0x01237485 ,	0x0123781c ,
	0x01234328 ,	0x012354fb ,	0x01232948 ,	0x01232702 ,
	0x01233623 ,	0x01234744 ,	0x01231209 ,	0x01234a32 ,
	0x01235f7d ,	0x012310b5 ,	0x01236a73 ,	0x012312f6 ,
	0x01233e6b ,	0x01233a85 ,	0x01234277 ,	0x01230ecf ,
	0x01233274 ,	0x01234ded ,	0x01236404 ,	0x01230029 ,
	0x01234823 ,	0x012318be ,	0x01236784 ,	0x01234ae1 ,
	0x01233d6c ,	0x01232cd6 ,	0x012372ae ,	0x01236952 ,
	0x01235f90 ,	0x01231649 ,	0x01236df1 ,	0x01235af1 ,
	0x012341bb ,	0x012326e9 ,	0x012301eb ,	0x01230bb3 ,
	0x01232ea6 ,	0x012312db ,	0x0123153c ,	0x01237e87 ,
	0x0123390c ,	0x01230f3e ,	0x01230099 ,	0x01230124 ,
	0x0123305e ,	0x0123440d ,	0x0123491c ,	0x01234d06 ,
	0x01234db7 ,	0x01231547 ,	0x012354de ,	0x012339b3 ,
	0x01232d12 ,	0x0123074d ,	0x01234dc8 ,	0x01236443 ,
	0x012366bb ,	0x0123428b ,	0x012326a6 ,	0x0123701f ,
	0x01235d03 ,	0x01237a5a ,	0x0123767d ,	0x01234509 ,
	0x01231238 ,	0x01233b25 ,	0x01231e1f ,	0x01236e5d ,
	0x01231ad4 ,	0x012363cb ,	0x01236bfc ,	0x01237f96 ,
	0x01237ff5 ,	0x01234e45 ,	0x0123323b ,	0x01232213 ,
	0x0123260d ,	0x01236b89 ,	0x0123030a ,	0x0123301c ,
	0x01230bdb ,	0x012356ae ,	0x01230732 ,	0x01230120 ,
	0x0123759a ,	0x01232350 ,	0x012322ee ,	0x01234b40 ,
	0x01235878 ,	0x01236b36 ,	0x01235cfd ,	0x01233e12 ,
	0x01231a49 ,	0x01235f32 ,	0x01233bf6 ,	0x01233a9e ,
	0x0123797d ,	0x01235f49 ,	0x01230ddc ,	0x01234cad ,
	0x0123314f ,	0x01235e14 ,	0x01234df2 ,	0x01234944 ,
	0x01232e40 ,	0x01231366 ,	0x01231cd0 ,	0x0123366b ,
	0x012366c4 ,	0x01234230 ,	0x01237eb7 ,	0x01236032 ,
	0x01232c3b ,	0x012315a1 ,	0x01235422 ,	0x01233ef6 ,
	0x01230822 ,	0x01235991 ,	0x0123409d ,    0x01231101 ,

	0x01247f9b ,	0x012418e5 ,	0x01247485 ,	0x0124781c ,
	0x01244328 ,	0x012454fb ,	0x01242948 ,	0x01242702 ,
	0x01243623 ,	0x01244744 ,	0x01241209 ,	0x01244a32 ,
	0x01245f7d ,	0x012410b5 ,	0x01246a73 ,	0x012412f6 ,
	0x01243e6b ,	0x01243a85 ,	0x01244277 ,	0x01240ecf ,
	0x01243274 ,	0x01244ded ,	0x01246404 ,	0x01240029 ,
	0x01244823 ,	0x012418be ,	0x01246784 ,	0x01244ae1 ,
	0x01243d6c ,	0x01242cd6 ,	0x012472ae ,	0x01246952 ,
	0x01245f90 ,	0x01241649 ,	0x01246df1 ,	0x01245af1 ,
	0x012441bb ,	0x012426e9 ,	0x012401eb ,	0x01240bb3 ,
	0x01242ea6 ,	0x012412db ,	0x0124153c ,	0x01247e87 ,
	0x0124390c ,	0x01240f3e ,	0x01240099 ,	0x01240124 ,
	0x0124305e ,	0x0124440d ,	0x0124491c ,	0x01244d06 ,
	0x01244db7 ,	0x01241547 ,	0x012454de ,	0x012439b3 ,
	0x01242d12 ,	0x0124074d ,	0x01244dc8 ,	0x01246443 ,
	0x012466bb ,	0x0124428b ,	0x012426a6 ,	0x0124701f ,
	0x01245d03 ,	0x01247a5a ,	0x0124767d ,	0x01244509 ,
	0x01241238 ,	0x01243b25 ,	0x01241e1f ,	0x01246e5d ,
	0x01241ad4 ,	0x012463cb ,	0x01246bfc ,	0x01247f96 ,
	0x01247ff5 ,	0x01244e45 ,	0x0124323b ,	0x01242213 ,
	0x0124260d ,	0x01246b89 ,	0x0124030a ,	0x0124301c ,
	0x01240bdb ,	0x012456ae ,	0x01240732 ,	0x01240120 ,
	0x0124759a ,	0x01242350 ,	0x012422ee ,	0x01244b40 ,
	0x01245878 ,	0x01246b36 ,	0x01245cfd ,	0x01243e12 ,
	0x01241a49 ,	0x01245f32 ,	0x01243bf6 ,	0x01243a9e ,
	0x0124797d ,	0x01245f49 ,	0x01240ddc ,	0x01244cad ,
	0x0124314f ,	0x01245e14 ,	0x01244df2 ,	0x01244944 ,
	0x01242e40 ,	0x01241366 ,	0x01241cd0 ,	0x0124366b ,
	0x012466c4 ,	0x01244230 ,	0x01247eb7 ,	0x01246032 ,
	0x01242c3b ,	0x012415a1 ,	0x01245422 ,	0x01243ef6 ,
	0x01240822 ,	0x01245991 ,	0x0124409d ,    0x01241101 ,

	0x01257f9b ,	0x012518e5 ,	0x01257485 ,	0x0125781c ,
	0x01254328 ,	0x012554fb ,	0x01252948 ,	0x01252702 ,
	0x01253623 ,	0x01254744 ,	0x01251209 ,	0x01254a32 ,
	0x01255f7d ,	0x012510b5 ,	0x01256a73 ,	0x012512f6 ,
	0x01253e6b ,	0x01253a85 ,	0x01254277 ,	0x01250ecf ,
	0x01253274 ,	0x01254ded ,	0x01256404 ,	0x01250029 ,
	0x01254823 ,	0x012518be ,	0x01256784 ,	0x01254ae1 ,
	0x01253d6c ,	0x01252cd6 ,	0x012572ae ,	0x01256952 ,
	0x01255f90 ,	0x01251649 ,	0x01256df1 ,	0x01255af1 ,
	0x012541bb ,	0x012526e9 ,	0x012501eb ,	0x01250bb3 ,
	0x01252ea6 ,	0x012512db ,	0x0125153c ,	0x01257e87 ,
	0x0125390c ,	0x01250f3e ,	0x01250099 ,	0x01250124 ,
	0x0125305e ,	0x0125440d ,	0x0125491c ,	0x01254d06 ,
	0x01254db7 ,	0x01251547 ,	0x012554de ,	0x012539b3 ,
	0x01252d12 ,	0x0125074d ,	0x01254dc8 ,	0x01256443 ,
	0x012566bb ,	0x0125428b ,	0x012526a6 ,	0x0125701f ,
	0x01255d03 ,	0x01257a5a ,	0x0125767d ,	0x01254509 ,
	0x01251238 ,	0x01253b25 ,	0x01251e1f ,	0x01256e5d ,
	0x01251ad4 ,	0x012563cb ,	0x01256bfc ,	0x01257f96 ,
	0x01257ff5 ,	0x01254e45 ,	0x0125323b ,	0x01252213 ,
	0x0125260d ,	0x01256b89 ,	0x0125030a ,	0x0125301c ,
	0x01250bdb ,	0x012556ae ,	0x01250732 ,	0x01250120 ,
	0x0125759a ,	0x01252350 ,	0x012522ee ,	0x01254b40 ,
	0x01255878 ,	0x01256b36 ,	0x01255cfd ,	0x01253e12 ,
	0x01251a49 ,	0x01255f32 ,	0x01253bf6 ,	0x01253a9e ,
	0x0125797d ,	0x01255f49 ,	0x01250ddc ,	0x01254cad ,
	0x0125314f ,	0x01255e14 ,	0x01254df2 ,	0x01254944 ,
	0x01252e40 ,	0x01251366 ,	0x01251cd0 ,	0x0125366b ,
	0x012566c4 ,	0x01254230 ,	0x01257eb7 ,	0x01256032 ,
	0x01252c3b ,	0x012515a1 ,	0x01255422 ,	0x01253ef6 ,
	0x01250822 ,	0x01255991 ,	0x0125409d ,    0x01251101 ,

	0x01267f9b ,	0x012618e5 ,	0x01267485 ,	0x0126781c ,
	0x01264328 ,	0x012654fb ,	0x01262948 ,	0x01262702 ,
	0x01263623 ,	0x01264744 ,	0x01261209 ,	0x01264a32 ,
	0x01265f7d ,	0x012610b5 ,	0x01266a73 ,	0x012612f6 ,
	0x01263e6b ,	0x01263a85 ,	0x01264277 ,	0x01260ecf ,
	0x01263274 ,	0x01264ded ,	0x01266404 ,	0x01260029 ,
	0x01264823 ,	0x012618be ,	0x01266784 ,	0x01264ae1 ,
	0x01263d6c ,	0x01262cd6 ,	0x012672ae ,	0x01266952 ,
	0x01265f90 ,	0x01261649 ,	0x01266df1 ,	0x01265af1 ,
	0x012641bb ,	0x012626e9 ,	0x012601eb ,	0x01260bb3 ,
	0x01262ea6 ,	0x012612db ,	0x0126153c ,	0x01267e87 ,
	0x0126390c ,	0x01260f3e ,	0x01260099 ,	0x01260124 ,
	0x0126305e ,	0x0126440d ,	0x0126491c ,	0x01264d06 ,
	0x01264db7 ,	0x01261547 ,	0x012654de ,	0x012639b3 ,
	0x01262d12 ,	0x0126074d ,	0x01264dc8 ,	0x01266443 ,
	0x012666bb ,	0x0126428b ,	0x012626a6 ,	0x0126701f ,
	0x01265d03 ,	0x01267a5a ,	0x0126767d ,	0x01264509 ,
	0x01261238 ,	0x01263b25 ,	0x01261e1f ,	0x01266e5d ,
	0x01261ad4 ,	0x012663cb ,	0x01266bfc ,	0x01267f96 ,
	0x01267ff5 ,	0x01264e45 ,	0x0126323b ,	0x01262213 ,
	0x0126260d ,	0x01266b89 ,	0x0126030a ,	0x0126301c ,
	0x01260bdb ,	0x012656ae ,	0x01260732 ,	0x01260120 ,
	0x0126759a ,	0x01262350 ,	0x012622ee ,	0x01264b40 ,
	0x01265878 ,	0x01266b36 ,	0x01265cfd ,	0x01263e12 ,
	0x01261a49 ,	0x01265f32 ,	0x01263bf6 ,	0x01263a9e ,
	0x0126797d ,	0x01265f49 ,	0x01260ddc ,	0x01264cad ,
	0x0126314f ,	0x01265e14 ,	0x01264df2 ,	0x01264944 ,
	0x01262e40 ,	0x01261366 ,	0x01261cd0 ,	0x0126366b ,
	0x012666c4 ,	0x01264230 ,	0x01267eb7 ,	0x01266032 ,
	0x01262c3b ,	0x012615a1 ,	0x01265422 ,	0x01263ef6 ,
	0x01260822 ,	0x01265991 ,	0x0126409d ,    0x01261101 ,

	0x01277f9b ,	0x012718e5 ,	0x01277485 ,	0x0127781c ,
	0x01274328 ,	0x012754fb ,	0x01272948 ,	0x01272702 ,
	0x01273623 ,	0x01274744 ,	0x01271209 ,	0x01274a32 ,
	0x01275f7d ,	0x012710b5 ,	0x01276a73 ,	0x012712f6 ,
	0x01273e6b ,	0x01273a85 ,	0x01274277 ,	0x01270ecf ,
	0x01273274 ,	0x01274ded ,	0x01276404 ,	0x01270029 ,
	0x01274823 ,	0x012718be ,	0x01276784 ,	0x01274ae1 ,
	0x01273d6c ,	0x01272cd6 ,	0x012772ae ,	0x01276952 ,
	0x01275f90 ,	0x01271649 ,	0x01276df1 ,	0x01275af1 ,
	0x012741bb ,	0x012726e9 ,	0x012701eb ,	0x01270bb3 ,
	0x01272ea6 ,	0x012712db ,	0x0127153c ,	0x01277e87 ,
	0x0127390c ,	0x01270f3e ,	0x01270099 ,	0x01270124 ,
	0x0127305e ,	0x0127440d ,	0x0127491c ,	0x01274d06 ,
	0x01274db7 ,	0x01271547 ,	0x012754de ,	0x012739b3 ,
	0x01272d12 ,	0x0127074d ,	0x01274dc8 ,	0x01276443 ,
	0x012766bb ,	0x0127428b ,	0x012726a6 ,	0x0127701f ,
	0x01275d03 ,	0x01277a5a ,	0x0127767d ,	0x01274509 ,
	0x01271238 ,	0x01273b25 ,	0x01271e1f ,	0x01276e5d ,
	0x01271ad4 ,	0x012763cb ,	0x01276bfc ,	0x01277f96 ,
	0x01277ff5 ,	0x01274e45 ,	0x0127323b ,	0x01272213 ,
	0x0127260d ,	0x01276b89 ,	0x0127030a ,	0x0127301c ,
	0x01270bdb ,	0x012756ae ,	0x01270732 ,	0x01270120 ,
	0x0127759a ,	0x01272350 ,	0x012722ee ,	0x01274b40 ,
	0x01275878 ,	0x01276b36 ,	0x01275cfd ,	0x01273e12 ,
	0x01271a49 ,	0x01275f32 ,	0x01273bf6 ,	0x01273a9e ,
	0x0127797d ,	0x01275f49 ,	0x01270ddc ,	0x01274cad ,
	0x0127314f ,	0x01275e14 ,	0x01274df2 ,	0x01274944 ,
	0x01272e40 ,	0x01271366 ,	0x01271cd0 ,	0x0127366b ,
	0x012766c4 ,	0x01274230 ,	0x01277eb7 ,	0x01276032 ,
	0x01272c3b ,	0x012715a1 ,	0x01275422 ,	0x01273ef6 ,
	0x01270822 ,	0x01275991 ,	0x0127409d ,    0x01271101 ,

	0x01287f9b ,	0x012818e5 ,	0x01287485 ,	0x0128781c ,
	0x01284328 ,	0x012854fb ,	0x01282948 ,	0x01282702 ,
	0x01283623 ,	0x01284744 ,	0x01281209 ,	0x01284a32 ,
	0x01285f7d ,	0x012810b5 ,	0x01286a73 ,	0x012812f6 ,
	0x01283e6b ,	0x01283a85 ,	0x01284277 ,	0x01280ecf ,
	0x01283274 ,	0x01284ded ,	0x01286404 ,	0x01280029 ,
	0x01284823 ,	0x012818be ,	0x01286784 ,	0x01284ae1 ,
	0x01283d6c ,	0x01282cd6 ,	0x012872ae ,	0x01286952 ,
	0x01285f90 ,	0x01281649 ,	0x01286df1 ,	0x01285af1 ,
	0x012841bb ,	0x012826e9 ,	0x012801eb ,	0x01280bb3 ,
	0x01282ea6 ,	0x012812db ,	0x0128153c ,	0x01287e87 ,
	0x0128390c ,	0x01280f3e ,	0x01280099 ,	0x01280124 ,
	0x0128305e ,	0x0128440d ,	0x0128491c ,	0x01284d06 ,
	0x01284db7 ,	0x01281547 ,	0x012854de ,	0x012839b3 ,
	0x01282d12 ,	0x0128074d ,	0x01284dc8 ,	0x01286443 ,
	0x012866bb ,	0x0128428b ,	0x012826a6 ,	0x0128701f ,
	0x01285d03 ,	0x01287a5a ,	0x0128767d ,	0x01284509 ,
	0x01281238 ,	0x01283b25 ,	0x01281e1f ,	0x01286e5d ,
	0x01281ad4 ,	0x012863cb ,	0x01286bfc ,	0x01287f96 ,
	0x01287ff5 ,	0x01284e45 ,	0x0128323b ,	0x01282213 ,
	0x0128260d ,	0x01286b89 ,	0x0128030a ,	0x0128301c ,
	0x01280bdb ,	0x012856ae ,	0x01280732 ,	0x01280120 ,
	0x0128759a ,	0x01282350 ,	0x012822ee ,	0x01284b40 ,
	0x01285878 ,	0x01286b36 ,	0x01285cfd ,	0x01283e12 ,
	0x01281a49 ,	0x01285f32 ,	0x01283bf6 ,	0x01283a9e ,
	0x0128797d ,	0x01285f49 ,	0x01280ddc ,	0x01284cad ,
	0x0128314f ,	0x01285e14 ,	0x01284df2 ,	0x01284944 ,
	0x01282e40 ,	0x01281366 ,	0x01281cd0 ,	0x0128366b ,
	0x012866c4 ,	0x01284230 ,	0x01287eb7 ,	0x01286032 ,
	0x01282c3b ,	0x012815a1 ,	0x01285422 ,	0x01283ef6 ,
	0x01280822 ,	0x01285991 ,	0x0128409d ,    0x01281101 ,

	0x01297f9b ,	0x012918e5 ,	0x01297485 ,	0x0129781c ,
	0x01294328 ,	0x012954fb ,	0x01292948 ,	0x01292702 ,
	0x01293623 ,	0x01294744 ,	0x01291209 ,	0x01294a32 ,
	0x01295f7d ,	0x012910b5 ,	0x01296a73 ,	0x012912f6 ,
	0x01293e6b ,	0x01293a85 ,	0x01294277 ,	0x01290ecf ,
	0x01293274 ,	0x01294ded ,	0x01296404 ,	0x01290029 ,
	0x01294823 ,	0x012918be ,	0x01296784 ,	0x01294ae1 ,
	0x01293d6c ,	0x01292cd6 ,	0x012972ae ,	0x01296952 ,
	0x01295f90 ,	0x01291649 ,	0x01296df1 ,	0x01295af1 ,
	0x012941bb ,	0x012926e9 ,	0x012901eb ,	0x01290bb3 ,
	0x01292ea6 ,	0x012912db ,	0x0129153c ,	0x01297e87 ,
	0x0129390c ,	0x01290f3e ,	0x01290099 ,	0x01290124 ,
	0x0129305e ,	0x0129440d ,	0x0129491c ,	0x01294d06 ,
	0x01294db7 ,	0x01291547 ,	0x012954de ,	0x012939b3 ,
	0x01292d12 ,	0x0129074d ,	0x01294dc8 ,	0x01296443 ,
	0x012966bb ,	0x0129428b ,	0x012926a6 ,	0x0129701f ,
	0x01295d03 ,	0x01297a5a ,	0x0129767d ,	0x01294509 ,
	0x01291238 ,	0x01293b25 ,	0x01291e1f ,	0x01296e5d ,
	0x01291ad4 ,	0x012963cb ,	0x01296bfc ,	0x01297f96 ,
	0x01297ff5 ,	0x01294e45 ,	0x0129323b ,	0x01292213 ,
	0x0129260d ,	0x01296b89 ,	0x0129030a ,	0x0129301c ,
	0x01290bdb ,	0x012956ae ,	0x01290732 ,	0x01290120 ,
	0x0129759a ,	0x01292350 ,	0x012922ee ,	0x01294b40 ,
	0x01295878 ,	0x01296b36 ,	0x01295cfd ,	0x01293e12 ,
	0x01291a49 ,	0x01295f32 ,	0x01293bf6 ,	0x01293a9e ,
	0x0129797d ,	0x01295f49 ,	0x01290ddc ,	0x01294cad ,
	0x0129314f ,	0x01295e14 ,	0x01294df2 ,	0x01294944 ,
	0x01292e40 ,	0x01291366 ,	0x01291cd0 ,	0x0129366b ,
	0x012966c4 ,	0x01294230 ,	0x01297eb7 ,	0x01296032 ,
	0x01292c3b ,	0x012915a1 ,	0x01295422 ,	0x01293ef6 ,
	0x01290822 ,	0x01295991 ,	0x0129409d ,    0x01291101 ,

	0x01307f9b ,	0x013018e5 ,	0x01307485 ,	0x0130781c ,
	0x01304328 ,	0x013054fb ,	0x01302948 ,	0x01302702 ,
	0x01303623 ,	0x01304744 ,	0x01301209 ,	0x01304a32 ,
	0x01305f7d ,	0x013010b5 ,	0x01306a73 ,	0x013012f6 ,
	0x01303e6b ,	0x01303a85 ,	0x01304277 ,	0x01300ecf ,
	0x01303274 ,	0x01304ded ,	0x01306404 ,	0x01300029 ,
	0x01304823 ,	0x013018be ,	0x01306784 ,	0x01304ae1 ,
	0x01303d6c ,	0x01302cd6 ,	0x013072ae ,	0x01306952 ,
	0x01305f90 ,	0x01301649 ,	0x01306df1 ,	0x01305af1 ,
	0x013041bb ,	0x013026e9 ,	0x013001eb ,	0x01300bb3 ,
	0x01302ea6 ,	0x013012db ,	0x0130153c ,	0x01307e87 ,
	0x0130390c ,	0x01300f3e ,	0x01300099 ,	0x01300124 ,
	0x0130305e ,	0x0130440d ,	0x0130491c ,	0x01304d06 ,
	0x01304db7 ,	0x01301547 ,	0x013054de ,	0x013039b3 ,
	0x01302d12 ,	0x0130074d ,	0x01304dc8 ,	0x01306443 ,
	0x013066bb ,	0x0130428b ,	0x013026a6 ,	0x0130701f ,
	0x01305d03 ,	0x01307a5a ,	0x0130767d ,	0x01304509 ,
	0x01301238 ,	0x01303b25 ,	0x01301e1f ,	0x01306e5d ,
	0x01301ad4 ,	0x013063cb ,	0x01306bfc ,	0x01307f96 ,
	0x01307ff5 ,	0x01304e45 ,	0x0130323b ,	0x01302213 ,
	0x0130260d ,	0x01306b89 ,	0x0130030a ,	0x0130301c ,
	0x01300bdb ,	0x013056ae ,	0x01300732 ,	0x01300120 ,
	0x0130759a ,	0x01302350 ,	0x013022ee ,	0x01304b40 ,
	0x01305878 ,	0x01306b36 ,	0x01305cfd ,	0x01303e12 ,
	0x01301a49 ,	0x01305f32 ,	0x01303bf6 ,	0x01303a9e ,
	0x0130797d ,	0x01305f49 ,	0x01300ddc ,	0x01304cad ,
	0x0130314f ,	0x01305e14 ,	0x01304df2 ,	0x01304944 ,
	0x01302e40 ,	0x01301366 ,	0x01301cd0 ,	0x0130366b ,
	0x013066c4 ,	0x01304230 ,	0x01307eb7 ,	0x01306032 ,
	0x01302c3b ,	0x013015a1 ,	0x01305422 ,	0x01303ef6 ,
	0x01300822 ,	0x01305991 ,	0x0130409d ,    0x01301101 ,

	0x01317f9b ,	0x013118e5 ,	0x01317485 ,	0x0131781c ,
	0x01314328 ,	0x013154fb ,	0x01312948 ,	0x01312702 ,
	0x01313623 ,	0x01314744 ,	0x01311209 ,	0x01314a32 ,
	0x01315f7d ,	0x013110b5 ,	0x01316a73 ,	0x013112f6 ,
	0x01313e6b ,	0x01313a85 ,	0x01314277 ,	0x01310ecf ,
	0x01313274 ,	0x01314ded ,	0x01316404 ,	0x01310029 ,
	0x01314823 ,	0x013118be ,	0x01316784 ,	0x01314ae1 ,
	0x01313d6c ,	0x01312cd6 ,	0x013172ae ,	0x01316952 ,
	0x01315f90 ,	0x01311649 ,	0x01316df1 ,	0x01315af1 ,
	0x013141bb ,	0x013126e9 ,	0x013101eb ,	0x01310bb3 ,
	0x01312ea6 ,	0x013112db ,	0x0131153c ,	0x01317e87 ,
	0x0131390c ,	0x01310f3e ,	0x01310099 ,	0x01310124 ,
	0x0131305e ,	0x0131440d ,	0x0131491c ,	0x01314d06 ,
	0x01314db7 ,	0x01311547 ,	0x013154de ,	0x013139b3 ,
	0x01312d12 ,	0x0131074d ,	0x01314dc8 ,	0x01316443 ,
	0x013166bb ,	0x0131428b ,	0x013126a6 ,	0x0131701f ,
	0x01315d03 ,	0x01317a5a ,	0x0131767d ,	0x01314509 ,
	0x01311238 ,	0x01313b25 ,	0x01311e1f ,	0x01316e5d ,
	0x01311ad4 ,	0x013163cb ,	0x01316bfc ,	0x01317f96 ,
	0x01317ff5 ,	0x01314e45 ,	0x0131323b ,	0x01312213 ,
	0x0131260d ,	0x01316b89 ,	0x0131030a ,	0x0131301c ,
	0x01310bdb ,	0x013156ae ,	0x01310732 ,	0x01310120 ,
	0x0131759a ,	0x01312350 ,	0x013122ee ,	0x01314b40 ,
	0x01315878 ,	0x01316b36 ,	0x01315cfd ,	0x01313e12 ,
	0x01311a49 ,	0x01315f32 ,	0x01313bf6 ,	0x01313a9e ,
	0x0131797d ,	0x01315f49 ,	0x01310ddc ,	0x01314cad ,
	0x0131314f ,	0x01315e14 ,	0x01314df2 ,	0x01314944 ,
	0x01312e40 ,	0x01311366 ,	0x01311cd0 ,	0x0131366b ,
	0x013166c4 ,	0x01314230 ,	0x01317eb7 ,	0x01316032 ,
	0x01312c3b ,	0x013115a1 ,	0x01315422 ,	0x01313ef6 ,
	0x01310822 ,	0x01315991 ,	0x0131409d ,    0x01311101 ,

	0x01327f9b ,	0x013218e5 ,	0x01327485 ,	0x0132781c ,
	0x01324328 ,	0x013254fb ,	0x01322948 ,	0x01322702 ,
	0x01323623 ,	0x01324744 ,	0x01321209 ,	0x01324a32 ,
	0x01325f7d ,	0x013210b5 ,	0x01326a73 ,	0x013212f6 ,
	0x01323e6b ,	0x01323a85 ,	0x01324277 ,	0x01320ecf ,
	0x01323274 ,	0x01324ded ,	0x01326404 ,	0x01320029 ,
	0x01324823 ,	0x013218be ,	0x01326784 ,	0x01324ae1 ,
	0x01323d6c ,	0x01322cd6 ,	0x013272ae ,	0x01326952 ,
	0x01325f90 ,	0x01321649 ,	0x01326df1 ,	0x01325af1 ,
	0x013241bb ,	0x013226e9 ,	0x013201eb ,	0x01320bb3 ,
	0x01322ea6 ,	0x013212db ,	0x0132153c ,	0x01327e87 ,
	0x0132390c ,	0x01320f3e ,	0x01320099 ,	0x01320124 ,
	0x0132305e ,	0x0132440d ,	0x0132491c ,	0x01324d06 ,
	0x01324db7 ,	0x01321547 ,	0x013254de ,	0x013239b3 ,
	0x01322d12 ,	0x0132074d ,	0x01324dc8 ,	0x01326443 ,
	0x013266bb ,	0x0132428b ,	0x013226a6 ,	0x0132701f ,
	0x01325d03 ,	0x01327a5a ,	0x0132767d ,	0x01324509 ,
	0x01321238 ,	0x01323b25 ,	0x01321e1f ,	0x01326e5d ,
	0x01321ad4 ,	0x013263cb ,	0x01326bfc ,	0x01327f96 ,
	0x01327ff5 ,	0x01324e45 ,	0x0132323b ,	0x01322213 ,
	0x0132260d ,	0x01326b89 ,	0x0132030a ,	0x0132301c ,
	0x01320bdb ,	0x013256ae ,	0x01320732 ,	0x01320120 ,
	0x0132759a ,	0x01322350 ,	0x013222ee ,	0x01324b40 ,
	0x01325878 ,	0x01326b36 ,	0x01325cfd ,	0x01323e12 ,
	0x01321a49 ,	0x01325f32 ,	0x01323bf6 ,	0x01323a9e ,
	0x0132797d ,	0x01325f49 ,	0x01320ddc ,	0x01324cad ,
	0x0132314f ,	0x01325e14 ,	0x01324df2 ,	0x01324944 ,
	0x01322e40 ,	0x01321366 ,	0x01321cd0 ,	0x0132366b ,
	0x013266c4 ,	0x01324230 ,	0x01327eb7 ,	0x01326032 ,
	0x01322c3b ,	0x013215a1 ,	0x01325422 ,	0x01323ef6 ,
	0x01320822 ,	0x01325991 ,	0x0132409d ,    0x01321101 ,

	0x01337f9b ,	0x013318e5 ,	0x01337485 ,	0x0133781c ,
	0x01334328 ,	0x013354fb ,	0x01332948 ,	0x01332702 ,
	0x01333623 ,	0x01334744 ,	0x01331209 ,	0x01334a32 ,
	0x01335f7d ,	0x013310b5 ,	0x01336a73 ,	0x013312f6 ,
	0x01333e6b ,	0x01333a85 ,	0x01334277 ,	0x01330ecf ,
	0x01333274 ,	0x01334ded ,	0x01336404 ,	0x01330029 ,
	0x01334823 ,	0x013318be ,	0x01336784 ,	0x01334ae1 ,
	0x01333d6c ,	0x01332cd6 ,	0x013372ae ,	0x01336952 ,
	0x01335f90 ,	0x01331649 ,	0x01336df1 ,	0x01335af1 ,
	0x013341bb ,	0x013326e9 ,	0x013301eb ,	0x01330bb3 ,
	0x01332ea6 ,	0x013312db ,	0x0133153c ,	0x01337e87 ,
	0x0133390c ,	0x01330f3e ,	0x01330099 ,	0x01330124 ,
	0x0133305e ,	0x0133440d ,	0x0133491c ,	0x01334d06 ,
	0x01334db7 ,	0x01331547 ,	0x013354de ,	0x013339b3 ,
	0x01332d12 ,	0x0133074d ,	0x01334dc8 ,	0x01336443 ,
	0x013366bb ,	0x0133428b ,	0x013326a6 ,	0x0133701f ,
	0x01335d03 ,	0x01337a5a ,	0x0133767d ,	0x01334509 ,
	0x01331238 ,	0x01333b25 ,	0x01331e1f ,	0x01336e5d ,
	0x01331ad4 ,	0x013363cb ,	0x01336bfc ,	0x01337f96 ,
	0x01337ff5 ,	0x01334e45 ,	0x0133323b ,	0x01332213 ,
	0x0133260d ,	0x01336b89 ,	0x0133030a ,	0x0133301c ,
	0x01330bdb ,	0x013356ae ,	0x01330732 ,	0x01330120 ,
	0x0133759a ,	0x01332350 ,	0x013322ee ,	0x01334b40 ,
	0x01335878 ,	0x01336b36 ,	0x01335cfd ,	0x01333e12 ,
	0x01331a49 ,	0x01335f32 ,	0x01333bf6 ,	0x01333a9e ,
	0x0133797d ,	0x01335f49 ,	0x01330ddc ,	0x01334cad ,
	0x0133314f ,	0x01335e14 ,	0x01334df2 ,	0x01334944 ,
	0x01332e40 ,	0x01331366 ,	0x01331cd0 ,	0x0133366b ,
	0x013366c4 ,	0x01334230 ,	0x01337eb7 ,	0x01336032 ,
	0x01332c3b ,	0x013315a1 ,	0x01335422 ,	0x01333ef6 ,
	0x01330822 ,	0x01335991 ,	0x0133409d ,    0x01331101 ,

	0x01347f9b ,	0x013418e5 ,	0x01347485 ,	0x0134781c ,
	0x01344328 ,	0x013454fb ,	0x01342948 ,	0x01342702 ,
	0x01343623 ,	0x01344744 ,	0x01341209 ,	0x01344a32 ,
	0x01345f7d ,	0x013410b5 ,	0x01346a73 ,	0x013412f6 ,
	0x01343e6b ,	0x01343a85 ,	0x01344277 ,	0x01340ecf ,
	0x01343274 ,	0x01344ded ,	0x01346404 ,	0x01340029 ,
	0x01344823 ,	0x013418be ,	0x01346784 ,	0x01344ae1 ,
	0x01343d6c ,	0x01342cd6 ,	0x013472ae ,	0x01346952 ,
	0x01345f90 ,	0x01341649 ,	0x01346df1 ,	0x01345af1 ,
	0x013441bb ,	0x013426e9 ,	0x013401eb ,	0x01340bb3 ,
	0x01342ea6 ,	0x013412db ,	0x0134153c ,	0x01347e87 ,
	0x0134390c ,	0x01340f3e ,	0x01340099 ,	0x01340124 ,
	0x0134305e ,	0x0134440d ,	0x0134491c ,	0x01344d06 ,
	0x01344db7 ,	0x01341547 ,	0x013454de ,	0x013439b3 ,
	0x01342d12 ,	0x0134074d ,	0x01344dc8 ,	0x01346443 ,
	0x013466bb ,	0x0134428b ,	0x013426a6 ,	0x0134701f ,
	0x01345d03 ,	0x01347a5a ,	0x0134767d ,	0x01344509 ,
	0x01341238 ,	0x01343b25 ,	0x01341e1f ,	0x01346e5d ,
	0x01341ad4 ,	0x013463cb ,	0x01346bfc ,	0x01347f96 ,
	0x01347ff5 ,	0x01344e45 ,	0x0134323b ,	0x01342213 ,
	0x0134260d ,	0x01346b89 ,	0x0134030a ,	0x0134301c ,
	0x01340bdb ,	0x013456ae ,	0x01340732 ,	0x01340120 ,
	0x0134759a ,	0x01342350 ,	0x013422ee ,	0x01344b40 ,
	0x01345878 ,	0x01346b36 ,	0x01345cfd ,	0x01343e12 ,
	0x01341a49 ,	0x01345f32 ,	0x01343bf6 ,	0x01343a9e ,
	0x0134797d ,	0x01345f49 ,	0x01340ddc ,	0x01344cad ,
	0x0134314f ,	0x01345e14 ,	0x01344df2 ,	0x01344944 ,
	0x01342e40 ,	0x01341366 ,	0x01341cd0 ,	0x0134366b ,
	0x013466c4 ,	0x01344230 ,	0x01347eb7 ,	0x01346032 ,
	0x01342c3b ,	0x013415a1 ,	0x01345422 ,	0x01343ef6 ,
	0x01340822 ,	0x01345991 ,	0x0134409d ,    0x01341101 ,

	0x01357f9b ,	0x013518e5 ,	0x01357485 ,	0x0135781c ,
	0x01354328 ,	0x013554fb ,	0x01352948 ,	0x01352702 ,
	0x01353623 ,	0x01354744 ,	0x01351209 ,	0x01354a32 ,
	0x01355f7d ,	0x013510b5 ,	0x01356a73 ,	0x013512f6 ,
	0x01353e6b ,	0x01353a85 ,	0x01354277 ,	0x01350ecf ,
	0x01353274 ,	0x01354ded ,	0x01356404 ,	0x01350029 ,
	0x01354823 ,	0x013518be ,	0x01356784 ,	0x01354ae1 ,
	0x01353d6c ,	0x01352cd6 ,	0x013572ae ,	0x01356952 ,
	0x01355f90 ,	0x01351649 ,	0x01356df1 ,	0x01355af1 ,
	0x013541bb ,	0x013526e9 ,	0x013501eb ,	0x01350bb3 ,
	0x01352ea6 ,	0x013512db ,	0x0135153c ,	0x01357e87 ,
	0x0135390c ,	0x01350f3e ,	0x01350099 ,	0x01350124 ,
	0x0135305e ,	0x0135440d ,	0x0135491c ,	0x01354d06 ,
	0x01354db7 ,	0x01351547 ,	0x013554de ,	0x013539b3 ,
	0x01352d12 ,	0x0135074d ,	0x01354dc8 ,	0x01356443 ,
	0x013566bb ,	0x0135428b ,	0x013526a6 ,	0x0135701f ,
	0x01355d03 ,	0x01357a5a ,	0x0135767d ,	0x01354509 ,
	0x01351238 ,	0x01353b25 ,	0x01351e1f ,	0x01356e5d ,
	0x01351ad4 ,	0x013563cb ,	0x01356bfc ,	0x01357f96 ,
	0x01357ff5 ,	0x01354e45 ,	0x0135323b ,	0x01352213 ,
	0x0135260d ,	0x01356b89 ,	0x0135030a ,	0x0135301c ,
	0x01350bdb ,	0x013556ae ,	0x01350732 ,	0x01350120 ,
	0x0135759a ,	0x01352350 ,	0x013522ee ,	0x01354b40 ,
	0x01355878 ,	0x01356b36 ,	0x01355cfd ,	0x01353e12 ,
	0x01351a49 ,	0x01355f32 ,	0x01353bf6 ,	0x01353a9e ,
	0x0135797d ,	0x01355f49 ,	0x01350ddc ,	0x01354cad ,
	0x0135314f ,	0x01355e14 ,	0x01354df2 ,	0x01354944 ,
	0x01352e40 ,	0x01351366 ,	0x01351cd0 ,	0x0135366b ,
	0x013566c4 ,	0x01354230 ,	0x01357eb7 ,	0x01356032 ,
	0x01352c3b ,	0x013515a1 ,	0x01355422 ,	0x01353ef6 ,
	0x01350822 ,	0x01355991 ,	0x0135409d ,    0x01351101 ,

	0x01367f9b ,	0x013618e5 ,	0x01367485 ,	0x0136781c ,
	0x01364328 ,	0x013654fb ,	0x01362948 ,	0x01362702 ,
	0x01363623 ,	0x01364744 ,	0x01361209 ,	0x01364a32 ,
	0x01365f7d ,	0x013610b5 ,	0x01366a73 ,	0x013612f6 ,
	0x01363e6b ,	0x01363a85 ,	0x01364277 ,	0x01360ecf ,
	0x01363274 ,	0x01364ded ,	0x01366404 ,	0x01360029 ,
	0x01364823 ,	0x013618be ,	0x01366784 ,	0x01364ae1 ,
	0x01363d6c ,	0x01362cd6 ,	0x013672ae ,	0x01366952 ,
	0x01365f90 ,	0x01361649 ,	0x01366df1 ,	0x01365af1 ,
	0x013641bb ,	0x013626e9 ,	0x013601eb ,	0x01360bb3 ,
	0x01362ea6 ,	0x013612db ,	0x0136153c ,	0x01367e87 ,
	0x0136390c ,	0x01360f3e ,	0x01360099 ,	0x01360124 ,
	0x0136305e ,	0x0136440d ,	0x0136491c ,	0x01364d06 ,
	0x01364db7 ,	0x01361547 ,	0x013654de ,	0x013639b3 ,
	0x01362d12 ,	0x0136074d ,	0x01364dc8 ,	0x01366443 ,
	0x013666bb ,	0x0136428b ,	0x013626a6 ,	0x0136701f ,
	0x01365d03 ,	0x01367a5a ,	0x0136767d ,	0x01364509 ,
	0x01361238 ,	0x01363b25 ,	0x01361e1f ,	0x01366e5d ,
	0x01361ad4 ,	0x013663cb ,	0x01366bfc ,	0x01367f96 ,
	0x01367ff5 ,	0x01364e45 ,	0x0136323b ,	0x01362213 ,
	0x0136260d ,	0x01366b89 ,	0x0136030a ,	0x0136301c ,
	0x01360bdb ,	0x013656ae ,	0x01360732 ,	0x01360120 ,
	0x0136759a ,	0x01362350 ,	0x013622ee ,	0x01364b40 ,
	0x01365878 ,	0x01366b36 ,	0x01365cfd ,	0x01363e12 ,
	0x01361a49 ,	0x01365f32 ,	0x01363bf6 ,	0x01363a9e ,
	0x0136797d ,	0x01365f49 ,	0x01360ddc ,	0x01364cad ,
	0x0136314f ,	0x01365e14 ,	0x01364df2 ,	0x01364944 ,
	0x01362e40 ,	0x01361366 ,	0x01361cd0 ,	0x0136366b ,
	0x013666c4 ,	0x01364230 ,	0x01367eb7 ,	0x01366032 ,
	0x01362c3b ,	0x013615a1 ,	0x01365422 ,	0x01363ef6 ,
	0x01360822 ,	0x01365991 ,	0x0136409d ,    0x01361101 ,

	0x01377f9b ,	0x013718e5 ,	0x01377485 ,	0x0137781c ,
	0x01374328 ,	0x013754fb ,	0x01372948 ,	0x01372702 ,
	0x01373623 ,	0x01374744 ,	0x01371209 ,	0x01374a32 ,
	0x01375f7d ,	0x013710b5 ,	0x01376a73 ,	0x013712f6 ,
	0x01373e6b ,	0x01373a85 ,	0x01374277 ,	0x01370ecf ,
	0x01373274 ,	0x01374ded ,	0x01376404 ,	0x01370029 ,
	0x01374823 ,	0x013718be ,	0x01376784 ,	0x01374ae1 ,
	0x01373d6c ,	0x01372cd6 ,	0x013772ae ,	0x01376952 ,
	0x01375f90 ,	0x01371649 ,	0x01376df1 ,	0x01375af1 ,
	0x013741bb ,	0x013726e9 ,	0x013701eb ,	0x01370bb3 ,
	0x01372ea6 ,	0x013712db ,	0x0137153c ,	0x01377e87 ,
	0x0137390c ,	0x01370f3e ,	0x01370099 ,	0x01370124 ,
	0x0137305e ,	0x0137440d ,	0x0137491c ,	0x01374d06 ,
	0x01374db7 ,	0x01371547 ,	0x013754de ,	0x013739b3 ,
	0x01372d12 ,	0x0137074d ,	0x01374dc8 ,	0x01376443 ,
	0x013766bb ,	0x0137428b ,	0x013726a6 ,	0x0137701f ,
	0x01375d03 ,	0x01377a5a ,	0x0137767d ,	0x01374509 ,
	0x01371238 ,	0x01373b25 ,	0x01371e1f ,	0x01376e5d ,
	0x01371ad4 ,	0x013763cb ,	0x01376bfc ,	0x01377f96 ,
	0x01377ff5 ,	0x01374e45 ,	0x0137323b ,	0x01372213 ,
	0x0137260d ,	0x01376b89 ,	0x0137030a ,	0x0137301c ,
	0x01370bdb ,	0x013756ae ,	0x01370732 ,	0x01370120 ,
	0x0137759a ,	0x01372350 ,	0x013722ee ,	0x01374b40 ,
	0x01375878 ,	0x01376b36 ,	0x01375cfd ,	0x01373e12 ,
	0x01371a49 ,	0x01375f32 ,	0x01373bf6 ,	0x01373a9e ,
	0x0137797d ,	0x01375f49 ,	0x01370ddc ,	0x01374cad ,
	0x0137314f ,	0x01375e14 ,	0x01374df2 ,	0x01374944 ,
	0x01372e40 ,	0x01371366 ,	0x01371cd0 ,	0x0137366b ,
	0x013766c4 ,	0x01374230 ,	0x01377eb7 ,	0x01376032 ,
	0x01372c3b ,	0x013715a1 ,	0x01375422 ,	0x01373ef6 ,
	0x01370822 ,	0x01375991 ,	0x0137409d ,    0x01371101 ,

	0x01387f9b ,	0x013818e5 ,	0x01387485 ,	0x0138781c ,
	0x01384328 ,	0x013854fb ,	0x01382948 ,	0x01382702 ,
	0x01383623 ,	0x01384744 ,	0x01381209 ,	0x01384a32 ,
	0x01385f7d ,	0x013810b5 ,	0x01386a73 ,	0x013812f6 ,
	0x01383e6b ,	0x01383a85 ,	0x01384277 ,	0x01380ecf ,
	0x01383274 ,	0x01384ded ,	0x01386404 ,	0x01380029 ,
	0x01384823 ,	0x013818be ,	0x01386784 ,	0x01384ae1 ,
	0x01383d6c ,	0x01382cd6 ,	0x013872ae ,	0x01386952 ,
	0x01385f90 ,	0x01381649 ,	0x01386df1 ,	0x01385af1 ,
	0x013841bb ,	0x013826e9 ,	0x013801eb ,	0x01380bb3 ,
	0x01382ea6 ,	0x013812db ,	0x0138153c ,	0x01387e87 ,
	0x0138390c ,	0x01380f3e ,	0x01380099 ,	0x01380124 ,
	0x0138305e ,	0x0138440d ,	0x0138491c ,	0x01384d06 ,
	0x01384db7 ,	0x01381547 ,	0x013854de ,	0x013839b3 ,
	0x01382d12 ,	0x0138074d ,	0x01384dc8 ,	0x01386443 ,
	0x013866bb ,	0x0138428b ,	0x013826a6 ,	0x0138701f ,
	0x01385d03 ,	0x01387a5a ,	0x0138767d ,	0x01384509 ,
	0x01381238 ,	0x01383b25 ,	0x01381e1f ,	0x01386e5d ,
	0x01381ad4 ,	0x013863cb ,	0x01386bfc ,	0x01387f96 ,
	0x01387ff5 ,	0x01384e45 ,	0x0138323b ,	0x01382213 ,
	0x0138260d ,	0x01386b89 ,	0x0138030a ,	0x0138301c ,
	0x01380bdb ,	0x013856ae ,	0x01380732 ,	0x01380120 ,
	0x0138759a ,	0x01382350 ,	0x013822ee ,	0x01384b40 ,
	0x01385878 ,	0x01386b36 ,	0x01385cfd ,	0x01383e12 ,
	0x01381a49 ,	0x01385f32 ,	0x01383bf6 ,	0x01383a9e ,
	0x0138797d ,	0x01385f49 ,	0x01380ddc ,	0x01384cad ,
	0x0138314f ,	0x01385e14 ,	0x01384df2 ,	0x01384944 ,
	0x01382e40 ,	0x01381366 ,	0x01381cd0 ,	0x0138366b ,
	0x013866c4 ,	0x01384230 ,	0x01387eb7 ,	0x01386032 ,
	0x01382c3b ,	0x013815a1 ,	0x01385422 ,	0x01383ef6 ,
	0x01380822 ,	0x01385991 ,	0x0138409d ,    0x01381101 ,

	0x01397f9b ,	0x013918e5 ,	0x01397485 ,	0x0139781c ,
	0x01394328 ,	0x013954fb ,	0x01392948 ,	0x01392702 ,
	0x01393623 ,	0x01394744 ,	0x01391209 ,	0x01394a32 ,
	0x01395f7d ,	0x013910b5 ,	0x01396a73 ,	0x013912f6 ,
	0x01393e6b ,	0x01393a85 ,	0x01394277 ,	0x01390ecf ,
	0x01393274 ,	0x01394ded ,	0x01396404 ,	0x01390029 ,
	0x01394823 ,	0x013918be ,	0x01396784 ,	0x01394ae1 ,
	0x01393d6c ,	0x01392cd6 ,	0x013972ae ,	0x01396952 ,
	0x01395f90 ,	0x01391649 ,	0x01396df1 ,	0x01395af1 ,
	0x013941bb ,	0x013926e9 ,	0x013901eb ,	0x01390bb3 ,
	0x01392ea6 ,	0x013912db ,	0x0139153c ,	0x01397e87 ,
	0x0139390c ,	0x01390f3e ,	0x01390099 ,	0x01390124 ,
	0x0139305e ,	0x0139440d ,	0x0139491c ,	0x01394d06 ,
	0x01394db7 ,	0x01391547 ,	0x013954de ,	0x013939b3 ,
	0x01392d12 ,	0x0139074d ,	0x01394dc8 ,	0x01396443 ,
	0x013966bb ,	0x0139428b ,	0x013926a6 ,	0x0139701f ,
	0x01395d03 ,	0x01397a5a ,	0x0139767d ,	0x01394509 ,
	0x01391238 ,	0x01393b25 ,	0x01391e1f ,	0x01396e5d ,
	0x01391ad4 ,	0x013963cb ,	0x01396bfc ,	0x01397f96 ,
	0x01397ff5 ,	0x01394e45 ,	0x0139323b ,	0x01392213 ,
	0x0139260d ,	0x01396b89 ,	0x0139030a ,	0x0139301c ,
	0x01390bdb ,	0x013956ae ,	0x01390732 ,	0x01390120 ,
	0x0139759a ,	0x01392350 ,	0x013922ee ,	0x01394b40 ,
	0x01395878 ,	0x01396b36 ,	0x01395cfd ,	0x01393e12 ,
	0x01391a49 ,	0x01395f32 ,	0x01393bf6 ,	0x01393a9e ,
	0x0139797d ,	0x01395f49 ,	0x01390ddc ,	0x01394cad ,
	0x0139314f ,	0x01395e14 ,	0x01394df2 ,	0x01394944 ,
	0x01392e40 ,	0x01391366 ,	0x01391cd0 ,	0x0139366b ,
	0x013966c4 ,	0x01394230 ,	0x01397eb7 ,	0x01396032 ,
	0x01392c3b ,	0x013915a1 ,	0x01395422 ,	0x01393ef6 ,
	0x01390822 ,	0x01395991 ,	0x0139409d ,    0x01391101 ,

	0x01407f9b ,	0x014018e5 ,	0x01407485 ,	0x0140781c ,
	0x01404328 ,	0x014054fb ,	0x01402948 ,	0x01402702 ,
	0x01403623 ,	0x01404744 ,	0x01401209 ,	0x01404a32 ,
	0x01405f7d ,	0x014010b5 ,	0x01406a73 ,	0x014012f6 ,
	0x01403e6b ,	0x01403a85 ,	0x01404277 ,	0x01400ecf ,
	0x01403274 ,	0x01404ded ,	0x01406404 ,	0x01400029 ,
	0x01404823 ,	0x014018be ,	0x01406784 ,	0x01404ae1 ,
	0x01403d6c ,	0x01402cd6 ,	0x014072ae ,	0x01406952 ,
	0x01405f90 ,	0x01401649 ,	0x01406df1 ,	0x01405af1 ,
	0x014041bb ,	0x014026e9 ,	0x014001eb ,	0x01400bb3 ,
	0x01402ea6 ,	0x014012db ,	0x0140153c ,	0x01407e87 ,
	0x0140390c ,	0x01400f3e ,	0x01400099 ,	0x01400124 ,
	0x0140305e ,	0x0140440d ,	0x0140491c ,	0x01404d06 ,
	0x01404db7 ,	0x01401547 ,	0x014054de ,	0x014039b3 ,
	0x01402d12 ,	0x0140074d ,	0x01404dc8 ,	0x01406443 ,
	0x014066bb ,	0x0140428b ,	0x014026a6 ,	0x0140701f ,
	0x01405d03 ,	0x01407a5a ,	0x0140767d ,	0x01404509 ,
	0x01401238 ,	0x01403b25 ,	0x01401e1f ,	0x01406e5d ,
	0x01401ad4 ,	0x014063cb ,	0x01406bfc ,	0x01407f96 ,
	0x01407ff5 ,	0x01404e45 ,	0x0140323b ,	0x01402213 ,
	0x0140260d ,	0x01406b89 ,	0x0140030a ,	0x0140301c ,
	0x01400bdb ,	0x014056ae ,	0x01400732 ,	0x01400120 ,
	0x0140759a ,	0x01402350 ,	0x014022ee ,	0x01404b40 ,
	0x01405878 ,	0x01406b36 ,	0x01405cfd ,	0x01403e12 ,
	0x01401a49 ,	0x01405f32 ,	0x01403bf6 ,	0x01403a9e ,
	0x0140797d ,	0x01405f49 ,	0x01400ddc ,	0x01404cad ,
	0x0140314f ,	0x01405e14 ,	0x01404df2 ,	0x01404944 ,
	0x01402e40 ,	0x01401366 ,	0x01401cd0 ,	0x0140366b ,
	0x014066c4 ,	0x01404230 ,	0x01407eb7 ,	0x01406032 ,
	0x01402c3b ,	0x014015a1 ,	0x01405422 ,	0x01403ef6 ,
	0x01400822 ,	0x01405991 ,	0x0140409d ,    0x01401101 ,

	0x01417f9b ,	0x014118e5 ,	0x01417485 ,	0x0141781c ,
	0x01414328 ,	0x014154fb ,	0x01412948 ,	0x01412702 ,
	0x01413623 ,	0x01414744 ,	0x01411209 ,	0x01414a32 ,
	0x01415f7d ,	0x014110b5 ,	0x01416a73 ,	0x014112f6 ,
	0x01413e6b ,	0x01413a85 ,	0x01414277 ,	0x01410ecf ,
	0x01413274 ,	0x01414ded ,	0x01416404 ,	0x01410029 ,
	0x01414823 ,	0x014118be ,	0x01416784 ,	0x01414ae1 ,
	0x01413d6c ,	0x01412cd6 ,	0x014172ae ,	0x01416952 ,
	0x01415f90 ,	0x01411649 ,	0x01416df1 ,	0x01415af1 ,
	0x014141bb ,	0x014126e9 ,	0x014101eb ,	0x01410bb3 ,
	0x01412ea6 ,	0x014112db ,	0x0141153c ,	0x01417e87 ,
	0x0141390c ,	0x01410f3e ,	0x01410099 ,	0x01410124 ,
	0x0141305e ,	0x0141440d ,	0x0141491c ,	0x01414d06 ,
	0x01414db7 ,	0x01411547 ,	0x014154de ,	0x014139b3 ,
	0x01412d12 ,	0x0141074d ,	0x01414dc8 ,	0x01416443 ,
	0x014166bb ,	0x0141428b ,	0x014126a6 ,	0x0141701f ,
	0x01415d03 ,	0x01417a5a ,	0x0141767d ,	0x01414509 ,
	0x01411238 ,	0x01413b25 ,	0x01411e1f ,	0x01416e5d ,
	0x01411ad4 ,	0x014163cb ,	0x01416bfc ,	0x01417f96 ,
	0x01417ff5 ,	0x01414e45 ,	0x0141323b ,	0x01412213 ,
	0x0141260d ,	0x01416b89 ,	0x0141030a ,	0x0141301c ,
	0x01410bdb ,	0x014156ae ,	0x01410732 ,	0x01410120 ,
	0x0141759a ,	0x01412350 ,	0x014122ee ,	0x01414b40 ,
	0x01415878 ,	0x01416b36 ,	0x01415cfd ,	0x01413e12 ,
	0x01411a49 ,	0x01415f32 ,	0x01413bf6 ,	0x01413a9e ,
	0x0141797d ,	0x01415f49 ,	0x01410ddc ,	0x01414cad ,
	0x0141314f ,	0x01415e14 ,	0x01414df2 ,	0x01414944 ,
	0x01412e40 ,	0x01411366 ,	0x01411cd0 ,	0x0141366b ,
	0x014166c4 ,	0x01414230 ,	0x01417eb7 ,	0x01416032 ,
	0x01412c3b ,	0x014115a1 ,	0x01415422 ,	0x01413ef6 ,
	0x01410822 ,	0x01415991 ,	0x0141409d ,    0x01411101 ,

	0x01427f9b ,	0x014218e5 ,	0x01427485 ,	0x0142781c ,
	0x01424328 ,	0x014254fb ,	0x01422948 ,	0x01422702 ,
	0x01423623 ,	0x01424744 ,	0x01421209 ,	0x01424a32 ,
	0x01425f7d ,	0x014210b5 ,	0x01426a73 ,	0x014212f6 ,
	0x01423e6b ,	0x01423a85 ,	0x01424277 ,	0x01420ecf ,
	0x01423274 ,	0x01424ded ,	0x01426404 ,	0x01420029 ,
	0x01424823 ,	0x014218be ,	0x01426784 ,	0x01424ae1 ,
	0x01423d6c ,	0x01422cd6 ,	0x014272ae ,	0x01426952 ,
	0x01425f90 ,	0x01421649 ,	0x01426df1 ,	0x01425af1 ,
	0x014241bb ,	0x014226e9 ,	0x014201eb ,	0x01420bb3 ,
	0x01422ea6 ,	0x014212db ,	0x0142153c ,	0x01427e87 ,
	0x0142390c ,	0x01420f3e ,	0x01420099 ,	0x01420124 ,
	0x0142305e ,	0x0142440d ,	0x0142491c ,	0x01424d06 ,
	0x01424db7 ,	0x01421547 ,	0x014254de ,	0x014239b3 ,
	0x01422d12 ,	0x0142074d ,	0x01424dc8 ,	0x01426443 ,
	0x014266bb ,	0x0142428b ,	0x014226a6 ,	0x0142701f ,
	0x01425d03 ,	0x01427a5a ,	0x0142767d ,	0x01424509 ,
	0x01421238 ,	0x01423b25 ,	0x01421e1f ,	0x01426e5d ,
	0x01421ad4 ,	0x014263cb ,	0x01426bfc ,	0x01427f96 ,
	0x01427ff5 ,	0x01424e45 ,	0x0142323b ,	0x01422213 ,
	0x0142260d ,	0x01426b89 ,	0x0142030a ,	0x0142301c ,
	0x01420bdb ,	0x014256ae ,	0x01420732 ,	0x01420120 ,
	0x0142759a ,	0x01422350 ,	0x014222ee ,	0x01424b40 ,
	0x01425878 ,	0x01426b36 ,	0x01425cfd ,	0x01423e12 ,
	0x01421a49 ,	0x01425f32 ,	0x01423bf6 ,	0x01423a9e ,
	0x0142797d ,	0x01425f49 ,	0x01420ddc ,	0x01424cad ,
	0x0142314f ,	0x01425e14 ,	0x01424df2 ,	0x01424944 ,
	0x01422e40 ,	0x01421366 ,	0x01421cd0 ,	0x0142366b ,
	0x014266c4 ,	0x01424230 ,	0x01427eb7 ,	0x01426032 ,
	0x01422c3b ,	0x014215a1 ,	0x01425422 ,	0x01423ef6 ,
	0x01420822 ,	0x01425991 ,	0x0142409d ,    0x01421101 ,

	0x01437f9b ,	0x014318e5 ,	0x01437485 ,	0x0143781c ,
	0x01434328 ,	0x014354fb ,	0x01432948 ,	0x01432702 ,
	0x01433623 ,	0x01434744 ,	0x01431209 ,	0x01434a32 ,
	0x01435f7d ,	0x014310b5 ,	0x01436a73 ,	0x014312f6 ,
	0x01433e6b ,	0x01433a85 ,	0x01434277 ,	0x01430ecf ,
	0x01433274 ,	0x01434ded ,	0x01436404 ,	0x01430029 ,
	0x01434823 ,	0x014318be ,	0x01436784 ,	0x01434ae1 ,
	0x01433d6c ,	0x01432cd6 ,	0x014372ae ,	0x01436952 ,
	0x01435f90 ,	0x01431649 ,	0x01436df1 ,	0x01435af1 ,
	0x014341bb ,	0x014326e9 ,	0x014301eb ,	0x01430bb3 ,
	0x01432ea6 ,	0x014312db ,	0x0143153c ,	0x01437e87 ,
	0x0143390c ,	0x01430f3e ,	0x01430099 ,	0x01430124 ,
	0x0143305e ,	0x0143440d ,	0x0143491c ,	0x01434d06 ,
	0x01434db7 ,	0x01431547 ,	0x014354de ,	0x014339b3 ,
	0x01432d12 ,	0x0143074d ,	0x01434dc8 ,	0x01436443 ,
	0x014366bb ,	0x0143428b ,	0x014326a6 ,	0x0143701f ,
	0x01435d03 ,	0x01437a5a ,	0x0143767d ,	0x01434509 ,
	0x01431238 ,	0x01433b25 ,	0x01431e1f ,	0x01436e5d ,
	0x01431ad4 ,	0x014363cb ,	0x01436bfc ,	0x01437f96 ,
	0x01437ff5 ,	0x01434e45 ,	0x0143323b ,	0x01432213 ,
	0x0143260d ,	0x01436b89 ,	0x0143030a ,	0x0143301c ,
	0x01430bdb ,	0x014356ae ,	0x01430732 ,	0x01430120 ,
	0x0143759a ,	0x01432350 ,	0x014322ee ,	0x01434b40 ,
	0x01435878 ,	0x01436b36 ,	0x01435cfd ,	0x01433e12 ,
	0x01431a49 ,	0x01435f32 ,	0x01433bf6 ,	0x01433a9e ,
	0x0143797d ,	0x01435f49 ,	0x01430ddc ,	0x01434cad ,
	0x0143314f ,	0x01435e14 ,	0x01434df2 ,	0x01434944 ,
	0x01432e40 ,	0x01431366 ,	0x01431cd0 ,	0x0143366b ,
	0x014366c4 ,	0x01434230 ,	0x01437eb7 ,	0x01436032 ,
	0x01432c3b ,	0x014315a1 ,	0x01435422 ,	0x01433ef6 ,
	0x01430822 ,	0x01435991 ,	0x0143409d ,    0x01431101 ,

	0x01447f9b ,	0x014418e5 ,	0x01447485 ,	0x0144781c ,
	0x01444328 ,	0x014454fb ,	0x01442948 ,	0x01442702 ,
	0x01443623 ,	0x01444744 ,	0x01441209 ,	0x01444a32 ,
	0x01445f7d ,	0x014410b5 ,	0x01446a73 ,	0x014412f6 ,
	0x01443e6b ,	0x01443a85 ,	0x01444277 ,	0x01440ecf ,
	0x01443274 ,	0x01444ded ,	0x01446404 ,	0x01440029 ,
	0x01444823 ,	0x014418be ,	0x01446784 ,	0x01444ae1 ,
	0x01443d6c ,	0x01442cd6 ,	0x014472ae ,	0x01446952 ,
	0x01445f90 ,	0x01441649 ,	0x01446df1 ,	0x01445af1 ,
	0x014441bb ,	0x014426e9 ,	0x014401eb ,	0x01440bb3 ,
	0x01442ea6 ,	0x014412db ,	0x0144153c ,	0x01447e87 ,
	0x0144390c ,	0x01440f3e ,	0x01440099 ,	0x01440124 ,
	0x0144305e ,	0x0144440d ,	0x0144491c ,	0x01444d06 ,
	0x01444db7 ,	0x01441547 ,	0x014454de ,	0x014439b3 ,
	0x01442d12 ,	0x0144074d ,	0x01444dc8 ,	0x01446443 ,
	0x014466bb ,	0x0144428b ,	0x014426a6 ,	0x0144701f ,
	0x01445d03 ,	0x01447a5a ,	0x0144767d ,	0x01444509 ,
	0x01441238 ,	0x01443b25 ,	0x01441e1f ,	0x01446e5d ,
	0x01441ad4 ,	0x014463cb ,	0x01446bfc ,	0x01447f96 ,
	0x01447ff5 ,	0x01444e45 ,	0x0144323b ,	0x01442213 ,
	0x0144260d ,	0x01446b89 ,	0x0144030a ,	0x0144301c ,
	0x01440bdb ,	0x014456ae ,	0x01440732 ,	0x01440120 ,
	0x0144759a ,	0x01442350 ,	0x014422ee ,	0x01444b40 ,
	0x01445878 ,	0x01446b36 ,	0x01445cfd ,	0x01443e12 ,
	0x01441a49 ,	0x01445f32 ,	0x01443bf6 ,	0x01443a9e ,
	0x0144797d ,	0x01445f49 ,	0x01440ddc ,	0x01444cad ,
	0x0144314f ,	0x01445e14 ,	0x01444df2 ,	0x01444944 ,
	0x01442e40 ,	0x01441366 ,	0x01441cd0 ,	0x0144366b ,
	0x014466c4 ,	0x01444230 ,	0x01447eb7 ,	0x01446032 ,
	0x01442c3b ,	0x014415a1 ,	0x01445422 ,	0x01443ef6 ,
	0x01440822 ,	0x01445991 ,	0x0144409d ,    0x01441101 ,

	0x01457f9b ,	0x014518e5 ,	0x01457485 ,	0x0145781c ,
	0x01454328 ,	0x014554fb ,	0x01452948 ,	0x01452702 ,
	0x01453623 ,	0x01454744 ,	0x01451209 ,	0x01454a32 ,
	0x01455f7d ,	0x014510b5 ,	0x01456a73 ,	0x014512f6 ,
	0x01453e6b ,	0x01453a85 ,	0x01454277 ,	0x01450ecf ,
	0x01453274 ,	0x01454ded ,	0x01456404 ,	0x01450029 ,
	0x01454823 ,	0x014518be ,	0x01456784 ,	0x01454ae1 ,
	0x01453d6c ,	0x01452cd6 ,	0x014572ae ,	0x01456952 ,
	0x01455f90 ,	0x01451649 ,	0x01456df1 ,	0x01455af1 ,
	0x014541bb ,	0x014526e9 ,	0x014501eb ,	0x01450bb3 ,
	0x01452ea6 ,	0x014512db ,	0x0145153c ,	0x01457e87 ,
	0x0145390c ,	0x01450f3e ,	0x01450099 ,	0x01450124 ,
	0x0145305e ,	0x0145440d ,	0x0145491c ,	0x01454d06 ,
	0x01454db7 ,	0x01451547 ,	0x014554de ,	0x014539b3 ,
	0x01452d12 ,	0x0145074d ,	0x01454dc8 ,	0x01456443 ,
	0x014566bb ,	0x0145428b ,	0x014526a6 ,	0x0145701f ,
	0x01455d03 ,	0x01457a5a ,	0x0145767d ,	0x01454509 ,
	0x01451238 ,	0x01453b25 ,	0x01451e1f ,	0x01456e5d ,
	0x01451ad4 ,	0x014563cb ,	0x01456bfc ,	0x01457f96 ,
	0x01457ff5 ,	0x01454e45 ,	0x0145323b ,	0x01452213 ,
	0x0145260d ,	0x01456b89 ,	0x0145030a ,	0x0145301c ,
	0x01450bdb ,	0x014556ae ,	0x01450732 ,	0x01450120 ,
	0x0145759a ,	0x01452350 ,	0x014522ee ,	0x01454b40 ,
	0x01455878 ,	0x01456b36 ,	0x01455cfd ,	0x01453e12 ,
	0x01451a49 ,	0x01455f32 ,	0x01453bf6 ,	0x01453a9e ,
	0x0145797d ,	0x01455f49 ,	0x01450ddc ,	0x01454cad ,
	0x0145314f ,	0x01455e14 ,	0x01454df2 ,	0x01454944 ,
	0x01452e40 ,	0x01451366 ,	0x01451cd0 ,	0x0145366b ,
	0x014566c4 ,	0x01454230 ,	0x01457eb7 ,	0x01456032 ,
	0x01452c3b ,	0x014515a1 ,	0x01455422 ,	0x01453ef6 ,
	0x01450822 ,	0x01455991 ,	0x0145409d ,    0x01451101 ,

	0x01467f9b ,	0x014618e5 ,	0x01467485 ,	0x0146781c ,
	0x01464328 ,	0x014654fb ,	0x01462948 ,	0x01462702 ,
	0x01463623 ,	0x01464744 ,	0x01461209 ,	0x01464a32 ,
	0x01465f7d ,	0x014610b5 ,	0x01466a73 ,	0x014612f6 ,
	0x01463e6b ,	0x01463a85 ,	0x01464277 ,	0x01460ecf ,
	0x01463274 ,	0x01464ded ,	0x01466404 ,	0x01460029 ,
	0x01464823 ,	0x014618be ,	0x01466784 ,	0x01464ae1 ,
	0x01463d6c ,	0x01462cd6 ,	0x014672ae ,	0x01466952 ,
	0x01465f90 ,	0x01461649 ,	0x01466df1 ,	0x01465af1 ,
	0x014641bb ,	0x014626e9 ,	0x014601eb ,	0x01460bb3 ,
	0x01462ea6 ,	0x014612db ,	0x0146153c ,	0x01467e87 ,
	0x0146390c ,	0x01460f3e ,	0x01460099 ,	0x01460124 ,
	0x0146305e ,	0x0146440d ,	0x0146491c ,	0x01464d06 ,
	0x01464db7 ,	0x01461547 ,	0x014654de ,	0x014639b3 ,
	0x01462d12 ,	0x0146074d ,	0x01464dc8 ,	0x01466443 ,
	0x014666bb ,	0x0146428b ,	0x014626a6 ,	0x0146701f ,
	0x01465d03 ,	0x01467a5a ,	0x0146767d ,	0x01464509 ,
	0x01461238 ,	0x01463b25 ,	0x01461e1f ,	0x01466e5d ,
	0x01461ad4 ,	0x014663cb ,	0x01466bfc ,	0x01467f96 ,
	0x01467ff5 ,	0x01464e45 ,	0x0146323b ,	0x01462213 ,
	0x0146260d ,	0x01466b89 ,	0x0146030a ,	0x0146301c ,
	0x01460bdb ,	0x014656ae ,	0x01460732 ,	0x01460120 ,
	0x0146759a ,	0x01462350 ,	0x014622ee ,	0x01464b40 ,
	0x01465878 ,	0x01466b36 ,	0x01465cfd ,	0x01463e12 ,
	0x01461a49 ,	0x01465f32 ,	0x01463bf6 ,	0x01463a9e ,
	0x0146797d ,	0x01465f49 ,	0x01460ddc ,	0x01464cad ,
	0x0146314f ,	0x01465e14 ,	0x01464df2 ,	0x01464944 ,
	0x01462e40 ,	0x01461366 ,	0x01461cd0 ,	0x0146366b ,
	0x014666c4 ,	0x01464230 ,	0x01467eb7 ,	0x01466032 ,
	0x01462c3b ,	0x014615a1 ,	0x01465422 ,	0x01463ef6 ,
	0x01460822 ,	0x01465991 ,	0x0146409d ,    0x01461101 ,

	0x01477f9b ,	0x014718e5 ,	0x01477485 ,	0x0147781c ,
	0x01474328 ,	0x014754fb ,	0x01472948 ,	0x01472702 ,
	0x01473623 ,	0x01474744 ,	0x01471209 ,	0x01474a32 ,
	0x01475f7d ,	0x014710b5 ,	0x01476a73 ,	0x014712f6 ,
	0x01473e6b ,	0x01473a85 ,	0x01474277 ,	0x01470ecf ,
	0x01473274 ,	0x01474ded ,	0x01476404 ,	0x01470029 ,
	0x01474823 ,	0x014718be ,	0x01476784 ,	0x01474ae1 ,
	0x01473d6c ,	0x01472cd6 ,	0x014772ae ,	0x01476952 ,
	0x01475f90 ,	0x01471649 ,	0x01476df1 ,	0x01475af1 ,
	0x014741bb ,	0x014726e9 ,	0x014701eb ,	0x01470bb3 ,
	0x01472ea6 ,	0x014712db ,	0x0147153c ,	0x01477e87 ,
	0x0147390c ,	0x01470f3e ,	0x01470099 ,	0x01470124 ,
	0x0147305e ,	0x0147440d ,	0x0147491c ,	0x01474d06 ,
	0x01474db7 ,	0x01471547 ,	0x014754de ,	0x014739b3 ,
	0x01472d12 ,	0x0147074d ,	0x01474dc8 ,	0x01476443 ,
	0x014766bb ,	0x0147428b ,	0x014726a6 ,	0x0147701f ,
	0x01475d03 ,	0x01477a5a ,	0x0147767d ,	0x01474509 ,
	0x01471238 ,	0x01473b25 ,	0x01471e1f ,	0x01476e5d ,
	0x01471ad4 ,	0x014763cb ,	0x01476bfc ,	0x01477f96 ,
	0x01477ff5 ,	0x01474e45 ,	0x0147323b ,	0x01472213 ,
	0x0147260d ,	0x01476b89 ,	0x0147030a ,	0x0147301c ,
	0x01470bdb ,	0x014756ae ,	0x01470732 ,	0x01470120 ,
	0x0147759a ,	0x01472350 ,	0x014722ee ,	0x01474b40 ,
	0x01475878 ,	0x01476b36 ,	0x01475cfd ,	0x01473e12 ,
	0x01471a49 ,	0x01475f32 ,	0x01473bf6 ,	0x01473a9e ,
	0x0147797d ,	0x01475f49 ,	0x01470ddc ,	0x01474cad ,
	0x0147314f ,	0x01475e14 ,	0x01474df2 ,	0x01474944 ,
	0x01472e40 ,	0x01471366 ,	0x01471cd0 ,	0x0147366b ,
	0x014766c4 ,	0x01474230 ,	0x01477eb7 ,	0x01476032 ,
	0x01472c3b ,	0x014715a1 ,	0x01475422 ,	0x01473ef6 ,
	0x01470822 ,	0x01475991 ,	0x0147409d ,    0x01471101 ,

	0x01487f9b ,	0x014818e5 ,	0x01487485 ,	0x0148781c ,
	0x01484328 ,	0x014854fb ,	0x01482948 ,	0x01482702 ,
	0x01483623 ,	0x01484744 ,	0x01481209 ,	0x01484a32 ,
	0x01485f7d ,	0x014810b5 ,	0x01486a73 ,	0x014812f6 ,
	0x01483e6b ,	0x01483a85 ,	0x01484277 ,	0x01480ecf ,
	0x01483274 ,	0x01484ded ,	0x01486404 ,	0x01480029 ,
	0x01484823 ,	0x014818be ,	0x01486784 ,	0x01484ae1 ,
	0x01483d6c ,	0x01482cd6 ,	0x014872ae ,	0x01486952 ,
	0x01485f90 ,	0x01481649 ,	0x01486df1 ,	0x01485af1 ,
	0x014841bb ,	0x014826e9 ,	0x014801eb ,	0x01480bb3 ,
	0x01482ea6 ,	0x014812db ,	0x0148153c ,	0x01487e87 ,
	0x0148390c ,	0x01480f3e ,	0x01480099 ,	0x01480124 ,
	0x0148305e ,	0x0148440d ,	0x0148491c ,	0x01484d06 ,
	0x01484db7 ,	0x01481547 ,	0x014854de ,	0x014839b3 ,
	0x01482d12 ,	0x0148074d ,	0x01484dc8 ,	0x01486443 ,
	0x014866bb ,	0x0148428b ,	0x014826a6 ,	0x0148701f ,
	0x01485d03 ,	0x01487a5a ,	0x0148767d ,	0x01484509 ,
	0x01481238 ,	0x01483b25 ,	0x01481e1f ,	0x01486e5d ,
	0x01481ad4 ,	0x014863cb ,	0x01486bfc ,	0x01487f96 ,
	0x01487ff5 ,	0x01484e45 ,	0x0148323b ,	0x01482213 ,
	0x0148260d ,	0x01486b89 ,	0x0148030a ,	0x0148301c ,
	0x01480bdb ,	0x014856ae ,	0x01480732 ,	0x01480120 ,
	0x0148759a ,	0x01482350 ,	0x014822ee ,	0x01484b40 ,
	0x01485878 ,	0x01486b36 ,	0x01485cfd ,	0x01483e12 ,
	0x01481a49 ,	0x01485f32 ,	0x01483bf6 ,	0x01483a9e ,
	0x0148797d ,	0x01485f49 ,	0x01480ddc ,	0x01484cad ,
	0x0148314f ,	0x01485e14 ,	0x01484df2 ,	0x01484944 ,
	0x01482e40 ,	0x01481366 ,	0x01481cd0 ,	0x0148366b ,
	0x014866c4 ,	0x01484230 ,	0x01487eb7 ,	0x01486032 ,
	0x01482c3b ,	0x014815a1 ,	0x01485422 ,	0x01483ef6 ,
	0x01480822 ,	0x01485991 ,	0x0148409d ,    0x01481101 ,

	0x01497f9b ,	0x014918e5 ,	0x01497485 ,	0x0149781c ,
	0x01494328 ,	0x014954fb ,	0x01492948 ,	0x01492702 ,
	0x01493623 ,	0x01494744 ,	0x01491209 ,	0x01494a32 ,
	0x01495f7d ,	0x014910b5 ,	0x01496a73 ,	0x014912f6 ,
	0x01493e6b ,	0x01493a85 ,	0x01494277 ,	0x01490ecf ,
	0x01493274 ,	0x01494ded ,	0x01496404 ,	0x01490029 ,
	0x01494823 ,	0x014918be ,	0x01496784 ,	0x01494ae1 ,
	0x01493d6c ,	0x01492cd6 ,	0x014972ae ,	0x01496952 ,
	0x01495f90 ,	0x01491649 ,	0x01496df1 ,	0x01495af1 ,
	0x014941bb ,	0x014926e9 ,	0x014901eb ,	0x01490bb3 ,
	0x01492ea6 ,	0x014912db ,	0x0149153c ,	0x01497e87 ,
	0x0149390c ,	0x01490f3e ,	0x01490099 ,	0x01490124 ,
	0x0149305e ,	0x0149440d ,	0x0149491c ,	0x01494d06 ,
	0x01494db7 ,	0x01491547 ,	0x014954de ,	0x014939b3 ,
	0x01492d12 ,	0x0149074d ,	0x01494dc8 ,	0x01496443 ,
	0x014966bb ,	0x0149428b ,	0x014926a6 ,	0x0149701f ,
	0x01495d03 ,	0x01497a5a ,	0x0149767d ,	0x01494509 ,
	0x01491238 ,	0x01493b25 ,	0x01491e1f ,	0x01496e5d ,
	0x01491ad4 ,	0x014963cb ,	0x01496bfc ,	0x01497f96 ,
	0x01497ff5 ,	0x01494e45 ,	0x0149323b ,	0x01492213 ,
	0x0149260d ,	0x01496b89 ,	0x0149030a ,	0x0149301c ,
	0x01490bdb ,	0x014956ae ,	0x01490732 ,	0x01490120 ,
	0x0149759a ,	0x01492350 ,	0x014922ee ,	0x01494b40 ,
	0x01495878 ,	0x01496b36 ,	0x01495cfd ,	0x01493e12 ,
	0x01491a49 ,	0x01495f32 ,	0x01493bf6 ,	0x01493a9e ,
	0x0149797d ,	0x01495f49 ,	0x01490ddc ,	0x01494cad ,
	0x0149314f ,	0x01495e14 ,	0x01494df2 ,	0x01494944 ,
	0x01492e40 ,	0x01491366 ,	0x01491cd0 ,	0x0149366b ,
	0x014966c4 ,	0x01494230 ,	0x01497eb7 ,	0x01496032 ,
	0x01492c3b ,	0x014915a1 ,	0x01495422 ,	0x01493ef6 ,
	0x01490822 ,	0x01495991 ,	0x0149409d ,    0x01491101 ,

	0x01507f9b ,	0x015018e5 ,	0x01507485 ,	0x0150781c ,
	0x01504328 ,	0x015054fb ,	0x01502948 ,	0x01502702 ,
	0x01503623 ,	0x01504744 ,	0x01501209 ,	0x01504a32 ,
	0x01505f7d ,	0x015010b5 ,	0x01506a73 ,	0x015012f6 ,
	0x01503e6b ,	0x01503a85 ,	0x01504277 ,	0x01500ecf ,
	0x01503274 ,	0x01504ded ,	0x01506404 ,	0x01500029 ,
	0x01504823 ,	0x015018be ,	0x01506784 ,	0x01504ae1 ,
	0x01503d6c ,	0x01502cd6 ,	0x015072ae ,	0x01506952 ,
	0x01505f90 ,	0x01501649 ,	0x01506df1 ,	0x01505af1 ,
	0x015041bb ,	0x015026e9 ,	0x015001eb ,	0x01500bb3 ,
	0x01502ea6 ,	0x015012db ,	0x0150153c ,	0x01507e87 ,
	0x0150390c ,	0x01500f3e ,	0x01500099 ,	0x01500124 ,
	0x0150305e ,	0x0150440d ,	0x0150491c ,	0x01504d06 ,
	0x01504db7 ,	0x01501547 ,	0x015054de ,	0x015039b3 ,
	0x01502d12 ,	0x0150074d ,	0x01504dc8 ,	0x01506443 ,
	0x015066bb ,	0x0150428b ,	0x015026a6 ,	0x0150701f ,
	0x01505d03 ,	0x01507a5a ,	0x0150767d ,	0x01504509 ,
	0x01501238 ,	0x01503b25 ,	0x01501e1f ,	0x01506e5d ,
	0x01501ad4 ,	0x015063cb ,	0x01506bfc ,	0x01507f96 ,
	0x01507ff5 ,	0x01504e45 ,	0x0150323b ,	0x01502213 ,
	0x0150260d ,	0x01506b89 ,	0x0150030a ,	0x0150301c ,
	0x01500bdb ,	0x015056ae ,	0x01500732 ,	0x01500120 ,
	0x0150759a ,	0x01502350 ,	0x015022ee ,	0x01504b40 ,
	0x01505878 ,	0x01506b36 ,	0x01505cfd ,	0x01503e12 ,
	0x01501a49 ,	0x01505f32 ,	0x01503bf6 ,	0x01503a9e ,
	0x0150797d ,	0x01505f49 ,	0x01500ddc ,	0x01504cad ,
	0x0150314f ,	0x01505e14 ,	0x01504df2 ,	0x01504944 ,
	0x01502e40 ,	0x01501366 ,	0x01501cd0 ,	0x0150366b ,
	0x015066c4 ,	0x01504230 ,	0x01507eb7 ,	0x01506032 ,
	0x01502c3b ,	0x015015a1 ,	0x01505422 ,	0x01503ef6 ,
	0x01500822 ,	0x01505991 ,	0x0150409d ,    0x01501101 ,

	0x01517f9b ,	0x015118e5 ,	0x01517485 ,	0x0151781c ,
	0x01514328 ,	0x015154fb ,	0x01512948 ,	0x01512702 ,
	0x01513623 ,	0x01514744 ,	0x01511209 ,	0x01514a32 ,
	0x01515f7d ,	0x015110b5 ,	0x01516a73 ,	0x015112f6 ,
	0x01513e6b ,	0x01513a85 ,	0x01514277 ,	0x01510ecf ,
	0x01513274 ,	0x01514ded ,	0x01516404 ,	0x01510029 ,
	0x01514823 ,	0x015118be ,	0x01516784 ,	0x01514ae1 ,
	0x01513d6c ,	0x01512cd6 ,	0x015172ae ,	0x01516952 ,
	0x01515f90 ,	0x01511649 ,	0x01516df1 ,	0x01515af1 ,
	0x015141bb ,	0x015126e9 ,	0x015101eb ,	0x01510bb3 ,
	0x01512ea6 ,	0x015112db ,	0x0151153c ,	0x01517e87 ,
	0x0151390c ,	0x01510f3e ,	0x01510099 ,	0x01510124 ,
	0x0151305e ,	0x0151440d ,	0x0151491c ,	0x01514d06 ,
	0x01514db7 ,	0x01511547 ,	0x015154de ,	0x015139b3 ,
	0x01512d12 ,	0x0151074d ,	0x01514dc8 ,	0x01516443 ,
	0x015166bb ,	0x0151428b ,	0x015126a6 ,	0x0151701f ,
	0x01515d03 ,	0x01517a5a ,	0x0151767d ,	0x01514509 ,
	0x01511238 ,	0x01513b25 ,	0x01511e1f ,	0x01516e5d ,
	0x01511ad4 ,	0x015163cb ,	0x01516bfc ,	0x01517f96 ,
	0x01517ff5 ,	0x01514e45 ,	0x0151323b ,	0x01512213 ,
	0x0151260d ,	0x01516b89 ,	0x0151030a ,	0x0151301c ,
	0x01510bdb ,	0x015156ae ,	0x01510732 ,	0x01510120 ,
	0x0151759a ,	0x01512350 ,	0x015122ee ,	0x01514b40 ,
	0x01515878 ,	0x01516b36 ,	0x01515cfd ,	0x01513e12 ,
	0x01511a49 ,	0x01515f32 ,	0x01513bf6 ,	0x01513a9e ,
	0x0151797d ,	0x01515f49 ,	0x01510ddc ,	0x01514cad ,
	0x0151314f ,	0x01515e14 ,	0x01514df2 ,	0x01514944 ,
	0x01512e40 ,	0x01511366 ,	0x01511cd0 ,	0x0151366b ,
	0x015166c4 ,	0x01514230 ,	0x01517eb7 ,	0x01516032 ,
	0x01512c3b ,	0x015115a1 ,	0x01515422 ,	0x01513ef6 ,
	0x01510822 ,	0x01515991 ,	0x0151409d ,    0x01511101 ,

	0x01527f9b ,	0x015218e5 ,	0x01527485 ,	0x0152781c ,
	0x01524328 ,	0x015254fb ,	0x01522948 ,	0x01522702 ,
	0x01523623 ,	0x01524744 ,	0x01521209 ,	0x01524a32 ,
	0x01525f7d ,	0x015210b5 ,	0x01526a73 ,	0x015212f6 ,
	0x01523e6b ,	0x01523a85 ,	0x01524277 ,	0x01520ecf ,
	0x01523274 ,	0x01524ded ,	0x01526404 ,	0x01520029 ,
	0x01524823 ,	0x015218be ,	0x01526784 ,	0x01524ae1 ,
	0x01523d6c ,	0x01522cd6 ,	0x015272ae ,	0x01526952 ,
	0x01525f90 ,	0x01521649 ,	0x01526df1 ,	0x01525af1 ,
	0x015241bb ,	0x015226e9 ,	0x015201eb ,	0x01520bb3 ,
	0x01522ea6 ,	0x015212db ,	0x0152153c ,	0x01527e87 ,
	0x0152390c ,	0x01520f3e ,	0x01520099 ,	0x01520124 ,
	0x0152305e ,	0x0152440d ,	0x0152491c ,	0x01524d06 ,
	0x01524db7 ,	0x01521547 ,	0x015254de ,	0x015239b3 ,
	0x01522d12 ,	0x0152074d ,	0x01524dc8 ,	0x01526443 ,
	0x015266bb ,	0x0152428b ,	0x015226a6 ,	0x0152701f ,
	0x01525d03 ,	0x01527a5a ,	0x0152767d ,	0x01524509 ,
	0x01521238 ,	0x01523b25 ,	0x01521e1f ,	0x01526e5d ,
	0x01521ad4 ,	0x015263cb ,	0x01526bfc ,	0x01527f96 ,
	0x01527ff5 ,	0x01524e45 ,	0x0152323b ,	0x01522213 ,
	0x0152260d ,	0x01526b89 ,	0x0152030a ,	0x0152301c ,
	0x01520bdb ,	0x015256ae ,	0x01520732 ,	0x01520120 ,
	0x0152759a ,	0x01522350 ,	0x015222ee ,	0x01524b40 ,
	0x01525878 ,	0x01526b36 ,	0x01525cfd ,	0x01523e12 ,
	0x01521a49 ,	0x01525f32 ,	0x01523bf6 ,	0x01523a9e ,
	0x0152797d ,	0x01525f49 ,	0x01520ddc ,	0x01524cad ,
	0x0152314f ,	0x01525e14 ,	0x01524df2 ,	0x01524944 ,
	0x01522e40 ,	0x01521366 ,	0x01521cd0 ,	0x0152366b ,
	0x015266c4 ,	0x01524230 ,	0x01527eb7 ,	0x01526032 ,
	0x01522c3b ,	0x015215a1 ,	0x01525422 ,	0x01523ef6 ,
	0x01520822 ,	0x01525991 ,	0x0152409d ,    0x01521101 ,

	0x01537f9b ,	0x015318e5 ,	0x01537485 ,	0x0153781c ,
	0x01534328 ,	0x015354fb ,	0x01532948 ,	0x01532702 ,
	0x01533623 ,	0x01534744 ,	0x01531209 ,	0x01534a32 ,
	0x01535f7d ,	0x015310b5 ,	0x01536a73 ,	0x015312f6 ,
	0x01533e6b ,	0x01533a85 ,	0x01534277 ,	0x01530ecf ,
	0x01533274 ,	0x01534ded ,	0x01536404 ,	0x01530029 ,
	0x01534823 ,	0x015318be ,	0x01536784 ,	0x01534ae1 ,
	0x01533d6c ,	0x01532cd6 ,	0x015372ae ,	0x01536952 ,
	0x01535f90 ,	0x01531649 ,	0x01536df1 ,	0x01535af1 ,
	0x015341bb ,	0x015326e9 ,	0x015301eb ,	0x01530bb3 ,
	0x01532ea6 ,	0x015312db ,	0x0153153c ,	0x01537e87 ,
	0x0153390c ,	0x01530f3e ,	0x01530099 ,	0x01530124 ,
	0x0153305e ,	0x0153440d ,	0x0153491c ,	0x01534d06 ,
	0x01534db7 ,	0x01531547 ,	0x015354de ,	0x015339b3 ,
	0x01532d12 ,	0x0153074d ,	0x01534dc8 ,	0x01536443 ,
	0x015366bb ,	0x0153428b ,	0x015326a6 ,	0x0153701f ,
	0x01535d03 ,	0x01537a5a ,	0x0153767d ,	0x01534509 ,
	0x01531238 ,	0x01533b25 ,	0x01531e1f ,	0x01536e5d ,
	0x01531ad4 ,	0x015363cb ,	0x01536bfc ,	0x01537f96 ,
	0x01537ff5 ,	0x01534e45 ,	0x0153323b ,	0x01532213 ,
	0x0153260d ,	0x01536b89 ,	0x0153030a ,	0x0153301c ,
	0x01530bdb ,	0x015356ae ,	0x01530732 ,	0x01530120 ,
	0x0153759a ,	0x01532350 ,	0x015322ee ,	0x01534b40 ,
	0x01535878 ,	0x01536b36 ,	0x01535cfd ,	0x01533e12 ,
	0x01531a49 ,	0x01535f32 ,	0x01533bf6 ,	0x01533a9e ,
	0x0153797d ,	0x01535f49 ,	0x01530ddc ,	0x01534cad ,
	0x0153314f ,	0x01535e14 ,	0x01534df2 ,	0x01534944 ,
	0x01532e40 ,	0x01531366 ,	0x01531cd0 ,	0x0153366b ,
	0x015366c4 ,	0x01534230 ,	0x01537eb7 ,	0x01536032 ,
	0x01532c3b ,	0x015315a1 ,	0x01535422 ,	0x01533ef6 ,
	0x01530822 ,	0x01535991 ,	0x0153409d ,    0x01531101 ,

	0x01547f9b ,	0x015418e5 ,	0x01547485 ,	0x0154781c ,
	0x01544328 ,	0x015454fb ,	0x01542948 ,	0x01542702 ,
	0x01543623 ,	0x01544744 ,	0x01541209 ,	0x01544a32 ,
	0x01545f7d ,	0x015410b5 ,	0x01546a73 ,	0x015412f6 ,
	0x01543e6b ,	0x01543a85 ,	0x01544277 ,	0x01540ecf ,
	0x01543274 ,	0x01544ded ,	0x01546404 ,	0x01540029 ,
	0x01544823 ,	0x015418be ,	0x01546784 ,	0x01544ae1 ,
	0x01543d6c ,	0x01542cd6 ,	0x015472ae ,	0x01546952 ,
	0x01545f90 ,	0x01541649 ,	0x01546df1 ,	0x01545af1 ,
	0x015441bb ,	0x015426e9 ,	0x015401eb ,	0x01540bb3 ,
	0x01542ea6 ,	0x015412db ,	0x0154153c ,	0x01547e87 ,
	0x0154390c ,	0x01540f3e ,	0x01540099 ,	0x01540124 ,
	0x0154305e ,	0x0154440d ,	0x0154491c ,	0x01544d06 ,
	0x01544db7 ,	0x01541547 ,	0x015454de ,	0x015439b3 ,
	0x01542d12 ,	0x0154074d ,	0x01544dc8 ,	0x01546443 ,
	0x015466bb ,	0x0154428b ,	0x015426a6 ,	0x0154701f ,
	0x01545d03 ,	0x01547a5a ,	0x0154767d ,	0x01544509 ,
	0x01541238 ,	0x01543b25 ,	0x01541e1f ,	0x01546e5d ,
	0x01541ad4 ,	0x015463cb ,	0x01546bfc ,	0x01547f96 ,
	0x01547ff5 ,	0x01544e45 ,	0x0154323b ,	0x01542213 ,
	0x0154260d ,	0x01546b89 ,	0x0154030a ,	0x0154301c ,
	0x01540bdb ,	0x015456ae ,	0x01540732 ,	0x01540120 ,
	0x0154759a ,	0x01542350 ,	0x015422ee ,	0x01544b40 ,
	0x01545878 ,	0x01546b36 ,	0x01545cfd ,	0x01543e12 ,
	0x01541a49 ,	0x01545f32 ,	0x01543bf6 ,	0x01543a9e ,
	0x0154797d ,	0x01545f49 ,	0x01540ddc ,	0x01544cad ,
	0x0154314f ,	0x01545e14 ,	0x01544df2 ,	0x01544944 ,
	0x01542e40 ,	0x01541366 ,	0x01541cd0 ,	0x0154366b ,
	0x015466c4 ,	0x01544230 ,	0x01547eb7 ,	0x01546032 ,
	0x01542c3b ,	0x015415a1 ,	0x01545422 ,	0x01543ef6 ,
	0x01540822 ,	0x01545991 ,	0x0154409d ,    0x01541101 ,

	0x01557f9b ,	0x015518e5 ,	0x01557485 ,	0x0155781c ,
	0x01554328 ,	0x015554fb ,	0x01552948 ,	0x01552702 ,
	0x01553623 ,	0x01554744 ,	0x01551209 ,	0x01554a32 ,
	0x01555f7d ,	0x015510b5 ,	0x01556a73 ,	0x015512f6 ,
	0x01553e6b ,	0x01553a85 ,	0x01554277 ,	0x01550ecf ,
	0x01553274 ,	0x01554ded ,	0x01556404 ,	0x01550029 ,
	0x01554823 ,	0x015518be ,	0x01556784 ,	0x01554ae1 ,
	0x01553d6c ,	0x01552cd6 ,	0x015572ae ,	0x01556952 ,
	0x01555f90 ,	0x01551649 ,	0x01556df1 ,	0x01555af1 ,
	0x015541bb ,	0x015526e9 ,	0x015501eb ,	0x01550bb3 ,
	0x01552ea6 ,	0x015512db ,	0x0155153c ,	0x01557e87 ,
	0x0155390c ,	0x01550f3e ,	0x01550099 ,	0x01550124 ,
	0x0155305e ,	0x0155440d ,	0x0155491c ,	0x01554d06 ,
	0x01554db7 ,	0x01551547 ,	0x015554de ,	0x015539b3 ,
	0x01552d12 ,	0x0155074d ,	0x01554dc8 ,	0x01556443 ,
	0x015566bb ,	0x0155428b ,	0x015526a6 ,	0x0155701f ,
	0x01555d03 ,	0x01557a5a ,	0x0155767d ,	0x01554509 ,
	0x01551238 ,	0x01553b25 ,	0x01551e1f ,	0x01556e5d ,
	0x01551ad4 ,	0x015563cb ,	0x01556bfc ,	0x01557f96 ,
	0x01557ff5 ,	0x01554e45 ,	0x0155323b ,	0x01552213 ,
	0x0155260d ,	0x01556b89 ,	0x0155030a ,	0x0155301c ,
	0x01550bdb ,	0x015556ae ,	0x01550732 ,	0x01550120 ,
	0x0155759a ,	0x01552350 ,	0x015522ee ,	0x01554b40 ,
	0x01555878 ,	0x01556b36 ,	0x01555cfd ,	0x01553e12 ,
	0x01551a49 ,	0x01555f32 ,	0x01553bf6 ,	0x01553a9e ,
	0x0155797d ,	0x01555f49 ,	0x01550ddc ,	0x01554cad ,
	0x0155314f ,	0x01555e14 ,	0x01554df2 ,	0x01554944 ,
	0x01552e40 ,	0x01551366 ,	0x01551cd0 ,	0x0155366b ,
	0x015566c4 ,	0x01554230 ,	0x01557eb7 ,	0x01556032 ,
	0x01552c3b ,	0x015515a1 ,	0x01555422 ,	0x01553ef6 ,
	0x01550822 ,	0x01555991 ,	0x0155409d ,    0x01551101 ,

	0x01567f9b ,	0x015618e5 ,	0x01567485 ,	0x0156781c ,
	0x01564328 ,	0x015654fb ,	0x01562948 ,	0x01562702 ,
	0x01563623 ,	0x01564744 ,	0x01561209 ,	0x01564a32 ,
	0x01565f7d ,	0x015610b5 ,	0x01566a73 ,	0x015612f6 ,
	0x01563e6b ,	0x01563a85 ,	0x01564277 ,	0x01560ecf ,
	0x01563274 ,	0x01564ded ,	0x01566404 ,	0x01560029 ,
	0x01564823 ,	0x015618be ,	0x01566784 ,	0x01564ae1 ,
	0x01563d6c ,	0x01562cd6 ,	0x015672ae ,	0x01566952 ,
	0x01565f90 ,	0x01561649 ,	0x01566df1 ,	0x01565af1 ,
	0x015641bb ,	0x015626e9 ,	0x015601eb ,	0x01560bb3 ,
	0x01562ea6 ,	0x015612db ,	0x0156153c ,	0x01567e87 ,
	0x0156390c ,	0x01560f3e ,	0x01560099 ,	0x01560124 ,
	0x0156305e ,	0x0156440d ,	0x0156491c ,	0x01564d06 ,
	0x01564db7 ,	0x01561547 ,	0x015654de ,	0x015639b3 ,
	0x01562d12 ,	0x0156074d ,	0x01564dc8 ,	0x01566443 ,
	0x015666bb ,	0x0156428b ,	0x015626a6 ,	0x0156701f ,
	0x01565d03 ,	0x01567a5a ,	0x0156767d ,	0x01564509 ,
	0x01561238 ,	0x01563b25 ,	0x01561e1f ,	0x01566e5d ,
	0x01561ad4 ,	0x015663cb ,	0x01566bfc ,	0x01567f96 ,
	0x01567ff5 ,	0x01564e45 ,	0x0156323b ,	0x01562213 ,
	0x0156260d ,	0x01566b89 ,	0x0156030a ,	0x0156301c ,
	0x01560bdb ,	0x015656ae ,	0x01560732 ,	0x01560120 ,
	0x0156759a ,	0x01562350 ,	0x015622ee ,	0x01564b40 ,
	0x01565878 ,	0x01566b36 ,	0x01565cfd ,	0x01563e12 ,
	0x01561a49 ,	0x01565f32 ,	0x01563bf6 ,	0x01563a9e ,
	0x0156797d ,	0x01565f49 ,	0x01560ddc ,	0x01564cad ,
	0x0156314f ,	0x01565e14 ,	0x01564df2 ,	0x01564944 ,
	0x01562e40 ,	0x01561366 ,	0x01561cd0 ,	0x0156366b ,
	0x015666c4 ,	0x01564230 ,	0x01567eb7 ,	0x01566032 ,
	0x01562c3b ,	0x015615a1 ,	0x01565422 ,	0x01563ef6 ,
	0x01560822 ,	0x01565991 ,	0x0156409d ,    0x01561101 ,

	0x01577f9b ,	0x015718e5 ,	0x01577485 ,	0x0157781c ,
	0x01574328 ,	0x015754fb ,	0x01572948 ,	0x01572702 ,
	0x01573623 ,	0x01574744 ,	0x01571209 ,	0x01574a32 ,
	0x01575f7d ,	0x015710b5 ,	0x01576a73 ,	0x015712f6 ,
	0x01573e6b ,	0x01573a85 ,	0x01574277 ,	0x01570ecf ,
	0x01573274 ,	0x01574ded ,	0x01576404 ,	0x01570029 ,
	0x01574823 ,	0x015718be ,	0x01576784 ,	0x01574ae1 ,
	0x01573d6c ,	0x01572cd6 ,	0x015772ae ,	0x01576952 ,
	0x01575f90 ,	0x01571649 ,	0x01576df1 ,	0x01575af1 ,
	0x015741bb ,	0x015726e9 ,	0x015701eb ,	0x01570bb3 ,
	0x01572ea6 ,	0x015712db ,	0x0157153c ,	0x01577e87 ,
	0x0157390c ,	0x01570f3e ,	0x01570099 ,	0x01570124 ,
	0x0157305e ,	0x0157440d ,	0x0157491c ,	0x01574d06 ,
	0x01574db7 ,	0x01571547 ,	0x015754de ,	0x015739b3 ,
	0x01572d12 ,	0x0157074d ,	0x01574dc8 ,	0x01576443 ,
	0x015766bb ,	0x0157428b ,	0x015726a6 ,	0x0157701f ,
	0x01575d03 ,	0x01577a5a ,	0x0157767d ,	0x01574509 ,
	0x01571238 ,	0x01573b25 ,	0x01571e1f ,	0x01576e5d ,
	0x01571ad4 ,	0x015763cb ,	0x01576bfc ,	0x01577f96 ,
	0x01577ff5 ,	0x01574e45 ,	0x0157323b ,	0x01572213 ,
	0x0157260d ,	0x01576b89 ,	0x0157030a ,	0x0157301c ,
	0x01570bdb ,	0x015756ae ,	0x01570732 ,	0x01570120 ,
	0x0157759a ,	0x01572350 ,	0x015722ee ,	0x01574b40 ,
	0x01575878 ,	0x01576b36 ,	0x01575cfd ,	0x01573e12 ,
	0x01571a49 ,	0x01575f32 ,	0x01573bf6 ,	0x01573a9e ,
	0x0157797d ,	0x01575f49 ,	0x01570ddc ,	0x01574cad ,
	0x0157314f ,	0x01575e14 ,	0x01574df2 ,	0x01574944 ,
	0x01572e40 ,	0x01571366 ,	0x01571cd0 ,	0x0157366b ,
	0x015766c4 ,	0x01574230 ,	0x01577eb7 ,	0x01576032 ,
	0x01572c3b ,	0x015715a1 ,	0x01575422 ,	0x01573ef6 ,
	0x01570822 ,	0x01575991 ,	0x0157409d ,    0x01571101 ,

	0x01587f9b ,	0x015818e5 ,	0x01587485 ,	0x0158781c ,
	0x01584328 ,	0x015854fb ,	0x01582948 ,	0x01582702 ,
	0x01583623 ,	0x01584744 ,	0x01581209 ,	0x01584a32 ,
	0x01585f7d ,	0x015810b5 ,	0x01586a73 ,	0x015812f6 ,
	0x01583e6b ,	0x01583a85 ,	0x01584277 ,	0x01580ecf ,
	0x01583274 ,	0x01584ded ,	0x01586404 ,	0x01580029 ,
	0x01584823 ,	0x015818be ,	0x01586784 ,	0x01584ae1 ,
	0x01583d6c ,	0x01582cd6 ,	0x015872ae ,	0x01586952 ,
	0x01585f90 ,	0x01581649 ,	0x01586df1 ,	0x01585af1 ,
	0x015841bb ,	0x015826e9 ,	0x015801eb ,	0x01580bb3 ,
	0x01582ea6 ,	0x015812db ,	0x0158153c ,	0x01587e87 ,
	0x0158390c ,	0x01580f3e ,	0x01580099 ,	0x01580124 ,
	0x0158305e ,	0x0158440d ,	0x0158491c ,	0x01584d06 ,
	0x01584db7 ,	0x01581547 ,	0x015854de ,	0x015839b3 ,
	0x01582d12 ,	0x0158074d ,	0x01584dc8 ,	0x01586443 ,
	0x015866bb ,	0x0158428b ,	0x015826a6 ,	0x0158701f ,
	0x01585d03 ,	0x01587a5a ,	0x0158767d ,	0x01584509 ,
	0x01581238 ,	0x01583b25 ,	0x01581e1f ,	0x01586e5d ,
	0x01581ad4 ,	0x015863cb ,	0x01586bfc ,	0x01587f96 ,
	0x01587ff5 ,	0x01584e45 ,	0x0158323b ,	0x01582213 ,
	0x0158260d ,	0x01586b89 ,	0x0158030a ,	0x0158301c ,
	0x01580bdb ,	0x015856ae ,	0x01580732 ,	0x01580120 ,
	0x0158759a ,	0x01582350 ,	0x015822ee ,	0x01584b40 ,
	0x01585878 ,	0x01586b36 ,	0x01585cfd ,	0x01583e12 ,
	0x01581a49 ,	0x01585f32 ,	0x01583bf6 ,	0x01583a9e ,
	0x0158797d ,	0x01585f49 ,	0x01580ddc ,	0x01584cad ,
	0x0158314f ,	0x01585e14 ,	0x01584df2 ,	0x01584944 ,
	0x01582e40 ,	0x01581366 ,	0x01581cd0 ,	0x0158366b ,
	0x015866c4 ,	0x01584230 ,	0x01587eb7 ,	0x01586032 ,
	0x01582c3b ,	0x015815a1 ,	0x01585422 ,	0x01583ef6 ,
	0x01580822 ,	0x01585991 ,	0x0158409d ,    0x01581101 ,

	0x01597f9b ,	0x015918e5 ,	0x01597485 ,	0x0159781c ,
	0x01594328 ,	0x015954fb ,	0x01592948 ,	0x01592702 ,
	0x01593623 ,	0x01594744 ,	0x01591209 ,	0x01594a32 ,
	0x01595f7d ,	0x015910b5 ,	0x01596a73 ,	0x015912f6 ,
	0x01593e6b ,	0x01593a85 ,	0x01594277 ,	0x01590ecf ,
	0x01593274 ,	0x01594ded ,	0x01596404 ,	0x01590029 ,
	0x01594823 ,	0x015918be ,	0x01596784 ,	0x01594ae1 ,
	0x01593d6c ,	0x01592cd6 ,	0x015972ae ,	0x01596952 ,
	0x01595f90 ,	0x01591649 ,	0x01596df1 ,	0x01595af1 ,
	0x015941bb ,	0x015926e9 ,	0x015901eb ,	0x01590bb3 ,
	0x01592ea6 ,	0x015912db ,	0x0159153c ,	0x01597e87 ,
	0x0159390c ,	0x01590f3e ,	0x01590099 ,	0x01590124 ,
	0x0159305e ,	0x0159440d ,	0x0159491c ,	0x01594d06 ,
	0x01594db7 ,	0x01591547 ,	0x015954de ,	0x015939b3 ,
	0x01592d12 ,	0x0159074d ,	0x01594dc8 ,	0x01596443 ,
	0x015966bb ,	0x0159428b ,	0x015926a6 ,	0x0159701f ,
	0x01595d03 ,	0x01597a5a ,	0x0159767d ,	0x01594509 ,
	0x01591238 ,	0x01593b25 ,	0x01591e1f ,	0x01596e5d ,
	0x01591ad4 ,	0x015963cb ,	0x01596bfc ,	0x01597f96 ,
	0x01597ff5 ,	0x01594e45 ,	0x0159323b ,	0x01592213 ,
	0x0159260d ,	0x01596b89 ,	0x0159030a ,	0x0159301c ,
	0x01590bdb ,	0x015956ae ,	0x01590732 ,	0x01590120 ,
	0x0159759a ,	0x01592350 ,	0x015922ee ,	0x01594b40 ,
	0x01595878 ,	0x01596b36 ,	0x01595cfd ,	0x01593e12 ,
	0x01591a49 ,	0x01595f32 ,	0x01593bf6 ,	0x01593a9e ,
	0x0159797d ,	0x01595f49 ,	0x01590ddc ,	0x01594cad ,
	0x0159314f ,	0x01595e14 ,	0x01594df2 ,	0x01594944 ,
	0x01592e40 ,	0x01591366 ,	0x01591cd0 ,	0x0159366b ,
	0x015966c4 ,	0x01594230 ,	0x01597eb7 ,	0x01596032 ,
	0x01592c3b ,	0x015915a1 ,	0x01595422 ,	0x01593ef6 ,
	0x01590822 ,	0x01595991 ,	0x0159409d ,    0x01591101 ,

	0x01607f9b ,	0x016018e5 ,	0x01607485 ,	0x0160781c ,
	0x01604328 ,	0x016054fb ,	0x01602948 ,	0x01602702 ,
	0x01603623 ,	0x01604744 ,	0x01601209 ,	0x01604a32 ,
	0x01605f7d ,	0x016010b5 ,	0x01606a73 ,	0x016012f6 ,
	0x01603e6b ,	0x01603a85 ,	0x01604277 ,	0x01600ecf ,
	0x01603274 ,	0x01604ded ,	0x01606404 ,	0x01600029 ,
	0x01604823 ,	0x016018be ,	0x01606784 ,	0x01604ae1 ,
	0x01603d6c ,	0x01602cd6 ,	0x016072ae ,	0x01606952 ,
	0x01605f90 ,	0x01601649 ,	0x01606df1 ,	0x01605af1 ,
	0x016041bb ,	0x016026e9 ,	0x016001eb ,	0x01600bb3 ,
	0x01602ea6 ,	0x016012db ,	0x0160153c ,	0x01607e87 ,
	0x0160390c ,	0x01600f3e ,	0x01600099 ,	0x01600124 ,
	0x0160305e ,	0x0160440d ,	0x0160491c ,	0x01604d06 ,
	0x01604db7 ,	0x01601547 ,	0x016054de ,	0x016039b3 ,
	0x01602d12 ,	0x0160074d ,	0x01604dc8 ,	0x01606443 ,
	0x016066bb ,	0x0160428b ,	0x016026a6 ,	0x0160701f ,
	0x01605d03 ,	0x01607a5a ,	0x0160767d ,	0x01604509 ,
	0x01601238 ,	0x01603b25 ,	0x01601e1f ,	0x01606e5d ,
	0x01601ad4 ,	0x016063cb ,	0x01606bfc ,	0x01607f96 ,
	0x01607ff5 ,	0x01604e45 ,	0x0160323b ,	0x01602213 ,
	0x0160260d ,	0x01606b89 ,	0x0160030a ,	0x0160301c ,
	0x01600bdb ,	0x016056ae ,	0x01600732 ,	0x01600120 ,
	0x0160759a ,	0x01602350 ,	0x016022ee ,	0x01604b40 ,
	0x01605878 ,	0x01606b36 ,	0x01605cfd ,	0x01603e12 ,
	0x01601a49 ,	0x01605f32 ,	0x01603bf6 ,	0x01603a9e ,
	0x0160797d ,	0x01605f49 ,	0x01600ddc ,	0x01604cad ,
	0x0160314f ,	0x01605e14 ,	0x01604df2 ,	0x01604944 ,
	0x01602e40 ,	0x01601366 ,	0x01601cd0 ,	0x0160366b ,
	0x016066c4 ,	0x01604230 ,	0x01607eb7 ,	0x01606032 ,
	0x01602c3b ,	0x016015a1 ,	0x01605422 ,	0x01603ef6 ,
	0x01600822 ,	0x01605991 ,	0x0160409d ,    0x01601101 ,

	0x01617f9b ,	0x016118e5 ,	0x01617485 ,	0x0161781c ,
	0x01614328 ,	0x016154fb ,	0x01612948 ,	0x01612702 ,
	0x01613623 ,	0x01614744 ,	0x01611209 ,	0x01614a32 ,
	0x01615f7d ,	0x016110b5 ,	0x01616a73 ,	0x016112f6 ,
	0x01613e6b ,	0x01613a85 ,	0x01614277 ,	0x01610ecf ,
	0x01613274 ,	0x01614ded ,	0x01616404 ,	0x01610029 ,
	0x01614823 ,	0x016118be ,	0x01616784 ,	0x01614ae1 ,
	0x01613d6c ,	0x01612cd6 ,	0x016172ae ,	0x01616952 ,
	0x01615f90 ,	0x01611649 ,	0x01616df1 ,	0x01615af1 ,
	0x016141bb ,	0x016126e9 ,	0x016101eb ,	0x01610bb3 ,
	0x01612ea6 ,	0x016112db ,	0x0161153c ,	0x01617e87 ,
	0x0161390c ,	0x01610f3e ,	0x01610099 ,	0x01610124 ,
	0x0161305e ,	0x0161440d ,	0x0161491c ,	0x01614d06 ,
	0x01614db7 ,	0x01611547 ,	0x016154de ,	0x016139b3 ,
	0x01612d12 ,	0x0161074d ,	0x01614dc8 ,	0x01616443 ,
	0x016166bb ,	0x0161428b ,	0x016126a6 ,	0x0161701f ,
	0x01615d03 ,	0x01617a5a ,	0x0161767d ,	0x01614509 ,
	0x01611238 ,	0x01613b25 ,	0x01611e1f ,	0x01616e5d ,
	0x01611ad4 ,	0x016163cb ,	0x01616bfc ,	0x01617f96 ,
	0x01617ff5 ,	0x01614e45 ,	0x0161323b ,	0x01612213 ,
	0x0161260d ,	0x01616b89 ,	0x0161030a ,	0x0161301c ,
	0x01610bdb ,	0x016156ae ,	0x01610732 ,	0x01610120 ,
	0x0161759a ,	0x01612350 ,	0x016122ee ,	0x01614b40 ,
	0x01615878 ,	0x01616b36 ,	0x01615cfd ,	0x01613e12 ,
	0x01611a49 ,	0x01615f32 ,	0x01613bf6 ,	0x01613a9e ,
	0x0161797d ,	0x01615f49 ,	0x01610ddc ,	0x01614cad ,
	0x0161314f ,	0x01615e14 ,	0x01614df2 ,	0x01614944 ,
	0x01612e40 ,	0x01611366 ,	0x01611cd0 ,	0x0161366b ,
	0x016166c4 ,	0x01614230 ,	0x01617eb7 ,	0x01616032 ,
	0x01612c3b ,	0x016115a1 ,	0x01615422 ,	0x01613ef6 ,
	0x01610822 ,	0x01615991 ,	0x0161409d ,    0x01611101 ,

	0x01627f9b ,	0x016218e5 ,	0x01627485 ,	0x0162781c ,
	0x01624328 ,	0x016254fb ,	0x01622948 ,	0x01622702 ,
	0x01623623 ,	0x01624744 ,	0x01621209 ,	0x01624a32 ,
	0x01625f7d ,	0x016210b5 ,	0x01626a73 ,	0x016212f6 ,
	0x01623e6b ,	0x01623a85 ,	0x01624277 ,	0x01620ecf ,
	0x01623274 ,	0x01624ded ,	0x01626404 ,	0x01620029 ,
	0x01624823 ,	0x016218be ,	0x01626784 ,	0x01624ae1 ,
	0x01623d6c ,	0x01622cd6 ,	0x016272ae ,	0x01626952 ,
	0x01625f90 ,	0x01621649 ,	0x01626df1 ,	0x01625af1 ,
	0x016241bb ,	0x016226e9 ,	0x016201eb ,	0x01620bb3 ,
	0x01622ea6 ,	0x016212db ,	0x0162153c ,	0x01627e87 ,
	0x0162390c ,	0x01620f3e ,	0x01620099 ,	0x01620124 ,
	0x0162305e ,	0x0162440d ,	0x0162491c ,	0x01624d06 ,
	0x01624db7 ,	0x01621547 ,	0x016254de ,	0x016239b3 ,
	0x01622d12 ,	0x0162074d ,	0x01624dc8 ,	0x01626443 ,
	0x016266bb ,	0x0162428b ,	0x016226a6 ,	0x0162701f ,
	0x01625d03 ,	0x01627a5a ,	0x0162767d ,	0x01624509 ,
	0x01621238 ,	0x01623b25 ,	0x01621e1f ,	0x01626e5d ,
	0x01621ad4 ,	0x016263cb ,	0x01626bfc ,	0x01627f96 ,
	0x01627ff5 ,	0x01624e45 ,	0x0162323b ,	0x01622213 ,
	0x0162260d ,	0x01626b89 ,	0x0162030a ,	0x0162301c ,
	0x01620bdb ,	0x016256ae ,	0x01620732 ,	0x01620120 ,
	0x0162759a ,	0x01622350 ,	0x016222ee ,	0x01624b40 ,
	0x01625878 ,	0x01626b36 ,	0x01625cfd ,	0x01623e12 ,
	0x01621a49 ,	0x01625f32 ,	0x01623bf6 ,	0x01623a9e ,
	0x0162797d ,	0x01625f49 ,	0x01620ddc ,	0x01624cad ,
	0x0162314f ,	0x01625e14 ,	0x01624df2 ,	0x01624944 ,
	0x01622e40 ,	0x01621366 ,	0x01621cd0 ,	0x0162366b ,
	0x016266c4 ,	0x01624230 ,	0x01627eb7 ,	0x01626032 ,
	0x01622c3b ,	0x016215a1 ,	0x01625422 ,	0x01623ef6 ,
	0x01620822 ,	0x01625991 ,	0x0162409d ,    0x01621101 ,

	0x01637f9b ,	0x016318e5 ,	0x01637485 ,	0x0163781c ,
	0x01634328 ,	0x016354fb ,	0x01632948 ,	0x01632702 ,
	0x01633623 ,	0x01634744 ,	0x01631209 ,	0x01634a32 ,
	0x01635f7d ,	0x016310b5 ,	0x01636a73 ,	0x016312f6 ,
	0x01633e6b ,	0x01633a85 ,	0x01634277 ,	0x01630ecf ,
	0x01633274 ,	0x01634ded ,	0x01636404 ,	0x01630029 ,
	0x01634823 ,	0x016318be ,	0x01636784 ,	0x01634ae1 ,
	0x01633d6c ,	0x01632cd6 ,	0x016372ae ,	0x01636952 ,
	0x01635f90 ,	0x01631649 ,	0x01636df1 ,	0x01635af1 ,
	0x016341bb ,	0x016326e9 ,	0x016301eb ,	0x01630bb3 ,
	0x01632ea6 ,	0x016312db ,	0x0163153c ,	0x01637e87 ,
	0x0163390c ,	0x01630f3e ,	0x01630099 ,	0x01630124 ,
	0x0163305e ,	0x0163440d ,	0x0163491c ,	0x01634d06 ,
	0x01634db7 ,	0x01631547 ,	0x016354de ,	0x016339b3 ,
	0x01632d12 ,	0x0163074d ,	0x01634dc8 ,	0x01636443 ,
	0x016366bb ,	0x0163428b ,	0x016326a6 ,	0x0163701f ,
	0x01635d03 ,	0x01637a5a ,	0x0163767d ,	0x01634509 ,
	0x01631238 ,	0x01633b25 ,	0x01631e1f ,	0x01636e5d ,
	0x01631ad4 ,	0x016363cb ,	0x01636bfc ,	0x01637f96 ,
	0x01637ff5 ,	0x01634e45 ,	0x0163323b ,	0x01632213 ,
	0x0163260d ,	0x01636b89 ,	0x0163030a ,	0x0163301c ,
	0x01630bdb ,	0x016356ae ,	0x01630732 ,	0x01630120 ,
	0x0163759a ,	0x01632350 ,	0x016322ee ,	0x01634b40 ,
	0x01635878 ,	0x01636b36 ,	0x01635cfd ,	0x01633e12 ,
	0x01631a49 ,	0x01635f32 ,	0x01633bf6 ,	0x01633a9e ,
	0x0163797d ,	0x01635f49 ,	0x01630ddc ,	0x01634cad ,
	0x0163314f ,	0x01635e14 ,	0x01634df2 ,	0x01634944 ,
	0x01632e40 ,	0x01631366 ,	0x01631cd0 ,	0x0163366b ,
	0x016366c4 ,	0x01634230 ,	0x01637eb7 ,	0x01636032 ,
	0x01632c3b ,	0x016315a1 ,	0x01635422 ,	0x01633ef6 ,
	0x01630822 ,	0x01635991 ,	0x0163409d ,    0x01631101 ,

	0x01647f9b ,	0x016418e5 ,	0x01647485 ,	0x0164781c ,
	0x01644328 ,	0x016454fb ,	0x01642948 ,	0x01642702 ,
	0x01643623 ,	0x01644744 ,	0x01641209 ,	0x01644a32 ,
	0x01645f7d ,	0x016410b5 ,	0x01646a73 ,	0x016412f6 ,
	0x01643e6b ,	0x01643a85 ,	0x01644277 ,	0x01640ecf ,
	0x01643274 ,	0x01644ded ,	0x01646404 ,	0x01640029 ,
	0x01644823 ,	0x016418be ,	0x01646784 ,	0x01644ae1 ,
	0x01643d6c ,	0x01642cd6 ,	0x016472ae ,	0x01646952 ,
	0x01645f90 ,	0x01641649 ,	0x01646df1 ,	0x01645af1 ,
	0x016441bb ,	0x016426e9 ,	0x016401eb ,	0x01640bb3 ,
	0x01642ea6 ,	0x016412db ,	0x0164153c ,	0x01647e87 ,
	0x0164390c ,	0x01640f3e ,	0x01640099 ,	0x01640124 ,
	0x0164305e ,	0x0164440d ,	0x0164491c ,	0x01644d06 ,
	0x01644db7 ,	0x01641547 ,	0x016454de ,	0x016439b3 ,
	0x01642d12 ,	0x0164074d ,	0x01644dc8 ,	0x01646443 ,
	0x016466bb ,	0x0164428b ,	0x016426a6 ,	0x0164701f ,
	0x01645d03 ,	0x01647a5a ,	0x0164767d ,	0x01644509 ,
	0x01641238 ,	0x01643b25 ,	0x01641e1f ,	0x01646e5d ,
	0x01641ad4 ,	0x016463cb ,	0x01646bfc ,	0x01647f96 ,
	0x01647ff5 ,	0x01644e45 ,	0x0164323b ,	0x01642213 ,
	0x0164260d ,	0x01646b89 ,	0x0164030a ,	0x0164301c ,
	0x01640bdb ,	0x016456ae ,	0x01640732 ,	0x01640120 ,
	0x0164759a ,	0x01642350 ,	0x016422ee ,	0x01644b40 ,
	0x01645878 ,	0x01646b36 ,	0x01645cfd ,	0x01643e12 ,
	0x01641a49 ,	0x01645f32 ,	0x01643bf6 ,	0x01643a9e ,
	0x0164797d ,	0x01645f49 ,	0x01640ddc ,	0x01644cad ,
	0x0164314f ,	0x01645e14 ,	0x01644df2 ,	0x01644944 ,
	0x01642e40 ,	0x01641366 ,	0x01641cd0 ,	0x0164366b ,
	0x016466c4 ,	0x01644230 ,	0x01647eb7 ,	0x01646032 ,
	0x01642c3b ,	0x016415a1 ,	0x01645422 ,	0x01643ef6 ,
	0x01640822 ,	0x01645991 ,	0x0164409d ,    0x01641101 ,

	0x01657f9b ,	0x016518e5 ,	0x01657485 ,	0x0165781c ,
	0x01654328 ,	0x016554fb ,	0x01652948 ,	0x01652702 ,
	0x01653623 ,	0x01654744 ,	0x01651209 ,	0x01654a32 ,
	0x01655f7d ,	0x016510b5 ,	0x01656a73 ,	0x016512f6 ,
	0x01653e6b ,	0x01653a85 ,	0x01654277 ,	0x01650ecf ,
	0x01653274 ,	0x01654ded ,	0x01656404 ,	0x01650029 ,
	0x01654823 ,	0x016518be ,	0x01656784 ,	0x01654ae1 ,
	0x01653d6c ,	0x01652cd6 ,	0x016572ae ,	0x01656952 ,
	0x01655f90 ,	0x01651649 ,	0x01656df1 ,	0x01655af1 ,
	0x016541bb ,	0x016526e9 ,	0x016501eb ,	0x01650bb3 ,
	0x01652ea6 ,	0x016512db ,	0x0165153c ,	0x01657e87 ,
	0x0165390c ,	0x01650f3e ,	0x01650099 ,	0x01650124 ,
	0x0165305e ,	0x0165440d ,	0x0165491c ,	0x01654d06 ,
	0x01654db7 ,	0x01651547 ,	0x016554de ,	0x016539b3 ,
	0x01652d12 ,	0x0165074d ,	0x01654dc8 ,	0x01656443 ,
	0x016566bb ,	0x0165428b ,	0x016526a6 ,	0x0165701f ,
	0x01655d03 ,	0x01657a5a ,	0x0165767d ,	0x01654509 ,
	0x01651238 ,	0x01653b25 ,	0x01651e1f ,	0x01656e5d ,
	0x01651ad4 ,	0x016563cb ,	0x01656bfc ,	0x01657f96 ,
	0x01657ff5 ,	0x01654e45 ,	0x0165323b ,	0x01652213 ,
	0x0165260d ,	0x01656b89 ,	0x0165030a ,	0x0165301c ,
	0x01650bdb ,	0x016556ae ,	0x01650732 ,	0x01650120 ,
	0x0165759a ,	0x01652350 ,	0x016522ee ,	0x01654b40 ,
	0x01655878 ,	0x01656b36 ,	0x01655cfd ,	0x01653e12 ,
	0x01651a49 ,	0x01655f32 ,	0x01653bf6 ,	0x01653a9e ,
	0x0165797d ,	0x01655f49 ,	0x01650ddc ,	0x01654cad ,
	0x0165314f ,	0x01655e14 ,	0x01654df2 ,	0x01654944 ,
	0x01652e40 ,	0x01651366 ,	0x01651cd0 ,	0x0165366b ,
	0x016566c4 ,	0x01654230 ,	0x01657eb7 ,	0x01656032 ,
	0x01652c3b ,	0x016515a1 ,	0x01655422 ,	0x01653ef6 ,
	0x01650822 ,	0x01655991 ,	0x0165409d ,    0x01651101 ,

	0x01667f9b ,	0x016618e5 ,	0x01667485 ,	0x0166781c ,
	0x01664328 ,	0x016654fb ,	0x01662948 ,	0x01662702 ,
	0x01663623 ,	0x01664744 ,	0x01661209 ,	0x01664a32 ,
	0x01665f7d ,	0x016610b5 ,	0x01666a73 ,	0x016612f6 ,
	0x01663e6b ,	0x01663a85 ,	0x01664277 ,	0x01660ecf ,
	0x01663274 ,	0x01664ded ,	0x01666404 ,	0x01660029 ,
	0x01664823 ,	0x016618be ,	0x01666784 ,	0x01664ae1 ,
	0x01663d6c ,	0x01662cd6 ,	0x016672ae ,	0x01666952 ,
	0x01665f90 ,	0x01661649 ,	0x01666df1 ,	0x01665af1 ,
	0x016641bb ,	0x016626e9 ,	0x016601eb ,	0x01660bb3 ,
	0x01662ea6 ,	0x016612db ,	0x0166153c ,	0x01667e87 ,
	0x0166390c ,	0x01660f3e ,	0x01660099 ,	0x01660124 ,
	0x0166305e ,	0x0166440d ,	0x0166491c ,	0x01664d06 ,
	0x01664db7 ,	0x01661547 ,	0x016654de ,	0x016639b3 ,
	0x01662d12 ,	0x0166074d ,	0x01664dc8 ,	0x01666443 ,
	0x016666bb ,	0x0166428b ,	0x016626a6 ,	0x0166701f ,
	0x01665d03 ,	0x01667a5a ,	0x0166767d ,	0x01664509 ,
	0x01661238 ,	0x01663b25 ,	0x01661e1f ,	0x01666e5d ,
	0x01661ad4 ,	0x016663cb ,	0x01666bfc ,	0x01667f96 ,
	0x01667ff5 ,	0x01664e45 ,	0x0166323b ,	0x01662213 ,
	0x0166260d ,	0x01666b89 ,	0x0166030a ,	0x0166301c ,
	0x01660bdb ,	0x016656ae ,	0x01660732 ,	0x01660120 ,
	0x0166759a ,	0x01662350 ,	0x016622ee ,	0x01664b40 ,
	0x01665878 ,	0x01666b36 ,	0x01665cfd ,	0x01663e12 ,
	0x01661a49 ,	0x01665f32 ,	0x01663bf6 ,	0x01663a9e ,
	0x0166797d ,	0x01665f49 ,	0x01660ddc ,	0x01664cad ,
	0x0166314f ,	0x01665e14 ,	0x01664df2 ,	0x01664944 ,
	0x01662e40 ,	0x01661366 ,	0x01661cd0 ,	0x0166366b ,
	0x016666c4 ,	0x01664230 ,	0x01667eb7 ,	0x01666032 ,
	0x01662c3b ,	0x016615a1 ,	0x01665422 ,	0x01663ef6 ,
	0x01660822 ,	0x01665991 ,	0x0166409d ,    0x01661101 ,

	0x01677f9b ,	0x016718e5 ,	0x01677485 ,	0x0167781c ,
	0x01674328 ,	0x016754fb ,	0x01672948 ,	0x01672702 ,
	0x01673623 ,	0x01674744 ,	0x01671209 ,	0x01674a32 ,
	0x01675f7d ,	0x016710b5 ,	0x01676a73 ,	0x016712f6 ,
	0x01673e6b ,	0x01673a85 ,	0x01674277 ,	0x01670ecf ,
	0x01673274 ,	0x01674ded ,	0x01676404 ,	0x01670029 ,
	0x01674823 ,	0x016718be ,	0x01676784 ,	0x01674ae1 ,
	0x01673d6c ,	0x01672cd6 ,	0x016772ae ,	0x01676952 ,
	0x01675f90 ,	0x01671649 ,	0x01676df1 ,	0x01675af1 ,
	0x016741bb ,	0x016726e9 ,	0x016701eb ,	0x01670bb3 ,
	0x01672ea6 ,	0x016712db ,	0x0167153c ,	0x01677e87 ,
	0x0167390c ,	0x01670f3e ,	0x01670099 ,	0x01670124 ,
	0x0167305e ,	0x0167440d ,	0x0167491c ,	0x01674d06 ,
	0x01674db7 ,	0x01671547 ,	0x016754de ,	0x016739b3 ,
	0x01672d12 ,	0x0167074d ,	0x01674dc8 ,	0x01676443 ,
	0x016766bb ,	0x0167428b ,	0x016726a6 ,	0x0167701f ,
	0x01675d03 ,	0x01677a5a ,	0x0167767d ,	0x01674509 ,
	0x01671238 ,	0x01673b25 ,	0x01671e1f ,	0x01676e5d ,
	0x01671ad4 ,	0x016763cb ,	0x01676bfc ,	0x01677f96 ,
	0x01677ff5 ,	0x01674e45 ,	0x0167323b ,	0x01672213 ,
	0x0167260d ,	0x01676b89 ,	0x0167030a ,	0x0167301c ,
	0x01670bdb ,	0x016756ae ,	0x01670732 ,	0x01670120 ,
	0x0167759a ,	0x01672350 ,	0x016722ee ,	0x01674b40 ,
	0x01675878 ,	0x01676b36 ,	0x01675cfd ,	0x01673e12 ,
	0x01671a49 ,	0x01675f32 ,	0x01673bf6 ,	0x01673a9e ,
	0x0167797d ,	0x01675f49 ,	0x01670ddc ,	0x01674cad ,
	0x0167314f ,	0x01675e14 ,	0x01674df2 ,	0x01674944 ,
	0x01672e40 ,	0x01671366 ,	0x01671cd0 ,	0x0167366b ,
	0x016766c4 ,	0x01674230 ,	0x01677eb7 ,	0x01676032 ,
	0x01672c3b ,	0x016715a1 ,	0x01675422 ,	0x01673ef6 ,
	0x01670822 ,	0x01675991 ,	0x0167409d ,    0x01671101 ,

	0x01687f9b ,	0x016818e5 ,	0x01687485 ,	0x0168781c ,
	0x01684328 ,	0x016854fb ,	0x01682948 ,	0x01682702 ,
	0x01683623 ,	0x01684744 ,	0x01681209 ,	0x01684a32 ,
	0x01685f7d ,	0x016810b5 ,	0x01686a73 ,	0x016812f6 ,
	0x01683e6b ,	0x01683a85 ,	0x01684277 ,	0x01680ecf ,
	0x01683274 ,	0x01684ded ,	0x01686404 ,	0x01680029 ,
	0x01684823 ,	0x016818be ,	0x01686784 ,	0x01684ae1 ,
	0x01683d6c ,	0x01682cd6 ,	0x016872ae ,	0x01686952 ,
	0x01685f90 ,	0x01681649 ,	0x01686df1 ,	0x01685af1 ,
	0x016841bb ,	0x016826e9 ,	0x016801eb ,	0x01680bb3 ,
	0x01682ea6 ,	0x016812db ,	0x0168153c ,	0x01687e87 ,
	0x0168390c ,	0x01680f3e ,	0x01680099 ,	0x01680124 ,
	0x0168305e ,	0x0168440d ,	0x0168491c ,	0x01684d06 ,
	0x01684db7 ,	0x01681547 ,	0x016854de ,	0x016839b3 ,
	0x01682d12 ,	0x0168074d ,	0x01684dc8 ,	0x01686443 ,
	0x016866bb ,	0x0168428b ,	0x016826a6 ,	0x0168701f ,
	0x01685d03 ,	0x01687a5a ,	0x0168767d ,	0x01684509 ,
	0x01681238 ,	0x01683b25 ,	0x01681e1f ,	0x01686e5d ,
	0x01681ad4 ,	0x016863cb ,	0x01686bfc ,	0x01687f96 ,
	0x01687ff5 ,	0x01684e45 ,	0x0168323b ,	0x01682213 ,
	0x0168260d ,	0x01686b89 ,	0x0168030a ,	0x0168301c ,
	0x01680bdb ,	0x016856ae ,	0x01680732 ,	0x01680120 ,
	0x0168759a ,	0x01682350 ,	0x016822ee ,	0x01684b40 ,
	0x01685878 ,	0x01686b36 ,	0x01685cfd ,	0x01683e12 ,
	0x01681a49 ,	0x01685f32 ,	0x01683bf6 ,	0x01683a9e ,
	0x0168797d ,	0x01685f49 ,	0x01680ddc ,	0x01684cad ,
	0x0168314f ,	0x01685e14 ,	0x01684df2 ,	0x01684944 ,
	0x01682e40 ,	0x01681366 ,	0x01681cd0 ,	0x0168366b ,
	0x016866c4 ,	0x01684230 ,	0x01687eb7 ,	0x01686032 ,
	0x01682c3b ,	0x016815a1 ,	0x01685422 ,	0x01683ef6 ,
	0x01680822 ,	0x01685991 ,	0x0168409d ,    0x01681101 ,

	0x01697f9b ,	0x016918e5 ,	0x01697485 ,	0x0169781c ,
	0x01694328 ,	0x016954fb ,	0x01692948 ,	0x01692702 ,
	0x01693623 ,	0x01694744 ,	0x01691209 ,	0x01694a32 ,
	0x01695f7d ,	0x016910b5 ,	0x01696a73 ,	0x016912f6 ,
	0x01693e6b ,	0x01693a85 ,	0x01694277 ,	0x01690ecf ,
	0x01693274 ,	0x01694ded ,	0x01696404 ,	0x01690029 ,
	0x01694823 ,	0x016918be ,	0x01696784 ,	0x01694ae1 ,
	0x01693d6c ,	0x01692cd6 ,	0x016972ae ,	0x01696952 ,
	0x01695f90 ,	0x01691649 ,	0x01696df1 ,	0x01695af1 ,
	0x016941bb ,	0x016926e9 ,	0x016901eb ,	0x01690bb3 ,
	0x01692ea6 ,	0x016912db ,	0x0169153c ,	0x01697e87 ,
	0x0169390c ,	0x01690f3e ,	0x01690099 ,	0x01690124 ,
	0x0169305e ,	0x0169440d ,	0x0169491c ,	0x01694d06 ,
	0x01694db7 ,	0x01691547 ,	0x016954de ,	0x016939b3 ,
	0x01692d12 ,	0x0169074d ,	0x01694dc8 ,	0x01696443 ,
	0x016966bb ,	0x0169428b ,	0x016926a6 ,	0x0169701f ,
	0x01695d03 ,	0x01697a5a ,	0x0169767d ,	0x01694509 ,
	0x01691238 ,	0x01693b25 ,	0x01691e1f ,	0x01696e5d ,
	0x01691ad4 ,	0x016963cb ,	0x01696bfc ,	0x01697f96 ,
	0x01697ff5 ,	0x01694e45 ,	0x0169323b ,	0x01692213 ,
	0x0169260d ,	0x01696b89 ,	0x0169030a ,	0x0169301c ,
	0x01690bdb ,	0x016956ae ,	0x01690732 ,	0x01690120 ,
	0x0169759a ,	0x01692350 ,	0x016922ee ,	0x01694b40 ,
	0x01695878 ,	0x01696b36 ,	0x01695cfd ,	0x01693e12 ,
	0x01691a49 ,	0x01695f32 ,	0x01693bf6 ,	0x01693a9e ,
	0x0169797d ,	0x01695f49 ,	0x01690ddc ,	0x01694cad ,
	0x0169314f ,	0x01695e14 ,	0x01694df2 ,	0x01694944 ,
	0x01692e40 ,	0x01691366 ,	0x01691cd0 ,	0x0169366b ,
	0x016966c4 ,	0x01694230 ,	0x01697eb7 ,	0x01696032 ,
	0x01692c3b ,	0x016915a1 ,	0x01695422 ,	0x01693ef6 ,
	0x01690822 ,	0x01695991 ,	0x0169409d ,    0x01691101 ,

	0x01707f9b ,	0x017018e5 ,	0x01707485 ,	0x0170781c ,
	0x01704328 ,	0x017054fb ,	0x01702948 ,	0x01702702 ,
	0x01703623 ,	0x01704744 ,	0x01701209 ,	0x01704a32 ,
	0x01705f7d ,	0x017010b5 ,	0x01706a73 ,	0x017012f6 ,
	0x01703e6b ,	0x01703a85 ,	0x01704277 ,	0x01700ecf ,
	0x01703274 ,	0x01704ded ,	0x01706404 ,	0x01700029 ,
	0x01704823 ,	0x017018be ,	0x01706784 ,	0x01704ae1 ,
	0x01703d6c ,	0x01702cd6 ,	0x017072ae ,	0x01706952 ,
	0x01705f90 ,	0x01701649 ,	0x01706df1 ,	0x01705af1 ,
	0x017041bb ,	0x017026e9 ,	0x017001eb ,	0x01700bb3 ,
	0x01702ea6 ,	0x017012db ,	0x0170153c ,	0x01707e87 ,
	0x0170390c ,	0x01700f3e ,	0x01700099 ,	0x01700124 ,
	0x0170305e ,	0x0170440d ,	0x0170491c ,	0x01704d06 ,
	0x01704db7 ,	0x01701547 ,	0x017054de ,	0x017039b3 ,
	0x01702d12 ,	0x0170074d ,	0x01704dc8 ,	0x01706443 ,
	0x017066bb ,	0x0170428b ,	0x017026a6 ,	0x0170701f ,
	0x01705d03 ,	0x01707a5a ,	0x0170767d ,	0x01704509 ,
	0x01701238 ,	0x01703b25 ,	0x01701e1f ,	0x01706e5d ,
	0x01701ad4 ,	0x017063cb ,	0x01706bfc ,	0x01707f96 ,
	0x01707ff5 ,	0x01704e45 ,	0x0170323b ,	0x01702213 ,
	0x0170260d ,	0x01706b89 ,	0x0170030a ,	0x0170301c ,
	0x01700bdb ,	0x017056ae ,	0x01700732 ,	0x01700120 ,
	0x0170759a ,	0x01702350 ,	0x017022ee ,	0x01704b40 ,
	0x01705878 ,	0x01706b36 ,	0x01705cfd ,	0x01703e12 ,
	0x01701a49 ,	0x01705f32 ,	0x01703bf6 ,	0x01703a9e ,
	0x0170797d ,	0x01705f49 ,	0x01700ddc ,	0x01704cad ,
	0x0170314f ,	0x01705e14 ,	0x01704df2 ,	0x01704944 ,
	0x01702e40 ,	0x01701366 ,	0x01701cd0 ,	0x0170366b ,
	0x017066c4 ,	0x01704230 ,	0x01707eb7 ,	0x01706032 ,
	0x01702c3b ,	0x017015a1 ,	0x01705422 ,	0x01703ef6 ,
	0x01700822 ,	0x01705991 ,	0x0170409d ,    0x01701101 ,

	0x01717f9b ,	0x017118e5 ,	0x01717485 ,	0x0171781c ,
	0x01714328 ,	0x017154fb ,	0x01712948 ,	0x01712702 ,
	0x01713623 ,	0x01714744 ,	0x01711209 ,	0x01714a32 ,
	0x01715f7d ,	0x017110b5 ,	0x01716a73 ,	0x017112f6 ,
	0x01713e6b ,	0x01713a85 ,	0x01714277 ,	0x01710ecf ,
	0x01713274 ,	0x01714ded ,	0x01716404 ,	0x01710029 ,
	0x01714823 ,	0x017118be ,	0x01716784 ,	0x01714ae1 ,
	0x01713d6c ,	0x01712cd6 ,	0x017172ae ,	0x01716952 ,
	0x01715f90 ,	0x01711649 ,	0x01716df1 ,	0x01715af1 ,
	0x017141bb ,	0x017126e9 ,	0x017101eb ,	0x01710bb3 ,
	0x01712ea6 ,	0x017112db ,	0x0171153c ,	0x01717e87 ,
	0x0171390c ,	0x01710f3e ,	0x01710099 ,	0x01710124 ,
	0x0171305e ,	0x0171440d ,	0x0171491c ,	0x01714d06 ,
	0x01714db7 ,	0x01711547 ,	0x017154de ,	0x017139b3 ,
	0x01712d12 ,	0x0171074d ,	0x01714dc8 ,	0x01716443 ,
	0x017166bb ,	0x0171428b ,	0x017126a6 ,	0x0171701f ,
	0x01715d03 ,	0x01717a5a ,	0x0171767d ,	0x01714509 ,
	0x01711238 ,	0x01713b25 ,	0x01711e1f ,	0x01716e5d ,
	0x01711ad4 ,	0x017163cb ,	0x01716bfc ,	0x01717f96 ,
	0x01717ff5 ,	0x01714e45 ,	0x0171323b ,	0x01712213 ,
	0x0171260d ,	0x01716b89 ,	0x0171030a ,	0x0171301c ,
	0x01710bdb ,	0x017156ae ,	0x01710732 ,	0x01710120 ,
	0x0171759a ,	0x01712350 ,	0x017122ee ,	0x01714b40 ,
	0x01715878 ,	0x01716b36 ,	0x01715cfd ,	0x01713e12 ,
	0x01711a49 ,	0x01715f32 ,	0x01713bf6 ,	0x01713a9e ,
	0x0171797d ,	0x01715f49 ,	0x01710ddc ,	0x01714cad ,
	0x0171314f ,	0x01715e14 ,	0x01714df2 ,	0x01714944 ,
	0x01712e40 ,	0x01711366 ,	0x01711cd0 ,	0x0171366b ,
	0x017166c4 ,	0x01714230 ,	0x01717eb7 ,	0x01716032 ,
	0x01712c3b ,	0x017115a1 ,	0x01715422 ,	0x01713ef6 ,
	0x01710822 ,	0x01715991 ,	0x0171409d ,    0x01711101 ,

	0x01727f9b ,	0x017218e5 ,	0x01727485 ,	0x0172781c ,
	0x01724328 ,	0x017254fb ,	0x01722948 ,	0x01722702 ,
	0x01723623 ,	0x01724744 ,	0x01721209 ,	0x01724a32 ,
	0x01725f7d ,	0x017210b5 ,	0x01726a73 ,	0x017212f6 ,
	0x01723e6b ,	0x01723a85 ,	0x01724277 ,	0x01720ecf ,
	0x01723274 ,	0x01724ded ,	0x01726404 ,	0x01720029 ,
	0x01724823 ,	0x017218be ,	0x01726784 ,	0x01724ae1 ,
	0x01723d6c ,	0x01722cd6 ,	0x017272ae ,	0x01726952 ,
	0x01725f90 ,	0x01721649 ,	0x01726df1 ,	0x01725af1 ,
	0x017241bb ,	0x017226e9 ,	0x017201eb ,	0x01720bb3 ,
	0x01722ea6 ,	0x017212db ,	0x0172153c ,	0x01727e87 ,
	0x0172390c ,	0x01720f3e ,	0x01720099 ,	0x01720124 ,
	0x0172305e ,	0x0172440d ,	0x0172491c ,	0x01724d06 ,
	0x01724db7 ,	0x01721547 ,	0x017254de ,	0x017239b3 ,
	0x01722d12 ,	0x0172074d ,	0x01724dc8 ,	0x01726443 ,
	0x017266bb ,	0x0172428b ,	0x017226a6 ,	0x0172701f ,
	0x01725d03 ,	0x01727a5a ,	0x0172767d ,	0x01724509 ,
	0x01721238 ,	0x01723b25 ,	0x01721e1f ,	0x01726e5d ,
	0x01721ad4 ,	0x017263cb ,	0x01726bfc ,	0x01727f96 ,
	0x01727ff5 ,	0x01724e45 ,	0x0172323b ,	0x01722213 ,
	0x0172260d ,	0x01726b89 ,	0x0172030a ,	0x0172301c ,
	0x01720bdb ,	0x017256ae ,	0x01720732 ,	0x01720120 ,
	0x0172759a ,	0x01722350 ,	0x017222ee ,	0x01724b40 ,
	0x01725878 ,	0x01726b36 ,	0x01725cfd ,	0x01723e12 ,
	0x01721a49 ,	0x01725f32 ,	0x01723bf6 ,	0x01723a9e ,
	0x0172797d ,	0x01725f49 ,	0x01720ddc ,	0x01724cad ,
	0x0172314f ,	0x01725e14 ,	0x01724df2 ,	0x01724944 ,
	0x01722e40 ,	0x01721366 ,	0x01721cd0 ,	0x0172366b ,
	0x017266c4 ,	0x01724230 ,	0x01727eb7 ,	0x01726032 ,
	0x01722c3b ,	0x017215a1 ,	0x01725422 ,	0x01723ef6 ,
	0x01720822 ,	0x01725991 ,	0x0172409d ,    0x01721101 ,

	0x01737f9b ,	0x017318e5 ,	0x01737485 ,	0x0173781c ,
	0x01734328 ,	0x017354fb ,	0x01732948 ,	0x01732702 ,
	0x01733623 ,	0x01734744 ,	0x01731209 ,	0x01734a32 ,
	0x01735f7d ,	0x017310b5 ,	0x01736a73 ,	0x017312f6 ,
	0x01733e6b ,	0x01733a85 ,	0x01734277 ,	0x01730ecf ,
	0x01733274 ,	0x01734ded ,	0x01736404 ,	0x01730029 ,
	0x01734823 ,	0x017318be ,	0x01736784 ,	0x01734ae1 ,
	0x01733d6c ,	0x01732cd6 ,	0x017372ae ,	0x01736952 ,
	0x01735f90 ,	0x01731649 ,	0x01736df1 ,	0x01735af1 ,
	0x017341bb ,	0x017326e9 ,	0x017301eb ,	0x01730bb3 ,
	0x01732ea6 ,	0x017312db ,	0x0173153c ,	0x01737e87 ,
	0x0173390c ,	0x01730f3e ,	0x01730099 ,	0x01730124 ,
	0x0173305e ,	0x0173440d ,	0x0173491c ,	0x01734d06 ,
	0x01734db7 ,	0x01731547 ,	0x017354de ,	0x017339b3 ,
	0x01732d12 ,	0x0173074d ,	0x01734dc8 ,	0x01736443 ,
	0x017366bb ,	0x0173428b ,	0x017326a6 ,	0x0173701f ,
	0x01735d03 ,	0x01737a5a ,	0x0173767d ,	0x01734509 ,
	0x01731238 ,	0x01733b25 ,	0x01731e1f ,	0x01736e5d ,
	0x01731ad4 ,	0x017363cb ,	0x01736bfc ,	0x01737f96 ,
	0x01737ff5 ,	0x01734e45 ,	0x0173323b ,	0x01732213 ,
	0x0173260d ,	0x01736b89 ,	0x0173030a ,	0x0173301c ,
	0x01730bdb ,	0x017356ae ,	0x01730732 ,	0x01730120 ,
	0x0173759a ,	0x01732350 ,	0x017322ee ,	0x01734b40 ,
	0x01735878 ,	0x01736b36 ,	0x01735cfd ,	0x01733e12 ,
	0x01731a49 ,	0x01735f32 ,	0x01733bf6 ,	0x01733a9e ,
	0x0173797d ,	0x01735f49 ,	0x01730ddc ,	0x01734cad ,
	0x0173314f ,	0x01735e14 ,	0x01734df2 ,	0x01734944 ,
	0x01732e40 ,	0x01731366 ,	0x01731cd0 ,	0x0173366b ,
	0x017366c4 ,	0x01734230 ,	0x01737eb7 ,	0x01736032 ,
	0x01732c3b ,	0x017315a1 ,	0x01735422 ,	0x01733ef6 ,
	0x01730822 ,	0x01735991 ,	0x0173409d ,    0x01731101 ,

	0x01747f9b ,	0x017418e5 ,	0x01747485 ,	0x0174781c ,
	0x01744328 ,	0x017454fb ,	0x01742948 ,	0x01742702 ,
	0x01743623 ,	0x01744744 ,	0x01741209 ,	0x01744a32 ,
	0x01745f7d ,	0x017410b5 ,	0x01746a73 ,	0x017412f6 ,
	0x01743e6b ,	0x01743a85 ,	0x01744277 ,	0x01740ecf ,
	0x01743274 ,	0x01744ded ,	0x01746404 ,	0x01740029 ,
	0x01744823 ,	0x017418be ,	0x01746784 ,	0x01744ae1 ,
	0x01743d6c ,	0x01742cd6 ,	0x017472ae ,	0x01746952 ,
	0x01745f90 ,	0x01741649 ,	0x01746df1 ,	0x01745af1 ,
	0x017441bb ,	0x017426e9 ,	0x017401eb ,	0x01740bb3 ,
	0x01742ea6 ,	0x017412db ,	0x0174153c ,	0x01747e87 ,
	0x0174390c ,	0x01740f3e ,	0x01740099 ,	0x01740124 ,
	0x0174305e ,	0x0174440d ,	0x0174491c ,	0x01744d06 ,
	0x01744db7 ,	0x01741547 ,	0x017454de ,	0x017439b3 ,
	0x01742d12 ,	0x0174074d ,	0x01744dc8 ,	0x01746443 ,
	0x017466bb ,	0x0174428b ,	0x017426a6 ,	0x0174701f ,
	0x01745d03 ,	0x01747a5a ,	0x0174767d ,	0x01744509 ,
	0x01741238 ,	0x01743b25 ,	0x01741e1f ,	0x01746e5d ,
	0x01741ad4 ,	0x017463cb ,	0x01746bfc ,	0x01747f96 ,
	0x01747ff5 ,	0x01744e45 ,	0x0174323b ,	0x01742213 ,
	0x0174260d ,	0x01746b89 ,	0x0174030a ,	0x0174301c ,
	0x01740bdb ,	0x017456ae ,	0x01740732 ,	0x01740120 ,
	0x0174759a ,	0x01742350 ,	0x017422ee ,	0x01744b40 ,
	0x01745878 ,	0x01746b36 ,	0x01745cfd ,	0x01743e12 ,
	0x01741a49 ,	0x01745f32 ,	0x01743bf6 ,	0x01743a9e ,
	0x0174797d ,	0x01745f49 ,	0x01740ddc ,	0x01744cad ,
	0x0174314f ,	0x01745e14 ,	0x01744df2 ,	0x01744944 ,
	0x01742e40 ,	0x01741366 ,	0x01741cd0 ,	0x0174366b ,
	0x017466c4 ,	0x01744230 ,	0x01747eb7 ,	0x01746032 ,
	0x01742c3b ,	0x017415a1 ,	0x01745422 ,	0x01743ef6 ,
	0x01740822 ,	0x01745991 ,	0x0174409d ,    0x01741101 ,

	0x01757f9b ,	0x017518e5 ,	0x01757485 ,	0x0175781c ,
	0x01754328 ,	0x017554fb ,	0x01752948 ,	0x01752702 ,
	0x01753623 ,	0x01754744 ,	0x01751209 ,	0x01754a32 ,
	0x01755f7d ,	0x017510b5 ,	0x01756a73 ,	0x017512f6 ,
	0x01753e6b ,	0x01753a85 ,	0x01754277 ,	0x01750ecf ,
	0x01753274 ,	0x01754ded ,	0x01756404 ,	0x01750029 ,
	0x01754823 ,	0x017518be ,	0x01756784 ,	0x01754ae1 ,
	0x01753d6c ,	0x01752cd6 ,	0x017572ae ,	0x01756952 ,
	0x01755f90 ,	0x01751649 ,	0x01756df1 ,	0x01755af1 ,
	0x017541bb ,	0x017526e9 ,	0x017501eb ,	0x01750bb3 ,
	0x01752ea6 ,	0x017512db ,	0x0175153c ,	0x01757e87 ,
	0x0175390c ,	0x01750f3e ,	0x01750099 ,	0x01750124 ,
	0x0175305e ,	0x0175440d ,	0x0175491c ,	0x01754d06 ,
	0x01754db7 ,	0x01751547 ,	0x017554de ,	0x017539b3 ,
	0x01752d12 ,	0x0175074d ,	0x01754dc8 ,	0x01756443 ,
	0x017566bb ,	0x0175428b ,	0x017526a6 ,	0x0175701f ,
	0x01755d03 ,	0x01757a5a ,	0x0175767d ,	0x01754509 ,
	0x01751238 ,	0x01753b25 ,	0x01751e1f ,	0x01756e5d ,
	0x01751ad4 ,	0x017563cb ,	0x01756bfc ,	0x01757f96 ,
	0x01757ff5 ,	0x01754e45 ,	0x0175323b ,	0x01752213 ,
	0x0175260d ,	0x01756b89 ,	0x0175030a ,	0x0175301c ,
	0x01750bdb ,	0x017556ae ,	0x01750732 ,	0x01750120 ,
	0x0175759a ,	0x01752350 ,	0x017522ee ,	0x01754b40 ,
	0x01755878 ,	0x01756b36 ,	0x01755cfd ,	0x01753e12 ,
	0x01751a49 ,	0x01755f32 ,	0x01753bf6 ,	0x01753a9e ,
	0x0175797d ,	0x01755f49 ,	0x01750ddc ,	0x01754cad ,
	0x0175314f ,	0x01755e14 ,	0x01754df2 ,	0x01754944 ,
	0x01752e40 ,	0x01751366 ,	0x01751cd0 ,	0x0175366b ,
	0x017566c4 ,	0x01754230 ,	0x01757eb7 ,	0x01756032 ,
	0x01752c3b ,	0x017515a1 ,	0x01755422 ,	0x01753ef6 ,
	0x01750822 ,	0x01755991 ,	0x0175409d ,    0x01751101 ,

	0x01767f9b ,	0x017618e5 ,	0x01767485 ,	0x0176781c ,
	0x01764328 ,	0x017654fb ,	0x01762948 ,	0x01762702 ,
	0x01763623 ,	0x01764744 ,	0x01761209 ,	0x01764a32 ,
	0x01765f7d ,	0x017610b5 ,	0x01766a73 ,	0x017612f6 ,
	0x01763e6b ,	0x01763a85 ,	0x01764277 ,	0x01760ecf ,
	0x01763274 ,	0x01764ded ,	0x01766404 ,	0x01760029 ,
	0x01764823 ,	0x017618be ,	0x01766784 ,	0x01764ae1 ,
	0x01763d6c ,	0x01762cd6 ,	0x017672ae ,	0x01766952 ,
	0x01765f90 ,	0x01761649 ,	0x01766df1 ,	0x01765af1 ,
	0x017641bb ,	0x017626e9 ,	0x017601eb ,	0x01760bb3 ,
	0x01762ea6 ,	0x017612db ,	0x0176153c ,	0x01767e87 ,
	0x0176390c ,	0x01760f3e ,	0x01760099 ,	0x01760124 ,
	0x0176305e ,	0x0176440d ,	0x0176491c ,	0x01764d06 ,
	0x01764db7 ,	0x01761547 ,	0x017654de ,	0x017639b3 ,
	0x01762d12 ,	0x0176074d ,	0x01764dc8 ,	0x01766443 ,
	0x017666bb ,	0x0176428b ,	0x017626a6 ,	0x0176701f ,
	0x01765d03 ,	0x01767a5a ,	0x0176767d ,	0x01764509 ,
	0x01761238 ,	0x01763b25 ,	0x01761e1f ,	0x01766e5d ,
	0x01761ad4 ,	0x017663cb ,	0x01766bfc ,	0x01767f96 ,
	0x01767ff5 ,	0x01764e45 ,	0x0176323b ,	0x01762213 ,
	0x0176260d ,	0x01766b89 ,	0x0176030a ,	0x0176301c ,
	0x01760bdb ,	0x017656ae ,	0x01760732 ,	0x01760120 ,
	0x0176759a ,	0x01762350 ,	0x017622ee ,	0x01764b40 ,
	0x01765878 ,	0x01766b36 ,	0x01765cfd ,	0x01763e12 ,
	0x01761a49 ,	0x01765f32 ,	0x01763bf6 ,	0x01763a9e ,
	0x0176797d ,	0x01765f49 ,	0x01760ddc ,	0x01764cad ,
	0x0176314f ,	0x01765e14 ,	0x01764df2 ,	0x01764944 ,
	0x01762e40 ,	0x01761366 ,	0x01761cd0 ,	0x0176366b ,
	0x017666c4 ,	0x01764230 ,	0x01767eb7 ,	0x01766032 ,
	0x01762c3b ,	0x017615a1 ,	0x01765422 ,	0x01763ef6 ,
	0x01760822 ,	0x01765991 ,	0x0176409d ,    0x01761101 ,

	0x01777f9b ,	0x017718e5 ,	0x01777485 ,	0x0177781c ,
	0x01774328 ,	0x017754fb ,	0x01772948 ,	0x01772702 ,
	0x01773623 ,	0x01774744 ,	0x01771209 ,	0x01774a32 ,
	0x01775f7d ,	0x017710b5 ,	0x01776a73 ,	0x017712f6 ,
	0x01773e6b ,	0x01773a85 ,	0x01774277 ,	0x01770ecf ,
	0x01773274 ,	0x01774ded ,	0x01776404 ,	0x01770029 ,
	0x01774823 ,	0x017718be ,	0x01776784 ,	0x01774ae1 ,
	0x01773d6c ,	0x01772cd6 ,	0x017772ae ,	0x01776952 ,
	0x01775f90 ,	0x01771649 ,	0x01776df1 ,	0x01775af1 ,
	0x017741bb ,	0x017726e9 ,	0x017701eb ,	0x01770bb3 ,
	0x01772ea6 ,	0x017712db ,	0x0177153c ,	0x01777e87 ,
	0x0177390c ,	0x01770f3e ,	0x01770099 ,	0x01770124 ,
	0x0177305e ,	0x0177440d ,	0x0177491c ,	0x01774d06 ,
	0x01774db7 ,	0x01771547 ,	0x017754de ,	0x017739b3 ,
	0x01772d12 ,	0x0177074d ,	0x01774dc8 ,	0x01776443 ,
	0x017766bb ,	0x0177428b ,	0x017726a6 ,	0x0177701f ,
	0x01775d03 ,	0x01777a5a ,	0x0177767d ,	0x01774509 ,
	0x01771238 ,	0x01773b25 ,	0x01771e1f ,	0x01776e5d ,
	0x01771ad4 ,	0x017763cb ,	0x01776bfc ,	0x01777f96 ,
	0x01777ff5 ,	0x01774e45 ,	0x0177323b ,	0x01772213 ,
	0x0177260d ,	0x01776b89 ,	0x0177030a ,	0x0177301c ,
	0x01770bdb ,	0x017756ae ,	0x01770732 ,	0x01770120 ,
	0x0177759a ,	0x01772350 ,	0x017722ee ,	0x01774b40 ,
	0x01775878 ,	0x01776b36 ,	0x01775cfd ,	0x01773e12 ,
	0x01771a49 ,	0x01775f32 ,	0x01773bf6 ,	0x01773a9e ,
	0x0177797d ,	0x01775f49 ,	0x01770ddc ,	0x01774cad ,
	0x0177314f ,	0x01775e14 ,	0x01774df2 ,	0x01774944 ,
	0x01772e40 ,	0x01771366 ,	0x01771cd0 ,	0x0177366b ,
	0x017766c4 ,	0x01774230 ,	0x01777eb7 ,	0x01776032 ,
	0x01772c3b ,	0x017715a1 ,	0x01775422 ,	0x01773ef6 ,
	0x01770822 ,	0x01775991 ,	0x0177409d ,    0x01771101 ,

	0x01787f9b ,	0x017818e5 ,	0x01787485 ,	0x0178781c ,
	0x01784328 ,	0x017854fb ,	0x01782948 ,	0x01782702 ,
	0x01783623 ,	0x01784744 ,	0x01781209 ,	0x01784a32 ,
	0x01785f7d ,	0x017810b5 ,	0x01786a73 ,	0x017812f6 ,
	0x01783e6b ,	0x01783a85 ,	0x01784277 ,	0x01780ecf ,
	0x01783274 ,	0x01784ded ,	0x01786404 ,	0x01780029 ,
	0x01784823 ,	0x017818be ,	0x01786784 ,	0x01784ae1 ,
	0x01783d6c ,	0x01782cd6 ,	0x017872ae ,	0x01786952 ,
	0x01785f90 ,	0x01781649 ,	0x01786df1 ,	0x01785af1 ,
	0x017841bb ,	0x017826e9 ,	0x017801eb ,	0x01780bb3 ,
	0x01782ea6 ,	0x017812db ,	0x0178153c ,	0x01787e87 ,
	0x0178390c ,	0x01780f3e ,	0x01780099 ,	0x01780124 ,
	0x0178305e ,	0x0178440d ,	0x0178491c ,	0x01784d06 ,
	0x01784db7 ,	0x01781547 ,	0x017854de ,	0x017839b3 ,
	0x01782d12 ,	0x0178074d ,	0x01784dc8 ,	0x01786443 ,
	0x017866bb ,	0x0178428b ,	0x017826a6 ,	0x0178701f ,
	0x01785d03 ,	0x01787a5a ,	0x0178767d ,	0x01784509 ,
	0x01781238 ,	0x01783b25 ,	0x01781e1f ,	0x01786e5d ,
	0x01781ad4 ,	0x017863cb ,	0x01786bfc ,	0x01787f96 ,
	0x01787ff5 ,	0x01784e45 ,	0x0178323b ,	0x01782213 ,
	0x0178260d ,	0x01786b89 ,	0x0178030a ,	0x0178301c ,
	0x01780bdb ,	0x017856ae ,	0x01780732 ,	0x01780120 ,
	0x0178759a ,	0x01782350 ,	0x017822ee ,	0x01784b40 ,
	0x01785878 ,	0x01786b36 ,	0x01785cfd ,	0x01783e12 ,
	0x01781a49 ,	0x01785f32 ,	0x01783bf6 ,	0x01783a9e ,
	0x0178797d ,	0x01785f49 ,	0x01780ddc ,	0x01784cad ,
	0x0178314f ,	0x01785e14 ,	0x01784df2 ,	0x01784944 ,
	0x01782e40 ,	0x01781366 ,	0x01781cd0 ,	0x0178366b ,
	0x017866c4 ,	0x01784230 ,	0x01787eb7 ,	0x01786032 ,
	0x01782c3b ,	0x017815a1 ,	0x01785422 ,	0x01783ef6 ,
	0x01780822 ,	0x01785991 ,	0x0178409d ,    0x01781101 ,

	0x01797f9b ,	0x017918e5 ,	0x01797485 ,	0x0179781c ,
	0x01794328 ,	0x017954fb ,	0x01792948 ,	0x01792702 ,
	0x01793623 ,	0x01794744 ,	0x01791209 ,	0x01794a32 ,
	0x01795f7d ,	0x017910b5 ,	0x01796a73 ,	0x017912f6 ,
	0x01793e6b ,	0x01793a85 ,	0x01794277 ,	0x01790ecf ,
	0x01793274 ,	0x01794ded ,	0x01796404 ,	0x01790029 ,
	0x01794823 ,	0x017918be ,	0x01796784 ,	0x01794ae1 ,
	0x01793d6c ,	0x01792cd6 ,	0x017972ae ,	0x01796952 ,
	0x01795f90 ,	0x01791649 ,	0x01796df1 ,	0x01795af1 ,
	0x017941bb ,	0x017926e9 ,	0x017901eb ,	0x01790bb3 ,
	0x01792ea6 ,	0x017912db ,	0x0179153c ,	0x01797e87 ,
	0x0179390c ,	0x01790f3e ,	0x01790099 ,	0x01790124 ,
	0x0179305e ,	0x0179440d ,	0x0179491c ,	0x01794d06 ,
	0x01794db7 ,	0x01791547 ,	0x017954de ,	0x017939b3 ,
	0x01792d12 ,	0x0179074d ,	0x01794dc8 ,	0x01796443 ,
	0x017966bb ,	0x0179428b ,	0x017926a6 ,	0x0179701f ,
	0x01795d03 ,	0x01797a5a ,	0x0179767d ,	0x01794509 ,
	0x01791238 ,	0x01793b25 ,	0x01791e1f ,	0x01796e5d ,
	0x01791ad4 ,	0x017963cb ,	0x01796bfc ,	0x01797f96 ,
	0x01797ff5 ,	0x01794e45 ,	0x0179323b ,	0x01792213 ,
	0x0179260d ,	0x01796b89 ,	0x0179030a ,	0x0179301c ,
	0x01790bdb ,	0x017956ae ,	0x01790732 ,	0x01790120 ,
	0x0179759a ,	0x01792350 ,	0x017922ee ,	0x01794b40 ,
	0x01795878 ,	0x01796b36 ,	0x01795cfd ,	0x01793e12 ,
	0x01791a49 ,	0x01795f32 ,	0x01793bf6 ,	0x01793a9e ,
	0x0179797d ,	0x01795f49 ,	0x01790ddc ,	0x01794cad ,
	0x0179314f ,	0x01795e14 ,	0x01794df2 ,	0x01794944 ,
	0x01792e40 ,	0x01791366 ,	0x01791cd0 ,	0x0179366b ,
	0x017966c4 ,	0x01794230 ,	0x01797eb7 ,	0x01796032 ,
	0x01792c3b ,	0x017915a1 ,	0x01795422 ,	0x01793ef6 ,
	0x01790822 ,	0x01795991 ,	0x0179409d ,    0x01791101 ,

	0x01807f9b ,	0x018018e5 ,	0x01807485 ,	0x0180781c ,
	0x01804328 ,	0x018054fb ,	0x01802948 ,	0x01802702 ,
	0x01803623 ,	0x01804744 ,	0x01801209 ,	0x01804a32 ,
	0x01805f7d ,	0x018010b5 ,	0x01806a73 ,	0x018012f6 ,
	0x01803e6b ,	0x01803a85 ,	0x01804277 ,	0x01800ecf ,
	0x01803274 ,	0x01804ded ,	0x01806404 ,	0x01800029 ,
	0x01804823 ,	0x018018be ,	0x01806784 ,	0x01804ae1 ,
	0x01803d6c ,	0x01802cd6 ,	0x018072ae ,	0x01806952 ,
	0x01805f90 ,	0x01801649 ,	0x01806df1 ,	0x01805af1 ,
	0x018041bb ,	0x018026e9 ,	0x018001eb ,	0x01800bb3 ,
	0x01802ea6 ,	0x018012db ,	0x0180153c ,	0x01807e87 ,
	0x0180390c ,	0x01800f3e ,	0x01800099 ,	0x01800124 ,
	0x0180305e ,	0x0180440d ,	0x0180491c ,	0x01804d06 ,
	0x01804db7 ,	0x01801547 ,	0x018054de ,	0x018039b3 ,
	0x01802d12 ,	0x0180074d ,	0x01804dc8 ,	0x01806443 ,
	0x018066bb ,	0x0180428b ,	0x018026a6 ,	0x0180701f ,
	0x01805d03 ,	0x01807a5a ,	0x0180767d ,	0x01804509 ,
	0x01801238 ,	0x01803b25 ,	0x01801e1f ,	0x01806e5d ,
	0x01801ad4 ,	0x018063cb ,	0x01806bfc ,	0x01807f96 ,
	0x01807ff5 ,	0x01804e45 ,	0x0180323b ,	0x01802213 ,
	0x0180260d ,	0x01806b89 ,	0x0180030a ,	0x0180301c ,
	0x01800bdb ,	0x018056ae ,	0x01800732 ,	0x01800120 ,
	0x0180759a ,	0x01802350 ,	0x018022ee ,	0x01804b40 ,
	0x01805878 ,	0x01806b36 ,	0x01805cfd ,	0x01803e12 ,
	0x01801a49 ,	0x01805f32 ,	0x01803bf6 ,	0x01803a9e ,
	0x0180797d ,	0x01805f49 ,	0x01800ddc ,	0x01804cad ,
	0x0180314f ,	0x01805e14 ,	0x01804df2 ,	0x01804944 ,
	0x01802e40 ,	0x01801366 ,	0x01801cd0 ,	0x0180366b ,
	0x018066c4 ,	0x01804230 ,	0x01807eb7 ,	0x01806032 ,
	0x01802c3b ,	0x018015a1 ,	0x01805422 ,	0x01803ef6 ,
	0x01800822 ,	0x01805991 ,	0x0180409d ,    0x01801101 ,

	0x01817f9b ,	0x018118e5 ,	0x01817485 ,	0x0181781c ,
	0x01814328 ,	0x018154fb ,	0x01812948 ,	0x01812702 ,
	0x01813623 ,	0x01814744 ,	0x01811209 ,	0x01814a32 ,
	0x01815f7d ,	0x018110b5 ,	0x01816a73 ,	0x018112f6 ,
	0x01813e6b ,	0x01813a85 ,	0x01814277 ,	0x01810ecf ,
	0x01813274 ,	0x01814ded ,	0x01816404 ,	0x01810029 ,
	0x01814823 ,	0x018118be ,	0x01816784 ,	0x01814ae1 ,
	0x01813d6c ,	0x01812cd6 ,	0x018172ae ,	0x01816952 ,
	0x01815f90 ,	0x01811649 ,	0x01816df1 ,	0x01815af1 ,
	0x018141bb ,	0x018126e9 ,	0x018101eb ,	0x01810bb3 ,
	0x01812ea6 ,	0x018112db ,	0x0181153c ,	0x01817e87 ,
	0x0181390c ,	0x01810f3e ,	0x01810099 ,	0x01810124 ,
	0x0181305e ,	0x0181440d ,	0x0181491c ,	0x01814d06 ,
	0x01814db7 ,	0x01811547 ,	0x018154de ,	0x018139b3 ,
	0x01812d12 ,	0x0181074d ,	0x01814dc8 ,	0x01816443 ,
	0x018166bb ,	0x0181428b ,	0x018126a6 ,	0x0181701f ,
	0x01815d03 ,	0x01817a5a ,	0x0181767d ,	0x01814509 ,
	0x01811238 ,	0x01813b25 ,	0x01811e1f ,	0x01816e5d ,
	0x01811ad4 ,	0x018163cb ,	0x01816bfc ,	0x01817f96 ,
	0x01817ff5 ,	0x01814e45 ,	0x0181323b ,	0x01812213 ,
	0x0181260d ,	0x01816b89 ,	0x0181030a ,	0x0181301c ,
	0x01810bdb ,	0x018156ae ,	0x01810732 ,	0x01810120 ,
	0x0181759a ,	0x01812350 ,	0x018122ee ,	0x01814b40 ,
	0x01815878 ,	0x01816b36 ,	0x01815cfd ,	0x01813e12 ,
	0x01811a49 ,	0x01815f32 ,	0x01813bf6 ,	0x01813a9e ,
	0x0181797d ,	0x01815f49 ,	0x01810ddc ,	0x01814cad ,
	0x0181314f ,	0x01815e14 ,	0x01814df2 ,	0x01814944 ,
	0x01812e40 ,	0x01811366 ,	0x01811cd0 ,	0x0181366b ,
	0x018166c4 ,	0x01814230 ,	0x01817eb7 ,	0x01816032 ,
	0x01812c3b ,	0x018115a1 ,	0x01815422 ,	0x01813ef6 ,
	0x01810822 ,	0x01815991 ,	0x0181409d ,    0x01811101 ,

	0x01827f9b ,	0x018218e5 ,	0x01827485 ,	0x0182781c ,
	0x01824328 ,	0x018254fb ,	0x01822948 ,	0x01822702 ,
	0x01823623 ,	0x01824744 ,	0x01821209 ,	0x01824a32 ,
	0x01825f7d ,	0x018210b5 ,	0x01826a73 ,	0x018212f6 ,
	0x01823e6b ,	0x01823a85 ,	0x01824277 ,	0x01820ecf ,
	0x01823274 ,	0x01824ded ,	0x01826404 ,	0x01820029 ,
	0x01824823 ,	0x018218be ,	0x01826784 ,	0x01824ae1 ,
	0x01823d6c ,	0x01822cd6 ,	0x018272ae ,	0x01826952 ,
	0x01825f90 ,	0x01821649 ,	0x01826df1 ,	0x01825af1 ,
	0x018241bb ,	0x018226e9 ,	0x018201eb ,	0x01820bb3 ,
	0x01822ea6 ,	0x018212db ,	0x0182153c ,	0x01827e87 ,
	0x0182390c ,	0x01820f3e ,	0x01820099 ,	0x01820124 ,
	0x0182305e ,	0x0182440d ,	0x0182491c ,	0x01824d06 ,
	0x01824db7 ,	0x01821547 ,	0x018254de ,	0x018239b3 ,
	0x01822d12 ,	0x0182074d ,	0x01824dc8 ,	0x01826443 ,
	0x018266bb ,	0x0182428b ,	0x018226a6 ,	0x0182701f ,
	0x01825d03 ,	0x01827a5a ,	0x0182767d ,	0x01824509 ,
	0x01821238 ,	0x01823b25 ,	0x01821e1f ,	0x01826e5d ,
	0x01821ad4 ,	0x018263cb ,	0x01826bfc ,	0x01827f96 ,
	0x01827ff5 ,	0x01824e45 ,	0x0182323b ,	0x01822213 ,
	0x0182260d ,	0x01826b89 ,	0x0182030a ,	0x0182301c ,
	0x01820bdb ,	0x018256ae ,	0x01820732 ,	0x01820120 ,
	0x0182759a ,	0x01822350 ,	0x018222ee ,	0x01824b40 ,
	0x01825878 ,	0x01826b36 ,	0x01825cfd ,	0x01823e12 ,
	0x01821a49 ,	0x01825f32 ,	0x01823bf6 ,	0x01823a9e ,
	0x0182797d ,	0x01825f49 ,	0x01820ddc ,	0x01824cad ,
	0x0182314f ,	0x01825e14 ,	0x01824df2 ,	0x01824944 ,
	0x01822e40 ,	0x01821366 ,	0x01821cd0 ,	0x0182366b ,
	0x018266c4 ,	0x01824230 ,	0x01827eb7 ,	0x01826032 ,
	0x01822c3b ,	0x018215a1 ,	0x01825422 ,	0x01823ef6 ,
	0x01820822 ,	0x01825991 ,	0x0182409d ,    0x01821101 ,

	0x01837f9b ,	0x018318e5 ,	0x01837485 ,	0x0183781c ,
	0x01834328 ,	0x018354fb ,	0x01832948 ,	0x01832702 ,
	0x01833623 ,	0x01834744 ,	0x01831209 ,	0x01834a32 ,
	0x01835f7d ,	0x018310b5 ,	0x01836a73 ,	0x018312f6 ,
	0x01833e6b ,	0x01833a85 ,	0x01834277 ,	0x01830ecf ,
	0x01833274 ,	0x01834ded ,	0x01836404 ,	0x01830029 ,
	0x01834823 ,	0x018318be ,	0x01836784 ,	0x01834ae1 ,
	0x01833d6c ,	0x01832cd6 ,	0x018372ae ,	0x01836952 ,
	0x01835f90 ,	0x01831649 ,	0x01836df1 ,	0x01835af1 ,
	0x018341bb ,	0x018326e9 ,	0x018301eb ,	0x01830bb3 ,
	0x01832ea6 ,	0x018312db ,	0x0183153c ,	0x01837e87 ,
	0x0183390c ,	0x01830f3e ,	0x01830099 ,	0x01830124 ,
	0x0183305e ,	0x0183440d ,	0x0183491c ,	0x01834d06 ,
	0x01834db7 ,	0x01831547 ,	0x018354de ,	0x018339b3 ,
	0x01832d12 ,	0x0183074d ,	0x01834dc8 ,	0x01836443 ,
	0x018366bb ,	0x0183428b ,	0x018326a6 ,	0x0183701f ,
	0x01835d03 ,	0x01837a5a ,	0x0183767d ,	0x01834509 ,
	0x01831238 ,	0x01833b25 ,	0x01831e1f ,	0x01836e5d ,
	0x01831ad4 ,	0x018363cb ,	0x01836bfc ,	0x01837f96 ,
	0x01837ff5 ,	0x01834e45 ,	0x0183323b ,	0x01832213 ,
	0x0183260d ,	0x01836b89 ,	0x0183030a ,	0x0183301c ,
	0x01830bdb ,	0x018356ae ,	0x01830732 ,	0x01830120 ,
	0x0183759a ,	0x01832350 ,	0x018322ee ,	0x01834b40 ,
	0x01835878 ,	0x01836b36 ,	0x01835cfd ,	0x01833e12 ,
	0x01831a49 ,	0x01835f32 ,	0x01833bf6 ,	0x01833a9e ,
	0x0183797d ,	0x01835f49 ,	0x01830ddc ,	0x01834cad ,
	0x0183314f ,	0x01835e14 ,	0x01834df2 ,	0x01834944 ,
	0x01832e40 ,	0x01831366 ,	0x01831cd0 ,	0x0183366b ,
	0x018366c4 ,	0x01834230 ,	0x01837eb7 ,	0x01836032 ,
	0x01832c3b ,	0x018315a1 ,	0x01835422 ,	0x01833ef6 ,
	0x01830822 ,	0x01835991 ,	0x0183409d ,    0x01831101 ,

	0x01847f9b ,	0x018418e5 ,	0x01847485 ,	0x0184781c ,
	0x01844328 ,	0x018454fb ,	0x01842948 ,	0x01842702 ,
	0x01843623 ,	0x01844744 ,	0x01841209 ,	0x01844a32 ,
	0x01845f7d ,	0x018410b5 ,	0x01846a73 ,	0x018412f6 ,
	0x01843e6b ,	0x01843a85 ,	0x01844277 ,	0x01840ecf ,
	0x01843274 ,	0x01844ded ,	0x01846404 ,	0x01840029 ,
	0x01844823 ,	0x018418be ,	0x01846784 ,	0x01844ae1 ,
	0x01843d6c ,	0x01842cd6 ,	0x018472ae ,	0x01846952 ,
	0x01845f90 ,	0x01841649 ,	0x01846df1 ,	0x01845af1 ,
	0x018441bb ,	0x018426e9 ,	0x018401eb ,	0x01840bb3 ,
	0x01842ea6 ,	0x018412db ,	0x0184153c ,	0x01847e87 ,
	0x0184390c ,	0x01840f3e ,	0x01840099 ,	0x01840124 ,
	0x0184305e ,	0x0184440d ,	0x0184491c ,	0x01844d06 ,
	0x01844db7 ,	0x01841547 ,	0x018454de ,	0x018439b3 ,
	0x01842d12 ,	0x0184074d ,	0x01844dc8 ,	0x01846443 ,
	0x018466bb ,	0x0184428b ,	0x018426a6 ,	0x0184701f ,
	0x01845d03 ,	0x01847a5a ,	0x0184767d ,	0x01844509 ,
	0x01841238 ,	0x01843b25 ,	0x01841e1f ,	0x01846e5d ,
	0x01841ad4 ,	0x018463cb ,	0x01846bfc ,	0x01847f96 ,
	0x01847ff5 ,	0x01844e45 ,	0x0184323b ,	0x01842213 ,
	0x0184260d ,	0x01846b89 ,	0x0184030a ,	0x0184301c ,
	0x01840bdb ,	0x018456ae ,	0x01840732 ,	0x01840120 ,
	0x0184759a ,	0x01842350 ,	0x018422ee ,	0x01844b40 ,
	0x01845878 ,	0x01846b36 ,	0x01845cfd ,	0x01843e12 ,
	0x01841a49 ,	0x01845f32 ,	0x01843bf6 ,	0x01843a9e ,
	0x0184797d ,	0x01845f49 ,	0x01840ddc ,	0x01844cad ,
	0x0184314f ,	0x01845e14 ,	0x01844df2 ,	0x01844944 ,
	0x01842e40 ,	0x01841366 ,	0x01841cd0 ,	0x0184366b ,
	0x018466c4 ,	0x01844230 ,	0x01847eb7 ,	0x01846032 ,
	0x01842c3b ,	0x018415a1 ,	0x01845422 ,	0x01843ef6 ,
	0x01840822 ,	0x01845991 ,	0x0184409d ,    0x01841101 ,

	0x01857f9b ,	0x018518e5 ,	0x01857485 ,	0x0185781c ,
	0x01854328 ,	0x018554fb ,	0x01852948 ,	0x01852702 ,
	0x01853623 ,	0x01854744 ,	0x01851209 ,	0x01854a32 ,
	0x01855f7d ,	0x018510b5 ,	0x01856a73 ,	0x018512f6 ,
	0x01853e6b ,	0x01853a85 ,	0x01854277 ,	0x01850ecf ,
	0x01853274 ,	0x01854ded ,	0x01856404 ,	0x01850029 ,
	0x01854823 ,	0x018518be ,	0x01856784 ,	0x01854ae1 ,
	0x01853d6c ,	0x01852cd6 ,	0x018572ae ,	0x01856952 ,
	0x01855f90 ,	0x01851649 ,	0x01856df1 ,	0x01855af1 ,
	0x018541bb ,	0x018526e9 ,	0x018501eb ,	0x01850bb3 ,
	0x01852ea6 ,	0x018512db ,	0x0185153c ,	0x01857e87 ,
	0x0185390c ,	0x01850f3e ,	0x01850099 ,	0x01850124 ,
	0x0185305e ,	0x0185440d ,	0x0185491c ,	0x01854d06 ,
	0x01854db7 ,	0x01851547 ,	0x018554de ,	0x018539b3 ,
	0x01852d12 ,	0x0185074d ,	0x01854dc8 ,	0x01856443 ,
	0x018566bb ,	0x0185428b ,	0x018526a6 ,	0x0185701f ,
	0x01855d03 ,	0x01857a5a ,	0x0185767d ,	0x01854509 ,
	0x01851238 ,	0x01853b25 ,	0x01851e1f ,	0x01856e5d ,
	0x01851ad4 ,	0x018563cb ,	0x01856bfc ,	0x01857f96 ,
	0x01857ff5 ,	0x01854e45 ,	0x0185323b ,	0x01852213 ,
	0x0185260d ,	0x01856b89 ,	0x0185030a ,	0x0185301c ,
	0x01850bdb ,	0x018556ae ,	0x01850732 ,	0x01850120 ,
	0x0185759a ,	0x01852350 ,	0x018522ee ,	0x01854b40 ,
	0x01855878 ,	0x01856b36 ,	0x01855cfd ,	0x01853e12 ,
	0x01851a49 ,	0x01855f32 ,	0x01853bf6 ,	0x01853a9e ,
	0x0185797d ,	0x01855f49 ,	0x01850ddc ,	0x01854cad ,
	0x0185314f ,	0x01855e14 ,	0x01854df2 ,	0x01854944 ,
	0x01852e40 ,	0x01851366 ,	0x01851cd0 ,	0x0185366b ,
	0x018566c4 ,	0x01854230 ,	0x01857eb7 ,	0x01856032 ,
	0x01852c3b ,	0x018515a1 ,	0x01855422 ,	0x01853ef6 ,
	0x01850822 ,	0x01855991 ,	0x0185409d ,    0x01851101 ,

	0x01867f9b ,	0x018618e5 ,	0x01867485 ,	0x0186781c ,
	0x01864328 ,	0x018654fb ,	0x01862948 ,	0x01862702 ,
	0x01863623 ,	0x01864744 ,	0x01861209 ,	0x01864a32 ,
	0x01865f7d ,	0x018610b5 ,	0x01866a73 ,	0x018612f6 ,
	0x01863e6b ,	0x01863a85 ,	0x01864277 ,	0x01860ecf ,
	0x01863274 ,	0x01864ded ,	0x01866404 ,	0x01860029 ,
	0x01864823 ,	0x018618be ,	0x01866784 ,	0x01864ae1 ,
	0x01863d6c ,	0x01862cd6 ,	0x018672ae ,	0x01866952 ,
	0x01865f90 ,	0x01861649 ,	0x01866df1 ,	0x01865af1 ,
	0x018641bb ,	0x018626e9 ,	0x018601eb ,	0x01860bb3 ,
	0x01862ea6 ,	0x018612db ,	0x0186153c ,	0x01867e87 ,
	0x0186390c ,	0x01860f3e ,	0x01860099 ,	0x01860124 ,
	0x0186305e ,	0x0186440d ,	0x0186491c ,	0x01864d06 ,
	0x01864db7 ,	0x01861547 ,	0x018654de ,	0x018639b3 ,
	0x01862d12 ,	0x0186074d ,	0x01864dc8 ,	0x01866443 ,
	0x018666bb ,	0x0186428b ,	0x018626a6 ,	0x0186701f ,
	0x01865d03 ,	0x01867a5a ,	0x0186767d ,	0x01864509 ,
	0x01861238 ,	0x01863b25 ,	0x01861e1f ,	0x01866e5d ,
	0x01861ad4 ,	0x018663cb ,	0x01866bfc ,	0x01867f96 ,
	0x01867ff5 ,	0x01864e45 ,	0x0186323b ,	0x01862213 ,
	0x0186260d ,	0x01866b89 ,	0x0186030a ,	0x0186301c ,
	0x01860bdb ,	0x018656ae ,	0x01860732 ,	0x01860120 ,
	0x0186759a ,	0x01862350 ,	0x018622ee ,	0x01864b40 ,
	0x01865878 ,	0x01866b36 ,	0x01865cfd ,	0x01863e12 ,
	0x01861a49 ,	0x01865f32 ,	0x01863bf6 ,	0x01863a9e ,
	0x0186797d ,	0x01865f49 ,	0x01860ddc ,	0x01864cad ,
	0x0186314f ,	0x01865e14 ,	0x01864df2 ,	0x01864944 ,
	0x01862e40 ,	0x01861366 ,	0x01861cd0 ,	0x0186366b ,
	0x018666c4 ,	0x01864230 ,	0x01867eb7 ,	0x01866032 ,
	0x01862c3b ,	0x018615a1 ,	0x01865422 ,	0x01863ef6 ,
	0x01860822 ,	0x01865991 ,	0x0186409d ,    0x01861101 ,

	0x01877f9b ,	0x018718e5 ,	0x01877485 ,	0x0187781c ,
	0x01874328 ,	0x018754fb ,	0x01872948 ,	0x01872702 ,
	0x01873623 ,	0x01874744 ,	0x01871209 ,	0x01874a32 ,
	0x01875f7d ,	0x018710b5 ,	0x01876a73 ,	0x018712f6 ,
	0x01873e6b ,	0x01873a85 ,	0x01874277 ,	0x01870ecf ,
	0x01873274 ,	0x01874ded ,	0x01876404 ,	0x01870029 ,
	0x01874823 ,	0x018718be ,	0x01876784 ,	0x01874ae1 ,
	0x01873d6c ,	0x01872cd6 ,	0x018772ae ,	0x01876952 ,
	0x01875f90 ,	0x01871649 ,	0x01876df1 ,	0x01875af1 ,
	0x018741bb ,	0x018726e9 ,	0x018701eb ,	0x01870bb3 ,
	0x01872ea6 ,	0x018712db ,	0x0187153c ,	0x01877e87 ,
	0x0187390c ,	0x01870f3e ,	0x01870099 ,	0x01870124 ,
	0x0187305e ,	0x0187440d ,	0x0187491c ,	0x01874d06 ,
	0x01874db7 ,	0x01871547 ,	0x018754de ,	0x018739b3 ,
	0x01872d12 ,	0x0187074d ,	0x01874dc8 ,	0x01876443 ,
	0x018766bb ,	0x0187428b ,	0x018726a6 ,	0x0187701f ,
	0x01875d03 ,	0x01877a5a ,	0x0187767d ,	0x01874509 ,
	0x01871238 ,	0x01873b25 ,	0x01871e1f ,	0x01876e5d ,
	0x01871ad4 ,	0x018763cb ,	0x01876bfc ,	0x01877f96 ,
	0x01877ff5 ,	0x01874e45 ,	0x0187323b ,	0x01872213 ,
	0x0187260d ,	0x01876b89 ,	0x0187030a ,	0x0187301c ,
	0x01870bdb ,	0x018756ae ,	0x01870732 ,	0x01870120 ,
	0x0187759a ,	0x01872350 ,	0x018722ee ,	0x01874b40 ,
	0x01875878 ,	0x01876b36 ,	0x01875cfd ,	0x01873e12 ,
	0x01871a49 ,	0x01875f32 ,	0x01873bf6 ,	0x01873a9e ,
	0x0187797d ,	0x01875f49 ,	0x01870ddc ,	0x01874cad ,
	0x0187314f ,	0x01875e14 ,	0x01874df2 ,	0x01874944 ,
	0x01872e40 ,	0x01871366 ,	0x01871cd0 ,	0x0187366b ,
	0x018766c4 ,	0x01874230 ,	0x01877eb7 ,	0x01876032 ,
	0x01872c3b ,	0x018715a1 ,	0x01875422 ,	0x01873ef6 ,
	0x01870822 ,	0x01875991 ,	0x0187409d ,    0x01871101 ,

	0x01887f9b ,	0x018818e5 ,	0x01887485 ,	0x0188781c ,
	0x01884328 ,	0x018854fb ,	0x01882948 ,	0x01882702 ,
	0x01883623 ,	0x01884744 ,	0x01881209 ,	0x01884a32 ,
	0x01885f7d ,	0x018810b5 ,	0x01886a73 ,	0x018812f6 ,
	0x01883e6b ,	0x01883a85 ,	0x01884277 ,	0x01880ecf ,
	0x01883274 ,	0x01884ded ,	0x01886404 ,	0x01880029 ,
	0x01884823 ,	0x018818be ,	0x01886784 ,	0x01884ae1 ,
	0x01883d6c ,	0x01882cd6 ,	0x018872ae ,	0x01886952 ,
	0x01885f90 ,	0x01881649 ,	0x01886df1 ,	0x01885af1 ,
	0x018841bb ,	0x018826e9 ,	0x018801eb ,	0x01880bb3 ,
	0x01882ea6 ,	0x018812db ,	0x0188153c ,	0x01887e87 ,
	0x0188390c ,	0x01880f3e ,	0x01880099 ,	0x01880124 ,
	0x0188305e ,	0x0188440d ,	0x0188491c ,	0x01884d06 ,
	0x01884db7 ,	0x01881547 ,	0x018854de ,	0x018839b3 ,
	0x01882d12 ,	0x0188074d ,	0x01884dc8 ,	0x01886443 ,
	0x018866bb ,	0x0188428b ,	0x018826a6 ,	0x0188701f ,
	0x01885d03 ,	0x01887a5a ,	0x0188767d ,	0x01884509 ,
	0x01881238 ,	0x01883b25 ,	0x01881e1f ,	0x01886e5d ,
	0x01881ad4 ,	0x018863cb ,	0x01886bfc ,	0x01887f96 ,
	0x01887ff5 ,	0x01884e45 ,	0x0188323b ,	0x01882213 ,
	0x0188260d ,	0x01886b89 ,	0x0188030a ,	0x0188301c ,
	0x01880bdb ,	0x018856ae ,	0x01880732 ,	0x01880120 ,
	0x0188759a ,	0x01882350 ,	0x018822ee ,	0x01884b40 ,
	0x01885878 ,	0x01886b36 ,	0x01885cfd ,	0x01883e12 ,
	0x01881a49 ,	0x01885f32 ,	0x01883bf6 ,	0x01883a9e ,
	0x0188797d ,	0x01885f49 ,	0x01880ddc ,	0x01884cad ,
	0x0188314f ,	0x01885e14 ,	0x01884df2 ,	0x01884944 ,
	0x01882e40 ,	0x01881366 ,	0x01881cd0 ,	0x0188366b ,
	0x018866c4 ,	0x01884230 ,	0x01887eb7 ,	0x01886032 ,
	0x01882c3b ,	0x018815a1 ,	0x01885422 ,	0x01883ef6 ,
	0x01880822 ,	0x01885991 ,	0x0188409d ,    0x01881101 ,

	0x01897f9b ,	0x018918e5 ,	0x01897485 ,	0x0189781c ,
	0x01894328 ,	0x018954fb ,	0x01892948 ,	0x01892702 ,
	0x01893623 ,	0x01894744 ,	0x01891209 ,	0x01894a32 ,
	0x01895f7d ,	0x018910b5 ,	0x01896a73 ,	0x018912f6 ,
	0x01893e6b ,	0x01893a85 ,	0x01894277 ,	0x01890ecf ,
	0x01893274 ,	0x01894ded ,	0x01896404 ,	0x01890029 ,
	0x01894823 ,	0x018918be ,	0x01896784 ,	0x01894ae1 ,
	0x01893d6c ,	0x01892cd6 ,	0x018972ae ,	0x01896952 ,
	0x01895f90 ,	0x01891649 ,	0x01896df1 ,	0x01895af1 ,
	0x018941bb ,	0x018926e9 ,	0x018901eb ,	0x01890bb3 ,
	0x01892ea6 ,	0x018912db ,	0x0189153c ,	0x01897e87 ,
	0x0189390c ,	0x01890f3e ,	0x01890099 ,	0x01890124 ,
	0x0189305e ,	0x0189440d ,	0x0189491c ,	0x01894d06 ,
	0x01894db7 ,	0x01891547 ,	0x018954de ,	0x018939b3 ,
	0x01892d12 ,	0x0189074d ,	0x01894dc8 ,	0x01896443 ,
	0x018966bb ,	0x0189428b ,	0x018926a6 ,	0x0189701f ,
	0x01895d03 ,	0x01897a5a ,	0x0189767d ,	0x01894509 ,
	0x01891238 ,	0x01893b25 ,	0x01891e1f ,	0x01896e5d ,
	0x01891ad4 ,	0x018963cb ,	0x01896bfc ,	0x01897f96 ,
	0x01897ff5 ,	0x01894e45 ,	0x0189323b ,	0x01892213 ,
	0x0189260d ,	0x01896b89 ,	0x0189030a ,	0x0189301c ,
	0x01890bdb ,	0x018956ae ,	0x01890732 ,	0x01890120 ,
	0x0189759a ,	0x01892350 ,	0x018922ee ,	0x01894b40 ,
	0x01895878 ,	0x01896b36 ,	0x01895cfd ,	0x01893e12 ,
	0x01891a49 ,	0x01895f32 ,	0x01893bf6 ,	0x01893a9e ,
	0x0189797d ,	0x01895f49 ,	0x01890ddc ,	0x01894cad ,
	0x0189314f ,	0x01895e14 ,	0x01894df2 ,	0x01894944 ,
	0x01892e40 ,	0x01891366 ,	0x01891cd0 ,	0x0189366b ,
	0x018966c4 ,	0x01894230 ,	0x01897eb7 ,	0x01896032 ,
	0x01892c3b ,	0x018915a1 ,	0x01895422 ,	0x01893ef6 ,
	0x01890822 ,	0x01895991 ,	0x0189409d ,    0x01891101 ,

	0x01907f9b ,	0x019018e5 ,	0x01907485 ,	0x0190781c ,
	0x01904328 ,	0x019054fb ,	0x01902948 ,	0x01902702 ,
	0x01903623 ,	0x01904744 ,	0x01901209 ,	0x01904a32 ,
	0x01905f7d ,	0x019010b5 ,	0x01906a73 ,	0x019012f6 ,
	0x01903e6b ,	0x01903a85 ,	0x01904277 ,	0x01900ecf ,
	0x01903274 ,	0x01904ded ,	0x01906404 ,	0x01900029 ,
	0x01904823 ,	0x019018be ,	0x01906784 ,	0x01904ae1 ,
	0x01903d6c ,	0x01902cd6 ,	0x019072ae ,	0x01906952 ,
	0x01905f90 ,	0x01901649 ,	0x01906df1 ,	0x01905af1 ,
	0x019041bb ,	0x019026e9 ,	0x019001eb ,	0x01900bb3 ,
	0x01902ea6 ,	0x019012db ,	0x0190153c ,	0x01907e87 ,
	0x0190390c ,	0x01900f3e ,	0x01900099 ,	0x01900124 ,
	0x0190305e ,	0x0190440d ,	0x0190491c ,	0x01904d06 ,
	0x01904db7 ,	0x01901547 ,	0x019054de ,	0x019039b3 ,
	0x01902d12 ,	0x0190074d ,	0x01904dc8 ,	0x01906443 ,
	0x019066bb ,	0x0190428b ,	0x019026a6 ,	0x0190701f ,
	0x01905d03 ,	0x01907a5a ,	0x0190767d ,	0x01904509 ,
	0x01901238 ,	0x01903b25 ,	0x01901e1f ,	0x01906e5d ,
	0x01901ad4 ,	0x019063cb ,	0x01906bfc ,	0x01907f96 ,
	0x01907ff5 ,	0x01904e45 ,	0x0190323b ,	0x01902213 ,
	0x0190260d ,	0x01906b89 ,	0x0190030a ,	0x0190301c ,
	0x01900bdb ,	0x019056ae ,	0x01900732 ,	0x01900120 ,
	0x0190759a ,	0x01902350 ,	0x019022ee ,	0x01904b40 ,
	0x01905878 ,	0x01906b36 ,	0x01905cfd ,	0x01903e12 ,
	0x01901a49 ,	0x01905f32 ,	0x01903bf6 ,	0x01903a9e ,
	0x0190797d ,	0x01905f49 ,	0x01900ddc ,	0x01904cad ,
	0x0190314f ,	0x01905e14 ,	0x01904df2 ,	0x01904944 ,
	0x01902e40 ,	0x01901366 ,	0x01901cd0 ,	0x0190366b ,
	0x019066c4 ,	0x01904230 ,	0x01907eb7 ,	0x01906032 ,
	0x01902c3b ,	0x019015a1 ,	0x01905422 ,	0x01903ef6 ,
	0x01900822 ,	0x01905991 ,	0x0190409d ,    0x01901101 ,

	0x01917f9b ,	0x019118e5 ,	0x01917485 ,	0x0191781c ,
	0x01914328 ,	0x019154fb ,	0x01912948 ,	0x01912702 ,
	0x01913623 ,	0x01914744 ,	0x01911209 ,	0x01914a32 ,
	0x01915f7d ,	0x019110b5 ,	0x01916a73 ,	0x019112f6 ,
	0x01913e6b ,	0x01913a85 ,	0x01914277 ,	0x01910ecf ,
	0x01913274 ,	0x01914ded ,	0x01916404 ,	0x01910029 ,
	0x01914823 ,	0x019118be ,	0x01916784 ,	0x01914ae1 ,
	0x01913d6c ,	0x01912cd6 ,	0x019172ae ,	0x01916952 ,
	0x01915f90 ,	0x01911649 ,	0x01916df1 ,	0x01915af1 ,
	0x019141bb ,	0x019126e9 ,	0x019101eb ,	0x01910bb3 ,
	0x01912ea6 ,	0x019112db ,	0x0191153c ,	0x01917e87 ,
	0x0191390c ,	0x01910f3e ,	0x01910099 ,	0x01910124 ,
	0x0191305e ,	0x0191440d ,	0x0191491c ,	0x01914d06 ,
	0x01914db7 ,	0x01911547 ,	0x019154de ,	0x019139b3 ,
	0x01912d12 ,	0x0191074d ,	0x01914dc8 ,	0x01916443 ,
	0x019166bb ,	0x0191428b ,	0x019126a6 ,	0x0191701f ,
	0x01915d03 ,	0x01917a5a ,	0x0191767d ,	0x01914509 ,
	0x01911238 ,	0x01913b25 ,	0x01911e1f ,	0x01916e5d ,
	0x01911ad4 ,	0x019163cb ,	0x01916bfc ,	0x01917f96 ,
	0x01917ff5 ,	0x01914e45 ,	0x0191323b ,	0x01912213 ,
	0x0191260d ,	0x01916b89 ,	0x0191030a ,	0x0191301c ,
	0x01910bdb ,	0x019156ae ,	0x01910732 ,	0x01910120 ,
	0x0191759a ,	0x01912350 ,	0x019122ee ,	0x01914b40 ,
	0x01915878 ,	0x01916b36 ,	0x01915cfd ,	0x01913e12 ,
	0x01911a49 ,	0x01915f32 ,	0x01913bf6 ,	0x01913a9e ,
	0x0191797d ,	0x01915f49 ,	0x01910ddc ,	0x01914cad ,
	0x0191314f ,	0x01915e14 ,	0x01914df2 ,	0x01914944 ,
	0x01912e40 ,	0x01911366 ,	0x01911cd0 ,	0x0191366b ,
	0x019166c4 ,	0x01914230 ,	0x01917eb7 ,	0x01916032 ,
	0x01912c3b ,	0x019115a1 ,	0x01915422 ,	0x01913ef6 ,
	0x01910822 ,	0x01915991 ,	0x0191409d ,    0x01911101 ,

	0x01927f9b ,	0x019218e5 ,	0x01927485 ,	0x0192781c ,
	0x01924328 ,	0x019254fb ,	0x01922948 ,	0x01922702 ,
	0x01923623 ,	0x01924744 ,	0x01921209 ,	0x01924a32 ,
	0x01925f7d ,	0x019210b5 ,	0x01926a73 ,	0x019212f6 ,
	0x01923e6b ,	0x01923a85 ,	0x01924277 ,	0x01920ecf ,
	0x01923274 ,	0x01924ded ,	0x01926404 ,	0x01920029 ,
	0x01924823 ,	0x019218be ,	0x01926784 ,	0x01924ae1 ,
	0x01923d6c ,	0x01922cd6 ,	0x019272ae ,	0x01926952 ,
	0x01925f90 ,	0x01921649 ,	0x01926df1 ,	0x01925af1 ,
	0x019241bb ,	0x019226e9 ,	0x019201eb ,	0x01920bb3 ,
	0x01922ea6 ,	0x019212db ,	0x0192153c ,	0x01927e87 ,
	0x0192390c ,	0x01920f3e ,	0x01920099 ,	0x01920124 ,
	0x0192305e ,	0x0192440d ,	0x0192491c ,	0x01924d06 ,
	0x01924db7 ,	0x01921547 ,	0x019254de ,	0x019239b3 ,
	0x01922d12 ,	0x0192074d ,	0x01924dc8 ,	0x01926443 ,
	0x019266bb ,	0x0192428b ,	0x019226a6 ,	0x0192701f ,
	0x01925d03 ,	0x01927a5a ,	0x0192767d ,	0x01924509 ,
	0x01921238 ,	0x01923b25 ,	0x01921e1f ,	0x01926e5d ,
	0x01921ad4 ,	0x019263cb ,	0x01926bfc ,	0x01927f96 ,
	0x01927ff5 ,	0x01924e45 ,	0x0192323b ,	0x01922213 ,
	0x0192260d ,	0x01926b89 ,	0x0192030a ,	0x0192301c ,
	0x01920bdb ,	0x019256ae ,	0x01920732 ,	0x01920120 ,
	0x0192759a ,	0x01922350 ,	0x019222ee ,	0x01924b40 ,
	0x01925878 ,	0x01926b36 ,	0x01925cfd ,	0x01923e12 ,
	0x01921a49 ,	0x01925f32 ,	0x01923bf6 ,	0x01923a9e ,
	0x0192797d ,	0x01925f49 ,	0x01920ddc ,	0x01924cad ,
	0x0192314f ,	0x01925e14 ,	0x01924df2 ,	0x01924944 ,
	0x01922e40 ,	0x01921366 ,	0x01921cd0 ,	0x0192366b ,
	0x019266c4 ,	0x01924230 ,	0x01927eb7 ,	0x01926032 ,
	0x01922c3b ,	0x019215a1 ,	0x01925422 ,	0x01923ef6 ,
	0x01920822 ,	0x01925991 ,	0x0192409d ,    0x01921101 ,

	0x01937f9b ,	0x019318e5 ,	0x01937485 ,	0x0193781c ,
	0x01934328 ,	0x019354fb ,	0x01932948 ,	0x01932702 ,
	0x01933623 ,	0x01934744 ,	0x01931209 ,	0x01934a32 ,
	0x01935f7d ,	0x019310b5 ,	0x01936a73 ,	0x019312f6 ,
	0x01933e6b ,	0x01933a85 ,	0x01934277 ,	0x01930ecf ,
	0x01933274 ,	0x01934ded ,	0x01936404 ,	0x01930029 ,
	0x01934823 ,	0x019318be ,	0x01936784 ,	0x01934ae1 ,
	0x01933d6c ,	0x01932cd6 ,	0x019372ae ,	0x01936952 ,
	0x01935f90 ,	0x01931649 ,	0x01936df1 ,	0x01935af1 ,
	0x019341bb ,	0x019326e9 ,	0x019301eb ,	0x01930bb3 ,
	0x01932ea6 ,	0x019312db ,	0x0193153c ,	0x01937e87 ,
	0x0193390c ,	0x01930f3e ,	0x01930099 ,	0x01930124 ,
	0x0193305e ,	0x0193440d ,	0x0193491c ,	0x01934d06 ,
	0x01934db7 ,	0x01931547 ,	0x019354de ,	0x019339b3 ,
	0x01932d12 ,	0x0193074d ,	0x01934dc8 ,	0x01936443 ,
	0x019366bb ,	0x0193428b ,	0x019326a6 ,	0x0193701f ,
	0x01935d03 ,	0x01937a5a ,	0x0193767d ,	0x01934509 ,
	0x01931238 ,	0x01933b25 ,	0x01931e1f ,	0x01936e5d ,
	0x01931ad4 ,	0x019363cb ,	0x01936bfc ,	0x01937f96 ,
	0x01937ff5 ,	0x01934e45 ,	0x0193323b ,	0x01932213 ,
	0x0193260d ,	0x01936b89 ,	0x0193030a ,	0x0193301c ,
	0x01930bdb ,	0x019356ae ,	0x01930732 ,	0x01930120 ,
	0x0193759a ,	0x01932350 ,	0x019322ee ,	0x01934b40 ,
	0x01935878 ,	0x01936b36 ,	0x01935cfd ,	0x01933e12 ,
	0x01931a49 ,	0x01935f32 ,	0x01933bf6 ,	0x01933a9e ,
	0x0193797d ,	0x01935f49 ,	0x01930ddc ,	0x01934cad ,
	0x0193314f ,	0x01935e14 ,	0x01934df2 ,	0x01934944 ,
	0x01932e40 ,	0x01931366 ,	0x01931cd0 ,	0x0193366b ,
	0x019366c4 ,	0x01934230 ,	0x01937eb7 ,	0x01936032 ,
	0x01932c3b ,	0x019315a1 ,	0x01935422 ,	0x01933ef6 ,
	0x01930822 ,	0x01935991 ,	0x0193409d ,    0x01931101 ,

	0x01947f9b ,	0x019418e5 ,	0x01947485 ,	0x0194781c ,
	0x01944328 ,	0x019454fb ,	0x01942948 ,	0x01942702 ,
	0x01943623 ,	0x01944744 ,	0x01941209 ,	0x01944a32 ,
	0x01945f7d ,	0x019410b5 ,	0x01946a73 ,	0x019412f6 ,
	0x01943e6b ,	0x01943a85 ,	0x01944277 ,	0x01940ecf ,
	0x01943274 ,	0x01944ded ,	0x01946404 ,	0x01940029 ,
	0x01944823 ,	0x019418be ,	0x01946784 ,	0x01944ae1 ,
	0x01943d6c ,	0x01942cd6 ,	0x019472ae ,	0x01946952 ,
	0x01945f90 ,	0x01941649 ,	0x01946df1 ,	0x01945af1 ,
	0x019441bb ,	0x019426e9 ,	0x019401eb ,	0x01940bb3 ,
	0x01942ea6 ,	0x019412db ,	0x0194153c ,	0x01947e87 ,
	0x0194390c ,	0x01940f3e ,	0x01940099 ,	0x01940124 ,
	0x0194305e ,	0x0194440d ,	0x0194491c ,	0x01944d06 ,
	0x01944db7 ,	0x01941547 ,	0x019454de ,	0x019439b3 ,
	0x01942d12 ,	0x0194074d ,	0x01944dc8 ,	0x01946443 ,
	0x019466bb ,	0x0194428b ,	0x019426a6 ,	0x0194701f ,
	0x01945d03 ,	0x01947a5a ,	0x0194767d ,	0x01944509 ,
	0x01941238 ,	0x01943b25 ,	0x01941e1f ,	0x01946e5d ,
	0x01941ad4 ,	0x019463cb ,	0x01946bfc ,	0x01947f96 ,
	0x01947ff5 ,	0x01944e45 ,	0x0194323b ,	0x01942213 ,
	0x0194260d ,	0x01946b89 ,	0x0194030a ,	0x0194301c ,
	0x01940bdb ,	0x019456ae ,	0x01940732 ,	0x01940120 ,
	0x0194759a ,	0x01942350 ,	0x019422ee ,	0x01944b40 ,
	0x01945878 ,	0x01946b36 ,	0x01945cfd ,	0x01943e12 ,
	0x01941a49 ,	0x01945f32 ,	0x01943bf6 ,	0x01943a9e ,
	0x0194797d ,	0x01945f49 ,	0x01940ddc ,	0x01944cad ,
	0x0194314f ,	0x01945e14 ,	0x01944df2 ,	0x01944944 ,
	0x01942e40 ,	0x01941366 ,	0x01941cd0 ,	0x0194366b ,
	0x019466c4 ,	0x01944230 ,	0x01947eb7 ,	0x01946032 ,
	0x01942c3b ,	0x019415a1 ,	0x01945422 ,	0x01943ef6 ,
	0x01940822 ,	0x01945991 ,	0x0194409d ,    0x01941101 ,

	0x01957f9b ,	0x019518e5 ,	0x01957485 ,	0x0195781c ,
	0x01954328 ,	0x019554fb ,	0x01952948 ,	0x01952702 ,
	0x01953623 ,	0x01954744 ,	0x01951209 ,	0x01954a32 ,
	0x01955f7d ,	0x019510b5 ,	0x01956a73 ,	0x019512f6 ,
	0x01953e6b ,	0x01953a85 ,	0x01954277 ,	0x01950ecf ,
	0x01953274 ,	0x01954ded ,	0x01956404 ,	0x01950029 ,
	0x01954823 ,	0x019518be ,	0x01956784 ,	0x01954ae1 ,
	0x01953d6c ,	0x01952cd6 ,	0x019572ae ,	0x01956952 ,
	0x01955f90 ,	0x01951649 ,	0x01956df1 ,	0x01955af1 ,
	0x019541bb ,	0x019526e9 ,	0x019501eb ,	0x01950bb3 ,
	0x01952ea6 ,	0x019512db ,	0x0195153c ,	0x01957e87 ,
	0x0195390c ,	0x01950f3e ,	0x01950099 ,	0x01950124 ,
	0x0195305e ,	0x0195440d ,	0x0195491c ,	0x01954d06 ,
	0x01954db7 ,	0x01951547 ,	0x019554de ,	0x019539b3 ,
	0x01952d12 ,	0x0195074d ,	0x01954dc8 ,	0x01956443 ,
	0x019566bb ,	0x0195428b ,	0x019526a6 ,	0x0195701f ,
	0x01955d03 ,	0x01957a5a ,	0x0195767d ,	0x01954509 ,
	0x01951238 ,	0x01953b25 ,	0x01951e1f ,	0x01956e5d ,
	0x01951ad4 ,	0x019563cb ,	0x01956bfc ,	0x01957f96 ,
	0x01957ff5 ,	0x01954e45 ,	0x0195323b ,	0x01952213 ,
	0x0195260d ,	0x01956b89 ,	0x0195030a ,	0x0195301c ,
	0x01950bdb ,	0x019556ae ,	0x01950732 ,	0x01950120 ,
	0x0195759a ,	0x01952350 ,	0x019522ee ,	0x01954b40 ,
	0x01955878 ,	0x01956b36 ,	0x01955cfd ,	0x01953e12 ,
	0x01951a49 ,	0x01955f32 ,	0x01953bf6 ,	0x01953a9e ,
	0x0195797d ,	0x01955f49 ,	0x01950ddc ,	0x01954cad ,
	0x0195314f ,	0x01955e14 ,	0x01954df2 ,	0x01954944 ,
	0x01952e40 ,	0x01951366 ,	0x01951cd0 ,	0x0195366b ,
	0x019566c4 ,	0x01954230 ,	0x01957eb7 ,	0x01956032 ,
	0x01952c3b ,	0x019515a1 ,	0x01955422 ,	0x01953ef6 ,
	0x01950822 ,	0x01955991 ,	0x0195409d ,    0x01951101 ,

	0x01967f9b ,	0x019618e5 ,	0x01967485 ,	0x0196781c ,
	0x01964328 ,	0x019654fb ,	0x01962948 ,	0x01962702 ,
	0x01963623 ,	0x01964744 ,	0x01961209 ,	0x01964a32 ,
	0x01965f7d ,	0x019610b5 ,	0x01966a73 ,	0x019612f6 ,
	0x01963e6b ,	0x01963a85 ,	0x01964277 ,	0x01960ecf ,
	0x01963274 ,	0x01964ded ,	0x01966404 ,	0x01960029 ,
	0x01964823 ,	0x019618be ,	0x01966784 ,	0x01964ae1 ,
	0x01963d6c ,	0x01962cd6 ,	0x019672ae ,	0x01966952 ,
	0x01965f90 ,	0x01961649 ,	0x01966df1 ,	0x01965af1 ,
	0x019641bb ,	0x019626e9 ,	0x019601eb ,	0x01960bb3 ,
	0x01962ea6 ,	0x019612db ,	0x0196153c ,	0x01967e87 ,
	0x0196390c ,	0x01960f3e ,	0x01960099 ,	0x01960124 ,
	0x0196305e ,	0x0196440d ,	0x0196491c ,	0x01964d06 ,
	0x01964db7 ,	0x01961547 ,	0x019654de ,	0x019639b3 ,
	0x01962d12 ,	0x0196074d ,	0x01964dc8 ,	0x01966443 ,
	0x019666bb ,	0x0196428b ,	0x019626a6 ,	0x0196701f ,
	0x01965d03 ,	0x01967a5a ,	0x0196767d ,	0x01964509 ,
	0x01961238 ,	0x01963b25 ,	0x01961e1f ,	0x01966e5d ,
	0x01961ad4 ,	0x019663cb ,	0x01966bfc ,	0x01967f96 ,
	0x01967ff5 ,	0x01964e45 ,	0x0196323b ,	0x01962213 ,
	0x0196260d ,	0x01966b89 ,	0x0196030a ,	0x0196301c ,
	0x01960bdb ,	0x019656ae ,	0x01960732 ,	0x01960120 ,
	0x0196759a ,	0x01962350 ,	0x019622ee ,	0x01964b40 ,
	0x01965878 ,	0x01966b36 ,	0x01965cfd ,	0x01963e12 ,
	0x01961a49 ,	0x01965f32 ,	0x01963bf6 ,	0x01963a9e ,
	0x0196797d ,	0x01965f49 ,	0x01960ddc ,	0x01964cad ,
	0x0196314f ,	0x01965e14 ,	0x01964df2 ,	0x01964944 ,
	0x01962e40 ,	0x01961366 ,	0x01961cd0 ,	0x0196366b ,
	0x019666c4 ,	0x01964230 ,	0x01967eb7 ,	0x01966032 ,
	0x01962c3b ,	0x019615a1 ,	0x01965422 ,	0x01963ef6 ,
	0x01960822 ,	0x01965991 ,	0x0196409d ,    0x01961101 ,

	0x01977f9b ,	0x019718e5 ,	0x01977485 ,	0x0197781c ,
	0x01974328 ,	0x019754fb ,	0x01972948 ,	0x01972702 ,
	0x01973623 ,	0x01974744 ,	0x01971209 ,	0x01974a32 ,
	0x01975f7d ,	0x019710b5 ,	0x01976a73 ,	0x019712f6 ,
	0x01973e6b ,	0x01973a85 ,	0x01974277 ,	0x01970ecf ,
	0x01973274 ,	0x01974ded ,	0x01976404 ,	0x01970029 ,
	0x01974823 ,	0x019718be ,	0x01976784 ,	0x01974ae1 ,
	0x01973d6c ,	0x01972cd6 ,	0x019772ae ,	0x01976952 ,
	0x01975f90 ,	0x01971649 ,	0x01976df1 ,	0x01975af1 ,
	0x019741bb ,	0x019726e9 ,	0x019701eb ,	0x01970bb3 ,
	0x01972ea6 ,	0x019712db ,	0x0197153c ,	0x01977e87 ,
	0x0197390c ,	0x01970f3e ,	0x01970099 ,	0x01970124 ,
	0x0197305e ,	0x0197440d ,	0x0197491c ,	0x01974d06 ,
	0x01974db7 ,	0x01971547 ,	0x019754de ,	0x019739b3 ,
	0x01972d12 ,	0x0197074d ,	0x01974dc8 ,	0x01976443 ,
	0x019766bb ,	0x0197428b ,	0x019726a6 ,	0x0197701f ,
	0x01975d03 ,	0x01977a5a ,	0x0197767d ,	0x01974509 ,
	0x01971238 ,	0x01973b25 ,	0x01971e1f ,	0x01976e5d ,
	0x01971ad4 ,	0x019763cb ,	0x01976bfc ,	0x01977f96 ,
	0x01977ff5 ,	0x01974e45 ,	0x0197323b ,	0x01972213 ,
	0x0197260d ,	0x01976b89 ,	0x0197030a ,	0x0197301c ,
	0x01970bdb ,	0x019756ae ,	0x01970732 ,	0x01970120 ,
	0x0197759a ,	0x01972350 ,	0x019722ee ,	0x01974b40 ,
	0x01975878 ,	0x01976b36 ,	0x01975cfd ,	0x01973e12 ,
	0x01971a49 ,	0x01975f32 ,	0x01973bf6 ,	0x01973a9e ,
	0x0197797d ,	0x01975f49 ,	0x01970ddc ,	0x01974cad ,
	0x0197314f ,	0x01975e14 ,	0x01974df2 ,	0x01974944 ,
	0x01972e40 ,	0x01971366 ,	0x01971cd0 ,	0x0197366b ,
	0x019766c4 ,	0x01974230 ,	0x01977eb7 ,	0x01976032 ,
	0x01972c3b ,	0x019715a1 ,	0x01975422 ,	0x01973ef6 ,
	0x01970822 ,	0x01975991 ,	0x0197409d ,    0x01971101 ,

	0x01987f9b ,	0x019818e5 ,	0x01987485 ,	0x0198781c ,
	0x01984328 ,	0x019854fb ,	0x01982948 ,	0x01982702 ,
	0x01983623 ,	0x01984744 ,	0x01981209 ,	0x01984a32 ,
	0x01985f7d ,	0x019810b5 ,	0x01986a73 ,	0x019812f6 ,
	0x01983e6b ,	0x01983a85 ,	0x01984277 ,	0x01980ecf ,
	0x01983274 ,	0x01984ded ,	0x01986404 ,	0x01980029 ,
	0x01984823 ,	0x019818be ,	0x01986784 ,	0x01984ae1 ,
	0x01983d6c ,	0x01982cd6 ,	0x019872ae ,	0x01986952 ,
	0x01985f90 ,	0x01981649 ,	0x01986df1 ,	0x01985af1 ,
	0x019841bb ,	0x019826e9 ,	0x019801eb ,	0x01980bb3 ,
	0x01982ea6 ,	0x019812db ,	0x0198153c ,	0x01987e87 ,
	0x0198390c ,	0x01980f3e ,	0x01980099 ,	0x01980124 ,
	0x0198305e ,	0x0198440d ,	0x0198491c ,	0x01984d06 ,
	0x01984db7 ,	0x01981547 ,	0x019854de ,	0x019839b3 ,
	0x01982d12 ,	0x0198074d ,	0x01984dc8 ,	0x01986443 ,
	0x019866bb ,	0x0198428b ,	0x019826a6 ,	0x0198701f ,
	0x01985d03 ,	0x01987a5a ,	0x0198767d ,	0x01984509 ,
	0x01981238 ,	0x01983b25 ,	0x01981e1f ,	0x01986e5d ,
	0x01981ad4 ,	0x019863cb ,	0x01986bfc ,	0x01987f96 ,
	0x01987ff5 ,	0x01984e45 ,	0x0198323b ,	0x01982213 ,
	0x0198260d ,	0x01986b89 ,	0x0198030a ,	0x0198301c ,
	0x01980bdb ,	0x019856ae ,	0x01980732 ,	0x01980120 ,
	0x0198759a ,	0x01982350 ,	0x019822ee ,	0x01984b40 ,
	0x01985878 ,	0x01986b36 ,	0x01985cfd ,	0x01983e12 ,
	0x01981a49 ,	0x01985f32 ,	0x01983bf6 ,	0x01983a9e ,
	0x0198797d ,	0x01985f49 ,	0x01980ddc ,	0x01984cad ,
	0x0198314f ,	0x01985e14 ,	0x01984df2 ,	0x01984944 ,
	0x01982e40 ,	0x01981366 ,	0x01981cd0 ,	0x0198366b ,
	0x019866c4 ,	0x01984230 ,	0x01987eb7 ,	0x01986032 ,
	0x01982c3b ,	0x019815a1 ,	0x01985422 ,	0x01983ef6 ,
	0x01980822 ,	0x01985991 ,	0x0198409d ,    0x01981101 ,

	0x01997f9b ,	0x019918e5 ,	0x01997485 ,	0x0199781c ,
	0x01994328 ,	0x019954fb ,	0x01992948 ,	0x01992702 ,
	0x01993623 ,	0x01994744 ,	0x01991209 ,	0x01994a32 ,
	0x01995f7d ,	0x019910b5 ,	0x01996a73 ,	0x019912f6 ,
	0x01993e6b ,	0x01993a85 ,	0x01994277 ,	0x01990ecf ,
	0x01993274 ,	0x01994ded ,	0x01996404 ,	0x01990029 ,
	0x01994823 ,	0x019918be ,	0x01996784 ,	0x01994ae1 ,
	0x01993d6c ,	0x01992cd6 ,	0x019972ae ,	0x01996952 ,
	0x01995f90 ,	0x01991649 ,	0x01996df1 ,	0x01995af1 ,
	0x019941bb ,	0x019926e9 ,	0x019901eb ,	0x01990bb3 ,
	0x01992ea6 ,	0x019912db ,	0x0199153c ,	0x01997e87 ,
	0x0199390c ,	0x01990f3e ,	0x01990099 ,	0x01990124 ,
	0x0199305e ,	0x0199440d ,	0x0199491c ,	0x01994d06 ,
	0x01994db7 ,	0x01991547 ,	0x019954de ,	0x019939b3 ,
	0x01992d12 ,	0x0199074d ,	0x01994dc8 ,	0x01996443 ,
	0x019966bb ,	0x0199428b ,	0x019926a6 ,	0x0199701f ,
	0x01995d03 ,	0x01997a5a ,	0x0199767d ,	0x01994509 ,
	0x01991238 ,	0x01993b25 ,	0x01991e1f ,	0x01996e5d ,
	0x01991ad4 ,	0x019963cb ,	0x01996bfc ,	0x01997f96 ,
	0x01997ff5 ,	0x01994e45 ,	0x0199323b ,	0x01992213 ,
	0x0199260d ,	0x01996b89 ,	0x0199030a ,	0x0199301c ,
	0x01990bdb ,	0x019956ae ,	0x01990732 ,	0x01990120 ,
	0x0199759a ,	0x01992350 ,	0x019922ee ,	0x01994b40 ,
	0x01995878 ,	0x01996b36 ,	0x01995cfd ,	0x01993e12 ,
	0x01991a49 ,	0x01995f32 ,	0x01993bf6 ,	0x01993a9e ,
	0x0199797d ,	0x01995f49 ,	0x01990ddc ,	0x01994cad ,
	0x0199314f ,	0x01995e14 ,	0x01994df2 ,	0x01994944 ,
	0x01992e40 ,	0x01991366 ,	0x01991cd0 ,	0x0199366b ,
	0x019966c4 ,	0x01994230 ,	0x01997eb7 ,	0x01996032 ,
	0x01992c3b ,	0x019915a1 ,	0x01995422 ,	0x01993ef6 ,
	0x01990822 ,	0x01995991 ,	0x0199409d ,    0x01991101

} ;

void Leak ( WmiAllocator &a_Allocator )
{
	for ( ULONG t_OuterIndex = 0 ; t_OuterIndex < 10 ; t_OuterIndex ++ ) 
	{
		for ( ULONG t_Index = 0 ; t_Index < 8 ; t_Index ++ )
		{
			void *t_Memory ;
			WmiStatusCode t_StatusCode = a_Allocator.New (

				( void ** ) & t_Memory ,
				1 << t_Index
			) ;
		}
	}

}


void Test_BasicTree ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 24 ) ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiBasicTree <UINT64,UINT64> t_Tree ( t_Allocator ) ;
		WmiBasicTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode != e_StatusCode_Success ) 
				{
					printf ( "\n Insert Error"  ) ;
				}

			}

			t_Index = 0 ;
			t_Iterator = t_Tree.End () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Decrement () ;
				t_Index ++ ;
			}

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			t_Iterator = t_Tree.Begin () ;
			t_Iterator.Decrement () ;

			t_Iterator = t_Tree.End () ;
			t_Iterator.Increment () ;

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}
		}
	}		
}

void Test_AvlTree ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 30 ) ;

	//WmiAllocator t_Allocator ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiAvlTree <UINT64,UINT64> t_Tree ( t_Allocator ) ;
		WmiAvlTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					Leak ( t_Allocator ) ;
				}
				else
				{
					printf ( "\nInsert Error"  ) ;
				}
			}

#if	0
			ULONG t_MaxHeight ;
			t_StatusCode = t_Tree.Check ( t_MaxHeight ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				printf ( "\nError"  ) ;
			}
#endif

			t_Index = 0 ;
			t_Iterator = t_Tree.End () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Decrement () ;
				t_Index ++ ;
			}

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			t_Iterator = t_Tree.Begin () ;
			t_Iterator.Decrement () ;

			t_Iterator = t_Tree.End () ;
			t_Iterator.Increment () ;

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}
		}
	}		
}

void Test_ThreadedAvlTree ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 30 ) ;

	//WmiAllocator t_Allocator ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiThreadedAvlTree <UINT64,UINT64> t_Tree ( t_Allocator ) ;
		WmiThreadedAvlTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					Leak ( t_Allocator ) ;
				}
				else
				{
					printf ( "\nInsert Error"  ) ;
				}
			}

#if	0
			ULONG t_MaxHeight ;
			t_StatusCode = t_Tree.Check ( t_MaxHeight ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				printf ( "\nError"  ) ;
			}
#endif

			t_Index = 0 ;
			t_Iterator = t_Tree.End () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Decrement () ;
				t_Index ++ ;
			}

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			t_Iterator = t_Tree.Begin () ;
			t_Iterator.Decrement () ;

			t_Iterator = t_Tree.End () ;
			t_Iterator.Increment () ;

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}
		}
	}		
}

LONG ULONG_ComparisonFunction ( void *a_ComparatorOperand , const WmiBPKey &a_Key1 , const WmiBPKey &a_Key2 )
{
	ULONG *t_Key1 = ( ULONG * ) ( a_Key1.GetConstData () ) ;
	ULONG *t_Key2 = ( ULONG * ) ( a_Key2.GetConstData () ) ;

	return *t_Key1 - *t_Key2 ;
}

void Test_BpTree ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 24 ) ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		ULONG t_BlockSize = 128 ;

		WmiMemoryBlockInterface t_BlockAllocator ( t_BlockSize ) ;

		t_StatusCode = t_BlockAllocator.Initialize () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			GUID t_Identifier ;
			CoCreateGuid ( & t_Identifier ) ;

			ULONG t_KeyType = 0 ;
			ULONG t_KeyTypeLength = sizeof ( UINT64 ) ;

			WmiBPlusTree t_Tree ( 

				t_Allocator ,
				t_BlockAllocator ,
				t_Identifier ,
				t_BlockSize ,
				t_KeyType ,
				t_KeyTypeLength ,
				ULONG_ComparisonFunction ,
				NULL 
			) ;

			t_StatusCode = t_Tree.Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

				for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
				{
					UINT64 t_Value = g_Array [ t_Index ] ;

					WmiBPKey t_Key ( ( BYTE * ) & t_Value , sizeof ( t_Value ) ) ;

					WmiBPElement t_ElementOffSet = 0xFFFFFFFF00000000 + t_Index ;

					t_StatusCode = t_Tree.Insert ( t_Key , t_ElementOffSet ) ;
					if ( t_StatusCode != e_StatusCode_Success ) 
					{
						printf ( "\nError"  ) ;
					}

				}

				UINT64 t_IteratorValue = 0 ;
				WmiBPKey t_IteratorKey ( ( BYTE * ) & t_IteratorValue , sizeof ( t_IteratorValue ) ) ;
				WmiBPElement t_IteratorElement = 0 ;

				WmiBPlusTree :: Iterator t_Iterator ( & t_Tree , t_IteratorKey , t_IteratorElement ) ;

				t_Index = 0 ;
				t_Iterator.End () ;
				while ( ! t_Iterator.Null () )	
				{
					t_Iterator.Decrement () ;
					t_Index ++ ;
				}

				t_Index = 0 ;
				t_Iterator.Begin () ;
				while ( ! t_Iterator.Null () )	
				{
					t_Iterator.Increment () ;
					t_Index ++ ;
				}

				t_Iterator.Begin () ;
				t_Iterator.Decrement () ;

				t_Iterator.End () ;
				t_Iterator.Increment () ;

				for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
				{
					UINT64 t_Value = g_Array [ t_Index ] ;

					WmiBPKey t_Key ( ( BYTE * ) & t_Value , sizeof ( t_Value ) ) ;

					t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
					}
					else
					{
						printf ( "\nFailure"  ) ;	
					}
				}

				for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
				{
					UINT64 t_Value = g_Array [ t_Size - t_Index - 1 ] ;

					WmiBPKey t_Key ( ( BYTE * ) & t_Value , sizeof ( t_Value ) ) ;

					WmiBPElement t_ElementOffSet = 0 ;

					t_StatusCode = t_Tree.Delete ( t_Key , t_ElementOffSet ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
					}
					else
					{
						printf ( "\nFailure"  ) ;	
					}
				}
			}
		}
	}		
}

void Test_ChunkArray ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

//	WmiAllocator t_Allocator ;
	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 30 ) ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiKeyedArray <UINT64,UINT64,100> t_Array ( t_Allocator ) ;
		WmiKeyedArray <UINT64,UINT64,100> :: Iterator t_Iterator ;

		t_StatusCode = t_Array.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Array.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					Leak ( t_Allocator ) ;
				//	printf ( "\n%lx" , t_Iterator.GetKey () ) ;
				}
				else
				{
					printf ( "\n Chunk Insert Error,%lx" , t_StatusCode ) ;
				}

			}

			t_Index = 0 ;
			t_Iterator = t_Array.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
//				printf ( "\n%lx" , t_Iterator.GetKey () ) ;
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			t_Index = 0 ;
			t_Iterator = t_Array.End () ;
			while ( ! t_Iterator.Null () )	
			{
//				printf ( "\n%lx" , t_Iterator.GetKey () ) ;
				t_Iterator.Decrement () ;
				t_Index ++ ;
			}

			t_Iterator = t_Array.Begin () ;
			t_Iterator.Decrement () ;

			t_Iterator = t_Array.End () ;
			t_Iterator.Increment () ;

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Index ] ;

				t_StatusCode = t_Array.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = g_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Array.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}
		}
	}		
}

void Test_Map ()
{
	std :: map <UINT64,UINT64> t_Tree ;
	std :: map <UINT64,UINT64> :: iterator t_Iterator ;

	UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

	for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Index ] ;
		UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

		try
		{
			t_Tree [ t_Key ] = t_Value ;
		}
		catch ( ... )
		{
			printf ( "\nError"  ) ;
		}
	}

	t_Index = 0 ;
	t_Iterator = t_Tree.end () ;
	t_Iterator -- ;
	while ( t_Iterator != t_Tree.end () )	
	{
		t_Iterator -- ;
		t_Index ++ ;
	}

	t_Index = 0 ;
	t_Iterator = t_Tree.begin () ;
	while ( t_Iterator != t_Tree.end ()  )	
	{
		t_Iterator ++ ;
		t_Index ++ ;
	}

	t_Iterator = t_Tree.begin () ;
	t_Iterator --  ;

	t_Iterator = t_Tree.end () ;
	t_Iterator ++ ;

	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Index ] ;

		t_Iterator = t_Tree.find ( t_Key ) ;
		if ( t_Iterator != t_Tree.end () ) 
		{
			UINT64 t_Value = t_Iterator->second ;
		}
		else
		{
			printf ( "\nSTL Failure"  ) ;	
		}
	}

	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Size - t_Index - 1 ] ;

		t_Tree.erase ( t_Key ) ;
	}
}

void Test_BasicTree1 ()
{
	Test_BasicTree () ;
}

void Test_BasicTree2 ()
{
	Test_BasicTree () ;
}

void Test_AvlTree1 ()
{
	Test_AvlTree () ;
}

void Test_AvlTree2 ()
{
	Test_AvlTree () ;
}

void Test_Map1 ()
{
	Test_Map () ;
}

void Test_Map2 ()
{
	Test_Map () ;
}


EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	UINT64 t_Size = sizeof ( g_Array ) / sizeof ( UINT64 ) ;

	for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Index ] ;
	}

#if 0
	Test_Map1 () ;
	Test_Map2 () ;

	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Index ] ;
	}

	Test_AvlTree1 () ;
	Test_AvlTree2 () ;
#endif

#if 1
	Test_AvlTree () ;
#endif

#if 0
	Test_BasicTree1 () ;
	Test_BasicTree2 () ;
#endif
 
#if 1

	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = g_Array [ t_Index ] ;
	}

	Test_ChunkArray () ;
#endif
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\include\tpqueue.h ===
#ifndef _TPQUEUE_H
#define _TPQUEUE_H

#include "PssException.h"
#include "Allocator.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement>
class WmiTreePriorityQueue
{
private:

	WmiBasicTree <WmiKey,WmiElement> m_Tree ;

	WmiAllocator &m_Allocator ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , WmiTreePriorityQueue :: Iterator &a_Iterator ) ;

friend Iterator ;
	class Iterator
	{
	private:

		WmiBasicTree <WmiKey,WmiElement> :: Iterator m_Iterator ;

	public:

		Iterator () { ; }
		Iterator ( WmiBasicTree <WmiKey,WmiElement> :: Iterator &a_Iterator ) { m_Iterator = a_Iterator ; }
		Iterator ( const Iterator &a_Iterator ) { m_Iterator = a_Iterator.m_Iterator ; }

		Iterator &Left () { m_Iterator.Left () ; return *this ; }
		Iterator &Right () { m_Iterator.Right () ; return *this ; }
		Iterator &Parent () { m_Iterator.Parent () ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Iterator.LeftMost () ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Iterator.RightMost () ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			m_Iterator.Decrement () ;
			return *this ;
		}

		Iterator &Increment () 
		{
			m_Iterator.Increment () ;
			return *this ;
		}

		bool Null () { return m_Iterator.Null () ; }

		WmiKey &GetKey () { return m_Iterator.GetKey () ; }
		WmiElement &GetElement () { return m_Iterator.GetElement () ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

public:

	WmiTreePriorityQueue ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiTreePriorityQueue () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode EnQueue ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiKey &a_Key ,
		WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		Iterator &a_Iterator 
	) ;

	WmiStatusCode DeQueue () ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;
	
	WmiStatusCode Merge (

		WmiTreePriorityQueue <WmiKey,WmiElement> &a_Queue
	) ;

	ULONG Size () { return m_Tree.Size () ; } ;

	Iterator Begin () { return Iterator ( m_Tree.Begin () ) ; }
	Iterator End () { return Iterator ( m_Tree.End () ) ; }
	Iterator Root () { return Iterator ( m_Tree.Root () )  ; }
	
} ;

#include <TPQueue.cpp>

#endif _TPQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemidl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMIDL.H

Abstract:

  Include file for all WBEM related interface definitions. To be included
  in projects that use any WBEM interfaces.

History:

--*/

#ifndef __WBEMIDL_H_
#define __WBEMIDL_H_

#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemtran.h>
#include <wbemdisp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test2\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\reposit\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemint\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\dlldata2.c ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    DLLDATA2.C

Abstract:

    Replacement for MIDL generated file

History:

--*/

/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/
//

#define PROXY_DELEGATION
#include <rpcproxy.h>
#include <stdio.h>

void ReadCurrentValue(char* szGuid, char * cCurrValue)
{
    long lLen = MAX_PATH;
	char	szKey[MAX_PATH];
	sprintf( szKey, "interface\\%s\\ProxyStubCLSID32", szGuid );
    RegQueryValue(HKEY_CLASSES_ROOT, szKey, cCurrValue, &lLen);
}

void RestoreCurrentValue(char* szGuid, char * cCurrValue)
{
	char	szKey[MAX_PATH];
	sprintf( szKey, "interface\\%s\\ProxyStubCLSID32", szGuid );
    if(lstrlen(cCurrValue))
    {
        RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, cCurrValue, lstrlen(cCurrValue));
    }
}


#define DLLDATA_ROUTINES2(pProxyFileList,pClsID )    \
    CLSID_PSFACTORYBUFFER \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    DLLCANUNLOADNOW(&gPFactory)   \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    DLLDUMMYPURECALL    \
//    REGISTER_PROXY_DLL_ROUTINES2(pProxyFileList, pClsID) \


#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( wbemcli )
EXTERN_PROXY_FILE( wbemint )
EXTERN_PROXY_FILE( wbemprov )
EXTERN_PROXY_FILE( wbemtran )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( wbemcli ),
  REFERENCE_PROXY_FILE( wbemint ),
  REFERENCE_PROXY_FILE( wbemprov ),
  REFERENCE_PROXY_FILE( wbemtran ),
/* End of list */
PROXYFILE_LIST_END

#define IWBEMOBJECTSINK_GUID		"{7c857801-7381-11cf-884d-00aa004b2e24}"
#define	IENUMWBEMCLASSOBJECT_GUID	"{027947E1-D731-11CE-A357-000000000001}"
#define IWBEMUNBOUNDOBJECTSINK_GUID "{E246107B-B06E-11D0-AD61-00C04FD8FDFF}"
#define IWBEMMULTITARGET_GUID		"{755F9DA6-7508-11D1-AD94-00C04FD8FDFF}"
#define IWBEMSERVICESEX_GUID		"{144459c4-cabc-11d3-a11b-00105a1f515a}"
#define IWBEMSERVICES_GUID			"{9556dc99-828c-11cf-a37e-00aa003240c7}"

DLLDATA_ROUTINES2( aProxyFileList, GET_DLL_CLSID )


    HINSTANCE hProxyDll = 0; 
    
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( 
        HINSTANCE  hinstDLL, 
        DWORD  fdwReason, 
        LPVOID  lpvReserved) 
    { 
        if(fdwReason == DLL_PROCESS_ATTACH) 
            hProxyDll = hinstDLL; 
        return TRUE; 
    } 
    
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \

    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() 
    { 
        HRESULT hRes;
        char	cCurrValueSink[MAX_PATH], cCurrValueEnum[MAX_PATH], cCurrValueUnboundSink[MAX_PATH],
				cCurrValueMultiTarget[MAX_PATH], cCurrValueServicesEx[MAX_PATH], cCurrValueServices[MAX_PATH];
        cCurrValueSink[0] = 0;
        cCurrValueEnum[0] = 0;
        cCurrValueUnboundSink[0] = 0;
        cCurrValueMultiTarget[0] = 0;
        cCurrValueServicesEx[0] = 0;
        ReadCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        ReadCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        ReadCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        ReadCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        ReadCurrentValue( IWBEMSERVICESEX_GUID, cCurrValueServicesEx );
        ReadCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );
        hRes = NdrDllRegisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID); 
        RestoreCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        RestoreCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        RestoreCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        RestoreCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        RestoreCurrentValue( IWBEMSERVICESEX_GUID, cCurrValueServicesEx );
        RestoreCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );
        return hRes;
    }  
    
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() 
    { 
        HRESULT hRes;
        char	cCurrValueSink[MAX_PATH], cCurrValueEnum[MAX_PATH], cCurrValueUnboundSink[MAX_PATH],
				cCurrValueMultiTarget[MAX_PATH];
        cCurrValueSink[0] = 0;
        cCurrValueEnum[0] = 0;
        ReadCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        ReadCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        ReadCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        ReadCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        hRes = NdrDllUnregisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ); 
        RestoreCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        RestoreCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        RestoreCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        RestoreCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        return hRes;
    }




#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test2\main.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#undef _CRTIMP
#define POLARITY __declspec( dllexport )
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <map>


#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <AvlTree.h>
#include <ThreadedAvlTree.h>
#include <KeyedArray.h>
#include <TPQueue.h>
#include <HashTable.h>
#include <Thread.h>
#include <BpTree.h>
#include <BasicTree.h>

std::_Lockit::_Lockit()
{
}

std::_Lockit::~_Lockit()
{
}
  
#define ARRAY_SIZE	1000

UINT64 t_Array[ARRAY_SIZE];

void InitAscendArray()
{
	for (int i = 0; i < ARRAY_SIZE; i++)
		t_Array[i] = i;
}

void InitDescendArray()
{
	for (int i = ARRAY_SIZE - 1; i >= 0; i--)
		t_Array[i] = i;
}

void InitRandomArray()
{
	InitAscendArray();

	for (int i = 0; i < ARRAY_SIZE; i++)
	{
		int    iToSwapWith = (rand() % ARRAY_SIZE);
		UINT64 iTemp = t_Array[i];

		t_Array[i] = t_Array[iToSwapWith];
		t_Array[iToSwapWith] = iTemp;
	}
}

void Test_BasicTree ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 24 ) ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiBasicTree <UINT64,UINT64> t_Tree ( t_Allocator ) ;
		WmiBasicTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( t_Array ) / sizeof ( UINT64 ) ;

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode != e_StatusCode_Success ) 
				{
					printf ( "\n Insert Error"  ) ;
				}

			}

			t_Index = 0 ;
			t_Iterator = t_Tree.End () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Decrement () ;
				t_Index ++ ;
			}

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			t_Iterator = t_Tree.Begin () ;
			t_Iterator.Decrement () ;

			t_Iterator = t_Tree.End () ;
			t_Iterator.Increment () ;

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}
		}
	}		
}

double GetSeconds(DWORD dwBegin)
{
	DWORD dwDiff = GetTickCount() - dwBegin;

	return ((float) dwDiff) / 1000.0;
}

void Test_AvlTree(
	double &fInsert,
	double &fIterate,
	double &fFind,
	double &fDelete)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ;
	DWORD		 dwBegin;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiAvlTree <UINT64,UINT64> *pTree = new WmiAvlTree <UINT64,UINT64>( t_Allocator ),
							       &t_Tree = *pTree;
		WmiAvlTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( t_Array ) / sizeof ( UINT64 ) ;

			dwBegin = GetTickCount();

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode != e_StatusCode_Success && 
					t_StatusCode != e_StatusCode_AlreadyExists) 
				{
					printf ( "\nError"  ) ;
				}
			}

			fInsert = GetSeconds(dwBegin);


#if	0
			ULONG t_MaxHeight ;
			t_StatusCode = t_Tree.Check ( t_MaxHeight ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				printf ( "\nError"  ) ;
			}
#endif

			dwBegin = GetTickCount();

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			fIterate = GetSeconds(dwBegin);

			//t_Iterator = t_Tree.Begin () ;
			//t_Iterator.Decrement () ;

			//t_Iterator = t_Tree.End () ;
			//t_Iterator.Increment () ;

			dwBegin = GetTickCount();

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			fFind = GetSeconds(dwBegin);


			dwBegin = GetTickCount();

			delete pTree;

			fDelete = GetSeconds(dwBegin);
/*
			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					//printf ( "\nFailure"  ) ;	
				}
			}
*/
		}
	}		
}

void Test_ThreadedAvlTree(
	double &fInsert,
	double &fIterate,
	double &fFind,
	double &fDelete)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ;
	DWORD		 dwBegin;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiThreadedAvlTree <UINT64,UINT64> *pTree = new WmiThreadedAvlTree <UINT64,UINT64>( t_Allocator ),
							       &t_Tree = *pTree;
		WmiThreadedAvlTree <UINT64,UINT64> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( t_Array ) / sizeof ( UINT64 ) ;

			dwBegin = GetTickCount();

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode != e_StatusCode_Success && 
					t_StatusCode != e_StatusCode_AlreadyExists) 
				{
					printf ( "\nError"  ) ;
				}
			}

			fInsert = GetSeconds(dwBegin);


#if	0
			ULONG t_MaxHeight ;
			t_StatusCode = t_Tree.Check ( t_MaxHeight ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				printf ( "\nError"  ) ;
			}
#endif

			dwBegin = GetTickCount();

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			fIterate = GetSeconds(dwBegin);

			//t_Iterator = t_Tree.Begin () ;
			//t_Iterator.Decrement () ;

			//t_Iterator = t_Tree.End () ;
			//t_Iterator.Increment () ;

			dwBegin = GetTickCount();

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			fFind = GetSeconds(dwBegin);


			dwBegin = GetTickCount();

			delete pTree;

			fDelete = GetSeconds(dwBegin);
/*
			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					//printf ( "\nFailure"  ) ;	
				}
			}
*/
		}
	}		
}


void Test_KeyedArray(
	double &fInsert,
	double &fIterate,
	double &fFind,
	double &fDelete)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ;
	DWORD		 dwBegin;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		WmiKeyedArray <UINT64,UINT64,100> *pTree = new WmiKeyedArray <UINT64,UINT64,100>( t_Allocator ),
							       &t_Tree = *pTree;
		WmiKeyedArray <UINT64,UINT64,100> :: Iterator t_Iterator ;

		t_StatusCode = t_Tree.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			UINT64 t_Size = sizeof ( t_Array ) / sizeof ( UINT64 ) ;

			dwBegin = GetTickCount();

			for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;
				UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

				t_StatusCode = t_Tree.Insert ( t_Key , t_Value , t_Iterator ) ;
				if ( t_StatusCode != e_StatusCode_Success && 
					t_StatusCode != e_StatusCode_AlreadyExists) 
				{
					printf ( "\nError"  ) ;
				}
			}

			fInsert = GetSeconds(dwBegin);


#if	0
			ULONG t_MaxHeight ;
			t_StatusCode = t_Tree.Check ( t_MaxHeight ) ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				printf ( "\nError"  ) ;
			}
#endif

			dwBegin = GetTickCount();

			t_Index = 0 ;
			t_Iterator = t_Tree.Begin () ;
			while ( ! t_Iterator.Null () )	
			{
				t_Iterator.Increment () ;
				t_Index ++ ;
			}

			fIterate = GetSeconds(dwBegin);

			//t_Iterator = t_Tree.Begin () ;
			//t_Iterator.Decrement () ;

			//t_Iterator = t_Tree.End () ;
			//t_Iterator.Increment () ;

			dwBegin = GetTickCount();

			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Index ] ;

				t_StatusCode = t_Tree.Find ( t_Key , t_Iterator ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					printf ( "\nFailure"  ) ;	
				}
			}

			fFind = GetSeconds(dwBegin);


			dwBegin = GetTickCount();

			delete pTree;

			fDelete = GetSeconds(dwBegin);
/*
			for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
			{
				UINT64 t_Key = t_Array [ t_Size - t_Index - 1 ] ;

				t_StatusCode = t_Tree.Delete ( t_Key ) ;
				if ( t_StatusCode == e_StatusCode_Success ) 
				{
				}
				else
				{
					//printf ( "\nFailure"  ) ;	
				}
			}
*/
		}
	}		
}

LONG ULONG_ComparisonFunction ( void *a_ComparatorOperand , const WmiBPKey &a_Key1 , const WmiBPKey &a_Key2 )
{
	ULONG *t_Key1 = ( ULONG * ) ( a_Key1.GetConstData () ) ;
	ULONG *t_Key2 = ( ULONG * ) ( a_Key2.GetConstData () ) ;

	return *t_Key1 - *t_Key2 ;
}

void Test_Map(
	double &fInsert,
	double &fIterate,
	double &fFind,
	double &fDelete)
{
	std :: map <UINT64,UINT64> *pTree = new std :: map <UINT64,UINT64>,
							   &t_Tree = *pTree;

	std :: map <UINT64,UINT64> :: iterator t_Iterator ;

	UINT64 t_Size = sizeof ( t_Array ) / sizeof ( UINT64 ) ;

	DWORD dwBegin = GetTickCount();

	for ( UINT64 t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = t_Array [ t_Index ] ;
		UINT64 t_Value = 0xFFFFFFFF00000000 + t_Index ;

		//try
		{
			t_Tree [ t_Key ] = t_Value ;
		}
		/*
		catch ( ... )
		{
			printf ( "\nError"  ) ;
		}
		*/
	}

	fInsert = GetSeconds(dwBegin);


/*
	t_Index = 0 ;
	t_Iterator = t_Tree.end () ;
	t_Iterator -- ;
	while ( t_Iterator != t_Tree.end () )	
	{
		t_Iterator -- ;
		t_Index ++ ;
	}
*/
	dwBegin = GetTickCount();

	t_Index = 0 ;
	t_Iterator = t_Tree.begin () ;
	while ( t_Iterator != t_Tree.end ()  )	
	{
		t_Iterator ++ ;
		t_Index ++ ;
	}

	fIterate = GetSeconds(dwBegin);


	//t_Iterator = t_Tree.begin () ;
	//t_Iterator --  ;

	//t_Iterator = t_Tree.end () ;
	//t_Iterator ++ ;

	dwBegin = GetTickCount();

	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = t_Array [ t_Index ] ;

		t_Iterator = t_Tree.find ( t_Key ) ;
		if ( t_Iterator != t_Tree.end () ) 
		{
			UINT64 t_Value = t_Iterator->second ;
		}
		else
		{
			printf ( "\nSTL Failure"  ) ;	
		}
	}

	fFind = GetSeconds(dwBegin);


	dwBegin = GetTickCount();

	delete pTree;

	fDelete = GetSeconds(dwBegin);
/*
	for ( t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		UINT64 t_Key = t_Array [ t_Size - t_Index - 1 ] ;

		t_Tree.erase ( t_Key ) ;
	}
*/
}

void DoStl()
{
	double fInsert,
	       fIterate,
		   fFind,
		   fDelete;

	Test_Map(fInsert, fIterate, fFind, fDelete);

	printf(
		"STL map:\n"
		"   Insert : %.02f\n"
		"  Iterate : %.02f\n"
		"     Find : %.02f\n"
		//"     Free : %.02f\n"
		"    TOTAL : %.02f\n",
		fInsert,
		fIterate,
		fFind,
		//fDelete,
		//fInsert + fIterate + fFind + fDelete);
		fInsert + fIterate + fFind);
}

void DoAVL()
{
	double fInsert,
	       fIterate,
		   fFind,
		   fDelete;

	Test_AvlTree(fInsert, fIterate, fFind, fDelete);

	printf(
		"AVL Tree:\n"
		"   Insert : %.02f\n"
		"  Iterate : %.02f\n"
		"     Find : %.02f\n"
		//"     Free : %.02f\n"
		"    TOTAL : %.02f\n",
		fInsert,
		fIterate,
		fFind,
		//fDelete,
		//fInsert + fIterate + fFind + fDelete);
		fInsert + fIterate + fFind);
}

void DoThreadedAVL()
{
	double fInsert,
	       fIterate,
		   fFind,
		   fDelete;

	Test_ThreadedAvlTree(fInsert, fIterate, fFind, fDelete);

	printf(
		"ThreadedAVL Tree:\n"
		"   Insert : %.02f\n"
		"  Iterate : %.02f\n"
		"     Find : %.02f\n"
		//"     Free : %.02f\n"
		"    TOTAL : %.02f\n",
		fInsert,
		fIterate,
		fFind,
		//fDelete,
		//fInsert + fIterate + fFind + fDelete);
		fInsert + fIterate + fFind);
}

void DoKeyedArray ()
{
	double fInsert,
	       fIterate,
		   fFind,
		   fDelete;

	Test_KeyedArray(fInsert, fIterate, fFind, fDelete);

	printf(
		"Keyed Array:\n"
		"   Insert : %.02f\n"
		"  Iterate : %.02f\n"
		"     Find : %.02f\n"
		//"     Free : %.02f\n"
		"    TOTAL : %.02f\n",
		fInsert,
		fIterate,
		fFind,
		//fDelete,
		//fInsert + fIterate + fFind + fDelete);
		fInsert + fIterate + fFind);
}

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	printf("Testing over %d values:\n", ARRAY_SIZE);

	printf("Doing ascending...\n");
	InitAscendArray();
	DoAVL();
	DoStl();
	DoThreadedAVL();
	DoKeyedArray();

	printf("\nDoing descending...\n");
	InitDescendArray();
	DoAVL();
	DoStl();
	DoThreadedAVL();
	DoKeyedArray();

	printf("\nDoing random...\n");
	InitRandomArray();
	DoAVL();
	DoStl();
	DoThreadedAVL();
	DoKeyedArray();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\containers\test\data.cpp ===
#if 1
ULONG g_ArrayConst [] = {

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1
} ;

#endif

#if 0

ULONG g_ArrayConst [] = {

	1 , 2 , 3 , 4 , 6 , 5 , 7 , 8 , 9 , 10
} ;

#endif

#if 0

ULONG g_ArrayConst [] = {

	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1

} ;

#endif

#if 0
ULONG g_ArrayConst [] = {

	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1
} ;

#endif

#if 0

ULONG g_ArrayConst [] = {

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ,

	100 , 99 , 98 , 97 , 96 , 95 , 94 , 93 , 92 , 91 ,
	90 , 89 , 88 , 87 , 86 , 85 , 84 , 83 , 82 , 81 ,
	80 , 79 , 78 , 77 , 76 , 75 , 74 , 73 , 72 , 71 ,
	70 , 69 , 68 , 67 , 66 , 65 , 64 , 63 , 62 , 61 ,
	60 , 59 , 58 , 57 , 56 , 55 , 54 , 53 , 52 , 51 ,
	50 , 49 , 48 , 47 , 46 , 45 , 44 , 43 , 42 , 41 ,
	40 , 39 , 38 , 37 , 36 , 35 , 34 , 33 , 32 , 31 ,
	30 , 29 , 28 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ,
	20 , 19 , 18 , 17 , 16 , 15 , 14 , 13 , 12 , 11 ,
	10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemsvc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemsvcw2k\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\newthrow\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemuuid\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\umiuuid\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemdc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\idl\wbemdc\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib


# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WMIIDL_SRC_INC)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

SOURCES= \
	..\wbemdcpl.idl \
	..\wbemdc.idl \
	$(O)\wbemdc_p.c \
	$(O)\wbemdc_i.c \
	$(O)\wbemdcpl_p.c \
	$(O)\wbemdcpl_i.c \
	$(O)\dlldata.c \
	..\ver.rc

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /DREGISTER_PROXY_DLL
MIDL_NO_ROBUST=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\newthrow\newthrow.cpp ===
//***************************************************************************

//

//  NewThrow.CPP

//

//  Module: Common new/delete w/throw

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

#include <windows.h>
#include <malloc.h>
#include <provexce.h>

void* __cdecl operator new( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void* __cdecl operator new[]( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void __cdecl operator delete( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

void __cdecl operator delete[]( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\autoptr.h ===
#ifndef __SMART_PTR_H__
#define __SMART_PTR_H__
#include <xmemory>
namespace wmilib
{
// TEMPLATE CLASS auto_ptr
template<class _Ty>
	class auto_ptr {
			// TEMPLATE CLASS auto_ptr_ref
	template<class _U>
		struct auto_ptr_ref {
		auto_ptr_ref(auto_ptr<_U>& _Y)
			: _Ref(_Y) {}
		auto_ptr<_U>& _Ref;
		};
public:
	typedef _Ty element_type;
	explicit auto_ptr(_Ty *_P = 0) _THROW0()
		: _Ptr(_P) {}
	auto_ptr(auto_ptr<_Ty>& _Y) _THROW0()
		: _Ptr(_Y.release()) {}
	auto_ptr(auto_ptr_ref<_Ty> _Y) _THROW0()
		: _Ptr(_Y._Ref.release()) {}
	template<class _U>
		operator auto_ptr<_U>() _THROW0()
		{return (auto_ptr<_U>(*this)); }
	template<class _U>
		operator auto_ptr_ref<_U>() _THROW0()
		{return (auto_ptr_ref<_U>(*this)); }
	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Y) _THROW0()
		{reset(_Y.release());
		return (*this); }
	~auto_ptr()
		{delete _Ptr; }
	_Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() _THROW0()
		{_Ty *_Tmp = _Ptr;
		_Ptr = 0;
		return (_Tmp); }
	void reset(_Ty* _P = 0)
		{if (_P != _Ptr)
			delete _Ptr;
		_Ptr = _P; }
private:
	_Ty *_Ptr;
	};

template<class _Ty>
	class auto_buffer {
			// TEMPLATE CLASS auto_ptr_ref
	template<class _U>
		struct auto_buffer_ref {
		auto_buffer_ref(auto_buffer<_U>& _Y)
			: _Ref(_Y) {}
		auto_buffer<_U>& _Ref;
		};
public:
	typedef _Ty element_type;
	explicit auto_buffer(_Ty *_P = 0, size_t val = -1) _THROW0()
		: _size(val),_Ptr(_P) {}
	auto_buffer(auto_buffer<_Ty>& _Y) _THROW0()
		: _size(_Y.size()), _Ptr(_Y.release()) {}
	auto_buffer(auto_buffer_ref<_Ty> _Y) _THROW0()
		: _size(_Y._Ref.size()),_Ptr(_Y._Ref.release()) {}
	template<class _U>
		operator auto_buffer<_U>() _THROW0()
		{return (auto_buffer<_U>(*this)); }
	template<class _U>
		operator auto_buffer_ref<_U>() _THROW0()
		{return (auto_buffer_ref<_U>(*this)); }
	auto_buffer<_Ty>& operator=(auto_buffer<_Ty>& _Y) _THROW0()
		{ size_t tmp = _Y.size();
		  reset(_Y.release());
		  size(tmp);
		return (*this); }
	~auto_buffer()
		{delete[] _Ptr; }
	_Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty& operator[](size_t index) const _THROW0()
		{return (*(get()+index));}
	_Ty *operator->() const _THROW0()
		{return (get()); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() _THROW0()
		{_Ty *_Tmp = _Ptr;
		_Ptr = 0;
		_size = -1;
		return (_Tmp); }
	void reset(_Ty* _P = 0)
		{if (_P != _Ptr){
			delete[] _Ptr;
			_size = -1;
		      }
		_Ptr = _P; }
	void size(size_t val) _THROW0()
		{ _size = val;}
	size_t size(void) _THROW0()
		{ return _size;}
private:
  	size_t _size;
	_Ty *_Ptr;
      };
};

#endif //__SMART_PTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\genlex.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\newthrow\newthrow.h ===
//***************************************************************************

//

//	NewThrow.H

//

//  Module: Common new/delete w/throw

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

#pragma once

#include <eh.h>

void * __cdecl operator new( size_t n);
void* __cdecl operator new[]( size_t n);
void __cdecl operator delete( void *ptr );
void __cdecl operator delete[]( void *ptr );

//taken from new.h
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\genlex.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\helper.h ===
#ifndef __HELPER_H__
#define __HELPER_H__

#include <windows.h>
#include <ole2.h>
#include <comdef.h>

#ifndef LENGTH_OF
    #define LENGTH_OF(a) (sizeof(a)/sizeof(a[0]))
#endif

#ifndef _DBG_ASSERT
  #ifdef DBG
    #define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
  #else
    #define _DBG_ASSERT(X)
  #endif
#endif


inline void RM(IUnknown * p){
	p->Release();
};

template <typename FT, FT F> class OnDelete0
{
public:
	OnDelete0(){};
	~OnDelete0(){ F(); };
};

template <typename T, typename FT, FT F> class OnDelete 
{
private:
	T Val_;
public:
	OnDelete(T Val):Val_(Val){};
	~OnDelete(){ F(Val_); };
};

template <typename T1, typename T2, typename FT, FT F> class OnDelete2
{
private:
	T1 Val1_;
	T2 Val2_;	
public:
	OnDelete2(T1 Val1,T2 Val2):Val1_(Val1),Val2_(Val2){};
	~OnDelete2(){ F(Val1_,Val2_); };
};


template <typename T, typename FT, FT F> class OnDeleteIf 
{
private:
	T Val_;
	bool bDismiss_;
public:
	OnDeleteIf(T Val):Val_(Val),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };
	~OnDeleteIf(){ if (!bDismiss_) F(Val_); };
};

template <typename C, typename FT, FT F> class OnDeleteObj0
{
private:
	C * pObj_;
public:
	OnDeleteObj0(C * pObj):pObj_(pObj){};
	~OnDeleteObj0(){ (pObj_->*F)();};
};

template <typename C, typename FT, FT F> class OnDeleteObjIf0
{
private:
	C * pObj_;
    bool bDismiss_;
public:
	OnDeleteObjIf0(C * pObj):pObj_(pObj),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };
	~OnDeleteObjIf0(){ if (!bDismiss_) { (pObj_->*F)(); }; };
};

template <typename T, typename C, typename FT, FT F> class OnDeleteObj
{
private:
	C * pObj_;
	T Val_;
public:
	OnDeleteObj(C * pObj,T Val):pObj_(pObj),Val_(Val){};
	~OnDeleteObj(){ (pObj_->*F)(Val_);};
};

template <typename T, typename C, typename FT, FT F> class OnDeleteObjIf
{
private:
	C * pObj_;
	T Val_;
    bool bDismiss_;	
public:
	OnDeleteObjIf(C * pObj,T Val):pObj_(pObj),Val_(Val),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };	
	~OnDeleteObjIf(){ if (!bDismiss_){ (pObj_->*F)(Val_);};};
};


#define RETURN_ON_FALSE( a ) \
{ BOOL bDoNotReuse = ( a ); if (!bDoNotReuse) return MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError()); } 

#define RETURN_ON_ERR( a ) \
{ HRESULT hrDoNotReuse = ( a ); if (FAILED(hrDoNotReuse)) return hrDoNotReuse; } 

#define THROW_ON_ERR( a ) \
{ HRESULT hrDoNotReuse = ( a ); if (FAILED(hrDoNotReuse)) _com_issue_error(hrDoNotReuse); }

#define THROW_ON_RES( a ) \
{ LONG lResDoNotReuse = ( a ); if (ERROR_SUCCESS != lResDoNotReuse) _com_issue_error(MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,lResDoNotReuse)); }

typedef void (__stdcall  *issue_error)(HRESULT);

inline
void no_error(HRESULT hr){
	return;
}

#endif /*_HELPER_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\cominit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMINIT.H

Abstract:

    WMI COM helpers

History:

--*/

#ifndef _COMINIT_H_
#define _COMINIT_H_

HRESULT WINAPI InitializeCom();

#ifdef _WIN32_WINNT
HRESULT WINAPI InitializeSecurity(
			PSECURITY_DESCRIPTOR         pSecDesc,
            LONG                         cAuthSvc,
            SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            void                        *pReserved1,
            DWORD                        dwAuthnLevel,
            DWORD                        dwImpLevel,
            void                        *pReserved2,
            DWORD                        dwCapabilities,
            void                        *pReserved3);
#endif /* _WIN32_WINNT  */

BOOL WINAPI IsDcomEnabled();
BOOL WINAPI IsKerberosAvailable(void);
DWORD WINAPI WbemWaitForSingleObject(HANDLE hHandle, DWORD dwMilli);
DWORD WINAPI WbemWaitForMultipleObjects(DWORD nCount, HANDLE* ahHandles,DWORD dwMilli);
HRESULT WINAPI WbemCoCreateInstance(REFCLSID rclsid, IUnknown* pUnkOuter, 
                            DWORD dwClsContext, REFIID riid, void** ppv);
HRESULT WINAPI WbemCoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, 
                            COSERVERINFO* pServerInfo, REFIID riid, void** ppv);
HRESULT WINAPI WbemCoGetCallContext(REFIID riid, void** ppv);

HRESULT WINAPI WbemCoQueryClientBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities);
HRESULT WINAPI WbemCoImpersonateClient( void);
bool WINAPI WbemIsImpersonating(void);
HRESULT WINAPI WbemCoRevertToSelf( void);
HRESULT WINAPI WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities,
	bool						fIgnoreUnk = false );

BOOL WINAPI WbemTryEnterCriticalSection(CRITICAL_SECTION* pcs);
HRESULT WINAPI WbemCoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject );


#ifndef _COMINIT_CPP_
#define COMINITEXTRN extern
#else
#define COMINITEXTRN
#endif
// a couple of functions we need for DCOM that will not exist when
// the OS is not DCOM enabled.
// ===============================================================
COMINITEXTRN HRESULT (STDAPICALLTYPE *g_pfnCoGetCallContext)(REFIID, void**);
COMINITEXTRN HRESULT (STDAPICALLTYPE *g_pfnCoInitializeEx)(void*, DWORD);
COMINITEXTRN HRESULT (STDAPICALLTYPE *g_pfnCoCreateInstanceEx)(REFCLSID,IUnknown*,DWORD,COSERVERINFO*,
                DWORD, MULTI_QI*);
COMINITEXTRN HRESULT (STDAPICALLTYPE *g_pfnCoSwitchCallContext)(IUnknown *pNewObject, IUnknown **ppOldObject);

SCODE WINAPI GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel);
SCODE WINAPI DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User);
SCODE WINAPI DetermineLoginTypeEx(BSTR & AuthArg, BSTR & UserArg,BSTR & PrincipalArg,BSTR & Authority,BSTR & User);
HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, IUnknown * pFrom, bool bAuthArg=true);
HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, COAUTHIDENTITY * pauthident, bool bAuthenticate = true);
HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities = 0);

// Extended functions that maintain credential and principal information
HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
							   COAUTHIDENTITY** ppAuthIdent, BSTR* ppPrinciple, bool GetInfoFirst=false );
HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
											  DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities = 0, bool GetInfoFirst=false);

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pUser, LPCWSTR pPassword, LPCWSTR pDomain, COAUTHIDENTITY** pAuthIdent );
HRESULT WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY* pAuthIdent );

BOOL WINAPI DoesContainCredentials( COAUTHIDENTITY* pAuthIdent );

void WINAPI CloseStuff();

// Encryption/Decryption support
HRESULT WINAPI SetInterfaceSecurityEncrypt(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
							   COAUTHIDENTITY** ppAuthIdent, BSTR* ppPrinciple, bool GetInfoFirst=false );
HRESULT WINAPI SetInterfaceSecurityDecrypt(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
											  DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities = 0, bool GetInfoFirst=false);

HRESULT WINAPI EncryptCredentials( COAUTHIDENTITY* pAuthIdent );

HRESULT WINAPI DecryptCredentials( COAUTHIDENTITY* pAuthIdent );

#endif // _COMINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\cominit.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    COMINIT.CPP

Abstract:

    WMI COM Helper functions

History:

--*/

#include "precomp.h"
#include <wbemidl.h>

#define _COMINIT_CPP_
#include "cominit.h"
#include <tchar.h>

BOOL WINAPI DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity )
{
    try
    {
        if ( NULL != pAuthIdentity && COLE_DEFAULT_AUTHINFO != pAuthIdentity)
        {
            return ( pAuthIdentity->UserLength != 0 || pAuthIdentity->PasswordLength != 0 );
        }

        return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

}

HRESULT WINAPI WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities,
    bool                        fIgnoreUnk )
{
    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;
    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }

    /*
     * Can't set pAuthInfo if cloaking requested, as cloaking implies
     * that the current proxy identity in the impersonated thread (rather
     * than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
     * is to be used.
     * See MSDN info on CoSetProxyBlanket for more details.
     */
    if (dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING))
        pAuthInfo = NULL;

    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;

    // If we are not explicitly told to ignore the IUnknown, then we should
    // check the auth identity structure.  This performs a heuristic which
    // assumes a COAUTHIDENTITY structure.  If the structure is not one, we're
    // wrapped with a try/catch in case we AV (this should be benign since
    // we're not writing to memory).

    if ( !fIgnoreUnk && DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
        if(sc == S_OK)
        {
            sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
            pCliSec->Release();
        }
        else if (sc == 0x80004002)
            sc = S_OK;
    }

    pUnk->Release();
    return sc;
}

// Helper class we can keep a static instance of and ensure that when a module unloads,
// the dll handle is freed.

class CLibHandle
{
public:

    CLibHandle() : m_hInstance( NULL ) {};
    ~CLibHandle();

    HINSTANCE GetHandle( void ) { return m_hInstance; }
    void SetHandle( HINSTANCE hInst )   { m_hInstance = hInst; }

private:

    HINSTANCE   m_hInstance;
};

CLibHandle::~CLibHandle()
{ 
    if ( NULL == m_hInstance )
        return;
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return;           // should never happen
    // if not nt, then we can crash by freeing the library, so only do it if nt!
    if(os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        FreeLibrary( m_hInstance );
    return;
}

// The OLE32 library has been loaded to access the functions above
// for DCOM calls.
// ===============================================================

// Static object that will destruct and free the handle to
// g_hOle32 when the module exits memory.
static CLibHandle  g_LibHandleOle32;

// DCOM check has been performed = TRUE.
// =====================================
static BOOL g_bInitialized = FALSE;

BOOL WINAPI InitComInit()
{
    UINT    uSize;
    BOOL    bRetCode = FALSE;

    HANDLE hMut;

    if(g_bInitialized) {
        return TRUE;
    }

    do {
        hMut = CreateMutex(NULL, TRUE,  _T("COMINIT_INITIALING"));
        if(hMut == INVALID_HANDLE_VALUE) {
            Sleep(50);
        }
    } while(hMut == INVALID_HANDLE_VALUE);

    if(g_bInitialized) {
        CloseHandle(hMut);
        return TRUE;
    }

    LPTSTR   pszSysDir = new _TCHAR[ MAX_PATH+10 ];
    if(pszSysDir == NULL)
    {
        CloseHandle(hMut);
        return FALSE;
    }

    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
    if(uSize > MAX_PATH) {
        delete[] pszSysDir;
        pszSysDir = new _TCHAR[ uSize +10 ];
        if(pszSysDir == NULL)
        {
            CloseHandle(hMut);
            return FALSE;
        }
        uSize = GetSystemDirectory(pszSysDir, uSize);
    }

    lstrcat(pszSysDir, _T("\\ole32.dll"));

    HINSTANCE   hOle32 = LoadLibraryEx(pszSysDir, NULL, 0);
    delete pszSysDir;

    if(hOle32 != NULL) 
    {
        bRetCode = TRUE;   
        (FARPROC&)g_pfnCoInitializeEx = GetProcAddress(hOle32, "CoInitializeEx");
        if(!g_pfnCoInitializeEx) {
            FreeLibrary(hOle32);
            hOle32 = NULL;
            bRetCode = FALSE;
        }

        // This handle will now automagically be freed when the Dll
        // is unloaded from memory.

        g_LibHandleOle32.SetHandle( hOle32 );

        (FARPROC&)g_pfnCoCreateInstanceEx = 
                GetProcAddress(g_LibHandleOle32.GetHandle(), "CoCreateInstanceEx");
        (FARPROC&)g_pfnCoGetCallContext = 
                GetProcAddress(g_LibHandleOle32.GetHandle(), "CoGetCallContext");
        (FARPROC&)g_pfnCoSwitchCallContext = 
                GetProcAddress(g_LibHandleOle32.GetHandle(), "CoSwitchCallContext");

    }
    g_bInitialized = TRUE;

    CloseHandle(hMut);

    return bRetCode;
}

BOOL WINAPI IsDcomEnabled()
{
    InitComInit();
    if(g_LibHandleOle32.GetHandle()) {
        // DCOM has been detected.
        // =======================
        return TRUE;
    } else {
        // DCOM was not detected.
        // ======================
        return FALSE;
    }
}

HRESULT WINAPI InitializeCom()
{
    if(IsDcomEnabled()) {
        return g_pfnCoInitializeEx(0, COINIT_MULTITHREADED);
    }
    return CoInitialize(0);
}


HRESULT WINAPI InitializeSecurity(
            PSECURITY_DESCRIPTOR         pSecDesc,
            LONG                         cAuthSvc,
            SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            void                        *pReserved1,
            DWORD                        dwAuthnLevel,
            DWORD                        dwImpLevel,
            void                        *pReserved2,
            DWORD                        dwCapabilities,
            void                        *pReserved3)
{
    // Get CoInitializeSecurity from ole32.dll
    // =======================================

    if(g_LibHandleOle32.GetHandle() == NULL)
    {
        return E_FAIL;
    }

    typedef HRESULT (STDAPICALLTYPE *PFN_COINITIALIZESECURITY)(
        PSECURITY_DESCRIPTOR, DWORD,
        SOLE_AUTHENTICATION_SERVICE*, void*, DWORD, DWORD,
        RPC_AUTH_IDENTITY_HANDLE, DWORD, void*);
    PFN_COINITIALIZESECURITY pfnCoInitializeSecurity = 
        (PFN_COINITIALIZESECURITY)
            GetProcAddress(g_LibHandleOle32.GetHandle(), "CoInitializeSecurity");
    if(pfnCoInitializeSecurity == NULL)
    {
        return S_FALSE;
    }

    // Initialize security
    // ===================

    return pfnCoInitializeSecurity(pSecDesc,
            cAuthSvc,
            asAuthSvc,
            pReserved1,
            dwAuthnLevel,
            dwImpLevel,
            pReserved2,
            dwCapabilities,
            pReserved3);
}

DWORD WINAPI WbemWaitForMultipleObjects(DWORD nCount, HANDLE* ahHandles, DWORD dwMilli)
{
    MSG msg;
    DWORD dwRet;
    while(1)
    {
        dwRet = MsgWaitForMultipleObjects(nCount, ahHandles, FALSE, dwMilli,
                                            QS_SENDMESSAGE);
        if(dwRet == (WAIT_OBJECT_0 + nCount)) 
        {
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
            continue;
        }
        else
        {
            break;
        }
    }

    return dwRet;
}


DWORD WINAPI WbemWaitForSingleObject(HANDLE hHandle, DWORD dwMilli)
{
    return WbemWaitForMultipleObjects(1, &hHandle, dwMilli);
}

BOOL WINAPI WbemTryEnterCriticalSection(CRITICAL_SECTION* pcs)
{
    // TBD properly!!

    if(pcs->LockCount >= 0)
        return FALSE;
    else
    {
        EnterCriticalSection(pcs);
        return TRUE;
    }
}


HRESULT WINAPI WbemCoCreateInstance(REFCLSID rclsid, IUnknown* pUnkOuter, 
                            DWORD dwClsContext, REFIID riid, void** ppv)
{
    if(!IsDcomEnabled())
    {
        dwClsContext &= ~CLSCTX_REMOTE_SERVER;
    }
    return CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

HRESULT WINAPI WbemCoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, 
                            COSERVERINFO* pServerInfo, REFIID riid, void** ppv)
{
    if(!IsDcomEnabled())
    {
        dwClsContext &= ~CLSCTX_REMOTE_SERVER;
    }
    return CoGetClassObject(rclsid, dwClsContext, pServerInfo, riid, ppv);
}

HRESULT WINAPI WbemCoGetCallContext(REFIID riid, void** ppv)
{
    if(!IsDcomEnabled())
    {
        *ppv = NULL;
        return E_NOTIMPL;
    }
    else
    {
        return (*g_pfnCoGetCallContext)(riid, ppv);
    }
}

HRESULT WINAPI WbemCoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject )
{
    if(!IsDcomEnabled())
    {
        return E_NOTIMPL;
    }
    else
    {
        return (*g_pfnCoSwitchCallContext)(pNewObject, ppOldObject);
    }
}
//***************************************************************************
//
//  SCODE DetermineLoginType
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return WBEM_E_INVALID_PARAMETER;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
            return WBEM_E_INVALID_PARAMETER;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        DWORD_PTR iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}

//***************************************************************************
//
//  SCODE DetermineLoginTypeEx
//
//  DESCRIPTION:
//
//  Extended version that supports Kerberos.  To do so, the authority string
//  must start with Kerberos:  and the other parts be compatible with the normal
//  login.  Ie, user should be domain\user.
//
//  PARAMETERS:
//
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  PrincipalArg        Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI DetermineLoginTypeEx(BSTR & AuthArg, BSTR & UserArg,BSTR & PrincipalArg,
                    BSTR & Authority,BSTR & User)
{

    // Normal case, just let existing code handle it

    if(Authority == NULL || _wcsnicmp(Authority, L"KERBEROS:",9))
        return DetermineLoginType(AuthArg, UserArg, Authority, User);
        
    if(!IsKerberosAvailable())
        return WBEM_E_INVALID_PARAMETER;

    PrincipalArg = SysAllocString(&Authority[9]);
    BSTR tempArg = NULL;
    return DetermineLoginType(AuthArg, UserArg, tempArg, User);

}

//***************************************************************************
//
//  bool bIsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

bool WINAPI bIsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

//***************************************************************************
//
//  bool IsKeberosAvailable
//
//  DESCRIPTION:
//
//  Returns true if Kerberos is available.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

BOOL WINAPI IsKerberosAvailable(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    // IMPORTANT!! This will need to be chanted if Kerberos is ever ported to 98
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}


//***************************************************************************
//
//  bool IsAuthenticated
//
//  DESCRIPTION:
//
//  This routine is used by clients in check if an interface pointer is using 
//  authentication.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

bool WINAPI IsAuthenticated(IUnknown * pFrom)
{
    bool bAuthenticate = true;
    if(pFrom == NULL)
        return true;
    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);

        if (sc == 0x800706d2 || (sc == S_OK && dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE))
            bAuthenticate = false;
        pFromSec->Release();
    }
    return bAuthenticate;
}

//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{

    if(pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
    }
    return sc;
}


//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pDomain             Input, domain
//  pUser               Input, user name
//  pPassword           Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                      is used
//  bAuthArg            If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, 
                             LPWSTR pPassword, IUnknown * pFrom, bool bAuthArg)
{
    
    SCODE sc;

    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Check the source pointer to determine if we are running in a non authenticated mode which
    // would be the case when connected to a Win9X box which is using share level security

    bool bAuthenticate = true;

    if(pFrom)
        bAuthenticate = IsAuthenticated(pFrom);
    else
        bAuthenticate = bAuthArg;

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
        return SetInterfaceSecurity(pInterface, NULL, bAuthenticate);

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = DetermineLoginType(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        if(UserArg)
        {
            authident.UserLength = wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(pPassword)
        {
            authident.PasswordLength = wcslen(pPassword);
            authident.Password = (LPWSTR)pPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        sc = SetInterfaceSecurity(pInterface, &authident, bAuthenticate);
    }
    else
    {
        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if(UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if(pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        sc = SetInterfaceSecurity(pInterface, &authident, bAuthenticate);
    }
    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}



//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pDomain             Input, domain
//  pUser               Input, user name
//  pPassword           Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                      is used
//  bAuthArg            If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, 
                             LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities)
{
    
    SCODE sc;

    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
    {
        sc = WbemSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            dwAuthLevel, dwImpLevel, 
            NULL,
            dwCapabilities);
        return sc;
    }

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL, PrincipalArg = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        if(UserArg)
        {
            authident.UserLength = wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(pPassword)
        {
            authident.PasswordLength = wcslen(pPassword);
            authident.Password = (LPWSTR)pPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if(UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if(pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }

    sc = WbemSetProxyBlanket(pInterface, 
        (PrincipalArg) ? 16 : RPC_C_AUTHN_WINNT, 
        RPC_C_AUTHZ_NONE, 
        PrincipalArg,
        dwAuthLevel, dwImpLevel, 
        (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT) ? &authident : NULL,
        dwCapabilities);
    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    if(PrincipalArg)
        SysFreeString(PrincipalArg);

    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, COAUTHIDENTITY * pauthident, bool bAuthenticate)
{

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    SCODE sc;
    sc = WbemSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE, 
        RPC_C_IMP_LEVEL_IDENTIFY, 
        (bAuthenticate) ? pauthident : NULL,
        EOAC_NONE);
    return sc;
}

void GetCurrentValue(IUnknown * pFrom,DWORD & dwAuthenticationArg, DWORD & dwAuthorizationArg)
{
    if(pFrom == NULL)
        return;
    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            NULL, NULL,
                                            NULL, NULL);

        if (sc == S_OK)
        {
            dwAuthenticationArg = dwAuthnSvc;
            dwAuthorizationArg = dwAuthzSvc;
        }
        pFromSec->Release();
    }
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityEx
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthority          Input, authority
//  pUser               Input, user name
//  pPassword           Input, password.
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  ppAuthIdent         Output, Allocated AuthIdentity if applicable, caller must free
//                      manually (can use the FreeAuthInfo function).
//  pPrincipal          Output, Principal calculated from supplied data  Caller must
//                      free using SysFreeString.
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword,
                               DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
                               COAUTHIDENTITY** ppAuthIdent, BSTR* pPrincipal, bool GetInfoFirst)
{
    
    SCODE sc;
    DWORD dwAuthenticationArg = RPC_C_AUTHN_WINNT;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;

    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;

    if( pInterface == NULL || NULL == ppAuthIdent || NULL == pPrincipal )
        return WBEM_E_INVALID_PARAMETER;

    if(GetInfoFirst)
        GetCurrentValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
    {
        sc = WbemSetProxyBlanket(pInterface, dwAuthenticationArg, dwAuthorizationArg, NULL,
            dwAuthLevel, dwImpLevel, 
            NULL,
            dwCapabilities);
        return sc;
    }

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    

    BSTR AuthArg = NULL, UserArg = NULL, PrincipalArg = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, pAuthority, pUser);
    if(sc != S_OK)
    {
        return sc;
    }

    // Handle an allocation failure
    COAUTHIDENTITY*  pAuthIdent = NULL;
    
    // We will only need this structure if we are not cloaking and we want at least
    // connect level authorization

    if ( !( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        && (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT) )
    {
        sc = WbemAllocAuthIdentity( UserArg, pPassword, AuthArg, &pAuthIdent );
    }

    if ( SUCCEEDED( sc ) )
    {
        sc = WbemSetProxyBlanket(pInterface, 
            (PrincipalArg) ? 16 : dwAuthenticationArg, 
            dwAuthorizationArg, 
            PrincipalArg,
            dwAuthLevel, dwImpLevel, 
            pAuthIdent,
            dwCapabilities);

        // We will store relevant values as necessary
        if ( SUCCEEDED( sc ) )
        {
            *ppAuthIdent = pAuthIdent;
            *pPrincipal = PrincipalArg;
        }
        else
        {
            WbemFreeAuthIdentity( pAuthIdent );
        }
    }

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);

    // Only free if we failed
    if(PrincipalArg && FAILED( sc ))
    {
        SysFreeString(PrincipalArg);
    }

    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityEx
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthIdent          Input, Preset COAUTHIDENTITY structure pointer.
//  pPrincipal          Input, Preset principal argument
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
                                              DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities, bool GetInfoFirst)
{
    DWORD dwAuthenticationArg = RPC_C_AUTHN_WINNT;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;

    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(GetInfoFirst)
        GetCurrentValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // The complicated values should have already been precalced.
    // Note : For auth level, we have to check for the 'RPC_C_AUTHN_LEVEL_DEFAULT' (=0) value as well,
    //        as after negotiation with the server it might result in something high that does need 
    //        the identity structure !!
    return WbemSetProxyBlanket(pInterface,
        (pPrincipal) ? 16 : dwAuthenticationArg,
        dwAuthorizationArg,
        pPrincipal,
        dwAuthLevel,
        dwImpLevel, 
        ((dwAuthLevel == RPC_C_AUTHN_LEVEL_DEFAULT) || 
         (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT)) ? pAuthIdent : NULL,
        dwCapabilities);

}

//***************************************************************************
//
//  HRESULT WbemAllocAuthIdentity
//
//  DESCRIPTION:
//
//  Walks a COAUTHIDENTITY structure and CoTaskMemAllocs the member data and the
//  structure.
//
//  PARAMETERS:
//
//  pUser       Input
//  pPassword   Input
//  pDomain     Input
//  ppAuthInfo  Output, Newly allocated structure
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pUser, LPCWSTR pPassword, LPCWSTR pDomain, COAUTHIDENTITY** ppAuthIdent )
{
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Handle an allocation failure
    COAUTHIDENTITY*  pAuthIdent = NULL;
    
    pAuthIdent = (COAUTHIDENTITY*) CoTaskMemAlloc( sizeof(COAUTHIDENTITY) );

    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memset((void *)pAuthIdent,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        // Allocate needed memory and copy in data.  Cleanup if anything goes wrong
        if ( NULL != pUser )
        {
            pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( ( wcslen(pUser) + 1 ) * sizeof( WCHAR ) );

            if ( NULL == pAuthIdent->User )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->UserLength = wcslen(pUser);
            wcscpy( pAuthIdent->User, pUser );
        }

        if ( NULL != pDomain )
        {
            pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( ( wcslen(pDomain) + 1 ) * sizeof( WCHAR ) );

            if ( NULL == pAuthIdent->Domain )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->DomainLength = wcslen(pDomain);
            wcscpy( pAuthIdent->Domain, pDomain );
        }

        if ( NULL != pPassword )
        {
            pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( ( wcslen(pPassword) + 1 ) * sizeof( WCHAR ) );

            if ( NULL == pAuthIdent->Password )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->PasswordLength = wcslen(pPassword);
            wcscpy( pAuthIdent->Password, pPassword );

        }

        pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {

        size_t  nBufferLength;

        // Allocate needed memory and copy in data.  Cleanup if anything goes wrong
        if ( NULL != pUser )
        {
            // How many characters do we need?
            nBufferLength = wcstombs( NULL, pUser, 0 ) + 1;

            pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( nBufferLength );

            if ( NULL == pAuthIdent->User )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->UserLength = wcslen(pUser);
            wcstombs( (LPSTR) pAuthIdent->User, pUser, nBufferLength );
        }

        if ( NULL != pDomain )
        {
            // How many characters do we need?
            nBufferLength = wcstombs( NULL, pDomain, 0 ) + 1;

            pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( nBufferLength );

            if ( NULL == pAuthIdent->Domain )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->DomainLength = wcslen(pDomain);
            wcstombs( (LPSTR) pAuthIdent->Domain, pDomain, nBufferLength );
        }

        if ( NULL != pPassword )
        {
            // How many characters do we need?
            nBufferLength = wcstombs( NULL, pPassword, 0 ) + 1;

            pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( nBufferLength );

            if ( NULL == pAuthIdent->Password )
            {
                WbemFreeAuthIdentity( pAuthIdent );
                return WBEM_E_OUT_OF_MEMORY;
            }

            pAuthIdent->PasswordLength = wcslen(pPassword);
            wcstombs( (LPSTR) pAuthIdent->Password, pPassword, nBufferLength );

        }

        pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }

    *ppAuthIdent = pAuthIdent;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT WbemFreeAuthIdentity
//
//  DESCRIPTION:
//
//  Walks a COAUTHIDENTITY structure and CoTaskMemFrees the member data and the
//  structure.
//
//  PARAMETERS:
//
//  pAuthInfo   Structure to free
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity )
{
    // Make sure we have a pointer, then walk the structure members and
    // cleanup.

    if ( NULL != pAuthIdentity )
    {
        if ( NULL != pAuthIdentity->User )
        {
            CoTaskMemFree( pAuthIdentity->User );
        }

        if ( NULL != pAuthIdentity->Password )
        {
            CoTaskMemFree( pAuthIdentity->Password );
        }

        if ( NULL != pAuthIdentity->Domain )
        {
            CoTaskMemFree( pAuthIdentity->Domain );
        }

        CoTaskMemFree( pAuthIdentity );
    }

    return S_OK;
}

//***************************************************************************
//
//  HRESULT WbemCoQueryClientBlanket
//  HRESULT WbemCoImpersonateClient( void)
//  HRESULT WbemCoRevertToSelf( void)
//
//  DESCRIPTION:
//
//  These routine wrap some common dcom functions.  They are wrapped just in
//  case the code is running on nt 3.51.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemCoQueryClientBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities)
{
    IServerSecurity * pss = NULL;
    SCODE sc = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        pss->QueryBlanket(pAuthnSvc, pAuthzSvc, pServerPrincName, 
                pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        pss->Release();
    }
    return sc;

}

HRESULT WINAPI WbemCoImpersonateClient( void)
{
    IServerSecurity * pss = NULL;
    SCODE sc = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        sc = pss->ImpersonateClient();    
        pss->Release();
    }
    return sc;
}

bool WINAPI WbemIsImpersonating(void)
{
    bool bRet = false;
    IServerSecurity * pss = NULL;
    SCODE sc = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        bRet = (pss->IsImpersonating() == TRUE);    
        pss->Release();
    }
    return bRet;
}

HRESULT WINAPI WbemCoRevertToSelf( void)
{
    IServerSecurity * pss = NULL;
    SCODE sc = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        sc = pss->RevertToSelf();    
        pss->Release();
    }
    return sc;
}

void WINAPI CloseStuff()
{
    if(g_LibHandleOle32.GetHandle())
    {
        FreeLibrary(g_LibHandleOle32.GetHandle());
        g_LibHandleOle32.SetHandle( NULL );
        g_bInitialized = FALSE;
    }
}

// Encryption/Decryption helpers
void EncryptWCHARString( WCHAR* pwszString, ULONG nNumChars )
{
    if ( NULL != pwszString )
    {
        for ( ULONG x = 0; x < nNumChars; x++ )
        {
            pwszString[x] += 1;
        }
    }
}

void DecryptWCHARString( WCHAR* pwszString, ULONG nNumChars )
{
    if ( NULL != pwszString )
    {
        for ( ULONG x = 0; x < nNumChars; x++ )
        {
            pwszString[x] -= 1;
        }
    }
}

void EncryptAnsiString( char* pszString, ULONG nNumChars )
{
    if ( NULL != pszString )
    {
        for ( ULONG x = 0; x < nNumChars; x++ )
        {
            pszString[x] += 1;
        }
    }
}

void DecryptAnsiString( char* pszString, ULONG nNumChars )
{
    if ( NULL != pszString )
    {
        for ( ULONG x = 0; x < nNumChars; x++ )
        {
            pszString[x] -= 1;
        }
    }
}

//***************************************************************************
//
//  SCODE EncryptCredentials
//
//  DESCRIPTION:
//
//  This routine is used to encrypt the supplied authidentity structure.
//
//  PARAMETERS:
//
//  pAuthIdent          Structure to encrypt.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************
HRESULT WINAPI EncryptCredentials( COAUTHIDENTITY* pAuthIdent )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pAuthIdent )
    {
        // ANSI or WCHAR
        if ( pAuthIdent->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
        {
            EncryptAnsiString( (char*) pAuthIdent->User, pAuthIdent->UserLength );
            EncryptAnsiString( (char*) pAuthIdent->Domain, pAuthIdent->DomainLength );
            EncryptAnsiString( (char*) pAuthIdent->Password, pAuthIdent->PasswordLength );
        }
        else
        {
            EncryptWCHARString( pAuthIdent->User, pAuthIdent->UserLength );
            EncryptWCHARString( pAuthIdent->Domain, pAuthIdent->DomainLength );
            EncryptWCHARString( pAuthIdent->Password, pAuthIdent->PasswordLength );
        }
    }

    return hr;
}

//***************************************************************************
//
//  SCODE DecryptCredentials
//
//  DESCRIPTION:
//
//  This routine is used to decrypt the supplied authidentity structure.  The
//  structure must have been encrypted by EncryptCredentials
//
//  PARAMETERS:
//
//  pAuthIdent          Structure to decrypt.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************
HRESULT WINAPI DecryptCredentials( COAUTHIDENTITY* pAuthIdent )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pAuthIdent )
    {
        // ANSI or WCHAR
        if ( pAuthIdent->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
        {
            DecryptAnsiString( (char*) pAuthIdent->User, pAuthIdent->UserLength );
            DecryptAnsiString( (char*) pAuthIdent->Domain, pAuthIdent->DomainLength );
            DecryptAnsiString( (char*) pAuthIdent->Password, pAuthIdent->PasswordLength );
        }
        else
        {
            DecryptWCHARString( pAuthIdent->User, pAuthIdent->UserLength );
            DecryptWCHARString( pAuthIdent->Domain, pAuthIdent->DomainLength );
            DecryptWCHARString( pAuthIdent->Password, pAuthIdent->PasswordLength );
        }
    }

    return hr;

}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityEncrypt
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  The returned AuthIdentity structure will be encrypted before returning.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthority          Input, authority
//  pUser               Input, user name
//  pPassword           Input, password.
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  ppAuthIdent         Output, Allocated AuthIdentity if applicable, caller must free
//                      manually (can use the FreeAuthInfo function).
//  pPrincipal          Output, Principal calculated from supplied data  Caller must
//                      free using SysFreeString.
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************
HRESULT WINAPI SetInterfaceSecurityEncrypt(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
                               COAUTHIDENTITY** ppAuthIdent, BSTR* ppPrinciple, bool GetInfoFirst )
{
    HRESULT hr = SetInterfaceSecurityEx( pInterface, pDomain, pUser, pPassword, dwAuthLevel, dwImpLevel, dwCapabilities,
                                        ppAuthIdent, ppPrinciple, GetInfoFirst );

    if ( SUCCEEDED( hr ) )
    {
        if ( NULL != ppAuthIdent )
        {
            hr = EncryptCredentials( *ppAuthIdent );
        }
    }

    return hr;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityDecrypt
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  It will unencrypt and reencrypt the auth identity structure in place.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthIdent          Input, Preset COAUTHIDENTITY structure pointer.
//  pPrincipal          Input, Preset principal argument
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityDecrypt(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
                                              DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities, bool GetInfoFirst )
{
    // Decrypt first
    HRESULT hr = DecryptCredentials( pAuthIdent );
        
    if ( SUCCEEDED( hr ) )
    {


        hr = SetInterfaceSecurityEx( pInterface, pAuthIdent, pPrincipal, dwAuthLevel, dwImpLevel,
                                        dwCapabilities, GetInfoFirst );

        hr = EncryptCredentials( pAuthIdent );

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\opathlex.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OPATHLEX.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\objpath.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>

#define DELETE_ME

struct KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;
    HRESULT m_hRes;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
    BOOL IsValid(){  return (m_pName && (S_OK == m_hRes)); };
};

struct ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
    BOOL IsValid()
    {
	    return (m_paNamespaces && m_paKeys);
    };
    
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\opathlex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\precomp.h ===
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\objpath.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

inline LPWSTR Macro_CloneLPWSTR(LPCWSTR x)
{
    if (x)
    {
        LPWSTR szTemp = new wchar_t[wcslen(x) + 1];

        if (szTemp)
            wcscpy(szTemp, x);

        return szTemp;
    }
    else
        return NULL;
}

bool inline CloneFailed(LPCWSTR p1, LPCWSTR p2)
{
	if (0 == p1 && 0 == p2 ) return false;
    if (p1 && p2) return false;
	return true;
}


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    if(m_paNamespaces)
		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
			m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
        delete m_pServer;

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
            delete m_paNamespaces[dwIx];
        delete m_paNamespaces;
    }

    if (m_pClass)
        delete m_pClass;

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
            delete m_paKeys[dwIx];
        delete m_paKeys;
    }
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    if (m_pClass)
        delete [] m_pClass;

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
        if (CloneFailed(m_pClass,wszClassName))
            return FALSE;
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        if(paNewNamespaces == NULL) return FALSE;
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
	LPWSTR p = Macro_CloneLPWSTR(wszNamespace);
	if (p)
	{
        m_paNamespaces[m_dwNumNamespaces++] = p;
        return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        if (S_OK == VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue ))
        {
	        m_dwNumKeys = 1 ;
        }
        else
        {
            bStatus = FALSE;
        }
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys[dwIndex]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                if (m_paKeys[dwIndex]->m_pName)
                {
                    wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
                }
                else
                {
                    bStatus = FALSE;
                    goto error;
                }
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            if (S_OK != VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                                      ( VARIANT * ) pvValue ))
            {
                bStatus = FALSE;
            }
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys[0]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                if (m_paKeys[0]->m_pName)
                {
	                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

	                if (S_OK == VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
        	                    ( VARIANT * ) pvValue ))
        	        {
		                m_dwNumKeys = 1;
	                }
	                else
	                {
	                    bStatus = FALSE;
	                }
                }
                else
                {
                    bStatus = FALSE;
                }
            }
            else
            {
                /* Add a Named Key */

                bStatus = AddKeyRef(wszKeyName, pvValue);
            }
        }
    }
error:
    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)

    m_paKeys = new KeyRef *[2];
    if (m_paKeys)
        m_dwAllocKeys = 2;
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (!paNewKeys)
            return FALSE;

        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

	if(m_paKeys == NULL)
		return FALSE;
    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (!m_paKeys[m_dwNumKeys] || !m_paKeys[m_dwNumKeys]->IsValid())
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if(paNewKeys == NULL)return FALSE;
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }
    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
    m_hRes = S_OK;
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    m_hRes = VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];

    if (!wszPath)
        return OutOfMemory;

    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (!m_pOutput || !m_pOutput->IsValid())
        return OutOfMemory;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];

                if (!m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    return OutOfMemory;
                }

                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (!m_pOutput->m_pServer)
        {
            delete m_pOutput;
            return OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (!m_pLexer)
    {
        delete m_pOutput;
        return OutOfMemory;
    }

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (!m_pOutput->m_pServer)
            {
                delete m_pOutput;
                return OutOfMemory;
            }

            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (CloneFailed(m_pInitialIdent,m_pLexer->GetTokenText()))
            return OutOfMemory;
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (CloneFailed(m_pOutput->m_pClass,m_pLexer->GetTokenText()))
        return OutOfMemory;

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    if (CloneFailed(m_pOutput->m_pClass,m_pInitialIdent))
        return OutOfMemory;
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef; // no IsValid here
        if (!m_pTmpKeyRef)
            return OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
		{
			delete m_pTmpKeyRef;
			m_pTmpKeyRef = 0;
            return OutOfMemory;
		}
		m_pTmpKeyRef = 0;        
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        
        BSTR bStr = SysAllocString(m_pLexer->GetTokenText());
        if (bStr)
        {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
            V_BSTR(&m_pTmpKeyRef->m_vValue) = bStr;
        }
        else
            return OutOfMemory;
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef; // no IsValid here

    if (!m_pTmpKeyRef)
        return OutOfMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
	{
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return OutOfMemory;
	}
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (CloneFailed(m_pTmpKeyRef->m_pName,m_pLexer->GetTokenText()))
        return OutOfMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        
        if (pTmp)
            wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    if (!pRetVal)
        return NULL;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];

    if (!wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut == NULL)return NULL;
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)return FALSE;
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=stdlibrary

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(STDLIBRARY_INC)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES= \
	..\cominit.cpp \
	..\genlex.cpp \
	..\objpath.cpp \
	..\opathlex.cpp \
	..\sqllex.cpp \
	..\sql_1.cpp

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__
WIN32_WINNT_VERSION=0x0400
USE_NATIVE_EH=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sqllex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.cpp

Abstract:

    SQL Level 1 DFA Table

History:


--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   23
#define ST_IDENT    28
#define ST_GE       34
#define ST_LE       36
#define ST_NE       39
#define ST_NUMERIC  41
#define ST_REAL     44
#define ST_STRING2  50
#define ST_STRING_ESC 55
#define ST_STRING2_ESC 56

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,  SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 22 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 23 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 26 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 27 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 28 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  0x80,   0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 34 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 36 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 37 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 39 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 40 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 41 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 42 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 43 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 44 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 45 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 48 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 56 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sqllex.h ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.h

Abstract:

    SQL Level 1 DFA Table & Tokens

History:

--*/

#ifndef _SQLLEX_H_
#define _SQLLEX_H_

#define SQL_1_TOK_EOF           0
#define SQL_1_TOK_ERROR         1
#define SQL_1_TOK_IDENT         100
#define SQL_1_TOK_QSTRING       101
#define SQL_1_TOK_INT           102
#define SQL_1_TOK_REAL          103
#define SQL_1_TOK_CHAR          104
#define SQL_1_TOK_BOOL          105

#define SQL_1_TOK_LE            106
#define SQL_1_TOK_LT            107
#define SQL_1_TOK_GE            108
#define SQL_1_TOK_GT            109
#define SQL_1_TOK_EQ            110
#define SQL_1_TOK_NE            111

#define SQL_1_TOK_DOT           112
#define SQL_1_TOK_OPEN_PAREN    113
#define SQL_1_TOK_CLOSE_PAREN   114
#define SQL_1_TOK_ASTERISK      115
#define SQL_1_TOK_COMMA         116

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\scopeguard.h ===
//  No Copyright here
//  Based on Nov 2000 CUJ Experts articole by
//  Andrei Alexandrescu and Petru Marginean

#ifndef SCOPEGUARD_H_
#define SCOPEGUARD_H_


template <class T>
class RefHolder
{
	T& ref_;
public:
	RefHolder(T& ref) : ref_(ref) {}
	operator T& () const 
	{
		return ref_;
	}
};

template <class T>
inline RefHolder<T> ByRef(T& t)
{
	return RefHolder<T>(t);
}

class ScopeGuardImplBase
{
	ScopeGuardImplBase& operator =(const ScopeGuardImplBase&);
protected:
	~ScopeGuardImplBase()
	{
	}
	ScopeGuardImplBase(const ScopeGuardImplBase& other) throw() 
		: dismissed_(other.dismissed_)
	{
		other.Dismiss();
	}
	template <typename J>
	static void SafeExecute(J& j) throw() 
	{
		if (!j.dismissed_)
			try
			{
				j.Execute();
			}
			catch(...)
			{
			}
	}
	
	mutable bool dismissed_;
public:
	ScopeGuardImplBase() throw() : dismissed_(false) 
	{
	}
	void Dismiss() const throw() 
	{
		dismissed_ = true;
	}
};

typedef const ScopeGuardImplBase& ScopeGuard;

template <typename F>
class ScopeGuardImpl0 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl0<F> MakeGuard(F fun)
	{
		return ScopeGuardImpl0<F>(fun);
	}
	~ScopeGuardImpl0() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		fun_();
	}
protected:
	ScopeGuardImpl0(F fun) : fun_(fun) 
	{
	}
	F fun_;
};

template <typename F> 
inline ScopeGuardImpl0<F> MakeGuard(F fun)
{
	return ScopeGuardImpl0<F>::MakeGuard(fun);
}

template <typename F, typename P1>
class ScopeGuardImpl1 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl1<F, P1> MakeGuard(F fun, P1 p1)
	{
		return ScopeGuardImpl1<F, P1>(fun, p1);
	}
	~ScopeGuardImpl1() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_);
	}
protected:
	ScopeGuardImpl1(F fun, P1 p1) : fun_(fun), p1_(p1) 
	{
	}
	F fun_;
	const P1 p1_;
};

template <typename F, typename P1> 
inline ScopeGuardImpl1<F, P1> MakeGuard(F fun, P1 p1)
{
	return ScopeGuardImpl1<F, P1>::MakeGuard(fun, p1);
}

template <typename F, typename P1, typename P2>
class ScopeGuardImpl2: public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl2<F, P1, P2> MakeGuard(F fun, P1 p1, P2 p2)
	{
		return ScopeGuardImpl2<F, P1, P2>(fun, p1, p2);
	}
	~ScopeGuardImpl2() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_, p2_);
	}
protected:
	ScopeGuardImpl2(F fun, P1 p1, P2 p2) : fun_(fun), p1_(p1), p2_(p2) 
	{
	}
	F fun_;
	const P1 p1_;
	const P2 p2_;
};

template <typename F, typename P1, typename P2>
inline ScopeGuardImpl2<F, P1, P2> MakeGuard(F fun, P1 p1, P2 p2)
{
	return ScopeGuardImpl2<F, P1, P2>::MakeGuard(fun, p1, p2);
}

template <typename F, typename P1, typename P2, typename P3>
class ScopeGuardImpl3 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl3<F, P1, P2, P3> MakeGuard(F fun, P1 p1, P2 p2, P3 p3)
	{
		return ScopeGuardImpl3<F, P1, P2, P3>(fun, p1, p2, p3);
	}
	~ScopeGuardImpl3() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_, p2_, p3_);
	}
protected:
	ScopeGuardImpl3(F fun, P1 p1, P2 p2, P3 p3) : fun_(fun), p1_(p1), p2_(p2), p3_(p3) 
	{
	}
	F fun_;
	const P1 p1_;
	const P2 p2_;
	const P3 p3_;
};

template <typename F, typename P1, typename P2, typename P3>
inline ScopeGuardImpl3<F, P1, P2, P3> MakeGuard(F fun, P1 p1, P2 p2, P3 p3)
{
	return ScopeGuardImpl3<F, P1, P2, P3>::MakeGuard(fun, p1, p2, p3);
}

//************************************************************

template <class Obj, typename MemFun>
class ObjScopeGuardImpl0 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl0<Obj, MemFun> MakeObjGuard(Obj& obj, MemFun memFun)
	{
		return ObjScopeGuardImpl0<Obj, MemFun>(obj, memFun);
	}
	~ObjScopeGuardImpl0() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)();
	}
protected:
	ObjScopeGuardImpl0(Obj& obj, MemFun memFun) 
		: obj_(obj), memFun_(memFun) {}
	Obj& obj_;
	MemFun memFun_;
};

template <class Obj, typename MemFun>
inline ObjScopeGuardImpl0<Obj, MemFun> MakeObjGuard(Obj& obj, MemFun memFun)
{
	return ObjScopeGuardImpl0<Obj, MemFun>::MakeObjGuard(obj, memFun);
}

template <class Obj, typename MemFun, typename P1>
class ObjScopeGuardImpl1 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl1<Obj, MemFun, P1> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1)
	{
		return ObjScopeGuardImpl1<Obj, MemFun, P1>(obj, memFun, p1);
	}
	~ObjScopeGuardImpl1() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)(p1_);
	}
protected:
	ObjScopeGuardImpl1(Obj& obj, MemFun memFun, P1 p1) 
		: obj_(obj), memFun_(memFun), p1_(p1) {}
	Obj& obj_;
	MemFun memFun_;
	const P1 p1_;
};

template <class Obj, typename MemFun, typename P1>
inline ObjScopeGuardImpl1<Obj, MemFun, P1> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1)
{
	return ObjScopeGuardImpl1<Obj, MemFun, P1>::MakeObjGuard(obj, memFun, p1);
}

template <class Obj, typename MemFun, typename P1, typename P2>
class ObjScopeGuardImpl2 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl2<Obj, MemFun, P1, P2> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2)
	{
		return ObjScopeGuardImpl2<Obj, MemFun, P1, P2>(obj, memFun, p1, p2);
	}
	~ObjScopeGuardImpl2() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)(p1_, p2_);
	}
protected:
	ObjScopeGuardImpl2(Obj& obj, MemFun memFun, P1 p1, P2 p2) 
		: obj_(obj), memFun_(memFun), p1_(p1), p2_(p2) {}
	Obj& obj_;
	MemFun memFun_;
	const P1 p1_;
	const P2 p2_;
};

template <class Obj, typename MemFun, typename P1, typename P2>
inline ObjScopeGuardImpl2<Obj, MemFun, P1, P2> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2)
{
	return ObjScopeGuardImpl2<Obj, MemFun, P1, P2>::MakeObjGuard(obj, memFun, p1, p2);
}
// Rollback helper functions
template<typename T>
void deletePtr(const T* p)
{
  delete p;
}

template<typename T>
void deleteArray(T* p)
{
  delete[] p;
}

#define CONCATENATE_DIRECT(s1, s2) s1##s2
#define CONCATENATE(s1, s2) CONCATENATE_DIRECT(s1, s2)
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __LINE__)

#define ON_BLOCK_EXIT ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeGuard
#define ON_BLOCK_EXIT_OBJ ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeObjGuard

#endif //SCOPEGUARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sql_1.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    SQL_1.H

Abstract:

    Level 1 Syntax SQL Parser

History:

--*/

#ifndef _SQL_1_H_
#define _SQL_1_H_

struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sql_test.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    SQL_TEST.CPP

Abstract:

  Test driver for Level 1 Syntax QL Parser

  Takes the filename of a file containing one or more WQL queries (one per
  line).  Writes the output to the console.

History:

  23-Apr-99    Modified to improve output.

--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

void xmain(int argc, char **argv)
{
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: ql_test WQL-query-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: ql_test WQL-query-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // get rid of newline
        char* ptr;
        if ((ptr = strchr(buf, '\n')) != NULL)
        {
            *ptr = '\0';
        }

        // get start of text
        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // ignore blank lines
        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            CTextLexSource src(buf2);
            SQL1_Parser parser(&src);
            SQL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;

            // get the class
            wchar_t classbuf[128];
            *classbuf = 0;
            printf("----GetQueryClass----\n");
            int nRes = parser.GetQueryClass(classbuf, 128);
            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                goto ContinueRead;
            }
            printf("Query class is %S\n", classbuf);

            // parse the full query
            nRes = parser.Parse(&pExp);

            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                //goto ContinueRead;
            }
            else
            {
                printf("No errors.\n");
            }

            // call Dump function to display the tokens
            if (pExp)
            {
                pExp->Dump("CON");
            }

ContinueRead:
            delete pExp;
            printf("%S\n", buf2);
            printf("=================================================EOL %d=======================================================\n", nLine);
        }
        nLine++;
    }

    if (ferror(f) != 0)
    {
        printf("\nError: line %d", nLine);
    }

    fclose(f);
}

void main(int argc, char **argv)
{
    xmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\analyser.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  analyser.cpp
//
//  Purpose: Performs query analysis
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>

#include "analyser.h"
#include <stack>
#include <vector>
#include <comdef.h>

#define AutoDestructStack( X )  \
                                \
        while(!X.empty())       \
        {                       \
            delete X.top();     \
            X.pop();            \
        }                       \

HRESULT CQueryAnalyser::GetNecessaryQueryForProperty (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    IN LPCWSTR wszPropName,
    DELETE_ME SQL_LEVEL_1_RPN_EXPRESSION *&pNewExpr
)
{
    pNewExpr = NULL ;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<SQL_LEVEL_1_RPN_EXPRESSION*> ExprStack;

    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = new SQL_LEVEL_1_RPN_EXPRESSION;
        if ( ! pNewExpr )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pExpr->pArrayOfTokens[i];
        SQL_LEVEL_1_RPN_EXPRESSION *pNew = new SQL_LEVEL_1_RPN_EXPRESSION;
        if ( pNew )
        {
            switch(Token.nTokenType)
            {
                case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
                {
                    if(IsTokenAboutProperty(Token, wszPropName))
                    {
                        SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(Token);
                        if ( pToken )
                        {
                            pNew->AddToken(pToken);
                        }
                        else
                        {
                            delete pNew ;
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }

                    ExprStack.push(pNew);
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_AND:
                {
                    if(ExprStack.size() < 2)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        delete pNew ;
                        break;
                    }

                    SQL_LEVEL_1_RPN_EXPRESSION *pFirst = ExprStack.top(); 
                    ExprStack.pop();

                    SQL_LEVEL_1_RPN_EXPRESSION *pSecond = ExprStack.top(); 
                    ExprStack.pop();

                    try
                    {
                        hres = AndQueryExpressions(pFirst, pSecond, pNew);
                    }
                    catch ( ... )
                    {
                        delete pNew ;
                        delete pFirst;
                        delete pSecond;

                        throw ;
                    }

                    try
                    {
                        ExprStack.push(pNew);
                    }
                    catch ( ... )
                    {
                        delete pFirst;
                        delete pSecond;

                        throw ;
                    }

                    delete pFirst;
                    delete pSecond;
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_OR:
                {
                    if(ExprStack.size() < 2)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        delete pNew ;
                        break;
                    }

                    SQL_LEVEL_1_RPN_EXPRESSION *pFirst = ExprStack.top(); 
                    ExprStack.pop();

                    SQL_LEVEL_1_RPN_EXPRESSION *pSecond = ExprStack.top(); 
                    ExprStack.pop();

                    try
                    {
                        hres = OrQueryExpressions(pFirst, pSecond, pNew);
                    }
                    catch ( ... )
                    {
                        delete pNew ;
                        delete pFirst;
                        delete pSecond;

                        throw ;
                    }

                    try
                    {
                        ExprStack.push(pNew);
                    }
                    catch ( ... )
                    {
                        delete pFirst;
                        delete pSecond;

                        throw ;
                    }

                    delete pFirst;
                    delete pSecond;
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
                {
                    if(ExprStack.size() < 1)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        delete pNew ;
                        break;
                    }

                    SQL_LEVEL_1_RPN_EXPRESSION *pFirst = ExprStack.top(); 
                    ExprStack.pop();

                    // No information

                    try
                    {
                        ExprStack.push(pNew);
                    }
                    catch ( ... )
                    {
                        delete pFirst ;

                        throw ;
                    }

                    delete pFirst;
                }
                break;

                default:
                {
                    hres = WBEM_E_CRITICAL_ERROR;
                    delete pNew;            
                }
                break ;
            }

            if(FAILED(hres))
            {
                // An error occurred, break out of the loop
                // ========================================

                break;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    
    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }
        
    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        AutoDestructStack ( ExprStack )

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();

    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty (

   IN SQL_LEVEL_1_TOKEN &Token,
   IN LPCWSTR wszPropName
)
{
    return (_wcsicmp(wszPropName, Token.pPropertyName) == 0);
}

void CQueryAnalyser::AppendQueryExpression (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pDest,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSource
)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(pSource->pArrayOfTokens[i]);
        if ( pToken )
        {
            pDest->AddToken(pToken);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
    OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
)
{
    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    SQL_LEVEL_1_TOKEN Token;
    Token.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
    SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(Token);
    if ( pToken )
    {
        pNew->AddToken(pToken);
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
    OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
)
{
    // If either one is empty, so is the result
    // ======================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    SQL_LEVEL_1_TOKEN Token;
    Token.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
    SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(Token);
    if ( pToken )
    {
        pNew->AddToken(pToken);
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    CHStringArray &awsVals
)
{
    awsVals.RemoveAll();

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        { 
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {

            // We treat them all as ORs
            // ========================

            }
            break; 

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_BSTR)
                {
                    delete pPropExpr;
                    return WBEM_E_TYPE_MISMATCH;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                awsVals.Add(CHString(V_BSTR(&Token.vConstValue)));
            }
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<_bstr_t> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];

        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
            // We treat them all as ORs
            // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_BSTR)
                {
                    delete pPropExpr;
                    return WBEM_E_INVALID_QUERY;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(_bstr_t(V_BSTR(&Token.vConstValue)));
            }   
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}


HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<int> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
                // We treat them all as ORs
                // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_I4)
                {
                    delete pPropExpr;
                    return WBEM_E_INVALID_QUERY;
                }

                // This token is an int equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(V_I4(&Token.vConstValue));
            }
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<_variant_t> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
                // We treat them all as ORs
                // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(_variant_t(Token.vConstValue));
            }
            break ;
        }
    }

    delete pPropExpr;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\test_par.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    test_par.cpp

Abstract:

    Test program for CObjectPathParser objects

History:

--*/

#include "precomp.h"
#include "genlex.h"
#include "objpath.h"

BOOL bVerbose = FALSE;

void fatal(int n)
{
    printf("\n*** Test failed on source line %d ***\n", n);
    exit(1);
}

void DisplayVariant(VARIANT * pvar)
{
    SCODE sc;
    VARTYPE vSave;
    VARTYPE vtSimple = pvar->vt & ~VT_ARRAY & ~VT_BYREF;

    VARIANT vTemp;
    if(pvar->vt == VT_NULL)
    {
        printf(" data is NULL");
        return;
    }

     // keep in mind that our bstr are acutally WCHAR * in this context.

     if(vtSimple == VT_BSTR)
     {
         printf(" Type is 0x%x, value is %S", pvar->vt, pvar->bstrVal);
         return;
     }


    VariantInit(&vTemp);
    vSave = pvar->vt;
    pvar->vt = vtSimple;
    sc = VariantChangeTypeEx(&vTemp, pvar,0,0, VT_BSTR);
    pvar->vt = vSave;
    if(sc == S_OK)
    {
        printf(" Type is 0x%x, value is %S", pvar->vt, vTemp.bstrVal);
    }
    else
        printf(" Couldnt convert type 0x%x, error code 0x%x", pvar->vt, sc);
    VariantClear(&vTemp);
}

void DumpIt(WCHAR * pTest, ParsedObjectPath * pOutput)
{
    DWORD dwCnt;
    if(!bVerbose)
        return;
    printf("\n\nTesting -%S-", pTest);
    if(pOutput == NULL)
        return;
    printf("\nClass is, %S, Singleton is %d", pOutput->m_pClass, pOutput->m_bSingletonObj);
    printf("\nNumber of keys is %d", pOutput->m_dwNumKeys);
    for(dwCnt = 0; dwCnt < pOutput->m_dwNumKeys; dwCnt++)
    {
        printf(" -%S-", pOutput->m_paKeys[dwCnt]->m_pName);
        DisplayVariant((&pOutput->m_paKeys[dwCnt]->m_vValue));
    
    }
    printf("\nNumber of namespaces is %d", pOutput->m_dwNumNamespaces);
    for(dwCnt = 0; dwCnt < pOutput->m_dwNumNamespaces; dwCnt++)
        printf(" -%S-", pOutput->m_paNamespaces[dwCnt]);
}

// this tests a normal single key path

void test1()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=\"a\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}


// this tests a singleton

void test2()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=@";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 0)
        fatal(__LINE__);
    if(!pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);

    delete pRet;
    delete pOutput;
}

// this tests a multiple key path

void test3()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass.key=23,key2=\"xx\"";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 2)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// this tests an error in a single key path - missing closing quote

void test4()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=\"hello";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet == CObjectPathParser::NoError)
        fatal(__LINE__);
}

// this tests forward path slashes and a mix of slashes in the key

void test5()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"//./root/default:MyClass.key=\"ab/c\\\\def\"";    // it takes four '\'s within a quoted string to yield a single '\'
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// This tests unicode

void test6()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"//./root/\x0100xde\231faul\xffef:MyClass.\x0100\231\xffef=\"\x0100\xffef\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);

    // note that the dump will not output much information since printf doesnt like unicode

    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[0],L"root"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[1],L"\x0100xde\231faul\xffef"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_pName,L"\x0100\231\xffef"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_vValue.bstrVal,L"\x0100\xffef"))
        fatal(__LINE__);

    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// This tests association type paths

void test7()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"\\\\.\\root\\default:Win32Users.Ant=\"\\\\\\\\WKSTA\\\\root\\\\default:System.Name=\\\"WKSTA\\\"\",Dep=\"Win32User.Name=\\\".Default\\\"\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);

    // note that the dump will not output much information since printf doesnt like unicode

    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"Win32Users"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[0],L"root"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[1],L"default"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_pName,L"Ant"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_vValue.bstrVal,
            L"\\\\WKSTA\\root\\default:System.Name=\"WKSTA\""))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[1]->m_pName,L"Dep"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[1]->m_vValue.bstrVal,L"Win32User.Name=\".Default\""))
        fatal(__LINE__);


    if(pOutput->m_dwNumKeys != 2)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}


int main(int argc, char **argv)
{
    int i;
    bVerbose = TRUE;
    for(i = 0; i< 1; i++)
    {
        printf("\ndoing test %d",i);
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\stdlibrary\sql_1.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SQL_1.CPP

Abstract:

  Level 1 Syntax SQL Parser

  Implements the syntax described in SQL_1.BNF.  This translates the input
  into an RPN stream of tokens.

History:

  21-Jun-96       Created.

--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>
#include <autoptr.h>

class CX_Exception {};

class CX_MemoryException : CX_Exception {};

//#define trace(x) printf x
#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    Init(pSrc);
}

SQL1_Parser::~SQL1_Parser()
{
    Cleanup();
}

void SQL1_Parser::Init(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_pExpression = 0;
    m_pLexer = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
    m_pPropComp = 0;
    m_bConstIsStrNumeric = FALSE;

    if (pSrc)
    {
        wmilib :: auto_ptr<CGenLexer> t_pLexer ( new CGenLexer(Sql_1_LexTable, pSrc) );
		if (! t_pLexer.get())
			throw CX_MemoryException();

        wmilib :: auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> t_pExpression ( new SQL_LEVEL_1_RPN_EXPRESSION ) ;
		if (! t_pExpression.get())
			throw CX_MemoryException();

		m_pLexer = t_pLexer.release () ;
		m_pExpression = t_pExpression.release () ;
    }
}

void SQL1_Parser::Cleanup()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pPropComp;
    delete m_pLexer;
    delete m_pExpression;
}

void SQL1_Parser::SetSource(CGenLexSource *pSrc)
{
    Cleanup();
    Init(pSrc);
}

int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    if ((!m_pLexer) || (!pDestBuf))
    {
        return FAILED;
    }

    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            wcscpy(pDestBuf, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    if ((!m_pLexer) || (!pOutput))
    {
        return FAILED;
    }

    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

LPSTR ToAnsi(LPWSTR Src)
{
    static char buf[256];
    WideCharToMultiByte(CP_ACP, NULL, Src, -1, buf, 256, NULL, NULL);
    return buf;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"65535";
        }
        else if (_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            // We need to clean up the expression so far.
            for (int i = 0; i < m_pExpression->nNumberOfProperties; i++)
                SysFreeString(m_pExpression->pbsRequestedPropertyNames[i]);

            m_pExpression->nNumberOfProperties = 0;
                // This signals 'all properties' to the evaluator
            return SUCCESS;
        }

        // Else a property name.
        // =====================

        trace(("Property name %S\n", m_pTokenText));

        m_pExpression->AddProperty(m_pTokenText);
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);
	if ( ! m_pExpression->bsClassName )
	{
		throw CX_MemoryException();
	}

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
			if ( ! pNewTok )
				throw CX_MemoryException();

            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
			if ( ! pNewTok )
			{
				throw CX_MemoryException();
			}

            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
		if ( ! pNewTok )
		{
			throw CX_MemoryException();
		}

        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (!m_pIdent)
    {
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        wcscpy(m_pIdent, m_pTokenText);
    }
    else
    {
        m_pPropComp = new wchar_t[wcslen(m_pTokenText) + 1];
		if ( ! m_pPropComp )
		{
			throw CX_MemoryException();
		}

        wcscpy(m_pPropComp, m_pTokenText);
    }

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator() || SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//  <trailing_or_null> ::= <trailing_prop_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    else if (!(nRes = trailing_const_expr()))
        return nRes;
    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);
        if (!m_dwConstFunction)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
    if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    wmilib :: auto_ptr<SQL_LEVEL_1_TOKEN> pNewTok ( new SQL_LEVEL_1_TOKEN ) ;
	if (! pNewTok.get())
		throw CX_MemoryException();

    pNewTok.get()->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok.get()->pPropertyName = SysAllocString(m_pIdent);
	if ( ! pNewTok.get()->pPropertyName )
	{
		throw CX_MemoryException();
	}

    if (m_pPropComp)
	{
        pNewTok.get()->pPropName2 = SysAllocString(m_pPropComp);
		if ( ! pNewTok.get()->pPropName2 )
		{
			throw CX_MemoryException();
		}
	}

    pNewTok.get()->nOperator = m_nRelOp;
    VariantInit(&pNewTok.get()->vConstValue);
    VariantCopy(&pNewTok.get()->vConstValue, &m_vTypedConst);
    pNewTok.get()->dwPropertyFunction = m_dwPropFunction;
    pNewTok.get()->dwConstFunction = m_dwConstFunction;
    pNewTok.get()->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok.release ());

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
        DWORD x = wcslen(m_pTokenText);

        if (*m_pTokenText == L'-')
        {
            //negative

            if ((x < 11) ||
                ((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				if ( V_BSTR(&m_vTypedConst) == NULL )
				{
					throw CX_MemoryException();
				}

                m_bConstIsStrNumeric = TRUE;
            }
        }
        else
        {
            //positive

            if ((x < 10) ||
                ((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				if ( V_BSTR(&m_vTypedConst) == NULL )
				{
					throw CX_MemoryException();
				}

                m_bConstIsStrNumeric = TRUE;
            }
        }

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
		if ( V_BSTR(&m_vTypedConst) == NULL )
		{
			throw CX_MemoryException();
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        V_R8(&m_vTypedConst) = 0.0;

        if (m_pTokenText)
        {
            VARIANT varFrom;
            varFrom.vt = VT_BSTR;
            varFrom.bstrVal = SysAllocString(m_pTokenText);
            if(varFrom.bstrVal)
            {
                VariantClear(&m_vTypedConst);
                VariantInit(&m_vTypedConst);
                SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
                VariantClear(&varFrom);

                if(sc != S_OK)
                {
                    VariantClear(&m_vTypedConst);
                    VariantInit(&m_vTypedConst);
                    return LEXICAL_ERROR;
                }
            }
			else
			{
				throw CX_MemoryException();
			}
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_BOOL)
    {
        trace((" Bool\n"));
        V_VT(&m_vTypedConst) = VT_BOOL;
        if (m_pTokenText && _wcsicmp(m_pTokenText, L"65535") == 0)
        {
            V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
        }
        else
            V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;

    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
	if (! pArrayOfTokens)
		throw CX_MemoryException();

    pbsRequestedPropertyNames = new BSTR[nCurPropSize];
	if (! pbsRequestedPropertyNames)
		throw CX_MemoryException();
}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
	try
	{
	    AddToken(*pTok);
	}
	catch ( ... )
	{
		delete pTok;
		pTok = NULL;

		throw ;
	}

    delete pTok;
    pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
		if ( pTemp )
		{
			for (int i = 0; i < nNumTokens; i++)
				pTemp[i] = pArrayOfTokens[i];
			delete [] pArrayOfTokens;
			pArrayOfTokens = pTemp;
		}
		else
		{
			throw CX_MemoryException();
		}
    }

    pArrayOfTokens[nNumTokens++] = pTok;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty (LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;
        wmilib :: auto_ptr<BSTR> pTemp ( new BSTR[nCurPropSize] ) ;
        if (!pTemp.get())
            throw CX_MemoryException();

        if (pbsRequestedPropertyNames)
		{
            memcpy(pTemp.get(), pbsRequestedPropertyNames,
                sizeof(BSTR) * nNumberOfProperties);
		}
        else
        {
            throw CX_MemoryException();
        }

        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp.release();
    }

	BSTR pTemp = SysAllocString(pProp);
	if ( pTemp)
	{
		pbsRequestedPropertyNames[nNumberOfProperties++] = pTemp ;
	}
	else
	{
		throw CX_MemoryException();
	}

}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
    //first clear any old values...
    if (pPropertyName)
	{
        SysFreeString(pPropertyName);
		pPropertyName = NULL ;
	}

    if (pPropName2)
	{
        SysFreeString(pPropName2);
		pPropName2 = NULL ;
	}

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;

	if ( Src.pPropertyName )
	{
		pPropertyName = SysAllocString(Src.pPropertyName);
		if ( ! pPropertyName )
		{
			throw CX_MemoryException();
		}
	}

    if (Src.pPropName2)
	{
		pPropName2 = SysAllocString(Src.pPropName2);
		if ( ! pPropName2 )
		{
			throw CX_MemoryException();
		}
	}

    nOperator = Src.nOperator;
    if ( FAILED ( VariantCopy(&vConstValue, &Src.vConstValue) ) )
	{
		throw CX_MemoryException();
	}

    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bConstIsStrNumeric = Src.bConstIsStrNumeric;

    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");
        if (pPropName2)
            fprintf(f, "   <Property:%S\n", pPropName2);
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "VT_BOOL = %d (%s)\n",
                        V_BOOL(&vConstValue),
                        V_BOOL(&vConstValue) == VARIANT_TRUE ? "VARIANT_TRUE" : "VARIANT_FALSE"
                        );
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\autoimprevert.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CImpersonate class implementation
// Created:  6/3/2000
// Author: khughes

#include <precomp.h>
#include <chstring.h>
#include "AutoImpRevert.h"



CAutoImpRevert::CAutoImpRevert(
    BOOL fOpenAsSelf)
  : m_hOriginalUser(INVALID_HANDLE_VALUE),
    m_dwLastError(ERROR_SUCCESS)
{
    GetCurrentImpersonation(fOpenAsSelf);
}


CAutoImpRevert::~CAutoImpRevert()
{
    if(m_hOriginalUser != INVALID_HANDLE_VALUE)
    {
        Revert();
    }
}


bool CAutoImpRevert::GetCurrentImpersonation(
    BOOL fOpenAsSelf)
{
    bool fRet = false;
    ::SetLastError(ERROR_SUCCESS);
    m_dwLastError = ERROR_SUCCESS;

    // Store the current user's handle...
    if(::OpenThreadToken(
        ::GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        fOpenAsSelf,
        &m_hOriginalUser))
    {
        fRet = true;
    }
    else
    {
        m_dwLastError = ::GetLastError();
        if(m_dwLastError == ERROR_NO_TOKEN)
        {
            ::SetLastError(ERROR_SUCCESS);
            if(::ImpersonateSelf(SecurityImpersonation))
            {
                if(::OpenThreadToken(
                    ::GetCurrentThread(),
                    TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                    fOpenAsSelf,
                    &m_hOriginalUser))
                {
                    fRet = true;
                    m_dwLastError = ERROR_SUCCESS;
                }
                else
                {
                    m_dwLastError = ::GetLastError();
                }
            }
            else
            {
                m_dwLastError = ::GetLastError();
            }
        }
    }

    return fRet;
}



bool CAutoImpRevert::Revert()
{
    bool fRet = false;

    if(m_hOriginalUser != INVALID_HANDLE_VALUE)
    {
        if(::ImpersonateLoggedOnUser(m_hOriginalUser))
        {
            CloseHandle(m_hOriginalUser);
            m_hOriginalUser = INVALID_HANDLE_VALUE;
            fRet = true;
        }
        else
        {
            m_dwLastError = ::GetLastError();
        }    
    }
    
    return fRet;    
}

DWORD CAutoImpRevert::LastError() const
{
    return m_dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\assertbreak.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  AssertBreak.cpp
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#include "precomp.h"

#if defined(_DEBUG) || defined(DEBUG)
#include <polarity.h>
#include <assertbreak.h>
#ifdef UTILLIB
#include <cregcls.h>
#endif
#include <chstring.h>
#include <malloc.h>

#include <cnvmacros.h>

////////////////////////////////////////////////////////////////////////
//
//  Function:   assert_break
//
//  Debug Helper function for displaying a message box
//
//  Inputs:     const char* pszReason - Reason for the  failure.
//              const char* pszFilename - Filename
//              int         nLine - Line Number
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFileName, int nLine )
{
    
    DWORD t_dwFlag = 0; //

#ifdef UTILLIB
    CRegistry   t_Reg;
    if(t_Reg.Open(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    KEY_READ) == ERROR_SUCCESS) 
    {

        // see if we can find the flag
        if((t_Reg.GetCurrentKeyValue(L"IgnoreAssert", t_dwFlag) != ERROR_SUCCESS))
        {
            t_dwFlag = 0;
        }
    }

#endif

    if (t_dwFlag == 0)
    {
        CHString    strAssert;

        strAssert.Format( L"Assert Failed\n\n[%s:%d]\n\n%s\n\nBreak into Debugger?", pszFileName, nLine, pszReason );

        // Set the MB flags correctly depending on which OS we are running on, since in NT we may
        // be running as a System Service, in which case we need to ensure we have the
        // MB_SERVICE_NOTIFICATION flag on, or the message box may not actually display.

        DWORD   dwFlags = MB_YESNO | MB_ICONSTOP;
        OSVERSIONINFOA OsVersionInfoA;

        OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
        GetVersionExA(&OsVersionInfoA);

        if ( OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Flag changed between OS's (sigh)
            if ( 4 <= OsVersionInfoA.dwMajorVersion )
            {
                dwFlags |= MB_SERVICE_NOTIFICATION;
            }
            else
            {
                dwFlags |= MB_SERVICE_NOTIFICATION_NT3X;
            }
        }

        // Now display the message box.

        int iRet;
        if (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            iRet = MessageBoxW( NULL, strAssert, L"Assertion Failed!", dwFlags);
        }
        else
        {
            bool t_ConversionFailure = false ;
            char *szAssert = NULL ;

            WCSTOANSISTRING(strAssert, szAssert, t_ConversionFailure );
            if ( ! t_ConversionFailure ) 
            {
                if ( szAssert )
                {
                    iRet = MessageBoxA( NULL, szAssert, "Assertion Failed!", dwFlags);
                }
            }
        }

        if (iRet == IDYES)
        {
            DebugBreak();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\chstrarr.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  ChStrArr.CPP
//
//  Purpose: utility library version of MFC CStringArray
//
//***************************************************************************

/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <chstring.h>
#include <chstrarr.h>              
#include <AssertBreak.h>

extern LPCWSTR afxPchNil;
extern const CHString& afxGetEmptyCHString();

#define afxEmptyCHString afxGetEmptyCHString()


/////////////////////////////////////////////////////////////////////////////
// Special implementations for CHStrings
// it is faster to bit-wise copy a CHString than to call an official
// constructor - since an empty CHString can be bit-wise copied
/////////////////////////////////////////////////////////////////////////////
static inline void ConstructElement(CHString* pNewData)
{
    memcpy(pNewData, &afxEmptyCHString, sizeof(CHString));
}

/////////////////////////////////////////////////////////////////////////////
static inline void DestructElement(CHString* pOldData)
{
    pOldData->~CHString();
}

/////////////////////////////////////////////////////////////////////////////
static inline void CopyElement(CHString* pSrc, CHString* pDest)
{
    *pSrc = *pDest;
}

/////////////////////////////////////////////////////////////////////////////
static void ConstructElements(CHString* pNewData, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        ConstructElement(pNewData);
        pNewData++;
    }
}

/////////////////////////////////////////////////////////////////////////////
static void DestructElements(CHString* pOldData, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        DestructElement(pOldData);
        pOldData++;
    }
}

/////////////////////////////////////////////////////////////////////////////
static void CopyElements(CHString* pDest, CHString* pSrc, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        *pDest = *pSrc;
        ++pDest;
        ++pSrc;
    }
}

/////////////////////////////////////////////////////////////////////////////
CHStringArray::CHStringArray() :    m_pData ( NULL ) ,
                                    m_nSize ( 0 ) ,
                                    m_nMaxSize ( 0 ) ,
                                    m_nGrowBy ( 0 )

{
}

/////////////////////////////////////////////////////////////////////////////
CHStringArray::~CHStringArray()
{
    DestructElements(m_pData, m_nSize);
    delete[] (BYTE*)m_pData;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_BREAK(nNewSize >= 0);

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy;  // set new size
    }

    if (nNewSize == 0)
    {
        // shrink to nothing

        DestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
#ifdef SIZE_T_MAX
        ASSERT_BREAK(nNewSize <= SIZE_T_MAX/sizeof(CHString));    // no overflow
#endif

        // create one with exact size

        m_pData = (CHString*) new BYTE[nNewSize * sizeof(CHString)];
        if ( m_pData )
        {
            ConstructElements(m_pData, nNewSize);

            m_nSize = m_nMaxSize = nNewSize;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

        }
        else if (m_nSize > nNewSize)  // destroy the old elements
        {
            DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }

        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        }
        else
        {
            nNewMax = nNewSize;  // no slush
        }

        ASSERT_BREAK(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT_BREAK(nNewMax <= SIZE_T_MAX/sizeof(CHString)); // no overflow
#endif

        CHString* pNewData = (CHString*) new BYTE[nNewMax * sizeof(CHString)];
        if ( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CHString));

            // construct remaining elements
            ASSERT_BREAK(nNewSize > m_nSize);

            ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
int CHStringArray::Append(const CHStringArray& src)
{
    ASSERT_BREAK(this != &src);   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);

    return nOldSize;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::Copy(const CHStringArray& src)
{
    ASSERT_BREAK(this != &src);   // cannot append to itself

    SetSize(src.m_nSize);

    CopyElements(m_pData, src.m_pData, src.m_nSize);

}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size

#ifdef SIZE_T_MAX
        ASSERT_BREAK(m_nSize <= SIZE_T_MAX/sizeof(CHString)); // no overflow
#endif

        CHString* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CHString*) new BYTE[m_nSize * sizeof(CHString)];
            if ( pNewData )
            {
                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(CHString));
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::SetAtGrow(int nIndex, LPCWSTR newElement)
{
    ASSERT_BREAK(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        SetSize(nIndex+1);
    }

    m_pData[nIndex] = newElement;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::InsertAt(int nIndex, LPCWSTR newElement, int nCount)
{
    ASSERT_BREAK(nIndex >= 0);    // will expand to meet need
    ASSERT_BREAK(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CHString));

        // re-init slots we copied from

        ConstructElements(&m_pData[nIndex], nCount);

    }

    // insert new value in the gap
    ASSERT_BREAK(nIndex + nCount <= m_nSize);
    while (nCount--)
    {
        m_pData[nIndex++] = newElement;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::RemoveAt(int nIndex, int nCount)
{
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nCount >= 0);
    ASSERT_BREAK(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    DestructElements(&m_pData[nIndex], nCount);

    if (nMoveCount)
    {
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CHString));
    }

    m_nSize -= nCount;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::InsertAt(int nStartIndex, CHStringArray* pNewArray)
{
    ASSERT_BREAK(pNewArray != NULL);
    ASSERT_BREAK(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }
}

#if (defined DEBUG || defined _DEBUG)
CHString CHStringArray::GetAt(int nIndex) const
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex]; 
}

void CHStringArray::SetAt(int nIndex, LPCWSTR newElement)
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    m_pData[nIndex] = newElement; 
}

CHString& CHStringArray::ElementAt(int nIndex)  
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex]; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\common.inc ===
#######################################################################

#

# Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#
# utillib Makefile
#
########################################################################

TARGET=utillib.lib

RELEASE=LIB\$(RELDIR)

CFLAGS=$(CFLAGS) -DUTILLIB -D_MBCS -D_DLL -DUSE_POLARITY -DBUILDING_DLL -DWIN32 -D_WINDOWS /YXwindows.h /Fp$(objdir)\utillib.pch /GF

CINC=$(CINC)\
	-I$(DEFDRIVE)$(DEFDIR)\INCLUDE \
	-I$(DEFDRIVE)$(DEFDIR)\IDL \
	-I$(DEFDRIVE)$(DEFDIR)\IDL\$(OBJDIR) \
	-I$(DEFDRIVE)$(DEFDIR)\StdLibrary \
    -I$(DEFDRIVE)$(DEFDIR)\Win32Provider\Framework\include \

CPPFILES=\
	CRegCls.CPP \
	analyser.cpp \
	assertbreak.cpp \
	CHPtrArr.cpp \
	CHStrarr.CPP \
	CHString.CPP \
	utils.cpp \
	WbemTime.CPP \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=utillib

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(UTILLIB_INC); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \

SOURCES= \
	..\CRegCls.CPP \
	..\analyser.cpp \
	..\assertbreak.cpp \
	..\CHPtrArr.cpp \
	..\CHStrarr.CPP \
	..\CHString.CPP \
	..\wbemtime.cpp \
	..\utils.cpp \
	..\AutoImpRevert.cpp

C_DEFINES=$(C_DEFINES) /DUTILLIB /D_DLL /DUSE_POLARITY /DBUILDING_DLL /DFRAMEWORK_ALLOW_DEPRECATED=0
USE_NATIVE_EH=ASYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\cregcls.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  cregcls.cpp
//
//  Purpose: registry wrapper class
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>

#include <stdio.h>
#include "CRegCls.h"
#include <malloc.h>
#include <cnvmacros.h>


DWORD CRegistry::s_dwPlatform = CRegistry::GetPlatformID () ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CRegistry::CRegistry()
 : m_fFromCurrentUser(false)
{
  
// Set the key to null so that if the caller does not open the key
// but still tries to use it we can return an error

    hKey = (HKEY)NULL;
    hSubKey = (HKEY)NULL;
    hRootKey = (HKEY)NULL;

// To prevent garbage values being returned if they try to get
// some information before they open the class

    SetDefaultValues();
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CRegistry::~CRegistry()
{
    Close();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::SetDefaultValues()
{
    // Information inited here rather than constructor so that this instance
    // can be reused

    ClassName[0] = '\0';
    dwcClassLen = MAX_PATH;         // Length of class string.
    dwcSubKeys = NULL_DWORD;        // Number of sub keys.
    dwcMaxSubKey = NULL_DWORD;      // Longest sub key size.
    dwcMaxClass = NULL_DWORD;       // Longest class string.
    dwcValues = NULL_DWORD;         // Number of values for this key.
    dwcMaxValueName = NULL_DWORD;   // Longest Value name.
    dwcMaxValueData = NULL_DWORD;   // Longest Value data.
    RewindSubKeys();                // Rewind the index to zero
  
    RootKeyPath.Empty();
}

////////////////////////////////////////////////////////////////
//  Function:       EnumerateAndGetValues
//  Description:    This function enumerates the values under the
//                  specified key and gets the value, keeps on
//                  going and going... until there aren't any more
//                  values to get.  The first call must set the
//                  value index to 0, this indicates for the function
//                  to start over;
//
//
//  NOTE!!!!    The USER has the responsibility of deleting the 
//              allocated memory for pValueName and pValueData
//
//
//  Arguments:
//  Returns:    Standard return value from registry open function
//  Inputs:
//  Outputs:
//  Caveats:
//  Raid:
////////////////////////////////////////////////////////////////
LONG CRegistry::EnumerateAndGetValues (

    DWORD &dwIndexOfValue,
    WCHAR *&pValueName,
    BYTE *&pValueData
)
{
    DWORD dwIndex = dwIndexOfValue, dwType;
    DWORD dwValueNameSize = dwcMaxValueName + 2;  // add extra for null
    DWORD dwValueDataSize = dwcMaxValueData + 2;  // add extra for null

    // If this is the first time we have come thru, then we
    // need to get the max size of things.

    pValueName = new WCHAR[dwValueNameSize + 2];
    if ( ! pValueName )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    // We have to use WCHAR's since for 9x, we'll be converting the
    // data from chars to WCHARs.
    pValueData = (LPBYTE) new WCHAR[dwValueDataSize + 2];
    if ( ! pValueData )
    {
        delete [] pValueName ;
		pValueName = NULL;
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    LONG lRc = ERROR_SUCCESS ;

    try 
    {
        lRc = myRegEnumValue (

            hKey,               // handle of key to query 
            dwIndex,            // index of value to query 
            pValueName,         // address of buffer for value string 
            &dwValueNameSize,   // address for size of value buffer 
            0,                  // reserved 
            &dwType,            // address of buffer for type code 
            pValueData,         // address of buffer for value data 
            &dwValueDataSize 
        ) ;

        dwIndexOfValue = dwIndex;

        if ( lRc != ERROR_SUCCESS )
        {
            delete[] pValueName;
            pValueName = NULL ;

            delete[] pValueData;
            pValueData = NULL ;
        }
    }
    catch ( ... )
    {
        delete[] pValueName;
        pValueName = NULL ;

        delete[] pValueData;
        pValueData = NULL ;

        throw ;                 // throw the exception up
    }

    return lRc ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::OpenCurrentUser(LPCWSTR lpszSubKey, REGSAM samDesired)  
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

DWORD CRegistry::OpenCurrentUser (
    LPCWSTR lpszSubKey,      // address of name of subkey to open 
    REGSAM samDesired)       // Access mask
{
    LONG RetValue = ERROR_SUCCESS; 

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance
    PrepareToReOpen();
 
    RetValue = ::RegOpenCurrentUser(
        samDesired,
        &hRootKey);

    m_fFromCurrentUser = true;
        
    if(RetValue == ERROR_SUCCESS)
    {
        // Just return the value and the hKey value never gets changed from NULL
        //======================================================================

        RetValue = myRegOpenKeyEx (

            hRootKey, 
            lpszSubKey,     // address of name of subkey to open 
            (DWORD) 0,      // reserved 
            samDesired,     // security access mask 
            (PHKEY)&hKey    // address of handle of open key 

        ); 

        // If we are not successful, then return the registry error
        //=========================================================

        if(RetValue == ERROR_SUCCESS) 
        {
            dwcClassLen = sizeof(ClassName);

            // Get the key information now, so it's available
            // this is not critical, so we won't fail the open if this fails
            //===============================================

            myRegQueryInfoKey (

                hKey,               // Key handle.
                ClassName,          // Buffer for class name.
                &dwcClassLen,       // Length of class string.
                NULL,               // Reserved.
                &dwcSubKeys,        // Number of sub keys.
                &dwcMaxSubKey,      // Longest sub key size.
                &dwcMaxClass,       // Longest class string.
                &dwcValues,         // Number of values for this key.
                &dwcMaxValueName,   // Longest Value name.
                &dwcMaxValueData,   // Longest Value data.
                &dwcSecDesc,        // Security descriptor.
                &ftLastWriteTime    // Last write time.

            ); 
  
            RootKeyPath = lpszSubKey;    // Assign 
        }
    }

    return RetValue;
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::Open(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired)  
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::Open(

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey, 
    REGSAM samDesired
)
{
    LONG RetValue; 

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance

    if(hKey != NULL) 
    {
        PrepareToReOpen();
    }
 
    hRootKey = hInRootKey;

    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================

    RetValue = myRegOpenKeyEx (

        hRootKey, 
        lpszSubKey,     // address of name of subkey to open 
        (DWORD) 0,      // reserved 
        samDesired,     // security access mask 
        (PHKEY)&hKey    // address of handle of open key 

    ); 

    // If we are not successful, then return the registry error
    //=========================================================

    if(RetValue != ERROR_SUCCESS) 
    {
        return RetValue;
    }

    dwcClassLen = sizeof(ClassName);

    // Get the key information now, so it's available
    // this is not critical, so we won't fail the open if this fails
    //===============================================

    myRegQueryInfoKey (

        hKey,               // Key handle.
        ClassName,          // Buffer for class name.
        &dwcClassLen,       // Length of class string.
        NULL,               // Reserved.
        &dwcSubKeys,        // Number of sub keys.
        &dwcMaxSubKey,      // Longest sub key size.
        &dwcMaxClass,       // Longest class string.
        &dwcValues,         // Number of values for this key.
        &dwcMaxValueName,   // Longest Value name.
        &dwcMaxValueData,   // Longest Value data.
        &dwcSecDesc,        // Security descriptor.
        &ftLastWriteTime    // Last write time.

    ); 
  
    RootKeyPath = lpszSubKey;    // Assign 

    return ERROR_SUCCESS;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::CreateOpen(HKEY hInRootKey, 
                           LPCWSTR lpszSubKey,
                           LPSTR lpClass = NULL, 
                           DWORD dwOptions = REG_OPTION_NON_VOLATILE, 
                           REGSAM samDesired = KEY_ALL_ACCESS,
                           LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL
                           LPDWORD pdwDisposition = NULL ); 
 Description:
 Arguments: lpClass, dwOptions, samDesired and lpSecurityAttrib have signature defaults
 Returns:   Standard return value from registry RegCreateKeyEx function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:                   a-peterc  28-Jul-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::CreateOpen (

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey,
    LPWSTR lpClass, 
    DWORD dwOptions, 
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttrib,
    LPDWORD pdwDisposition 
)
{
    LONG RetValue; 
    DWORD dwDisposition;

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance
    if(hKey != NULL) 
    {
        PrepareToReOpen();
    }
 
    hRootKey = hInRootKey;

    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================
    RetValue = myRegCreateKeyEx (

        hRootKey, 
        lpszSubKey,         // address of name of subkey to open 
        (DWORD) 0,          // reserved
        lpClass,            // address of the object class string
        dwOptions,          // special options flag
        samDesired,         // security access mask
        lpSecurityAttrib,   // address of the key security structure 
        (PHKEY)&hKey,       // address of handle of open key
        &dwDisposition      // address of the disposition value buffer   
    );  
  
    // If we are not successful, then return the registry error
    //=========================================================

    if(RetValue != ERROR_SUCCESS) 
    {
        return RetValue;
    }

    if( pdwDisposition )
    {
        *pdwDisposition = dwDisposition;
    }

    // Get the key information now, so it's available
    // this is not critical, so we won't fail the open if this fails
    //===============================================

    myRegQueryInfoKey (

        hKey,               // Key handle.
        ClassName,          // Buffer for class name.
        &dwcClassLen,       // Length of class string.
        NULL,               // Reserved.
        &dwcSubKeys,        // Number of sub keys.
        &dwcMaxSubKey,      // Longest sub key size.
        &dwcMaxClass,       // Longest class string.
        &dwcValues,         // Number of values for this key.
        &dwcMaxValueName,   // Longest Value name.
        &dwcMaxValueData,   // Longest Value data.
        &dwcSecDesc,        // Security descriptor.
        &ftLastWriteTime    // Last write time.
    ); 
  
    RootKeyPath = lpszSubKey;    // Assign 

    return ERROR_SUCCESS;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      DWORD CRegistry::DeleteKey( CHString* pchsSubKeyPath = NULL )   

 Description:   deletes the specified subkey or the Rootkey specified in the open

 Arguments:     pchsSubKeyPath has signature default of NULL, 
                    specifying the RootKeyPath by default 

 Returns:       Standard return value from registry RegDeleteKey function       
 Inputs:
 Outputs:
 Caveats:       A deleted key is not removed until the last handle to it has been closed.
                Subkeys and values cannot be created under a deleted key.               
 Raid:
 History:                   a-peterc  28-Jul-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::DeleteKey( CHString* pchsSubKeyPath )
{ 
    CHString* pSubKey = pchsSubKeyPath ? pchsSubKeyPath : &RootKeyPath;

    return myRegDeleteKey( hKey, pSubKey->GetBuffer(0) );
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      DWORD CRegistry::DeleteValue( LPCWSTR pValueName )  

 Description:   deletes the specified value in the createopen

 Arguments:     pValueName to be deleted

 Returns:       Standard return value from registry RegDeleteValue function     
 Inputs:
 Outputs:
 Caveats:                   
 Raid:
 History:                   a-peterc  30-Sep-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::DeleteValue( LPCWSTR pValueName )
{ 
    return myRegDeleteValue( hKey, pValueName );
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::OpenAndEnumerateSubKeys(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired)   
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::OpenAndEnumerateSubKeys (

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey, 
    REGSAM samDesired
)
{
    return (Open( hInRootKey,  lpszSubKey,  samDesired | KEY_ENUMERATE_SUB_KEYS));
}


/////////////////////////////////////////////////////////////////////
//
//  This function opens and enumerates a key, then gets the requested
//  value
//
/////////////////////////////////////////////////////////////////////
LONG CRegistry::OpenLocalMachineKeyAndReadValue(

    LPCWSTR lpszSubKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{ 
    LONG lRc;

    //===============================================
    //  Open the key.  Note, if it is already in use
    //  the current key will be closed and everything
    //  reinitilized by the Open call
    //===============================================

    lRc = Open( HKEY_LOCAL_MACHINE,lpszSubKey,KEY_READ );
    if( lRc != ERROR_SUCCESS )
    {
        return lRc;
    }

    //===============================================
    // Get the value
    //===============================================
    return( GetCurrentKeyValue( pValueName, DestValue ));
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentRawKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pValueType, 
    LPDWORD pSizeOfDestValue
)
{
    DWORD RetValue;


// If subkey is open then get value
// ================================

    RetValue = myRegQueryValueEx( 

        UseKey,                     // handle of key to query 
        pValueName,                 // address of name of value to query 
        NULL,                       // reserved 
        pValueType,                 // address of buffer for value type 
        (LPBYTE) pDestValue,        // address of data buffer 
        (LPDWORD)pSizeOfDestValue   // address of data buffer size 
    );  

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD SizeOfValue = 0L;
    DWORD TypeOfValue;
    LPBYTE pValue = NULL ;      // Pointer to buffer for value

    DestValue = L"";

    LONG t_Status = myRegQueryValueEx( 

        UseKey,                     // handle of key to query 
        pValueName,                 // address of name of value to query 
        NULL,                       // reserved 
        (LPDWORD)&TypeOfValue,      // address of buffer for value type 
        (LPBYTE) NULL,              // address of data buffer NULL to force size being returned 
        (LPDWORD)&SizeOfValue       // Get the size of the buffer we need 
    ) ;
                                            
    if( t_Status != ERROR_SUCCESS )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }
 
    /////////////////////////////////////////////////////////////
    if( SizeOfValue <= 0 )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    // Allow extra room for strings -- query doesn't include room for NULLs
    //      a-jmoon 8/19/97
    //=====================================================================

    if(TypeOfValue == REG_SZ        ||
       TypeOfValue == REG_EXPAND_SZ ||    
       TypeOfValue == REG_MULTI_SZ) 
    {
        SizeOfValue += 2 ;
    }

    pValue = new BYTE[SizeOfValue];
    if( ! pValue )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        ///////////////////////////////////////////////////////////////////
        // Get the value in its RAW format
        ///////////////////////////////////////////////////////////////////
        if( GetCurrentRawKeyValue(UseKey, pValueName, pValue, (LPDWORD)&TypeOfValue, (LPDWORD)&SizeOfValue) != ERROR_SUCCESS )
        {
            delete []pValue;
			pValue = NULL;
            return (DWORD) REGDB_E_INVALIDVALUE;
        }  

        // If the type is a null termiated string
        // then assign it to the CHString
        // ======================================

        switch(TypeOfValue)
        {
            case REG_SZ:
            case REG_EXPAND_SZ:
            {
                DestValue = (LPCWSTR)pValue;  // Move string in
            }
            break;

            case REG_MULTI_SZ:
            {
                WCHAR *ptemp = (WCHAR *) pValue;
                int stringlength;
                stringlength = wcslen((LPCWSTR)ptemp);
                while(stringlength) 
                {
                    DestValue += (LPCWSTR)ptemp;  // Move string in
                    DestValue += L"\n";            // Linefeed as separator
                    ptemp += stringlength+1;
                    stringlength = wcslen((LPCWSTR)ptemp);
                }
            }       
            break;

            case REG_DWORD:
            {
                LPWSTR pTemp = new WCHAR[MAX_SUBKEY_BUFFERSIZE];
                if(pTemp) 
                {
                    try
                    {
                        swprintf(pTemp, L"%ld", *((DWORD*)pValue));
                        DestValue = pTemp;
                        delete []pTemp;
						pTemp = NULL;
                    }
                    catch ( ... )
                    {
                        delete [] pTemp ;
						pTemp = NULL;
                        throw ;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }     
            break;

            case REG_BINARY:
            {
               DestValue.Empty();
              
               // copy into DestValue, Creating a byte buffer wide enough. 
               // Note: SizeOfValue is in bytes, while GetBuffer() returns wide char allocation.
               
               DWORD t_dwResidual = ( SizeOfValue % 2 ) ;
               DWORD t_dwWideSize = ( SizeOfValue / 2 ) + t_dwResidual ;

               memcpy( DestValue.GetBuffer( t_dwWideSize ), pValue, SizeOfValue );
               
               // cap the byte blob  
               if( t_dwResidual )
               {
                    *( (LPBYTE)((LPCWSTR) DestValue) + SizeOfValue ) = NULL;
               }
               
               DestValue.GetBufferSetLength( t_dwWideSize ) ;
            }
            break;

            default:
            {
                delete []pValue;
				pValue = NULL;
                return (DWORD) REGDB_E_INVALIDVALUE;
            }
        }
    }
    catch ( ... )
    {
        delete []pValue;
		pValue = NULL;
		throw;
    }

    /////////////////////////////////////////////////////////////
    delete []pValue;

    return (DWORD)ERROR_SUCCESS;
}
 
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue(LPCWSTR pValueName, CHString &DestValue)
{
    return( GetCurrentKeyValue(hKey,  pValueName,  DestValue));
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue(HKEY UseKey, LPCWSTR pValueName, CHStringArray &DestValue)
{
    DWORD SizeOfValue = 0L;
    DWORD TypeOfValue;
    LPBYTE pValue;      // Pointer to buffer for value

    DestValue.RemoveAll();

    // Get the size of the buffer we need 

    LONG t_Status = myRegQueryValueEx( 

        UseKey,                 // handle of key to query 
        pValueName,             // address of name of value to query 
        NULL,                   // reserved 
        (LPDWORD)&TypeOfValue,  // address of buffer for value type 
        (LPBYTE) NULL,          // address of data buffer NULL to force size being returned 
        (LPDWORD)&SizeOfValue 
    ) ;

    if( t_Status != ERROR_SUCCESS )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }
 
    /////////////////////////////////////////////////////////////
    if (( SizeOfValue <= 0 ) || (TypeOfValue != REG_MULTI_SZ)) 
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    SizeOfValue += 2 ;

    pValue = new BYTE[SizeOfValue];
    if( !pValue )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    ///////////////////////////////////////////////////////////////////
    // Get the value in its RAW format
    ///////////////////////////////////////////////////////////////////

    try {

        if( GetCurrentRawKeyValue(UseKey, pValueName, pValue, (LPDWORD)&TypeOfValue, (LPDWORD)&SizeOfValue) != ERROR_SUCCESS )
        {
            delete []pValue;
			pValue = NULL;
            return (DWORD) REGDB_E_INVALIDVALUE;
        }  

        // If the type is a null termiated string
        // then assign it to the CHString
        // ======================================

        switch(TypeOfValue)
        {
            case REG_MULTI_SZ:
            {
                LPCWSTR ptemp = (LPCWSTR)pValue;
                int stringlength;
                stringlength = wcslen(ptemp);
                while(stringlength) 
                {
                    DestValue.Add(ptemp);  // Move string in
                    ptemp += stringlength+1;
                    stringlength = wcslen(ptemp);
                }
            }       
            break;

            default:
            {
                delete [] pValue;
				pValue = NULL;
                return (DWORD) REGDB_E_INVALIDVALUE;
            }
        }
    }
    catch ( ... )
    {
        delete [] pValue ;
		pValue = NULL;
        throw ;
    }
    
    delete [] pValue;
	pValue = NULL;
    return (DWORD)ERROR_SUCCESS;
}
 
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    return GetCurrentKeyValue (

        hKey,  
        pValueName,  
        DestValue
    );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD SizeOfValue = MAX_SUBKEY_BUFFERSIZE;
    long RetValue;
    DWORD TypeOfValue;
    LPBYTE pValue;      // Pointer to buffer for value
  
    pValue = new BYTE[MAX_SUBKEY_BUFFERSIZE];
    if(pValue) 
    {
        try 
        {
            // Get the value in its RAW format
            // ===============================
            RetValue = GetCurrentRawKeyValue (

                UseKey, 
                pValueName, 
                pValue, 
                (LPDWORD)&TypeOfValue, 
                (LPDWORD)&SizeOfValue
            );

            if( ERROR_SUCCESS == RetValue )
            {
                // If the type is a null termiated string
                // then assign it to the CHString
                // ======================================
                switch(TypeOfValue)
                {
                    case REG_SZ:
                    {
                        DestValue = atol((LPSTR)pValue);
                    }
                    break;

                    case REG_DWORD:
                    {
                        DestValue = *((DWORD*)(pValue));
                    }
                    break;

                    default:
                    {
                        DestValue = (DWORD)0L;
                        RetValue = REGDB_E_INVALIDVALUE; // Invalid value
                    }
                    break;
                }
            }
            delete[] pValue;
			pValue = NULL;
        }
        catch ( ... )
        {
            delete [] pValue ;
			pValue = NULL;
            throw ;
        }
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    return( GetCurrentKeyValue(hKey,  pValueName,  DestValue));
}

 //////////////////////////////////////////////////////////////////////
 //  Added support for Binary Type
 //////////////////////////////////////////////////////////////////////
 
DWORD CRegistry::GetCurrentBinaryKeyValue (

    LPCWSTR pValueName, 
    CHString &chsDest
)
{
    DWORD dwType = REG_BINARY;
    DWORD dwRc;
    WCHAR szDest[_MAX_PATH+2], ByteBuf[_MAX_PATH];
    BYTE bRevision[_MAX_PATH+2]; 
    DWORD dwSize = _MAX_PATH;

    dwRc = GetCurrentRawKeyValue (

        hKey, 
        pValueName, 
        bRevision, 
        &dwType, 
        &dwSize
    );

    if( dwRc != ERROR_SUCCESS )
    {
        return dwRc;
    }

    wcscpy( szDest, QUOTE );

    for( DWORD i=0; i<dwSize; i++ )
    {
        swprintf( ByteBuf, L"%02x", bRevision[i]);
        wcscat( szDest, ByteBuf );
    }

    wcscat(szDest, QUOTE);
    chsDest = szDest;

    return dwRc;
}

DWORD CRegistry::GetCurrentBinaryKeyValue (

    LPCWSTR pValueName, 
    LPBYTE  pbDest,
    LPDWORD pSizeOfDestValue 
)
{
    DWORD dwType = 0 ;

    return GetCurrentRawKeyValue (

        hKey, 
        pValueName, 
        pbDest, 
        &dwType, 
        &(*pSizeOfDestValue) 
    ) ;
}

DWORD CRegistry::GetCurrentBinaryKeyValue (  
                                HKEY UseKey , 
                                LPCWSTR pValueName , 
                                LPBYTE pbDest , 
                                LPDWORD pSizeOfDestValue )
{
    DWORD dwType = 0 ;

    return GetCurrentRawKeyValue (

        UseKey, 
        pValueName, 
        pbDest, 
        &dwType, 
        &(*pSizeOfDestValue) 
    ) ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyName (

    CHString &DestSubKeyName
)
{
    WCHAR KeyName[MAX_SUBKEY_BUFFERSIZE];
    DWORD RetValue;

    // and don't bother having RegEnumKey error out
    if(CurrentSubKeyIndex >= dwcSubKeys) 
    {
    // If we have exceeded the number of subkeys available tell the caller
        return( ERROR_NO_MORE_ITEMS );
    }         

    RetValue = myRegEnumKey (

        hKey, 
        CurrentSubKeyIndex, 
        KeyName,
        MAX_SUBKEY_BUFFERSIZE
    );

    // If we are successfull reading the name
    //=======================================  
    if(ERROR_SUCCESS == RetValue) 
    {
        DestSubKeyName = KeyName;
    }
    else 
    {
    // Otherwise clear the string so we don't leave garbage
    //=====================================================

        DestSubKeyName.Empty();  
    }  

    return RetValue;         // In either event, return the value RegEnumKey returned
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyPath (

    CHString &DestSubKeyPath
)
{
    CHString TempName;
    DWORD dwRet;

    dwRet = GetCurrentSubKeyName(TempName);
    if (dwRet == ERROR_SUCCESS) 
    {
        DestSubKeyPath = RootKeyPath+"\\";
        DestSubKeyPath += TempName; 
    }
    else 
    {
        DestSubKeyPath.Empty();
    }

    return dwRet;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::Close(void)
{   
    if(hSubKey != NULL) 
    {
        RegCloseKey(hSubKey) ;
        hSubKey = NULL ;
    }

    if(hKey != NULL)
    { 
        RegCloseKey(hKey); 
        hKey = NULL;
    }

    if(hRootKey != NULL && m_fFromCurrentUser)
    {
        RegCloseKey(hRootKey); 
        hRootKey = NULL;   
    }

    SetDefaultValues();     // Reset all the member vars for next
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::OpenSubKey(void)
{
    CHString SubKeyPath;
    LONG RetValue;

    // If they try and open the same subkey again then
    // leave things alone, otherwise open the subkey

    if(hSubKey) 
    {
        return ERROR_SUCCESS;
    }

    // Get the current subkey path
    //============================
    GetCurrentSubKeyPath(SubKeyPath);


    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================

    RetValue = myRegOpenKeyEx (

        hRootKey, 
        (LPCWSTR)SubKeyPath,    // address of name of subkey to open 
        (DWORD) 0,              // reserved 
        KEY_READ,               // security access mask 
        (PHKEY)&hSubKey         // address of handle of open key 
    ); 

    return RetValue;
}


 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::RewindSubKeys(void)
{
    CurrentSubKeyIndex = 0;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::CloseSubKey(void)
{
    if(hSubKey != NULL) 
    {
        RegCloseKey(hSubKey); 
    }

    hSubKey = NULL; // Only Close once
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentRawSubKeyValue (

    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pValueType, 
    LPDWORD pSizeOfDestValue
)
{
    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    DWORD RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentRawKeyValue (

            hSubKey, 
            pValueName, 
            pDestValue, 
            pValueType,  
            pSizeOfDestValue
        );
    }

    return RetValue;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pSizeOfDestValue
)
{
    DWORD RetValue;

    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentRawSubKeyValue (

            pValueName, 
            pDestValue, 
            NULL, 
            pSizeOfDestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD RetValue;

    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentKeyValue (

            hSubKey, 
            pValueName,
            DestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD RetValue;

// Try and open subkey
// and set hSubKey variable
// ======================== 
    RetValue = OpenSubKey();

// If subkey is open then get value
// ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentKeyValue (

            hSubKey, 
            pValueName,
            DestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::NextSubKey(void)
{
    if (CurrentSubKeyIndex >= dwcSubKeys) 
    {
        return( ERROR_NO_MORE_ITEMS );
    }

    // Close the currently opened subkey
    CloseSubKey();

    if(++CurrentSubKeyIndex >= dwcSubKeys) 
    {
        // CurrentSubKeyIndex is 0 based, dwcSubKeys is one based
        return( ERROR_NO_MORE_ITEMS );
    }
    else 
    {
        return (ERROR_SUCCESS);           
    }
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::PrepareToReOpen(void)
{ 
   Close();     
   SetDefaultValues(); 
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  SetCurrentKeyValueString(LPCSTR pValueName, CHString &DestValue)
 Description:   sets registry string using REG_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult;
    
    if(DestValue.Find(_T('%')) != -1)
    {
        dwResult = SetCurrentKeyValueExpand (

            hKey, 
            pValueName, 
            DestValue
        );
    }
    else
    {
        dwResult = SetCurrentKeyValue (

            hKey, 
            pValueName, 
            DestValue
        );
    }
    
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD dwResult = SetCurrentKeyValue (

        hKey, 
        pValueName, 
        DestValue
    );

    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    DWORD dwResult = SetCurrentKeyValue (

        hKey, 
        pValueName, 
        DestValue
    );

    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHString &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_SZ, // data type
        (const BYTE*)(LPCWSTR)DestValue,
        ( DestValue.GetLength() + 1 ) * sizeof ( WCHAR ) 
    );
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, DWORD &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_DWORD,  // data type
        (const BYTE*)&DestValue,
        sizeof(DWORD)
    );
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    DWORD dwResult = ERROR_SUCCESS;

    DWORD dwArrayChars = 0;
    for ( LONG Index = 0; Index < DestValue.GetSize(); Index++ )
    {
        CHString chsTemp = DestValue.GetAt(Index);
        
        dwArrayChars += (  chsTemp.GetLength() + 1 ) * sizeof(WCHAR);
    }

    // Add room for the trailing wide character null
    dwArrayChars += 2;
    
    WCHAR* pValue = new WCHAR[dwArrayChars];
    if( !pValue )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
 
    try 
    {
        memset( pValue, 0, dwArrayChars*sizeof(WCHAR) );
        
        DWORD dwCharCount = 0;
        for ( Index = 0; Index < DestValue.GetSize(); Index++ )
        {
            CHString chsTemp = DestValue.GetAt(Index);
                
            wcscpy(&pValue[dwCharCount], chsTemp.GetBuffer(0));

            dwCharCount += (  chsTemp.GetLength() + 1 ) ;
        }

        dwResult = myRegSetValueEx (

            hUseKey,    // key handle
            pValueName, // name of value
            0,  // reserved -- must be zero
            REG_MULTI_SZ,   // data type
            (const BYTE *)pValue,
            dwArrayChars
        );

        delete [] pValue;
		pValue = NULL;
    }
    catch ( ... )
    {
        delete [] pValue;
		pValue = NULL;
        throw ;
    }
    
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValueExpand(HKEY UseKey, LPCSTR pValueName, CHString &DestValue)
 Description: sets registry string using REG_EXPAND_SZ, required when the string contains variables (e.g., %SystemRoot%)
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValueExpand (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_EXPAND_SZ,  // data type
        (const BYTE*)(LPCWSTR)DestValue,
        ( DestValue.GetLength() + 1 ) * sizeof ( WCHAR ) 
    );
        
    return dwResult ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::DeleteCurrentKeyValue (

    LPCWSTR pValueName
)
{
    return myRegDeleteValue (

        hKey, 
        pValueName
    );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::DeleteCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName
)
{
    return myRegDeleteValue (

        UseKey, 
        pValueName
    );
}   

//*****************************************************************
///////////////////////////////////////////////////////////////////
//
//  Class:  CRegistrySearch
//
//  This class searches through the registry for matching Values, 
//  Keys and Partial Keys 
//
///////////////////////////////////////////////////////////////////
//*****************************************************************
CRegistrySearch::CRegistrySearch()
{
}

///////////////////////////////////////////////////////////////////
CRegistrySearch::~CRegistrySearch()
{
}

///////////////////////////////////////////////////////////////////
//
//  void CRegistrySearch::CheckAndAddToList( CRegistry * pReg, 
//                                         CHString chsSubKey, 
//                                         CHString chsFullKey,
//                                         CHPtrArray & chpaList,
//                                         CHString chsSearchString,
//                                         int nSearchType)
//
//  Desc:       This function performs the requested search on the
//              current key and if it matches, then adds it to the
//              CHPtrArray
//
//  Parameters: 
//              pReg        - The current registry class
//              chsSubKey   - The current Key
//              chsFullKey  - The complete key
//              chpaList    - The target CHPtrArray
//              chsSearchString - The string to search for
//              nSearchType - The type of search, the following are
//                            supported:
//                            KEY_FULL_MATCH_SEARCH      
//                               Only keys that match the chsSearchString
//                            KEY_PARTIAL_MATCH_SEARCH   
//                               Keys that have chsSearchString anywhere in them
//                            VALUE_SEARCH               
//                               Values that match chsSearchString
//
//  History
//          Initial coding      jennymc     10/10/96
//  
///////////////////////////////////////////////////////////////////
void CRegistrySearch::CheckAndAddToList (

    CRegistry * pReg, 
    CHString chsSubKey, 
    CHString chsFullKey,
    CHPtrArray & chpaList,
    CHString chsSearchString,
    CHString chsValue,
    int nSearchType
)
{
    BOOL bFound = FALSE;

    //====================================================
    //  We need to check out the current key to see if it
    //  matches any of our criteria.
    //====================================================

    if( nSearchType == VALUE_SEARCH )
    {
        //====================================================
        //  If it is a Value search, then let us try to open
        //  the value.  
        //====================================================

        CHString chsTmp ;

        if( pReg->GetCurrentSubKeyValue(chsValue, chsTmp) == ERROR_SUCCESS)
        {
            if( chsSearchString.CompareNoCase(chsTmp) == 0 )
            {
                bFound = TRUE;
            }
        }
    }        
    else if( nSearchType == KEY_FULL_MATCH_SEARCH )
    {
        if( chsSearchString == chsSubKey )
        {
            bFound = TRUE;
        }
    }
    else
    {
        if( chsSubKey.Find(chsSearchString) )
        {
            bFound = TRUE;
        }
    }
    //====================================================
    //  If it was found, then record the key location
    //====================================================
    if( bFound )
    {
        CHString *pchsPtr = new CHString;
        if ( pchsPtr )
        {
            try 
            {
                *pchsPtr = chsFullKey;
                chpaList.Add( pchsPtr );
            }
            catch ( ... )
            {
                delete pchsPtr ;
				pchsPtr = NULL;
                throw ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

///////////////////////////////////////////////////////////////////
//  Public function:  Documented in cregcls.h
//
//  History
//          Initial coding      jennymc     10/10/96
//
///////////////////////////////////////////////////////////////////
BOOL CRegistrySearch::SearchAndBuildList (

    CHString chsRootKey, 
    CHPtrArray & cpaList,
    CHString chsSearchString,
    CHString chsValue,
    int nSearchType,
    HKEY hkDefault
)
{
    BOOL bRc;

    //=======================================================
    //  Allocate a registry class to open and enumerate the
    //  requested key.
    //=======================================================

    CRegistry *pReg = new CRegistry;
    if( !pReg )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try 
    {
        //=======================================================
        //  If the key cannot be opened, then cleanup and back
        //  out.
        //=======================================================
        if( pReg->OpenAndEnumerateSubKeys(hkDefault,chsRootKey, KEY_READ ) != ERROR_SUCCESS )
        {
            delete pReg ;
			pReg = NULL;
            return FALSE;
        }

        try 
        {
            CHString chsSubKey ;

            //=======================================================
            //  As long as there are subkeys under this key,
            //  let us open and enumerate each one, each time 
            //  checking if it has the value or part of the 
            //  string we want. 
            //
            //  The GetCurrentSubKeyName function only returns the
            //  current key, we have to add it to the end of the
            //  Parent key in order to get the full key name.
            //=======================================================
            while ( pReg->GetCurrentSubKeyName(chsSubKey) == ERROR_SUCCESS )
            {
                CHString chsFullKey ;
                CHString chsSlash = L"\\";

                chsFullKey = chsRootKey + chsSlash + chsSubKey;

                CheckAndAddToList (

                    pReg, 
                    chsSubKey, 
                    chsFullKey, 
                    cpaList, 
                    chsSearchString, 
                    chsValue, 
                    nSearchType 
                );

                pReg->NextSubKey();

                bRc = SearchAndBuildList (

                    chsFullKey, 
                    cpaList, 
                    chsSearchString, 
                    chsValue, 
                    nSearchType 
                );
            }

            //=======================================================
            //  Close the current key and delete the registry pointer
            //=======================================================
            pReg->Close();

        }
        catch ( ... )
        {
            pReg->Close();

            throw ;
        }

        delete pReg;
		pReg = NULL;
    }
    catch ( ... )
    {
        delete pReg ;
		pReg = NULL;
        throw ;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////
BOOL CRegistrySearch::FreeSearchList (

    int nType, 
    CHPtrArray & cpaList 
)
{
    BOOL bRc;
    int i;
    int nNum =  cpaList.GetSize();

    switch( nType )
    {
        case CSTRING_PTR:
        {
            CHString *pPtr;
            for ( i=0; i < nNum; i++ )
            {
                pPtr = ( CHString * ) cpaList.GetAt(i);
                delete pPtr;
				pPtr = NULL;
            }
            bRc = TRUE;
        }
        break;

        default:
        {
            bRc = FALSE;
        }
        break;
    }

    if( bRc )
    {
        cpaList.RemoveAll();
    }

    return bRc;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   MOPropertySet_DevMem::LocateNTOwnerDevice
//
//  DESCRIPTION :   Helper function for locating a key of the specified
//                  name, or a key containg the specified value name.
//
//  INPUTS      :   HKEY        hKeyParent - Parent Key
//                  LPCWSTR     pszKeyName - Name of Key to open
//                  LPCWSTR     pszSubKeyName - Name of SubKey to Find
//                  LPCWSTR*    ppszValueNames - Array of Value Names
//                  DWORD       dwNumValueNames - Number of names in array
//
//  OUTPUTS     :   CHString&   strFoundKeyName -   Storage for name of key if found.
//                  CHString&   strFoundKeyPath - Storage for pathed key name
//
//  RETURNS     :   nothing
//
//  COMMENTS    :   Recursively Enumerates the registry from a specified
//                  starting point until it locates a subkey matching either
//                  a supplied subkey name or a value name matching one of
//                  the supplied names.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CRegistrySearch::LocateKeyByNameOrValueName(

    HKEY        hKeyParent,
    LPCWSTR     pszKeyName,
    LPCWSTR     pszSubKeyName,
    LPCWSTR*    ppszValueNames,
    DWORD       dwNumValueNames,
    CHString&   strFoundKeyName,
    CHString&   strFoundKeyPath
)
{
    CRegistry   reg;
    BOOL        fFound = FALSE;

    // Get out of here if we got garbage parameters
    if ( NULL == pszSubKeyName && NULL == ppszValueNames )
    {
        return FALSE;
    }

    // Open the key for enumeration and go through the sub keys.

    LONG t_Status = reg.OpenAndEnumerateSubKeys ( 

        hKeyParent,
        pszKeyName,
        KEY_READ 
    ) ;

    if ( ERROR_SUCCESS == t_Status )
    {
        try 
        {
            CHString    strSubKeyName;
            DWORD       dwValueBuffSize =   0;

            // As long as we can get sub keys, we can try to find values.

            while ( !fFound && ERROR_SUCCESS == reg.GetCurrentSubKeyName( strSubKeyName ) )
            {

                // First check if the specified sub key name matches the sub key name.
                // If not, then check for the value names.

                if ( NULL != pszSubKeyName && strSubKeyName == pszSubKeyName )
                {
                    fFound = TRUE;
                }
                else if ( NULL != ppszValueNames )
                {
                    // Enumerate the value names in the array until one is found.

                    for ( DWORD dwEnum = 0; !fFound && dwEnum < dwNumValueNames; dwEnum++ )
                    {
                        t_Status = reg.GetCurrentSubKeyValue(

                            ppszValueNames[dwEnum],
                            NULL,
                            &dwValueBuffSize 
                        ) ;

                        if ( ERROR_SUCCESS  ==  t_Status )
                        {
                            fFound = TRUE;
                        }

                    }   // FOR dwEnum

                }   // IF NULL != ppszValueNames

                // Check if one of the methods located the key.  If so, store all
                // the current values.

                if ( !fFound )
                {
                    //
                    // No success, so recurse (WOOHOO!)
                    //

                    fFound = LocateKeyByNameOrValueName (

                        reg.GethKey(),
                        strSubKeyName,
                        pszSubKeyName,
                        ppszValueNames,
                        dwNumValueNames,
                        strFoundKeyName,
                        strFoundKeyPath 
                    );
                }
                else
                {
                    // Store the actual key name in both the single
                    // name and path.  We will build the full path
                    // as we slide back up the recursive chain.

                    strFoundKeyName = strSubKeyName;
                    strFoundKeyPath = strSubKeyName;
                }

                // Lastly, since fFound may now have been set by recursion, we will
                // want to attach the current key path to the key name we've opened
                // so when we return out of here, we get the full path to the
                // located key name stored correctly.

                if ( fFound )
                {
                    CHString strSavePath( strFoundKeyPath );
                    strFoundKeyPath.Format(L"%s\\%s", (LPCWSTR) pszKeyName, (LPCWSTR) strSavePath );
                }
                else
                {
                    // Not found yet, so go to the next key.
                    reg.NextSubKey();
                }

            }   // While !Found

            reg.Close();
        }
        catch ( ... )
        {
            reg.Close () ;

            throw ;
        }

    }   // If OpenAndEnumerateSubKeys

    return fFound;

}

//========================================================================================
// These routines are for the multiplatform support
DWORD CRegistry::GetPlatformID(void)
{
    OSVERSIONINFOA OsVersionInfoA;

    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);

    return OsVersionInfoA.dwPlatformId;
}

LONG CRegistry::myRegCreateKeyEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD Reserved, 
    LPWSTR lpwcsClass, 
    DWORD dwOptions, 
    REGSAM samDesired, 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
    PHKEY phkResult, 
    LPDWORD lpdwDisposition
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegCreateKeyExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            lpwcsClass, 
            dwOptions, 
            samDesired, 
            lpSecurityAttributes, 
            phkResult, 
            lpdwDisposition
        );
    }
    else
    {
        char *szSubKey = NULL ;
        bool t_ConversionFailure = false ;

        WCSTOANSISTRING ( lpwcsSubKey , szSubKey , t_ConversionFailure ) ;
        
	if (t_ConversionFailure)
	{
	  return ERROR_NO_UNICODE_TRANSLATION;
	}

        char *lpClass = NULL ;
        t_ConversionFailure = false ;

        WCSTOANSISTRING ( lpwcsClass , lpClass , t_ConversionFailure );
        
        if (t_ConversionFailure)
	{
	  return ERROR_NO_UNICODE_TRANSLATION;
	}
	
        return RegCreateKeyExA (

                    hKey, 
                    szSubKey, 
                    Reserved, 
                    lpClass, 
                    dwOptions, 
                    samDesired, 
                    lpSecurityAttributes, 
                    phkResult, 
                    lpdwDisposition
                );
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegSetValueEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData
)
{
    LONG lRet;

    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        lRet = RegSetValueExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            dwType, 
            lpData, 
            cbData
        );
    }
    else
    {
// First convert the key name

        bool t_ConversionFailure = false ;
        char *pName = NULL ;

        if ( lpwcsSubKey != NULL )
        {
            WCSTOANSISTRING ( lpwcsSubKey , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure )
            {
                if ( ! pName )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
        }

// Now, we may need to convert the data

        BYTE *pMyData = NULL ;

        try
        {
            DWORD dwMySize = 0 ;

            bool bDoit = false ;

            switch ( dwType )
            {
                case REG_EXPAND_SZ:
                case REG_SZ:
                {
// If it's a simple string, convert it

                    t_ConversionFailure = false ;

                    WCHAR *pStrUnicode = ( WCHAR * ) lpData ;
                    char *pStrAnsi = NULL ;

                    WCSTOANSISTRING ( pStrUnicode , pStrAnsi , t_ConversionFailure ) ;

                    if ( ! t_ConversionFailure )
                    {
                        if ( pStrAnsi != NULL )
                        {
                            pMyData = ( BYTE * ) pStrAnsi ;
                            dwMySize = strlen ( pStrAnsi ) ;

                            bDoit = true ;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                    else
                    {
                        return ERROR_NO_UNICODE_TRANSLATION ;
                    }
                }
                break ;

                case REG_MULTI_SZ:
                {
// If it's a multi-sz, it take a little more

                    int nLen = ::WideCharToMultiByte (

                        CP_ACP , 
                        0 , 
                        ( const WCHAR *) lpData , 
                        cbData , 
                        NULL , 
                        0 , 
                        NULL , 
                        NULL
                    );

                    if ( nLen > 0 ) 
                    {
                        pMyData = new BYTE [ nLen ] ;
                        if ( pMyData != NULL )
                        {
                            dwMySize = WideCharToMultiByte (

                                CP_ACP , 
                                0, 
                                ( const WCHAR * ) lpData , 
                                cbData , 
                                ( char * )pMyData , 
                                nLen , 
                                NULL , 
                                NULL
                            ) ;

                            bDoit = true;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                    else
                    {
                        lRet = ERROR_NO_UNICODE_TRANSLATION ;
                    }
                }
                break ;

                default:
                {
// All other types, just write it

                    pMyData = ( BYTE * ) lpData ;
                    dwMySize = cbData ;
                    bDoit = true;
                }
                break ;
            }

            if ( bDoit )
            {
                lRet = RegSetValueExA (

                    hKey, 
                    pName, 
                    Reserved, 
                    dwType, 
                    pMyData, 
                    dwMySize
                );
            }

            if ( ( dwType == REG_MULTI_SZ ) && ( pMyData != NULL ) )
            {
                delete [] pMyData ;
				pMyData = NULL;
            }
        }
        catch ( ... )
        {
            if ( ( dwType == REG_MULTI_SZ ) && ( pMyData != NULL ) )
            {
                delete [] pMyData ;
				pMyData = NULL;
            }

            throw ;
        }
    }

    return lRet;
}

LONG CRegistry::myRegQueryValueEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    LPDWORD Reserved, 
    LPDWORD dwType, 
    LPBYTE lpData, 
    LPDWORD cbData
)
{
    LONG lRet;

    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        lRet = RegQueryValueExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            dwType, 
            lpData, 
            cbData
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;

        if ( lpwcsSubKey != NULL )
        {
            WCSTOANSISTRING ( lpwcsSubKey , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure )
            {
                if ( ! pName )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
        }

        BYTE *pMyData = NULL ;

        try
        {
            if ( lpData != NULL )
            {
                pMyData = new BYTE [ *cbData ] ;
                if ( ! pMyData )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

            if ( ( pMyData != NULL ) || (lpData == NULL))
            {
                DWORD dwMySize = *cbData;

                lRet = RegQueryValueExA (

                    hKey, 
                    pName, 
                    Reserved, 
                    dwType, 
                    pMyData, 
                    & dwMySize
                ) ;

// If it worked, we may need to convert the strings

                if ( lRet == ERROR_SUCCESS )
                {
                    switch ( *dwType )
                    {
                        case REG_EXPAND_SZ:
                        case REG_SZ:
                        {
// If lpData is null, there isn't any way to say for sure how long the target string needs
// to be.  However, it can't be more than twice as long (it can be less).

                            if (lpData == NULL)
                            {
                                *cbData = dwMySize * 2;
                            }
                            else
                            {
                                int nLen = ::MultiByteToWideChar (

                                    CP_ACP, 
                                    0, 
                                    (const char *)pMyData, 
                                    -1, 
                                    (WCHAR *)lpData, 
                                    *cbData
                                );  
// Convert to bytes
                                *cbData = nLen * 2;
                            }
                        }
                        break ;

                        case REG_MULTI_SZ:
                        {
// If lpData is null, there isn't any way to say for sure how long the target string needs
// to be.  However, it can't be more than twice as long (it can be less).

                            if (lpData == NULL)
                            {
                                *cbData = dwMySize * 2;
                            }
                            else
                            {
                                DWORD dwConverted = MultiByteToWideChar (

                                    CP_ACP, 
                                    0, 
                                    (const char *)pMyData, 
                                    dwMySize, 
                                    (WCHAR *)lpData, 
                                    *cbData
                                );
                            }
                        }
                        break ;

                        default:
                        {
// All other types are handled in RegQueryValue

                            *cbData = dwMySize ;

                            if( NULL != lpData )
                            {
                                memcpy ( lpData , pMyData , *cbData ) ;
                            }
                        }
                        break ;
                    }
                }

                delete [] pMyData;
				pMyData = NULL;
            }
        }
        catch ( ... )
        {
            delete [] pMyData ;
			pMyData = NULL;
            throw ;
        }
    }

    return lRet;
}

LONG CRegistry::myRegEnumKey (

    HKEY hKey, 
    DWORD dwIndex, 
    LPWSTR lpwcsName, 
    DWORD cbData
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegEnumKeyW (

            hKey, 
            dwIndex, 
            lpwcsName, 
            cbData
        );
    }
    else
    {
        char szName[_MAX_PATH];

        LONG lRet = RegEnumKeyA (

            hKey, 
            dwIndex, 
            szName, 
            cbData
        );

        if (lRet == ERROR_SUCCESS)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            ANSISTRINGTOWCS ( szName , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure ) 
            {
                if ( pName )
                {
                    wcscpy(lpwcsName, pName);
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
            
        }

        return lRet;
    }
}

LONG CRegistry::myRegDeleteValue (

    HKEY hKey, 
    LPCWSTR lpwcsName
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegDeleteValueW (

            hKey, 
            lpwcsName
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwcsName, pName , t_ConversionFailure ) ;

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {
                return RegDeleteValueA (

                    hKey, 
                    pName
                );
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION ;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegDeleteKey (

    HKEY hKey, 
    LPCWSTR lpwcsName
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegDeleteKeyW (

            hKey, 
            lpwcsName
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwcsName, pName , t_ConversionFailure ) ;

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {
                return RegDeleteKeyA (

                    hKey, 
                    pName
                );
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION ;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegOpenKeyEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD ulOptions, 
    REGSAM samDesired, 
    PHKEY phkResult
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegOpenKeyExW (

            hKey, 
            lpwcsSubKey, 
            ulOptions, 
            samDesired, 
            phkResult
        );
    }

    char *pName = NULL ;
    bool t_ConversionFailure = false ;

    WCSTOANSISTRING ( lpwcsSubKey, pName , t_ConversionFailure );
    
    if ( ! t_ConversionFailure ) 
    {
        if ( pName )
        {
            return RegOpenKeyExA (

                hKey, 
                pName, 
                ulOptions, 
                samDesired, 
                phkResult
            );
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegQueryInfoKey (

    HKEY hKey, 
    LPWSTR lpwstrClass, 
    LPDWORD lpcbClass,
    LPDWORD lpReserved, 
    LPDWORD lpcSubKeys, 
    LPDWORD lpcbMaxSubKeyLen,  
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues, 
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen, 
    LPDWORD lpcbSecurityDescriptor, 
    PFILETIME lpftLastWriteTime
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegQueryInfoKeyW (

            hKey, 
            lpwstrClass, 
            lpcbClass, 
            lpReserved, 
            lpcSubKeys, 
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen, 
            lpcValues, 
            lpcbMaxValueNameLen, 
            lpcbMaxValueLen, 
            lpcbSecurityDescriptor, 
            lpftLastWriteTime
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwstrClass, pName, t_ConversionFailure );

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {

                return RegQueryInfoKeyA (

                    hKey, 
                    pName, 
                    lpcbClass, 
                    lpReserved, 
                    lpcSubKeys, 
                    lpcbMaxSubKeyLen, 
                    lpcbMaxClassLen, 
                    lpcValues, 
                    lpcbMaxValueNameLen, 
                    lpcbMaxValueLen, 
                    lpcbSecurityDescriptor, 
                    lpftLastWriteTime
                ) ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegEnumValue (

    HKEY hKey, 
    DWORD dwIndex, 
    LPWSTR lpValueName,
    LPDWORD lpcbValueName, 
    LPDWORD lpReserved, 
    LPDWORD lpType,
    LPBYTE lpData, 
    LPDWORD lpcbData
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegEnumValueW (

            hKey, 
            dwIndex, 
            lpValueName, 
            lpcbValueName, 
            lpReserved, 
            lpType, 
            lpData, 
            lpcbData
        );
    }
    else
    {
        char szData[MAX_PATH * 2];

        LONG lRet = RegEnumValueA (

            hKey, 
            dwIndex, 
            szData, 
            lpcbValueName, 
            lpReserved, 
            lpType, 
            lpData, 
            lpcbData
        );

        if (lRet == ERROR_SUCCESS)
        {
            // Get the name.
            mbstowcs(lpValueName, szData, lstrlenA(szData) + 1);

            // Get the value if the data is a string.
            if (*lpType == REG_SZ || *lpType == REG_MULTI_SZ)
            {
                lstrcpyA(szData, (LPSTR) lpData);
                mbstowcs((LPWSTR) lpData, szData, lstrlenA(szData) + 1);
                *lpcbData = (lstrlenW((LPWSTR) lpData) + 1) * sizeof(WCHAR);
            }
        }

        return lRet;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\chstring.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  CHSTRING.CPP
//
//  Purpose: utility library version of MFC CString
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <chstring.h>
#include <stdio.h>
#include <comdef.h>
#include <AssertBreak.h>
#include <ScopeGuard.h>
#define _wcsinc(_pc)    ((_pc)+1)

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

#define DEPRECATED 0

const CHString& afxGetEmptyCHString();

#define afxEmptyCHString afxGetEmptyCHString()

// Global data used for LoadString.
#if 0
HINSTANCE g_hModule = GetModuleHandle(NULL); // Default to use the process module.
#endif

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void WINAPI SetCHStringResourceHandle(HINSTANCE handle)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    g_hModule = handle;
#endif
}
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines
/////////////////////////////////////////////////////////////////////////////
WCHAR afxChNil = '\0';

static DWORD GetPlatformID(void)
{
    OSVERSIONINFOA version;

    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA) ;
    GetVersionExA(&version);

    return version.dwPlatformId;
}

static DWORD s_dwPlatformID = GetPlatformID();

/////////////////////////////////////////////////////////////////////////////
// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
/////////////////////////////////////////////////////////////////////////////
static int rgInitData[] = { -1, 0, 0, 0 };
static CHStringData* afxDataNil = (CHStringData*)&rgInitData;
LPCWSTR afxPchNil = (LPCWSTR)(((BYTE*)&rgInitData)+sizeof(CHStringData));
/////////////////////////////////////////////////////////////////////////////
// special function to make EmptyString work even during initialization
/////////////////////////////////////////////////////////////////////////////
// special function to make afxEmptyString work even during initialization
const CHString& afxGetEmptyCHString()
{
    return *(CHString*)&afxPchNil; 
}


///////////////////////////////////////////////////////////////////////////////
// CHString conversion helpers (these use the current system locale)
///////////////////////////////////////////////////////////////////////////////
int  _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
    {
        return 0;
    }

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, count, NULL, NULL);
    ASSERT_BREAK(mbstr != NULL || result <= (int)count);

    if (result > 0)
    {
        mbstr[result-1] = 0;
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
int _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
    {
        return 0;
    }

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,wcstr, count);
    ASSERT_BREAK(wcstr != NULL || result <= (int)count);
    
    if (result > 0)
    {
        wcstr[result-1] = 0;
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
//*************************************************************************
//
//  THE CHSTRING CLASS:   PROTECTED MEMBER FUNCTIONS
//
//*************************************************************************
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// implementation helpers
///////////////////////////////////////////////////////////////////////////////
CHStringData* CHString::GetData() const
{
    if( m_pchData == (WCHAR*)*(&afxPchNil)) 
    {
        return (CHStringData *)afxDataNil;
    }

    return ((CHStringData*)m_pchData)-1; 
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       Init
//
//  Description:    This function initializes the data ptr
//
///////////////////////////////////////////////////////////////////////////////
void CHString::Init()
{
    m_pchData = (WCHAR*)*(&afxPchNil);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AllocCopy
//
//  Description:    This function will clone the data attached to this 
//                  string allocating 'nExtraLen' characters, it places
//                  results in uninitialized string 'dest' and will copy
//                  the part or all of original data to start of new string
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocCopy( CHString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const
{
    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AllocBuffer
//
//  Description:    Always allocate one extra character for '\0' 
//                  termination.  assumes [optimistically] that 
//                  data length will equal allocation length
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocBuffer(int nLen)
{
    ASSERT_BREAK(nLen >= 0);
    ASSERT_BREAK(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        CHStringData* pData = (CHStringData*)new BYTE[sizeof(CHStringData) + (nLen+1)*sizeof(WCHAR)];
        if ( pData )
        {
            pData->nRefs = 1;
            pData->data()[nLen] = '\0';
            pData->nDataLength = nLen;
            pData->nAllocLength = nLen;
            m_pchData = pData->data();
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AssignCopy
//
//  Description:    Assigns a copy of the string to the current data ptr
//                  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    // Call this first, it will release the buffer if it has
    // already been allocated and no one is using it
    AllocBeforeWrite(nSrcLen);

    // Now, check to see if the nSrcLen is > 0, if it is, then
    // continue, otherwise, go ahead and return
    if( nSrcLen > 0 )
    {
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
    }
    else
    {
        Release();
    }        
}

//////////////////////////////////////////////////////////////////////////////
// 
//  ConcatCopy
//
//  Description:    This is the master concatenation routine
//                  Concatenates two sources, and assumes
//                  that 'this' is a new CHString object
//
//////////////////////////////////////////////////////////////////////////////
void CHString::ConcatCopy( int nSrc1Len, LPCWSTR lpszSrc1Data,
                           int nSrc2Len, LPCWSTR lpszSrc2Data)
{
    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// 
//  ConcatInPlace
//
//  Description:        The main routine for += operators
//
//////////////////////////////////////////////////////////////////////////////
void CHString::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
    {
        return;
    }

    //  if the buffer is too small, or we have a width mis-match, just
    //  allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength) 
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CHStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        ASSERT_BREAK(pOldData != NULL);
        CHString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        ASSERT_BREAK(GetData()->nDataLength <= GetData()->nAllocLength);
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

//////////////////////////////////////////////////////////////////////////////
// 
//  FormatV
//
//  Description:        Formats the variable arg list
//
//////////////////////////////////////////////////////////////////////////////
void CHString::FormatV(LPCWSTR lpszFormat, va_list argList)
{
    ASSERT_BREAK(lpszFormat!=NULL);

    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCWSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _wcsinc(lpsz)){
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _wcsinc(lpsz)) == '%'){
            nMaxLen += wcslen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _wcsinc(lpsz)){
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0){
            // width indicated by
            nWidth = _wtoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                ;
        }
        ASSERT_BREAK(nWidth >= 0);

        int nPrecision = 0;
        if (*lpsz == '.'){
            // skip past '.' separator (width.precision)
            lpsz = _wcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*'){
                nPrecision = va_arg(argList, int);
                lpsz = _wcsinc(lpsz);
            }
            else{
                nPrecision = _wtoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                    ;
            }
            ASSERT_BREAK(nPrecision >= 0);
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz){
            // modifiers that affect size
            case 'h':
                nModifier = FORCE_ANSI;
                lpsz = _wcsinc(lpsz);
                break;
            case 'l':
                nModifier = FORCE_UNICODE;
                lpsz = _wcsinc(lpsz);
                break;

            // modifiers that do not affect size
            case 'F':
            case 'N':
            case 'L':
                lpsz = _wcsinc(lpsz);
                break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier){
            // single characters
            case 'c':
            case 'C':
                nItemLen = 2;
                va_arg(argList, TCHAR_ARG);
                break;
            case 'c'|FORCE_ANSI:
            case 'C'|FORCE_ANSI:
                nItemLen = 2;
                va_arg(argList, CHAR_ARG);
                break;
            case 'c'|FORCE_UNICODE:
            case 'C'|FORCE_UNICODE:
                nItemLen = 2;
                va_arg(argList, WCHAR_ARG);
                break;

            // strings
            case 's':
                nItemLen = wcslen(va_arg(argList, LPCWSTR));
                nItemLen = max(1, nItemLen);
                break;

            case 'S':
                nItemLen = strlen(va_arg(argList, LPCSTR));
                nItemLen = max(1, nItemLen);
                break;

            case 's'|FORCE_ANSI:
            case 'S'|FORCE_ANSI:
                nItemLen = strlen(va_arg(argList, LPCSTR));
                nItemLen = max(1, nItemLen);
                break;
    #ifndef _MAC
            case 's'|FORCE_UNICODE:
            case 'S'|FORCE_UNICODE:
                nItemLen = wcslen(va_arg(argList, LPWSTR));
                nItemLen = max(1, nItemLen);
                break;
    #endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0){
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else{
            switch (*lpsz){
                // integers
                case 'd':
                case 'i':
                case 'u':
                case 'x':
                case 'X':
                case 'o':
                    va_arg(argList, int);
                    nItemLen = 32;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                case 'e':
                case 'f':
                case 'g':
                case 'G':
                    va_arg(argList, DOUBLE_ARG);
                    nItemLen = 128;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                case 'p':
                    va_arg(argList, void*);
                    nItemLen = 32;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                // no output
                case 'n':
                    va_arg(argList, int*);
                    break;

                default:
                    ASSERT_BREAK(FALSE);  // unknown formatting option
            }
         }

         // adjust nMaxLen for output nItemLen
         nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    int iSize = vswprintf(m_pchData, lpszFormat, argListSave); //<= GetAllocLength();
    ASSERT_BREAK(iSize <= nMaxLen);

    ReleaseBuffer();

    va_end(argListSave);
}

//////////////////////////////////////////////////////////////////////////////
//
//  CopyBeforeWrite
//
//  Description:
//
//////////////////////////////////////////////////////////////////////////////
void CHString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CHStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  AllocBeforeWrite
//
//  Description:
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Release
//
//  Description:    Deallocate data
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Release()
{
    if (GetData() != afxDataNil)
    {
        ASSERT_BREAK(GetData()->nRefs != 0);
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
        {
            delete[] (BYTE*)GetData();
        }

        Init();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Release
//
//  Description:    Deallocate data
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Release(CHStringData* pData)
{
    if (pData != afxDataNil)
    {
        ASSERT_BREAK(pData->nRefs != 0);
        if (InterlockedDecrement(&pData->nRefs) <= 0)
        {
            delete[] (BYTE*)pData;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString()
{
    Init();
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(WCHAR ch, int nLength)
{
    ASSERT_BREAK(!_istlead(ch));    // can't create a lead byte string

    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
        {
            m_pchData[i] = ch;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        ASSERT_BREAK(lpch!=NULL);

        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
//#ifdef _UNICODE
CHString::CHString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? strlen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
//#else //_UNICODE
#if 0
CHString::CHString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0){
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif 

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(LPCWSTR lpsz)
{
    Init();
//  if (lpsz != NULL && HIWORD(lpsz) == NULL)
//  {
        //??
//  }
//  else
//  {
        int nLen = SafeStrlen(lpsz);
        if (nLen != 0)
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
        }
//  }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(const CHString& stringSrc)
{
    ASSERT_BREAK(stringSrc.GetData()->nRefs != 0);

    if (stringSrc.GetData()->nRefs >= 0)
    {
        ASSERT_BREAK(stringSrc.GetData() != afxDataNil);
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Empty()
{
    if (GetData()->nDataLength == 0)
    {
        return;
    }

    if (GetData()->nRefs >= 0)
    {
        Release();
    }
    else
    {
        *this = &afxChNil;
    }

    ASSERT_BREAK(GetData()->nDataLength == 0);
    ASSERT_BREAK(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::~CHString()
{
    if (GetData() != afxDataNil)
    {   
//  free any attached data

        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
        {
            delete[] (BYTE*)GetData();
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::SetAt(int nIndex, WCHAR ch)
{
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CHString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//
/////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(const CHString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            ASSERT_BREAK(stringSrc.GetData() != afxDataNil);
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }

    return *this;

/*  if (m_pchData != stringSrc.m_pchData){

        // can just copy references around
        Release();
        if( stringSrc.GetData() != afxDataNil) {
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;*/
} 

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL);

    AssignCopy(SafeStrlen(lpsz), lpsz);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

//#ifdef _UNICODE
const CHString& CHString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? strlen(lpsz) : 0 ;
    
    AllocBeforeWrite( nSrcLen ) ;
    
    if( nSrcLen )
    {
        _mbstowcsz( m_pchData, lpsz, nSrcLen + 1 ) ;
        ReleaseBuffer() ;
    }
    else
    {
        Release() ;
    }
    
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
//#else //!_UNICODE
#if 0
const CHString& CHString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0 ;

    AllocBeforeWrite( nSrcLen * 2 ) ;
    
    if( nSrcLen )
    {
        _wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1 ) ;
        ReleaseBuffer();
    }
    else
    {
        Release() ;
    }

    return *this;
}
#endif

//////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(WCHAR ch)
{
    ASSERT_BREAK(!_istlead(ch));    // can't set single lead byte

    AssignCopy(1, &ch);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CHString + CHString
// and for ? = WCHAR, LPCWSTR
//          CHString + ?
//          ? + CHString
/////////////////////////////////////////////////////////////////////////////

CHString WINAPI operator+(const CHString& string1, const CHString& string2)
{
    CHString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(const CHString& string, LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL );

    CHString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CHString::SafeStrlen(lpsz), lpsz);

    return s;
}
/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(LPCWSTR lpsz, const CHString& string)
{
    ASSERT_BREAK(lpsz != NULL );

    CHString s;
    s.ConcatCopy(CHString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(const CHString& string1, WCHAR ch)
{
    CHString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(WCHAR ch, const CHString& string)
{
    CHString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL );

    ConcatInPlace(SafeStrlen(lpsz), lpsz);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(const CHString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);

    return *this;
}

///////////////////////////////////////////////////////////////////////////////
int CHString::Compare(LPCWSTR lpsz ) const 
{   
    ASSERT_BREAK( lpsz!=NULL );
    ASSERT_BREAK( m_pchData != NULL );

    return wcscmp(m_pchData, lpsz);  // MBCS/Unicode aware   strcmp

}   

///////////////////////////////////////////////////////////////////////////////
//
//
//  Description: Advanced direct buffer access
//
///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::GetBuffer(int nMinBufLength)
{
    ASSERT_BREAK(nMinBufLength >= 0);

    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CHStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
        {
            nMinBufLength = nOldLen;
        }

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CHString::Release(pOldData);
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);

    // return a pointer to the character storage for this string
    ASSERT_BREAK(m_pchData != NULL);

    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
    {
        nNewLength = wcslen(m_pchData); // zero terminated
    }

    ASSERT_BREAK(nNewLength <= GetData()->nAllocLength);

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::GetBufferSetLength(int nNewLength)
{
    ASSERT_BREAK(nNewLength >= 0);

    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';

    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::FreeExtra()
{
    ASSERT_BREAK(GetData()->nDataLength <= GetData()->nAllocLength);
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CHStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));

        ASSERT_BREAK(m_pchData[GetData()->nDataLength] == '\0');

        CHString::Release(pOldData);
    }

    ASSERT_BREAK(GetData() != NULL);
}

///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;

    return lpsz;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::UnlockBuffer()
{
    ASSERT_BREAK(GetData()->nRefs == -1);

    if (GetData() != afxDataNil)
    {
        GetData()->nRefs = 1;
    }
}

///////////////////////////////////////////////////////////////////////////////
int CHString::Find(WCHAR ch) const
{
    // find first single character
    LPWSTR lpsz = wcschr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
int CHString::FindOneOf(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet!=0);

    LPWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);

    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
int CHString::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// find a sub-string (like strstr)
int CHString::Find(LPCWSTR lpszSub) const
{
    ASSERT_BREAK(lpszSub!=NULL);

    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeUpper()
{
    CopyBeforeWrite();
    ::_wcsupr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeLower()
{
    CopyBeforeWrite();
    ::_wcslwr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
//#ifndef _UNICODE
//void CHString::AnsiToOem()
//{
//  CopyBeforeWrite();
//  ::AnsiToOemW(m_pchData, m_pchData);
//}
//void CHString::OemToAnsi()
//{
//  CopyBeforeWrite();
//  ::OemToAnsi(m_pchData, m_pchData);
//}
//#endif

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CHString CHString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
    {
        nFirst = 0;
    }

    if (nCount < 0)
    {
        nCount = 0;
    }

    if (nFirst + nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength - nFirst;
    }

    if (nFirst > GetData()->nDataLength)
    {
        nCount = 0;
    }

    CHString dest;
    AllocCopy(dest, nCount, nFirst, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Right(int nCount) const
{
    if (nCount < 0)
    {
        nCount = 0;
    }
    else if (nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength;
    }

    CHString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Left(int nCount) const
{
    if (nCount < 0)
    {
        nCount = 0;
    }
    else if (nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength;
    }

    CHString dest;
    AllocCopy(dest, nCount, 0, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
// strspn equivalent
CHString CHString::SpanIncluding(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet != NULL);

    return Left(wcsspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// strcspn equivalent
CHString CHString::SpanExcluding(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet != NULL);

    return Left(wcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
void CHString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)

    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
            {
                lpszLast = lpsz;
            }
        }
        else
        {
            lpszLast = NULL;
        }

        lpsz = _wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start

        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

//////////////////////////////////////////////////////////////////////////////
void CHString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character

    LPCWSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
    {
        lpsz = _wcsinc(lpsz);
    }

    // fix up data and length

    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
    GetData()->nDataLength = nDataLength;
}

//////////////////////////////////////////////////////////////////////////////
// formatting (using wsprintf style formatting)
void __cdecl CHString::Format(LPCWSTR lpszFormat, ...)
{
    ASSERT_BREAK(lpszFormat!=NULL);

    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void __cdecl CHString::Format(UINT nFormatID, ...)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    CHString strFormat;
    
    strFormat.LoadStringW(nFormatID);

    va_list argList;
    va_start(argList, nFormatID);
    FormatV(strFormat, argList);
    va_end(argList);
#endif
}
#endif

class auto_va_list
{
  va_list& argList_;
public:
  auto_va_list(va_list& arg):argList_(arg){ };
  ~auto_va_list(){va_end(argList_);}
};

//////////////////////////////////////////////////////////////////////////////
// formatting (using FormatMessage style formatting)
void __cdecl CHString::FormatMessageW(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    
    auto_va_list _arg(argList);

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        LPWSTR lpszTemp = 0;

        if (::FormatMessageW(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            lpszFormat, 
            0, 
            0, 
            (LPWSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == 0)
	    throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR);
	
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
        ASSERT_BREAK(lpszTemp != NULL);

        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
    }
    else
    {
        LPSTR lpszTemp = 0;

        if (::FormatMessageA(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCTSTR) bstr_t(lpszFormat), 
            0, 
            0, 
            (LPSTR) &lpszTemp, 
            0, 
            &argList)==0 || lpszTemp == 0)
	  throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR);
	
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
        ASSERT_BREAK(lpszTemp != NULL);

        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
    }
}

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void __cdecl CHString::FormatMessageW(UINT nFormatID, ...)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    // get format string from string table
    CHString strFormat;
    
    strFormat.LoadStringW(nFormatID);

    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, nFormatID);
    auto_va_list _arg(argList);

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        LPWSTR lpszTemp = 0;

        if (::FormatMessageW(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCWSTR) strFormat, 
            0, 
            0, 
            (LPWSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == NULL)
        {
            // Should throw memory exception here.  Now we do.
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        };
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
	  // assign lpszTemp into the resulting string and free lpszTemp
          *this = lpszTemp;
    }
    else
    {
        LPSTR lpszTemp = 0;

        if (::FormatMessageA(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCSTR) bstr_t(strFormat), 
            0, 
            0, 
            (LPSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == NULL)
        {
            // Should throw memory exception here.  Now we do.
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
            // assign lpszTemp into the resulting string and free lpszTemp
            *this = lpszTemp;
        }
    }
#endif

}
#endif

///////////////////////////////////////////////////////////////////////////////
BSTR CHString::AllocSysString() const
{

    BSTR bstr;
    bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if ( ! bstr )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    ASSERT_BREAK(bstr!=NULL);

    return bstr;
}

///////////////////////////////////////////////////////////////////////////////
// CHString support for template collections
void ConstructElements(CHString* pElements, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pElements != NULL );

    for (; nCount--; ++pElements)
    {
        memcpy(pElements, &afxPchNil, sizeof(*pElements));
    }
}

void DestructElements(CHString* pElements, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pElements != NULL);

    for (; nCount--; ++pElements)
    {
        pElements->~CHString();
    }
}

void  CopyElements(CHString* pDest, const CHString* pSrc, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pDest != NULL );
    ASSERT_BREAK(nCount != 0 || pSrc != NULL );

    for (; nCount--; ++pDest, ++pSrc)
    {
        *pDest = *pSrc;
    }
}

UINT  HashKey(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
    {
        nHash = (nHash<<5) + nHash + *key++;
    }

    return nHash;
}

/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings
#ifdef _UNICODE
#define CHAR_FUDGE 1    // one WCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

#define STR_BLK_SIZE 256 

#ifdef FRAMEWORK_ALLOW_DEPRECATED
BOOL CHString::LoadStringW(UINT nID)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    // try fixed buffer first (to avoid wasting space in the heap)
    WCHAR szTemp[ STR_BLK_SIZE ];

    int nLen = LoadStringW(nID, szTemp, STR_BLK_SIZE);
    
    if (STR_BLK_SIZE - nLen > CHAR_FUDGE)
    {
        *this = szTemp;
    }
    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        int nSize = STR_BLK_SIZE;

        do
        {
            nSize += STR_BLK_SIZE;
            nLen = LoadStringW(nID, GetBuffer(nSize-1), nSize);

        } 
        while (nSize - nLen <= CHAR_FUDGE);

        ReleaseBuffer();
    }

    return nLen > 0;
#endif
    return FALSE;
}
#endif

#ifdef FRAMEWORK_ALLOW_DEPRECATED
int CHString::LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    int nLen;

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        nLen = ::LoadStringW(g_hModule, nID, lpszBuf, nMaxBuf);
        if (nLen == 0)
        {
            lpszBuf[0] = '\0';
        }
    }
    else
    {
        char *pszBuf = new char[nMaxBuf];
        if ( pszBuf )
        {
            nLen = ::LoadStringA(g_hModule, nID, pszBuf, nMaxBuf);
            if (nLen == 0)
            {
                lpszBuf[0] = '\0';
            }
            else
            {
                nLen = ::MultiByteToWideChar(CP_ACP, 0, pszBuf, nLen + 1, 
                            lpszBuf, nMaxBuf); 
                
                // Truncate to requested size  
                if (nLen > 0)
                {
                    // nLen doesn't include the '\0'.
                    nLen = min(nMaxBuf - 1, (UINT) nLen - 1); 
                }
                
                lpszBuf[nLen] = '\0'; 
            }
            
            delete pszBuf;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return nLen; // excluding terminator
#endif
    return 0;
}
#endif

#if (defined DEBUG || defined _DEBUG)
WCHAR CHString::GetAt(int nIndex) const
{ 
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    return m_pchData[nIndex]; 
}

WCHAR CHString::operator[](int nIndex) const
{   
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    return m_pchData[nIndex]; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\chptrarr.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  chptrarr.cpp
//
//  Purpose: Non-MFC CPtrArray class implementation
//
//***************************************************************************

//=================================================================

// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.
//===============================================================

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>
#include <chptrarr.h>
#include <AssertBreak.h>

CHPtrArray::CHPtrArray () : m_pData ( NULL ) ,
                            m_nSize ( 0 ) ,
                            m_nMaxSize ( 0 ) , 
                            m_nGrowBy ( 0 )
{
}

CHPtrArray::~CHPtrArray()
{
    if ( m_pData )
    {
        delete [] (BYTE*) m_pData ;
    }
}

void CHPtrArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_BREAK(nNewSize >= 0) ;

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy ;  // set new size
    }

    if (nNewSize == 0)
    {
        // shrink to nothing

        delete[] (BYTE*)m_pData ;
        m_pData = NULL ;
        m_nSize = m_nMaxSize = 0 ;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size

        m_pData = (void**) new BYTE[nNewSize * sizeof(void*)] ;
        if ( m_pData )
        {
            memset(m_pData, 0, nNewSize * sizeof(void*)) ;  // zero fill

            m_nSize = m_nMaxSize = nNewSize ;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits

        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*)) ;
        }

        m_nSize = nNewSize ;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy ;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8)) ;
        }

        int nNewMax ;
        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy ;  // granularity
        }
        else
        {
            nNewMax = nNewSize ;  // no slush
        }

        ASSERT_BREAK(nNewMax >= m_nMaxSize) ;  // no wrap around

        void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)] ;
        if ( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*)) ;

            // construct remaining elements
            ASSERT_BREAK(nNewSize > m_nSize) ;

            memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*)) ;

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData ;
            m_pData = pNewData ;
            m_nSize = nNewSize ;
            m_nMaxSize = nNewMax ;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

int CHPtrArray::Append(const CHPtrArray& src)
{
    ASSERT_BREAK(this != &src) ;   // cannot append to itself

    int nOldSize = m_nSize ;
    SetSize(m_nSize + src.m_nSize) ;

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*)) ;

    return nOldSize ;
}

void CHPtrArray::Copy(const CHPtrArray& src)
{
    ASSERT_BREAK(this != &src) ;   // cannot append to itself

    SetSize(src.m_nSize) ;

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*)) ;

}

void CHPtrArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size

        void** pNewData = NULL ;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void*)] ;
            if ( pNewData )
            {
                // copy new data from old   
                memcpy(pNewData, m_pData, m_nSize * sizeof(void*)) ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData ;
        m_pData = pNewData ;
        m_nMaxSize = m_nSize ;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CHPtrArray::SetAtGrow(int nIndex, void* newElement)
{
    ASSERT_BREAK(nIndex >= 0) ;

    if (nIndex >= m_nSize)
    {
        SetSize(nIndex+1) ;
    }

    m_pData[nIndex] = newElement ;
}

void CHPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
    ASSERT_BREAK(nIndex >= 0) ;    // will expand to meet need
    ASSERT_BREAK(nCount > 0) ;     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount) ;  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize ;
        SetSize(m_nSize + nCount) ;  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(void*)) ;

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(void*)) ;

    }

    // insert new value in the gap
    ASSERT_BREAK(nIndex + nCount <= m_nSize) ;
    while (nCount--)
    {
        m_pData[nIndex++] = newElement ;
    }
}

void CHPtrArray::RemoveAt(int nIndex, int nCount)
{
    ASSERT_BREAK(nIndex >= 0) ;
    ASSERT_BREAK(nCount >= 0) ;
    ASSERT_BREAK(nIndex + nCount <= m_nSize) ;

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount) ;

    if (nMoveCount)
    {
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(void*)) ;
    }

    m_nSize -= nCount ;
}

void CHPtrArray::InsertAt(int nStartIndex, CHPtrArray* pNewArray)
{
    ASSERT_BREAK(pNewArray != NULL) ;
    ASSERT_BREAK(nStartIndex >= 0) ;

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()) ;
        for (int i = 0 ; i < pNewArray->GetSize() ; i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i)) ;
        }
    }
}

// Inline functions (from CArray)
//===============================

inline int CHPtrArray::GetSize() const { 

    return m_nSize ; 
}

inline int CHPtrArray::GetUpperBound() const { 

    return m_nSize-1 ; 
}

inline void CHPtrArray::RemoveAll() { 

    SetSize(0, -1) ; 
    return ;
}

inline void *CHPtrArray::GetAt(int nIndex) const { 

    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    return m_pData[nIndex] ; 
}

inline void CHPtrArray::SetAt(int nIndex, void * newElement) {
 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    m_pData[nIndex] = newElement ; 
    return ;
}

inline void *&CHPtrArray::ElementAt(int nIndex) { 
    
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    return m_pData[nIndex] ; 
}

inline const void **CHPtrArray::GetData() const { 

    return (const void **) m_pData ; 
}

inline void **CHPtrArray::GetData() { 

    return (void **) m_pData ; 
}

inline int CHPtrArray::Add(void *newElement) { 

    int nIndex = m_nSize ;
    SetAtGrow(nIndex, newElement) ;
    return nIndex ; 
}

inline void *CHPtrArray::operator[](int nIndex) const { 

    return GetAt(nIndex) ; 
}

inline void *&CHPtrArray::operator[](int nIndex) { 

    return ElementAt(nIndex) ; 
}

// Diagnostics
//============

#ifdef _DEBUG

void CHPtrArray::AssertValid() const
{
    if (m_pData == NULL)
    {
        ASSERT_BREAK(m_nSize == 0) ;
        ASSERT_BREAK(m_nMaxSize == 0) ;
    }
    else
    {
        ASSERT_BREAK(m_nSize >= 0) ;
        ASSERT_BREAK(m_nMaxSize >= 0) ;
        ASSERT_BREAK(m_nSize <= m_nMaxSize) ;
    }
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\tracking.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  tracking.cpp
//
//  Purpose: 
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>


#define MAX_ELEMENTS 12000

int Trace(const char *fmt, ...);

void  __declspec( dllexport ) _SysFreeString( 
   BSTR  bstr,
   char *File,
   int nLine
   )
{
    Trace("    ## SysFreeString on 0x%X [%s, %d]\n", bstr, File, nLine);
}
   
BSTR  __declspec( dllexport ) _SysAllocString( 
   const OLECHAR FAR* sz,
   char *File,
   int nLine
   )
{
    BSTR Res = SysAllocString(sz);
    Trace("SysAllocString on 0x%X (%S) [%s, %d]\n", Res, sz, File, nLine);
    return Res;
}


HRESULT  __declspec( dllexport ) DetectLeaks()
{
    return 0;
}

void  __declspec( dllexport ) _VariantInit( 
   VARIANTARG FAR*  pvarg,
   char *File,
   int nLine 
   )
{
    Trace("VariantInit on 0x%X [%s, %d]\n", pvarg, File, nLine);
    VariantInit(pvarg);
}

HRESULT  __declspec( dllexport ) _VariantClear( 
   VARIANTARG FAR*  pvarg,
   char *File,
   int nLine
   )
{
    HRESULT hRes;

    char *p = 0;

    switch (V_VT(pvarg))
    {
        case VT_I4: p = "VT_I4"; break;
        case VT_I2: p = "VT_I2"; break;
        case VT_BSTR: p = "VT_BSTR"; break;
        case VT_UI1: p = "VT_UI1"; break;
        case VT_R8: p = "VT_R8"; break;
        default: "<VT_?>";
    }


    Trace("    ## VariantClear on 0x%X (%s)", pvarg, p);

    if (V_VT(pvarg) == VT_BSTR)
        Trace(" contains BSTR at address 0x%X (%S)", V_BSTR(pvarg), V_BSTR(pvarg));
    
    Trace(" [%s, %d]\n", File, nLine);
        

    hRes = VariantClear(pvarg);    
    return hRes;
    
}   

HRESULT  __declspec( dllexport ) _VariantCopy( 
    VARIANTARG FAR*  pvargDest, 
    const VARIANTARG FAR*  pvargSrc,
    char *File,
    int nLine
    )
{
    Trace("VariantCopy Dest=0x%X Src=0x%X [%s, %d]\n", pvargDest, pvargSrc,
        File, nLine);
        
    HRESULT hRes = VariantCopy(pvargDest, (VARIANT *) pvargSrc);

    return hRes;    
}    





CRITICAL_SECTION cs2;

int Trace(const char *fmt, ...)
{
    static BOOL bFirstCall = TRUE;
    
    if (bFirstCall)
    {
        InitializeCriticalSection(&cs2);
        bFirstCall = FALSE;
    }

    EnterCriticalSection(&cs2);
        
    char *buffer = new char[2048];

    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = vsprintf(buffer, fmt, argptr);
    va_end(argptr);

    int iRetries = 0;

    // Get time.
    // =========
    char timebuf[64];
    time_t now = time(0);
    struct tm *local = localtime(&now);
    strcpy(timebuf, asctime(local));
    timebuf[strlen(timebuf) - 1] = 0;   // O

    for (;;)
    {
        FILE *fp = fopen("C:\\OAMEM.LOG", "at");

        if (!fp && iRetries++ < 5)
        {
            Sleep(500);
            continue;
        }

        if (!fp)
            break;

        if (fp)
        {
            fprintf(fp, "%s", buffer);
            fclose(fp);
            break;
        }
    }

    delete buffer;
    LeaveCriticalSection(&cs2);
    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\utils.cpp ===
//***************************************************************************

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//  utils.cpp
//
//  Purpose: utility functions
//
//***************************************************************************

#include "precomp.h"
#include <utillib.h>
#include <utils.h>

// see comments in header
DWORD WINAPI NormalizePath(
                                    
    LPCWSTR lpwszInPath, 
    LPCWSTR lpwszComputerName, 
    LPCWSTR lpwszNamespace,
    DWORD dwFlags,
    CHString &sOutPath
)
{
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser    objpathParser;

    GetValuesForPropResults eRet = e_OK;

    int nStatus = objpathParser.Parse( lpwszInPath,  &pParsedPath );

    if ( 0 == nStatus )
    {
        try
        {
            // Check the machine name and namespace
            if (pParsedPath->IsRelative( lpwszComputerName, lpwszNamespace ))
            {
                // If there is only one key, null out the property name (easier than trying
                // to find the key name if it is missing).
                if (pParsedPath->m_dwNumKeys == 1)
                {
                    if (pParsedPath->m_paKeys[0]->m_pName != NULL)
                    {
                        if (!(dwFlags & NORMALIZE_NULL))
                        {
                        }
                        else
                        {
                            delete pParsedPath->m_paKeys[0]->m_pName;
                            pParsedPath->m_paKeys[0]->m_pName = NULL;
                        }
                    }
                    else
                    {
                        if (!(dwFlags & NORMALIZE_NULL))
                        {
                            eRet = e_NullName;
                        }
                    }
                }

                if (eRet == e_OK)
                {
                    // Reform the object path, minus machine name and namespace name
                    LPWSTR pPath = NULL;
                    if (objpathParser.Unparse(pParsedPath, &pPath) == 0)
                    {
                        try
                        {
                            sOutPath = pPath;
                        }
                        catch ( ... )
                        {
                            delete pPath;
                            throw;
                        }
                        delete pPath;
                    }
                    else
                    {
                        sOutPath.Empty();
                        eRet = e_UnParseError;
                    }
                }
            }
            else
            {
                sOutPath.Empty();
                eRet = e_NonLocalPath;
            }
        }
        catch (...)
        {
            objpathParser.Free( pParsedPath );
            throw;
        }

        objpathParser.Free( pParsedPath );
    }
    else
    {
        sOutPath.Empty();
        eRet = e_UnparsablePath;
    }

    return eRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\analyser.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  analyser.h
//
//  Purpose: query analysis support.
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include <stdio.h>

#pragma warning(4 : 4275 4800 4786 4251)

#include <wbemidl.h>
#include <GenLex.h>
#include <SQLLex.h>
#include <SQL_1.h>       // SQL level 1 tokens and expressions  
#include <chstring.h>
#include <chstrarr.h>
#include <comdef.h>
#include <vector>

#define DELETE_ME 
//-----------------------------


class CQueryAnalyser
{
public:

    static HRESULT WINAPI GetNecessaryQueryForProperty (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
		IN LPCWSTR wszPropName,
		DELETE_ME SQL_LEVEL_1_RPN_EXPRESSION *&pNewExpr
	) ;

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		CHStringArray& awsVals
	) ;

    // overloaded version in case client wants to use vector of _bstr_t's:

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		std::vector<_bstr_t> &vectorVals
	) ;

    static HRESULT WINAPI GetValuesForProp (

	    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
	    std::vector<int> &vectorVals
    );

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		std::vector<_variant_t> &vectorVals
	) ;

protected:

    static BOOL WINAPI IsTokenAboutProperty (

		IN SQL_LEVEL_1_TOKEN &Token,
		IN LPCWSTR wszPropName
	) ;

    static void WINAPI AppendQueryExpression (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pDest,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSource
	) ;

    static HRESULT WINAPI AndQueryExpressions (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
		OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
	) ;

    static HRESULT WINAPI OrQueryExpressions (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
		OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
	);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\chstest\cstrest.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
/////////////////////////////////////////////////////////////////////
//
//  Tests the CHString class
//
/////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <chstring.h>
#include <chstrarr.h>
#include <stdio.h>
#include "resource.h"
//#include <dbgalloc.h>
/////////////////////////////////////////////////////////////////////////
void TestCHString (void)
{
    CHString sTemp;
    CHString sResource;

    sResource.LoadString(IDS_STRING1);

    printf( "%0x Should say TestResource: %s\n",&sResource, (const char*) sResource );

    sTemp = "" ;
    sTemp = "This is a temporary string" ;
    sTemp = "" ;


    ////////////////////////////////////////////////////////////////////
    CHString Tmp("Tmp");
    printf( "%0x Should say Tmp: %s\n",&Tmp, (const char*) Tmp );

    ////////////////////////////////////////////////////////////////////
    CHString TestIt;
    TestIt = Tmp;
    printf( "Should say Tmp: %s\n",(const char*) TestIt );
    printf( "Should have different addresses: %0x %0x\n", &Tmp,&TestIt );

    ////////////////////////////////////////////////////////////////////
    if( TestIt == Tmp ){
        printf("Yep, these strings match: %s, %s\n",(const char*) Tmp, (const char*)TestIt );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }
    ////////////////////////////////////////////////////////////////////
    TestIt = "New String";
    if( TestIt > Tmp ){
        printf("%s is larger than %s\n", (const char*) TestIt, (const char*)Tmp );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }

    if( TestIt > "NEWBIE"){
        printf("%s is larger than %s\n", (const char*) TestIt, (const char*)"NEWBIE" );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }
    ////////////////////////////////////////////////////////////////////
    if( TestIt < Tmp ){
        printf ( "*******************BIG TIME ERROR!\n");
    }
    else{
        printf("%s is not smaller than %s\n", (const char*) TestIt, (const char*)Tmp );
    }

    if( TestIt < "THIS"){
        printf ( "*******************BIG TIME ERROR!\n");
    }
    else{
        printf("%s is not smaller than %s\n", (const char*) TestIt, (const char*)Tmp );
    }
    
    ////////////////////////////////////////////////////////////////////
    TestIt = "Me";
    if( TestIt < Tmp ){
        printf("%s is smaller than %s\n", (const char*) TestIt, (const char*)Tmp );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }

    if( TestIt < "THIS"){
        printf("%s is smaller than %s\n", (const char*) TestIt, (const char*)Tmp );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }

    ////////////////////////////////////////////////////////////////////
    TestIt = "Tmp";
    if( TestIt == Tmp ){
        printf("%s is equal to %s\n", (const char*) TestIt, (const char*)Tmp );
    }
    else{
        printf ( "*******************BIG TIME ERROR!\n");
    }
    ////////////////////////////////////////////////////////////////////
    CHString NewStr("Jenny's New String");
    printf(" This should say: Jenny's New String: %s\n", (const char*) NewStr );
    if( stricmp( (const char*) NewStr, "Jenny's New String" ) != 0 )
        printf ( "*******************BIG TIME ERROR!\n");

    CHString New;
    New = Tmp + NewStr;
    printf( "New string is: %s",(const char*) New );
    // example for CString::CString
    CHString s1;                    // Empty string
    CHString s2( "cat" );           // From a C string literal
    CHString s3 = s2;               // Copy constructor
    CHString s4( s2 + " " + s3 );   // From a string expression

    CHString s5( 'x' );             // s5 = "x"
    CHString s6( 'x', 6 );          // s6 = "xxxxxx"

    s2=s5;
    s6="YES";
    CHString str;
    str.GetBuffer(1024);
    str.Format("%s-%d", "LaDeDah",2);

    printf(" Formatted string is: %s\n", (const char*) str );

}
////////////////////////////////////////////////////////////////////
void AddStuff( CHStringArray & array )
{
    CHString Tmp = "Test 0";
    array.Add(Tmp); // Element 0
    array.Add( CHString("Test 1") ); // Element 1

}
////////////////////////////////////////////////////////////////////
void TestCHStringArray()
{
    CHStringArray array;

    AddStuff(array);

    int nLargestIndex = array.GetUpperBound(); // Largest index
    if( nLargestIndex != 1 )
        printf ( "*******************BIG TIME ERROR!\n");
  
    int nSize = array.GetSize();
    if( nSize != 2 )
        printf ( "*******************BIG TIME ERROR!\n");

    array.RemoveAll(); // Pointers removed but objects not deleted.

    nSize = array.GetSize();
    if( nSize != 0 )
        printf ( "*******************BIG TIME ERROR!\n");

    CHString Tmp="Test 0";
    array.Add( Tmp ); // Element 0
    array.Add( CHString("Test 1") ); // Element 1
    array.Add( CHString("Test 2") ); // Element 2

    Tmp = array.GetAt( 0 );
    if( Tmp != "Test 0" )
        printf ( "*******************BIG TIME ERROR!\n");

    array.SetAt( 0, CHString("New Test") );  // Replace element 0.
 
    array.SetAtGrow( 3, CHString("Grow Test")); // Element 2 deliberately
                                                    // skipped.
    array.InsertAt( 1, CHString("Insert Test"));  // New element 1

    nSize = array.GetSize();
    //////////////////////////////////////////////
    Tmp = array.GetAt( 0 );
    if( Tmp != "New Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 1 );
    if( Tmp != "Insert Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 2 );
    if( Tmp != "Test 1" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 3 );
    if( Tmp != "Test 2" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 4 );
    if( Tmp != "Grow Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    array.RemoveAt( 2 );  // Element 1 moves to 0.
    nSize = array.GetSize();
    if( nSize != 4 )
        printf ( "*******************BIG TIME ERROR!\n");

    //////////////////////////////////////////////
    Tmp = array.GetAt( 0 );
    if( Tmp != "New Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 1 );
    if( Tmp != "Insert Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 2 );
    if( Tmp != "Test 2" )
        printf ( "*******************BIG TIME ERROR!\n");

    Tmp = array.GetAt( 3 );
    if( Tmp != "Grow Test" )
        printf ( "*******************BIG TIME ERROR!\n");

    printf("Done with CHStringArray!!!\n");
}

void main(void)
{
    TestCHString();
//    DEBUG_DumpAllocations("cstring.leak");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\assertbreak.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  AssertBreak.h
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ASSERT_BREAK_HMH_
#define _ASSERT_BREAK_HMH_

#include <polarity.h>

// Needed to add L to the __FILE__
#define __FRT2(x)      L ## x
#define _FRT2(x)       __FRT2(x)

// We'll need both of these values in case we're running in NT.
// Since our project is not an NT-only project, these are #ifdefd
// out of windows.h

#ifndef _WIN32_WINNT
#define MB_SERVICE_NOTIFICATION          0x00200000L
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

void POLARITY WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFilename, int nLine );

#if (defined DEBUG || defined _DEBUG)
#define ASSERT_BREAK(exp)    \
    if (!(exp)) { \
        assert_break( _FRT2(#exp), _FRT2(__FILE__), __LINE__ ); \
    }
#else
#define ASSERT_BREAK(exp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\chstest\resource.h ===
// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chstest.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\wbemtime.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  wbemtime.cpp 
//
//  Purpose: Defines the WBEMTime and WBEMTimeSpan objects which are 
//  similar to the MFC CTime and CTimeSpan objects.  The WBEM versions
//  are capable of storing down to the nsec and also have functions for
//  Creating from and getting BSTRs.
//
//  Note; The current implementation of WBEMTime does not support dates 
//  before 1/1/1601;
//
//  WBEMTime::m_uTime is stored in GMT as 100 nsecs since 1/1/1601
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#pragma warning( disable : 4290 ) 

#ifdef UTILLIB
#include <assertbreak.h>
#else
#define ASSERT_BREAK(a)
#endif //UTILLIB

#include <WbemTime.h>
#include <comdef.h>


// These are here rather than wbemtime.h so we don't have to doc/support
#define DECPOS 14
#define SGNPOS 21
#define DMTFLEN 25

#define DEPRECATED 0
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

// ****************************************************************
// Static functions and variables.  These can't be called/referenced
// outside of wbemtime.cpp

static WBEMTime g_Jan1970((time_t)0);

//***************************************************************************
//
//  StructtmToSystemTime
//
//  Description:  General utility for converting between the two common
//  data structures.
//
//  Return values: TRUE if OK;  
//
//***************************************************************************

static BOOL StructtmToSystemTime(const struct tm *ptm, SYSTEMTIME * pst)
{
    if (pst && ptm)
    {
        pst->wYear = ptm->tm_year + 1900; 
        pst->wMonth = ptm->tm_mon + 1; 
        pst->wDay = (WORD)ptm->tm_mday; 
        pst->wHour = (WORD)ptm->tm_hour; 
        pst->wMinute = (WORD)ptm->tm_min; 
        pst->wSecond = (WORD)ptm->tm_sec;
        pst->wDayOfWeek = (WORD)ptm->tm_wday;
        pst->wMilliseconds = 0;

        return TRUE;
    }

    return FALSE;
}

static BOOL SystemTimeToStructtm(const SYSTEMTIME *pst, struct tm *ptm)
{
    if (pst && ptm && pst->wYear >= 1900)
    {
        ptm->tm_year = pst->wYear - 1900; 
        ptm->tm_mon = pst->wMonth - 1; 
        ptm->tm_mday = pst->wDay; 
        ptm->tm_hour = pst->wHour; 
        ptm->tm_min = pst->wMinute; 
        ptm->tm_sec = pst->wSecond;
        ptm->tm_wday = pst->wDayOfWeek;
        ptm->tm_isdst = 0;  // Since we are working in gmt...

        return TRUE;
    }

    return FALSE;
}

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

LONG WBEMTime::GetLocalOffsetForDate(const time_t &t)
{
    FILETIME ft;
    ULONGLONG ull = Int32x32To64(t, 10000000) + 116444736000000000;

    ui64ToFileTime(&ull, &ft);

    return GetLocalOffsetForDate(&ft);
}

LONG WBEMTime::GetLocalOffsetForDate(const struct tm *ptmin)
{
    SYSTEMTIME st;

    StructtmToSystemTime(ptmin, &st);
    
    return GetLocalOffsetForDate(&st);
}

LONG WBEMTime::GetLocalOffsetForDate(const FILETIME *pft)
{
    SYSTEMTIME st;

    FileTimeToSystemTime(pft, &st);
    
    return GetLocalOffsetForDate(&st);
}

LONG WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator=(BSTR bstrWbemFormat) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  The string must have the format:
//  YYYYMMDDHHSS.123456789    So 3:04 am, 1/1/96 would be 199601010304.0
//
//  or the format yyyymmddhhmmss.mmmmmmsuuu.
//
//  Note that the fractional part can be between 1 and nine digits.   
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const BSTR bstrWbemFormat)
{
    Clear();   // set when properly assigned

    if((NULL == bstrWbemFormat) || 
        bstrWbemFormat[DECPOS] != L'.'
        )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    if ( (wcslen(bstrWbemFormat) == DMTFLEN) &&
        (bstrWbemFormat[SGNPOS] == L'+' || bstrWbemFormat[SGNPOS] == L'-') )
    {
        SetDMTF(bstrWbemFormat);
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }
 
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
    FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
    {
        // now assign using a FILETIME.
        *this = t_ft;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const FILETIME & ft)
{
    FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(struct tm tmin) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard c runtine struct tm stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const struct tm &a_tmin)
{
    Clear();   // set when properly assigned

    SYSTEMTIME systemTime;
    if (StructtmToSystemTime(&a_tmin, &systemTime))
    {
        *this = systemTime;
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(struct time_t t) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard c runtine time_t stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const time_t & t)
{
    if (t >= 0)
    {
        m_uTime = Int32x32To64(t, 10000000) + 116444736000000000;
    }
    else
    {
        Clear();
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTime &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

WBEMTime WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk() && uAdd.IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTime &WBEMTime::operator+=( const WBEMTimeSpan &ts )
{ 
    if (IsOk() && ts.IsOk())
    {
        m_uTime += ts.m_Time ; 
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this ; 
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTime::operator-(const WBEMTime & sub)
{
    WBEMTimeSpan ret;

    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_uTime))
    {
        ret.m_Time = m_uTime-sub.m_uTime;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

WBEMTime WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTime &WBEMTime::operator-=(const WBEMTimeSpan & sub)
{
    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_Time))
    {
        m_uTime -= sub.m_Time;
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::GetBSTR(void)
//
//  This function used to CLAIM to do this:
//
//  WRONG Description:  Converts the time which is stored as the number of 
//  nano seconds since 1970 into a bstr with this format.
//  YYYYMMDDHHSS.123456789    So 3:04 am, 1/1/96 would be 199601010304.000000000
//
//  What it really did was return some bastardized form of a dmtf string.  Now
//  it returns a dmtf string in gmt form (which is what the docs claim).
//
//  Return: BSTR representation of time, or NULL if error.  Note that the
//  caller should free up this string!
//
//***************************************************************************

BSTR WBEMTime::GetBSTR(void) const
{
    return GetDMTF(false) ;
}

//***************************************************************************
//
//  WBEMTime::GetDMTFNonNtfs(void)
//
//***************************************************************************

BSTR WBEMTime::GetDMTFNonNtfs(void) const
{
    FILETIME t_ft1, t_ft2;
    BSTR t_Date = NULL;

    if (GetFILETIME(&t_ft1) && FileTimeToLocalFileTime(&t_ft1, &t_ft2))
    {
        t_Date = WBEMTime(t_ft2).GetDMTF();

        if (t_Date != NULL)
        {
            t_Date[21] = L'+';
            t_Date[22] = L'*';
            t_Date[23] = L'*';
            t_Date[24] = L'*';
        }
    }

    return t_Date;
}

//***************************************************************************
//
//  WBEMTime::time_t(time_t * ptm)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::Gettime_t(time_t * ptm) const
{
    if( (!IsOk()) || (ptm == NULL) || (*this < g_Jan1970))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    if (g_Jan1970 != *this)
    {
        LONGLONG t_tmp = ( (m_uTime - g_Jan1970.m_uTime) / 10000000);

        if (t_tmp <= (LONGLONG)0xffffffff)
        {
            *ptm = (time_t)t_tmp;
        }
        else
        {
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
            return FALSE;
        }
    }
    else
    {
        *ptm = 0;
    }

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetStructtm(struct tm * ptm)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetStructtm(struct tm * ptm) const
{
    SYSTEMTIME systemTime;

    return (GetSYSTEMTIME(&systemTime) && SystemTimeToStructtm(&systemTime, ptm));
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
    if ((pst == NULL) || (!IsOk()))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    FILETIME t_ft;

    if (GetFILETIME(&t_ft))
    {
        if (!FileTimeToSystemTime(&t_ft, pst))
        {
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetFILETIME(FILETIME * pft) const
{
    if ((pft == NULL) || (!IsOk()))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  CWbemTime::SetDMTF(BSTR wszText)
//
//  Description:  Sets the time value to the DMTF string datetime value
//  passed as the parameter
//
//  Return: TRUE if OK.
//
//***************************************************************************
BOOL WBEMTime::SetDMTF( const BSTR a_wszText )
{

    wchar_t t_DefaultBuffer[] = {L"16010101000000.000000+000"} ;
    wchar_t t_DateBuffer[ DMTFLEN + 1 ] ;
            t_DateBuffer[ DMTFLEN ] = NULL ;

    bstr_t  t_bstrDate( a_wszText ) ;

    // wildcard cleanup and validation
    // ===============================

    if( DMTFLEN != t_bstrDate.length() )
    {
        ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
        return FALSE ;  
    }
    
    wchar_t *t_pwBuffer = (wchar_t*)t_bstrDate ;
    
    for( int t_i = 0; t_i < DMTFLEN; t_i++ )
    {
        switch( t_pwBuffer[ t_i ] )
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                // stepping on separator or sign
                if( DECPOS == t_i || SGNPOS == t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;
                
                break ;
            }           
            case '*':
            {               
                // stepping on separator or sign
                if( DECPOS == t_i || SGNPOS == t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                else
                {
                    // replace with default stamp
                    t_DateBuffer[ t_i ] = t_DefaultBuffer[ t_i ] ; 
                }   
                break ;
            }           
            case '.':
            {
                if( DECPOS != t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;

                break ;
            }           
            case '+':
            case '-':
            {
                if( SGNPOS != t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;
                break ;
            }           
            default:
            {
                ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                return FALSE ;
            }           
        }
    }

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        (LPCWSTR)&t_DateBuffer, 
        L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
        &nYear, 
        &nMonth, 
        &nDay, 
        &nHour, 
        &nMinute, 
        &nSecond, 
        &nMicro, 
        &wchSep, 
        &nOffset
    );

    if ( ( 9 != nRes )  || ( 1601 > nYear) )    
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return FALSE;
    }

    // Convert it to SYSTEMTIME
    // ========================

    SYSTEMTIME st;
    st.wYear        = (WORD)nYear;
    st.wMonth       = (WORD)nMonth;
    st.wDay         = (WORD)nDay;
    st.wHour        = (WORD)nHour;
    st.wMinute      = (WORD)nMinute;
    st.wSecond      = (WORD)nSecond;
    st.wMilliseconds = nMicro / 1000;
    st.wDayOfWeek   = 0;

    *this = st;

    // NOW we adjust for the offset
    // ============================

    if ( IsOk() )
    {
        int nSign = (wchSep == L'+') ? 1 : -1 ;
        
        m_uTime -= (LONGLONG)nSign * (LONGLONG)nOffset * 60 * 10000000;
    }
    else
    {
        ASSERT_BREAK( INVALID_TIME_ARITHMETIC ) ;
        return FALSE ;
    }

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(void)
//
//  Description:  Gets the time in DMTF string datetime format. User must call
//  SysFreeString with the result. If bLocal is true, then the time is given
//  in the local timezone, else the time is given in GMT.
//
//  Return: NULL if not OK.
//
//***************************************************************************


BSTR WBEMTime::GetDMTF(BOOL bLocal) const
{

    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return NULL;
    }

    SYSTEMTIME t_Systime;
    wchar_t chsign = L'-';
    int offset = 0;

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
    ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
    t_ConversionZone = t_ConversionZone * 10000000L ;
    if ( !bLocal || ( m_uTime < t_ConversionZone ) )
    {
        if(!GetSYSTEMTIME(&t_Systime))
        {
            return NULL;
        }
    }
    else
    {
        if (GetSYSTEMTIME(&t_Systime))
        {
            offset = GetLocalOffsetForDate(&t_Systime);

            WBEMTime wt;
            if (offset >= 0)
            {
                chsign = '+';
                wt = *this + WBEMTimeSpan(0, 0, offset, 0);
            }
            else
            {
                offset *= -1;
                wt = *this - WBEMTimeSpan(0, 0, offset, 0);
            }
            wt.GetSYSTEMTIME(&t_Systime);
        }
        else
        {
            return NULL;
        }
    }

    LONGLONG tmpMicros = m_uTime%10000000;
    LONG micros = (LONG)(tmpMicros / 10);

    BSTR t_String = SysAllocStringLen(NULL, DMTFLEN + 1);
    if ( ! t_String ) 
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    swprintf(

        t_String,
        L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d%c%03.3ld",
        t_Systime.wYear,
        t_Systime.wMonth, 
        t_Systime.wDay,
        t_Systime.wHour,
        t_Systime.wMinute,
        t_Systime.wSecond,
        micros, 
        chsign, 
        offset
    );

    return t_String ;

}

///////////////////////////////////////////////////////////////////////////
// WBEMTimeSpan - This class holds timespan values.  The data is stored
// in 100 nanosecond units (like FILETIME). 

//***************************************************************************
//
//  WBEMTimeSpan::WBEMTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
//                int iMSec, int iUSec, int iNSec)
//
//  Description:  Constructor.
//
//***************************************************************************

WBEMTimeSpan::WBEMTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
                int iMSec, int iUSec, int iNSec)
{
    m_Time = 0;        //todo, check values!!!
    m_Time += iSeconds;
    m_Time += iMinutes * 60;
    m_Time += iHours * 60 * 60;
    m_Time += iDays * 24 * 60 * 60;
    m_Time *= 10000000;
    m_Time += iNSec / 100;  // Nanoseconds
    m_Time += iUSec*10;   // Microseconds
    m_Time += iMSec*10000; // Milliseconds
}

WBEMTimeSpan::WBEMTimeSpan ( const FILETIME &ft )
{
    ASSERT_BREAK(DEPRECATED);
    *this = ft ; 
}

WBEMTimeSpan::WBEMTimeSpan ( const time_t & t )
{
    ASSERT_BREAK(DEPRECATED);
    *this = t ; 
} ;

//***************************************************************************
//
//  WBEMTimeSpan::operator=(const BSTR bstrWbemFormat) 
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

const WBEMTimeSpan & WBEMTimeSpan::operator=(const BSTR bstrWbemFormat)
{
    Clear();

    // all characters should be digits except for one which 
    // must be a period

    if ((bstrWbemFormat == NULL) || (bstrWbemFormat[DECPOS] != L'.') ||
        (wcslen(bstrWbemFormat) != DMTFLEN) || (bstrWbemFormat[SGNPOS] != L':') )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    int nDays, nHours, nMinutes, nSeconds, nMicros, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        bstrWbemFormat, 
        L"%8d%2d%2d%2d.%6d%c%3d", 
        &nDays, 
        &nHours, 
        &nMinutes, 
        &nSeconds, 
        &nMicros, 
        &wchSep, 
        &nOffset
    );

    if ( (nRes != 7) || ( nOffset != 0) )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    *this = WBEMTimeSpan(nDays, nHours, nMinutes, nSeconds, 0, nMicros, 0);

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::operator=(const FILETIME &) 
//  WBEMTimeSpan::operator=(const time_t &) 
//
//  Description:  Assignment operator which is also used by the constructor.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

const WBEMTimeSpan &  WBEMTimeSpan::operator=(const FILETIME &ft)
{
    ASSERT_BREAK(DEPRECATED);

    ULONGLONG uTemp;
    FileTimeToui64(&ft, &uTemp);
    m_Time = uTemp;

    return *this;
}

const WBEMTimeSpan &  WBEMTimeSpan::operator=(const time_t & t)
{
    ASSERT_BREAK(DEPRECATED);

    ULONGLONG uTemp = 0;

    uTemp = t;
    if (t >= 0)
    {
        m_Time = uTemp * 10000000;
    }
    else
    {
        Clear();
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::operator +(const WBEMTimeSpan &uAdd)
//
//  Description:  function for adding two WBEMTimeSpan objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTimeSpan::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTimeSpan ret;

    if (IsOk() && uAdd.IsOk())
    {
        ret.m_Time = m_Time + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTimeSpan &WBEMTimeSpan::operator+= ( const WBEMTimeSpan &uAdd )
{ 
    if (IsOk() && uAdd.IsOk())
    {
        m_Time += uAdd.m_Time ; 
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this ; 
}

//***************************************************************************
//
//  WBEMTimeSpan::operator -(const WBEMTimeSpan &uAdd)
//
//  Description:  function for adding two WBEMTimeSpan objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTimeSpan::operator-(const WBEMTimeSpan &uSub) const
{
    WBEMTimeSpan ret;
    
    if (IsOk() && uSub.IsOk() && (m_Time >= uSub.m_Time))
    {
        ret.m_Time = m_Time - uSub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTimeSpan &WBEMTimeSpan::operator-= ( const WBEMTimeSpan &uSub ) 
{
    if (IsOk() && uSub.IsOk() && (m_Time >= uSub.m_Time))
    {
        m_Time -= uSub.m_Time;
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::GetBSTR(void)
//
//  Description:  Converts the time which is stored as the number of 
//  100 nano second units into a dmtf formatted string
//  ddddddddhhmmss.mmmmmm:000
//
//  Return: BSTR representation of time, or NULL if error.  Note that the
//  caller should free up this string!
//
//***************************************************************************

BSTR WBEMTimeSpan::GetBSTR(void) const
{
    if(!IsOk())
    {
        return NULL;
    }

    ULONGLONG Time = m_Time;

    // The /10 is to convert from 100ns to microseconds
    long iMicro = (long)((Time % 10000000) / 10);
    Time /= 10000000;
    int iSec = (int)(Time % 60);
    Time /= 60;
    int iMin = (int)(Time % 60);
    Time /= 60;
    int iHour = (int)(Time % 24);
    Time /= 24;

    BSTR t_String = SysAllocStringLen(NULL, DMTFLEN + 1);
    if ( ! t_String ) 
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    swprintf(t_String, L"%08I64i%02d%02d%02d.%06ld:000",
                Time, iHour, iMin, iSec, iMicro);

    return t_String ;
}

//***************************************************************************
//
//  WBEMTimeSpan::Gettime_t(void)
//  WBEMTimeSpan::GetFILETIME(void)
//
//  Description:  Converts the time span which is stored as the number of 
//  nano seconds into common stuctures.
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTimeSpan::Gettime_t(time_t * ptime_t) const
{
    ASSERT_BREAK(DEPRECATED);

    if(!IsOk())
    {
        return FALSE;
    }

    *ptime_t = (DWORD)(m_Time / 10000000);

    return TRUE;
}

BOOL WBEMTimeSpan::GetFILETIME(FILETIME * pst) const
{
    ASSERT_BREAK(DEPRECATED);

    if(!IsOk())
    {
        return FALSE;
    }

    ULONGLONG uTemp;
    uTemp = m_Time;
    ui64ToFileTime(&uTemp,pst);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\autoimprevert.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CAutoImpRevert class header
// Created:  10/4/2000
// Author: khughes

#pragma once
#pragma warning( disable : 4290 ) 


class CAutoImpRevert;
class CAutoImpError;



class CAutoImpRevert
{
public:
    CAutoImpRevert(
        BOOL fOpenAsSelf = TRUE) throw(CAutoImpError);
    
    virtual ~CAutoImpRevert();

    DWORD LastError() const;

private:
    bool GetCurrentImpersonation(
        BOOL fOpenAsSelf);

    bool Revert();

    HANDLE m_hOriginalUser;
    DWORD m_dwLastError;

};




class CAutoImpError
{
public:
    
    CAutoImpError(
        LPCWSTR wstrDescription)
    {
        m_chstrDescription = wstrDescription;    
    }

    CAutoImpError(const CAutoImpError& err)
    {
        m_chstrDescription = err.m_chstrDescription;
    }   

    virtual ~CAutoImpError() {}
    
    CHString GetDescription() const
    {
        return m_chstrDescription;
    }


private:
    CHString m_chstrDescription;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\cnvmacros.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  cnvmacros.h
//
//  Purpose: Converts ansi to wcs or wcs to ansi using stack
//
//
//                          WARNING!
//
//  Do not attempt to use these functions on strings longer than _MAX_PATH
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CNVMACROS_H_
#define _CNVMACROS_H_

#include <assertbreak.h>

#define WCSTOANSISTRING(x, y, conversionFailure )                                                                                       \
        char t_##x[_MAX_PATH];                                                                                      \
        {                                                                                                           \
			conversionFailure = false ;																				\
        	int nLen = ::WideCharToMultiByte(CP_ACP, 0, x, -1, t_##x, _MAX_PATH, NULL, NULL);                       \
            if (nLen != 0)                                                                                          \
            {                                                                                                       \
                y = t_##x;                                                                                          \
	        }                                                                                                       \
            else                                                                                                    \
            {                                                                                                       \
                ASSERT_BREAK(0);                                                                                    \
				conversionFailure = true ;																			\
                y = NULL;                                                                                           \
            }                                                                                                       \
        }                                                                                                           \

#define ANSISTRINGTOWCS(in, out, conversionFailure )                                                                                    \
        WCHAR t_##x[_MAX_PATH];																							\
        {                                                                                                           \
			conversionFailure = false ;																				\
	        int nLen = MultiByteToWideChar(CP_ACP, 0, in, -1, t_##x, sizeof(t_##x)/sizeof(WCHAR));					\
            if (nLen != 0)                                                                                          \
            {                                                                                                       \
                out = t_##x;                                                                                        \
            }                                                                                                       \
            else                                                                                                    \
            {                                                                                                       \
                ASSERT_BREAK(0);                                                                                    \
				conversionFailure = true ;																			\
                out = NULL;                                                                                         \
            }                                                                                                       \
        }                                                                                                           \

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\pragma.h ===
// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
#pragma comment(lib, "wbemuuid.lib")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\chstrarr.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  CHSTRARR.H
//
//  Purpose: Utility library version of MFC CHStringArray
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHStringArray_
#define _CHStringArray_

#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHStringArray 
{
    public:

        CHStringArray();
        ~CHStringArray();

        // Attributes
        int GetSize() const             { return m_nSize; }
        int GetUpperBound() const       { return m_nSize-1; }
        void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

        // Operations
        // Clean up
        void FreeExtra() throw ( CHeap_Exception ) ;
        void RemoveAll()                { SetSize(0); }

        // Accessing elements
#if (!defined DEBUG && !defined _DEBUG)
        CHString GetAt(int nIndex) const{ return m_pData[nIndex]; }
        void SetAt(int nIndex, LPCWSTR newElement){ m_pData[nIndex] = newElement; }
        CHString& ElementAt(int nIndex) { return m_pData[nIndex]; }
#else
        CHString GetAt(int nIndex) const;
        void SetAt(int nIndex, LPCWSTR newElement);
        CHString& ElementAt(int nIndex);
#endif

        // Direct Access to the element data (may return NULL)
        const CHString* GetData() const { return (const CHString*)m_pData; }
        CHString* GetData()             { return (CHString*)m_pData; }

        // Potentially growing the array
        void SetAtGrow(int nIndex, LPCWSTR newElement) throw ( CHeap_Exception ) ;
        int Add(LPCWSTR newElement) throw ( CHeap_Exception ) 
        { 
            int nIndex = m_nSize;
            SetAtGrow(nIndex, newElement);
            return nIndex; 
        }

        int Append(const CHStringArray& src) throw ( CHeap_Exception ) ;
        void Copy(const CHStringArray& src) throw ( CHeap_Exception ) ;

        // overloaded operator helpers
        CHString operator[](int nIndex) const { return GetAt(nIndex); }
        CHString& operator[](int nIndex)      { return ElementAt(nIndex); }

        // Operations that move elements around
        void InsertAt(int nIndex, LPCWSTR newElement, int nCount = 1) throw ( CHeap_Exception ) ;
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CHStringArray* pNewArray) throw ( CHeap_Exception ) ;

        // Implementation

    protected:
        CHString* m_pData;      // the actual array of data
        int m_nSize;            // # of elements (upperBound - 1)
        int m_nMaxSize;         // max allocated
        int m_nGrowBy;          // grow amount
                                // local typedefs for class templates
        typedef CHString BASE_TYPE;
        typedef LPCWSTR BASE_ARG_TYPE;
};
////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\chptrarr.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  chptrarr.h
//
//  Purpose: Non-MFC CPtrArray class definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CHPTRARRAY__
#define __CHPTRARRAY__

#include <windows.h>
#include <limits.h>
#include <assert.h>
#include <tchar.h>
#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHPtrArray
{
    public :

        // Construction/destruction
        //=========================

    CHPtrArray() ;

// Attributes
    int GetSize() const ;
    int GetUpperBound() const ;
    void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

// Operations
    // Clean up
    void FreeExtra() throw ( CHeap_Exception ) ;
    void RemoveAll() ;

    // Accessing elements
    void* GetAt(int nIndex) const ;
    void SetAt(int nIndex, void* newElement) ;
    void*& ElementAt(int nIndex) ;

    // Direct Access to the element data (may return NULL)
    const void** GetData() const ;
    void** GetData() ;

    // Potentially growing the array
    void SetAtGrow(int nIndex, void* newElement) throw ( CHeap_Exception ) ;
    int Add(void* newElement) throw ( CHeap_Exception ) ;
    int Append(const CHPtrArray& src) throw ( CHeap_Exception ) ;
    void Copy(const CHPtrArray& src) throw ( CHeap_Exception ) ;

    // overloaded operator helpers
    void* operator[](int nIndex) const ;
    void*& operator[](int nIndex) ;

    // Operations that move elements around
    void InsertAt(int nIndex, void* newElement, int nCount = 1) throw ( CHeap_Exception ) ;
    void RemoveAt(int nIndex, int nCount = 1) ;
    void InsertAt(int nStartIndex, CHPtrArray* pNewArray) throw ( CHeap_Exception ) ;

// Implementation
protected:
    void** m_pData ;   // the actual array of data
    int m_nSize ;     // # of elements (upperBound - 1)
    int m_nMaxSize ;  // max allocated
    int m_nGrowBy ;   // grow amount

public:
    ~CHPtrArray() ;
#ifdef _DEBUG
//    void Dump(CDumpContext&) const ;
    void AssertValid() const ;
#endif

protected:
    // local typedefs for class templates
    typedef void* BASE_TYPE ;
    typedef void* BASE_ARG_TYPE ;
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\copyright.h ===
//

//	This file was automatically generated from the IDL files 

//	included with the WBEM SDK in the \include directory.  If you

//  experience problems compiling this file you can re-generate it

//  by running NMAKE (or another MAKE utility) from within the 

//	\include directory.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//
//=================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\cregcls.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  cregcls.h
//
//  Purpose: registry wrapper class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CREGCLS_H_
#define _CREGCLS_H_

#include <Polarity.h>
#include <CHString.h>
#include <chstrarr.h>
#include <chptrarr.h>

#define MAX_VALUE_NAME (1024)
#define NULL_DWORD ((DWORD)0L)
#define MAX_SUBKEY_BUFFERSIZE (MAX_PATH+1)      // Per spec
#define QUOTE L"\""
#define CSTRING_PTR (1)

class POLARITY CRegistry 
{
public:

    CRegistry ();   // Constructor
    ~CRegistry ();  // Destructor

// Opens the key and subkey using the desired access mask

    LONG Open (

        HKEY hRootKey,          // handle of open key 
        LPCWSTR lpszSubKey, // address of name of subkey to open 
        REGSAM samDesired       // Access mask
    ); 
    
    // Version that properly opens the user key appropriate
    // to the current thread
    DWORD OpenCurrentUser(
        LPCWSTR lpszSubKey,     // address of name of subkey to open 
        REGSAM samDesired);     // Access mask


// Generalized RegCreateKeyEx form 

    LONG CreateOpen (

        HKEY hInRootKey, 
        LPCWSTR lpszSubKey,
        LPWSTR lpClass = NULL, 
        DWORD dwOptions = REG_OPTION_NON_VOLATILE, 
        REGSAM samDesired = KEY_ALL_ACCESS,
        LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL,
        LPDWORD pdwDisposition = NULL 
    );


// Deletes the specified subkey or the opened root

    LONG DeleteKey ( 

        CHString *pchsSubKeyPath = NULL 
    );

// Deletes the specified value within the createopened portion of the registry

    LONG DeleteValue (

        LPCWSTR pValueName 
    ); 

// Opens the key but forces the enumation of subkeys flag
//=======================================================

    LONG OpenAndEnumerateSubKeys (

        HKEY hInRootKey, 
        LPCWSTR lpszSubKey, 
        REGSAM samDesired
    );

    LONG EnumerateAndGetValues (

        DWORD &dwIndexOfValue,
        WCHAR *&pValueName,
        BYTE *&pValueData
    );

    void Close ( void ) ;



// Information Functions

// Having a key, but no class name is legal so just return a null string
// if there has been no class name set
//======================================================================

    HKEY GethKey ( void )                       { return hKey; }

    WCHAR *GetClassName ( void )                { return ( ClassName ) ; }
    DWORD GetCurrentSubKeyCount ( void )        { return ( dwcSubKeys ) ; }
    DWORD GetLongestSubKeySize ( void )         { return ( dwcMaxSubKey ) ; }
    DWORD GetLongestClassStringSize ( void )    { return ( dwcMaxClass ) ; }
    DWORD GetValueCount ( void )                { return ( dwcValues ) ; }
    DWORD GetLongestValueName ( void )          { return ( dwcMaxValueName ) ; }
    DWORD GetLongestValueData ( void )          { return ( dwcMaxValueData ) ; }

    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD GetCurrentBinaryKeyValue ( LPCWSTR pValueName , CHString &chsDest ) ;
    DWORD GetCurrentBinaryKeyValue ( LPCWSTR pValueName , LPBYTE pbDest , LPDWORD pSizeOfDestValue ) ;

    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValueExpand ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;

    DWORD GetCurrentBinaryKeyValue (  HKEY UseKey , LPCWSTR pValueName , LPBYTE pbDest , LPDWORD pSizeOfDestValue ) ;

    DWORD DeleteCurrentKeyValue ( LPCWSTR pValueName ) ;
    DWORD DeleteCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName ) ;

    // Subkey functions
    //=================

    void  RewindSubKeys ( void ) ;
    DWORD GetCurrentSubKeyName ( CHString &DestSubKeyName ) ;

    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, void *pDestValue , LPDWORD pSizeOfDestValue ) ;
    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, CHString &DestValue ) ;
    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, DWORD &DestValue ) ;

    DWORD NextSubKey ( void ) ; 
    DWORD GetCurrentSubKeyPath ( CHString &DestSubKeyPath ) ; 

    LONG  OpenLocalMachineKeyAndReadValue (

        LPCWSTR lpszSubKey , 
        LPCWSTR pValueName, 
        CHString &DestValue
    );

private:

    // Private functions
    //==================

    // Set the member variables to their default state
    //================================================
    void SetDefaultValues ( void ) ;

    // Open and close the subkey
    // =========================
    DWORD OpenSubKey ( void ) ;
    void  CloseSubKey ( void ) ;

    // Given a good key gets the value
    // ===============================
    DWORD GetCurrentRawKeyValue (

        HKEY UseKey, 
        LPCWSTR pValueName, 
        void *pDestValue,
        LPDWORD pValueType, 
        LPDWORD pSizeOfDestValue
    ) ;

    DWORD GetCurrentRawSubKeyValue (

        LPCWSTR pValueName, 
        void *pDestValue,
        LPDWORD pValueType, 
        LPDWORD pSizeOfDestValue
    ) ;

    // Init static vars
    // ================
    static DWORD WINAPI GetPlatformID ( void ) ;

    // MultiPlatform support
    // =====================

    LONG myRegCreateKeyEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD Reserved, 
        LPWSTR lpwcsClass, 
        DWORD dwOptions, 
        REGSAM samDesired, 
        LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
        PHKEY phkResult, 
        LPDWORD lpdwDisposition
    );

    LONG myRegSetValueEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE *lpData, 
        DWORD cbData
    );

    LONG myRegQueryValueEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        LPDWORD Reserved, 
        LPDWORD dwType, 
        LPBYTE lpData, 
        LPDWORD cbData
    );

    LONG myRegEnumKey (

        HKEY hKey, 
        DWORD dwIndex, 
        LPWSTR lpwcsName, 
        DWORD cbData
    );

    LONG myRegDeleteValue (

        HKEY hKey, 
        LPCWSTR lpwcsName
    ) ;

    LONG myRegDeleteKey (

        HKEY hKey, 
        LPCWSTR lpwcsName
    );

    LONG myRegOpenKeyEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD ulOptions, 
        REGSAM samDesired, 
        PHKEY phkResult
    );

    LONG myRegQueryInfoKey (

        HKEY hKey, 
        LPWSTR lpwstrClass, 
        LPDWORD lpcbClass,
        LPDWORD lpReserved, 
        LPDWORD lpcSubKeys, 
        LPDWORD lpcbMaxSubKeyLen,  
        LPDWORD lpcbMaxClassLen, 
        LPDWORD lpcValues, 
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen, 
        LPDWORD lpcbSecurityDescriptor, 
        PFILETIME lpftLastWriteTime
    );

    LONG myRegEnumValue (

        HKEY hKey, 
        DWORD dwIndex, 
        LPWSTR lpValueName,
        LPDWORD lpcbValueName, 
        LPDWORD lpReserved, 
        LPDWORD lpType,
        LPBYTE lpData, 
        LPDWORD lpcbData
    );


    // In the event the caller is REUSING this instance,
    // close the existing key and reset values to the default
    // in preparation to REOPEN this instance
    //=======================================================
    void PrepareToReOpen ( void ) ;

    // Private data
    //=============

    HKEY hRootKey;             // Current root key for cla
    HKEY hKey;                 // Current active key
    HKEY hSubKey;             // Current active subkey
    static DWORD s_dwPlatform; // Currently running OS

    CHString RootKeyPath;      // Current path to root assigned by open

    DWORD CurrentSubKeyIndex; // Current subkey being indexed

    bool m_fFromCurrentUser;  // allows check on whether to free
                              // hRootKey member based on whether
                              // its value was populated via a call
                              // to ::RegOpenCurrentUser.

    // Information about this class
    //=============================

    WCHAR ClassName[MAX_PATH];      // Buffer for class name.
    DWORD dwcClassLen;              // Length of class string.
    DWORD dwcSubKeys;               // Number of sub keys.
    DWORD dwcMaxSubKey;             // Longest sub key size.
    DWORD dwcMaxClass;              // Longest class string.
    DWORD dwcValues;                // Number of values for this key.
    DWORD dwcMaxValueName;          // Longest Value name.
    DWORD dwcMaxValueData;          // Longest Value data.
    DWORD dwcSecDesc;               // Security descriptor.
    FILETIME ftLastWriteTime;       // Last write time.
}; 

//*********************************************************************
//
//   CLASS:         CRegistrySearch
//
//   Description:   This class uses the CRegistry Class to search
//                  through the registry to build a list of keys
//                  for the requested value, or requested full key
//                  name, or requested partial key name.  This class
//                  allocates CHString objects and puts them in the
//                  users CHPtrArray.  The user is responsible for
//                  deleting the memory allocated, the FreeSearchList
//                  function can accomplish this, or the user must
//                  remember to delete every object in the array
//                  before deallocating the array.
//
//
//=====================================================================
//
//  Note:  Private functions are documented in the .CPP file
//
//=====================================================================
//
//  Public functions
//
//=====================================================================
//
//  BOOL SearchAndBuildList( CHString chsRootKey, 
//                           CHPtrArray & cpaList,
//                           CHString chsSearchString,
//                           CHString chsValueString,
//                           int nSearchType );
//
//  Parameters:
//      chsRootKey          - The root key to start the search from.
//                            Note:  At this point in time, we just
//                            search thru HKEY_LOCAL_MACHINE, this
//                            can be changed when needed. 
//      cpaList             - The reference to the CHPtrArray to put
//                            the list of keys that matched the search
//                            criteria.
//      chsSearchString     - The string to search for
//      chsValueString      - The value to open and see if it matches what is 
//                            chsSearchString
//      nSearchType         - The type of search, the following are
//                            supported:
//                            KEY_FULL_MATCH_SEARCH      
//                               Only keys that match the chsSearchString
//                            KEY_PARTIAL_MATCH_SEARCH   
//                               Keys that have chsSearchString anywhere in them
//                            VALUE_SEARCH               
//                               Values that match chsSearchString
//*********************************************************************
#define KEY_FULL_MATCH_SEARCH      1
#define KEY_PARTIAL_MATCH_SEARCH   2
#define VALUE_SEARCH               3

class POLARITY CRegistrySearch
{
private:

    void CheckAndAddToList (

        CRegistry * pReg, 
        CHString chsSubKey, 
        CHString chsFullKey,
        CHPtrArray & chpaList,
        CHString chsSearchString,
        CHString chsValueString,
        int nSearchType
    );

    int m_nSearchType ;
    CHString m_chsSearchString ;
    CHPtrArray m_cpaList ;


public:

    CRegistrySearch () ;
    ~CRegistrySearch () ;

    BOOL SearchAndBuildList ( 

        CHString chsRootKey, 
        CHPtrArray & cpaList,
        CHString chsSearchString,
        CHString chsValueString,
        int nSearchType,
        HKEY hkDefault = HKEY_LOCAL_MACHINE 
    );

    BOOL FreeSearchList (

        int nType, 
        CHPtrArray & cpaList
    ) ;

    BOOL LocateKeyByNameOrValueName (

        HKEY hKeyParent,
        LPCWSTR pszKeyName,
        LPCWSTR pszSubKeyName,
        LPCWSTR *ppszValueNames,
        DWORD dwNumValueNames,
        CHString &strFoundKeyName,
        CHString &strFoundKeyPath
    ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\chstring.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  CHSTRING.h
//
//  Purpose: Utility library version of MFC CString
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHSTRING_H
#define _CHSTRING_H

/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <limits.h>
#include <tchar.h>
#include <polarity.h>
#pragma warning( disable : 4290 ) // Ignore 'C++ Exception Specification ignored'
#include <ProvExce.h>

/////////////////////////////////////////////////////////////////////////////

struct _DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void POLARITY WINAPI SetCHStringResourceHandle(HINSTANCE handle);
#endif

/////////////////////////////////////////////////////////////////////////////
// CHString formatting
/////////////////////////////////////////////////////////////////////////////
#define TCHAR_ARG   WCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

struct CHStringData
{
    long nRefs;
    int nDataLength;
    int nAllocLength;

    WCHAR* data()
    {
        return (WCHAR*)(this+1); 
    }
};

/////////////////////////////////////////////////////////////////////////////
class POLARITY CHString
{
    protected:

        LPWSTR m_pchData;               // pointer to ref counted string data

    protected:

                                        // implementation helpers

        CHStringData* GetData() const;  // returns data pointer
        void Init();
        void AllocCopy(CHString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const throw ( CHeap_Exception ) ;
        void AllocBuffer(int nLen) throw ( CHeap_Exception ) ;
        void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData) throw ( CHeap_Exception ) ;
        void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data) throw ( CHeap_Exception ) ;
        void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
        void CopyBeforeWrite() throw ( CHeap_Exception ) ;
        void AllocBeforeWrite(int nLen) throw ( CHeap_Exception ) ;
        void Release();
        static void WINAPI Release(CHStringData* pData);
        static inline int WINAPI SafeStrlen(LPCWSTR lpsz)   { return (lpsz == NULL) ? 0 : wcslen(lpsz); }

        // Helper function used to load resource into lpszBuf buffer.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf) throw ( CHeap_Exception ) ;
#endif

    public:

// Constructors/Destruction

        CHString();
        CHString(const CHString& stringSrc);
        CHString(WCHAR ch, int nRepeat = 1) throw ( CHeap_Exception ) ;
        CHString(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpch, int nLength) throw ( CHeap_Exception ) ;
        inline CHString(const unsigned char* lpsz)  { Init(); *this = (LPCSTR)lpsz; }

        ~CHString();

// Functions

        void SetAt(int nIndex, WCHAR ch) throw ( CHeap_Exception ) ;
        void Empty();    

        // inlines

        inline int GetLength() const { return GetData()->nDataLength; }
        inline BOOL IsEmpty() const  { return GetData()->nDataLength == 0; }

#if (!defined DEBUG && !defined _DEBUG)
        inline WCHAR GetAt(int nIndex) const{ return m_pchData[nIndex]; }
        inline WCHAR operator[](int nIndex) const{  return m_pchData[nIndex]; }
#else
        WCHAR GetAt(int nIndex) const;
        WCHAR operator[](int nIndex) const;
#endif
        inline operator LPCWSTR() const     { return m_pchData; }
        inline int GetAllocLength() const       { return GetData()->nAllocLength; }

// overloaded assignment

        const CHString& operator=(const CHString& stringSrc) throw ( CHeap_Exception ) ;
        const CHString& operator=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        inline const CHString& operator=(const unsigned char* lpsz) throw ( CHeap_Exception ) { *this = (LPCSTR)lpsz; return *this; }
        inline const CHString& operator=(CHString *p) throw ( CHeap_Exception ) { *this = *p; return *this; }
        inline const CHString& operator=(char ch) throw ( CHeap_Exception ) { *this = (WCHAR)ch; return *this; }        
        
        inline const CHString& CHString::operator+=(char ch) throw ( CHeap_Exception ) { *this += (WCHAR)ch; return *this; }
        friend inline CHString  operator+(const CHString& string, char ch) throw ( CHeap_Exception ) { return string + (WCHAR)ch; }
        friend inline CHString  operator+(char ch, const CHString& string) throw ( CHeap_Exception ) { return (WCHAR)ch + string; }

        const CHString& operator+=(const CHString& string) throw ( CHeap_Exception ) ;
        const CHString& operator+=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator+=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;

        friend CHString POLARITY WINAPI operator+(const CHString& string1,  const CHString& string2) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, WCHAR ch) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(WCHAR ch, const CHString& string) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(LPCWSTR lpsz, const CHString& string) throw ( CHeap_Exception ) ;

// string comparison

        int Compare(LPCWSTR lpsz) const;

        inline int CompareNoCase(LPCWSTR lpsz) const
        {
            // ignore case

            return _wcsicmp(m_pchData, lpsz); 

        }   // MBCS/Unicode aware

        inline int Collate(LPCWSTR lpsz) const
        {  
            // NLS aware
            // CHString::Collate is often slower than Compare but is MBSC/Unicode
            // aware as well as locale-sensitive with respect to sort order.

            return wcscoll(m_pchData, lpsz); 

        }   // locale sensitive

// Load string from resource file.

#ifdef FRAMEWORK_ALLOW_DEPRECATED
        BOOL LoadStringW(UINT nID) throw ( CHeap_Exception ) ;
#endif

// Access to string implementation buffer as "C" character array

        LPWSTR GetBuffer(int nMinBufLength) throw ( CHeap_Exception ) ;
        void ReleaseBuffer(int nNewLength = -1) throw ( CHeap_Exception ) ;
        LPWSTR GetBufferSetLength(int nNewLength) throw ( CHeap_Exception ) ;
        void FreeExtra() throw ( CHeap_Exception ) ;

// Use LockBuffer/UnlockBuffer to turn refcounting off

        LPWSTR LockBuffer() ;
        void UnlockBuffer();

// searching (return starting index, or -1 if not found)
// look for a single character match

        int Find(WCHAR ch) const;               // like "C" strchr
        int FindOneOf(LPCWSTR lpszCharSet) const;
        int ReverseFind(WCHAR ch) const;

// look for a specific sub-string

        int Find(LPCWSTR lpszSub) const;        // like "C" strstr

// upper/lower/reverse conversion

        void MakeUpper() throw ( CHeap_Exception ) ;
        void MakeLower() throw ( CHeap_Exception ) ;
        void MakeReverse() throw ( CHeap_Exception ) ;

// simple sub-string extraction

        CHString Mid(int nFirst, int nCount) const throw ( CHeap_Exception ) ;
        CHString Mid(int nFirst) const throw ( CHeap_Exception ) ;
        CHString Left(int nCount) const throw ( CHeap_Exception ) ;
        CHString Right(int nCount) const throw ( CHeap_Exception ) ;

        CHString SpanIncluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;
        CHString SpanExcluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;

// trimming whitespace (either side)

        void TrimRight() throw ( CHeap_Exception ) ;
        void TrimLeft() throw ( CHeap_Exception ) ;
    
// printf-like formatting using passed string
        void __cdecl Format(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;
        void FormatV(LPCWSTR lpszFormat, va_list argList);

// printf-like formatting using referenced string resource
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl Format(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

// format using FormatMessage API on passed string
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
        void __cdecl FormatMessageW(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;

// format using FormatMessage API on referenced string resource
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl FormatMessageW(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

#ifndef _NO_BSTR_SUPPORT

        // OLE BSTR support (use for OLE automation)

        BSTR AllocSysString() const throw ( CHeap_Exception ) ;
#endif

};

inline BOOL operator==(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) == 0; }
inline BOOL operator==(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) == 0; }

inline BOOL operator!=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) != 0; }
inline BOOL operator!=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) != 0; }

inline BOOL operator<(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) < 0; }
inline BOOL operator<(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) < 0; }

inline BOOL operator>(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) > 0; }
inline BOOL operator>(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) > 0; }

inline BOOL operator<=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) <= 0; }
inline BOOL operator<=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) <= 0; }

inline BOOL operator>=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) >= 0; }
inline BOOL operator>=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) >= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\testlib\resource.h ===
// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chstest.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\testlib\chstringtest.h ===
#ifndef CPP_UNIT_EXAMPLETESTCASE_H
#define CPP_UNIT_EXAMPLETESTCASE_H

#include "TestCase.h"
#include "TestSuite.h"
#include "TestCaller.h"

#define _NO_BSTR_SUPPORT


/* 
 * A test case that is designed to produce
 * example errors and failures
 *
 */

class CHStringTestCase : public TestCase
{
protected:

	double			m_value1;
	double			m_value2;

public:
       CHStringTestCase (std::string name) : TestCase (name) {}

	void			setUp ();
	static Test		*suite ();

protected:
	void			example ();
	void			anotherExample ();
	void			testAdd ();
	void			testDivideByZero ();
	void			testEquals ();
	void testHStringLoad ();
	void testHStringFormat () ;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\testlib\chstringtest.cpp ===
#include <windows.h>
#include "resource.h"

#include "CHStringTest.h"
#include "chstring.h"


void CHStringTestCase::example ()
{
	assertDoublesEqual (1.0, 1.1, 0.05);
	assert (1 == 0);
	assert (1 == 1);
}


void CHStringTestCase::anotherExample ()
{
	assert (1 == 2);
}

void CHStringTestCase::setUp ()
{
	m_value1 = 2.0;
	m_value2 = 3.0;
}

void CHStringTestCase::testAdd ()
{
	double result = m_value1 + m_value2;
	assert (result == 6.0);
}


void CHStringTestCase::testDivideByZero ()
{
	int	zero	= 0;
	int result	= 8 / zero;
}


void CHStringTestCase::testEquals ()
{
    std::auto_ptr<long>	l1 (new long (12));
    std::auto_ptr<long>	l2 (new long (12));

	assertLongsEqual (12, 12);
	assertLongsEqual (12L, 12L);
	assertLongsEqual (*l1, *l2);

	assert (12L == 12L);
	assertLongsEqual (12, 13);
	assertDoublesEqual (12.0, 11.99, 0.5);



}


void CHStringTestCase::testHStringFormat ()
{
  CHString str;
  str.GetBuffer(1024);
  str.FormatMessageW(L"%1!d! of %2!d! developers agree: Hockey is %3%!", 
   4, 5, L"Best");
  assert( wcscmp(L"4 of 5 developers agree: Hockey is Best!",str)==0);
}



Test *CHStringTestCase::suite ()
{
  TestSuite *testSuite = new TestSuite ("CHStringTestCase");
  testSuite->addTest (new TestCaller <CHStringTestCase> ("testFormat", testHStringFormat));
  return testSuite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\provexce.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CSetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc ;

public:

	static void _cdecl trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		m_PrevFunc = _set_se_translator ( trans_func ) ;
	}

	~CSetStructuredExceptionHandler ()
	{
		_set_se_translator ( m_PrevFunc ) ;
	}
} ;

/**************************************************************
 *
 **************************************************************/

#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\utillib.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  utillib.h
//
//  Purpose: gather up utillib headers into one catch-all
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef UTILLIB_HEADERFILE_IS_INCLUDED
#define UTILLIB_HEADERFILE_IS_INCLUDED

#include <ProvExce.h>

#include <GenLex.h>
#include <ObjPath.h> 
#include <OPathLex.h> 

#include <CHString.h>
#include <CHStrArr.h>
#include <CHPtrArr.h>
#include <Polarity.h>
#include <WbemTime.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\bmof.c ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    BMOF.C

Abstract:

    Structures and helper functions for naviagating a BMOF file.

History:

    a-davj  14-April-97   Created.

--*/

#include <windows.h>
#include <oleauto.h>
#include <string.h>
#include "bmof.h"
#include <wbemutil.h>

int wmi_unaligned_wcslen( LPCWSTR wszString )
{
    BYTE*   pbData = (BYTE*) wszString;
	int i;

    // Walk the string looking for two 0 bytes next to each other.
    for( i =0; !(!*(pbData) && !*(pbData+1) ); pbData+=2, i++ );

    return i;
}

WCHAR* wmi_unaligned_wcscpy( WCHAR* wszDest, LPCWSTR wszSource )
{
    int nLen = wmi_unaligned_wcslen( wszSource );

    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nLen+1) * 2 );

    return wszDest;
}

//***************************************************************************
//
//  BOOL LookupFlavor
//
//  DESCRIPTION:
//
//  Looks in the flavor table to see if a qualifier has a flavor.
//
//  PARAMETERS:
//
//  pQual      Pointer to the qualifier.
//  pdwFlavor  Pointer to where the return value is put
//  pBuff      Pointer to the main buffer.  I.e. "BMOF...."
//  pToFar	   Pointer to 1 past the last byte in the buffer
//
//
//  RETURN VALUE:
//
//  TRUE if there is a flavor.  Note that failure is normal
//
//***************************************************************************

BOOL LookupFlavor(BYTE * pQual, DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    UNALIGNED DWORD * pTemp;
    BYTE * pFlavorBlob;
    DWORD dwNumPairs;
    UNALIGNED DWORD * pOffset;
    UNALIGNED DWORD * pFlavor;
    DWORD dwMyOffset;
    DWORD dwCnt;

    *pdwFlavor = 0;

    // Calculate the pointer of the start of the flavor data

    pTemp = (DWORD * )pBuff;
    pTemp++;                            // point to the original blob size
    pFlavorBlob = pBuff + *pTemp;

	// Dont even try past the end of memory

	if(pToFar == NULL)
		return FALSE;

	if(pFlavorBlob + 16 >= pToFar)
		return FALSE;

    // Check if the flavor blob is valid, it should start off with the 
    // characters "BMOFQUALFLAVOR11"

    if(memcmp(pFlavorBlob, "BMOFQUALFLAVOR11", 16))
        return FALSE;                               // Not really a problem since it may be old file
    
    // The flavor part of the file has the format 
    // DWORD dwNumPair, followed by pairs of dwords;
    // offset, flavor

    // Determine the number of pairs

    pFlavorBlob+= 16;
    pTemp = (DWORD *)pFlavorBlob;
    dwNumPairs = *pTemp;              // Number of offset/value pairs
    if(dwNumPairs < 1)
        return FALSE;

    // point to the first offset/flavor pair

    pOffset = pTemp+1;
    pFlavor = pOffset+1;

    // Determine the offset we are looking for.  That is the pointer to the qualifier minus
    // the pointer to the start of the block;

    dwMyOffset = (DWORD)(pQual - pBuff);

    for(dwCnt = 0; dwCnt < dwNumPairs; dwCnt++)
    {
        if(dwMyOffset == *pOffset)
        {
            *pdwFlavor = *pFlavor;
        }
        if(dwMyOffset < *pOffset)
            return FALSE;
        pOffset += 2;
        pFlavor += 2;
    }
    return FALSE;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN DWORD vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    vtTest &= ~ VT_BYREF; // get rid of possible byref bit

    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;

        default:
            iRet = 0;
        }
    return iRet;
}


//***************************************************************************
//
//  CBMOFQualList * CreateQualList
//
//  DESCRIPTION:
//
//  Create a CBMOFQualList object which serves as a wrapper.
//
//  PARAMETERS:
//
//  pwql                 pointer to the WBEM_Qualifier structure in the binary
//                      MOF.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList structure that servers as a wrapper.  NULL
//  if error.  This must be freed via BMOFFree() when no longer needed.
//
//
//***************************************************************************

CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pwql)
{

    CBMOFQualList * pRet = NULL;
    if(pwql == NULL)
      return NULL;


    pRet = (CBMOFQualList *)BMOFAlloc(sizeof (CBMOFQualList));
    if(pRet != NULL)
    {
        pRet->m_pql = pwql;
        pRet->m_pInfo = (UNALIGNED WBEM_Qualifier *)
            ((BYTE *)pRet->m_pql + sizeof(WBEM_QualifierList));;
        ResetQualList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetQualList
//
//  DESCRIPTION:
//
//  Resets CBMOFQualList stucture to point to the first entry.
//
//  PARAMETERS:
//
//  pql                 structure to be reset
//
//***************************************************************************

void ResetQualList(CBMOFQualList * pql)
{
   if(pql)
   {
      pql->m_CurrQual = 0;
      pql->m_pCurr = pql->m_pInfo;
   }
}

//***************************************************************************
//
//  BOOL NextQual
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem)
{
    return NextQualEx(pql, ppName, pItem, NULL, NULL, NULL);
}


//***************************************************************************
//
//  BOOL NextQualEx
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//  pToFar              Pointer to one past the end of the memory buffer
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem,
                                            DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;

    if(pql == NULL || pql->m_CurrQual++ >= pql->m_pql->dwNumQualifiers)
        return FALSE;

    if(pdwFlavor && pBuff)
        LookupFlavor((BYTE *)pql->m_pCurr, pdwFlavor, pBuff, pToFar);
 
    pInfo = (BYTE *)pql->m_pCurr + sizeof(WBEM_Qualifier);
    
    if(ppName)
      SetName(ppName, pInfo, pql->m_pCurr->dwOffsetName);

    if(pInfo)
      bRet = SetValue(pItem, pInfo, pql->m_pCurr->dwOffsetValue, 
                        pql->m_pCurr->dwType);

    // advance to next
    pql->m_pCurr = (UNALIGNED WBEM_Qualifier *)((BYTE *)pql->m_pCurr + pql->m_pCurr->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindQual
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem)
{
    return FindQualEx(pql, pName, pItem, NULL, NULL, NULL);
}

//***************************************************************************
//
//  BOOL FindQualEx
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                          DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Qualifier * pQual = pql->m_pInfo;
    for(dwCnt = 0; dwCnt < pql->m_pql->dwNumQualifiers; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;
        BYTE * pInfo = (BYTE *)pQual + sizeof(WBEM_Qualifier);
        if(!SetName(&pTest, pInfo, pQual->dwOffsetName))
            return FALSE;

        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);
        if(bMatch)
        {
            if(pdwFlavor && pBuff)
                LookupFlavor((BYTE *)pQual, pdwFlavor, pBuff, pToFar);
            return SetValue(pItem, pInfo, pQual->dwOffsetValue, pQual->dwType);
        }
        pQual = (UNALIGNED WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return FALSE;
}

//***************************************************************************
//
//  BOOL SetValue
//
//  DESCRIPTION:
//
//  Sets up a CBMOFDataItem structure to point to a value in the BMOF.
//
//  PARAMETERS:
//
//  pItem               Input/Output, item to be set
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//  dwType              Input data type.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType)
{

    if(pItem == NULL || pInfo == NULL)
        return FALSE;

    pItem->m_dwType = dwType;

    // Check for NULL case.  This is how uninitialized data is stored.

    if(dwOffset == 0xffffffff)
        pItem->m_pData = NULL;
    else
        pItem->m_pData = pInfo + dwOffset;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetName
//
//  DESCRIPTION:
//
//  Gets a name out of an information block.
//
//  PARAMETERS:
//
//  ppName              Input/Output.  On successful return, will point to a
//                      WCHAR string containing the name.  This MUST be freed
//                      by the caller via BMOFFree()!
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset)
{
    UNALIGNED WCHAR * pName;
    if(ppName == NULL || pInfo == NULL || dwOffset == 0xffffffff)
        return FALSE;

    pName = (UNALIGNED WCHAR *)(pInfo + dwOffset);   // point to string in info block
    *ppName = (WCHAR *)BMOFAlloc(2*(wmi_unaligned_wcslen((LPWSTR)pName) + 1));
    if(*ppName == NULL)
        return FALSE;
    wmi_unaligned_wcscpy(*ppName, (LPWSTR)pName);
    return TRUE;
}

//***************************************************************************
//
//  CBMOFObj * CreateObj
//
//  DESCRIPTION:
//
//  Create a CBMOFObj structure which wraps a WBEM_Object
//
//  PARAMETERS:
//
//  pwob                Input, structure to be wrapped
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pwob)
{
    CBMOFObj * pRet = (CBMOFObj *)BMOFAlloc(sizeof(CBMOFObj));
    if(pRet)
     {
        pRet->m_pob = pwob;
        pRet->m_pInfo = ((BYTE *)pwob) + sizeof(WBEM_Object);
        pRet->m_ppl = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetPropertyList);
        pRet->m_pml = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetMethodList);
        ResetObj(pRet);
     }
    return pRet;
}


//***************************************************************************
//
//  void ResetObj
//
//  DESCRIPTION:
//
//  Resets a CBMOFObj structure so that it points to its first property.
//
//  PARAMETERS:
//
//  pob                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObj(CBMOFObj * pob)
{
   if(pob)
   {
      pob->m_CurrProp = 0;
      pob->m_pCurrProp = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_ppl +
                                    sizeof(WBEM_PropertyList));
      pob->m_CurrMeth = 0;
      pob->m_pCurrMeth = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_pml +
                                    sizeof(WBEM_PropertyList));
   }
}

//***************************************************************************
//
//  CBMOFQualList * GetQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps the objects qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetQualList(CBMOFObj * pob)
{

    UNALIGNED WBEM_QualifierList *pql;
    if(pob->m_pob->dwOffsetQualifierList == 0xffffffff)
        return NULL;
    pql = (UNALIGNED WBEM_QualifierList *)((BYTE *)pob->m_pInfo+
                            pob->m_pob->dwOffsetQualifierList);
    return CreateQualList(pql);
}


//***************************************************************************
//
//  CBMOFQualList * GetPropQualList
//  CBMOFQualList * GetMethQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps a property or
//  methods qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Property name.  Note that this is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetPropOrMethQualList(UNALIGNED WBEM_Property * pProp)
{
    if(pProp == NULL)
        return NULL;
    if(pProp->dwOffsetQualifierSet == 0xffffffff)
        return NULL;
    return CreateQualList((UNALIGNED WBEM_QualifierList *)(
                                    (BYTE *)pProp + sizeof(WBEM_Property)+
                                    pProp->dwOffsetQualifierSet));
}

CBMOFQualList * GetPropQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

CBMOFQualList * GetMethQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

//***************************************************************************
//
//  BOOL NextProp
//  BOOL NextMet
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Output, if functions succeeds, this points to a
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
///
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL Info(UNALIGNED WBEM_Property * pPropOrMeth, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;
    if(pPropOrMeth == NULL)
        return FALSE;

    pInfo = (BYTE *)pPropOrMeth + sizeof(WBEM_Property);
    if(ppName)
       SetName(ppName, pInfo, pPropOrMeth->dwOffsetName);
    if(pItem)
       bRet = SetValue(pItem, pInfo,
                        pPropOrMeth->dwOffsetValue,
                        pPropOrMeth->dwType);
    return bRet;
}

BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrProp++ >= pob->m_ppl->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrProp, ppName, pItem);

    // advance pointer to next property.

    pob->m_pCurrProp = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrProp + pob->m_pCurrProp->dwLength);
    return bRet;
}

BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrMeth++ >= pob->m_pml->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrMeth, ppName, pItem);

    // advance pointer to next method.

    pob->m_pCurrMeth = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrMeth + pob->m_pCurrMeth->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindProp
//  BOOL FindMeth
//
//  DESCRIPTION:
//
//  Sets a CBMOFDataItem structure to point to a properties data.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input. Name to be use for case insensitve search.
//  pItem               Input/Output.  Data item stucture to be updated.
//
//  RETURN VALUE:
//
//  True if found.
//
//***************************************************************************

BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

//***************************************************************************
//
//  BOOL GetName
//
//  DESCRIPTION:
//
//  Gets the name of an object.  This is works be returning the "__Class"
//  property.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Input/Output.  Points to a WCHAR string which
//                      has the name.  The caller MUST free this via
//                      BMOFFree()
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL GetName(CBMOFObj * pob, WCHAR ** ppName)
{
    CBMOFDataItem Item;
    BOOL bRet = FALSE, bFound;
    if(pob == NULL || ppName == NULL)
        return FALSE;

    bFound = FindProp(pob, L"__Class", &Item);
    if(!bFound)
        return FALSE;
    if(Item.m_dwType == VT_BSTR  && ppName)
    {
        bRet = GetData(&Item, (BYTE *)ppName, NULL);
    }
    return bRet;
}


//***************************************************************************
//
//  DWORD GetType
//
//  DESCRIPTION:
//
//  Returns an objects type.  A 0 indicates a class while a 1 indicates an
//  instance.  A 0xffffffff if passed a null pointer.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//
//  RETURN VALUE:
//
//  See description.
//
//***************************************************************************

DWORD GetType(CBMOFObj * pob)
{
   if(pob)
      return pob->m_pob->dwType;
   else
      return 0xFFFFFFFF;
}

//***************************************************************************
//
//  WBEM_Property * FindPropPtr
//  WBEM_Property * FindMethPtr
//
//  DESCRIPTION:
//
//  Returns a WBEM_Property stucture pointer for a particular property or
//  method given its name.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Name of property.  Comparison is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  pointer to WBEM_Property, NULL if it cant be found.
//
//***************************************************************************

UNALIGNED WBEM_Property *  Search(BYTE * pList, DWORD dwListSize, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Property * pProp = NULL;

    // point to first property structure

    pProp = (UNALIGNED WBEM_Property *)(pList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwListSize; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;

        // point to the property's name and retrieve it

        BYTE * pInfo = (BYTE *)pProp + sizeof(WBEM_Property);
        if(!SetName(&pTest, pInfo, pProp->dwOffsetName))
            return NULL;
        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);

        // If we have a match, return

        if(bMatch)
            return pProp;

        pProp = (UNALIGNED WBEM_Property *)((BYTE *)pProp + pProp->dwLength);
    }
    return NULL;
}

UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_ppl, pob->m_ppl->dwNumberOfProperties, pName);
}

UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_pml, pob->m_pml->dwNumberOfProperties, pName);
}


//***************************************************************************
//
//  CBMOFObjList * CreateObjList
//
//  DESCRIPTION:
//
//  Create a CBMOFObjList structure which wraps a BMOF file.
//
//  PARAMETERS:
//
//  pBuff                Input, points to start of BMOF file.
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObjList * CreateObjList(BYTE * pBuff)
{
    CBMOFObjList * pRet = (CBMOFObjList * )BMOFAlloc(sizeof(CBMOFObjList));
    if(pRet)
    {
        pRet->m_pol = (WBEM_Binary_MOF *)pBuff;
        pRet->m_pInfo = (WBEM_Object *)
                   ((BYTE *)pBuff + sizeof(WBEM_Binary_MOF));
        ResetObjList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetObjList
//
//  DESCRIPTION:
//
//  Resets a CBMOFObjList structure so that it points to its first object.
//
//  PARAMETERS:
//
//  pol                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObjList(CBMOFObjList * pol)
{
   if(pol)
   {
      pol->m_pCurrObj = pol->m_pInfo;
      pol->m_CurrObj = 0;
   }
}

//***************************************************************************
//
//  CBMOFObj * NextObj
//
//  DESCRIPTION:
//
//  Gets the next object in the list.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * NextObj(CBMOFObjList *pol)
{
    CBMOFObj * pRet;

    if(pol == NULL || pol->m_CurrObj++ >= pol->m_pol->dwNumberOfObjects)
        return NULL;

    pRet = CreateObj(pol->m_pCurrObj);
    pol->m_pCurrObj = (UNALIGNED WBEM_Object *)((BYTE *)pol->m_pCurrObj + pol->m_pCurrObj->dwLength);
    return pRet;
}


//***************************************************************************
//
//  CBMOFObj * FindObj
//
//  DESCRIPTION:
//
//  Searches the object list for the first object which has a "__className"
//  property.  The search is case insensitive.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//  pName               Input. Name of object being searched for
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Object * pob;

    if(pol->m_pol == NULL || pName == NULL)
        return NULL;

    pob = pol->m_pInfo;
    for(dwCnt = 0; dwCnt < pol->m_pol->dwNumberOfObjects; dwCnt)
    {
        WCHAR * pwcName = NULL;
        BOOL bMatch = FALSE;

        CBMOFObj * pRet = CreateObj(pob);
         if(pRet == NULL)
            return NULL;
        if(GetName(pRet,&pwcName))
            bMatch = TRUE;
        if(pwcName)
            BMOFFree(pwcName);

        // If we found it, return it, otherwise free object and advance

        if(bMatch)
            return pRet;
        BMOFFree(pRet);
        pob = (UNALIGNED WBEM_Object *)((BYTE *)pob + pob->dwLength);
    }
    return NULL;
}


//***************************************************************************
//
//  int GetNumDimensions
//
//  DESCRIPTION:
//
//  Returns the number of dimensions for a data item.
//
//  PARAMETERS:
//
//  pItem               Input.  Item in question.
//
//  RETURN VALUE:
//  -1 if bogus argument, or if the data item doesnt hold data which would
//     be the case for uninitialized properties.
//  0  if non array argument
//  n  Number of dimensions.  Currently only single dimension arrays are
//     supported.
//
//***************************************************************************

int GetNumDimensions(CBMOFDataItem * pItem)
{
   UNALIGNED unsigned long * pdwTemp;
   if(pItem == NULL)
      return -1;
   if(!(pItem->m_dwType & VT_ARRAY))
      return 0;
   if(pItem->m_pData == NULL)
      return -1;

   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;        // skip past total size
   return *pdwTemp;
}


//***************************************************************************
//
//  int GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements for an array dimension.  Note that 1 is the
//  first dimenstion.  Currently, only scalars and 1 dimensional arrays are
//  supported.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item in question.
//  lDim                Input.  Dimension in question.  The most significent
//                      (and for now only) dimension is 0.
//
//  RETURN VALUE:
//
//  Number of array elements.  Note that scalars will return -1.
//
//***************************************************************************

int GetNumElements(CBMOFDataItem * pItem, long lDim)
{
   int iCnt; UNALIGNED DWORD * pdwTemp;
   int lNumDim = GetNumDimensions(pItem);
   if(lNumDim == -1 || lDim > lNumDim)
      return -1;
   pdwTemp = (UNALIGNED unsigned long *)pItem->m_pData;
   pdwTemp++;                          // skip total size
   pdwTemp++;                          // skip number of dimensions
   for(iCnt = 0; iCnt < lDim; iCnt++)
      pdwTemp++;
   return *pdwTemp;
}


//***************************************************************************
//
//  BYTE * GetDataElemPtr
//
//  DESCRIPTION:
//
//  Used to get the pointer to a particular data element.  Note that this is
//  usually used internally.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//  vtSimple            Input.  Variant type of the data with the VT_ARRAY
//                      and VT_BYREF bits cleared.
//
//  RETURN VALUE:
//

//  pointer to the data.
//***************************************************************************

BYTE * GetDataElemPtr(CBMOFDataItem * pItem, long * plDims, DWORD vtSimple)
{
   int iNumDim;
   DWORD dwTotalDataSize;
   BYTE * pEndOfData;
   UNALIGNED DWORD * pdwCurr;
   UNALIGNED DWORD * pdwCurrObj;
   BYTE * pRow;
   int iCnt;

   // first check the number of dimensions.

   iNumDim = GetNumDimensions(pItem);
   if(iNumDim == -1)
      return NULL;
   if(iNumDim == 0)           // simple case of scalar argument
      return pItem->m_pData;

   // for arrays, the data block starts off with this form,
   // dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
   // Since currently only 1 dimensional arrays are supported, a 5 element
   // array would start with
   // dwSize, 1, 5

   pdwCurr = (UNALIGNED DWORD *)pItem->m_pData;
   dwTotalDataSize = *pdwCurr;
   pEndOfData = pItem->m_pData + dwTotalDataSize;
   pdwCurr+= 2;      // skip to dimension list
   pdwCurr += iNumDim;  // skip of dimension sizes.

   while((BYTE *)pdwCurr < pEndOfData)
   {
      // Each row has the format
      // dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
      // For a one dimensional array, it would just be
      // dwSizeOfRow, data


      DWORD dwRowSize = *pdwCurr;

      // test if this row is ok.  Each row of data will have
      // a set of Indicies for each higher dimension.

      for(iCnt = 0; iCnt < iNumDim-1; iCnt++)
      {
         UNALIGNED DWORD * pRowInd = pdwCurr +1 + iCnt;
         if((long)*pRowInd != plDims[iCnt])
            break;

      }
      if(iCnt >= iNumDim -1)
      {
         break;                  // found the row.
      }

      // go to the next row

      pdwCurr = (UNALIGNED DWORD *)((BYTE *)pdwCurr + dwRowSize);

   }

   if((BYTE *)pdwCurr >= pEndOfData)
      return NULL;

   pRow = (BYTE *)(pdwCurr + 1 + iNumDim -1);
   for(iCnt = 0; iCnt < plDims[iNumDim-1]; iCnt++)
   {
      if(vtSimple == VT_BSTR)
         pRow += 2*(wmi_unaligned_wcslen((WCHAR *)pRow)+1);
      else if(vtSimple == VT_EMBEDDED_OBJECT)
      {
         // Each embedded object starts off with its own size

         pdwCurrObj = (DWORD *)pRow;
         pRow += *pdwCurrObj;

      }
      else
         pRow += iTypeSize(vtSimple);
   }

   return pRow;

}


//***************************************************************************
//
//  int GetData
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  pRet                Input/Output.  Pointer to where the data is to be
//                      copied.  For simple data, such as ints, this can just
//                      be a pointer to an int.  For BSTRs, or embedded
//                      objects, this is treated as a pointer to a pointer
//                      and it is the responsibility of the caller to free
//                      the strings via BMOFFree().
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//                      The first element in any dimension is 0.
//  RETURN VALUE:
//
//  Number of bytes of data.
//***************************************************************************

int GetData(CBMOFDataItem * pItem, BYTE * pRet, long * plDims)
{
   DWORD dwSimple;
   BYTE * pData;
   CBMOFObj * pObjRet = NULL;
   dwSimple = pItem->m_dwType &~ VT_ARRAY &~VT_BYREF;
   pData = GetDataElemPtr(pItem, plDims, dwSimple);
   if(pData == NULL)
      return 0;
   if(dwSimple == VT_BSTR)
   {

      // For strings, a new WCHAR buffer is returned.  Note that
      // SysAllocString isnt used so as to avoid any Ole dependencies.

      BYTE * pStr;
      DWORD dwSize = 2*(wmi_unaligned_wcslen((WCHAR *)pData)+1);

      pStr = BMOFAlloc(dwSize);
      if(pStr == NULL)
      		return 0;
      memcpy((void *)pRet, &pStr, sizeof(void *));
      wmi_unaligned_wcscpy((WCHAR *)pStr, (WCHAR *)pData);
      return dwSize;
   }
   else if(dwSimple == VT_EMBEDDED_OBJECT)
   {

      // This is the embedded object case.
      pObjRet = CreateObj((UNALIGNED WBEM_Object *)pData);
      memcpy((void *)pRet, &pObjRet, sizeof(void *));

      return sizeof(void *);
   }
   else
   {
      memcpy((void *)pRet, (void *)pData, iTypeSize(dwSimple));
      return iTypeSize(dwSimple);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\utillib\include\utils.h ===
//***************************************************************************

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//  utils.h
//
//  Purpose: utility functions
//
//***************************************************************************
#pragma once

#define NORMALIZE_NULL 1

typedef enum
{
    e_OK,
    e_UnparsablePath,
    e_NonLocalPath,
    e_UnParseError,
    e_NullName
} GetValuesForPropResults;

/*****************************************************************************
 *
 *  FUNCTION    : NormalizePath
 *
 *  DESCRIPTION : Converts object paths to a normalized form
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : Machine name is verified, then removed.  Namespace is verified
 *                then removed.  If there is only one key, then the key property
 *                name is removed.  If there is more than one key, then the order
 *                of the key names is alphabetized.
 *
 *                If dwFlags == 0, then DON'T null the key
 *                property name, if NORMALIZE_NULL, then DO null the key.
 *
 *****************************************************************************/

DWORD POLARITY WINAPI NormalizePath(
    
    LPCWSTR lpwszInPath, 
    LPCWSTR lpwszComputerName, 
    LPCWSTR lpwszNamespace,
    DWORD dwFlags,
    CHString &sOutPath
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\bmof.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    BMOF.H

Abstract:

	Describes the format of binary MOF files.  In addition, it defines some
	structures which specify the details of the format and also defines some
	addtional structures and helper functions for navigating a BMOF file.

History:

	a-davj  14-April-97   Created.

--*/

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

//  The extension  for supporting qualifier flavors is to add the following data after the current blob.
//  
//  typedef struct 
//  {
//      WCHAR wcSignature;          // the string BMOFQUALFLAVOR11
//      DWORD dwNumPair;
//      // BYTE FlavorInfo[];             // Blob containing array of WBEM_Object structs
//  }WBEM_Binary_FLAVOR;
//  
//  The FlavorInfo blob will be a series of DWORD pairs of the form
//  
//  Typedef struct
//  {
//  	DWORD dwOffsetInOriginalBlob;
//  	DWORD dwFlavor;
//  }

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    UNALIGNED WBEM_QualifierList * m_pql;
    UNALIGNED WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    UNALIGNED WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    UNALIGNED WBEM_Object * m_pob;
    BYTE * m_pInfo;
    UNALIGNED WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    UNALIGNED WBEM_Property * m_pCurrProp;

    UNALIGNED WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    UNALIGNED WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    UNALIGNED WBEM_Object * m_pInfo;
    UNALIGNED WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;

// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

void * BMOFAlloc(size_t Size);
void BMOFFree(void * pFree);


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * CreateObjList(BYTE * pBuff);
void ResetObjList(CBMOFObjList * pol);
CBMOFObj * NextObj(CBMOFObjList *pol);
CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void ResetObj(CBMOFObj * pol);
CBMOFQualList * GetQualList(CBMOFObj * pol);
CBMOFQualList * GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD GetType(CBMOFObj * pob);
UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName);
UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void ResetQualList(CBMOFQualList * pql);
BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff, 
											BYTE * pToFar);
BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff,
											BYTE * pToFar);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int GetNumDimensions(CBMOFDataItem *);
int GetNumElements(CBMOFDataItem *, long lDim);
int GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int iTypeSize(DWORD vtTest);
BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pql);
CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\crc32.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    CRC32.H

Abstract:

    Standard CRC-32 implementation

History:

	raymcc      07-Jul-97       Createada

--*/

#ifndef _CRC_H_
#define _CRC_H_

#define STARTING_CRC32_VALUE    0xFFFFFFFF

DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be STARTING_CRC_VALUE (0xFFFFFFFF) 
                                // if no previous CRC, otherwise this is the
                                // CRC of the previous cycle.
    );

#define FINALIZE_CRC32(x)    (x=~x)

/*
The CRC holding value must be preinitialized to STARTING_CRC32_VALUE
UpdateCRC32() may be called as many times as necessary on a single buffer.  
When computing the CRC32

The final value must be post-processed using the FINALIZE_CRC32() macro.

Example:

void main()
{
    BYTE Data[] = { 1, 2, 3 };

    DWORD dwCRC = STARTING_CRC32_VALUE;

    dwCRC = UpdateCRC32(Data, 3, dwCRC);

    FINALIZE_CRC32(dwCRC);

    printf("CRC32 = 0x%X\n", dwCRC);
}

*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\common\wdmlib\crc32.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    CRC32.CPP

Abstract:

    Standard CRC-32 implementation

History:

    raymcc      07-Jul-97       Createada

--*/

#include "precomp.h"
#include <stdio.h>
#include <crc32.h>

static DWORD CrcTable[] =
{
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb4