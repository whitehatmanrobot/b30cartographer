e = sizeof(timeStamp);
            status = RegSetValueExW(
                        hKey,
                        wstr,
                        0L,
                        REG_QWORD,
                        (LPBYTE) &timeStamp,
                        dwSize);
        }
    }
    if ((timeStamp - ErrorLog->LastTime) >= TimeLimit) {
        // Get here if we no write access to regkey
        ErrorLog->LastTime = timeStamp;
        bUpdate = TRUE;
    }
    return bUpdate;
}

VOID
PerfpDeleteErrorLogs(
    IN PERROR_LOG ErrorLog
    )
{
    PLIST_ENTRY entry, head, pError;

    head = (PLIST_ENTRY) ErrorLog;
    entry = head->Flink;
    DebugPrint((3, "PERFLIB:DeleteErrorLogs Entering Critsec %x\n", ErrorLog));
    RtlEnterCriticalSection(&PerfpCritSect);
    while (entry != head) {
        pError = entry;
        entry = entry->Flink;
        DebugPrint((3, "PERFLIB: Deleting error log entry %d/%x from %x\n",
                 ((PERROR_LOG) pError)->ErrorNumber, pError, ErrorLog));
        FREEMEM(pError);        // because we put ListEntry first
    }
    InitializeListHead(head);
    RtlLeaveCriticalSection(&PerfpCritSect);
    DebugPrint((3, "PERFLIB:DeleteErrorLogs Leaving Critsec\n"));
}

ULONG
PerfpThrottleError(
    IN DWORD ErrorNumber,
    IN HKEY hKey,
    IN PERROR_LOG ErrorLog
    )
{
    PERROR_LOG pError;
    ULONG bReportError, status;
    LONG64 TimeLimit = 3600 * 24;
    LONG64 SavedTime = 0;

    if (lEventLogLevel > LOG_USER) { // only throttle for <= LOG_USER
        return TRUE;
    }
    if (lEventLogLevel < LOG_USER) { // don't report error
        return FALSE;
    }
    ErrorNumber = ErrorNumber & 0x00FFFFFF;

    pError = PerfpFindError(ErrorNumber, ErrorLog);

    if (pError == NULL)
        return FALSE;       // don't report error if no more resources
    TimeLimit *= 10000000;

    SavedTime = pError->LastTime;
    bReportError = PerfpCheckErrorTime(pError, TimeLimit, hKey);
    DebugPrint((3, "PERFLIB:PerfpThrottleError ReportError %d hKey %X\n",
                    bReportError, hKey));

    if ((hKey == NULL) && (bReportError)) {
        status = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   HKLMPerflibKey,
                   0L,
                   KEY_READ | KEY_WRITE,
                   &hKey);
        if (status != ERROR_SUCCESS) {  // try read access anyway
            status = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        HKLMPerflibKey,
                        0L,
                        KEY_READ,
                        &hKey);
        }
        DebugPrint((3, "PERFLIB:PerfpThrottleError Perflib open status %d\n", status));
        if (status == ERROR_SUCCESS) {
            //
            // if this is the first time we see this error, reset the time
            // and see if a previous time was saved in registry
            //
            pError->LastTime = SavedTime;
            bReportError = PerfpCheckErrorTime(pError, TimeLimit, hKey);
            DebugPrint((3, "PERFLIB:PerfpThrottleError ReportError2 %d\n", bReportError));
            RegCloseKey(hKey);
        }
    }
    return bReportError;
}

#ifdef DBG
VOID
PerfpDebug(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all Perflib

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    if ((DebugPrintLevel <= (PerfLibDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfLibDebug)) {
        DbgPrint("%d:Perflib:", GetCurrentThreadId());
    }
    else
        return;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (PerfLibDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfLibDebug)) {

        _vsnprintf(
            (LPSTR)PerfLibDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint((LPSTR)PerfLibDebugBuffer);
    }

    va_end(ap);

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regconn\regbind.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    regbind.c

Abstract:

    This module contains routines for binding and unbinding to the Win32
    Registry server. 

Author:

    David J. Gilman (davegi) 06-Feb-1992

Revision History:
    Dragos C. Sambotin (dragoss) 21-May-1999
        Moved this code from ..\client\bind.c
        Added EndpointConn_np (pipe connecting)
        Added BaseBindToMachineShutdownInterface to bind to the new winlogon 
            ShutDown interface

--*/

#include <ntrpcp.h>
#include <rpc.h>
#include "shutinit.h"
#include "regconn.h"

//
// wRegConn_bind - common function to bind to a transport and free the
//                                      string binding.
//

wRegConn_bind(
    LPWSTR *    StringBinding,
    RPC_BINDING_HANDLE * pBindingHandle
    )
{
    DWORD RpcStatus;

    RpcStatus = RpcBindingFromStringBindingW(*StringBinding,pBindingHandle);

    RpcStringFreeW(StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        return RpcStatus;
    }
    return(ERROR_SUCCESS);
}


/*++

Routine Description for the RegConn_* functions:

    Bind to the RPC server over the specified transport

Arguments:

    ServerName - Name of server to bind with (or netaddress).

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    ERROR_SUCCESS - The binding has been successfully completed.

    ERROR_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    ERROR_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/



//
// wRegConn_Netbios - Worker function to get a binding handle for any of the
//                                              netbios protocols
//

DWORD wRegConn_Netbios(
    IN  LPWSTR  rpc_protocol,
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )

{
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    LPCWSTR           PlainServerName;

    *pBindingHandle = NULL;

    //
    // Ignore leading "\\"
    //

    if ((ServerName[0] == '\\') && (ServerName[1] == '\\')) {
        PlainServerName = &ServerName[2];
    } else {
        PlainServerName = ServerName;
    }

    RpcStatus = RpcStringBindingComposeW(0,
                                         rpc_protocol,
                                         (LPWSTR)PlainServerName,
                                         NULL,   // endpoint
                                         NULL,
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
        return( ERROR_BAD_NETPATH );
    }
    return(wRegConn_bind(&StringBinding, pBindingHandle));
}

DWORD
RegConn_nb_nb(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_nb",
                                ServerName,
                                pBindingHandle));
}

DWORD
RegConn_nb_tcp(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_tcp",
                                ServerName,
                                pBindingHandle));
}

DWORD
RegConn_nb_ipx(
    IN  LPCWSTR               ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_ipx",
                                ServerName,
                                pBindingHandle));
}


//
// EndpointConn_np - connects to a specific pipe on the remote machine
//                              (Win95 does not support server-side named pipes)
//

DWORD
EndpointConn_np(
    IN  LPCWSTR              ServerName,
    IN unsigned short *      Endpoint,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    RPC_STATUS  RpcStatus;
    LPWSTR      StringBinding;
    LPWSTR      SlashServerName;
    int         have_slashes;
    ULONG       NameLen;

    *pBindingHandle = NULL;

    if (ServerName[1] == L'\\') {
        have_slashes = 1;
    } else {
        have_slashes = 0;
    }

    //
    // Be nice and prepend slashes if not supplied.
    //

    NameLen = lstrlenW(ServerName);
    if ((!have_slashes) &&
        (NameLen > 0)) {

        //
        // Allocate new buffer large enough for two forward slashes and a
        // NULL terminator.
        //
        SlashServerName = LocalAlloc(LMEM_FIXED, (NameLen + 3) * sizeof(WCHAR));
        if (SlashServerName == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        SlashServerName[0] = L'\\';
        SlashServerName[1] = L'\\';
        lstrcpyW(&SlashServerName[2], ServerName);
    } else {
        SlashServerName = (LPWSTR)ServerName;
    }

    RpcStatus = RpcStringBindingComposeW(0,
                                         L"ncacn_np",
                                         SlashServerName,
                                         Endpoint,
                                         NULL,
                                         &StringBinding);
    if (SlashServerName != ServerName) {
        LocalFree(SlashServerName);
    }

    if ( RpcStatus != RPC_S_OK ) {
        return( ERROR_BAD_NETPATH );
    }

    return(wRegConn_bind(&StringBinding, pBindingHandle));
}

//
// RegConn_np - get a remote registry RPC binding handle for an NT server
//                              (Win95 does not support server-side named pipes)
//

DWORD
RegConn_np(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    return EndpointConn_np(ServerName,L"\\PIPE\\winreg",pBindingHandle);
}


//
// RegConn_spx - Use the Netbios connection function, RPC will resolve the name
//                               via winsock.
//

DWORD
RegConn_spx(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    return(wRegConn_Netbios(L"ncacn_spx",
                            ServerName,
                            pBindingHandle));
}


DWORD RegConn_ip_tcp(
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )

{
    return(wRegConn_Netbios(L"ncacn_ip_tcp",
                            ServerName,
                            pBindingHandle));
}

RPC_BINDING_HANDLE
PREGISTRY_SERVER_NAME_bind(
        PREGISTRY_SERVER_NAME ServerName
    )

/*++

Routine Description:

    To make the remote registry multi-protocol aware, PREGISTRY_SERVER_NAME
        parameter actually points to an already bound binding handle.
        PREGISTRY_SERVER_NAME is declared a PWSTR only to help maintain
        compatibility with NT.

--*/

{
    return(*(RPC_BINDING_HANDLE *)ServerName);
}


void
PREGISTRY_SERVER_NAME_unbind(
    PREGISTRY_SERVER_NAME ServerName,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine unbinds the RPC client from the server. It is called
    directly from the RPC stub that references the handle.

Arguments:

    ServerName - Not used.

    BindingHandle - Supplies the handle to unbind.

Return Value:

    None.

--*/

{
    DWORD    Status;

    UNREFERENCED_PARAMETER( ServerName );
    return;

}

LONG
BaseBindToMachineShutdownInterface(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This is a helper routine used to create an RPC binding from
    a given machine name to the shutdown interface (now residing in winlogon)

Arguments:

    lpMachineName - Supplies a pointer to a machine name. Must not
                    be NULL.

    BindCallback - Supplies the function that should be called once
                   a binding has been created to initiate the connection.

    Context1 - Supplies the first parameter to pass to the callback routine.

    Context2 - Supplies the second parameter to pass to the callback routine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG    Error;
    RPC_BINDING_HANDLE binding;

    Error = EndpointConn_np(lpMachineName,L"\\PIPE\\InitShutdown",&binding);

    if (Error == ERROR_SUCCESS) {

        //
        // For the named pipes protocol, we use a static endpoint, so the
        // call to RpcEpResolveBinding is not needed.
        // Also, the server checks the user's credentials on opening
        // the named pipe, so RpcBindingSetAuthInfo is not needed.
        //
        Error = (BindCallback)(&binding,
                               Context1,
                               Context2);
        RpcBindingFree(&binding);
        if (Error != RPC_S_SERVER_UNAVAILABLE) {
            return Error;
        }
    }

    if (Error != ERROR_SUCCESS) {
        if ((Error == RPC_S_INVALID_ENDPOINT_FORMAT) ||
            (Error == RPC_S_INVALID_NET_ADDR) ) {
            Error = ERROR_INVALID_COMPUTERNAME;
        } else {
            Error = ERROR_BAD_NETPATH;
        }
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regconn\regconn.h ===
/*++


Copyright (c) 1999 Microsoft Corporation

Module Name:

    regconn.h

Abstract:

    This module is the header file for the regconn library

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

--*/

//
// Common helper routine used by RegConnectRegistry and InitiateSystemShutdown
//

#ifndef __REG_CONN_H__
#define __REG_CONN_H__

typedef LONG (*PBIND_CALLBACK)(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );

typedef struct _SHUTDOWN_CONTEXT {
    DWORD dwTimeout;
    BOOLEAN bForceAppsClosed;
    BOOLEAN bRebootAfterShutdown;
} SHUTDOWN_CONTEXT, *PSHUTDOWN_CONTEXT;

//
// SHUTDOWN_CONTEXTEX contains an additional
// parameter indicating the reason for the shutdown
//

typedef struct _SHUTDOWN_CONTEXTEX {
    DWORD dwTimeout;
    BOOLEAN bForceAppsClosed;
    BOOLEAN bRebootAfterShutdown;
    DWORD dwReason; 
} SHUTDOWN_CONTEXTEX, *PSHUTDOWN_CONTEXTEX;

LONG
BaseBindToMachineShutdownInterface(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );


DWORD
RegConn_nb_nb(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    );

DWORD
RegConn_nb_tcp(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_nb_ipx(
    IN  LPCWSTR               ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_np(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_spx(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD RegConn_ip_tcp(
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    );

LONG
NewShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
NewShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
NewAbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );


#endif //__REG_CONN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regconn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by regconn.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regconn\shutcall.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    shutcall.c


Abstract:

    This module contains callbacks for RP-Calling into winlogon's
    shutdown interface

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

Notes:


Revision History:


--*/


#include <rpc.h>
#include "shutinit.h"
#include "regconn.h"


LONG
NewShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXT ShutdownContext
    )
/*++

Routine Description:

    New callback for binding to a machine to initiate a shutdown.
    This will call into BaseInitiateShutdown from InitShutdown interface (in winlogon),
    instead of BaseInitiateSystemShutdown from winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateShutdown((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}


LONG
NewShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXTEX ShutdownContext
    )
/*++

Routine Description:

    New version of callback for binding to a machine to initiate a shutdown.
    This will call BaseInitiateShutdownEx from InitShutdown interface (in winlogon)
    instead of BaseInitiateSystemShutdownEx from winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateShutdownEx((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown,
                                            ShutdownContext->dwReason);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}


LONG
NewAbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Unused1,
    IN PVOID Unused2
    )
/*++

Routine Description:

    New callback for binding to a machine to abort a shutdown.
    This will call into BaseAbortShutdown in InitShutdown interface (in winlogon),
    instead of BaseAbortSystemShutdown in winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseAbortShutdown((PREGISTRY_SERVER_NAME)pbinding);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regsvc\init.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module contains the initialization routine for the Win32 Registry
    API RPC server.

Author:

    David J. Gilman (davegi) 15-May-1992

--*/

#include <ntrpcp.h>
#include <rpc.h>
#include <svcs.h>
#include "regrpc.h"
#include "..\perflib\ntconreg.h"

BOOL InitializeRemoteSecurity( );

BOOL InitializeRegCreateKey( );

NTSTATUS InitRestrictedMachineHandle( );

VOID CleanupRestrictedMachineHandle( );

extern PSVCHOST_GLOBAL_DATA    g_svcsGlobalData;

BOOL
StartWinregRPCServer( 
                     )
{
    LPWSTR              ServiceName;
    NTSTATUS            Status;

    if( !g_svcsGlobalData ) {
        return FALSE;
    }
    ServiceName = INTERFACE_NAME;
    Status = g_svcsGlobalData->StartRpcServer(
                ServiceName,
                winreg_ServerIfHandle
                );
    ASSERT( NT_SUCCESS( Status ));
    if( ! NT_SUCCESS( Status )) {
        return FALSE;
    }
    
    return TRUE;
}

BOOL
InitializeWinreg(
    )

/*++

Routine Description:

    Initialize the Winreg RPC server by creating the notify thread,
    starting the server and creating the external synchronization event.

Arguments:

    None.

Return Value:

    BOOL - Returns TRUE if initialization is succesful.

--*/
{
    BOOL                Success;
    HANDLE              PublicEvent;

    if( !NT_SUCCESS(InitRestrictedMachineHandle()) ) {
        return FALSE;
    }
    //
    // Create the notify thread.
    //

    Success = InitializeRegNotifyChangeKeyValue( );
    ASSERT( Success == TRUE );
    if( Success == FALSE ) {
        return FALSE;
    }

    //
    // Initialize BaseRegCreateKey
    //

    Success = InitializeRegCreateKey( );
    ASSERT( Success == TRUE );
    if( Success == FALSE ) {
        return FALSE;
    }

    //
    // Initialize support for remote security
    //

    Success = InitializeRemoteSecurity( );
    if ( Success == FALSE )
    {
        return( FALSE );
    }

    //
    // Start the Winreg RPC server.
    //
    Success = StartWinregRPCServer( );
    if ( Success == FALSE )
    {
        return( FALSE );
    }

    //
    //  Let the world know that the server is running.
    //
    PublicEvent = CreateEvent( NULL, TRUE, TRUE, PUBLIC_EVENT );
    ASSERT( PublicEvent );
    if( !PublicEvent  ) {
        return FALSE;
    }

    //
    // Success!
    //

    return TRUE;
}

BOOL
ShutdownWinreg(
    )

/*++

Routine Description:

    Stops the Winreg RPC server.

Arguments:

    None.

Return Value:

    None

--*/
{
    // 
    // Stop the rpc server
    //
    if( !g_svcsGlobalData ) {
        return FALSE;
    }
    g_svcsGlobalData->StopRpcServer( winreg_ServerIfHandle );
    if ( !PerfRegCleanup() ) {
        return FALSE;
    }

    CleanupRestrictedMachineHandle();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regsvc\dllmain.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    DLL entry point. Does nothing for now. We may add to it later.

Author:

    Dragos C. Sambotin (dragoss) 10-Aug-2000

--*/

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.  Here's why:
//   1. Incorrectly assuming that thread attach/detach are 1:1. (explain)
//   2. Performance
//      a) touching pages (#3 below)
//      b) assume you will be loaded by someone who is performance-critical.
//
//   1. For every process that the DLL is attached to, DllMain gets called
//      with DLL_PROCESS_ATTACH.  For any new threads created or destroyed
//      after DLL_PROCESS_ATTACH, DllMain is called with DLL_THREAD_ATTACH
//      and DLL_THREAD_DETACH events.  Since it is rare that a DLL controls
//      or even knows about the clients that use it, it shouldn't assume
//      that DllMain is called only once (or even a small number of times).
//      In fact, you should assume the worst case (that it is called a lot)
//      and code for that case.  This is not unrealistic either.  If your
//      DLL gets attached to services.exe for example, you will be hit
//      with a lot of thread attach/detach events.  If you don't need these
//      events (and you shouldn't) your DllMain code needs to get paged in
//      (assuming it's not paged in) and called.
//
//   2. Over time, people tend to lose sight of why and when DLLs are loaded.
//      Further, as more APIs are added to the DLL the likelihood that the
//      DLL will be loaded increases.  (i.e. It becomes more useful.) It
//      is your responsibility to keep the performance of your DLL at a level
//      compatible with your most demanding (performance wise) client.  For
//      example: Say a very performance-critical client needs to use a small
//      piece of functionality in your DLL.  If you've done things in DllMain
//      (like create heaps, or access the registry, etc.) that don't strictly
//      need to be done to access that small piece of functionality, then
//      it is wasteful to do so and may be the straw that broke the camel's
//      back in terms of your client deciding your DLL is "too heavy" to be
//      used.  For the functionality in your DLL to "scale" from your first
//      very simple client to the Nth performance-critical client, you've got
//      to keep DllMain absolutely lean and mean.
//
//   3. Fewer code in DllMain means fewer pages touched when your DLL is
//      loaded.  If your DLL is loaded at all during boot of the OS or
//      an application, this means faster startup times.  Let's say it again
//      in another way -- "the more code you add to DllMain, the slower the
//      OS or application boots up".  You may think now that your DLL won't
//      be loaded during boot.  I'll bet most of the developers of the DLLs
//      that are now loaded during boot thought the same thing in the
//      beginning. ;-)  As your DLL becomes more useful, it gets used by
//      more and more parts of the system.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {

    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\regsvc\regsvc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regsvc.c

Abstract:

    This module contains the implementation of the remote registry
    service. 
    
    It just initialize and starts the registry RPC server. The service
    is supposed automatically started by SC at boot, and then restarted
    if something goes wrong.

    Used \nt\private\samples\service as a template

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

Revision History:

    Dragos C. Sambotin (dragoss) 10-Aug-2000
        - converted to a dll to be loaded inside a svchost.exe instance
        - used base\screg\sc\svchost\sample\server as a template


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>
#include <svcs.h>
#include "..\perflib\ntconreg.h"


SERVICE_STATUS_HANDLE   g_hStatus;
SERVICE_STATUS          g_status;
BOOLEAN                 g_FirstTime = TRUE;
PSVCHOST_GLOBAL_DATA    g_svcsGlobalData = NULL;

BOOL
InitializeWinreg( VOID );

BOOL
ShutdownWinreg(VOID);

BOOL
StartWinregRPCServer( VOID );

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    g_svcsGlobalData = pGlobals;
}

VOID
UpdateServiceStatus (DWORD dwCurrentState,
                     DWORD dwWin32ExitCode,
                     DWORD dwWaitHint)
{    

    static DWORD dwCheckPoint = 1;

    ASSERT (g_hStatus);

    if (dwCurrentState == SERVICE_START_PENDING) {
        g_status.dwControlsAccepted = 0;
    } else {
        g_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    }

    g_status.dwCurrentState = dwCurrentState;
    g_status.dwWin32ExitCode = dwWin32ExitCode;
    g_status.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) || ( dwCurrentState == SERVICE_STOPPED ) ) {
        g_status.dwCheckPoint = 0;
    } else {
        g_status.dwCheckPoint = dwCheckPoint++;
    }

    SetServiceStatus (g_hStatus, &g_status);
}

VOID
StopService()
{
    //
    // Terminate the registry RPC server
    //
    ShutdownWinreg();

    g_svcsGlobalData = NULL;
    // report the status to the service control manager.
    //
    UpdateServiceStatus (SERVICE_STOPPED,NO_ERROR,0);
}

//+---------------------------------------------------------------------------
// ServiceHandler - Called by the service controller at various times.
//
// type of LPHANDLER_FUNCTION
//
VOID
WINAPI
ServiceHandler (
    DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        UpdateServiceStatus (SERVICE_STOP_PENDING,ERROR_SERVICE_SPECIFIC_ERROR,3000);

        StopService();
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        // This may not be need, but refresh our status to the service
        // controller.
        //
        ASSERT (g_hStatus);
        SetServiceStatus (g_hStatus, &g_status);
        break;
    }
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by svchost when starting this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
VOID
WINAPI
ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    RPC_STATUS Status;

    // Since we run in svchost.exe, we must have the 'share process' bit set.
    //
    ZeroMemory (&g_status, sizeof(g_status));
    g_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    g_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    ASSERT( g_svcsGlobalData != NULL );
    // Register the service control handler.
    //
    //DbgPrint( "Starting Remote Registry Service\n" );
    g_hStatus = RegisterServiceCtrlHandler (TEXT("RemoteRegistry"), ServiceHandler);
    if (g_hStatus)
    {
        UpdateServiceStatus (SERVICE_START_PENDING,NO_ERROR,3000);

        // now svchost.exe does it for us
        //RpcpInitRpcServer();


        if (!PerfRegInitialize()) {
            goto ErrorExit;
        }

        if( g_FirstTime ) {
            if( !InitializeWinreg() ) {
                goto ErrorExit;
            }
            g_FirstTime = FALSE;
        } else {
            // just restart RPC service
            if( !StartWinregRPCServer() ) {
                goto ErrorExit;
            }
        }

        Status = RpcServerRegisterAuthInfo( NULL, RPC_C_AUTHN_WINNT, NULL, NULL );
    
        if( Status ) {
            goto Cleanup;
        }

        Status = RpcServerRegisterAuthInfo( NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);

        if( Status ) {
            goto Cleanup;
        }

        UpdateServiceStatus (SERVICE_RUNNING,NO_ERROR,0);

        return;


Cleanup:
        //
        // Terminate the registry RPC server
        //
        ShutdownWinreg();

ErrorExit:
        // report the status to the service control manager.
        //
        UpdateServiceStatus (SERVICE_STOPPED,NO_ERROR,0);
        
        //DbgPrint( "RegisterServiceCtrlHandler failed! (1)\n" );
    }
    else 
    {
        DbgPrint( "RegisterServiceCtrlHandler failed!  %d\n", GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\predefh.c ===
/*++


Copyright (c) 1991 Microsoft Corporation

Module Name:

    Predefh.c

Abstract:

    This module contains routines for opening the Win32 Registry API's
    predefined handles.

    A predefined handle is used as a root to an absolute or relative
    sub-tree in the real Nt Registry. An absolute predefined handle maps
    to a specific key within the Registry. A relative predefined handle
    maps to a key relative to some additional information such as the
    current user.

    Predefined handles are strictly part of the Win32 Registry API. The
    Nt Registry API knows nothing about them.

    A predefined handle can be used anywhere that a non-predefined handle
    (i.e. one returned from RegCreateKey(), RegOpenKey() or
    RegConnectRegistry()) can be used.

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "ntconreg.h"
#include "regsec.h"
#ifdef LOCAL
#include "tsappcmp.h"

#if defined(LEAK_TRACK) 
#include "regleak.h"
#endif // LEAK_TRACK
#endif

//
// Determine the length of a Unicode string w/o the trailing NULL.
//

#define LENGTH( str )   ( sizeof( str ) - sizeof( UNICODE_NULL ))

//
// Nt Registry name space.
//

#define MACHINE         L"\\REGISTRY\\MACHINE"

#define USER            L"\\REGISTRY\\USER"

#define CLASSES         L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"

#define CURRENTCONFIG   L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\HARDWARE PROFILES\\CURRENT"

extern const
UNICODE_STRING          MachineStringKey = {
                            LENGTH( MACHINE ),
                            LENGTH( MACHINE ),
                            MACHINE
                            };

extern const
UNICODE_STRING          UserStringKey = {
                            LENGTH( USER ),
                            LENGTH( USER ),
                            USER
                        };

extern const
UNICODE_STRING          ClassesStringKey = {
                            LENGTH( CLASSES ),
                            LENGTH( CLASSES ),
                            CLASSES
                        };

extern const
UNICODE_STRING          CurrentConfigStringKey = {
                            LENGTH( CURRENTCONFIG ),
                            LENGTH( CURRENTCONFIG ),
                            CURRENTCONFIG
                        };


HANDLE	RestrictedMachineHandle = NULL;

NTSTATUS
InitSecurityAcls(PSECURITY_DESCRIPTOR *SecurityDescriptor)
/*++

Routine Description:

    Gives GENERIC_ALL to admins and denies WRITE_OWNER | WRITE_DAC  from everyone

Arguments:


Return Value:


--*/
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID                        BuiltInAdministrators = NULL;
    PSID                        Everyone = NULL;
    NTSTATUS                    Status;
    ULONG                       AclSize;
    ACL                         *Acl;

    *SecurityDescriptor = NULL;

    Status = RtlAllocateAndInitializeSid(
              &WorldAuthority,
              1,
              SECURITY_WORLD_RID,
              0,0,0,0,0,0,0,
              &Everyone );
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAllocateAndInitializeSid(
              &NtAuthority,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0,0,0,0,0,0,
              &BuiltInAdministrators );

    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }



    AclSize = sizeof (ACL) +
        (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(BuiltInAdministrators) +
        GetLengthSid(Everyone);

    *SecurityDescriptor = (PSECURITY_DESCRIPTOR)RtlAllocateHeap( RtlProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (!*SecurityDescriptor) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    } 

    Acl = (ACL *)((BYTE *)(*SecurityDescriptor) + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateAcl(  Acl,
                            AclSize,
                            ACL_REVISION);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    (KEY_ALL_ACCESS & ~(WRITE_OWNER | WRITE_DAC)),
                                    Everyone);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    GENERIC_ALL,
                                    BuiltInAdministrators);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlCreateSecurityDescriptor(
                *SecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlSetDaclSecurityDescriptor(  *SecurityDescriptor,
                                            TRUE,
                                            Acl,
                                            FALSE);

Exit:
    if( Everyone ) {
        RtlFreeSid( Everyone );
    }
    
    if( BuiltInAdministrators ) {
        RtlFreeSid( BuiltInAdministrators );
    }

    return Status;
}


error_status_t
OpenClassesRoot(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CLASSES_ROOT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SOFTWARE\CLASSES.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PSECURITY_DESCRIPTOR     SecurityDescriptor = NULL;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          UsersHive;
    UNICODE_STRING          UsersMergedHive;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

#ifdef LOCAL
    //
    // Multiuser CLASSES key so each user has their own key.  If opening
    // CLASSES in execute mode - open it under HKEY_CURRENT_USER else
    // just let it fall thru here and open the global one.
    //
    if (gpfnTermsrvOpenUserClasses) {
        Status = gpfnTermsrvOpenUserClasses(samDesired,phKey);
    } else {
        *phKey = NULL;
    }
    if (!(*phKey)) {
#endif // LOCAL


    //
    // Initialize the SECURITY_DESCRIPTOR.
    //
    Status = InitSecurityAcls(&SecurityDescriptor);

    if( ! NT_SUCCESS( Status )) {
        goto error_exit;
    }


#ifdef LOCAL

    if (gbCombinedClasses) {
        // first try for a per-user HKCR
        Status = OpenCombinedClassesRoot( samDesired, phKey );

        if ( NT_SUCCESS( Status ) ) {
            goto error_exit;
        }
    }
#endif

    //
    // Initialize the OBJECT_ATTRIBUTES structure so that it creates
    // (opens) the key "\REGISTRY\MACHINE\SOFTWARE\CLASSES" with a Security
    // Descriptor that allows everyone complete access.
    //

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING)&ClassesStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        SecurityDescriptor
        );

    Status = NtCreateKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );
#ifdef LOCAL
    }
#endif // LOCAL

#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Creating HKEY_CLASSES_ROOT failed, status = 0x%x\n",
                Status
                );
        }
#endif

error_exit:
    
    if( SecurityDescriptor != NULL ) {
	RtlFreeHeap( RtlProcessHeap(), 0, SecurityDescriptor );
    }
    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenCurrentUser(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_USER predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\USER\*.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    // Open the registry key.
    //

    Status = RtlOpenCurrentUser( samDesired, /* MAXIMUM_ALLOWED, */ phKey );

    RPC_REVERT_TO_SELF();
    //
    // Map the returned status
    //

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenLocalMachine(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempt to open the the HKEY_LOCAL_MACHINE predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING)&MachineStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_LOCAL_MACHINE failed, status = 0x%x\n",
                Status
                );
        }
#endif

    if ( NT_SUCCESS( Status ) )
    {
        if (! REGSEC_CHECK_REMOTE( phKey ) )
        {
            ASSERT( RestrictedMachineHandle != NULL );
            NtClose(*phKey);
            *phKey = REGSEC_FLAG_HANDLE( RestrictedMachineHandle, CHECK_MACHINE_PATHS );
        }
    }

    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenUsers(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_USERS predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\USER.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING)&UserStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_USERS failed, status = 0x%x\n",
                Status
                );
        }
#endif

/*
    if ( NT_SUCCESS( Status ) )
    {
        if (! REGSEC_CHECK_REMOTE( phKey ) )
        {
            *phKey = REGSEC_FLAG_HANDLE( *phKey, CHECK_USER_PATHS );
        }
    }
*/
    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenCurrentConfig(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_CONFIG predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\HARDWARE PROFILES\CURRENT

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING)&CurrentConfigStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_CURRENT_CONFIG failed, status = 0x%x\n",
                Status
                );
        }
#endif
    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}
error_status_t
OpenPerformanceData(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_DATA predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns a the predefined handle HKEY_PERFORMANCE_DATA.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    NTSTATUS status;

    if ( 0 ) {
        DBG_UNREFERENCED_PARAMETER(ServerName);
        DBG_UNREFERENCED_PARAMETER(samDesired);
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    if ( ! REGSEC_CHECK_PERF( phKey ) )
    {
        RPC_REVERT_TO_SELF();
        return( ERROR_ACCESS_DENIED );
    }

    // Move lodctr/unlodctr access check to part of PerfOpenKey()

    status  = PerfOpenKey( HKEY_PERFORMANCE_DATA );

    RPC_REVERT_TO_SELF();

    *phKey = (RPC_HKEY) HKEY_PERFORMANCE_DATA;
    return ERROR_SUCCESS;

}

error_status_t
OpenPerformanceText(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_TEXT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns the predefined handle HKEY_PERFORMANCE_TEXT.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    error_status_t Status = ERROR_SUCCESS;

// No need to call OpenPerformanceData for getting text (HWC 4/1994)
//    Status = OpenPerformanceData(ServerName, samDesired, phKey);
//    if (Status==ERROR_SUCCESS) {
        *phKey = HKEY_PERFORMANCE_TEXT;
//    }
    return(Status);
}

error_status_t
OpenPerformanceNlsText(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_TEXT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns the predefined handle HKEY_PERFORMANCE_NLSTEXT.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    error_status_t Status = ERROR_SUCCESS;

// No need to call OpenPerformanceData for getting text (HWC 4/1994)
//    Status = OpenPerformanceData(ServerName, samDesired, phKey);
//    if (Status==ERROR_SUCCESS) {
        *phKey = HKEY_PERFORMANCE_NLSTEXT;
//    }
    return(Status);
}


error_status_t
OpenDynData(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )
/*++

Routine Description:

    Attempts to open the the HKEY_DYN_DATA predefined handle.

    There is currently no HKEY_DYN_DATA on NT, thus this
    function always returns ERROR_CALL_NOT_IMPLEMENTED.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key HKEY_DYN_DATA

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    return((error_status_t)ERROR_CALL_NOT_IMPLEMENTED);
}

//
// Default ("fake") handle returned to all check_machine_paths-like connections
//
NTSTATUS
OpenMachineKey(PHANDLE phKey)
{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    InitializeObjectAttributes(
                            &Obja,
                            (PUNICODE_STRING)&MachineStringKey,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL
                            );

    Status = NtOpenKey(
                        phKey,
                        MAXIMUM_ALLOWED,
                        &Obja
                        );

    return Status;
}

NTSTATUS
InitRestrictedMachineHandle()
{
    return OpenMachineKey(&RestrictedMachineHandle);
}

VOID
CleanupRestrictedMachineHandle()
{
    if( RestrictedMachineHandle != NULL ) {
        NtClose(RestrictedMachineHandle);
        RestrictedMachineHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regclass.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegClass.c

Abstract:

    This module contains routines to manipulate class registration
    registry keys for the win32 registry apis.  These routines are called
    from several of the functions for manipulating registry, including
    the functions that open, enumerate, create, and delete keys.

Author:

    Adam P. Edwards     (adamed)  14-Nov-1997

Key Functions:

    OpenCombinedClassesRoot
    BaseRegGetKeySemantics
    BaseRegOpenClassKey
    BaseRegOpenClassKeyFromLocation
    BaseRegGetUserAndMachineClass

Notes:

****************************************************
    PLEASE READ THIS IF YOU ARE NEW TO THIS CODE!!!!
****************************************************

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for
    HKLM\Software\Classes.

    The per-user HKCR combines machine classes stored it the
    traditional HKLM\Software\Classes location with classes
    stored in HKCU\Software\Classes.

    Certain keys, such as CLSID, will have subkeys that come
    from both the machine and user locations.  When there is a conflict
    in key names, the user oriented key overrides the other one --
    only the user key is seen in that case.

    Here are the key ideas for this implementation:

    1. The changes for this module only affect keys under
       HKEY_CLASSES_ROOT. Only the Local registry
       implementation supports HKCR so all the changes are
       local only, they do not exist in the
       remote rpc registry server.

    2. We parse each key under HKCR as

         <prefix>\<intermediate>\<special>[\<classreg>]\[<lastelement>]

       where <prefix> is one of the forms

         \Registry\Machine\Software\Classes
         \Registry\User\<sid>\Software\Classes
         \Registry\User\<sid>_Classes

       <intermediate> can be a subpath of arbitrary length

       <special> is a certain list of keys, shown below in the
         gSpecialSubtrees table, e.g. IID, CLSID.

       <classreg> is any subkey of <special>.  <lastelement> is
         the remainder of the path.

    3. In order to quickly distinguish keys in HKCR from keys not in HKCR, we
       use tag bits on each registry handle that we return from an open or create
       if the key is under HKCR. When the HKCR predefined handle is opened,
       we set a tag on its handle index -- any children open or created with a
       parent key whose tag is set like this will inherit the tag. There are other
       tags, such as those for local and remote regkeys, already in use prior
       to the implementation of per user class registration in NT5. Please see
       the header file for more information on how to interpret the tags.

    4. The special keys have the following properties which differentiate
       them from standard registry keys:

       a. The children of a special key come from both HKLM\Software\Classes
          and HKCU\Software\Classes.  Thus, since CLSID is a special key,
          if HKLM\Software\Classes\CLSID\Key1 exists and
          HKCU\Software\Classes\CLSID\Key2 exists, one would find the keys
          Key1 and Key2 under HKCR\CLSID.
       b. If the same key exists in both the user and machine locations, only
          the user version of the key is seen under HKCR.

     5. To create the illusion described above, the code for several api's
        had to be modified:

        a. RegOpenKeyEx -- for HKCR subkeys, this api was modified to look
           for the key to open first in the user part of the registry,
           then the machine part if the user version did not exist. All
           keys opened with HKCR as an ancestor get a bit set in the handle
           index.

        b. RegCreateKeyEx -- modified in a fashion similar to RegOpenKeyEx.
        c. RegDeleteKey  -- modified to find key to delete in fashion similar
           to RegOpenKeyEx.

        d. RegEnumKeyEx -- extensive changes for HKCR. Previously this api was
           simply a wrapper to the kernel version. This is insufficient now
           because the kernel knows nothing of our hkcr scheme.  See regecls.*
           for details.

        e. RegQueryInfoKey -- changes related to RegEnumKeyEx changes -- see
           regecls.*, regqkey.c.

    It should be noted that HKCU\Software\Classes is not the true
    location of the user-only class data.  If it were, all the class
    data would be in ntuser.dat, which roams with the user.  Since
    class data can get very large, installation of a few apps
    would cause HKCU (ntuser.dat) to grow from a manageable size
    to many megabytes.  Since user-specific class data comes from
    the directory, it does not need to roam and therefore it was
    separated from HKCU (ntuser.dat) and stored in another hive
    mounted under HKEY_USERS.

    It is still desirable to allow access to this hive through
    HKCU\Software\Classes, so we use some trickery (symlinks) to
    make it seem as if the user class data exists there.

**************************
    IMPORTANT ASSUMPTIONS:
**************************

    This code assumes that all special keys exist in both
    HKEY_LOCAL_MACHINE\Software\Classes and HKEY_CURRENT_USER\Software\Classes.
    The code may break if this is not true.

--*/


#ifdef LOCAL

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"


NTSTATUS QueryKeyInfo(
    HKEY hKey,
    PKEY_FULL_INFORMATION* ppKeyFullInfo,
    ULONG BufferLength,
    BOOL fClass,
    USHORT MaxClassLength);

extern HKEY HKEY_ClassesRoot;

BOOL            gbCombinedClasses = TRUE;

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

RTL_CRITICAL_SECTION gRegClassHeapCritSect;
DWORD                gcbAllocated = 0;
DWORD                gcAllocs = 0;
DWORD                gcbMaxAllocated = 0;
DWORD                gcMaxAllocs = 0;
PVOID                gpvAllocs;

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

UNICODE_STRING gMachineClassesName = {
    REG_MACHINE_CLASSES_HIVE_NAMELEN,
    REG_MACHINE_CLASSES_HIVE_NAMELEN,
    REG_MACHINE_CLASSES_HIVE_NAME};


error_status_t
OpenCombinedClassesRoot(
     IN REGSAM samDesired,
    OUT HANDLE * phKey
    )
/*++

Routine Description:

    Attempts to open the the HKEY_CLASSES_ROOT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SOFTWARE\CLASSES.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          UsersHive;
    UNICODE_STRING          UsersMergedHive;

    // first try for a per-user HKCR
    Status = RtlFormatCurrentUserKeyPath( &UsersHive );
    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    UsersMergedHive.MaximumLength = UsersHive.MaximumLength +
        REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_CHAR_SIZE;

    UsersMergedHive.Buffer = RtlAllocateHeap( RtlProcessHeap( ), 0,UsersMergedHive.MaximumLength);
    if( UsersMergedHive.Buffer == NULL ) {
        RtlFreeUnicodeString( &UsersHive );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&UsersMergedHive, &UsersHive );

    // add the _Merged_Classes suffix
    Status = RtlAppendUnicodeToString( &UsersMergedHive, REG_USER_HIVE_CLASSES_SUFFIX);

    ASSERT(NT_SUCCESS(Status));

    //
    // Initialize the OBJECT_ATTRIBUTES structure so that it creates
    // (opens) the key "\HKU\<sid>_Merged_Classes" with a Security
    // Descriptor that allows everyone complete access.
    //

    InitializeObjectAttributes(
        &Obja,
        &UsersMergedHive,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );

    RtlFreeUnicodeString( &UsersMergedHive );
    RtlFreeUnicodeString( &UsersHive );

    //
    // This key is the ancestor of all keys in HKCR, so
    // we must mark its handle so that its origin in HKCR
    // is propagated to all children opened with this handle
    //
    if (NT_SUCCESS(Status)) {

        *phKey = REG_CLASS_SET_SPECIAL_KEY(*phKey);

    }

    return Status;
}



NTSTATUS BaseRegGetKeySemantics(
    HKEY            hkParent,
    PUNICODE_STRING pSubKey,
    SKeySemantics*  pKeySemantics)
/*++

Routine Description:

    This function parses a key in HKEY_CLASSES_ROOT.  It is used to determine if a given key
    is a class registration unit key, as well as other syntactic / semantic information about
    the key.  It sets the value of pfIsClsRegKey to TRUE if it is, FALSE if not.

    The key in question is defined by the (hkParent, pSubKey) pair.

    Definitions for terms such as Prefix, Special Key, and class registration can
    be found at the top of this module.

Arguments:

    hkParent      - parent portion of key
    pSubKey       - child portion of key
    pKeySemantics - pointer to struct containing key semantic information -- the
                    following members of this structure are affected:

                    _fUser: TRUE if this key is rooted in HKEY_USERS, FALSE if not
                    _fMachine: TRUE if this key is rooted in HKLM, FALSE if not
                    _fCombinedClasses: TRUE if this key is rooted in HKEY_USERS\\<Sid>_Classes
                    _fClassRegistration: TRUE if this key is a class registration unit
                    _fClassRegParent: TRUE if this key is the parent of a class registration unit
                    _ichKeyStart: index to start of a class reg after the prefix -- this is after
                                 the pathsep which follows the prefix
                    _cbPrefixLen: Length (in bytes) of prefix from start of full path
                    _cbSpecialKey: Length (in bytes) of the name of the special key -- this is
                                 not from the start of the full path, just that key name only. It
                                 includes an initial pathsep.
                    _cbClassRegKey: length of class reg key name (not from start of full path).
                                 Includes an initial pathsep.
                    _cbFullPath: size of buffer structure pointed to by _pFullPath.  On return,
                                 this member is set to the number of bytes written to _pFullPath
                                 by the function, or the required number of bytes if the buffer
                                 passed in was too small
                    _pFullPath: KEY_NAME_INFORMATION structure containing the full pathname
                                of the registry key defined by (hkParent, pSubKey). This pathname
                                is null terminated.

Returns:

    NT_SUCCESS If the function completed successfully.  If the buffer pointed to by
    pKeySemantics->_pFullPath is not large enough to hold the name of the key, the
    function returns STATUS_BUFFER_TOO_SMALL and the required size in bytes is
    written to pKeySemantics->_cbFullPath.  The caller may then reallocate the buffer
    and call this function again.  All other errors return the appropriate NTSTATUS
    failure code.

Notes:

    After calling this function and getting a successful return status, the pKeySemantics
    structure should be freed by calling BaseRegReleaseKeySemantics

--*/
{
    NTSTATUS                 Status;
    UNICODE_STRING           NameInfo;
    PKEY_NAME_INFORMATION    pNameInfo;

    USHORT                   ichClassesKeyNameEnd;
    USHORT                   ichSpecialKeyNameEnd;
    USHORT                   cbName;
    ULONG                    cbObjInfo;
    WCHAR*                   szClassRegKeyEnd;

    //
    // Save in params
    //
    cbObjInfo = pKeySemantics->_cbFullPath  - REG_CHAR_SIZE; // subtract one for trailing \0
    pNameInfo = pKeySemantics->_pFullPath;

    //
    // reset out params
    //
    memset(&(pKeySemantics->_pFullPath), 0, sizeof(*(pKeySemantics->_pFullPath->Name)));
    memset(pKeySemantics, 0, sizeof(*pKeySemantics));

    //
    // restore in params
    //
    pKeySemantics->_pFullPath = pNameInfo;
    pKeySemantics->_cbFullPath = cbObjInfo;

    //
    // Get full name of key -- first, we need to find the path
    // for the registry key hkParent
    //
    if (!hkParent) {

        //
        // If no key name was specified, the full path is simply the subkey name
        //
        pKeySemantics->_cbFullPath = REG_CHAR_SIZE;
        (pKeySemantics->_pFullPath->Name)[0] = L'\0';
        pKeySemantics->_pFullPath->NameLength = 0;
        pKeySemantics->_cbFullPath = sizeof(*(pKeySemantics->_pFullPath));

    } else {

        Status = NtQueryKey(
            hkParent,
            KeyNameInformation,
            pKeySemantics->_pFullPath,
            cbObjInfo,
            &pKeySemantics->_cbFullPath);

        if (STATUS_KEY_DELETED == Status) {
            Status = STATUS_SUCCESS;
        }

        //
        // Kernel set the _cbFullPath member to the necessary size -- tack
        // on the length of the subkey too
        //

        pKeySemantics->_cbFullPath += pSubKey->Length + REG_CHAR_SIZE * 2;

        //
        // The retrieval of the object's name information may have succeeded,
        // but we still need to append the subkey, so verify that enough
        // space is left
        //
        if (NT_SUCCESS(Status) && (cbObjInfo < pKeySemantics->_cbFullPath)) {
            //
            // we have successfully retrieved the info from the kernel,
            // but adding the subkey, we overflow ==> allocate a buffer
            // big enough and copy the info from _pFullPath
            //
            pNameInfo = (PKEY_NAME_INFORMATION) RegClassHeapAlloc(
                pKeySemantics->_cbFullPath);

            if (!pNameInfo) {
                return STATUS_NO_MEMORY;
            }

            RtlCopyMemory(pNameInfo->Name,
                          pKeySemantics->_pFullPath->Name,
                          pKeySemantics->_pFullPath->NameLength);
            pNameInfo->NameLength = pKeySemantics->_pFullPath->NameLength;

        }

        if (!NT_SUCCESS(Status)) {

            //
            // Retry by allocating a new buffer if the kernel thought the
            // supplied buffer was too small.  Add extra padding
            // because we may need to add a null terminator and pathsep later
            //
            if (STATUS_BUFFER_OVERFLOW == Status) {

                //
                // The _cbFullPath member was to the required length in the
                // call to NtQueryKey above and includes extra padding
                // for appending more characters
                //
                pNameInfo = (PKEY_NAME_INFORMATION) RegClassHeapAlloc(
                    pKeySemantics->_cbFullPath);

                if (!pNameInfo) {
                    return STATUS_NO_MEMORY;
                }

                cbObjInfo = pKeySemantics->_cbFullPath;

                //
                // Retry -- we should have a large enough buffer now
                //
                Status = NtQueryKey(
                    hkParent,
                    KeyNameInformation,
                    pNameInfo,
                    cbObjInfo,
                    &pKeySemantics->_cbFullPath);

                if (STATUS_KEY_DELETED == Status) {
                    Status = STATUS_SUCCESS;
                }
            }

            if (!NT_SUCCESS(Status)) {

                //
                // We allocated heap for the second query, but since it failed,
                // we need to free the allocated memory.
                //
                if (pNameInfo != pKeySemantics->_pFullPath) {
                    RegClassHeapFree(pNameInfo);
                }

                return Status;
            }
        }
    }

    //
    // If this isn't set, we know a non-registry key handle was passed in since
    // all registry handles have a path associated with them, whereas other types
    // of handles may not
    //
    if (!(pNameInfo->Name)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // We will always return success after this point, so it's
    // ok to set the full path member of the structure now. Make
    // sure we set the flag indicating that we had to allocate
    // memory to store the name if that was indeed the case
    //
    if (pNameInfo != pKeySemantics->_pFullPath) {
        pKeySemantics->_fAllocedNameBuf = TRUE;
    }

    pKeySemantics->_pFullPath = pNameInfo;

    //
    // Now that we know the name of the parent key, we can concatenate it
    // with the pSubKey parameter
    //

    //
    // First we need to add a trailing pathsep and NULL terminate it
    //
    pNameInfo->Name[pNameInfo->NameLength / 2] = L'\\';
    pNameInfo->Name[pNameInfo->NameLength / 2 + 1] = L'\0';

    //
    // Get a unicode string so we can perform string operations
    //
    RtlInitUnicodeString(&NameInfo, pNameInfo->Name);

    //
    // Adjust the length to reflect the unicode string -- right
    // now it inlcudes the length of the Length member of the
    // KEY_NAME_INFORMATION structure -- we just want the length
    // of the string
    //
    pNameInfo->NameLength = NameInfo.Length;

    //
    // Now add space to the string for the subkey and slash
    //
    NameInfo.MaximumLength += pSubKey->Length + REG_CHAR_SIZE;

    //
    // append the subkey to the parent key
    //

    //
    // We made sure the buffer was big enough, so the only way this will
    // fail is if pSubKey is invalid, which will cause an
    // access violation, so no need no test
    //
    Status = RtlAppendUnicodeStringToString(&NameInfo, pSubKey);

    ASSERT(NT_SUCCESS(Status));

    //
    // if the key name isn't at least as long as the shortest
    // classes hive name, leave.
    // This assumes that
    // HKU\\Sid_Classes is shorter than
    // HKU\\Sid\\Software\\Classes
    //
    if (NameInfo.Length < REG_CLASSES_HIVE_MIN_NAMELEN) {
        return STATUS_SUCCESS;
    }

    //
    // remove any terminating pathsep
    //
    if (NameInfo.Buffer[NameInfo.Length / 2 - 1] == L'\\') {
        NameInfo.Length-= sizeof(L'\\');
    }

    //
    // We're done getting the name of the key, save its length
    // for the caller
    //
    pNameInfo->NameLength = NameInfo.Length;

    //
    // cache the name length
    //
    cbName = (USHORT) pNameInfo->NameLength;

    //
    // null terminate the name
    //
    pNameInfo->Name[cbName / REG_CHAR_SIZE] = L'\0';

    if (REG_CLASS_IS_SPECIAL_KEY(hkParent)) {
        pKeySemantics->_fCombinedClasses = TRUE;
    }

    //
    // First, see if we're even in the correct hive -- we can check
    // certain characters in the path to avoid doing extra string compares
    //
    switch (pNameInfo->Name[REG_CLASSES_FIRST_DISTINCT_ICH])
    {
    case L'M':
    case L'm':
        //
        // check if we're in the machine hive
        //
        NameInfo.Length = REG_MACHINE_CLASSES_HIVE_NAMELEN;

        //
        // Compare prefix with the name for the machine classes key
        // Set machine flag if comparison returns equality.
        //
        if (RtlEqualUnicodeString(
                &NameInfo,
                &gMachineClassesName,
                TRUE) != 0) {

            NameInfo.Length = cbName;
            ichClassesKeyNameEnd = REG_MACHINE_CLASSES_HIVE_NAMECCH;

            pKeySemantics->_fMachine = TRUE;

            break;
        }

        return STATUS_SUCCESS;

    case L'U':
    case L'u':
        //
        // check if we're in the users hive
        //
        {
            //
            // This will try to find the user prefix -- it fails
            // if we're not in the user hive and returns a zero-length
            // prefix. Set the flag if it succeeds.
            //
            ichClassesKeyNameEnd = BaseRegGetUserPrefixLength(
                &NameInfo);

            if (!ichClassesKeyNameEnd) {
                return STATUS_SUCCESS;
            }

            pKeySemantics->_fUser = TRUE;

            break;
        }

        //
        // this isn't a class registration because it isn't in any of the
        // correct trees
        //
        return STATUS_SUCCESS;

    default:

        //
        // the appropriate characters weren't in the key name, so
        // this can't be a class registration
        //
        return STATUS_SUCCESS;
    }

    //
    // At this point, we've found the prefix. The next part of the key
    // is the special key -- we look for that now.
    //
    pKeySemantics->_cbPrefixLen = ichClassesKeyNameEnd * REG_CHAR_SIZE;
    pKeySemantics->_ichKeyStart = ichClassesKeyNameEnd;

    //
    // the start of the special key
    // is the character right after the end of the prefix
    //
    if (pKeySemantics->_cbPrefixLen < pNameInfo->NameLength) {
        pKeySemantics->_ichKeyStart++;
    }

    //
    // search for a special subkey of the classes hive --
    // this will return the index in the full path of the end
    // of the special key name.
    //
    ichSpecialKeyNameEnd = BaseRegCchSpecialKeyLen(
        &NameInfo,
        ichClassesKeyNameEnd,
        pKeySemantics);

    //
    // if we find that the entire key is a special key, we're done --
    // there's nothing after it in this case so there's no more to
    // parse
    //
    if (pKeySemantics->_fClassRegParent) {
        return STATUS_SUCCESS;
    }

    //
    // at this point, we know the key itself is a class registration
    //
    pKeySemantics->_fClassRegistration = TRUE;

    pKeySemantics->_cbClassRegKey = (USHORT) pNameInfo->NameLength -
        (pKeySemantics->_cbPrefixLen + pKeySemantics->_cbSpecialKey + REG_CHAR_SIZE);

    return STATUS_SUCCESS;
}


void BaseRegReleaseKeySemantics(SKeySemantics* pKeySemantics)
/*++
Routine Description:

    This function frees resources associated with an SKeySemantics object

Arguments:

    pKeySemantics - pointer to SKeySemantics object whose resources should
        be freed

Return Value:

    None

--*/
{
    if (pKeySemantics->_fAllocedNameBuf) {
        RegClassHeapFree(pKeySemantics->_pFullPath);
    }
}



NTSTATUS BaseRegOpenClassKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
/*++
Routine Description:

    This function is used to retry opening a class registration key.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.

    lpSubKey - Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    dwOptions -- reserved.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully opened, otherwise it
        returns an NTSTATUS error code

    Note:

    The key must be a class registration key in order to be opened

--*/
{
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE];
    SKeySemantics       keyinfo;
    NTSTATUS            Status;

    //
    // Set up the buffer that will hold the name of the key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
    keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
    keyinfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, lpSubKey, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Use the information above to look in both user and machine
    // hives for the key to be opened
    //
    Status =  BaseRegOpenClassKeyFromLocation(
        &keyinfo,
        hKey,
        lpSubKey,
        samDesired,
        LOCATION_BOTH,
        phkResult);

    BaseRegReleaseKeySemantics(&keyinfo);

    return Status;
}



NTSTATUS BaseRegOpenClassKeyFromLocation(
    SKeySemantics*  pKeyInfo,
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    REGSAM          samDesired,
    DWORD           dwLocation,
    HKEY*           phkResult)
/*++
Routine Description:

    This function will try to open a class registration key that has no link
    in the combined classes hive -- it does this by attempting to open the
    class registration in the machine hive.  If it succeeds, it also creates
    a link to the key in the combined classes hive

Arguments:

    pKeyInfo -- structure supplying information about a key

    hKey -- Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.

    lpSubKey -- Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.  If NULL,
        no open key handle is returned.

    dwLocation -- set of flags that specify where to look for the key.
        If LOCATION_MACHINE is specified, the function looks in machine.
        If LOCATION_USER is specified, the function looks in user.  Both
        flags may be specified simultaneously, so that it will look in both
        places, or LOCATION_BOTH may be specified for this purpose.  If
        the function looks in both places, an existing key in the user hive
        takes precedence over one in the machine hive.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully opened, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    WCHAR*              FullPathBuf;
    USHORT              NewPathLen;
    UNICODE_STRING      ClassRegkey;
    UNICODE_STRING      ClassRegSubkey;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;
    USHORT              PrefixLen;

    //
    // Init locals
    //
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    NewPathLen = (USHORT) pKeyInfo->_pFullPath->NameLength + REG_CLASSES_SUBTREE_PADDING;

    //
    // Allocate space for the remapped key -- note that if alloca
    // fails, it throws an exception, so we don't check for NULL return value
    //
    FullPathBuf = (WCHAR*) RegClassHeapAlloc(NewPathLen);

    if (!FullPathBuf) {
        return STATUS_NO_MEMORY;
    }

    //
    // Set up a unicode string to use this buffer
    //
    ClassRegkey.MaximumLength = NewPathLen;
    ClassRegkey.Buffer = FullPathBuf;

    ASSERT((dwLocation == LOCATION_USER) || (dwLocation == LOCATION_MACHINE) ||
           (dwLocation == LOCATION_BOTH));

    //
    // Opening the entire key is a two step process.  First, open
    // the class registration portion -- we need to do that from
    // either the machine or user location.  The second step
    // is to open everything after the class registration using the
    // key obtained in the first step.
    //

    //
    // Below we try to find a user or machine version of the
    // class registration
    //

    if ( LOCATION_USER & dwLocation ) {
        //
        // Try the user location -- first, move the key name to
        // the user hive's namespace
        //
        if( pKeyInfo->_fUser ) {
            //
            // in the user's hive we can try a relative open
            //
            InitializeObjectAttributes(
                &Obja,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey, // relative path
                NULL);
        } else {
            //
            // we need to do an absolute path open
            //
            Status = BaseRegTranslateToUserClassKey(
                pKeyInfo,
                &ClassRegkey,
                &PrefixLen);

            if (!NT_SUCCESS(Status)) {
                goto cleanup;
            }

            //
            // now try opening the key with the new HKCU string
            //
            InitializeObjectAttributes(
                &Obja,
                &ClassRegkey,
                OBJ_CASE_INSENSITIVE,
                NULL, // using absolute path, no hkey
                NULL);
        }

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);
    }

    //
    // Only try machine if we failed to open user key above
    // (or didn't even try to open it)
    //
    if ((LOCATION_MACHINE & dwLocation) && !NT_SUCCESS(Status)) {

        //
        // Now try HKLM -- translate the key to the machine
        // namespace
        //
        if( pKeyInfo->_fMachine ) {
            //
            // in the machine hive we can try a relative open
            //
            InitializeObjectAttributes(
                &Obja,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey, // relative path
                NULL);
        } else {
            //
            // we need to do an absolute path open
            //
            Status = BaseRegTranslateToMachineClassKey(
                pKeyInfo,
                &ClassRegkey,
                &PrefixLen);

            if (!NT_SUCCESS(Status)) {
                goto cleanup;
            }

            //
            // now try opening the key with the new HKLM string
            //
            InitializeObjectAttributes(
                &Obja,
                &ClassRegkey,
                OBJ_CASE_INSENSITIVE,
                NULL, // using absolute path, no hkey
                NULL);
        }

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }
    }

    //
    // mark this key as a class key from HKCR
    //
    if (NT_SUCCESS(Status)) {
        *phkResult = REG_CLASS_SET_SPECIAL_KEY(*phkResult);
    }

cleanup:

    RegClassHeapFree(FullPathBuf);

    return Status;
}



NTSTATUS BaseRegConstructUserClassPrefix(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassPrefix)
/*++
Routine Description:

    This function creates a prefix for a class key that is in the user hive

Arguments:

    pKeyInfo         - pointer to struct containing key semantic information
    pUserClassPrefix - out param for the constructed prefix

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING UserKey;
    NTSTATUS       Status;

    //
    // The prefix looks like <sid>_Classes
    //

    //
    // First obtain the sid
    //
    if (pKeyInfo->_fUser) {

        UNICODE_STRING SidString;

        //
        // construct a string that contains the user's sid
        //
        KeySemanticsGetSid(pKeyInfo, &SidString);

        RtlInitUnicodeString(&UserKey, REG_USER_HIVE_NAME);

        //
        // create a string that starts with the HKU prefix
        //
        RtlCopyUnicodeString(pUserClassPrefix, &UserKey);

        //
        // append the sid to the user prefix
        //
        Status = RtlAppendUnicodeStringToString(pUserClassPrefix, &SidString);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        UNICODE_STRING          UsersHive;

        //
        // This will only happen if a special key has been deleted from
        // the user hive
        //
        Status = RtlFormatCurrentUserKeyPath( &UsersHive );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RtlCopyUnicodeString(pUserClassPrefix, &UsersHive );

        RtlFreeUnicodeString(&UsersHive);
    }

    //
    // Append the suffix to the sid
    //
    return RtlAppendUnicodeToString(pUserClassPrefix, REG_USER_HIVE_CLASSES_SUFFIX);
}


NTSTATUS BaseRegTranslateToMachineClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pMachineClassKey,
    USHORT*         pPrefixLen)
/*++
Routine Description:

    This function translates a class key rooted in HKCR to the machine hive

Arguments:

    pKeyInfo - pointer to struct containing key semantic information -- the
    pMachineClassKey - out param for result of translation
    pPrefixLen - out param for length of the prefix of the resulting translation

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING MachineKey;
    UNICODE_STRING ClassSubkey;

    RtlInitUnicodeString(&MachineKey, REG_MACHINE_CLASSES_HIVE_NAME);

    //
    // get the unique class key portion
    //
    KeySemanticsRemovePrefix(pKeyInfo, &ClassSubkey, REMOVEPREFIX_KEEP_INITIAL_PATHSEP);

    //
    // create a string that starts with the HKLM prefix and has the
    // desired class registration key as a subkey
    //
    RtlCopyUnicodeString(pMachineClassKey, &MachineKey);

    *pPrefixLen = REG_MACHINE_CLASSES_HIVE_NAMELEN;

    return RtlAppendUnicodeStringToString(pMachineClassKey, &ClassSubkey);
}


NTSTATUS BaseRegTranslateToUserClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassKey,
    USHORT*         pPrefixLen)
/*++
Routine Description:

    This function translates a class key rooted in HKCR to the user hive

Arguments:

    pKeyInfo - pointer to struct containing key semantic information -- the
    pUserClassKey - out param for result of translation
    pPrefixLen - out param for length of the prefix of the resulting translation

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING ClassSubkey;
    NTSTATUS       Status;

    //
    // get the unique class key portion
    //
    KeySemanticsRemovePrefix(pKeyInfo, &ClassSubkey, REMOVEPREFIX_KEEP_INITIAL_PATHSEP);

    if (!NT_SUCCESS(Status = BaseRegConstructUserClassPrefix(
        pKeyInfo,
        pUserClassKey))) {
        return Status;
    }

    *pPrefixLen = pUserClassKey->Length;

    //
    // finally, append the class key
    //
    return RtlAppendUnicodeStringToString(pUserClassKey, &ClassSubkey);
}



USHORT BaseRegGetUserPrefixLength(PUNICODE_STRING pFullPath)
/*++
Routine Description:

    This function is used to determine the length of the prefix
    \\Registry\\User\\<Sid>\\Software\Classes or \\Registry\\User\\\<Sid>_classes

Arguments:

    pFullPath          - full path of the registry, rooted at \\Registry

Return Value:

    Returns the length of the prefix (which must be nonzero), 0 if unsuccessful

--*/
{
    UNICODE_STRING UserHive;
    UNICODE_STRING FullPath;
    USHORT         ich;
    USHORT         ichMax;

    FullPath = *pFullPath;

    //
    // set ourselves up to look for the user hive portion
    // of the prefix
    //
    RtlInitUnicodeString(&UserHive, REG_USER_HIVE_NAME);

    if (FullPath.Length <= UserHive.Length) {
        return 0;
    }

    FullPath.Length = UserHive.Length;

    //
    // check for the user hive prefix, leave if not found
    //
    if (!RtlEqualUnicodeString(&UserHive, &FullPath, TRUE)) {
        return 0;
    }

    ichMax = pFullPath->Length / REG_CHAR_SIZE;

    //
    // before looking for the classes subtree, we must skip past
    // the user's sid -- the prefix is in the form
    // \\Registry\\User\\<sid>\\Software\\Classes or
    // \\Registry\\User\\<sid>_Classes
    //
    for (ich = REG_USER_HIVE_NAMECCH + 1; ich < ichMax; ich++)
    {
        //
        // if we find a pathsep, we cannot be in the combined
        // classes hive or the user classes hive
        //
        if (pFullPath->Buffer[ich] == L'\\') {
            return 0;
        }

        //
        // if we find the underscore character, we are in the combined
        // classes hive or the user classes hive -- i.e. the prefix looks like
        // \\Registry\\User\\<sid>_Classes
        // -- use the underscore to distinguish from other cases
        //
        if (pFullPath->Buffer[ich] == L'_') {

            UNICODE_STRING Suffix;

            RtlInitUnicodeString(&Suffix, REG_USER_HIVE_CLASSES_SUFFIX);

            FullPath.Length = Suffix.Length;
            FullPath.Buffer = &(pFullPath->Buffer[ich]);

            // look for the user classes suffix in the user hive
            if (RtlEqualUnicodeString(&FullPath, &Suffix, TRUE)) {

                return ich + REG_USER_HIVE_CLASSES_SUFFIXCCH;
            }

            return 0;
        }
    }

    return 0;
}



USHORT BaseRegCchSpecialKeyLen(
    PUNICODE_STRING pFullPath,
    USHORT          ichSpecialKeyStart,
    SKeySemantics*  pKeySemantics)
/*++
Routine Description:

    This function is used to determine the length of a special subkey contained
    on the pSpecialKey parameter.  If the entire pFullPath is a special key,
    a flag in pKeySemantics will be set to TRUE

Arguments:

    pFullPath          - full path of the registry, rooted at \\Registry
    ichSpecialKeyStart - index in the full path of the start of the special key path
    pKeySemantics      - pointer to structure which stores semantics information about a key

Return Value:

    Returns the length of the special key if there is a special key in the pSpecialKey
        path, 0 if there is none

    Notes:

    This function depends on the gSpecialSubtree array being a *sorted* list of special
        key names.

--*/
{
    WCHAR* wszSpecialKey;
    USHORT ichSpecialKeyLen;

    ASSERT(pFullPath->Length / REG_CHAR_SIZE >= ichSpecialKeyStart);

    //
    // For hkcr itself, there is no ancestor -- detect this special
    // case and return
    //
    if (pFullPath->Length / REG_CHAR_SIZE == ichSpecialKeyStart) {
        pKeySemantics->_fClassRegParent = TRUE;
        return ichSpecialKeyStart;
    }

    //
    // The special key is now just the parent of this key -- find
    // the immediate ancestor of this key
    //
    wszSpecialKey = wcsrchr(&(pFullPath->Buffer[ichSpecialKeyStart]), L'\\');

    ASSERT(wszSpecialKey);

    //
    // The length of the special key is the difference
    // between the '\' at the end of the special key and the start
    // of the string
    //
    ichSpecialKeyLen = (USHORT)(wszSpecialKey - pFullPath->Buffer);

    //
    // Store the length of the special key name by itself as well
    //
    pKeySemantics->_cbSpecialKey = ichSpecialKeyLen - ichSpecialKeyStart;

    return ichSpecialKeyLen;
}


NTSTATUS BaseRegOpenClassKeyRoot(
    SKeySemantics*  pKeyInfo,
    PHKEY           phkClassRoot,
    PUNICODE_STRING pClassKeyPath,
    BOOL            fMachine)
/*++
Routine Description:

    This function will try to open the class root key appropriate to
    a given key being opened from HKEY_CLASSES_ROOT. The key opened is either
    HKEY_USERS\<Sid>_Classes or HKLM\Software\Classes. If the key exists
    in the user portion, then that the user key will be opened.  Otherwise,
    the machine key is returned. It also returns the unicode string
    subkey name used to open the key specified in
    pKeyInfo relative to the class root key returned in phkClassRoot.

Arguments:

    pKeyInfo -- structure supplying information about a key

    phkClassRoot -- out param for the class root key result of the function

    pClassKeyPath -- Supplies the downward key path to the key to open.
        pClassKeyPath is always relative to the key specified by hKey.

    pfMachine -- out param flag that indicates that whether or not
        this key was opened in the machine hive.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    NTSTATUS        Status;
    USHORT          PrefixLen;
    UNICODE_STRING  NewFullPath;
    PVOID           Buffer = NULL;

    Buffer = RtlAllocateHeap( RtlProcessHeap( ), 0,pClassKeyPath->MaximumLength);
    if( Buffer == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    NewFullPath.Buffer = Buffer;
    NewFullPath.MaximumLength = pClassKeyPath->MaximumLength;

    //
    // Translate to appropriate location
    //
    if (fMachine) {

        Status = BaseRegTranslateToMachineClassKey(
            pKeyInfo,
            &NewFullPath,
            &PrefixLen);
    } else {

        Status = BaseRegTranslateToUserClassKey(
            pKeyInfo,
            &NewFullPath,
            &PrefixLen);
    }

    if (!NT_SUCCESS(Status)) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
        return Status;
    }

    //
    // Open the prefix
    //
    {
        UNICODE_STRING RootKey;
        OBJECT_ATTRIBUTES Obja;

        RootKey.Buffer = NewFullPath.Buffer;

        //
        // Calculate the length of the prefix
        //
        RootKey.Length = PrefixLen;

        //
        // now, get ready to open it
        //
        InitializeObjectAttributes(&Obja,
                                   &RootKey,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL, // full path, no hkey
                                   NULL);

        Status =  NtOpenKey(
            phkClassRoot,
            MAXIMUM_ALLOWED,
            &Obja);
    }

    if (NT_SUCCESS(Status)) {

        //
        // Skip past the prefix
        //
        NewFullPath.Buffer += (PrefixLen / REG_CHAR_SIZE);
        NewFullPath.Length -= PrefixLen;

        if (L'\\' == NewFullPath.Buffer[0]) {
            NewFullPath.Length -= REG_CHAR_SIZE;
            NewFullPath.Buffer ++;
        }

        //
        // Copy everything after the prefix
        //
        RtlCopyUnicodeString(pClassKeyPath, &NewFullPath);
    }

    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    return Status;
}


NTSTATUS
BaseRegMapClassRegistrationKey(
    HKEY              hKey,
    PUNICODE_STRING   pSubKey,
    SKeySemantics*    pKeyInfo,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied,
    PHKEY             phkDestResult,
    PUNICODE_STRING*  ppSubKeyResult)
/*++
Routine Description:

    This function will map a key from HKEY_CLASSES_ROOT into either the
    user hive or machine hive.  The remapped key is returned in the
    (*phkDestResult, *ppSubKeyResult) pair.

Arguments:

    hKey    -- root of key to remap

    pSubKey -- Supplies the downward key path to the key to remap.
        pSubKey is always relative to the key specified by hKey.

    pKeyInfo -- structure supplying information about a key

    pDestSubKey -- unicode string in which to store result data
        if the key gets remapped

    pfRetryOnAccessDenied -- out param flag to set indicating whether
        failure to open the remapped key because of access denied should
        be retried

    phkDestResult -- out param for root of remapped key

    ppSubKeyResult -- out param for remainder of path of remapped key

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    BOOL           fMachine;
    UNICODE_STRING ClassKeyPath;
    NTSTATUS       Status;
    HKEY           hkUser;

    //
    // by default, use machine
    //
    fMachine = TRUE;


    //
    // Check for existence of the key in the
    // user hive
    //
    Status =  BaseRegOpenClassKeyFromLocation(
        pKeyInfo,
        hKey,
        pSubKey,
        MAXIMUM_ALLOWED,
        LOCATION_USER,
        &hkUser);

    if (!NT_SUCCESS(Status)) {

        //
        // a not found error is fine -- this just means that
        // neither key exists already -- in this case we
        // choose to use machine
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
            return Status;
        }

    } else {

        //
        // The user key exists, we choose it over
        // the machine key
        //
        fMachine = FALSE;

        NtClose(hkUser);
    }

    //
    // Get a buffer for the new path
    //
    ClassKeyPath.Buffer = (WCHAR*) RegClassHeapAlloc(
        ClassKeyPath.MaximumLength = ((USHORT) pKeyInfo->_pFullPath->NameLength +
        REG_CLASSES_SUBTREE_PADDING));

    if (!(ClassKeyPath.Buffer)) {
        return STATUS_NO_MEMORY;
    }

    //
    // Remap the key
    //
    Status = BaseRegOpenClassKeyRoot(
        pKeyInfo,
        phkDestResult,
        &ClassKeyPath,
        fMachine);

    if (!NT_SUCCESS(Status)) {

        RegClassHeapFree(ClassKeyPath.Buffer);

        return Status;
    }

    //
    // If the remapped key is in the machine hive, set the flag so that
    // retries are not permitted.
    //
    if (*pfRetryOnAccessDenied && !fMachine) {
        *pfRetryOnAccessDenied = FALSE;
    }

    //
    // phkDestResult, the root portion of the remapped key, was set above.
    // now set the subkey portion and leave
    //
    *pDestSubKey = ClassKeyPath;
    *ppSubKeyResult = pDestSubKey;

    return STATUS_SUCCESS;
}


NTSTATUS BaseRegGetUserAndMachineClass(
    SKeySemantics* pKeySemantics,
    HKEY           hKey,
    REGSAM         samDesired,
    PHKEY          phkMachine,
    PHKEY          phkUser)
/*++
Routine Description:

    This function will return kernel objects corresponding to the user
    and machine components of a given kernel object.

Arguments:

    pKeySemantics -- supplies information about hKey.  This is optional --
        if the caller does not supply it, the function will query for the information.
        This is an optimization for callers that already have this info
        and can save us the time of

    hKey -- key for which to open user and machine versions

    samDesired -- security access mask for one of the returned keys -- see
        note below for important info on this

    phkMachine -- out param for machine version of key

    phkUser -- out param for user version of key

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

Notes:

***VERY IMPORTANT!!!***

    One of the two returned keys will alias hKey -- this way we only open
    one object (one trip to the kernel) instead of two.  This means that the caller
    should not blindly call NtClose on the two returned objects -- a == comparison
    between one of the keys and hKey should be made to determine if it that key is
    the alias -- if it is, you should *NOT* call NtClose on it because otherwise the
    owner of hKey will call NtClose on the same handle value after your call to close
    that handle which will cause an exception.  You *should* close the handle that does not
    alias hKey -- if you don't you'll get a handle leak.

    Another important note -- only the new key (non-aliased) will have the access mask
    specified in samDesired -- the aliased key is just hKey, so it has the same access
    mask.  If you want to ensure the correct access on that key, you'll need to explicitly
    duplicate or open that key with the correct access.

--*/
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    SKeySemantics* pKeyInfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    DWORD          dwLocation;
    PHKEY          phkNew;

    //
    // Clear out parameters
    //
    *phkMachine = NULL;
    *phkUser = NULL;

    //
    // Try to use caller supplied key information
    //
    if (pKeySemantics) {
        pKeyInfo = pKeySemantics;
    } else {

        //
        // Set buffer to store info about this key
        //
        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
        keyinfo._cbFullPath = sizeof(rgNameBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // get information about this key
        //
        Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        pKeyInfo = &keyinfo;
    }

    if (pKeyInfo->_fMachine) {

        *phkMachine = hKey;
        dwLocation = LOCATION_USER;
        phkNew = phkUser;

    } else {

        *phkUser = hKey;
        dwLocation = LOCATION_MACHINE;
        phkNew = phkMachine;

    }

    (void) BaseRegOpenClassKeyFromLocation(
        pKeyInfo,
        hKey,
        &EmptyString,
        (samDesired & KEY_WOW64_RES) | MAXIMUM_ALLOWED,
        dwLocation,
        phkNew);

    if (!pKeySemantics) {
        BaseRegReleaseKeySemantics(&keyinfo);
    }

    return STATUS_SUCCESS;
}


NTSTATUS GetFixedKeyInfo(
    HKEY     hkUser,
    HKEY     hkMachine,
    LPDWORD  pdwUserValues,
    LPDWORD  pdwMachineValues,
    LPDWORD  pdwUserMaxDataLen,
    LPDWORD  pdwMachineMaxDataLen,
    LPDWORD  pdwMaxValueNameLen)
{

    NTSTATUS                Status;
    DWORD                   cUserValues;
    DWORD                   cMachineValues;
    KEY_CACHED_INFORMATION  KeyInfo;
    DWORD                   dwRead;
    DWORD                   cbMaxNameLen;
    DWORD                   cbUserMaxDataLen;
    DWORD                   cbMachineMaxDataLen;

    //
    // Init locals
    //
    cUserValues = 0;
    cMachineValues = 0;
    cbMaxNameLen = 0;
    cbUserMaxDataLen = 0;
    cbMachineMaxDataLen = 0;

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Init out params
    //
    if (pdwUserValues) {
        *pdwUserValues = 0;
    }

    if (pdwMachineValues) {
        *pdwMachineValues = 0;
    }

    if (pdwMaxValueNameLen) {
        *pdwMaxValueNameLen = 0;
    }

    if (pdwUserMaxDataLen) {
        *pdwUserMaxDataLen = 0;
    }

    if (pdwMachineMaxDataLen) {
        *pdwMachineMaxDataLen = 0;
    }

    //
    // Get user information
    //
    if (hkUser) {

        Status = NtQueryKey(
            hkUser,
            KeyCachedInformation,
            &KeyInfo,
            sizeof(KeyInfo),
            &dwRead);

        //
        // KEY_CACHED_INFORMATION is a fixed struct !!!
        //
        ASSERT( Status != STATUS_BUFFER_OVERFLOW);
        //if (STATUS_BUFFER_OVERFLOW == Status) {
        //  Status = STATUS_SUCCESS;
        //}

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        cUserValues = KeyInfo.Values;
        cbMaxNameLen = KeyInfo.MaxValueNameLen;
        cbUserMaxDataLen = KeyInfo.MaxValueDataLen;
    }

    //
    // Get machine information
    //
    if (hkMachine) {

        Status = NtQueryKey(
            hkMachine,
            KeyCachedInformation,
            &KeyInfo,
            sizeof(KeyInfo),
            &dwRead);

        //
        // KEY_CACHED_INFORMATION is a fixed struct !!!
        //
        ASSERT( Status != STATUS_BUFFER_OVERFLOW);
        //if (STATUS_BUFFER_OVERFLOW == Status) {
        //  Status = STATUS_SUCCESS;
        //}

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        cMachineValues = KeyInfo.Values;
        cbMachineMaxDataLen = KeyInfo.MaxValueDataLen;

        if (KeyInfo.MaxValueNameLen > cbMaxNameLen) {
            cbMaxNameLen = KeyInfo.MaxValueNameLen;
        }
    }

    if (pdwUserValues) {
        *pdwUserValues = cUserValues;
    }

    if (pdwMachineValues) {
        *pdwMachineValues = cMachineValues;
    }

    if (pdwMaxValueNameLen) {
        *pdwMaxValueNameLen = cbMaxNameLen;
    }

    if (pdwUserMaxDataLen) {
        *pdwUserMaxDataLen = cbUserMaxDataLen;
    }

    if (pdwMachineMaxDataLen) {
        *pdwMachineMaxDataLen = cbMachineMaxDataLen;
    }

    return Status;
}


//#ifdef CLASSES_RETRY_ON_ACCESS_DENIED


NTSTATUS
BaseRegMapClassOnAccessDenied(
    SKeySemantics*    pKeySemantics,
    PHKEY             phkDest,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied)
/*++
Routine Description:

    This function will remap a key to the user hive when an access denied
    error is encountered creating it in the machine hive

Arguments:

    pKeySemantics -- structure supplying information about a key

    phkDest -- out param for root of remapped key

    pDestSubKey -- out param for remainder of path of remapped key

    pfRetryOnAccessDenied -- in / out param.  If true, we can
      remap it.  On return this value indicates whether or not
      we can do another retry

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    NTSTATUS Status;
    UNICODE_STRING NewFullPath;

    Status = STATUS_ACCESS_DENIED;
    NewFullPath.Buffer=NULL;

    if (pKeySemantics->_fCombinedClasses &&
        *pfRetryOnAccessDenied) {

        USHORT         PrefixLen;

        //
        // Close the original key -- we don't need it anymore.
        //
        if(*phkDest) {
            NtClose(*phkDest);
            *phkDest = NULL;
        }


        //
        // No more retries permitted for this key
        //
        *pfRetryOnAccessDenied = FALSE;

        //
        // Get space for the new path -- we will free this below.
        // We avoid using alloca because of stack overflows
        //
        NewFullPath.MaximumLength = (USHORT)(pKeySemantics->_pFullPath->NameLength) + REG_CLASSES_SUBTREE_PADDING;

        NewFullPath.Buffer = RegClassHeapAlloc(NewFullPath.MaximumLength);

        if (!(NewFullPath.Buffer)) {
            return STATUS_NO_MEMORY;
        }

        //
        // Translate this key to the user hive
        //
        Status = BaseRegTranslateToUserClassKey(
            pKeySemantics,
            &NewFullPath,
            &PrefixLen);

        if (NT_SUCCESS(Status)) {

            UNICODE_STRING    Prefix;
            OBJECT_ATTRIBUTES Obja;

            //
            // Allocate space for the new key name to give back to the caller
            //
            pDestSubKey->MaximumLength = NewFullPath.MaximumLength - PrefixLen + REG_CHAR_SIZE;
            pDestSubKey->Buffer = (WCHAR*) RegClassHeapAlloc(pDestSubKey->MaximumLength);

            if (!(pDestSubKey->Buffer)) {
                Status = STATUS_NO_MEMORY;
                goto cleanup;
            }

            //
            // Make a string which strips off every thing after the prefix --
            // we will open up to the prefix
            //
            Prefix.Buffer = NewFullPath.Buffer;
            Prefix.Length = PrefixLen;

            //
            // Move our full path past the prefix
            //
            NewFullPath.Buffer += (PrefixLen + REG_CHAR_SIZE) / REG_CHAR_SIZE;
            NewFullPath.Length -= (PrefixLen + REG_CHAR_SIZE);
            //
            // Copy everything after the prefix to the subkey path
            // that we're returning to the caller
            //
            RtlCopyUnicodeString(pDestSubKey, &NewFullPath);

            //
            //Get the original pointer back so we could free it!
            //
            NewFullPath.Buffer -= (PrefixLen + REG_CHAR_SIZE) / REG_CHAR_SIZE;
            NewFullPath.Length += (PrefixLen + REG_CHAR_SIZE);
            //
            // Now open the root for the caller
            //
            InitializeObjectAttributes(&Obja,
                                       &Prefix,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL, // full path, no hkey
                                       NULL);

            Status = NtOpenKey(
                phkDest,
                MAXIMUM_ALLOWED,
                &Obja);

            if(!NT_SUCCESS(Status)) {
                RegClassHeapFree(pDestSubKey->Buffer);
                pDestSubKey->Buffer=NULL;
            }
        }
    }

cleanup:

    //
    // Free the buffer we allocated above
    //
    if(NewFullPath.Buffer) {
        RegClassHeapFree(NewFullPath.Buffer);
    }

    return Status;
}

//#endif // CLASSES_RETRY_ON_ACCESS_DENIED

NTSTATUS
CreateMultipartUserClassKey(
    IN HKEY hKey,
    OUT PHKEY phkResult)
/*++

Routine Description:

    This function creates HKCU\Software\Classes\... subkey
    corresponding to given HKLM\Software\Classes\... subkey

Arguments:

    IN HKEY hKey - handle of HKLM\Software\Classes\... subkey
    OUT PHKEY phkResult - handle of HKCU\Software\Classes\... subkey

Return Value:

    Returns STATUS_SUCCESS on success, other NTSTATUS if failed.

--*/
{
    LPWSTR            KeyBuffer;
    ULONG             NumberOfSubKeys;
    LPWSTR            p;
    ULONG             i;
    LPWSTR            Token;
    UNICODE_STRING    KeyName;
    HANDLE            TempHandle1;
    HANDLE            TempHandle2;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;

    ////////////////////////////////////////////////////////////////////////////
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE];
    SKeySemantics       keyinfo;
    UNICODE_STRING      EmptyString= {0, 0, 0};
    HKEY                hkDestKey=NULL;
    UNICODE_STRING      DestSubkey;
    BOOL                fRetryOnAccessDenied=TRUE;
    //
    // Set up the buffer that will hold the name of the key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
    keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
    keyinfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    DestSubkey.Buffer=NULL;

    //
    //Remap key to the user hive.
    //
    Status = BaseRegMapClassOnAccessDenied(
                &keyinfo,
                &hkDestKey,
                &DestSubkey,
                &fRetryOnAccessDenied);

    BaseRegReleaseKeySemantics(&keyinfo);

    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    //If we've opened new hkDestKey we must close it.
    //
    if( hkDestKey != hKey ) {
        TempHandle1 = hkDestKey;
    } else {
        TempHandle1 = NULL;
    }

    //
    // Initialize the buffer to be tokenized.
    //

    KeyBuffer = DestSubkey.Buffer;

    //
    //  Find out the number of subkeys to be created
    //
    NumberOfSubKeys = 1;
    p = KeyBuffer;
    while ( ( p = wcschr( p, ( WCHAR )'\\' ) ) != NULL ) {
        p++;
        NumberOfSubKeys++;
    }

    for( i = 0, Token = KeyBuffer; i < NumberOfSubKeys; i++ ) {

        ASSERT(Token != NULL);

        if( ( *Token == ( WCHAR )'\\' ) &&
            ( i != NumberOfSubKeys - 1 ) ) {
            //
            //  If the first character of the key name is '\', and the key
            //  is not the last to be created, then ignore this key name.
            //  This condition can happen if the key name contains
            //  consecutive '\'.
            //  This behavior is consistent with the one we had in the past
            //  when the API used wcstok() to get the key names.
            //  Note that if the key name is an empty string, we return a handle
            //  that is different than hKey, even though both point to the same
            //  key. This is by design.
            //
            Token++;
            continue;
        }

        //
        // Convert the token to a counted Unicode string.
        //
        KeyName.Buffer = Token;
        if (i == NumberOfSubKeys - 1) {
            KeyName.Length = wcslen(Token)*sizeof(WCHAR);
        } else {
            KeyName.Length = (USHORT)(wcschr(Token, ( WCHAR )'\\') - Token)*sizeof(WCHAR);
        }

        //
        // Remember the intermediate handle (NULL the first time through).
        //

        TempHandle2 = TempHandle1;

        //
        // Initialize the OBJECT_ATTRIBUTES structure, close the
        // intermediate key and create or open the key.
        //

        InitializeObjectAttributes(
                &Obja,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                hkDestKey,
                NULL
                );

        Status = NtCreateKey(
                &TempHandle1,
                MAXIMUM_ALLOWED,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

        //
        // Initialize the next object directory (i.e. parent key) handle.
        //

        hkDestKey = TempHandle1;

        //
        // Close the intermediate key.
        // This fails the first time through the loop since the
        // handle is NULL.
        //

        if( TempHandle2 != NULL ) {
            NtClose( TempHandle2 );
        }

        //
        // If creating the key failed, return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            break;
        }

        Token = wcschr( Token, ( WCHAR )'\\') + 1;

    }

    if(DestSubkey.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, DestSubkey.Buffer);
    }

    //
    // Only set the return value once we know we've
    // succeeded.
    //
    if( NT_SUCCESS( Status )) {
        *phkResult = hkDestKey;
    }

    return Status;
}


#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

BOOL InitializeInstrumentedRegClassHeap()
{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(
                    &(gRegClassHeapCritSect)); 

    return NT_SUCCESS(Status);
}

BOOL CleanupInstrumentedRegClassHeap()
{
    NTSTATUS Status;

    Status = RtlDeleteCriticalSection(
                    &(gRegClassHeapCritSect));

    DbgPrint("WINREG: Instrumented memory data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: Classes Heap Maximum Allocated: 0x%x\n", gcbMaxAllocated);
    DbgPrint("WINREG: Classes Heap Maximum Outstanding Allocs: 0x%x\n", gcMaxAllocs);

    if (gcbAllocated || gcAllocs) {

        DbgPrint("WINREG: Classes Heap ERROR!\n");
        DbgPrint("WINREG: Classes Heap not completely freed!\n");
        DbgPrint("WINREG: Classes Heap Leaked 0x%x bytes\n", gcbAllocated);
        DbgPrint("WINREG: Classes Heap Outstanding Allocs: 0x%x\n", gcAllocs);

        DbgBreakPoint();
    } else {
        DbgPrint("WINREG: Classes Heap is OK.\n");
    }

    return NT_SUCCESS(Status);
}


#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

/*++

Routine Description:

    Replaces HKLM\Software\Classes\<something> path with HKCR\<something>

Arguments:

    phKey        - The pointer to the handle of the key to map
    lpSubKey    - The key that is to be opened/created/deleted


Return Value:

    If the [phKey] is in an interesting area return TRUE

    If not, or if an error occurs, return FALSE.

--*/

BOOL
ExtractClassKey(
        IN OUT HKEY *phKey,
        IN OUT PUNICODE_STRING lpSubKey)
{

#define STR_CLASSES1 L"Classes\\"
#define STR_CLASSES2 L"Software\\Classes\\"
#define STR_MACHINE1 L"\\Registry\\Machine\\Software"
#define STR_MACHINE2 L"\\Registry\\Machine"

    static const WCHAR *szCmpStr1[2]={STR_CLASSES1,STR_CLASSES2};
    static const WCHAR *szCmpStr2[2]={STR_MACHINE1,STR_MACHINE2};
    static const USHORT SizeCmpStr1[2]={sizeof(STR_CLASSES1)/sizeof(WCHAR)-2,
                                        sizeof(STR_CLASSES2)/sizeof(WCHAR)-2};
    static const USHORT SizeCmpStr2[2]={sizeof(STR_MACHINE1)/sizeof(WCHAR)-1,
                                        sizeof(STR_MACHINE2)/sizeof(WCHAR)-1};
    static const USHORT LengthCmpStr1[2]={sizeof(STR_CLASSES1)-2*sizeof(WCHAR),
                                          sizeof(STR_CLASSES2)-2*sizeof(WCHAR)};
    static const USHORT LengthCmpStr2[2]={sizeof(STR_MACHINE1)-sizeof(WCHAR),
                                          sizeof(STR_MACHINE2)-sizeof(WCHAR)};

    static const USHORT offset[2]={sizeof(STR_CLASSES1)-sizeof(WCHAR),
                                   sizeof(STR_CLASSES2)-sizeof(WCHAR)};

    static BYTE pBuff[sizeof(STR_MACHINE1)+sizeof(KEY_NAME_INFORMATION)];

    PKEY_NAME_INFORMATION    pNameInfo = (PKEY_NAME_INFORMATION)pBuff;
    ULONG ResultLength;
    NTSTATUS Status;

    int index = 0;



    //if length of the subkey name is less than "Classes" this is
    //not the key we are interested in.
    if(lpSubKey->Length < LengthCmpStr1[index]) {

        return FALSE;
    }

    //see if subkey name starts with "Classes"
    //If length of the subkey name is longer than "Classes",
    //see if we have '\\' in the right place
    //(because it could be something like "ClassesSomething").
    if(_wcsnicmp(lpSubKey->Buffer,szCmpStr1[index],SizeCmpStr1[index]) ||
        (lpSubKey->Length > LengthCmpStr1[index] &&
        lpSubKey->Buffer[SizeCmpStr1[index]] != L'\\')) {

        index = 1;

        //if length of the subkey name is less than "Software\\Classes" this is
        //not the key we are interested in.
        if(lpSubKey->Length < LengthCmpStr1[index]) {

            return FALSE;
        }

        //see if subkey name starts with "Software\\Classes"
        //If length of the subkey name is longer than "Software\\Classes",
        //see if we have '\\' in the right place
        //(because it could be something like "Software\\ClassesSomething").
        if(_wcsnicmp(lpSubKey->Buffer,szCmpStr1[index],SizeCmpStr1[index]) ||
            (lpSubKey->Length > LengthCmpStr1[index] &&
            lpSubKey->Buffer[SizeCmpStr1[index]] != L'\\')) {

            return FALSE;
        }
    }

    //Get the parent key name
    Status = NtQueryKey(
                *phKey,
                KeyNameInformation,
                pNameInfo,
                sizeof(pBuff),
                &ResultLength);

    if (!NT_SUCCESS(Status)) {

        return FALSE;
    }

    if(pNameInfo->NameLength != LengthCmpStr2[index] ||
        _wcsnicmp(pNameInfo->Name,szCmpStr2[index],SizeCmpStr2[index])) {

        return FALSE;
    }

    //Get handle to HKCR
    if( !HKEY_ClassesRoot ) {

        if( LocalOpenClassesRoot(NULL, MAXIMUM_ALLOWED, &HKEY_ClassesRoot) != ERROR_SUCCESS ) {

            return FALSE;
        }
    }


    // cut "Classes\\" or "Software\\Classes\\" from lpSubKey
    if(lpSubKey->Length <= offset[index] ) {
        //user tries to access HKLM\Software\Classes[\]"
        //we will just return him handle to HKCR.
        lpSubKey->Length = 0;

    } else {
        //move pointer after "Classes\\" or "Software\\Classes\\"
        //it will be restored by caller
        lpSubKey->Length -= offset[index];
        lpSubKey->MaximumLength -= offset[index];
        lpSubKey->Buffer += offset[index]/sizeof(WCHAR);
    }

    //replace hKey with HKCR
    *phKey = HKEY_ClassesRoot;

    return TRUE;
}

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\localreg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Localreg.h

Abstract:

    This file is used to make small changes to the Winreg Base entry
    points so that they compile as local or remote functions.

Author:

    David J. Gilman (davegi) 26-Aug-1992

Notes:

    The mapping from BaseRegNotifyChangeKeyValue to
    LocalBaseRegNotifyChangeKeyValue is missing because in the
    local case the call to NJt is made by the client.


--*/

#if defined( LOCAL )

//
// Change the 'server' enrty point names for the local functions.
//

//
// Base functions.
//

#define BaseRegDeleteKey                LocalBaseRegDeleteKey
#define BaseRegDeleteValue              LocalBaseRegDeleteValue
#define BaseRegEnumKey                  LocalBaseRegEnumKey
#define BaseRegEnumValue                LocalBaseRegEnumValue
#define BaseRegCloseKey                 LocalBaseRegCloseKey
#define BaseRegCreateKey                LocalBaseRegCreateKey
#define BaseRegFlushKey                 LocalBaseRegFlushKey
#define BaseRegOpenKey                  LocalBaseRegOpenKey
#define BaseRegLoadKey                  LocalBaseRegLoadKey
#define BaseRegUnLoadKey                LocalBaseRegUnLoadKey
#define BaseRegReplaceKey               LocalBaseRegReplaceKey
#define BaseRegQueryInfoKey             LocalBaseRegQueryInfoKey
#define BaseRegQueryValue               LocalBaseRegQueryValue
#define BaseRegGetKeySecurity           LocalBaseRegGetKeySecurity
#define BaseRegSetKeySecurity           LocalBaseRegSetKeySecurity
#define BaseRegRestoreKey               LocalBaseRegRestoreKey
#define BaseRegSaveKey                  LocalBaseRegSaveKey
#define BaseRegSaveKeyEx                LocalBaseRegSaveKeyEx
#define BaseRegSetValue                 LocalBaseRegSetValue
#define BaseRegQueryMultipleValues      LocalBaseRegQueryMultipleValues
#define BaseRegQueryMultipleValues2     LocalBaseRegQueryMultipleValues2
#define BaseRegGetVersion               LocalBaseRegGetVersion


//
// Predefined handle functions.
//

#define OpenClassesRoot                 LocalOpenClassesRoot
#define OpenCurrentUser                 LocalOpenCurrentUser
#define OpenLocalMachine                LocalOpenLocalMachine
#define OpenUsers                       LocalOpenUsers
#define OpenPerformanceData             LocalOpenPerformanceData
#define OpenPerformanceText             LocalOpenPerformanceText
#define OpenPerformanceNlsText          LocalOpenPerformanceNlsText
#define OpenCurrentConfig               LocalOpenCurrentConfig
#define OpenDynData                     LocalOpenDynData


//
// Initialization and cleanup functions.
//

#define InitializeRegCreateKey          LocalInitializeRegCreateKey
#define CleanupRegCreateKey             LocalCleanupRegCreateKey


//
// No RPC Impersonation needed in the local case.
//

#define RPC_IMPERSONATE_CLIENT( Handle ) 
#define RPC_REVERT_TO_SELF()

#define REGSEC_CHECK_HANDLE( Handle )           ( 0 )
#define REGSEC_FLAG_HANDLE( Handle, Flag )      ( Handle )
#define REGSEC_TEST_HANDLE( Handle, Flag )      ( Handle )
#define REGSEC_CLEAR_HANDLE( Handle )           ( Handle )
#define REGSEC_CHECK_REMOTE( Key )              ( 1 )
#define REGSEC_CHECK_PATH( Key, Path )          ( 1 )
#define REGSEC_CHECK_PERF( Key )                ( 1 )

#else

#include <Rpcasync.h>
//
// Impersonate the client.
//

#define RPC_IMPERSONATE_CLIENT( Handle )                                                \
    {                                                                                   \
        RPC_STATUS _rpcstatus;                                                          \
        RPC_CALL_ATTRIBUTES CallAttributes;                                             \
        memset(&CallAttributes, 0, sizeof(CallAttributes));                             \
        CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;                           \
        _rpcstatus = RpcServerInqCallAttributesW(0, &CallAttributes);                   \
        if(_rpcstatus == RPC_S_BINDING_HAS_NO_AUTH ) {                                  \
        } else if (_rpcstatus == RPC_S_OK) {                                            \
            if( CallAttributes.AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY ) {  \
                RpcRaiseException(RPC_S_ACCESS_DENIED);                                 \
            }                                                                           \
        } else {                                                                        \
            RpcRaiseException(_rpcstatus);                                              \
        }                                                                               \
        _rpcstatus = RpcImpersonateClient( NULL );                                      \
        if (_rpcstatus != ERROR_SUCCESS) {                                              \
            RpcRaiseException(_rpcstatus);                                              \
        }                                                                               \
    }

#define RPC_REVERT_TO_SELF() { RPC_STATUS _rpcstatus = RpcRevertToSelf(); }

#define CHECK_MACHINE_PATHS     0x00000001

#define REGSEC_CHECK_HANDLE( Handle )   ((LONG)(ULONG_PTR) (Handle) & CHECK_MACHINE_PATHS)
#define REGSEC_FLAG_HANDLE( Handle, Flag )    LongToHandle(HandleToLong(Handle) | Flag)
#define REGSEC_TEST_HANDLE( Handle, Flag )  ((LONG)(ULONG_PTR) (Handle) & Flag )
#define REGSEC_CLEAR_HANDLE( Handle )   LongToHandle(HandleToLong(Handle) & ~(CHECK_MACHINE_PATHS))
#define REGSEC_CHECK_REMOTE( Key )              ( RegSecCheckRemoteAccess( Key ) )
#define REGSEC_CHECK_PATH( Key, Path )          ( RegSecCheckPath( Key, Path ) )
#define REGSEC_CHECK_PERF( Key )                ( RegSecCheckRemotePerfAccess( Key ) )


#endif // LOCAL

NTSTATUS RelinkMachineKey( 
   LPWSTR lpSubDirName, 
   PUNICODE_STRING lpSubKey,
   HKEY  hKey );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regclass.h ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    regclass.h

Abstract:

    This file contains declarations needed for manipulating
    the portion of the registry that contains class registrations

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#if defined( LOCAL )

//
// Declarations
//

#define LENGTH( str )   ( sizeof( str ) - sizeof( UNICODE_NULL ))
#define INIT_SPECIALKEY(x) {LENGTH(x), LENGTH(x), x}

#define REG_CLASSES_FIRST_DISTINCT_ICH 10

#define REG_CHAR_SIZE sizeof(WCHAR)

#define REG_USER_HIVE_NAME L"\\Registry\\User"
#define REG_USER_HIVE_NAMELEN LENGTH(REG_USER_HIVE_NAME)
#define REG_USER_HIVE_NAMECCH (REG_USER_HIVE_NAMELEN / REG_CHAR_SIZE)

#define REG_USER_HIVE_CLASSES_SUFFIX L"_Classes"
#define REG_USER_HIVE_CLASSES_SUFFIXLEN LENGTH(REG_USER_HIVE_CLASSES_SUFFIX)
#define REG_USER_HIVE_CLASSES_SUFFIXCCH (REG_USER_HIVE_CLASSES_SUFFIXLEN / REG_CHAR_SIZE)

#define REG_MACHINE_CLASSES_HIVE_NAME L"\\Registry\\Machine\\Software\\Classes"
#define REG_MACHINE_CLASSES_HIVE_NAMELEN LENGTH(REG_MACHINE_CLASSES_HIVE_NAME)
#define REG_MACHINE_CLASSES_HIVE_NAMECCH (REG_MACHINE_CLASSES_HIVE_NAMELEN / REG_CHAR_SIZE)

#define REG_USER_HIVE_LINK_TREE L"\\Software\\Classes"

#define REG_CLASSES_HIVE_MIN_NAMELEN REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_USER_HIVE_NAMELEN

//
// The difference between these two paths
// \Registry\User\<sid>_Classes and
// \Registry\User\<siid>\Software\Classes
//
// plus extra for the translation from machine to user -- take into account the sid
//
#define REG_CLASSES_SUBTREE_PADDING 128

#define REG_MAX_CLASSKEY_LEN 384
#define REG_MAX_CLASSKEY_CCH (REG_MAX_CLASSKEY_LEN / REG_CHAR_SIZE)

#define REG_MAX_KEY_LEN 512
#define REG_MAX_KEY_CCH (REG_MAX_KEY_LEN / REG_CHAR_SIZE)

#define REG_MAX_KEY_PATHLEN 65535


//
// HKCR Handle Tags for Per-user Class Registration.
//
// Subkeys of HKCR up to and including a class registration parent key are tagged
// by setting two free bits in their handle value (the lower two bits of a handle
// are free to be used as tags).  This makes it easy to tell if a key is in
// HKCR and needs special treatment.  After the class registration part of a path,
// this marker is not needed since such keys do not require special treatment
// for enumeration, opening, and deletion.
//

//
// Note that for the sake of speed we are using 1 bit instead of a specific pattern of
// two bits.  Currently, bit 0 is used to mark remote handles.  Bit 2 is used in the
// server only to mark restricted keys.  Locally, we use it to mark hkcr keys.  More
// Here is a list of valid combinations -- unused bits must be 0. Invalid means that
// in the current implementation, you should never see it in that part of the registry.
//

//
//  Local                       Server                               Client (application sees these)
//  00  (non HKCR, unused)      00 (unrestricted, unused)            00 (non HKCR, local)
//  01  Invalid (HKCR, unused)  01 Invalid (unrestricted, unused)    01 (non HKCR, remote)
//  10  (HKCR, unused)          10 (restricted, unused)              10 (HKCR, local)
//  11  Invalid (HKCR, unused)  11 Invalid (restricted, unused)      11 Invalid (HKCR, remote)
//

//
//  Note that we could use either 10 or 11 to mark HKCR handles -- we chose 10 for simplicity's
//  sake since it simply involves oring in a bit. This can be changed in the future
//  if yet another bit pattern is needed. Otherwise, clients never see 11 -- they only see
//  00, 01, and 10. Note that these bits must be propagated to the local portion. This is done
//  simply by leaving the bits as-is, because local doesn't use any of the bits.  Note that
//  we would be broken if the bits needed to propagate to server for some reason, since it
//  is using bit 2 already.  We do not allow HKCR as a remote handle, however, so this is
//  not a problem.
//

#define REG_CLASS_HANDLE_MASK 0x3

#define REG_CLASS_HANDLE_VALUE 0x2
#define REG_CLASS_IS_SPECIAL_KEY( Handle )     ( (LONG) ( ( (ULONG_PTR) (Handle) ) & REG_CLASS_HANDLE_VALUE ) )
#define REG_CLASS_SET_SPECIAL_KEY( Handle )    ( (HANDLE) ( (  (ULONG_PTR) (Handle) ) | \
                                                            REG_CLASS_HANDLE_VALUE ) )

#define REG_CLASS_RESET_SPECIAL_KEY( Handle )  ( (HANDLE) ( ( ( (ULONG_PTR) (Handle) ) & ~REG_CLASS_HANDLE_MASK )))

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

extern RTL_CRITICAL_SECTION gRegClassHeapCritSect;
extern DWORD                gcbAllocated;
extern DWORD                gcAllocs;
extern DWORD                gcbMaxAllocated;
extern DWORD                gcMaxAllocs;
extern PVOID                gpvAllocs;

__inline PVOID RegClassHeapAlloc(SIZE_T cbSize)
{
    PVOID pvAllocation;

    pvAllocation = RtlAllocateHeap(RtlProcessHeap(), 0, cbSize + sizeof(SIZE_T));

    RtlEnterCriticalSection(&gRegClassHeapCritSect);

    if (pvAllocation) {
        gcbAllocated += cbSize;
        gcAllocs ++;
        (ULONG_PTR) gpvAllocs ^= (ULONG_PTR) pvAllocation;

        if (gcAllocs > gcMaxAllocs) {
            gcMaxAllocs = gcAllocs;
        }

        if (gcbAllocated > gcbMaxAllocated) {
            gcbMaxAllocated = gcbAllocated;
        }
    }

    RtlLeaveCriticalSection(&gRegClassHeapCritSect);

    *((SIZE_T*) pvAllocation) = cbSize;

    ((SIZE_T*) pvAllocation) ++;

    return pvAllocation;
}

__inline BOOLEAN RegClassHeapFree(PVOID pvAllocation)
{
    BOOLEAN bRetVal;
    SIZE_T  cbSize;

    ((SIZE_T*) pvAllocation) --;

    cbSize = *((SIZE_T*) pvAllocation);

    bRetVal = RtlFreeHeap(RtlProcessHeap(), 0, pvAllocation);

    RtlEnterCriticalSection(&gRegClassHeapCritSect);

    gcbAllocated -= cbSize;
    gcAllocs --;

    (ULONG_PTR) gpvAllocs ^= (ULONG_PTR) pvAllocation;

    RtlLeaveCriticalSection(&gRegClassHeapCritSect);

    if (!bRetVal) {
        DbgBreakPoint();
    }

    return bRetVal;
}

#else // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

#define RegClassHeapAlloc(x) RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define RegClassHeapFree(x) RtlFreeHeap(RtlProcessHeap(), 0, x)

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

enum
{
    LOCATION_MACHINE =     0x1,
    LOCATION_USER =        0x2,
    LOCATION_BOTH =        0x3
};


//
// SKeySemantics
//
// This structure is the result of parsing a registry key full path
//
// ATTENTION: This structure, along with the current parsing code, needs to
// be overhauled.  Originally, it was designed to do one thing. Now, it
// identifies several parts of keys.  The original goal was speed --
// we attempted to touch the least amount of string (memory) possible.
// As more functionality was added to the parser, this became more complex.
// A better solution would pay more attention to a generic, straightforward
// way of parsing the key -- things have become far too convoluted in
// an attempt to be fast.
//

typedef struct _SKeySemantics
{
    /* out */     unsigned _fUser              : 1;     // this key is rooted in the user hive
    /* out */     unsigned _fMachine           : 1;     // this key is rooted in the machine hive
    /* out */     unsigned _fCombinedClasses   : 1;     // this key is rooted in the combined classes hive
    /* out */     unsigned _fClassRegistration : 1;     // this key is a class registration key
    /* out */     unsigned _fClassRegParent    : 1;     // this key is a special key (parent of a class reg key)
    /* out */     unsigned _fAllocedNameBuf    : 1;     // nonzero if _pFullPath was realloc'd and needs to be freed
    /* out */     USHORT   _ichKeyStart;                // index to start of a class reg after
                                                        //     \\software\\classes in the returned full path
    /* out */     USHORT   _cbPrefixLen;                // length of prefix
    /* out */     USHORT   _cbSpecialKey;               // length of special key
    /* out */     USHORT   _cbClassRegKey;              // length of class reg key name
    /* in, out */ ULONG    _cbFullPath;                 // size of the KEY_NAME_INFORMATION passed in
    /* out */     PKEY_NAME_INFORMATION _pFullPath;     // address of an OBJECT_NAME_INFORMATION structure
} SKeySemantics;


//
// External Prototypes
//

//
// Opens the HKCR predefined handle with the combined view
//
error_status_t OpenCombinedClassesRoot(
    IN REGSAM samDesired,
    OUT HANDLE * phKey);

//
// Parses a registry key and returns results
//
NTSTATUS BaseRegGetKeySemantics(
    HKEY hkParent,
    PUNICODE_STRING pSubKey,
    SKeySemantics* pKeySemantics);
//
// Frees resources associated with an SKeySemantics structure
//
void BaseRegReleaseKeySemantics(SKeySemantics* pKeySemantics);

//
// Opens a class key that exists in either
// HKLM or HKCU
//
NTSTATUS BaseRegOpenClassKey(
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    DWORD           dwOptions,
    REGSAM          samDesired,
    PHKEY           phkResult);

//
// Opens a class key from a specified set
// of locations
//
NTSTATUS BaseRegOpenClassKeyFromLocation(
    SKeySemantics*  pKeyInfo,
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    REGSAM          samDesired,
    DWORD           dwLocation,
    HKEY*           phkResult);

//
// Returns key objects for the user and machine
// versions of a key
//
NTSTATUS BaseRegGetUserAndMachineClass(
    SKeySemantics*  pKeySemantics,
    HKEY            Key,
    REGSAM          samDesired,
    PHKEY           phkMachine,
    PHKEY           phkUser);


//
// Internal Prototypes
//

USHORT BaseRegGetUserPrefixLength(
    PUNICODE_STRING pFullPath);

USHORT BaseRegCchSpecialKeyLen(
    PUNICODE_STRING pFullPath,
    USHORT          ichSpecialKeyStart,
    SKeySemantics*  pKeySemantics);

NTSTATUS BaseRegTranslateToMachineClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pMachineClassKey,
    USHORT*         pPrefixLen);

NTSTATUS BaseRegTranslateToUserClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassKey,
    USHORT*         pPrefixLen);

NTSTATUS BaseRegOpenClassKeyRoot(
    SKeySemantics*  pKeyInfo,
    PHKEY           phkClassRoot,
    PUNICODE_STRING pClassKeyPath,
    BOOL            fMachine);

NTSTATUS BaseRegMapClassRegistrationKey(
    HKEY              hKey,
    PUNICODE_STRING   pSubKey,
    SKeySemantics*    pKeyInfo,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied,
    PHKEY             phkDestResult,
    PUNICODE_STRING*  ppSubKeyResult);

NTSTATUS BaseRegMapClassOnAccessDenied(
    SKeySemantics*    pKeySemantics,
    PHKEY             phkDest,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied);

NTSTATUS CreateMultipartUserClassKey(
    IN HKEY hKey,
    OUT PHKEY phkResult);

NTSTATUS GetFixedKeyInfo(
    HKEY     hkUser,
    HKEY     hkMachine,
    LPDWORD  pdwUserValues,
    LPDWORD  pdwMachineValues,
    LPDWORD  pdwUserMaxDataLen,
    LPDWORD  pdwMachineMaxDataLen,
    LPDWORD  pdwMaxValueNameLen);

BOOL InitializeClassesNameSpace();

extern BOOL gbCombinedClasses;


//
// Inline functions
//

enum
{
    REMOVEPREFIX_DISCARD_INITIAL_PATHSEP = 0,
    REMOVEPREFIX_KEEP_INITIAL_PATHSEP = 1
};

__inline void KeySemanticsRemovePrefix(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pDestination,
    DWORD           dwFlags)
{
    BOOL fMoveBack;

    fMoveBack = (dwFlags & REMOVEPREFIX_KEEP_INITIAL_PATHSEP) &&
        (pKeyInfo->_pFullPath->Name[pKeyInfo->_ichKeyStart]);

    pDestination->Buffer = &(pKeyInfo->_pFullPath->Name[pKeyInfo->_ichKeyStart -
                                                              (fMoveBack ? 1 : 0)]);

    pDestination->Length = (USHORT) pKeyInfo->_pFullPath->NameLength -
        ((pKeyInfo->_ichKeyStart - (fMoveBack ? 1 : 0))  * REG_CHAR_SIZE);
}

__inline void KeySemanticsGetSid(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pSidString)
{
    pSidString->Buffer = &(pKeyInfo->_pFullPath->Name[REG_USER_HIVE_NAMECCH]);

    pSidString->Length = pKeyInfo->_cbPrefixLen -
            (REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_USER_HIVE_NAMELEN);
}

__inline void KeySemanticsTruncatePrefixToClassReg(
    SKeySemantics*  pKeyInfo,
    USHORT          PrefixLen,
    PUNICODE_STRING pDestination)
{
    pDestination->Length = PrefixLen + (pKeyInfo->_fClassRegistration ? REG_CHAR_SIZE : 0) +
        pKeyInfo->_cbSpecialKey + pKeyInfo->_cbClassRegKey;
}

BOOL
ExtractClassKey(
        IN OUT HKEY *phKey,
        IN OUT PUNICODE_STRING lpSubKey);

#else // LOCAL

#define REG_CLASS_IS_SPECIAL_KEY( Handle )     0
#define REG_CLASS_SET_SPECIAL_KEY( Handle )    (Handle)
#define REG_CLASS_RESET_SPECIAL_KEY( Handle )  (Handle)

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regdkey.c ===
//depot/Lab04_N/Base/screg/winreg/server/regdkey.c#5 - integrate change 12179 (text)
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regdkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to delete a key.  That is:

        - BaseRegDeleteKey

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the Notes in Regkey.c.


--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include <malloc.h>
#ifdef LOCAL
#include "tsappcmp.h"
#include <wow64reg.h>
#endif



error_status_t
BaseRegDeleteKey(
    HKEY hKey,
    PUNICODE_STRING lpSubKey
    )

/*++

Routine Description:

    Delete a key.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.  Any of the predefined
        reserved handles or a previously opened key handle may be used for
        hKey.

    lpSubKey - Supplies the downward key path to the key to delete.  May
        NOT be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    If successful, RegDeleteKey removes the key at the desired location
    from the registration database.  The entire key, including all of its
    values, will be removed.  The key to be deleted may NOT have children,
    otherwise the call will fail.  There must not be any open handles that
    refer to the key to be deleted, otherwise the call will fail.  DELETE
    access to the key being deleted is required.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;
    NTSTATUS            StatusCheck;
    HKEY                KeyHandle;
    BOOL                fSafeToDelete;

#ifdef LOCAL
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string
#endif //LOCAL

    //
    // Check for malformed arguments from malicious clients
    //
    if( (lpSubKey == NULL) ||
        (lpSubKey->Length < sizeof(UNICODE_NULL)) ||
        (lpSubKey->Buffer == NULL) ||
        ((lpSubKey->Length % sizeof(WCHAR)) != 0) ||
        (lpSubKey->Buffer[lpSubKey->Length / sizeof(WCHAR) - 1] != L'\0') ) {
        return(ERROR_INVALID_PARAMETER);
    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );
    //
    // Impersonate the client.
    //
    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Subtract the NULL from the string length. This was added
    //  by the client so that RPC would transmit the whole thing.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

#ifdef LOCAL
    //
    // see if this key is a special key in HKCR
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        (   (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION)
         && ExtractClassKey(&hKey,lpSubKey) ) ) {

        //
        // if this is a class registration, we call a special routine
        // to open this key
        //
        Status = BaseRegOpenClassKey(
            hKey,
            lpSubKey,
            0,
            MAXIMUM_ALLOWED,
            &KeyHandle);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

    } else
#endif // LOCAL
    {
        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the sub key
        // so that it can then be deleted.
        //

        InitializeObjectAttributes(
            &Obja,
            lpSubKey,
            OBJ_CASE_INSENSITIVE,
            hKey,
            NULL
            );

        Status = NtOpenKey(
            &KeyHandle,
            DELETE,
            &Obja
            );
    }

#ifdef LOCAL
    if (gpfnTermsrvDeleteKey) {
        //
        // Remove the key from the Terminal Server registry tracking database
        //
        gpfnTermsrvDeleteKey(KeyHandle);
    }
#endif

        //
        // If for any reason the key could not be opened, return the error.
        //

    if( NT_SUCCESS( Status )) {
        //
        // Call the Nt APIs to delete and close the key.
        //

#if defined(_WIN64) & defined ( LOCAL)
        HKEY hWowKey = Wow64OpenRemappedKeyOnReflection (KeyHandle);
#endif //wow64 reflection case

        Status = NtDeleteKey( KeyHandle );
        StatusCheck = NtClose( KeyHandle );
        ASSERT( NT_SUCCESS( StatusCheck ));

#if defined(_WIN64) & defined ( LOCAL)
        if ( (NT_SUCCESS( Status )) && (hWowKey != NULL))
            Wow64RegDeleteKey (hWowKey, NULL);

        if (hWowKey != NULL)
            NtClose (hWowKey);
#endif //wow64 reflection case
        
    }

#ifdef LOCAL
cleanup:

    *lpSubKey = TmpStr;
#endif
    RPC_REVERT_TO_SELF();

    //
    // Map the NTSTATUS code to a Win32 Registry error code and return.
    //

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regdval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regdval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to delete values from keys. That is:

        - BaseRegDeleteValue

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegDeleteValue (
    HKEY hKey,
    PUNICODE_STRING lpValueName
    )

/*++

Routine Description:

    Remove the named value from the specified key.

Arguments:

    hKey - Supplies a handle to the open key.

    lpValueName - Supplies the name of the value to remove.  lpValueName
        may be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    hKey must have been opened for KEY_SET_VALUE.

--*/

{
    HKEY                            hkDelete;
    NTSTATUS                        Status;
#ifdef LOCAL

    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;

#endif //LOCAL
    //
    // Check for malformed arguments from malicious clients
    //
    if( (lpValueName == NULL) ||
        (lpValueName->Length < sizeof(UNICODE_NULL)) ||
        ((lpValueName->Length % sizeof(WCHAR)) != 0) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    hkDelete = hKey;

    //
    //  Subtract the NULL from the string length. This was added
    //  by the client so that RPC would transmit the whole thing.
    //
    lpValueName->Length -= sizeof( UNICODE_NULL );

    //
    // Call the Nt Api to delete the value, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

#ifdef LOCAL
    if (gpfnTermsrvDeleteValue) {
        //
        // Remove the value from the Terminal Server registry tracking database
        //
        gpfnTermsrvDeleteValue(hKey, lpValueName);
    }
#endif

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hkDelete,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkDelete = hkUserClasses;
    }
#endif

    Status = NtDeleteValueKey(
        hkDelete,
        lpValueName
        );

#ifdef LOCAL
    
    //
    // For class keys, try again with machine if there were
    // two keys of the same name
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        if ((STATUS_OBJECT_NAME_NOT_FOUND == Status) && 
            (hkUserClasses && hkMachineClasses)) {

            Status = NtDeleteValueKey(
                hkMachineClasses,
                lpValueName
                );
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }
#endif // LOCAL

    return (error_status_t)RtlNtStatusToDosError(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regecls.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regecls.h

Abstract:

    This file contains declarations for data structures
    needed for enumerating keys under HKEY_CLASSES_ROOT

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#if !defined(_REGECLS_H_)
#define _REGECLS_H_

#include "regstate.h"

#define ENUM_DEFAULT_KEY_NAME_SIZE         128
#define ENUM_DEFAULT_CLASS_SIZE            128

//
// Constants for controlling the direction of enumeration
//
enum
{
    ENUM_DIRECTION_BACKWARD = 0,
    ENUM_DIRECTION_FORWARD = 1,
    ENUM_DIRECTION_IGNORE = 2
};

//
// Constants specifying the physical location of a key being
// enumerated
//
enum 
{
    ENUM_LOCATION_USER = 1,
    ENUM_LOCATION_MACHINE = 2,
    ENUM_LOCATION_NONE = 3
};

//
// Structure for holding the state of an enumeration on a 
// user or machine subtree
//
typedef struct _EnumSubtreeState {
    PKEY_NODE_INFORMATION  pKeyInfo;  // structure holding information about a key
    ULONG                  cbKeyInfo; // size of pKeyInfo
    DWORD                  iSubKey;   // which key we need to ask the kernel for
    BOOL                   Finished;  // TRUE means we are done enumerating this subtree
    union {
        KEY_NODE_INFORMATION;         // Force the buffer to be aligned.
        BYTE                   KeyInfoBuffer[ sizeof( KEY_NODE_INFORMATION ) +
                                            ENUM_DEFAULT_KEY_NAME_SIZE +
                                            ENUM_DEFAULT_CLASS_SIZE ];

    };
} EnumSubtreeState;

//
// Structure for holding the state of enumeration for a registry key
// This structure persists in between calls to RegEnumKeyEx
//
typedef struct _EnumState {

    StateObject            Object;
    unsigned               Direction : 1;
    unsigned               LastLocation : 2;
    unsigned               fClassesRoot : 1;
    HKEY                   hKey;
    HKEY                   hkUserKey;
    HKEY                   hkMachineKey;
    DWORD                  dwLastRequest;
    DWORD                  dwThreadId;
    EnumSubtreeState       UserState;
    EnumSubtreeState       MachineState;

} EnumState;

typedef struct _KeyStateList {

    StateObject     Object;
    StateObjectList StateList;
    EnumState       RootState;

} KeyStateList;

typedef StateObjectList ThreadList;

VOID KeyStateListInit(KeyStateList* pStateList);
VOID KeyStateListDestroy(StateObject* pObject); 

//
// Hash table for storing enumeration states.  This table is indexed
// by (key handle, thread id).
//
typedef struct _EnumTable {

    BOOLEAN                bCriticalSectionInitialized;
    RTL_CRITICAL_SECTION   CriticalSection;
    ThreadList             ThreadEnumList;

} EnumTable;    

//
// Declaration of instance of enumeration table
//
extern EnumTable gClassesEnumTable;

//
// Prototypes for winreg client -- cleanup, init
//
BOOL InitializeClassesEnumTable();
BOOL CleanupClassesEnumTable(BOOL fThisThreadOnly);


//
// functions for managing enumeration state table
//
NTSTATUS EnumTableInit(EnumTable* pEnumTable);

enum
{
    ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD = 1,
    ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD = 2
};

NTSTATUS EnumTableClear(EnumTable* pEnumTable, DWORD dwCriteria);

DWORD EnumTableHashKey(
    EnumTable* pEnumTable,
    HKEY       hKey);

NTSTATUS EnumTableAddKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwFirstSubKey,
    EnumState** ppEnumState,
    EnumState** ppRootState);

NTSTATUS EnumTableRemoveKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwCriteria);

NTSTATUS EnumTableGetNextEnum(
    EnumTable*            pEnumTable,
    HKEY                  hKey,
    DWORD                 dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo);

NTSTATUS EnumTableGetKeyState(
    EnumTable*  pEnumTable,
    HKEY        hKey,
    DWORD       dwSubkey,
    EnumState** ppEnumState,
    EnumState** ppRootState,
    LPDWORD     pcbKeyInfo);

NTSTATUS EnumTableFindKeyState(
    EnumTable*     pEnumTable,
    HKEY           hKey,
    EnumState**    ppEnumState);

void EnumTableUpdateRootState(
    EnumTable* pEnumTable,
    EnumState* pRootState,
    EnumState* pEnumState,
    BOOL       fResetState);

NTSTATUS EnumTableGetRootState(
    EnumTable*  pEnumTable,
    EnumState** ppRootState);


//
// functions to manage enumeration subtrees
//
void EnumSubtreeStateClear(EnumSubtreeState* pTreeState);

NTSTATUS EnumSubtreeStateCopyKeyInfo(
    EnumSubtreeState*     pTreeState,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pDestKeyinfo,
    ULONG                 cbDestKeyInfo,
    PULONG                pcbResult);

//
// functions for managing key enumeration state
//
NTSTATUS EnumStateInit(
    EnumState*     pEnumState,
    HKEY           hKey,
    DWORD          dwFirstSubKey,
    DWORD          dwDirection,
    SKeySemantics* pKeySemantics);

NTSTATUS EnumStateGetNextEnum(
    EnumState*            pEnumState,
    DWORD                 dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo,
    BOOL*                 pfFreeState);

NTSTATUS EnumStateSetLimits(
    EnumState* pEnumState,
    DWORD      dwSubKey,
    LPDWORD    pdwStart,
    LPDWORD    pdwLimit,
    PLONG      plIncrement);

NTSTATUS EnumStateChooseNext(
    EnumState*         pEnumState,
    DWORD              dwSubKey,
    DWORD              dwStart,
    DWORD              dwLimit,
    LONG               lIncrement,
    EnumSubtreeState** ppTreeState);

NTSTATUS EnumStateCompareSubtrees(
    EnumState*         pEnumState,
    LONG               lIncrement,
    EnumSubtreeState** ppSubtree);

VOID EnumStateClear(EnumState* pEnumState);
VOID EnumStateDestroy(StateObject* pObject);

BOOL EnumStateIsEmpty(EnumState* pEnumState);

NTSTATUS EnumStateCopy(
    EnumState*            pDestState,
    EnumState*            pEnumState);

//
// Utility functions
//    
NTSTATUS EnumClassKey(
    HKEY              hKey,
    EnumSubtreeState* pTreeState);

NTSTATUS GetSubKeyCount(
    HKEY    hkClassKey,
    LPDWORD pdwUserSubKeys);

NTSTATUS ClassKeyCountSubKeys(
    HKEY    hKey,
    HKEY    hkUser,
    HKEY    hkMachine,
    DWORD   cMax,
    LPDWORD pcSubKeys);

__inline BOOL IsRootKey(SKeySemantics* pKeySemantics)
{
    return pKeySemantics->_fClassRegParent;
}

#endif // !defined(_REGECLS_H_)

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regekey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regekey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to enumerate keys.  That is:

        - BaseRegEnumKey

Author:

    David J. Gilman (davegi) 23-Dec-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include <malloc.h>

#define DEFAULT_KEY_NAME_SIZE         128
#define DEFAULT_CLASS_SIZE            128



error_status_t
BaseRegEnumKey (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpName,
    OUT PUNICODE_STRING lpClass OPTIONAL,
    OUT PFILETIME lpftLastWriteTime OPTIONAL
    )

/*++

Routine Description:

    Used to enumerate subkeys of an open key.  This function copies the
    dwIndex-th subkey of hKey.

Arguments:

    hKey - A handle to the open key.  The keys returned are relative to
        the key pointed to by this key handle.  Any of the predefined reserved
        handles or a previously opened key handle may be used for hKey.

    dwIndex - The index of the subkey to return.  Note that this is for
        convenience, subkeys are not ordered (a new subkey has an arbitrary
        index).  Indexes start at 0.

    lpName - Provides a pointer to a buffer to receive the name of the
        key.

    lpClass - If present, provides a pointer to a buffer to receive the
        class of the key.

    lpftLastWriteTime - The time when the value was last written (set or
        created).

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    This function is guaranteed to operate correctly only if dwIndex
    starts at 0 and is incremented on successive calls without intervening
    calls to other registration APIs that will change the key.
    KEY_ENUMERATE_SUB_KEYS access is required.

    When lpName->Buffer is NULL the api must return STATUS_BUFFER_OVERFLOW.
    Failure to do so will break other components.

--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_INFORMATION_CLASS           KeyInformationClass;
    PVOID                           KeyInformation;
    ULONG                           ResultLength;
    BOOL                            fClassKey;

    BYTE         PrivateKeyInformation[ sizeof( KEY_NODE_INFORMATION ) +
                                        DEFAULT_KEY_NAME_SIZE +
                                        DEFAULT_CLASS_SIZE ];

    ASSERT( lpName != NULL );

    //
    // Protect ourselves against malicious callers passing NULL
    // pointers.
    //
    if( (lpName == NULL ) ||
        (lpName->Length != 0) ||
        ((lpName->MaximumLength % sizeof(WCHAR)) != 0) ||
        (lpClass == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA or
    // HKEY_PERFORMANCE_TEXT or HKEY_PERFORMANCE_NLSTEXT

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
//    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return (error_status_t)PerfRegEnumKey (
                                        hKey,
                                        dwIndex,
                                        lpName,
                                        NULL,
                                        lpClass,
                                        lpftLastWriteTime
                                        );
    }


    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyInformationClass = (ARGUMENT_PRESENT( lpClass->Buffer ))?
                               KeyNodeInformation :
                               KeyBasicInformation;


    KeyInformation = PrivateKeyInformation;
    BufferLength = sizeof( PrivateKeyInformation );

    fClassKey = FALSE;
    Status = STATUS_SUCCESS;

    //
    // Query for the necessary information about the supplied key.
    //

#ifdef LOCAL
    //
    // For hkcr, we need to do special enumeration
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        Status = EnumTableGetNextEnum( &gClassesEnumTable,
                                       hKey,
                                       dwIndex,
                                       KeyInformationClass,
                                       KeyInformation,
                                       BufferLength,
                                       &ResultLength);

        if (!NT_SUCCESS(Status) || (NT_SUCCESS(Status) && ResultLength)) {
            fClassKey = TRUE;
        }
    }
#endif // LOCAL

    if (!fClassKey) {

        Status = NtEnumerateKey( hKey,
                                 dwIndex,
                                 KeyInformationClass,
                                 KeyInformation,
                                 BufferLength,
                                 &ResultLength
            );
    }

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the fixed portions of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );


    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Key information.
        //  If the caller's buffer are big enough to hold the key name
        //  and key class, then allocate a new buffer, and call the
        //  NT API again.
        //
        if( ( ( KeyInformationClass == KeyBasicInformation ) &&
              ( (ULONG)( lpName->MaximumLength ) >=
                 (( PKEY_BASIC_INFORMATION )
                 KeyInformation )->NameLength + sizeof(UNICODE_NULL)
              )
            ) ||
            ( ( KeyInformationClass == KeyNodeInformation ) &&
              ( (ULONG)(lpName->MaximumLength) >=
                 (( PKEY_NODE_INFORMATION )
                 KeyInformation )->NameLength + sizeof(UNICODE_NULL)
              ) &&
              (
                ARGUMENT_PRESENT( lpClass->Buffer )
              ) &&
              (
                (ULONG)(lpClass->MaximumLength) >= (( PKEY_NODE_INFORMATION )
                        KeyInformation )->ClassLength + sizeof(UNICODE_NULL)
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                              BufferLength
                                            );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyInformation ) {
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied key.
            // This may or may not include the class depending on lpClass->Buffer
            // as determined above.
            //

#ifdef LOCAL
            if (fClassKey) {
                //
                // For hkcr, we need to do special enumeration
                //
                Status = EnumTableGetNextEnum( &gClassesEnumTable,
                                               hKey,
                                               dwIndex,
                                               KeyInformationClass,
                                               KeyInformation,
                                               BufferLength,
                                               &ResultLength);

            } else
#endif // LOCAL
            {
                Status = NtEnumerateKey( hKey,
                                         dwIndex,
                                         KeyInformationClass,
                                         KeyInformation,
                                         BufferLength,
                                         &ResultLength
                    );
            }

        }
    }

    if( NT_SUCCESS( Status ) ) {
        //
        //  Copy key name
        //

        if( KeyInformationClass == KeyBasicInformation ) {
            //
            // Return the name length and the name of the key.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( lpName->Buffer && ((ULONG)(lpName->MaximumLength) >=
                 (( PKEY_BASIC_INFORMATION )
                  KeyInformation )->NameLength + sizeof( UNICODE_NULL ) ))  {

                lpName->Length = ( USHORT )
                                 (( PKEY_BASIC_INFORMATION )
                                 KeyInformation )->NameLength;

                RtlMoveMemory( lpName->Buffer,
                               (( PKEY_BASIC_INFORMATION )
                               KeyInformation )->Name,
                               lpName->Length
                             );

                //
                // NUL terminate the value name.
                //

                lpName->Buffer[ lpName->Length >> 1 ] = UNICODE_NULL;
                lpName->Length += sizeof( UNICODE_NULL );

            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // If requested, return the last write time.
            //

            if( ARGUMENT_PRESENT( lpftLastWriteTime )) {

                *lpftLastWriteTime
                = *( PFILETIME )
                &(( PKEY_BASIC_INFORMATION ) KeyInformation )
                ->LastWriteTime;
            }

        } else {
            //
            // Return the name length and the name of the key.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( lpName->Buffer && 
                ( (ULONG)(lpName->MaximumLength) >=
                  (( PKEY_NODE_INFORMATION )
                   KeyInformation )->NameLength + sizeof( UNICODE_NULL ) ) &&
                ( (ULONG)(lpClass->MaximumLength) >=
                  (( PKEY_NODE_INFORMATION )
                   KeyInformation )->ClassLength + sizeof( UNICODE_NULL) )
              ) {
                //
                //  Copy the key name
                //
                lpName->Length = ( USHORT )
                                 (( PKEY_NODE_INFORMATION )
                                 KeyInformation )->NameLength;

                RtlMoveMemory( lpName->Buffer,
                               (( PKEY_NODE_INFORMATION )
                               KeyInformation )->Name,
                               lpName->Length
                             );

                //
                // NUL terminate the key name.
                //

                lpName->Buffer[ lpName->Length >> 1 ] = UNICODE_NULL;
                lpName->Length += sizeof( UNICODE_NULL );


                //
                //  Copy the key class
                //

                lpClass->Length = (USHORT)
                    ((( PKEY_NODE_INFORMATION ) KeyInformation )->ClassLength );

                RtlMoveMemory(
                    lpClass->Buffer,
                    ( PBYTE ) KeyInformation
                    + (( PKEY_NODE_INFORMATION ) KeyInformation )->ClassOffset,
                    (( PKEY_NODE_INFORMATION ) KeyInformation )->ClassLength
                    );

                //
                // NUL terminate the class.
                //

                lpClass->Buffer[ lpClass->Length >> 1 ] = UNICODE_NULL;

                lpClass->Length += sizeof( UNICODE_NULL );


            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // If requested, return the last write time.
            //

            if( ARGUMENT_PRESENT( lpftLastWriteTime )) {

                *lpftLastWriteTime
                = *( PFILETIME )
                &(( PKEY_NODE_INFORMATION ) KeyInformation )
                ->LastWriteTime;
            }

        }

    }

    if( KeyInformation != PrivateKeyInformation ) {
        //
        // Free the buffer allocated.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyInformation );
    }

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regecls.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegeCls.c

Abstract:

    This module contains helper functions for enumerating
    class registrations via the win32 RegEnumKeyEx api

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

    EnumTableGetNextEnum
    EnumTableRemoveKey
    InitializeClassesEnumTable
    ClassKeyCountSubKeys

Notes:

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for
    HKLM\Software\Classes.  Please see regclass.c for more information
    on this functionality.

    This feature complicates registry key enumeration because certain keys,
    such as CLSID, can have some subkeys that come from HKLM\Software\Classes, and
    other subkeys that come from HKCU\Software\Classes.  Since the feature is
    implemented in user mode, the kernel mode apis know nothing of this.  When it's
    time to enumerate keys, the kernel doesn't know that it should enumerate keys from
    two different parent keys.

    The key problem is that keys with the same name can exist in the user and machine portions.
    When this happens, we choose the user portion is belonging to HKCR -- the other
    one does not exist -- it is "overridden" by the user version. This means that
    we cannot simply enumerate from both places and return the results -- we would
    get duplicates in this case.  Thus, we have to do work in user mode to make
    sure duplicates are not returned.

    This module provides the user mode implementation for enumerating class
    registration keys in HKEY_CLASSES_ROOT.

    The general method is to maintain state between each call to RegEnumKeyEx.  The
    state is kept in a global table indexed by registry key handle and thread id. The
    state allows the api to remember where it is in the enumeration.  The rest of the code
    handles finding the next key, which is accomplished by retrieving keys from both user
    and machine locations.  Since the kernel returns keys from either of these locations in
    sorted order, we can compare the key names and return whichever one is less or greater,
    depending on if we're enumerating upward or downward.  We keep track of where
    we are for both user and machine locations, so we know which key to enumerate
    next and when to stop.

**************************
    IMPORTANT ASSUMPTIONS:
**************************

    This code assumes that the caller has both query permission and enumerate subkey 
    permission in the registry key's acl -- some calls may fail with access denied if the
    acl denies access to the caller.

--*/


#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include <malloc.h>


NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength);

//
// Global table of registry key enumeration state.  This is initialized
// at dll initialize time.
//
EnumTable gClassesEnumTable;

//
// Global indicating need for calling thread detach routines
//
BOOL gbDllHasThreadState = FALSE;

BOOL InitializeClassesEnumTable()
/*++

Routine Description:

    Initializes the global classes enumeration table when
    advapi32.dll is initialized.

Arguments:

Return Value:

    Returns TRUE for success, FALSE for failure

Notes:
    This recordset merging is all in user mode -- 
    should be moved to the kernel for perf and other reasons ??

--*/
{
    NTSTATUS Status;

    //
    // Init the classes enumeration table
    //
    Status = EnumTableInit(&gClassesEnumTable);

    return NT_SUCCESS(Status);
}

BOOL CleanupClassesEnumTable(BOOL fThisThreadOnly)
/*++

Routine Description:

    Uninitializes the global classes enumeration table when
    advapi32.dll is unloaded -- this frees all
    heap associated with the enumeration table, including
    that for keys which have not been closed. Other resources
    required for the table are also freed.

Arguments:

    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       then only the table entries concerning this thread are cleaned up.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, the table entries
       for all threads in the process are cleaned up.

Return Value:

    TRUE for success, FALSE otherwise.

Notes:

--*/
{
    NTSTATUS Status;
    DWORD    dwCriteria;

    dwCriteria = fThisThreadOnly ? ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD :
        ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD;

    //
    // Clear our enumeration table
    //
    Status = EnumTableClear(&gClassesEnumTable, dwCriteria);

    return NT_SUCCESS(Status);
}

NTSTATUS EnumTableInit(EnumTable* pEnumTable)
/*++

Routine Description:

    Initializes an enumeration state table

Arguments:

    pEnumTable - table to initialize

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS   Status;
    EnumState* rgNewState;

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    DbgPrint("WINREG: Instrumented enum table data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: EnumTableInit subtree state size %d\n", sizeof(rgNewState->UserState));
    DbgPrint("WINREG: EnumTableInit state size %d\n", sizeof(*rgNewState));
    DbgPrint("WINREG: EnumTableInit initial table size %d\n", sizeof(*pEnumTable));
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_

    //
    // Initialize the thread list
    //
    StateObjectListInit(
        &(pEnumTable->ThreadEnumList),
        0);

    //
    // We have not initialized the critical section
    // for this table yet -- remember this.
    //
    pEnumTable->bCriticalSectionInitialized = FALSE;

    //
    // Initialize the critical section that will be used to
    // synchronize access to this table
    //
    Status = RtlInitializeCriticalSection(
                    &(pEnumTable->CriticalSection));

    //
    // Remember that we have initialized this critical section
    // so we can remember to delete it.
    //
    pEnumTable->bCriticalSectionInitialized = NT_SUCCESS(Status);

    return Status;
}


NTSTATUS EnumTableClear(EnumTable* pEnumTable, DWORD dwCriteria)
/*++

Routine Description:

    Clears all state in an enumeration table --
    frees all state (memory, resources) memory associated
    with the enumeration table.

Arguments:

    pEnumTable - table to clear
    
    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       enumeration states are removed for this thread only.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, enumeration
       states are removed for all threads in the process.

Return Value:

    none

Notes:

--*/
{
    NTSTATUS    Status;
    BOOL        fThisThreadOnly;
    DWORD       dwThreadId;

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    DWORD        cOrphanedStates = 0;        
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_


    ASSERT((ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria) ||
           (ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD == dwCriteria));

    Status = STATUS_SUCCESS;

    //
    // we assume that if we are called with ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD
    // that we are being called at process detach to remove all keys from the
    // table and free the table itself -- this means that we are the only
    // thread executing this code.
    //

    //
    // Protect ourselves while modifying the table
    //
    if (dwCriteria != ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD) {

        Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
            return Status;
        }
    }

    fThisThreadOnly = (ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria);

    //
    // Find our thread id if the caller wants to remove
    // state for just this thread
    //
    if (fThisThreadOnly) {
        
        KeyStateList* pStateList;

        dwThreadId = GetCurrentThreadId();

        pStateList = (KeyStateList*) StateObjectListRemove(
            &(pEnumTable->ThreadEnumList),
            ULongToPtr((const unsigned long)dwThreadId));

        //
        // Announce that this dll no longer stores state for any
        // threads -- used to avoid calls to dll thread
        // detach routines when there's no state to clean up.
        //
        if (StateObjectListIsEmpty(&(pEnumTable->ThreadEnumList))) {
            gbDllHasThreadState = FALSE;
        }

        if (pStateList) {
            KeyStateListDestroy((StateObject*) pStateList);
        }
            
    } else {

        //
        // If we're clearing all threads, just destroy this list
        //
        StateObjectListClear(&(pEnumTable->ThreadEnumList),
                             KeyStateListDestroy);

        gbDllHasThreadState = FALSE;

    }

    //
    // It's safe to unlock the table
    //
    if (dwCriteria != ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD) {

        Status = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    if (pEnumTable->bCriticalSectionInitialized && !fThisThreadOnly) {

        Status = RtlDeleteCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT(NT_SUCCESS(Status));

#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlDeleteCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif

    }

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    if (!fThisThreadOnly) {
        DbgPrint("WINREG: EnumTableClear() deleted %d unfreed states.\n", cOrphanedStates);
        DbgPrint("WINREG: If the number of unfreed states is > 1, either the\n"
                 "WINREG: process terminated a thread with TerminateThread, the process\n"
                 "WINREG: didn't close all registry handles before exiting,\n"
                 "WINREG: or there's a winreg bug in the classes enumeration code\n");
    }
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_

    return Status;
}


NTSTATUS EnumTableFindKeyState(
    EnumTable*     pEnumTable,
    HKEY           hKey,
    EnumState**    ppEnumState)
/*++

Routine Description:

   Searches for the state for a registry key in
   an enumeration table

Arguments:

    pEnumTable - table in which to search

    hKey - key for whose state we're searching

    ppEnumState - out param for result of search

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pStateList;

    pStateList = (KeyStateList*) StateObjectListFind(
        &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    if (!pStateList) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    } else {

        *ppEnumState = (EnumState*) StateObjectListFind(
            (StateObjectList*) pStateList,
            hKey);
        
        if (!*ppEnumState) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS EnumTableAddKey(
    EnumTable*         pEnumTable,
    HKEY               hKey,
    DWORD              dwFirstSubKey,
    EnumState**        ppEnumState,
    EnumState**        ppRootState)
/*++

Routine Description:

   Adds an enumeration state to
   an enumeration table for a given key.

Arguments:

    pEnumTable - table in which to add state

    hKey - key for whom we want to add state

    dwFirstSubKey - index of first subkey requested by caller
        for enumeration

    ppEnumState - out param for result of search or add

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    EnumState*    pEnumState;
    KeyStateList* pStateList;
    NTSTATUS      Status;
    
    pEnumState = NULL;

    //
    // Announce that this dll has thread state so it will
    // be properly cleaned up by dll thread detach routines
    //
    gbDllHasThreadState = TRUE;

    pStateList = (KeyStateList*) StateObjectListFind(
        (StateObjectList*) &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    if (!pStateList) {
        
        pStateList = RegClassHeapAlloc(sizeof(*pStateList));

        if (!pStateList) {
            return STATUS_NO_MEMORY;
        }

        KeyStateListInit(pStateList);

        StateObjectListAdd(
            &(pEnumTable->ThreadEnumList),
            (StateObject*) pStateList);
    }

    pEnumState = RegClassHeapAlloc(sizeof(*pEnumState));

    if (!pEnumState) {
        return STATUS_NO_MEMORY;
    }
    
    RtlZeroMemory(pEnumState, sizeof(*pEnumState));

    {
        SKeySemantics  keyinfo;
        UNICODE_STRING EmptyString = {0, 0, 0};
        BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    
        //
        // Set buffer to store info about this key
        //
        RtlZeroMemory(&keyinfo, sizeof(keyinfo));

        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
        keyinfo._cbFullPath = sizeof(rgNameBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // get information about this key
        //
        Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

        if (!NT_SUCCESS(Status)) {
            goto error_exit;
        }

        //
        // initialize the empty spot
        //
        Status = EnumStateInit(
            pEnumState,
            hKey,
            dwFirstSubKey,
            dwFirstSubKey ? ENUM_DIRECTION_BACKWARD : ENUM_DIRECTION_FORWARD,
            &keyinfo);

        BaseRegReleaseKeySemantics(&keyinfo);

        if (!NT_SUCCESS(Status)) {
            goto error_exit;
        }

        if (IsRootKey(&keyinfo)) {

            NTSTATUS   RootStatus;

            //
            // If this fails, it is not fatal -- it just means
            // we may miss out on an optimization.  This can 
            // fail due to out of memory, so it is possible
            // that it may fail and we would still want to continue
            //
            RootStatus = EnumTableGetRootState(pEnumTable, ppRootState);

#if DBG
            if (!NT_SUCCESS(RootStatus)) {
                DbgPrint( "WINREG: EnumTableAddKey failed to get classes root state. Status = %lx \n", RootStatus );
            }
#endif // DBG


            if (NT_SUCCESS(RootStatus)) {

                RootStatus = EnumStateCopy(
                    pEnumState,
                    *ppRootState);

#if DBG
                if (!NT_SUCCESS(RootStatus)) {
                    DbgPrint( "WINREG: EnumTableAddKey failed to copy key state. Status = %lx \n", RootStatus );
                }
#endif // DBG
            }
        }
    }

    //
    // set the out parameter for the caller
    //
    *ppEnumState = pEnumState;

    StateObjectListAdd(
        (StateObjectList*) pStateList,
        (StateObject*) pEnumState);
    
    Status = STATUS_SUCCESS;

error_exit:

    if (!NT_SUCCESS(Status) && pEnumState) {
        RegClassHeapFree(pEnumState);
    }

    return Status;
}

NTSTATUS EnumTableRemoveKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwCriteria)
/*++

Routine Description:

   remove an enumeration state from
   an enumeration table for a given key.

Arguments:

    pEnumTable - table in which to remove state

    hKey - key whose state we wish to remove

    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       the enumeration state for hkey is removed for this thread only.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, the enumeration
       state for hkey is removed for all threads in the
       process.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pStateList;
    EnumState*    pEnumState;
    BOOL          fThisThreadOnly;
    NTSTATUS      Status;

    //
    // Protect ourselves while modifying the table
    //
    Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    fThisThreadOnly = (ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria);

    {
        KeyStateList* pNext;

        pNext = NULL;

        for (pStateList = (KeyStateList*) (pEnumTable->ThreadEnumList.pHead);
             pStateList != NULL;
             pStateList = NULL)
        {
            EnumState* pEnumState;

            if (fThisThreadOnly) {

                pStateList = (KeyStateList*) StateObjectListFind(
                    (StateObjectList*) &(pEnumTable->ThreadEnumList),
                    ULongToPtr((const unsigned long)GetCurrentThreadId()));

                if (!pStateList) {
                    break;
                }

            } else {
                pNext = (KeyStateList*) (pStateList->Object.Links.Flink);
            }

            pEnumState = (EnumState*) StateObjectListRemove(
                (StateObjectList*) pStateList,
                hKey);

            if (pEnumState) {

                Status = STATUS_SUCCESS;

                EnumStateDestroy((StateObject*) pEnumState);

                //
                // Note the state list might be empty for a given thread,
                // but we will not destroy this list in order to avoid
                // excessive heap calls
                //
            }
        }
    }

    //
    // It's safe to unlock the table
    //
    Status = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
    }
#endif

    return Status;
}


NTSTATUS EnumTableGetNextEnum(
    EnumTable* pEnumTable,
    HKEY hKey,
    DWORD dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID pKeyInfo,
    DWORD cbKeyInfo,
    LPDWORD pcbKeyInfo)
/*++

Routine Description:

   Gets the next enumerated subkey for a
   particular subkey

Arguments:

    pEnumTable - table that holds state of
       registry key enumerations

    hKey - key for whom we want to add state

    dwSubKey - index of subkey requested by caller
        for enumeration

    KeyInformationClass - the type of key information data
        requested by caller

    pKeyInfo - out param -- buffer for key information data for caller

    cbKeyInfo - size of pKeyInfo buffer

    pcbKeyInfo - out param -- size of key information returned to caller

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    EnumState* pEnumState;
    EnumState* pRootState;
    NTSTATUS   Status;
    BOOL       fFreeState;

    //
    // Protect ourselves while we enumerate
    //
    Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

    //
    // Very big -- unlikely to happen unless there's a runaway enumeration
    // due to a bug in this module.
    //
    // ASSERT(dwSubkey < 16383);

    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableGetNextENUm() failed. Status = %lx \n", Status );
#endif
        return Status;
    }

    //
    // Find the enumeration state for the requested key.  Note that even if this
    // function fails to find an existing state, which case it returns a failure code
    // it can still return an empty pEnumState for that hKey so it can be added later
    //
    Status = EnumTableGetKeyState(pEnumTable, hKey, dwSubkey, &pEnumState, &pRootState, pcbKeyInfo);

    if (!NT_SUCCESS(Status) || !pEnumState) {
        goto cleanup;
    }

    //
    // We have a state for this key, now we can use it to enumerate the next key
    //
    Status = EnumStateGetNextEnum(pEnumState, dwSubkey, KeyInformationClass, pKeyInfo, cbKeyInfo, pcbKeyInfo, &fFreeState);

    //
    // Below is an optimization for apps that enumerate HKEY_CLASSES_ROOT but close the handle and reopen it each
    // time before they call the registry enumeration api.  This is a very bad way to use the api (that's two extra
    // kernel calls for the open and close per enumeration), but existing applications do this and 
    // without the optimization, their enumeration times can go from 3 seconds to 1 or more minutes.  With this optimization,
    // the time gets back down to a few seconds.  This happened because we lost state after the close -- when the new
    // key was opened, we had to call the kernel to enumerate all the keys up to the requested index since we had no
    // previous state to go by -- this ends up making the entire enumeration an O(n^2) operation instead of O(n) as it
    // had been when callers didn't close the key during the enumeration. Here, n is a kernel trap to enumerate a key.
    //

    //
    // Above, we retrieved an enumeration state for the root of classes -- this state reflects the enumeration state
    // of the last handle that was used to enumerate the root on this thread.  This way, when a new handle is opened
    // to enumerate the root, we start with this state which will most likely be right at the index before the requested
    // index.  Instead of making i calls to NtEnumerateKey where i is the index of enumeration requested by the caller,
    // we make 1 or at most 2 calls.
    //

    //
    // Here, we update the root state to match the recently enumerated state.  Note that this only happens
    // if the key being enumerated refers to HKEY_CLASSES_ROOT since pRootState is only non-NULL in this
    // case.
    //
    if (pRootState) {
        EnumTableUpdateRootState(pEnumTable, pRootState, pEnumState, fFreeState);
    }

    if (fFreeState) {

        NTSTATUS RemoveStatus;

        //
        // For whatever reason, we've been told to free the enumeration state for this key.
        // This could be due to an error, or it could be a normal situation such as reaching
        // the end of an enumeration.
        //

        RemoveStatus = EnumTableRemoveKey(pEnumTable, hKey, ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD);

        ASSERT(NT_SUCCESS(RemoveStatus));
    }

cleanup:

    //
    // It's safe to unlock the table now.
    //
    {
        NTSTATUS CriticalSectionStatus;

        CriticalSectionStatus = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( CriticalSectionStatus ) );
#if DBG
        if ( !NT_SUCCESS( CriticalSectionStatus ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableGetNextEnum() failed. Status = %lx \n",
                      CriticalSectionStatus );
        }
#endif
    }

    return Status;
}


NTSTATUS EnumTableGetKeyState(
    EnumTable*  pEnumTable,
    HKEY        hKey,
    DWORD       dwSubkey,
    EnumState** ppEnumState,
    EnumState** ppRootState,
    LPDWORD     pcbKeyInfo)
/*++

Routine Description:

    Finds a key state for hKey -- creates a new state for hkey if 
    there is no existing state

Arguments:

    pEnumTable - enumeration table in which to find key's state
    hKey - handle to registry key for which to find state
    dwSubkey - subkey that we're trying to enumerate -- needed in
        case we need to create a new state
    ppEnumState - pointer to where we should return address of 
        the retrieved state,
    ppRootState - if the retrieved state is the root of the classes
        tree, this address will point to a known state for the root
        that's good across all hkey's enumerated on this thread
    pcbKeyInfo - stores size of key information on return

Return Value:

    STATUS_SUCCESS for success, other error code on error

Notes:

--*/
{
    NTSTATUS Status;

    if (ppRootState) {
        *ppRootState = NULL;
    }

    //
    // Find the enumeration state for the requested key.  Note that even if this
    // function fails to find an existing state, in which case it returns a failure code
    // it can still return an empty pEnumState for that hKey so it can be added later
    //
    Status = EnumTableFindKeyState(pEnumTable, hKey, ppEnumState);

    if (!NT_SUCCESS(Status)) {

        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

            //
            // This means the key didn't exist, already, so we'll add it
            //
            Status = EnumTableAddKey(pEnumTable, hKey, dwSubkey, ppEnumState, ppRootState);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            // The above function can succeed but return a NULL pEnumState -- this
            // happens if it turns out this key is not a "special key" -- i.e. this key's
            // parents exist in only one hive, not two, so we don't need to do anything here
            // and regular enumeration will suffice.
            //
            if (!(*ppEnumState)) {
                //
                // We set this value to let our caller know that this isn't a class key
                //
                *pcbKeyInfo = 0;
            }
        }
    } else {

        if ((*ppEnumState)->fClassesRoot) {
            Status = EnumTableGetRootState(pEnumTable, ppRootState);
        }
    }

    return Status;
}


NTSTATUS EnumTableGetRootState(
    EnumTable*  pEnumTable,
    EnumState** ppRootState)
/*++

Routine Description:

    

Arguments:

    pEnumTable - enumeration table in which to find the root
        state
    ppRootState - points to address of root state on return

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    DWORD         cbKeyInfo;
    KeyStateList* pStateList;
    
    //
    // We assume the caller has made sure that a state list
    // for this thread exists -- this should never, ever fail
    //
    pStateList = (KeyStateList*) StateObjectListFind(
        &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    ASSERT(pStateList);

    *ppRootState = &(pStateList->RootState);

    return STATUS_SUCCESS;
}


void EnumTableUpdateRootState(
    EnumTable* pEnumTable,
    EnumState* pRootState,
    EnumState* pEnumState,
    BOOL       fResetState)
/*++

Routine Description:

    Updates the state of the classes root for this thread -- this
    allows us to optimize for apps that close handles when enumerating
    hkcr -- we use this classes root state when no existing state is
    found for an hkey that refers to hkcr, and we update this state
    after enumerating an hkcr key on this thread so that it will
    be up to date.

Arguments:

    pEnumTable - enumeration table in which the classes root state resides

    pRootState - classes root state that should be updated

    ppEnumState - state that contains the data with which pRootState should
        be updated

    fResetState - if TRUE, this flag means we should not update the root state
        with pEnumState's data, just reset it.  If FALSE, we update the root
        with pEnumState's data.

Return Value:

     None.

Notes:

--*/
{
    NTSTATUS Status;

    //
    // See if we need to merely reset the root or actually
    // update it with another state
    //
    if (!fResetState) {

        //
        // Don't reset -- copy over the state from pEnumState to the
        // root state -- the root's state will be the same as pEnumState's
        // after this copy
        //
        Status = EnumStateCopy(pRootState, pEnumState);

    } else {

        //
        // Just clear out the state -- caller didn't request that we
        // use pEnumState.
        //
        Status = EnumStateInit(
            pRootState,
            0,
            0,
            ENUM_DIRECTION_FORWARD,
            NULL);
    }

    //
    // If there's a failure, it must be out-of-memory, so we should get rid
    // of this state since we can't make it accurately reflect the true
    // enumeration state
    //
    if (!NT_SUCCESS(Status)) {

#if DBG
        DbgPrint( "WINREG: failure in UpdateRootState. Status = %lx \n", Status );
#endif

        ASSERT(STATUS_NO_MEMORY == Status);

        EnumStateClear(pRootState);
    }
}


VOID KeyStateListInit(KeyStateList* pStateList)
/*++

Routine Description:

    Initializes a state list

Arguments:

    pObject -- pointer to KeyStateList object to destroy

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // First initialize the base object
    //
    StateObjectListInit((StateObjectList*) pStateList,
                        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    //
    // Now do KeyStateList specific init
    //
    (void) EnumStateInit(
        &(pStateList->RootState),
        NULL,
        0,
        ENUM_DIRECTION_FORWARD,
        NULL);
}

VOID KeyStateListDestroy(StateObject* pObject)
/*++

Routine Description:

    Destroys an KeyStateList, freeing its resources such
        as memory or kernel object handles

Arguments:

    pObject -- pointer to KeyStateList object to destroy

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pThisList;

    pThisList = (KeyStateList*) pObject;

    //
    // Destroy all states in this list
    //
    StateObjectListClear(
        (StateObjectList*) pObject,
        EnumStateDestroy);

    //
    // Free resources associated with the root state
    //
    EnumStateClear(&(pThisList->RootState));

    //
    // Free the data structure for this object
    //
    RegClassHeapFree(pThisList);
} 


NTSTATUS EnumStateInit(
    EnumState*     pEnumState,
    HKEY           hKey,
    DWORD          dwFirstSubKey,
    DWORD          dwDirection,
    SKeySemantics* pKeySemantics)
/*++

Routine Description:

    Initializes enumeration state

Arguments:

    pEnumState - enumeration state to initialize
    hKey       - registry key to which this state refers
    dwFirstSubKey - index of the first subkey which this state will enumerate
    dwDirection - direction through which we should enumerate -- either
        ENUM_DIRECTION_FORWARD or ENUM_DIRECTION_BACKWARD
    pKeySemantics - structure containing information about hKey

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

--*/
{
    NTSTATUS Status;
    ULONG    cMachineKeys;
    ULONG    cUserKeys;
    HKEY     hkOther;

    ASSERT((ENUM_DIRECTION_FORWARD == dwDirection) || (ENUM_DIRECTION_BACKWARD == dwDirection) ||
        (ENUM_DIRECTION_IGNORE == dwDirection));

    ASSERT((ENUM_DIRECTION_IGNORE == dwDirection) ? hKey == NULL : TRUE);

    Status = STATUS_SUCCESS;

    hkOther = NULL;

    //
    // If no hkey is specified, this is an init of a blank enum
    // state, so clear everything
    //
    if (!hKey) {
        memset(pEnumState, 0, sizeof(*pEnumState));
    }

    //
    // Clear each subtree
    //
    EnumSubtreeStateClear(&(pEnumState->UserState));
    EnumSubtreeStateClear(&(pEnumState->MachineState));

    //
    // Reset each subtree
    //
    pEnumState->UserState.Finished = FALSE;
    pEnumState->MachineState.Finished = FALSE;

    pEnumState->UserState.iSubKey = 0;
    pEnumState->MachineState.iSubKey = 0;

    cUserKeys = 0;
    cMachineKeys = 0;

    if (pKeySemantics) {
        StateObjectInit((StateObject*) &(pEnumState->Object), hKey);
    }

    if (hKey) {

        if (pKeySemantics) {
            pEnumState->fClassesRoot = IsRootKey(pKeySemantics);
        }

        //
        // open the other key if we have enough info to do so --
        //
        if (pKeySemantics) {

            //
            // Remember, only one of the handles returned below
            // is new -- the other is simply hKey
            //
            Status = BaseRegGetUserAndMachineClass(
                pKeySemantics,
                hKey,
                MAXIMUM_ALLOWED,
                &(pEnumState->hkMachineKey),
                &(pEnumState->hkUserKey));

            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
         
        //
        // for backwards enumerations
        //
        if (ENUM_DIRECTION_BACKWARD == dwDirection) {

            ULONG             cMachineKeys;
            ULONG             cUserKeys;
            HKEY              hkUser;
            HKEY              hkMachine;
            
            cMachineKeys = 0;
            cUserKeys = 0;
            
            hkMachine = pEnumState->hkMachineKey;
            hkUser = pEnumState->hkUserKey;

            //
            // In order to query for subkey counts, we should
            // to get a new handle since the caller supplied handle
            // may not have enough permissions
            //
            {
                HKEY   hkSource;
                HANDLE hCurrentProcess;

                hCurrentProcess = NtCurrentProcess();

                hkSource = (hkMachine == hKey) ? hkMachine : hkUser;
                
                Status = NtDuplicateObject(
                    hCurrentProcess,
                    hkSource,
                    hCurrentProcess,
                    &hkOther,
                    KEY_QUERY_VALUE,
                    FALSE,
                    0);

                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }

                if (hkSource == hkUser) {
                    hkUser = hkOther;
                } else {
                    hkMachine = hkOther;
                }
            }

            //
            // find new start -- query for index of last subkey in
            // each hive 
            //
            if (hkMachine) {

                Status = GetSubKeyCount(hkMachine, &cMachineKeys);
            
                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }
            }

            if (hkUser) {

                Status = GetSubKeyCount(hkUser, &cUserKeys);
                
                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }
            }

            //
            // If either subtree has no subkeys, we're done enumerating that
            // subtree
            //
            if (!cUserKeys) {
                pEnumState->UserState.Finished = TRUE;
            } else {
                pEnumState->UserState.iSubKey = cUserKeys - 1;
            }

            if (!cMachineKeys) {
                pEnumState->MachineState.Finished = TRUE;
            } else {
                pEnumState->MachineState.iSubKey = cMachineKeys - 1;
            }
        }
    }
  
    //
    // Set members of this structure
    //
        
    pEnumState->dwThreadId = GetCurrentThreadId();
    pEnumState->Direction = dwDirection;
    pEnumState->dwLastRequest = dwFirstSubKey;
    pEnumState->LastLocation = ENUM_LOCATION_NONE;
        
    pEnumState->hKey = hKey;

error_exit:

    if (!NT_SUCCESS(Status)) {
        EnumSubtreeStateClear(&(pEnumState->MachineState));
        EnumSubtreeStateClear(&(pEnumState->UserState));
    }

    if (hkOther) {
        NtClose(hkOther);
    }

    return Status;
}


NTSTATUS EnumStateGetNextEnum(
    EnumState*            pEnumState,
    DWORD                 dwSubKey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo,
    BOOL*                 pfFreeState)
/*++

Routine Description:

    Gets the next key in an enumeration based on the current state.

Arguments:

    pEnumState - enumeration state on which to base our search
                 for the next key
    dwSubKey   - index of key to enumerate
    KeyInformationClass - enum for what sort of information to retrieve in the
         enumeration -- Basic Information or Node Information

    pKeyInfo   - location to store retrieved data for caller
    cbKeyInfo  - size of caller's info buffer
    pcbKeyInfo - size of data this function writes to buffer on return.
    pfFreeState - out param -- if set to TRUE, caller should free pEnumState.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

    This function essentially enumerates from the previous index requested
    by the caller of RegEnumKeyEx to the new one. In most cases, this just
    means one trip to the kernel -- i.e. if a caller goes from index 2 to 3,
    or from 3 to 2, this is one trip to the kernel.  However, if the caller goes
    from 2 to 5, we'll have to do several enumerations on the way from 2 to 5.
    Also, if the caller switches direction (i.e. starts off 0,1,2,3 and then
    requests 1), a large penalty may be incurred.  When switching from ascending
    to descending, we have to enumerate all keys to the end and then before we
    can then enumerate down to the caller's requested index.  Switching from
    descending to ascending is less expensive -- we know that the beginning
    is at 0 for both user and machine keys, so we can simply set our indices to
    0 without enumerating anything.  However, we must then enumerate to the
    caller's requested index.  Note that for all descending enumerations, we
    must enumerate all the way to the end first before returning anything to the
    caller.

--*/
{
    NTSTATUS          Status;
    LONG              lIncrement;
    DWORD             dwStart;
    DWORD             dwLimit;
    EnumSubtreeState* pTreeState;

    //
    // If anything bad happens, this state should be freed
    //
    *pfFreeState = TRUE;

    //
    // Find out the limits (start, finish, increment) for
    // our enumeration. The increment is either 1 or -1,
    // depending on whether this is an ascending or descending
    // enumeration.  EnumStateSetLimits will take into account
    // any changes in direction and set dwStart and dwLimit
    // accordingly.
    //
    Status = EnumStateSetLimits(
        pEnumState,
        dwSubKey,
        &dwStart,
        &dwLimit,
        &lIncrement);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Get the next enum to give back to the caller
    //
    Status = EnumStateChooseNext(
        pEnumState,
        dwSubKey,
        dwStart,
        dwLimit,
        lIncrement,
        &pTreeState);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // We have retrieved information, so we should
    // not free this state
    //
    if (!(pEnumState->UserState.Finished && pEnumState->MachineState.Finished)) {
        *pfFreeState = FALSE;
    }

    //
    // Remember the last key we enumerated
    //
    pEnumState->dwLastRequest = dwSubKey;

    //
    // Copy the retrieved information to the user's
    // buffer.
    //
    Status = EnumSubtreeStateCopyKeyInfo(
        pTreeState,
        KeyInformationClass,
        pKeyInfo,
        cbKeyInfo,
        pcbKeyInfo);

    //
    // The copy could fail if the user's buffer isn't big enough --
    // if it succeeds, clear the name information for the subkey from
    // which we retrieved the data so that the next time we're called
    // we'll get the next subkey for that subtree.
    //
    if (NT_SUCCESS(Status)) {
        EnumSubtreeStateClear(pTreeState);
    }

    return Status;
}


NTSTATUS EnumStateSetLimits(
    EnumState*   pEnumState,
    DWORD        dwSubKey,
    LPDWORD      pdwStart,
    LPDWORD      pdwLimit,
    PLONG        plIncrement)
/*++

Routine Description:

    Gets the limits (start, finish, increment) for enumerating a given
    subkey index

Arguments:

    pEnumState - enumeration state on which to base our limits

    dwSubKey   - index of key which caller wants enumerated

    pdwStart   - out param -- result is the place at which to start
                 enumerating in order to find dwSubKey

    pdwLimit   - out param -- result is the place at which to stop
                 enumerating when looking for dwSubKey

    plIncrement - out param -- increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    LONG     lNewIncrement;
    NTSTATUS Status;
    BOOL     fSameKey;

    //
    // set our increment to the direction which our state remembers
    //
    *plIncrement = pEnumState->Direction == ENUM_DIRECTION_FORWARD ? 1 : -1;

    fSameKey = FALSE;

    //
    // Figure out what the new direction should be
    // This is done by comparing the current request
    // with the last request.
    //
    if (dwSubKey > pEnumState->dwLastRequest) {
        lNewIncrement = 1;
    } else if (dwSubKey < pEnumState->dwLastRequest) {
        lNewIncrement = -1;
    } else {
        //
        // We are enumerating a key that may already
        // have been enumerated
        //
        fSameKey = TRUE;
        lNewIncrement = *plIncrement;
    }

    //
    // See if we've changed direction
    //
    if (lNewIncrement != *plIncrement) {

        //
        // If so, we should throw away all existing state and start from scratch
        //
        Status = EnumStateInit(
            pEnumState,
            pEnumState->hKey,
            (-1 == lNewIncrement) ? dwSubKey : 0,
            (-1 == lNewIncrement) ? ENUM_DIRECTION_BACKWARD : ENUM_DIRECTION_FORWARD,
            NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // By default, we start enumerating where we left off
    //
    *pdwStart = pEnumState->dwLastRequest;

    //
    // for state for which we have previously enumerated a key
    //
    if (ENUM_LOCATION_NONE != pEnumState->LastLocation) {

        //
        // We're going in the same direction as on the
        // previous call. We should start
        // one past our previous position.  Note that we
        // only start there if this is a different key --
        // if we've already enumerated it we start at the
        // same spot.
        //
        if (!fSameKey) {
            *pdwStart += *plIncrement;
        } else {
            
            // 
            // If we're being asked for the same index
            // multiple times they're probably deleting
            // keys -- we should reset ourselves to
            // the beginning so their enum will hit
            // all the keys
            //

            //
            // We're starting at zero, so set ourselves
            // to start at the beginning
            //
            Status = EnumStateInit(
                pEnumState,
                pEnumState->hKey,
                0,
                ENUM_DIRECTION_FORWARD,
                NULL);
            
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
            
            *plIncrement = 1;
            pEnumState->Direction = ENUM_DIRECTION_FORWARD;
            *pdwStart = 0;
        }

    } else {

        //
        // No previous calls were made for this state
        //
        if (ENUM_DIRECTION_BACKWARD == pEnumState->Direction) {

            //
            // For backwards enumerations, we want to get an
            // accurate count of total subkeys and start there
            //
            Status = ClassKeyCountSubKeys(
                pEnumState->hKey,
                pEnumState->hkUserKey,
                pEnumState->hkMachineKey,
                0,
                pdwStart);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            // Make sure we don't go past the end
            //
            if (dwSubKey >= *pdwStart) {
                return STATUS_NO_MORE_ENTRIES;
            }

            //
            // This is a zero-based index, so to
            // put our start at the very end we must
            // be one less than the number of keys
            //
            (*pdwStart)--;

            *plIncrement = -1;

        } else {
            *plIncrement = 1;
        }
    }

    //
    // Set limit to be one past requested subkey
    //
    *pdwLimit = dwSubKey + *plIncrement;

    return STATUS_SUCCESS;
}


NTSTATUS EnumStateChooseNext(
    EnumState*         pEnumState,
    DWORD              dwSubKey,
    DWORD              dwStart,
    DWORD              dwLimit,
    LONG               lIncrement,
    EnumSubtreeState** ppTreeState)
/*++

Routine Description:

    Iterates through registry keys to get the key requested by the caller

Arguments:

    pEnumState - enumeration state on which to base our search

    dwSubKey   - index of key which caller wants enumerated

    dwStart   - The place at which to start
                enumerating in order to find dwSubKey

    dwLimit   - The place at which to stop
                enumerating when looking for dwSubKey

    lIncrement - Increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

    ppTreeState - out param -- pointer to address of subtree state in which this regkey
                  was found -- each EnumState has two EnumSubtreeState's -- one for user
                  and one for machine.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    DWORD    iCurrent;
    NTSTATUS Status;
    BOOL     fClearLast;

    Status = STATUS_NO_MORE_ENTRIES;

    fClearLast = FALSE;

    //
    // We will now iterate from dwStart to dwLimit so that we can find the key
    // requested by the caller
    //
    for (iCurrent = dwStart; iCurrent != dwLimit; iCurrent += lIncrement) {

        BOOL fFoundKey;
        BOOL fIgnoreFailure;

        fFoundKey = FALSE;

        fIgnoreFailure = FALSE;

        Status = STATUS_NO_MORE_ENTRIES;

        //
        // Clear last subtree
        //
        if (fClearLast) {
            EnumSubtreeStateClear(*ppTreeState);
        }

        //
        // if key names aren't present, alloc space and get names
        //
        if (pEnumState->hkUserKey) {
            if (pEnumState->UserState.pKeyInfo) {
                fFoundKey = TRUE;
            } else if (!(pEnumState->UserState.Finished)) {

                // get user key info
                Status = EnumClassKey(
                    pEnumState->hkUserKey,
                    &(pEnumState->UserState));

                fFoundKey = NT_SUCCESS(Status);

                //
                // If there are no more subkeys for this subtree,
                // mark it as finished
                //
                if (!NT_SUCCESS(Status)) {

                    if (STATUS_NO_MORE_ENTRIES != Status) {
                        return Status;
                    }

                    if (lIncrement > 0) {
                        pEnumState->UserState.Finished = TRUE;
                    } else {

                        pEnumState->UserState.iSubKey += lIncrement;
                        fIgnoreFailure = TRUE;
                    }
                }
            }
        }

        if (pEnumState->hkMachineKey) {

            if (pEnumState->MachineState.pKeyInfo) {
                fFoundKey = TRUE;
            } else if (!(pEnumState->MachineState.Finished)) {

                // get machine key info
                Status = EnumClassKey(
                    pEnumState->hkMachineKey,
                    &(pEnumState->MachineState));

                //
                // If there are no more subkeys for this subtree,
                // mark it as finished
                //
                if (NT_SUCCESS(Status)) {
                    fFoundKey = TRUE;
                } else if (STATUS_NO_MORE_ENTRIES == Status) {

                    if (lIncrement > 0) {
                        pEnumState->MachineState.Finished = TRUE;
                    } else {
                        pEnumState->MachineState.iSubKey += lIncrement;
                        fIgnoreFailure = TRUE;
                    }
                }
            }
        }

        //
        // If we found no keys in either user or machine locations, there are
        // no more keys.
        //
        if (!fFoundKey) {

            //
            // For descending enumerations, we ignore STATUS_NO_MORE_ENTRIES
            // and keep going until we find one.
            //
            if (fIgnoreFailure) {
                continue;
            }

            return Status;
        }

        //
        // If we already hit the bottom, skip to the end
        //
        if ((pEnumState->UserState.iSubKey == 0) &&
            (pEnumState->MachineState.iSubKey == 0) &&
            (lIncrement < 0)) {
            
            iCurrent = dwLimit - lIncrement;
        }

        //
        // Now we need to choose between keys in the machine hive and user hives --
        // this call will choose which key to use.
        //
        Status = EnumStateCompareSubtrees(pEnumState, lIncrement, ppTreeState);

        if (!NT_SUCCESS(Status)) {

            pEnumState->dwLastRequest = dwSubKey;

            return Status;
        }
        
        fClearLast = TRUE;

    }

    return Status;
}


NTSTATUS EnumStateCompareSubtrees(
    EnumState*         pEnumState,
    LONG               lIncrement,
    EnumSubtreeState** ppSubtree)
/*++

Routine Description:

    Compares the user and machine subtrees of an enumeration state
    to see which of the two current keys in each hive should be
    returned as the next key in an enumeration

Arguments:

    pEnumState - enumeration state on which to base our search

    lIncrement - Increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

    ppSubtree - out param -- pointer to address of subtree state where
                key was found -- the name of the key can be extracted from it.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // If both subtrees have a current subkey name, we'll need to compare
    // the names
    //
    if (pEnumState->MachineState.pKeyInfo && pEnumState->UserState.pKeyInfo) {

        UNICODE_STRING MachineKeyName;
        UNICODE_STRING UserKeyName;
        LONG           lCompareResult;

        MachineKeyName.Buffer = pEnumState->MachineState.pKeyInfo->Name;
        MachineKeyName.Length = (USHORT) pEnumState->MachineState.pKeyInfo->NameLength;

        UserKeyName.Buffer = pEnumState->UserState.pKeyInfo->Name;
        UserKeyName.Length = (USHORT) pEnumState->UserState.pKeyInfo->NameLength;

        //
        // Do the comparison
        //
        lCompareResult =
            RtlCompareUnicodeString(&UserKeyName, &MachineKeyName, TRUE) * lIncrement;

        //
        // User wins comparison
        //
        if (lCompareResult < 0) {
            // choose user
            *ppSubtree = &(pEnumState->UserState);
            pEnumState->LastLocation = ENUM_LOCATION_USER;

        } else if (lCompareResult > 0) {

            //
            // Machine wins choose machine
            //
            *ppSubtree = &(pEnumState->MachineState);
            pEnumState->LastLocation = ENUM_LOCATION_MACHINE;

        } else {

            //
            // Comparison returned equality -- the keys have the same
            // name.  This means the same key name exists in both machine and
            // user, so we need to make a choice about which one we will enumerate.
            // Policy for per-user class registration enumeration is to choose user, just
            // as we do for other api's such as RegOpenKeyEx and RegCreateKeyEx.
            //
            if (!((pEnumState->MachineState.iSubKey == 0) && (lIncrement < 0))) {
                pEnumState->MachineState.iSubKey += lIncrement;
            } else {
                pEnumState->MachineState.Finished = TRUE;
            }

            //
            // Clear the machine state and move it to the next index -- we don't
            // have to clear the user state yet because the state of whichever subtree
            // was selected is cleared down below
            //
            EnumSubtreeStateClear(&(pEnumState->MachineState));
            pEnumState->LastLocation = ENUM_LOCATION_USER;
            *ppSubtree = &(pEnumState->UserState);
        }

    } else if (!(pEnumState->UserState.pKeyInfo) && !(pEnumState->MachineState.pKeyInfo)) {
        //
        // Neither subtree state has a subkey, so there are no subkeys
        //
        return STATUS_NO_MORE_ENTRIES;

    } else if (pEnumState->MachineState.pKeyInfo) {

        //
        // Only machine has a subkey
        //
        *ppSubtree = &(pEnumState->MachineState);
        pEnumState->LastLocation = ENUM_LOCATION_MACHINE;

    } else {

        //
        // only user has a subkey
        //
        *ppSubtree = &(pEnumState->UserState);
        pEnumState->LastLocation = ENUM_LOCATION_USER;
    }

    //
    // change the state of the subtree which we selected
    //
    if (!(((*ppSubtree)->iSubKey == 0) && (lIncrement < 0))) {
        (*ppSubtree)->iSubKey += lIncrement;
    } else {
        (*ppSubtree)->Finished = TRUE;
    }

    return STATUS_SUCCESS;
}

void EnumStateDestroy(StateObject* pObject)
{
    EnumStateClear((EnumState*) pObject);

    RegClassHeapFree(pObject);
}

VOID EnumStateClear(EnumState* pEnumState)
/*++

Routine Description:

    Clears the enumeration state

Arguments:

    pEnumState - enumeration state to clear

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // Close an existing reference to a second key
    //
    if (pEnumState->hkMachineKey && (pEnumState->hKey != pEnumState->hkMachineKey)) {

        NtClose(pEnumState->hkMachineKey);

    } else if (pEnumState->hkUserKey && (pEnumState->hKey != pEnumState->hkUserKey)) {
        
        NtClose(pEnumState->hkUserKey);
    }

    //
    // Free any heap memory held by our subtrees
    //
    EnumSubtreeStateClear(&(pEnumState->UserState));
    EnumSubtreeStateClear(&(pEnumState->MachineState));

    //
    // reset everything in this state
    //
    memset(pEnumState, 0, sizeof(*pEnumState));
}


BOOL EnumStateIsEmpty(EnumState* pEnumState)
/*++

Routine Description:

    Returns whether or not an enumeration state is empty.
    An enumeration state is empty if it is not associated
    with any particular registry key handle

Arguments:

    pEnumState - enumeration state to clear

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    return pEnumState->hKey == NULL;
}

NTSTATUS EnumStateCopy(
    EnumState*            pDestState,
    EnumState*            pEnumState)
/*++

Routine Description:

    Copies an enumeration state for one hkey
    to the state for another hkey -- note that it the 
    does not change the hkey referred to by the destination
    state, it just makes pDestState->hKey's state the
    same as pEnumState's

Arguments:

    pDestState - enumeration state which is destination
        of the copy
    pEnumState - source enumeration for the copy

Return Value:

    STATUS_SUCCESS for success, other error code on error

Notes:

--*/
{
    NTSTATUS Status;

    PKEY_NODE_INFORMATION pKeyInfoUser;
    PKEY_NODE_INFORMATION pKeyInfoMachine;

    Status = STATUS_SUCCESS;

    //
    // Copy simple data
    //
    pDestState->Direction = pEnumState->Direction;
    pDestState->LastLocation = pEnumState->LastLocation;

    pDestState->dwLastRequest = pEnumState->dwLastRequest;
    pDestState->dwThreadId = pEnumState->dwThreadId;

    //
    // Free existing data before we overwrite it -- note that the pKeyInfo can point to a fixed buffer inside the state or 
    // a heap allocated buffer, so we must see which one it points to before we decide to free it
    //
    if (pDestState->UserState.pKeyInfo &&
        (pDestState->UserState.pKeyInfo != (PKEY_NODE_INFORMATION) pDestState->UserState.KeyInfoBuffer)) {
        RegClassHeapFree(pDestState->UserState.pKeyInfo);
        pDestState->UserState.pKeyInfo = NULL;
    }

    if (pDestState->MachineState.pKeyInfo &&
        (pDestState->MachineState.pKeyInfo != (PKEY_NODE_INFORMATION) pDestState->MachineState.KeyInfoBuffer)) {
        RegClassHeapFree(pDestState->MachineState.pKeyInfo);
        pDestState->MachineState.pKeyInfo = NULL;
    }

    //
    // easy way to copy states -- we'll have to fix up below though since pKeyInfo can be
    // self-referential.
    //
    memcpy(&(pDestState->UserState), &(pEnumState->UserState), sizeof(pEnumState->UserState));
    memcpy(&(pDestState->MachineState), &(pEnumState->MachineState), sizeof(pEnumState->MachineState));

    pKeyInfoUser = NULL;
    pKeyInfoMachine = NULL;
        
    //
    // Copy new data -- as above, keep in mind that pKeyInfo can be self-referential, so check
    // for that before deciding whether to allocate heap or use the internal fixed buffer of the
    // structure.
    //
    if (pEnumState->UserState.pKeyInfo &&
        ((pEnumState->UserState.pKeyInfo != (PKEY_NODE_INFORMATION) pEnumState->UserState.KeyInfoBuffer))) {

        pKeyInfoUser = (PKEY_NODE_INFORMATION) 
            RegClassHeapAlloc(pEnumState->UserState.cbKeyInfo);

        if (!pKeyInfoUser) {
            Status = STATUS_NO_MEMORY;
        }

        pDestState->UserState.pKeyInfo = pKeyInfoUser;

        RtlCopyMemory(pDestState->UserState.pKeyInfo,
                      pEnumState->UserState.pKeyInfo,
                      pEnumState->UserState.cbKeyInfo);
    } else {
        if (pDestState->UserState.pKeyInfo) {
            pDestState->UserState.pKeyInfo = (PKEY_NODE_INFORMATION) pDestState->UserState.KeyInfoBuffer;
        }
    }
    
    if (pEnumState->MachineState.pKeyInfo &&
        ((pEnumState->MachineState.pKeyInfo != (PKEY_NODE_INFORMATION) pEnumState->MachineState.KeyInfoBuffer))) {
      
        pKeyInfoMachine = (PKEY_NODE_INFORMATION) 
            RegClassHeapAlloc(pEnumState->MachineState.cbKeyInfo);

        if (!pKeyInfoMachine) {
            Status = STATUS_NO_MEMORY;
        }

        pDestState->MachineState.pKeyInfo = pKeyInfoMachine;

        RtlCopyMemory(pDestState->MachineState.pKeyInfo,
                      pEnumState->MachineState.pKeyInfo,
                      pEnumState->MachineState.cbKeyInfo);
    } else {
        if (pDestState->MachineState.pKeyInfo) {
            pDestState->MachineState.pKeyInfo = (PKEY_NODE_INFORMATION) pDestState->MachineState.KeyInfoBuffer;
        }
    }

    //
    // On error, make sure we clean up.
    // 
    if (!NT_SUCCESS(Status)) {

        if (pKeyInfoUser) {
            RegClassHeapFree(pKeyInfoUser);
        }

        if (pKeyInfoMachine) {
            RegClassHeapFree(pKeyInfoMachine);
        }
    }

    return Status;
}


void EnumSubtreeStateClear(EnumSubtreeState* pTreeState)
/*++
Routine Description:

    This function frees the key data associated with this
    subtree state

Arguments:

    pTreeState -- tree state to clear

Return Value: None.

    Note:

--*/

{
    //
    // see if we're using pre-alloced buffer -- if not, free it
    //
    if (pTreeState->pKeyInfo && (((LPBYTE) pTreeState->pKeyInfo) != pTreeState->KeyInfoBuffer)) {

        RegClassHeapFree(pTreeState->pKeyInfo);
    }

    pTreeState->pKeyInfo = NULL;
}

NTSTATUS EnumSubtreeStateCopyKeyInfo(
    EnumSubtreeState* pTreeState,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID pDestKeyInfo,
    ULONG cbDestKeyInfo,
    PULONG pcbResult)
/*++

Routine Description:

    Copies information about a key into a buffer supplied by the caller

Arguments:

    pTreeState - subtree tate from which to copy

    KeyInformationClass - the type of buffer supplied by the caller -- either
        a KEY_NODE_INFORMATION or KEY_BASIC_INFORMATION structure

    pDestKeyInfo - caller's buffer for key information

    cbDestKeyInfo - size of caller's buffer

    pcbResult - out param -- amount of data to be written to caller's buffer

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    ULONG cbNeeded;

    ASSERT((KeyInformationClass == KeyNodeInformation) ||
           (KeyInformationClass == KeyBasicInformation));

    //
    // Find out how big the caller's buffer needs to be.  This
    // depends on whether the caller specified full or node information
    // as well as the size of the variable size members of those
    // structures
    //

    if (KeyNodeInformation == KeyInformationClass) {

        PKEY_NODE_INFORMATION pNodeInformation;

        //
        // Copy fixed length pieces first -- caller expects them to
        // be set even when the variable length members are not large enough
        //

        //
        // Set ourselves to point to caller's buffer
        //
        pNodeInformation = (PKEY_NODE_INFORMATION) pDestKeyInfo;

        //
        // Copy all fixed-length pieces of structure
        //
        pNodeInformation->LastWriteTime = pTreeState->pKeyInfo->LastWriteTime;
        pNodeInformation->TitleIndex = pTreeState->pKeyInfo->TitleIndex;
        pNodeInformation->ClassOffset = pTreeState->pKeyInfo->ClassOffset;
        pNodeInformation->ClassLength = pTreeState->pKeyInfo->ClassLength;
        pNodeInformation->NameLength = pTreeState->pKeyInfo->NameLength;

        //
        // Take care of the size of the node information structure
        //
        cbNeeded = sizeof(KEY_NODE_INFORMATION);

        if (cbDestKeyInfo < cbNeeded) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Add in the size of the variable length members
        //
        cbNeeded += pTreeState->pKeyInfo->NameLength;
        cbNeeded += pTreeState->pKeyInfo->ClassLength;
        cbNeeded -= sizeof(WCHAR); // the structure's Name member is already set to 1,
                                   // so that one has already been accounted for in
                                   // the size of the structure

    } else {

        PKEY_BASIC_INFORMATION pBasicInformation;

        //
        // Copy fixed length pieces first -- caller expects them to
        // be set even when the variable length members are not large enough
        //

        //
        // Set ourselves to point to caller's buffer
        //
        pBasicInformation = (PKEY_BASIC_INFORMATION) pDestKeyInfo;

        //
        // Copy all fixed-length pieces of structure
        //
        pBasicInformation->LastWriteTime = pTreeState->pKeyInfo->LastWriteTime;
        pBasicInformation->TitleIndex = pTreeState->pKeyInfo->TitleIndex;
        pBasicInformation->NameLength = pTreeState->pKeyInfo->NameLength;


        cbNeeded = sizeof(KEY_BASIC_INFORMATION);

        //
        // Take care of the size of the basic information structure
        //
        if (cbDestKeyInfo < cbNeeded) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Add in the size of the variable length members
        //
        cbNeeded += pTreeState->pKeyInfo->NameLength;
        cbNeeded -= sizeof(WCHAR); // the structure's Name member is already set to 1,
                                   // so that one has already been accounted for in
                                   // the size of the structure
    }

    //
    // Store the amount needed for the caller
    //
    *pcbResult = cbNeeded;

    //
    // See if the caller supplied enough buffer -- leave if not
    //
    if (cbDestKeyInfo < cbNeeded) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // We copy variable-length information differently depending
    // on which type of structure was passsed in
    //
    if (KeyNodeInformation == KeyInformationClass) {

        PBYTE                 pDestClass;
        PBYTE                 pSrcClass;
        PKEY_NODE_INFORMATION pNodeInformation;

        pNodeInformation = (PKEY_NODE_INFORMATION) pDestKeyInfo;

        //
        // Copy variable length pieces such as name and class
        //
        RtlCopyMemory(pNodeInformation->Name,
                      pTreeState->pKeyInfo->Name,
                      pTreeState->pKeyInfo->NameLength);

        //
        // Only copy the class if it exists
        //
        if (((LONG)pTreeState->pKeyInfo->ClassOffset) >= 0) {
            pDestClass = ((PBYTE) pNodeInformation) + pTreeState->pKeyInfo->ClassOffset;
            pSrcClass = ((PBYTE) pTreeState->pKeyInfo) + pTreeState->pKeyInfo->ClassOffset;
            RtlCopyMemory(pDestClass, pSrcClass, pTreeState->pKeyInfo->ClassLength);
        }

    } else {

        PKEY_BASIC_INFORMATION pBasicInformation;

        //
        // Set ourselves to point to caller's buffer
        //
        pBasicInformation = (PKEY_BASIC_INFORMATION) pDestKeyInfo;

        //
        // Copy variable length pieces -- only name is variable length
        //
        RtlCopyMemory(pBasicInformation->Name,
                      pTreeState->pKeyInfo->Name,
                      pTreeState->pKeyInfo->NameLength);

    }

    return STATUS_SUCCESS;
}



NTSTATUS EnumClassKey(
    HKEY              hKey,
    EnumSubtreeState* pTreeState)
/*++

Routine Description:

    Enumerates a subkey for a subtree state -- calls the kernel

Arguments:

    hKey - key we want the kernel to enumerate
    pTreeState - subtree state -- either a user or machine subtree

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    PKEY_NODE_INFORMATION pCurrentKeyInfo;
    NTSTATUS Status;

    ASSERT(!(pTreeState->pKeyInfo));

    //
    // First try to use the buffer built in to the subtree state
    //
    pCurrentKeyInfo = (PKEY_NODE_INFORMATION) pTreeState->KeyInfoBuffer;

    //
    // Query for the necessary information about the supplied key.
    //

    Status = NtEnumerateKey( hKey,
                             pTreeState->iSubKey,
                             KeyNodeInformation,
                             pCurrentKeyInfo,
                             sizeof(pTreeState->KeyInfoBuffer),
                             &(pTreeState->cbKeyInfo));

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    //
    // If the subtree state's buffer isn't big enough, we'll have
    // to ask the heap to give us one.
    //
    if (STATUS_BUFFER_OVERFLOW == Status) {

        pCurrentKeyInfo = RegClassHeapAlloc(pTreeState->cbKeyInfo);
        //
        // If the memory allocation fails, return a Registry Status.
        //
        if( ! pCurrentKeyInfo ) {
            return STATUS_NO_MEMORY;
        }

        //
        // Query for the necessary information about the supplied key.
        //

        Status = NtEnumerateKey( hKey,
                                 pTreeState->iSubKey,
                                 KeyNodeInformation,
                                 pCurrentKeyInfo,
                                 pTreeState->cbKeyInfo,
                                 &(pTreeState->cbKeyInfo));

    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // set the subtree state's reference to point
    // to the location of the data
    //
    pTreeState->pKeyInfo = pCurrentKeyInfo;

    return STATUS_SUCCESS;
}


NTSTATUS GetSubKeyCount(
    HKEY    hkClassKey,
    LPDWORD pdwUserSubKeys)
/*++

Routine Description:

    Counts the number of subkeys under a key

Arguments:

    hkClassKey - key whose subkeys we wish to count
    pdwUserSubKeys - out param for number of subkeys

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS                Status;
    PKEY_CACHED_INFORMATION  KeyCachedInfo;
    ULONG                   BufferLength;
    BYTE                    PrivateKeyCachedInfo[ sizeof( KEY_CACHED_INFORMATION ) ];

    //
    // Initialize out params
    //
    *pdwUserSubKeys = 0;

    //
    // Set up to query kernel for subkey information
    //
    KeyCachedInfo = (PKEY_CACHED_INFORMATION) PrivateKeyCachedInfo;
    BufferLength = sizeof(PrivateKeyCachedInfo);

    Status = QueryKeyInfo(
                hkClassKey,
                KeyCachedInformation,
                &KeyCachedInfo,
                BufferLength,
                FALSE,
                0
                );

    if (NT_SUCCESS(Status)) {
        //
        // set the out param with the subkey data from the kernel call
        //
        *pdwUserSubKeys = KeyCachedInfo->SubKeys;

        ASSERT( KeyCachedInfo == ( PKEY_CACHED_INFORMATION )PrivateKeyCachedInfo );
    }

    return Status;

}


NTSTATUS ClassKeyCountSubKeys(
    HKEY    hKey,
    HKEY    hkUser,
    HKEY    hkMachine,
    DWORD   cMax,
    LPDWORD pcSubKeys)
/*++

Routine Description:

    Counts the total number of subkeys of a special key -- i.e.
    the sum of the subkeys in the user and machine portions
    of that special key minus duplicates.

Arguments:

    hkUser - user part of special key

    hkMachine - machine part of special key

    cMax - Maximum number of keys to count -- if
        zero, this is ignored

    pcSubKeys - out param -- count of subkeys

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

    This is INCREDIBLY expensive if either hkUser or hkMachine
    has more than a few subkeys.  It essentially merges two
    sorted lists by enumerating in both the user and machine
    locations, and viewing them as a merged list by doing
    comparisons betweens items in each list --
    separate user and machine pointers are advanced according
    to the results of the comparison. This means that if there are
    N keys under hkUser and M keys under hkMachine, this function
    will make N+M calls to the kernel to enumerate the keys.

    This is currently the only way to do this -- before, an approximation
    was used in which the sum of the number of subkeys in the
    user and machine versions was returned.  This method didn't take
    duplicates into account, and so it overestimated the number of keys.
    This was not thought to be a problem since there is no guarantee
    to callers that the number they receive is completely up to date,
    but it turns out that there are applications that make that assumption
    (such as regedt32) that do not function properly unless the
    exact number is returned.

--*/
{
    NTSTATUS          Status;
    BOOL              fCheckUser;
    BOOL              fCheckMachine;
    EnumSubtreeState  UserTree;
    EnumSubtreeState  MachineTree;
    DWORD             cMachineKeys;
    DWORD             cUserKeys;
    OBJECT_ATTRIBUTES Obja;
    HKEY              hkUserCount;
    HKEY              hkMachineCount;
    HKEY              hkNewKey;

    UNICODE_STRING EmptyString = {0, 0, 0};

    Status = STATUS_SUCCESS;

    hkNewKey = NULL;

    cMachineKeys = 0;
    cUserKeys = 0;

    //
    // Initialize ourselves to check in both the user
    // and machine hives for subkeys
    //
    fCheckUser = (hkUser != NULL);
    fCheckMachine = (hkMachine != NULL);

    memset(&UserTree, 0, sizeof(UserTree));
    memset(&MachineTree, 0, sizeof(MachineTree));

    //
    // We can't be sure that the user key was opened
    // with the right permissions so we'll open
    // a version that has the correct permissions
    //
    if (fCheckUser && (hkUser == hKey)) {
     
        InitializeObjectAttributes(
            &Obja,
            &EmptyString,
            OBJ_CASE_INSENSITIVE,
            hkUser,
            NULL);

        Status = NtOpenKey(
            &hkNewKey,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
            &Obja);
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        hkUserCount = hkNewKey;
    } else {
        hkUserCount = hkUser;
    }

    if (fCheckMachine && (hkMachine == hKey)) {
     
        InitializeObjectAttributes(
            &Obja,
            &EmptyString,
            OBJ_CASE_INSENSITIVE,
            hkMachine,
            NULL);

        Status = NtOpenKey(
            &hkNewKey,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
            &Obja);
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        hkMachineCount = hkNewKey;
    } else {
        hkMachineCount = hkMachine;
    }

    //
    // Now check to see how many keys are in the user subtree
    //
    if (fCheckUser) {
        Status = GetSubKeyCount(hkUserCount, &cUserKeys);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // We only need to enumerate the user portion if it has subkeys
        //
        fCheckUser = (cUserKeys != 0);
    }

    //
    // Now check to see how many keys are in the user subtree
    //
    if (fCheckMachine) {
        Status = GetSubKeyCount(hkMachineCount, &cMachineKeys);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // We only need to enumerate the machine portion if it has subkeys
        //
        fCheckMachine = (cMachineKeys != 0);
    }

    if (!fCheckUser) {

        *pcSubKeys = cMachineKeys;

        Status = STATUS_SUCCESS;
        
        goto cleanup;
    }

    if (!fCheckMachine) {

        *pcSubKeys = cUserKeys;

        Status = STATUS_SUCCESS;

        goto cleanup;
    }

    ASSERT(fCheckMachine && fCheckUser);

    *pcSubKeys = 0;

    //
    // Keep enumerating subkeys until one of the locations
    // runs out of keys
    //
    for (;;) {

        NTSTATUS EnumStatus;

        //
        // If we can still check in the user hive and we
        // are missing user key info, query the kernel for it
        //
        if (!(UserTree.pKeyInfo)) {
            EnumStatus = EnumClassKey(
                hkUserCount,
                &UserTree);

            //
            // If there are no more user subkeys, set our
            // flag so that we no longer look in the user portion
            // for subkeys
            //
            if (!NT_SUCCESS(EnumStatus)) {
                if (STATUS_NO_MORE_ENTRIES == EnumStatus) {

                    *pcSubKeys += cMachineKeys;
                    Status = STATUS_SUCCESS;
                    break;

                } else {
                    Status = EnumStatus;
                    break;
                }
            }
        }

        //
        // if we can still check in the machine hive and
        // we are missing machine info, query for it
        //
        if (!(MachineTree.pKeyInfo)) {

            EnumStatus = EnumClassKey(
                hkMachineCount,
                &MachineTree);

            //
            // Turn off checking in machine if there are
            // no more machine keys
            //
            if (!NT_SUCCESS(EnumStatus)) {
                if (STATUS_NO_MORE_ENTRIES == EnumStatus) {

                    *pcSubKeys += cUserKeys;
                    Status = STATUS_SUCCESS;
                    break;

                } else {
                    Status = EnumStatus;
                    break;
                }
            }
        }

        //
        // If we have keys in both user and machine, we need to compare
        // the key names to see when to advance our subtree pointers
        //
        {

            LONG lCompare;

            UNICODE_STRING MachineKeyName;
            UNICODE_STRING UserKeyName;

            MachineKeyName.Buffer = MachineTree.pKeyInfo->Name;
            MachineKeyName.Length = (USHORT) MachineTree.pKeyInfo->NameLength;

            UserKeyName.Buffer = UserTree.pKeyInfo->Name;
            UserKeyName.Length = (USHORT) UserTree.pKeyInfo->NameLength;

            //
            // Do the comparison of user and machine keys
            //
            lCompare =
                RtlCompareUnicodeString(&UserKeyName, &MachineKeyName, TRUE);

            //
            // User is smaller, so move our user pointer up and clear it
            // so we'll query for user data next time
            //
            if (lCompare <= 0) {
                EnumSubtreeStateClear(&UserTree);
                UserTree.iSubKey++;
                cUserKeys--;
            }

            //
            // Machine is smaller, so move our user pointer up and clear it
            // so we'll query for machine data next time
            //
            if (lCompare >= 0) {
                EnumSubtreeStateClear(&MachineTree);
                MachineTree.iSubKey++;
                cMachineKeys--;
            }

            //
            // Increase the total number of subkeys
            //
            (*pcSubKeys)++;

        }

        //
        // Only enumerate up to max -- the caller
        // doesn't need to go all the way to the end
        //
        if (cMax && (*pcSubKeys > cMax)) {
            break;
        }
    }

    //
    // Free any buffer held by these subtree states
    //
    EnumSubtreeStateClear(&UserTree);
    EnumSubtreeStateClear(&MachineTree);

cleanup:

    if (hkNewKey) {
        NtClose(hkNewKey);
    }

    return Status;
}

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regkey.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry APIs to open, create, flush and close keys.  That is:

        - BaseRegCloseKey
        - BaseRegCreateKey
        - BaseRegFlushKey
        - BaseRegOpenKey

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    These notes apply to the Win32 Registry API implementation as a whole
    and not just to this module.

    On the client side, modules contain RPC wrappers for both the new
    Win32 and compatible Win 3.1 APIs.  The Win 3.1 wrappers generally
    supply default parameters before calling the Win32 wrappers.  In some
    cases they may need to call multiple Win32 wrappers in order to
    function correctly (e.g.  RegSetValue sometimes needs to call
    RegCreateKeyEx).  The Win32 wrappers are quite thin and usually do
    nothing more than map a predefined handle to a real handle and perform
    ANSI<->Unicode translations.  In some cases (e.g.  RegCreateKeyEx) the
    wrapper also converts some argument (e.g.  SECURITY_ATTRIBUTES) to an
    RPCable representation.  In both the Win 3.1 and Win32 cases ANSI and
    Unicode implementations are provided.

    On the server side, there is one entry point for each of the Win32
    APIs.  Each contains an identical interface with the client side
    wrapper with the exception that all string / count arguments are
    passed as a single counted Unicode string.  Pictorially, for an API
    named "F":

                RegWin31FA()          RegWin31FW()      (client side)

                    |                     |
                    |                     |
                    |                     |
                    |                     |
                    V                     V

                RegWin32FExA()        RegWin32FExW()

                    |                     |
                    ^                     ^
                    v                     v             (RPC)
                    |                     |
                    |                     |
                    +----> BaseRegF() <---+             (server side)


    This yields smaller code (as the string conversion is done only once
    per API) at the cost of slightly higher maintenance (i.e. Win 3.1
    default parameter replacement and Win32 string conversions must be
    manually kept in synch).

    Another option would be to have a calling sequence that looks like,

                RegWin31FA()          RegWin31FW()

                    |                     |
                    |                     |
                    |                     |
                    V                     V

                RegWin32FExA() -----> RegWin32FExW()

    and have the RegWin32FExW() API perform all of the actual work.  This
    method is generally less efficient.  It requires the RegWin32FExA()
    API to convert its ANSI string arguments to counted Unicode strings,
    extract the buffers to call the RegWin32FExW() API only to have it
    rebuild a counted Unicode string.  However in some cases (e.g.
    RegConnectRegistry) where a counted Unicode string was not needed in
    the Unicode API this method is used.

    Details of an API's functionality, arguments and return value can be
    found in the base implementations (e.g.  BaseRegF()).  All other
    function headers contain only minimal routine descriptions and no
    descriptions of their arguments or return value.

    The comment string "Win3.1ism" indicates special code for Win 3.1
    compatability.

    Throughout the implementation the following variable names are used
    and always refer to the same thing:

        Obja        - An OBJECT_ATTRIBUTES structure.
        Status      - A NTSTATUS value.
        Error       - A Win32 Registry error code (n.b. one of the error
                      values is ERROR_SUCCESS).

--*/

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include "regsec.h"
#include <malloc.h>

#ifdef LOCAL
#include "tsappcmp.h"

#ifdef LEAK_TRACK
#include "regleak.h"
#endif // LEAK_TRACK

#endif

NTSTATUS
BaseRegCreateMultipartKey(
    IN HKEY hkDestKey,
    IN PUNICODE_STRING pDestSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL,
    ULONG             Attributes);


#if DBG
extern HANDLE RestrictedMachineHandle;
#endif

NTSTATUS
OpenMachineKey(PHANDLE phKey);

BOOL
InitializeRegCreateKey(
    )

/*++

Routine Description:

    This function was used to initialize a critical section that no longer
    exists. This critical section was used when a key name '\', and multiple
    multiple keys were to be created. The API used the wcstok defined in the
    kernel, which was not multi-threaded safe.

    This function now will always return TRUE. It will not be removed from the code
    to avoid change in the rpc interface.

Arguments:

    None.

Return Value:

    Returns TRUE always.

--*/

{
    return( TRUE );

}



BOOL
CleanupRegCreateKey(
    )

/*++

Routine Description:

    This function was used to clean up a critical section that no longer
    exists. This critical section was used when a key name '\', and multiple
    multiple keys were to be created. The API used the wcstok defined in the
    kernel, which was not multi-threaded safe.

    This function now will always return TRUE. It will not be removed from the code
    to avoid change in the rpc interface.



Arguments:

    None.

Return Value:

    Returns TRUE if the cleanup succeeds.

--*/

{
    return( TRUE );
}



error_status_t
BaseRegCloseKeyInternal(
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes a key handle.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS Status;
#if defined(LEAK_TRACK)
    BOOL fTrack;
#endif // defined(LEAK_TRACK)

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( *phKey == HKEY_PERFORMANCE_DATA ) ||
       ( *phKey == HKEY_PERFORMANCE_TEXT ) ||
       ( *phKey == HKEY_PERFORMANCE_NLSTEXT )) {

        Status = PerfRegCloseKey( phKey );
        return (error_status_t)Status;
    }

    ASSERT( IsPredefinedRegistryHandle( *phKey ) == FALSE );

#ifndef LOCAL
    //
    // Quick check for a "restricted" handle; then this turns to noop as the global restricted handle will 
	// be cleaned up when the service is terminated 
    //
    if ( REGSEC_CHECK_HANDLE( *phKey ) )
    {
        *phKey = REGSEC_CLEAR_HANDLE( *phKey );
        ASSERT( RestrictedMachineHandle == *phKey );
        *phKey = NULL;
        return ERROR_SUCCESS;
    }

#endif //LOCAL

#ifdef LOCAL
    //
    // now we need to remove any state for registry key enumeration associated
    // with this key if it's a class registration parent
    //
    if (REG_CLASS_IS_SPECIAL_KEY(*phKey)) {

        // this may not succeed since someone could have already removed this key
        (void) EnumTableRemoveKey(
            &gClassesEnumTable,
            *phKey,
            ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD);
    }

#if defined(LEAK_TRACK)

    if (g_RegLeakTraceInfo.bEnableLeakTrack) {
        fTrack = RegLeakTableIsTrackedObject(&gLeakTable, *phKey);
    }

#endif // defined(LEAK_TRACK)

#endif // LOCAL


    Status = NtClose( *phKey );

    if( NT_SUCCESS( Status )) {

#ifdef LOCAL
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            if (fTrack) {
                (void) UnTrackObject(*phKey);
            }
        }

#endif // defined(LEAK_TRACK)
#endif // LOCAL

        //
        // Set the handle to NULL so that RPC knows that it has been closed.
        //
        *phKey = NULL;

        return ERROR_SUCCESS;

    } else {

        return (error_status_t)RtlNtStatusToDosError( Status );
    }
}



error_status_t
BaseRegCloseKey(
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes a key handle.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    error_status_t Error;

#ifndef LOCAL
    RPC_STATUS _rpcstatus = RpcImpersonateClient( NULL );
#if DBG
    if( _rpcstatus != ERROR_SUCCESS ) {
        DbgPrint("WINREG: BaseRegCloseKey: Failed to impersonate in process %p, thread %p, for handle %p \n",NtCurrentProcess(),NtCurrentThread(),*phKey);
    }
#endif
#endif //LOCAL

    Error = BaseRegCloseKeyInternal(phKey);

#ifndef LOCAL

#if DBG
    if( Error != ERROR_SUCCESS ) {
        DbgPrint("WINREG: BaseRegCloseKeyInternal without impersonation returned %lx\n",Error);
    }
#endif

    if (_rpcstatus == ERROR_SUCCESS) {
        _rpcstatus = RpcRevertToSelf();
    }
#endif

    return Error;
}


error_status_t
BaseRegCreateKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL
    )

/*++

Routine Description:

    Create a new key, with the specified name, or open an already existing
    key.  RegCreateKeyExW is atomic, meaning that one can use it to create
    a key as a lock.  If a second caller creates the same key, the call
    will return a value that says whether the key already existed or not,
    and thus whether the caller "owns" the "lock" or not.  RegCreateKeyExW
    does NOT truncate an existing entry, so the lock entry may contain
    data.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey key path
        parameter is relative to this key handle.  Any of the predefined
        reserved handle values or a previously opened key handle may be used
        for hKey.

    lpSubKey - Supplies the downward key path to the key to create.
        lpSubKey is always relative to the key specified by hKey.
        This parameter may not be NULL.

    lpClass - Supplies the class (object type) of this key.  Ignored if
        the key already exists.  No class is associated with this key if
        this parameter is NULL.

    dwOptions - Supplies special options.  Only one is currently defined:

        REG_VOLATILE -  Specifies that this key should not be preserved
            across reboot.  The default is not volatile.  This is ignored
            if the key already exists.

        WARNING: All descendent keys of a volatile key are also volatile.

    samDesired - Supplies the requested security access mask.  This
        access mask describes the desired security access to the newly
        created key.

    lpSecurityAttributes - Supplies a pointer to a SECURITY_ATTRIBUTES
        structure for the newly created key. This parameter is ignored
        if NULL or not supported by the OS.

    phkResult - Returns an open handle to the newly created key.

    lpdwDisposition - Returns the disposition state, which can be one of:

            REG_CREATED_NEW_KEY - the key did not exist and was created.

            REG_OPENED_EXISTING_KEY - the key already existed, and was simply
                opened without being changed.

        This parameter is ignored if NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegCreateKeyEx creates the new key (or opens the key if
    it already exists), and returns an open handle to the newly created
    key in phkResult.  Newly created keys have no value; RegSetValue, or
    RegSetValueEx must be called to set values.  hKey must have been
    opened for KEY_CREATE_SUB_KEY access.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    ULONG               Attributes;
    NTSTATUS            Status;
#if DBG
    HANDLE              DebugKey = hKey;
#endif
    HKEY                hkDestKey;
    UNICODE_STRING      DestClassSubkey;
    PUNICODE_STRING     pDestSubkey;
    DWORD               dwDisposition;
    BOOL                fRetryOnAccessDenied;
    BOOL                fRetried;
    BOOL                fTrySingleCreate;
#if LOCAL
    SKeySemantics       keyinfo;
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN];
    REGSAM              OriginalSam = samDesired;
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string


    memset(&keyinfo, 0, sizeof(keyinfo));
#endif

#ifndef LOCAL
    BOOL                UseFakeMachineKey = FALSE;
#endif LOCAL

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );
    ASSERT( lpSubKey->Length > 0 );

    DestClassSubkey.Buffer = NULL;

    //
    // For class registrations, retry on access denied in machine hive --
    // if we do retry, this will be set to FALSE so we only retry once
    //
    fRetryOnAccessDenied = TRUE;
    fRetried = FALSE;

    //
    // First attempt should do create with a single ntcreatekey call
    // If that doesn't work, this gets set to false so we remember if we
    // have to retry for access denied in the machine hive
    //
    fTrySingleCreate = TRUE;

    hkDestKey = NULL;
    pDestSubkey = NULL;


    //
    // Check for malformed arguments from malicious clients
    //
    if( (lpSubKey == NULL) ||
        (lpSubKey->Length < sizeof(UNICODE_NULL)) ||
        (lpSubKey->Buffer == NULL) ||
        ((lpSubKey->Length % sizeof(WCHAR)) != 0) ||
        (lpSubKey->Buffer[lpSubKey->Length / sizeof(WCHAR) - 1] != L'\0') ||
        (phkResult == NULL) ||
        (lpClass == NULL) ||
        (lpClass->Length & 1) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Quick check for a "restricted" handle
    //
    if ( REGSEC_CHECK_HANDLE( hKey ) )
    {
        if ( ! REGSEC_CHECK_PATH( hKey, lpSubKey ) )
        {
            return( ERROR_ACCESS_DENIED );
        }

        hKey = REGSEC_CLEAR_HANDLE( hKey );
        ASSERT( RestrictedMachineHandle == hKey );
#ifndef LOCAL
        UseFakeMachineKey = TRUE;
#endif LOCAL
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Initialize the variable that will contain the handle to NULL
    //  to ensure that in case of error the API will not return a
    //  bogus handle. This is required otherwise RPC will get confused.
    //  Note that RPC should have already initialized it to 0.
    //
    *phkResult = NULL;

    //
    //  Subtract the NULLs from the Length of the provided strings.
    //  These were added on the client side so that the NULLs were
    //  transmitted by RPC.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

    if( lpSubKey->Buffer[0] == ( WCHAR )'\\' ) {
        //
        // Do not accept a key name that starts with '\', even though
        // the code below would handle it. This is to ensure that
        // RegCreateKeyEx and RegOpenKeyEx will behave in the same way
        // when they get a key name that starts with '\'.
        //
        Status = STATUS_OBJECT_PATH_INVALID;
        goto cleanup;
    }

    if ( lpClass->Length > 0 ) {
        lpClass->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Determine the correct set of attributes.
    //

    Attributes = OBJ_CASE_INSENSITIVE;

    if( ARGUMENT_PRESENT( pRpcSecurityAttributes )) {

        if( pRpcSecurityAttributes->bInheritHandle ) {

            Attributes |= OBJ_INHERIT;
        }
    }

    if (dwOptions & REG_OPTION_OPEN_LINK) {
        Attributes |= OBJ_OPENLINK;
    }

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION ) 
             && ExtractClassKey(&hKey,lpSubKey) ) ) {

        //
        // Find more information
        // about this key -- the most important piece of information
        // is whether it's a class registration key
        //
        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
        keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // see if this is a class registration
        //
        Status = BaseRegGetKeySemantics(hKey, lpSubKey, &keyinfo);

        // if we can't determine what type of key this is, leave
        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        Status = BaseRegMapClassRegistrationKey(
            hKey,
            lpSubKey,
            &keyinfo,
            &DestClassSubkey,
            &fRetryOnAccessDenied,
            &hkDestKey,
            &pDestSubkey);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

    } else
#endif // LOCAL
    {
#ifdef LOCAL
        memset(&keyinfo, 0, sizeof(keyinfo));
#endif // LOCAL

        hkDestKey = hKey;
        pDestSubkey = lpSubKey;
    }

#ifndef LOCAL
	//
	// open a new key in the caller's context
	//
    if( UseFakeMachineKey ) {
        Status = OpenMachineKey(&hkDestKey);
            if( !NT_SUCCESS(Status) ) {
            goto cleanup;
        }
        //
        // hkDestKey opened here will be used throught the function to perform the appropiate 
        // open and it'll be closed on cleanup path (see commented below at the end of the function)
        //
        //if (hkDestKey && (hkDestKey != hKey)) {
        //	NtClose(hkDestKey);
        //}

    }
#endif LOCAL

    for (;;) {

#ifdef LOCAL

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        if (fTrySingleCreate)
        {
#endif

            //
            // Validate the security descriptor.
            //
            if( ARGUMENT_PRESENT( pRpcSecurityAttributes ) &&
                pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor)
            {
                if( !RtlValidRelativeSecurityDescriptor((PSECURITY_DESCRIPTOR)(pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor),
                                                        pRpcSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
                                                        0 )) {
                    //
                    //  We were passed a bogus security descriptor to set.  Bail out
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            //
            // Try to create the specified key. This will work if there is only
            // one key being created or if the key already exists. If more than
            // one key needs to be created, this will fail and we will have to
            // do all the complicated stuff to create each intermediate key.
            //
            InitializeObjectAttributes(&Obja,
                                       pDestSubkey,
                                       Attributes,
                                       hkDestKey,
                                       ARGUMENT_PRESENT( pRpcSecurityAttributes )
                                       ? pRpcSecurityAttributes
                                       ->RpcSecurityDescriptor.lpSecurityDescriptor
                                       : NULL);
            Status = NtCreateKey(phkResult,
                                 samDesired,
                                 &Obja,
                                 0,
                                 lpClass,
                                 dwOptions,
                                 &dwDisposition);


#ifdef LOCAL
            if (gpfnTermsrvCreateRegEntry && NT_SUCCESS(Status) && (dwDisposition == REG_CREATED_NEW_KEY)) {
                //
                // Terminal Server application compatiblity
                // Store the newly created key in the Terminal Server registry tracking database
                //

                gpfnTermsrvCreateRegEntry(*phkResult,
                                          &Obja,
                                          0,
                                          lpClass,
                                          dwOptions);
            }

        }

#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
        if (fTrySingleCreate && (STATUS_ACCESS_DENIED == Status) && keyinfo._fCombinedClasses &&
            fRetryOnAccessDenied ) {

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            // we failed for some reason -- exit
            break;

        }
#else
        //if (it's terminal server; we're trying to create single key;
        //we've got ASSESS_DENIED trying to create key
        //a key we want to create is HKCR subkey(keyinfo._fCombinedClasses!=0);
        //Registry flag is set to allow per user classes redirection.
        //(fRetryOnAccessDenied !=0 - means that parent key is not in the user hive))
        //then try to create the key in the user hive.
        if ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION) 
             && fTrySingleCreate && (STATUS_ACCESS_DENIED == Status)
                && keyinfo._fCombinedClasses && fRetryOnAccessDenied 
           ) {


                if (DestClassSubkey.Buffer) {
                    RegClassHeapFree(DestClassSubkey.Buffer);
                    DestClassSubkey.Buffer=NULL;
                }

                Status = BaseRegMapClassOnAccessDenied(
                        &keyinfo,
                        &hkDestKey,
                        pDestSubkey,
                        &fRetryOnAccessDenied);

                if (NT_SUCCESS(Status)) {
                    fRetried = TRUE;
                    continue;
                }

            // we failed for some reason -- exit
            break;

        }
#endif // CLASSES_RETRY_ON_ACCESS_DENIED
#endif // LOCAL

        fTrySingleCreate = FALSE;

        if (NT_SUCCESS(Status)) {

            if (lpdwDisposition) {
                *lpdwDisposition = dwDisposition;
            }

        } else {

            Status = BaseRegCreateMultipartKey(
                hkDestKey,
                pDestSubkey,
                lpClass,
                dwOptions,
                samDesired,
                pRpcSecurityAttributes,
                phkResult,
                lpdwDisposition,
                Attributes);
        }

#ifdef LOCAL
#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
        if ((STATUS_ACCESS_DENIED == Status) && keyinfo._fCombinedClasses &&
            fRetryOnAccessDenied ) {

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            break;

        }
#else
        //We've tried to create single key and failed (Status !=STATUS_ACCESS_DENIED)
        //then we tried to create multipart key and got access denied
        //thus we've got here
        if ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION) 
             && (STATUS_ACCESS_DENIED == Status) 
             && keyinfo._fCombinedClasses && fRetryOnAccessDenied 
           ) {

            if (DestClassSubkey.Buffer) {
                RegClassHeapFree(DestClassSubkey.Buffer);
                DestClassSubkey.Buffer=NULL;
            }

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            break;

        }
#endif //  CLASSES_RETRY_ON_ACCESS_DENIED

        if (NT_SUCCESS(Status)) {
            if (keyinfo._fCombinedClasses) {
                // mark this key as part of hkcr
                *phkResult = REG_CLASS_SET_SPECIAL_KEY(*phkResult);
            }
        }

#endif // LOCAL

        break;
    }

cleanup:


#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
    //
    // Memory was allocated if we retried, so free it
    //
    if (fRetried && pDestSubkey->Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pDestSubkey->Buffer);
        pDestSubkey->Buffer = NULL;
    }
#endif // CLASSES_RETRY_ON_ACCESS_DENIED

    if (hkDestKey && (hkDestKey != hKey)) {
        NtClose(hkDestKey);
    }

#ifdef LOCAL
    if (DestClassSubkey.Buffer) {
        RegClassHeapFree(DestClassSubkey.Buffer);
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    *lpSubKey = TmpStr; //restore original SubKey string
#endif // LOCAL

    if (NT_SUCCESS(Status)) {
#ifdef LOCAL
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }

#endif // defined(LEAK_TRACK)
#endif LOCAL
        // disabled, for the case where we specifically close a predefined key inside 
		// RegOpenKeyExA and RegOpenKeyExW
		//ASSERT( *phkResult != DebugKey );
    }

    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );

}



NTSTATUS
BaseRegCreateMultipartKey(
    IN HKEY hkDestKey,
    IN PUNICODE_STRING pDestSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL,
    ULONG             Attributes)
/*++

Routine Description:

    This function creates registry keys for which multiple path components
    are nonexistent.  It parses the key path and creates each intermediate
    subkey.

Arguments:

    See BaseRegCreateKey.

Return Value:

    Returns STATUS_SUCCESS on success, other NTSTATUS if failed.

--*/
{
    LPWSTR            KeyBuffer;
    ULONG             NumberOfSubKeys;
    LPWSTR            p;
    ULONG             i;
    LPWSTR            Token;
    UNICODE_STRING    KeyName;
    HANDLE            TempHandle1;
    HANDLE            TempHandle2;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    DWORD             dwDisposition;
#ifdef LOCAL
    REGSAM            OriginalSam = samDesired;
#endif // LOCAL

    dwDisposition = REG_OPENED_EXISTING_KEY;
    TempHandle1 = NULL;

    //
    // Win3.1ism - Loop through each '\' separated component in the
    // supplied sub key and create a key for each component. This is
    // guaranteed to work at least once because lpSubKey was validated
    // on the client side.
    //


    //
    // Initialize the buffer to be tokenized.
    //

    KeyBuffer = pDestSubKey->Buffer;

    //
    //  Find out the number of subkeys to be created
    //
    NumberOfSubKeys = 1;
    p = KeyBuffer;
    while ( ( p = wcschr( p, ( WCHAR )'\\' ) ) != NULL ) {
        p++;
        NumberOfSubKeys++;
    }

    for( i = 0, Token = KeyBuffer; i < NumberOfSubKeys; i++ ) {

        ASSERT(Token != NULL);

        if( ( *Token == ( WCHAR )'\\' ) &&
            ( i != NumberOfSubKeys - 1 ) ) {
            //
            //  If the first character of the key name is '\', and the key
            //  is not the last to be created, then ignore this key name.
            //  This condition can happen if the key name contains
            //  consecutive '\'.
            //  This behavior is consistent with the one we had in the past
            //  when the API used wcstok() to get the key names.
            //  Note that if the key name is an empty string, we return a handle
            //  that is different than hKey, even though both point to the same
            //  key. This is by design.
            //
            Token++;
            continue;
        }

        //
        // Convert the token to a counted Unicode string.
        //
        KeyName.Buffer = Token;
        if (i == NumberOfSubKeys - 1) {
            KeyName.Length = wcslen(Token)*sizeof(WCHAR);
        } else {
            KeyName.Length = (USHORT)(wcschr(Token, ( WCHAR )'\\') - Token)*sizeof(WCHAR);
        }

        //
        // Remember the intermediate handle (NULL the first time through).
        //

        TempHandle2 = TempHandle1;

        {
            //
            // Initialize the OBJECT_ATTRIBUTES structure, close the
            // intermediate key and create or open the key.
            //

            InitializeObjectAttributes(
                &Obja,
                &KeyName,
                Attributes,
                hkDestKey,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                ? pRpcSecurityAttributes
                ->RpcSecurityDescriptor.lpSecurityDescriptor
                : NULL
                );

            Status = NtCreateKey(
                &TempHandle1,
                ( i == NumberOfSubKeys - 1 )? samDesired : 
                    (samDesired & KEY_WOW64_RES) | MAXIMUM_ALLOWED,
                &Obja,
                0,
                lpClass,
                dwOptions,
                &dwDisposition
                );

            if (NT_SUCCESS(Status) && lpdwDisposition) {
                *lpdwDisposition = dwDisposition;
            }

#ifdef LOCAL
            // This code is in Hydra 4. We have disabled this for NT 5
            // for now till we are sure that its needed to get some imporatant
            // app to work on Hydra 5. Otherwise this should be removed
            if ( gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION ) {

                // For Terminal Server only.
                // Some apps try to create/open the key with all of the access bits
                // turned on.  We'll mask off the ones they don't have access to by
                // default, (at least under HKEY_LOCAL_MACHINE\Software) and try to
                // open the key again.
                if (Status == STATUS_ACCESS_DENIED) {
                    //MAXIMUM_ALLOWED does not include ACCESS_SYSTEM_SECURITY
                    //so if user asks for this permission, we need to add it.
                    //It could result in ACCESS_DENIED error but for 
                    //TS App. Compat. it is not important.
                    Status = NtCreateKey(
                            &TempHandle1,
                            (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY) ) | MAXIMUM_ALLOWED,
                            &Obja,
                            0,
                            lpClass,
                            dwOptions,
                            &dwDisposition);

                        // Give app back the original error
                        if (!NT_SUCCESS(Status)) {
                            Status = STATUS_ACCESS_DENIED;
                        }

                        if (lpdwDisposition) {
                             *lpdwDisposition = dwDisposition;
                        }
                }
            }


            if (gpfnTermsrvCreateRegEntry && NT_SUCCESS(Status) && (dwDisposition == REG_CREATED_NEW_KEY)) {

                //
                // Terminal Server application compatiblity
                // Store the newly created key in the Terminal Server registry tracking database
                //
                gpfnTermsrvCreateRegEntry(TempHandle1,
                                          &Obja,
                                          0,
                                          lpClass,
                                          dwOptions);
            }
#endif
        }

        //
        // Initialize the next object directory (i.e. parent key) handle.
        //

        hkDestKey = TempHandle1;

        //
        // Close the intermediate key.
        // This fails the first time through the loop since the
        // handle is NULL.
        //

        if( TempHandle2 != NULL ) {
            NtClose( TempHandle2 );
        }

        //
        // If creating the key failed, map and return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            return Status;
        }

        Token = wcschr( Token, ( WCHAR )'\\') + 1;

    }

    //
    // Only set the return value once we know we've
    // succeeded.
    //
    *phkResult = hkDestKey;

    return STATUS_SUCCESS;
}



error_status_t
BaseRegFlushKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Flush changes to backing store.  Flush will not return until the data
    has been written to backing store.  It will flush all the attributes
    of a single key.  Closing a key without flushing it will NOT abort
    changes.

Arguments:

    hKey - Supplies a handle to the open key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegFlushKey will flush to backing store any changes
    made to the key.

Notes:

    RegFlushKey may also flush other data in the Registry, and therefore
    can be expensive, it should not be called gratuitously.

--*/

{
    if ((hKey == HKEY_PERFORMANCE_DATA) ||
        (hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        return(ERROR_SUCCESS);
    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );


    //
    // Call the Nt Api to flush the key, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

    return (error_status_t)RtlNtStatusToDosError( NtFlushKey( hKey ));
}

error_status_t
BaseRegOpenKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Open a key for access, returning a handle to the key.  If the key is
    not present, it is not created (see RegCreateKeyExW).

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.  Any of the predefined
        reserved handle values or a previously opened key handle may be used
        for hKey.  NULL is not permitted.

    lpSubKey - Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    dwOptions -- reserved.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegOpenKeyEx will return the handle to the newly opened
    key in phkResult.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status = STATUS_OBJECT_NAME_NOT_FOUND;
    error_status_t      ret = ERROR_SUCCESS;
#ifdef LOCAL
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string
#endif

#ifndef LOCAL
    BOOL                UseFakeMachineKey = FALSE;
#endif

    UNREFERENCED_PARAMETER( dwOptions );

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

    //
    // Check for malformed arguments from malicious clients
    //
    if( (lpSubKey == NULL) ||
        (lpSubKey->Length < sizeof(UNICODE_NULL)) ||
        ((lpSubKey->Length % sizeof(WCHAR)) != 0) ||
        (phkResult == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Need to NULL this out param for compat with NT4, even though SDK
    // does not define this out param on api failure -- bad apps were written
    // which rely on this.  Used to get NULLed by call to NtOpenKey, but since
    // we don't always call that now, we need to do this here in user mode.  Also
    // need an exception wrapper since NtOpenKey would simply return an error if
    // the pointer were invalid, whereas in user mode we access violate if we simply
    // assign -- yet another fix needed for app compatibility as some apps on NT 4
    // were actually passing in a bad pointer and ignoring the error returned
    // by the api as part of their normal operation.
    //

    __try {

        *phkResult = NULL;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();

#if DBG
        DbgPrint( "WINREG Error: Exception %x in BaseRegOpenKey\n",
                  Status );
#endif
        ret = RtlNtStatusToDosError( Status );
    }

    //
    // This will only be true if there was an exception above --
    // return the exception code as an error
    //

    if (ERROR_SUCCESS != ret) {
        return ret;
    }

    //
    // Quick check for a "restricted" handle
    //

    if ( REGSEC_CHECK_HANDLE( hKey ) )
    {
        if ( ! REGSEC_CHECK_PATH( hKey, lpSubKey ) )
        {
            return( ERROR_ACCESS_DENIED );
        }

        hKey = REGSEC_CLEAR_HANDLE( hKey );
        ASSERT( RestrictedMachineHandle == hKey );
#ifndef LOCAL
        UseFakeMachineKey = TRUE;
#endif LOCAL
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

#ifndef LOCAL
	//
	// open a new key in the caller's context
	//
    if( UseFakeMachineKey ) {
        Status = OpenMachineKey(&hKey);
        if( !NT_SUCCESS(Status) ) {
            ret = RtlNtStatusToDosError( Status );
            RPC_REVERT_TO_SELF();
            return ret;
        }
    }
#endif LOCAL
    //
    //  Subtract the NULLs from the Length of the provided string.
    //  This was added on the client side so that the NULL was
    //  transmited by RPC.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        lpSubKey,
        dwOptions & REG_OPTION_OPEN_LINK ? (OBJ_OPENLINK | OBJ_CASE_INSENSITIVE)
        : OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

#ifdef LOCAL
    if ( REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION)
          && ExtractClassKey(&hKey,lpSubKey) ) ) {
        Status = BaseRegOpenClassKey(
            hKey,
            lpSubKey,
            dwOptions,
            samDesired,
            phkResult);

    } else
#endif // LOCAL
    {
        //
        // Obja was initialized above
        //

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);
    }

#ifndef LOCAL
	//
	// close the fake machine key
	//
    if( UseFakeMachineKey ) {
        NtClose(hKey);
    }
#endif LOCAL

    RPC_REVERT_TO_SELF();

    ret = (error_status_t)RtlNtStatusToDosError( Status );

#ifdef LOCAL
    if (STATUS_ACCESS_DENIED == Status)
    {
        //If key could not be opened with SamDesired access
        //open it with MAXIMUM_ALLOWED.
        //do it only if it's terminal server and proper
        //flag is set in the registry.
        if ( gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION )
        {
            {
                //MAXIMUM_ALLOWED does not include ACCESS_SYSTEM_SECURITY
                //so if user asks for this permission, we need to add it.
                //It could result in ACCESS_DENIED error but for 
                //TS App. Compat. it is not important.
                if(REG_CLASS_IS_SPECIAL_KEY(hKey))
                {
                    Status = BaseRegOpenClassKey(
                                hKey,
                                lpSubKey,
                                dwOptions,
                                (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY)) | MAXIMUM_ALLOWED,
                                phkResult);
                }
                else
                {
                    Status = NtOpenKey(
                            phkResult,
                            (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY)) | MAXIMUM_ALLOWED,
                            &Obja); 
                }


                // Give app back the original error
                if (!NT_SUCCESS(Status)) {
                    Status = STATUS_ACCESS_DENIED;
                }
                ret = (error_status_t)RtlNtStatusToDosError( Status );
            }

        }
    }


    if ((!REG_CLASS_IS_SPECIAL_KEY(hKey)) && !NT_SUCCESS(Status) && gpfnTermsrvOpenRegEntry) {

        //
        // Obja was initialized above
        //

        if (gpfnTermsrvOpenRegEntry(phkResult,
                                    samDesired,
                                    &Obja)) {
            Status = STATUS_SUCCESS;
            ret = (error_status_t)RtlNtStatusToDosError( Status );
        }
    }
#if defined(LEAK_TRACK)

    if (g_RegLeakTraceInfo.bEnableLeakTrack) {
        if (ERROR_SUCCESS == ret) {
            (void) TrackObject(*phkResult);
        }
    }

#endif (LEAK_TRACK)

    *lpSubKey = TmpStr; //Restore original SubKey string

#endif // LOCAL

    return ret;
}

//
// BaseRegGetVersion - new for Chicago to determine what version a registry
//                                              key is connected to.
//

error_status_t
BaseRegGetVersion(
    IN HKEY hKey,
    OUT LPDWORD lpdwVersion
    )
/*++

Routine Description:

    New for Win95, allows a caller to determine what version a registry
    key is connected to.

Arguments:

    hKey - Supplies a handle to an open key.

    lpdwVersion - Returns the registry version.

Return Value:

    Returns ERROR_SUCCESS (0) for success;

    If successful, BaseRegGetVersion returns the registry version in lpdwVersion

--*/
{
    if (lpdwVersion != NULL) {
        *lpdwVersion = REMOTE_REGISTRY_VERSION;
        return(ERROR_SUCCESS);
    }
    //
    // ERROR_NOACCESS is kind of a weird thing to return,
    // but we want to return something different in the
    // NULL case because that is how we tell whether we
    // are talking to a Win95 machine. Win95's implementation
    // of BaseRegGetVersion does not actually fill in the
    // version. It just returns ERROR_SUCCESS or
    // ERROR_INVALID_PARAMETER.
    //
    return(ERROR_NOACCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\reglukey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Reglukey.c

Abstract:

    This module contains the server side Win32 Registry
    APIs to load, unload and replace keys. That is:

        - BaseRegLoadKeyA
        - BaseRegLoadKeyW
        - BaseRegUnLoadKeyA
        - BaseRegUnLoadKeyW
        - BaseRegReplaceKeyA
        - BaseRegReplaceKeyW

Author:


    Ramon J. San Andres (ramonsa) 16-Apr-1992



--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"

error_status_t
BaseRegLoadKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpSubKey OPTIONAL,
    IN  PUNICODE_STRING lpFile
    )

/*++

Routine Description:

    Load the tree in the supplied file into the key referenced by the
    supplied key handle and sub-key.  The loaded tree will overwrite all
    of the contents of the supplied sub-key except for its name.
    Pictorially, if the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies the predefined handle HKEY_USERS or HKEY_LOCAL_MACHINE.
        lpSubKey is relative to this handle.

    lpSubKey - Supplies a path name to a new (i.e.  non-existant) key
        where the supplied file will be loaded.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey. The file name may not have an extension.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    The difference between RegRestoreKey and RegLoadKey is that in the
    latter case the supplied file is used as the actual backing store
    whereas in the former case the information in the file is copied into
    the Registry.

    RegLoadKey requires SeRestorePrivilege.

--*/

{
    OBJECT_ATTRIBUTES   ObjaKey;
    OBJECT_ATTRIBUTES   ObjaFile;
    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    PUNICODE_STRING     SubKey;

#if DBG
    //OutputDebugString( "WINREG: Entering BaseRegLoadKey\n" );
#endif


    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // check for oddly formed UNICODE_STRINGs passed by malicious clients
    // check also for zero-length strings
    //
    if ((!lpFile->Length)    ||
        (lpFile->Length & 1) ||
        (lpFile->Buffer[lpFile->Length/sizeof(WCHAR) - 1] != UNICODE_NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    if ((lpSubKey) &&
        ((!lpSubKey->Length)    ||
         (lpSubKey->Length & 1) ||
         (lpSubKey->Buffer && (lpSubKey->Buffer[lpSubKey->Length/sizeof(WCHAR) - 1] != UNICODE_NULL)))) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );


    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
        SubKey = lpSubKey;
    } else {
        SubKey = NULL;
    }

    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                SubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the file.
    //
    InitializeObjectAttributes(
            &ObjaFile,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

#if DBG
    //OutputDebugString( "WINREG: Before NtLoadKey\n" );
#endif


    NtStatus = NtLoadKey(
                    &ObjaKey,
                    &ObjaFile
                    );

    RtlReleaseRelativeName(&RelativeName);

#if DBG
    //OutputDebugString( "WINREG: After RegLoadKey\n" );
#endif

    RPC_REVERT_TO_SELF();

    //
    // Free the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

#if DBG
    //OutputDebugString( "WINREG: Leaving BaseRegLoadKey\n" );
#endif

    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}




error_status_t
BaseRegUnLoadKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpSubKey OPTIONAL
    )

/*++

Routine Description:

    Unload the specified tree (hive) from the Registry.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be unloaded.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry created with RegRestoreKey or RegLoadKey.  This parameter may
        be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    OBJECT_ATTRIBUTES   ObjaKey;
    NTSTATUS            NtStatus;


    ASSERT( hKey != NULL );
    if ( (hKey == NULL) ||
        (lpSubKey && (lpSubKey->Length &1)) ) {
        return ERROR_INVALID_PARAMETER;
    }


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    NtStatus = NtUnloadKey( &ObjaKey );

    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}









error_status_t
BaseRegReplaceKey(
    HKEY             hKey,
    PUNICODE_STRING  lpSubKey,
    PUNICODE_STRING  lpNewFile,
    PUNICODE_STRING  lpOldFile
    )

/*++

Routine Description:

    Replace an existing tree (hive) in the Registry. The new tree will
    take effect the next time the system is rebooted.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be replaced.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry.  This parameter may be NULL.

    lpNewFile - Supplies a file name for the new hive file.

    lpOldFile - Supplies a backup file name for the old (existing) hive file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    lpNewFile will remain open until after the system is rebooted.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    UNICODE_STRING      NewFileName;
    UNICODE_STRING      OldFileName;
    RTL_RELATIVE_NAME_U NewRelativeName;
    RTL_RELATIVE_NAME_U OldRelativeName;
    PVOID               NewFreeBuffer;
    PVOID               OldFreeBuffer;
    HANDLE              HiveHandle;
    OBJECT_ATTRIBUTES   ObjaKey;
    OBJECT_ATTRIBUTES   ObjaNewFile;
    OBJECT_ATTRIBUTES   ObjaOldFile;
    BOOLEAN             ErrorFlag;
    NTSTATUS            NtStatus;


    ErrorFlag = (BOOLEAN)( (hKey   == NULL)            ||
                           (lpNewFile == NULL)         ||
                           (lpNewFile->Buffer == NULL) ||
                           (lpNewFile->Length & 1)     || 
                           (lpOldFile == NULL)         ||
                           (lpOldFile->Buffer == NULL) ||
                           (lpOldFile->Length & 1)     ||
                           (lpSubKey && (lpSubKey->Length & 1))
                           );

    ASSERT( !ErrorFlag );

    if ( ErrorFlag ) {
        return ERROR_INVALID_PARAMETER;
    }


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
    }

    if ( lpNewFile->Length > 0 ) {
        lpNewFile->Length -= sizeof( UNICODE_NULL );
    }

    if ( lpOldFile->Length > 0 ) {
        lpOldFile->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    //
    //  Get a handle to the hive root
    //
    NtStatus = NtCreateKey(
                    &HiveHandle,
                    MAXIMUM_ALLOWED,
                    &ObjaKey,
                    0,
                    NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    NULL
                    );


    if ( !NT_SUCCESS( NtStatus ) ) {
        RPC_REVERT_TO_SELF();
        return (error_status_t)RtlNtStatusToDosError( NtStatus );
    }



    //
    // Convert the new DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpNewFile->Buffer,
                    &NewFileName,
                    NULL,
                    &NewRelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        NtClose( HiveHandle );
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    NewFreeBuffer = NewFileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( NewRelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        NewFileName = NewRelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        NewRelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the new file.
    //
    InitializeObjectAttributes(
            &ObjaNewFile,
            &NewFileName,
            OBJ_CASE_INSENSITIVE,
            NewRelativeName.ContainingDirectory,
            NULL
            );


    //
    // Convert the old DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpOldFile->Buffer,
                    &OldFileName,
                    NULL,
                    &OldRelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RtlReleaseRelativeName(&NewRelativeName);
        RtlFreeHeap( RtlProcessHeap( ), 0, NewFreeBuffer );
        NtClose( HiveHandle );
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    OldFreeBuffer = OldFileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( OldRelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        OldFileName = OldRelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        OldRelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the new file.
    //
    InitializeObjectAttributes(
            &ObjaOldFile,
            &OldFileName,
            OBJ_CASE_INSENSITIVE,
            OldRelativeName.ContainingDirectory,
            NULL
            );


    NtStatus = NtReplaceKey(
                    &ObjaNewFile,
                    HiveHandle,
                    &ObjaOldFile
                    );

    RtlReleaseRelativeName(&NewRelativeName);
    RtlReleaseRelativeName(&OldRelativeName);

    //
    // Free the buffers allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, NewFreeBuffer );
    RtlFreeHeap( RtlProcessHeap( ), 0, OldFreeBuffer );

    NtClose( HiveHandle );

    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regnccls.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regnccls.c

Abstract:

    This file contains functions needed for handling 
    change notifications in the classes portion of the registry

Author:

    Adam P. Edwards     (adamed)  14-Nov-1997

Key Functions:

    BaseRegNotifyClassKey

Notes:

--*/


#ifdef LOCAL

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regnccls.h"
#include <malloc.h>

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous)
{
    NTSTATUS           Status;
    HKEY               hkUser;
    HKEY               hkMachine;
    SKeySemantics      KeyInfo;
    UNICODE_STRING     EmptyString = {0, 0, 0};
    BYTE               rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(OBJECT_NAME_INFORMATION)];
    OBJECT_ATTRIBUTES  Obja;
    BOOL               fAllocatedPath;

    //
    // Set buffer to store info about this key
    //
    KeyInfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    KeyInfo._cbFullPath = sizeof(rgNameBuf);
    KeyInfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &KeyInfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    fAllocatedPath = FALSE;
    Obja.ObjectName = NULL;

    //
    // Now get handles for both user and machine versions of the key
    //
    Status = BaseRegGetUserAndMachineClass(
        &KeyInfo,
        hKey,
        KEY_NOTIFY,
        &hkUser,
        &hkMachine);

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (fWatchSubtree || (hkUser && hkMachine)) {

        //
        // This will return the closest ancestor to the
        // nonexistent translated key -- note that it allocates memory
        // to the Obja.ObjectName member, so we need to free that on
        // success
        //
        Status = BaseRegGetBestAncestor(
            &KeyInfo,
            hkUser,
            hkMachine,
            &Obja);

        fAllocatedPath = Obja.ObjectName != NULL;

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // Ask for the notify on both user and machine keys (or
        // the closest approximation).  Note that we pass a full path --
        // if we used an relative path with an object handle instead, we
        // would never have an opportunity to close the object, so we would
        // leak objects
        // 
        //
        Status = NtNotifyChangeMultipleKeys(
            hKey,
            1,
            &Obja,
            hEvent,
            NULL,
            NULL,
            pLocalIoStatusBlock,
            dwNotifyFilter,
            fWatchSubtree,
            NULL,
            0,
            fAsynchronous
            );

    } else {

        Status = NtNotifyChangeKey(
            hkUser ? hkUser : hkMachine,
            hEvent,
            NULL,
            NULL,
            pLocalIoStatusBlock,
            dwNotifyFilter,
            fWatchSubtree,
            NULL,
            0,
            fAsynchronous
            );
    }

cleanup:

    //if (!NT_SUCCESS(Status)) {
        
        if (hkUser && (hkUser != hKey)) {
            NtClose(hkUser);
        }

        if (hkMachine && (hkMachine != hKey)) {
            NtClose(hkMachine);
        }
    //}

    if (fAllocatedPath) {
        RegClassHeapFree(Obja.ObjectName);
    }

    return Status;
}

NTSTATUS BaseRegGetBestAncestor(
    IN SKeySemantics*      pKeySemantics,
    IN HKEY                hkUser,
    IN HKEY                hkMachine,
    IN POBJECT_ATTRIBUTES  pObja)
/*++

Routine Description:

    Finds a full object path for the closest ancestor for a key
    described by a key semantics structure


Arguments:
    
    pKeySemantics - contains information about a registry key
    hkUser        - handle to a user class version of the key above
    hkMachine     - handle to a machine class version of the key above
    pObja         - Object Attributes structure to initialize with a full
                    object path for the closest ancestor -- not that memory
                    is allocated for the ObjectName member of the structure
                    which must be freed by the caller -- caller should
                    check this member to see if it's non-NULL, regardless
                    of success code returned by function

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/
{
    USHORT             PrefixLen;
    NTSTATUS           Status;
    PUNICODE_STRING    pKeyPath;
    USHORT             uMaxLen;

    //
    // Allocate memory for the Obja's ObjectName member
    //
    uMaxLen = (USHORT) pKeySemantics->_pFullPath->NameLength +  REG_CLASSES_SUBTREE_PADDING;

    pKeyPath = RegClassHeapAlloc(uMaxLen + sizeof(*pKeyPath));

    if (!(pKeyPath)) {
        return STATUS_NO_MEMORY;
    }

    //
    // Now initialize the structure
    //
    pKeyPath->MaximumLength = uMaxLen;
    pKeyPath->Buffer = (WCHAR*) (((PBYTE) pKeyPath) + sizeof(*pKeyPath));

    //
    // Now form a version of this key path in the opposite tree
    //
    if (pKeySemantics->_fUser) {
            
        Status = BaseRegTranslateToMachineClassKey(
            pKeySemantics,
            pKeyPath,
            &PrefixLen);

    } else {

        Status = BaseRegTranslateToUserClassKey(
            pKeySemantics,
            pKeyPath,
            &PrefixLen);
    }
    
    //
    // Make sure the caller has a reference to allocated memory
    //
    pObja->ObjectName = pKeyPath;

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    //
    // Set up the object attributes with this translated key so 
    // we can use the structure to notify keys
    //
    InitializeObjectAttributes(
        pObja,
        pKeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL, // using absolute path, no hkey
        NULL);

    //
    // If we were supplied both keys, then they both exist,
    // so we can simply use the translated path above
    //
    if (hkUser && hkMachine) {
        goto cleanup;
    }

    //
    // At this point, we know the translated path doesn't exist,
    // since we only have a handle for one of the paths.  Therefore
    // we will attempt to find an approximation.  Note that the 
    // manipulation of KeyPath below affects the Obja passed in since
    // the Obja struct references KeyPath
    //
    do
    {
        WCHAR* pBufferEnd;
        HKEY   hkExistingKey;

        //
        // Find the last pathsep in the current key path
        //
        pBufferEnd = wcsrchr(pKeyPath->Buffer, L'\\');

        //
        // We should never get NULL here, because all keys
        // have the ancestory \Registry\User or \Registry\Machine,
        // each which have two pathseps to spare -- the loop
        // terminates once that path is shorter than those prefixes,
        // so we should never encounter this situation
        //
        ASSERT(pBufferEnd);

        //
        // Now truncate the string
        //
        *pBufferEnd = L'\0';

        //
        // Adjust the unicode string structure to conform
        // to the truncated string
        //
        RtlInitUnicodeString(pKeyPath, pKeyPath->Buffer);

        //
        // Now attempt to open with this truncated path
        //
        Status = NtOpenKey(
            &hkExistingKey,
            KEY_NOTIFY,
            pObja);

        //
        // If we do open it, we will close it and not pass this object
        // since we want our obja to use a full path and not a relative
        // path off a kernel object
        //
        if (NT_SUCCESS(Status)) {
            NtClose(hkExistingKey);
            break;
        }

        //
        // If we get any error besides a key not found error, then our reason
        // for failing the open is not because the key did not exist, but because
        // of some other error, most likely access denied.
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
            break;
        }

    } while (pKeyPath->Length > PrefixLen);

cleanup:

    return Status;
    
}


#endif // defined ( LOCAL )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regnccls.h ===
/*++




Copyright (c) 1992  Microsoft Corporation

Module Name:

    regnccls.h

Abstract:

    This file contains declarations needed for handling 
    change notifications in the classes portion of the registry

Author:

    Adam Edwards (adamed) 19-Aug-1998

Notes:

--*/

#if defined( LOCAL )

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous);

NTSTATUS BaseRegGetBestAncestor(
    IN SKeySemantics*     pKeySemantics,
    IN HKEY               hkUser,
    IN HKEY               hkMachine,
    IN POBJECT_ATTRIBUTES pObja);


#endif // defined( LOCAL )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regeval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regeval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to enumerate values. That is:

        - BaseRegEnumValue

Author:

    David J. Gilman (davegi) 23-Dec-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"

#define DEFAULT_VALUE_SIZE          128
#define DEFAULT_VALUE_NAME_SIZE     64


error_status_t
BaseRegEnumValue(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData OPTIONAL,
    IN OUT LPDWORD lpcbData OPTIONAL,
    IN OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    Used to enumerate the ValueNames of an open key.  This function copies
    the dwIndex-th ValueName of hKey.  This function is guaranteed to
    operate correctly only if dwIndex starts at 0 and is incremented on
    successive calls without intervening calls to other registration APIs
    that will change the key.  The ValueName (only the ValueName, not the
    full path) is copied to lpBuffer.  The size of lpBuffer is specified
    by dwBufferSize.

Arguments:

    hKey - A handle to the open key.  The value entries returned are
        contained in the key pointed to by this key handle.  Any of the
        predefined reserved handles or a previously opened key handle may be
        used for hKey.

    dwIndex - The index of the ValueName to return.  Note that this is for
        convenience, ValueNames are not ordered (a new ValueName has an
        arbitrary index).  Indexes start at 0.

    lpValueName - Provides a pointer to a buffer to receive the name of
        the value (it's Id)

    lpType - If present, supplies pointer to variable to receive the type
        code of value entry.

    lpData - If present, provides a pointer to a buffer to receive the
        data of the value entry.

    lpcbData - Must be present if lpDatais.  Provides pointer to a
        variable which on input contains the size of the buffer lpDatapoints
        to.  On output, the variable will receive the number of bytes returned
        in lpData.

    lpcbLen - Return the number of bytes to transmit to the client (used
        by RPC).


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    hKey must have been opened for KEY_QUERY_VALUE access.


--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;
    ULONG                           ResultLength;

    BYTE    PrivateKeyValueInformation[ sizeof( KEY_VALUE_FULL_INFORMATION ) +
                                        DEFAULT_VALUE_NAME_SIZE +
                                        sizeof(UNICODE_NULL) +
                                        DEFAULT_VALUE_SIZE +
                                        sizeof(UNICODE_NULL) ];
    HKEY                            hkEnum;
#ifdef LOCAL
    ValueState*                     pValState;

    pValState = NULL;
#endif // LOCAL    
    hkEnum = hKey;

    //
    //  If the client gave us a bogus size, patch it.
    //
    if ( ARGUMENT_PRESENT( lpcbData ) && !ARGUMENT_PRESENT( lpData ) ) {
        *lpcbData = 0;
    }
    if( (lpValueName == NULL) || (lpValueName->Buffer == NULL) ) {
        //
        // malicious RPC attack
        //
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        return (error_status_t)PerfRegEnumValue (
                                    hKey,
                                    dwIndex,
                                    lpValueName,
                                    NULL,
                                    lpType,
                                    lpData,
                                    lpcbData,
                                    lpcbLen
                                    );
    }

#ifdef LOCAL
    //
    // If we are in HKEY_CLASSES_ROOT, then we need to remap
    // the key / index pair to take into account merging
    //

    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        //
        // Find a key state for this key
        //
        Status = BaseRegGetClassKeyValueState(
            hKey,
            dwIndex,
            &pValState);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }

        //
        // Now remap to the appropriate key / index 
        //
        ValStateGetPhysicalIndexFromLogical(
            pValState,
            hKey,
            dwIndex,
            &hkEnum,
            &dwIndex);

    }
#endif // LOCAL

    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyValueInformationClass = ( ARGUMENT_PRESENT( lpcbData ))?
                               KeyValueFullInformation :
                               KeyValueBasicInformation;


    KeyValueInformation = PrivateKeyValueInformation;
    BufferLength = sizeof( PrivateKeyValueInformation );

    //
    // Query for the necessary information about the supplied value.
    //

    Status = NtEnumerateValueKey( hkEnum,
                                  dwIndex,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
                                );

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );


    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Value information.
        //  If the caller's buffer are big enough to hold the value name
        //  and value data, then allocate a new buffer, and call the
        //  NT API again.
        //
        if( ( ( KeyValueInformationClass == KeyValueBasicInformation ) &&
              ( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_BASIC_INFORMATION )
                 KeyValueInformation )->NameLength + sizeof(UNICODE_NULL)
              )
            ) ||
            ( ( KeyValueInformationClass == KeyValueFullInformation ) &&
              ( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_FULL_INFORMATION )
                 KeyValueInformation )->NameLength + sizeof(UNICODE_NULL)
              ) &&
              ( !ARGUMENT_PRESENT( lpData ) ||
                ( ARGUMENT_PRESENT( lpData ) &&
                  ARGUMENT_PRESENT( lpcbData ) &&
                  ( *lpcbData >= (( PKEY_VALUE_FULL_INFORMATION )
                        KeyValueInformation )->DataLength
                  )
                )
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                   BufferLength
                                                 );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyValueInformation ) {
#ifdef LOCAL
                ValStateRelease(pValState);
#endif // LOCAL
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied value. This
            // may or may not include the data depending on lpcbData as determined
            // above.
            //

            Status = NtEnumerateValueKey( hkEnum,
                                          dwIndex,
                                          KeyValueInformationClass,
                                          KeyValueInformation,
                                          BufferLength,
                                          &ResultLength
                                        );
        }
    }

#ifdef LOCAL
    ValStateRelease(pValState);
#endif // LOCAL

    //
    //  If the API succeeded, try to copy the value name to the client's buffer
    //

    if( NT_SUCCESS( Status ) ) {
        //
        //  Copy value name
        //

        if( KeyValueInformationClass == KeyValueBasicInformation ) {
            //
            // Return the name length and the name of the value.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_BASIC_INFORMATION )
                  KeyValueInformation )->NameLength + sizeof( UNICODE_NULL )) {

                //
                // If client's buffer is big enough for the name,
                // copy the value name and NUL terminate it
                //
                lpValueName->Length = ( USHORT )
                                      (( PKEY_VALUE_BASIC_INFORMATION )
                                          KeyValueInformation )->NameLength;

                RtlMoveMemory( lpValueName->Buffer,
                               (( PKEY_VALUE_BASIC_INFORMATION )
                               KeyValueInformation )->Name,
                               lpValueName->Length
                             );

                lpValueName->Buffer[ lpValueName->Length >> 1 ] = UNICODE_NULL;

                //
                // Value name length must include size of UNICODE_NULL.
                // It will be decremented in the client side
                //

                lpValueName->Length += sizeof( UNICODE_NULL );

            } else {
                //
                //  If the client's buffer for the value name is not big
                //  enough, then set status to STATUS_BUFFER_OVERFLOW.
                //
                //  Note that in the remote case, RPC will transmit garbage
                //  in the buffer back to the client.
                //  We cannot set the buffer to prevent this transmission,
                //  because in the local case we would be destroying the
                //  buffer in the &NtCurrectTeb->StaticUnicodeString.
                //

                Status = STATUS_BUFFER_OVERFLOW;
            }

        } else {
            //
            // Here if KeyValueInformation == KeyValueFullInformation
            //
            // Return the name length and the name of the value.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_FULL_INFORMATION )
                  KeyValueInformation )->NameLength + sizeof( UNICODE_NULL )) {

                //
                // If client's buffer is big enough for the name,
                // copy the value name and NUL terminate it
                //
                lpValueName->Length = ( USHORT )
                                      (( PKEY_VALUE_FULL_INFORMATION )
                                          KeyValueInformation )->NameLength;

                RtlMoveMemory( lpValueName->Buffer,
                               (( PKEY_VALUE_FULL_INFORMATION )
                               KeyValueInformation )->Name,
                               lpValueName->Length
                             );

                lpValueName->Buffer[ lpValueName->Length >> 1 ] = UNICODE_NULL;

                //
                // Value name length must include size of UNICODE_NULL.
                // It will be decremented in the client side
                //

                lpValueName->Length += sizeof( UNICODE_NULL );

            } else {
                //
                //  If the client's buffer for the value name is not big
                //  enough, then set status to STATUS_BUFFER_OVERFLOW.
                //
                //  Note that in the remote case, RPC will transmit garbage
                //  in the buffer back to the client.
                //  We cannot set the buffer to prevent this transmission,
                //  because in the local case we would be destroying the
                //  buffer in the &NtCurrectTeb->StaticUnicodeString.
                //

                Status = STATUS_BUFFER_OVERFLOW;
            }

        }
    }



    if( NT_SUCCESS( Status ) &&
        ARGUMENT_PRESENT( lpData ) ) {

        //
        //  If we were able to copy the value name to the client's buffer
        //  and the value data is also requested, then try to copy it
        //  to the client's buffer
        //

        if( *lpcbData >= (( PKEY_VALUE_FULL_INFORMATION )
                           KeyValueInformation )->DataLength ) {
            //
            // If the buffer is big enough to hold the data, copy the data
            //
            RtlMoveMemory( lpData,
                           ( PBYTE ) KeyValueInformation
                             + (( PKEY_VALUE_FULL_INFORMATION )
                                KeyValueInformation )->DataOffset,
                           (( PKEY_VALUE_FULL_INFORMATION )
                                     KeyValueInformation )->DataLength
                         );
        } else {
            //
            // If buffer is not big enough to hold the data, then return
            // STATUS_BUFFER_OVERFLOW.
            //
            //  Note that in the remote case, RPC will transmit garbage
            //  in the buffer back to the client.
            //  We cannot set the buffer to prevent this transmission,
            //  because in the local case we would be destroying the
            //  buffer in the &NtCurrectTeb->StaticUnicodeString.
            //
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }



    //
    // Certain information is returned on success or in the case of
    // NtEnumerateValueKey returning STATUS_BUFFER_OVERFLOW.  This information
    // is always available because we always pass the minimum size required for
    // the NtEnumerateValueKey API.
    //

    if( NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) {

        if( KeyValueInformationClass == KeyValueBasicInformation ) {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_BASIC_INFORMATION )
                            KeyValueInformation )->Type;
            }

//            lpValueName->Length
//                = ( USHORT ) ((( PKEY_VALUE_BASIC_INFORMATION )
//                KeyValueInformation )->NameLength + sizeof( UNICODE_NULL ) );

        } else {
            //
            // Here if KeyValueInformationClass == KeyValueFullInformation
            //

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_FULL_INFORMATION )
                            KeyValueInformation )->Type;
            }

//            lpValueName->Length
//                = ( USHORT ) ((( PKEY_VALUE_FULL_INFORMATION )
//                KeyValueInformation )->NameLength + sizeof( UNICODE_NULL ) );

            *lpcbData = (( PKEY_VALUE_FULL_INFORMATION )
                            KeyValueInformation )->DataLength;
        }
    }

    //
    // Transmit all of the value data back to the client.
    //

    if( NT_SUCCESS( Status ) ) {
        if( ARGUMENT_PRESENT( lpcbLen  ) &&
            ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbLen = *lpcbData;
        }
    } else {
        //
        // If something failed, don't transmit any data back to the client
        //
        if( ARGUMENT_PRESENT( lpcbLen ) ) {
            *lpcbLen = 0;
        }
    }

    //
    //  Free memory if it was allocated
    //
    if( KeyValueInformation != PrivateKeyValueInformation ) {

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyValueInformation );

    }

    return (error_status_t)RtlNtStatusToDosError( Status );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regnckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regnckey.c

Abstract:

    This module contains the Win32 Registry APIs to notify a caller about
    a changed Key value. That is:

        - RegNotifyChangeKey

Author:

    David J. Gilman (davegi) 10-Feb-1992


Notes:


    The RegNotifyChangeKey server creates an event and calls
    NtNotifyChangeKey asynchronously with that event.  It then
    places the event (plus some other client information, such
    as a named pipe and a client event) in a "Notification List"
    and returns to the client.

    A Notification List is a list of events controled by a
    handler thread. The handler thread waits on the events in
    the list. When an event is signaled the handler thread
    identifies the client to which the event belongs, and
    gives the client (via named pipe) the corresponding client
    event.

    Since there is a limit on the number of events on which a
    thread can wait, there may be several Notification Lists.

    Since all the calls to RegNotifyChangeKey in a client
    process use the same named pipe, we maintain only one copy
    of each pipe. Pipe information is maintained in a symbol table
    for fast lookup.



Revision History:

    02-Apr-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.


--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include <string.h>


#ifndef REMOTE_NOTIFICATION_DISABLED
//
//  Strings used for generating named pipe names
//
#define NAMED_PIPE_HERE     L"\\Device\\NamedPipe\\"
#define NAMED_PIPE_THERE    L"\\DosDevices\\UNC\\"


//
//  Pipe names are maintained in a symbol table. The symbol table has
//  one entry for each different pipe given by a client.  The entry
//  is maintained for as long as there is at least one entry in a
//  Notification List referencing it.
//
typedef struct _PIPE_ENTRY *PPIPE_ENTRY;

typedef struct _PIPE_ENTRY {

    PPIPE_ENTRY             Previous;
    PPIPE_ENTRY             Next;
    UNICODE_STRING          PipeName;
    DWORD                   ReferenceCount;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

} PIPE_ENTRY;




//
//  The PIPE_SYMBOL_TABLE structure contains the symbol table for
//  all the pipes being used by the clients of
//  RegNotifyChangeKey
//
#define BUCKETS_IN_SYMBOL_TABLE     211

typedef struct _PIPE_SYMBOL_TABLE   *PPIPE_SYMBOL_TABLE;

typedef struct _PIPE_SYMBOL_TABLE {

    PPIPE_ENTRY             Bucket[ BUCKETS_IN_SYMBOL_TABLE ];

} PIPE_SYMBOL_TABLE;




//
//  Information about a pending event is maintained in a
//  NOTIFICATION_ENTRY structure.
//
typedef struct _NOTIFICATION_ENTRY *PNOTIFICATION_ENTRY;

typedef struct _NOTIFICATION_ENTRY {

    DWORD                   ClientEvent;    //  Event in client side
    HANDLE                  hKey;           //  Key handle
    DWORD                   Flags;          //  Misc. flags
    PPIPE_ENTRY             PipeEntry;      //  Pipe Entry

} NOTIFICATION_ENTRY;


//
//  Flag values
//
#define CLIENT_IS_DEAD       0x00000001
#define MUST_NOTIFY          0x00000002
#define NOTIFICATION_FAILED  0x00000004



//
//  The pending events are maintained in notification lists. Each
//  notification list contains:
//
//  Previous        -   Previous in chain
//  Next            -   Next in chain
//  EventsInUse     -   Number of entries being used in this list
//  EventHandle     -   Array of event handles
//  ClientEvent     -   Array of events in client
//  PipeEntry       -   Array of pointers to pipe entries in symbol table
//
//
//  The first event in the EventHandle list is the event used to wake
//  up the thread whenever we add new entries to the list.
//
//  The array entries 0..EventsInUse-1 contain the pending events.
//  New events are always added at position EventsInUse. When removing
//  an event, all the arrays are shifted.
//
//  Whenever EventsInUse == 1, the list is empty of client events and
//  it can be removed (together with its thread).
//
//
//  Notification Lists are kept in a doubly-linked list. A new
//  Notification List is created and added to the chain whenever an
//  event is added and all the existing lists are full.  Notification
//  lists are deleted when the last event in the list is signaled.
//
//
typedef struct _NOTIFICATION_LIST *PNOTIFICATION_LIST;

typedef struct _NOTIFICATION_LIST {

    PNOTIFICATION_LIST      Previous;
    PNOTIFICATION_LIST      Next;
    DWORD                   EventsInUse;
    HANDLE                  HandlerThread;
    CLIENT_ID               HandlerClientId;
    DWORD                   PendingNotifications;
    HANDLE                  EventHandle[ MAXIMUM_WAIT_OBJECTS ];
    NOTIFICATION_ENTRY      Event[ MAXIMUM_WAIT_OBJECTS ];
    DWORD                   TimeOutCount;
    BOOLEAN                 ResetCount;

} NOTIFICATION_LIST;

#define MAX_TIMEOUT_COUNT   128


#if DBG
    #define BIGDBG 0
#else
    #define BIGDBG 0
#endif

#define HASH(a,b)   Hash(a,b)



// *****************************************************************
//
//                    Static Variables
//
// *****************************************************************



//
//  Head of chain of Notification lists
//
PNOTIFICATION_LIST      NotificationListChainHead;

//
//  The critical sesction protects all the global structures.
//
RTL_CRITICAL_SECTION    NotificationCriticalSection;

//
//  Symbol table for named pipes in use.
//
PIPE_SYMBOL_TABLE       PipeSymbolTable;

//
//  Our machine name is used for determining if requests are local
//  or remote.
//
WCHAR                   OurMachineNameBuffer[ MAX_PATH ];
UNICODE_STRING          OurMachineName;

//
//  The I/O Status Block is updated by the NtNotifyChangeKey API
//  upon notification.  We cannot put this structure on the stack
//  because at notification time this stack might belong to someone
//  else. We can use a single variable because we don't care about
//  its contents so it's ok if several people mess with it at the
//  same time.
//
IO_STATUS_BLOCK         IoStatusBlock;





// *****************************************************************
//
//                    Local Prototypes
//
// *****************************************************************



LONG
CreateNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    );

LONG
DeleteNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
AddEvent (
    IN  HKEY                     hKey,
    IN  HANDLE                   EventHandle,
    IN  DWORD                    ClientEvent,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL,
    OUT PNOTIFICATION_LIST      *NotificationListUsed
    );

LONG
RemoveEvent (
    IN      HANDLE              EventHandle,
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
GetAvailableNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    );

LONG
AddEntryToNotificationList(
    IN OUT  PNOTIFICATION_LIST       NotificationList,
    IN      HKEY                     hKey,
    IN      HANDLE                   EventHandle,
    IN      DWORD                    ClientEvent,
    IN      PUNICODE_STRING          PipeName,
    IN      PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL
    );

LONG
RemoveEntryFromNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList,
    IN      DWORD               EntryIndex
    );

LONG
CompactNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

VOID
AddNotificationListToChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

VOID
RemoveNotificationListFromChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
GetFullPipeName(
    IN      PUNICODE_STRING         MachineName,
    IN      PUNICODE_STRING         PipeName,
    IN OUT  PUNICODE_STRING         FullPipeName
    );

LONG
CreatePipeEntry (
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    );

LONG
DeletePipeEntry(
    IN OUT PPIPE_ENTRY  PipeEntry
    );

LONG
AddPipe(
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    );

LONG
RemovePipe(
    IN OUT PPIPE_ENTRY  PipeEntry
    );

LONG
AddPipeEntryToSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    );

LONG
RemovePipeEntryFromSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    );

LONG
LookForPipeEntryInSymbolTable(
    IN  PUNICODE_STRING PipeName,
    OUT PPIPE_ENTRY     *PipeEntryUsed
    );

DWORD
Hash(
    IN  PUNICODE_STRING  Symbol,
    IN  DWORD            Buckets
    );

VOID
NotificationHandler(
    IN  PNOTIFICATION_LIST  NotificationList
    );

DWORD
NotificationListMaintenance(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
SendEventToClient(
    IN  DWORD           ClientEvent,
    IN  PPIPE_ENTRY     PipeEntry
    );

#if BIGDBG
VOID
DumpNotificationLists(
    );

VOID
DumpPipeTable(
    );

#endif

#endif // REMOTE_NOTIFICATION_DISABLED



// *****************************************************************
//
//                    BaseRegNotifyChangeKeyValue
//
// *****************************************************************





BOOL
InitializeRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Initializes the static data structures used by the
    RegNotifyChangeKeyValue server. Called once at program
    initialization.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{
#ifdef REMOTE_NOTIFICATION_DISABLED

    return( TRUE );

#else   // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS        NtStatus;
    DWORD           Bucket;
    DWORD           MachineNameLength;


    NotificationListChainHead = NULL;

    //
    //  Determine our machine name
    //
    MachineNameLength = MAX_PATH;
    if ( !GetComputerNameW( OurMachineNameBuffer, &MachineNameLength ) ) {
        return FALSE;
    }

    OurMachineName.Buffer        = OurMachineNameBuffer;
    OurMachineName.Length        = (USHORT)(MachineNameLength * sizeof(WCHAR));
    OurMachineName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));


    //
    //  Initialize Notification critical section
    //
    NtStatus = RtlInitializeCriticalSection(
                    &NotificationCriticalSection
                    );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }


    //
    //  Initialize the pipe symbol table
    //
    for ( Bucket = 0; Bucket < BUCKETS_IN_SYMBOL_TABLE; Bucket++ ) {
        PipeSymbolTable.Bucket[Bucket] = NULL;
    }

    return TRUE;
#endif   // REMOTE_NOTIFICATION_DISABLED
}




error_status_t
BaseRegNotifyChangeKeyValue(
    IN  HKEY                     hKey,
    IN  BOOLEAN                  fWatchSubtree,
    IN  DWORD                    dwNotifyFilter,
    IN  DWORD                    hEvent,
    IN  PUNICODE_STRING          MachineName,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL
    )

/*++

Routine Description:

    This API is used to watch a key or sub-tree for changes. It is
    asynchronous. It is possible to filter the criteria by which the
    notification occurs.


Arguments:

    hKey - Supplies a handle to a key that has been previously opened with
        KEY_NOTIFY access.

    fWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the key and all of its decsendants.  A value of
        FALSE causes the system to monitor only the specified key.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification.

        REG_NOTIFY_CHANGE_KEYNAME - Any key name changes that occur
            in a key or subtree being watched will satisfy a
            change notification wait.  This includes creations
            and deletions.

        REG_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a key or subtree being watched will
            satisfy a change notification.


    hEvent - Supplies a DWORD which represents an event that will have to
             be communicated to the client (via named pipe) when a key
             has to be notified.


    PipeName - Supplies the name of the pipe used for communicating
            the notification to the client.

    pRpcSa - Supplies the optional security attributes of the named
            pipe.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

#ifdef REMOTE_NOTIFICATION_DISABLED

    return ERROR_INVALID_PARAMETER;

#else   // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS            NtStatus;
    HANDLE              EventHandle;
    PNOTIFICATION_LIST  NotificationList;
    LONG                Error;
    UNICODE_STRING      FullPipeName;


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Enter the critical section
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return (error_status_t)RtlNtStatusToDosError( NtStatus );
    }

    try {

#if BIGDBG
        DbgPrint( "WINREG: RegNotify entered\n" );

        //DbgPrint( "WINREG: Notification requested. HKEY 0x%x, Client 0x%x, pipe %wZ\n",
        //           hKey, hEvent, PipeName );
        //DbgPrint( "       Watch subtree: 0x%x, filter 0x%x\n", fWatchSubtree, dwNotifyFilter );

#endif


        //
        //  Subtract the NULL from the Length of all the strings.
        //  This was added by the client so that RPC would transmit
        //  the whole thing.
        //
        if ( MachineName->Length > 0 ) {
            MachineName->Length -= sizeof(UNICODE_NULL );
        }
        if ( PipeName->Length > 0 ) {
            PipeName->Length -= sizeof(UNICODE_NULL );
        }

        //
        //  Construct the full pipe name based on the machine name
        //  and the pipe name given.
        //
        FullPipeName.Buffer = RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                MAX_PATH * sizeof(WCHAR)
                                );

        if ( !FullPipeName.Buffer ) {

            Error = ERROR_OUTOFMEMORY;

        } else {


            FullPipeName.Length         = 0;
            FullPipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);


            Error = GetFullPipeName(
                        MachineName,
                        PipeName,
                        &FullPipeName
                        );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Create an event on which we will wait for completion of
                //  the API.
                //
                NtStatus = NtCreateEvent(
                                &EventHandle,
                                (ACCESS_MASK)EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE
                                );

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    //  Add the event to a Notification List
                    //
                    Error = AddEvent(
                                hKey,
                                EventHandle,
                                hEvent,
                                &FullPipeName,
                                pRpcSa,
                                &NotificationList
                                );

                    if ( Error == ERROR_SUCCESS ) {

                        //
                        //  Call the NT API
                        //
                        NtStatus = NtNotifyChangeKey(
                                        hKey,
                                        EventHandle,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        dwNotifyFilter,
                                        ( BOOLEAN ) fWatchSubtree,
                                        NULL,
                                        0,
                                        TRUE
                                        );

                        if ( NT_SUCCESS( NtStatus ) ||
                             (NtStatus == STATUS_PENDING) ) {

                            Error = ERROR_SUCCESS;

                        } else {

                            //
                            //  Could not request notification, remove the
                            //  event from the notification list.
                            //
                            Error = RemoveEvent(
                                        EventHandle,
                                        NotificationList
                                        );

                            ASSERT( Error == ERROR_SUCCESS );

                            Error = RtlNtStatusToDosError( NtStatus );
                        }

                    } else {

                        //
                        //  Could not add the event to any notification
                        //  list.
                        //
                        NtStatus = NtClose( EventHandle );
                        ASSERT( NT_SUCCESS( NtStatus ) );
                    }

                } else {

                    Error = RtlNtStatusToDosError( NtStatus );
                }
            }

            RtlFreeHeap(
                RtlProcessHeap( ), 0,
                FullPipeName.Buffer
                );
        }

    } except ( NtStatus = GetExceptionCode() ) {

#if DBG
        DbgPrint( "WINREG Error: Exception %x in BaseRegNotifyChangeKeyValue\n",
                  NtStatus );
        DbgBreakPoint();
#endif
        Error = RtlNtStatusToDosError( NtStatus );

    }

#if BIGDBG
    DbgPrint( "WINREG: RegNotify left\n" );
#endif

    NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
    ASSERT( NT_SUCCESS( NtStatus ) );

    RPC_REVERT_TO_SELF();
    return (error_status_t)Error;
#endif   // REMOTE_NOTIFICATION_DISABLED
}




BOOL
CleanDeadClientInfo(
    HKEY    hKey
    )
/*++

Routine Description:

    When a client dies, this function searches the notification lists to
    see if we the client has some pending notifications. We flag the
    entries in the notification lists and signal the events so that
    the notification handler can get rid of these orphans.

Arguments:

    hKey    -   Client's hKey

Return Value:

    BOOL - Returns TRUE unless something REALLY weird happened.


--*/

{
#ifdef REMOTE_NOTIFICATION_DISABLED

    return( TRUE );

#else // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS            NtStatus;
    PNOTIFICATION_LIST  NotificationList;
    PNOTIFICATION_ENTRY Event;
    DWORD               Index;
    BOOL                Ok               = TRUE;
    BOOL                FoundDeadClients;

    //
    //  Enter the critical section
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }

#if BIGDBG
    DbgPrint( "WINREG: Dead client, hKey 0x%x\n", hKey );
#endif

    try {

        //
        //  Traverse all the lists looking for orphans.
        //
        for ( NotificationList = NotificationListChainHead;
              NotificationList;
              NotificationList = NotificationList->Next ) {

            FoundDeadClients = FALSE;
            Event = NotificationList->Event;

            //
            //  Examine all the entries of the list to see if any
            //  entry is an orphan.
            //
            for ( Index = 1;
                  Index < NotificationList->EventsInUse;
                  Index++ ) {

                //
                //  If this entry is an orphan, flag it as such and
                //  signal the event so that the notification handler
                //  can clean it up.
                //
                if ( Event->hKey == hKey ) {

#if BIGDBG
                    DbgPrint( "WINREG:  Found notification orphan, hKey 0x%x Client 0x%x\n",
                              hKey, Event->ClientEvent );
#endif
                    Event->Flags |= CLIENT_IS_DEAD;

                    FoundDeadClients = TRUE;
                }

                Event++;
            }

            if ( FoundDeadClients ) {
                NtStatus = NtSetEvent( NotificationList->EventHandle[0], NULL );
                ASSERT( NT_SUCCESS( NtStatus ) );
            }
        }

    } except ( NtStatus = GetExceptionCode() ) {

#if DBG
        DbgPrint( "WINREG Error: Exception %x in CleanDeadClientInfo\n",
                  NtStatus );
        DbgBreakPoint();
#endif

        Ok = FALSE;

    }

#if BIGDBG
    DbgPrint( "WINREG: Dead client left\n" );
#endif

    NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
    ASSERT( NT_SUCCESS( NtStatus ) );

    return Ok;
#endif // REMOTE_NOTIFICATION_DISABLED
}


// *****************************************************************
//
//                  Notification List funcions
//
// *****************************************************************



#ifndef REMOTE_NOTIFICATION_DISABLED

LONG
CreateNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    )
/*++

Routine Description:

    Creates a new Notification List and its handler thread.

Arguments:

    NotificationListUsed    -   Supplies pointer to pointer to Notification List

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    PNOTIFICATION_LIST  NotificationList;
    DWORD               Index;
    NTSTATUS            NtStatus;
    LONG                Error;

#if BIGDBG
    DbgPrint( "WINREG: Creating new notification list\n" );
#endif

    //
    //  Allocate memory for the new Notification List
    //
    NotificationList = RtlAllocateHeap(
                            RtlProcessHeap( ), 0,
                            sizeof( NOTIFICATION_LIST )
                            );

    if ( !NotificationList ) {
        return ERROR_OUTOFMEMORY;
    }


    //
    //  Create the "Wake up" event handle, which is used to wake
    //  up the handler thread whenever new events are added to
    //  the notification list.
    //
    NtStatus = NtCreateEvent(
                    &(NotificationList->EventHandle[0] ),
                    (ACCESS_MASK)EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE
                    );

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        //  Mark rest of entries as "available"
        //
        for ( Index = 1; Index < MAXIMUM_WAIT_OBJECTS; Index++ ) {
            NotificationList->EventHandle[Index] = NULL;
        }

        //
        //  Set initial number of EventInUse to 1 (which is the
        //  index to the next available spot in the list).
        //
        NotificationList->EventsInUse = 1;

        //
        //  Set chain links
        //
        NotificationList->Previous  = NULL;
        NotificationList->Next      = NULL;

        NotificationList->PendingNotifications = 0;

        //
        //  Now that everything has been initialized, create the
        //  handler thread for the list.
        //
        NotificationList->HandlerThread =
                                CreateThread(
                                        NULL,
                                        (32 * 1024),
                                        (LPTHREAD_START_ROUTINE)NotificationHandler,
                                        NotificationList,
                                        0,
                                        (LPDWORD)&(NotificationList->HandlerClientId)
                                        );

        if ( NotificationList->HandlerThread != NULL ) {

            *NotificationListUsed = NotificationList;

            Error = ERROR_SUCCESS;

        } else {

            //
            //  Could not create thread, close the event that we just
            //  created.
            //
            Error = GetLastError();

#if DBG
            DbgPrint( "WINREG Error: Cannot create notification thread, error %d\n",
                      Error );
            DbgBreakPoint();
#endif

            NtStatus = NtClose( NotificationList->EventHandle[0] );

            ASSERT( NT_SUCCESS( NtStatus ) );
        }

    } else {

#if DBG
        DbgPrint( "WINREG Error: Cannot create notification event, status 0x%x\n",
                  NtStatus );
        DbgBreakPoint();
#endif

        Error = RtlNtStatusToDosError( NtStatus );
    }

    //
    //  If something went wrong, free up the notification list
    //
    if ( Error != ERROR_SUCCESS ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            NotificationList
            );
        *NotificationListUsed = NULL;
    }

    return Error;
}




LONG
DeleteNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Deletes a Notification List. The handler thread is not terminated
    because it is the handler thread who deletes notification lists,
    commiting suicide afterwards.

Arguments:

    NotificationList    -   Supplies pointer to Notification List

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    NTSTATUS    NtStatus;

#if BIGDBG
    DbgPrint( "WINREG: Removing empty notification list\n" );
#endif

    //
    //  The only event in the list must be the "wakeup" event
    //
    ASSERT( NotificationList->EventsInUse == 1 );

    //
    //  Delete the "wake up" event
    //
    NtStatus = NtClose( NotificationList->EventHandle[0] );
    ASSERT( NT_SUCCESS( NtStatus ) );

    //
    //  Free up the heap used by the Notification List
    //
    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         NotificationList
         );

    return ERROR_SUCCESS;
}




LONG
AddEvent (
    IN  HKEY                     hKey,
    IN  HANDLE                   EventHandle,
    IN  DWORD                    ClientEvent,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL,
    OUT PNOTIFICATION_LIST      *NotificationListUsed
    )
/*++

Routine Description:

    Adds an event to the first notification list with an available slot.

    If no notification list has an available slot, a new notification list
    (an its handler thread) is created.


Arguments:

    hKey        -   Supplies registry key handle

    EventHandle -   Supplies an event on which the handler thread of the
                    Notification List has to wait.

    ClientEvent -   Supplies the event which has to be communicated to the
                    client when out EventHandle is signaled. This event is
                    communicated to the client via named pipe.

    PipeNameU   -   Supplies the name of the pipe for communicating with the
                    client.

    pRpcSa      -   Supplies the optional security attributes of the named
                    pipe.

    NotificationListused -   Supplies a pointer where the address of the
                             Notification List in which the event is put
                             is placed.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    PNOTIFICATION_LIST  NotificationList;
    LONG                Error;
    NTSTATUS            NtStatus;

    ASSERT( EventHandle != NULL );
    ASSERT( PipeName && PipeName->Buffer );
    ASSERT( NotificationListUsed );


    //
    //  Get a Notification List with an available entry.
    //
    Error = GetAvailableNotificationList(
                    &NotificationList
                    );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Add the entry
        //
        Error = AddEntryToNotificationList(
                        NotificationList,
                        hKey,
                        EventHandle,
                        ClientEvent,
                        PipeName,
                        pRpcSa
                        );

        if ( Error == ERROR_SUCCESS ) {

            //
            //  A new entry has been added, we have to wake up the
            //  handler thread so that it will wait on the newly added
            //  event.
            //
            NtStatus = NtSetEvent( NotificationList->EventHandle[0], NULL );
            ASSERT( NT_SUCCESS( NtStatus ) );

            *NotificationListUsed = NotificationList;

        } else {

#if DBG
            DbgPrint( "WINREG: Could not add notification entry! Error %d\n ", Error);
#endif
        }

    } else {

#if DBG
        DbgPrint( "WINREG: Could not get a notification list! Error %d\n ", Error);
#endif

    }

    return Error;
}




LONG
RemoveEvent (
    IN      HANDLE              EventHandle,
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Removes an event from the notification list. The caller must
    make sure that the event handle given does live in the
    Notification List specified.

    This function is called if the notification is aborted for some
    reason (e.g. the NT notification API fails).

Arguments:

    EventHandle         -   Supplies the event to remove.

    NotificationList    -   Supplies the Notification List in which
                            the event lives.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG        Error;
    DWORD       EntryIndex;

    //
    //  Search for the entry that we have to remove.
    //
    for ( EntryIndex = 1;
          EntryIndex < NotificationList->EventsInUse;
          EntryIndex++ ) {

        if ( EventHandle == NotificationList->EventHandle[ EntryIndex ] ) {
            break;
        }
    }

    ASSERT( EntryIndex < NotificationList->EventsInUse );

    if ( EntryIndex < NotificationList->EventsInUse ) {

        //
        //  Found entry, remove it
        //
        Error = RemoveEntryFromNotificationList(
                    NotificationList,
                    EntryIndex
                    );

        //
        //  Note that we are leaving a hole in the Notification list,
        //  the handler will eventually compact it.
        //

    } else {

        Error = ERROR_ARENA_TRASHED;

    }

    return Error;
}




LONG
GetAvailableNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    )
/*++

Routine Description:

    Gets a Notification List with an available entry.

Arguments:

    NotificationList    -   Supplies pointer to where the Notification
                            List pointer will be placed.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    LONG                Error = ERROR_SUCCESS;
    PNOTIFICATION_LIST  NotificationList;

    //
    //  Traverse the chain of Notification lists until we find a Notification
    //  list with an available entry.
    //
    for ( NotificationList = NotificationListChainHead;
          NotificationList && NotificationList->EventsInUse >= MAXIMUM_WAIT_OBJECTS;
          NotificationList = NotificationList->Next );


    //
    //  If we did not find a Notification List with an available spot,
    //  create a new Notification List and add it to the chain.
    //
    if ( !NotificationList ) {

        Error = CreateNotificationList( &NotificationList );

        if ( Error == ERROR_SUCCESS ) {

            ASSERT( NotificationList );

            AddNotificationListToChain( NotificationList );
        }
    }

    *NotificationListUsed = NotificationList;

    return Error;
}




LONG
AddEntryToNotificationList(
        IN OUT  PNOTIFICATION_LIST       NotificationList,
        IN      HKEY                     hKey,
        IN      HANDLE                   EventHandle,
        IN      DWORD                    ClientEvent,
        IN      PUNICODE_STRING          PipeName,
        IN      PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL
        )
/*++

Routine Description:

    Adds an entry to a notification list.

    Calls to this function must be protected by the critical
    section of the Notification List.


Arguments:

    NotificationList    -   Supplies pointer to Notification List

    hKey                -   Supplies registry key handle

    EventHandle         -   Supplies the event handle

    ClientEvent         -   Supplies the client's event

    PipeName            -   Supplies name of pipe.

    pRpcSa              -   Supplies security attributes for the pipe

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    LONG                Error;
    PPIPE_ENTRY         PipeEntry;
    DWORD               Index;
    PNOTIFICATION_ENTRY Event;


    //
    //  Add the pipe information to the pipe symbol table
    //
    Error = AddPipe( PipeName, pRpcSa, &PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Add the event in the next available spot in the list,
        //  and increment the number of events in use by the
        //  list.
        //
        Index = NotificationList->EventsInUse++;

        Event = &(NotificationList->Event[ Index ]);

        NotificationList->EventHandle[ Index ] = EventHandle;

        Event->ClientEvent = ClientEvent;
        Event->hKey        = hKey;
        Event->Flags       = 0;
        Event->PipeEntry   = PipeEntry;

    } else {

#if BIGDBG
        DbgPrint( "WINREG: Could not create pipe entry for %wZ\n",
                  PipeName );
#endif

    }

    return Error;
}




LONG
RemoveEntryFromNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList,
    IN      DWORD               EntryIndex
    )
/*++

Routine Description:


    Removes an entry from a Notification List. It leaves a hole
    in the list, i.e. the list is not compacted.

Arguments:

    NotificationList    -   Supplies pointer to Notification List.

    EntryIndex          -   Supplies index of entry to remove.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG    Error;

    ASSERT( EntryIndex < NotificationList->EventsInUse );
    ASSERT( NotificationList->EventHandle[ EntryIndex ] != NULL );

    //
    //  Remove the entry from the pipe symbol table.
    //
    Error = RemovePipe( NotificationList->Event[ EntryIndex ].PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  We "remove" the entry from the notification list by
        //  invalidating its handle. Note that we don't decrement
        //  the counter of entries in the notification list because
        //  that is used for indexing the next available entry.
        //  The counter will be fixed by the compaction function.
        //
        NotificationList->EventHandle[ EntryIndex ]     = NULL;
        NotificationList->Event[ EntryIndex ].PipeEntry = NULL;
    }

    return Error;
}




LONG
CompactNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:


    Compacts (i.e. removes holes from) a Notification List.

Arguments:

    NotificationList    -   Supplies pointer to Notification List.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   ToIndex;
    DWORD   FromIndex;
    DWORD   Index;
    DWORD   EntriesToMove;
    PVOID   Src;
    PVOID   Dst;

#if BIGDBG
    DbgPrint( "    * Compacting notification list\n" );
#endif

    for ( ToIndex = 1; ToIndex < NotificationList->EventsInUse; ToIndex++ ) {

#if BIGDBG
        DbgPrint( "        - %d\n", ToIndex );
#endif
        //
        //  If we find a hole, we compact the arrays i.e. shift them to
        //  remove the hole.
        //
        if ( NotificationList->EventHandle[ ToIndex ] == NULL ) {

            //
            //  Found the beginning of a hole, search for the next
            //  entry in use.
            //
            for ( FromIndex = ToIndex+1;
                  (FromIndex < NotificationList->EventsInUse) &&
                  (NotificationList->EventHandle[ FromIndex ] == NULL );
                  FromIndex++ ) {
            }

            //
            //  If there is something to shift, shift it
            //
            if ( FromIndex < NotificationList->EventsInUse ) {

                EntriesToMove = NotificationList->EventsInUse - FromIndex;

                Src = (PVOID)&(NotificationList->EventHandle[ FromIndex ] );
                Dst = (PVOID)&(NotificationList->EventHandle[ ToIndex ] );

                RtlMoveMemory(
                         Dst,
                         Src,
                         EntriesToMove * sizeof( HANDLE )
                         );

                Src = &(NotificationList->Event[ FromIndex ] );
                Dst = &(NotificationList->Event[ ToIndex ] );

                RtlMoveMemory(
                         Dst,
                         Src,
                         EntriesToMove * sizeof( NOTIFICATION_ENTRY )
                         );

                //
                //  Clear the rest of the entries, just to keep things
                //  clean.
                //
                for ( Index = ToIndex + EntriesToMove;
                      Index < NotificationList->EventsInUse;
                      Index++ ) {

                    NotificationList->EventHandle[ Index ] = NULL;
                }

                NotificationList->EventsInUse -= (FromIndex - ToIndex);


            } else {

                //
                //  Nothing to shift, this will become the
                //  first available entry of the list.
                //
                NotificationList->EventsInUse = ToIndex;
            }
        }
    }

#if BIGDBG
    DbgPrint( "    * Compacted.\n" );
#endif


    return ERROR_SUCCESS;
}





VOID
AddNotificationListToChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Adds a Notification list to the chain of Notification Lists.

    The new list is put at the head of the chain.

Arguments:

    NotificationList    -   Supplies the Notification list to add


Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    NotificationList->Previous = NULL;
    NotificationList->Next     = NotificationListChainHead;

    if ( NotificationListChainHead ) {
        NotificationListChainHead->Previous = NotificationList;
    }

    NotificationListChainHead = NotificationList;
}




VOID
RemoveNotificationListFromChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Removes a Notification list from the chain


Arguments:

    NotificationList    -   Supplies the Notification list to remove


Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    if ( NotificationList->Previous ) {
        (NotificationList->Previous)->Next = NotificationList->Next;
    }

    if ( NotificationList->Next ) {
        (NotificationList->Next)->Previous = NotificationList->Previous;
    }


    //
    //  If this is at the head of the chain, Let the next
    //  list be the new head.
    //
    if ( NotificationListChainHead == NotificationList ) {
        NotificationListChainHead = NotificationList->Next;
    }
}



// *****************************************************************
//
//                  Pipe Symbol Table functions
//
// *****************************************************************


LONG
GetFullPipeName (
    IN  PUNICODE_STRING          MachineName,
    IN  PUNICODE_STRING          PipeName,
    OUT PUNICODE_STRING          FullPipeName
    )
/*++

Routine Description:

    Makes a fully qualified pipe name from the supplied machine
    name and pipe name.

Arguments:

    PipeName        -   Supplies the pipe name

    MachineName     -   Supplies the client's machine name

    FullPipeName    -   Supplies the full pipe name

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG            Error = ERROR_SUCCESS;
    NTSTATUS        NtStatus;

    ASSERT( PipeName->Buffer     && MachineName->Buffer &&
            PipeName->Length > 0 && MachineName->Length > 0 );

    if( !PipeName->Buffer     || !MachineName->Buffer ||
        PipeName->Length == 0 || MachineName->Length == 0 ) {
        Error =  ERROR_INVALID_PARAMETER;
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        //  If the client's machine name and our machine name match,
        //  then we form a local named pipe path, otherwise we
        //  form a remote named pipe path.
        //
        if ( RtlEqualUnicodeString(
                        MachineName,
                        &OurMachineName,
                        TRUE
                        ) ) {


            //
            //  Pipe is local
            //
            RtlMoveMemory(
                    FullPipeName->Buffer,
                    NAMED_PIPE_HERE,
                    sizeof( NAMED_PIPE_HERE )
                    );

            FullPipeName->Length = sizeof( NAMED_PIPE_HERE ) - sizeof(UNICODE_NULL);


        } else {

            //
            //  Pipe is remote
            //
            RtlMoveMemory(
                    FullPipeName->Buffer,
                    NAMED_PIPE_THERE,
                    sizeof( NAMED_PIPE_THERE )
                    );

            FullPipeName->Length = sizeof( NAMED_PIPE_THERE ) - sizeof(UNICODE_NULL);

            NtStatus = RtlAppendUnicodeStringToString(
                                FullPipeName,
                                MachineName
                                );

            ASSERT( NT_SUCCESS( NtStatus ) );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = RtlAppendUnicodeToString(
                                    FullPipeName,
                                    L"\\Pipe\\"
                                    );

                ASSERT( NT_SUCCESS( NtStatus ) );

                if ( !NT_SUCCESS( NtStatus ) ) {
                    Error = RtlNtStatusToDosError( NtStatus );
                }

            } else {

                Error = RtlNtStatusToDosError( NtStatus );
            }
        }

        if ( Error == ERROR_SUCCESS ) {

            NtStatus = RtlAppendUnicodeStringToString(
                                FullPipeName,
                                PipeName
                                );

            ASSERT( NT_SUCCESS( NtStatus ) );

            if ( !NT_SUCCESS( NtStatus ) ) {
                Error = RtlNtStatusToDosError( NtStatus );
            }
        }
    }

    return Error;
}






LONG
CreatePipeEntry (
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    )
/*++

Routine Description:

    Creates a pipe entry

Arguments:

    PipeName    -   Supplies the pipe name

    pRpcSa      -   Supplies the optional security attributes for the pipe

    PipeEntry   -   Supplies pointer to pointer to pipe entry.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    PPIPE_ENTRY PipeEntry;
    LONG        Error;
    ULONG       LengthSd;

    ASSERT( PipeName && PipeName->Buffer );

    //
    //  Validate the security descriptor if one was provided
    //
    if ( pRpcSa ) {
        if ( !RtlValidSecurityDescriptor(
                pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor
                ) ) {

            return ERROR_INVALID_PARAMETER;
        }
    }


    //
    //  Allocate space for the Pipe Entry
    //
    PipeEntry = RtlAllocateHeap(
                    RtlProcessHeap( ), 0,
                    sizeof( PIPE_ENTRY )
                    );

    if ( !PipeEntry ) {
        return ERROR_OUTOFMEMORY;
    }


    //
    //  Allocate space for the pipe's name
    //
    PipeEntry->PipeName.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap( ), 0,
                                    PipeName->Length + sizeof( UNICODE_NULL )
                                    );

    PipeEntry->PipeName.MaximumLength = PipeName->Length + (USHORT)sizeof( UNICODE_NULL );

    if ( PipeEntry->PipeName.Buffer ) {

        //
        //  Copy the pipe name
        //
        RtlCopyUnicodeString(
                &(PipeEntry->PipeName),
                PipeName
                );

        PipeEntry->Previous = NULL;
        PipeEntry->Next     = NULL;

        PipeEntry->ReferenceCount = 0;

        //
        //  Allocate space for the security descriptor if one
        //  is provided.
        //
        if ( pRpcSa ) {

            LengthSd = RtlLengthSecurityDescriptor(
                            pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor
                            );

            PipeEntry->SecurityDescriptor = RtlAllocateHeap(
                                                RtlProcessHeap( ), 0,
                                                LengthSd
                                                );


            if ( PipeEntry->SecurityDescriptor ) {

                //
                //  Copy the security descriptor
                //
                RtlMoveMemory (
                        PipeEntry->SecurityDescriptor,
                        pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor,
                        LengthSd
                        );

                *PipeEntryUsed = PipeEntry;

                return ERROR_SUCCESS;

            } else {

                Error = ERROR_OUTOFMEMORY;
            }

            RtlFreeHeap(
                 RtlProcessHeap( ), 0,
                 PipeEntry->PipeName.Buffer
                 );

        } else {

            PipeEntry->SecurityDescriptor = NULL;

            *PipeEntryUsed = PipeEntry;

            return ERROR_SUCCESS;
        }

    } else {

        Error = ERROR_OUTOFMEMORY;
    }


    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         PipeEntry
         );

    return Error;
}



LONG
DeletePipeEntry(
    IN OUT PPIPE_ENTRY  PipeEntry
    )

/*++

Routine Description:


    Deletes a pipe entry

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

#if BIGDBG
    DbgPrint( "    * In DeletePipeEntry\n" );
#endif

    ASSERT( PipeEntry );
    ASSERT( PipeEntry->PipeName.Buffer );

    if ( PipeEntry->PipeName.Buffer ) {
        RtlFreeHeap(
             RtlProcessHeap( ), 0,
            PipeEntry->PipeName.Buffer
            );
    }

    if ( PipeEntry->SecurityDescriptor != NULL ) {
        RtlFreeHeap(
             RtlProcessHeap( ), 0,
             PipeEntry->SecurityDescriptor
             );
    }

    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         PipeEntry
         );


#if BIGDBG
    DbgPrint( "    * Deleted PipeEntry.\n" );
#endif

    return ERROR_SUCCESS;
}




LONG
AddPipe(
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    )

/*++

Routine Description:

    Adds a new entry to the pipe symbol table

Arguments:

    PipeName    -   Supplies the pipe name

    pRpcSa      -   Supplies the optional security attributes for the pipe

    PipeEntry   -   Supplies pointer to pointer to pipe entry in the
                    symbol table.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    PPIPE_ENTRY PipeEntry;
    LONG        Error;


    //
    //  Look for the pipe name in the symbol table
    //
    Error  = LookForPipeEntryInSymbolTable( PipeName, &PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  If the pipe is not in the symbol table, add it
        //
        if ( !PipeEntry ) {

            //
            //  Create a new pipe entry
            //
            Error = CreatePipeEntry(
                        PipeName,
                        pRpcSa,
                        &PipeEntry
                        );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Add the entry to the symbol table
                //
                Error = AddPipeEntryToSymbolTable(
                            PipeEntry
                            );

                if ( Error != ERROR_SUCCESS ) {

                    //
                    //  Could not add pipe entry, delete it.
                    //
                    DeletePipeEntry( PipeEntry );
                    PipeEntry = NULL;
                }
            }
        }

        //
        //  If got a pipe entry, increment its reference count
        //
        if ( PipeEntry ) {

            PipeEntry->ReferenceCount++;
            *PipeEntryUsed = PipeEntry;
        }
    }

#if BIGDBG
        DbgPrint( "Added Pipe %Z:\n", PipeName );
        DumpPipeTable();
#endif

    return Error;
}




LONG
RemovePipe(
    IN OUT PPIPE_ENTRY  PipeEntry
    )

/*++

Routine Description:

    Decrements the reference count of a pipe entry and removes the
    entry if the reference count reaches zero.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry in the symbol table

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    LONG        Error = ERROR_SUCCESS;
    PPIPE_ENTRY Entry = PipeEntry;

    ASSERT( Entry );
    ASSERT( Entry->ReferenceCount > 0 );

#if BIGDBG
    DbgPrint( "    * In RemovePipe - Ref. count %d\n", Entry->ReferenceCount );
#endif

    //
    //  Decrement the reference count
    //
    Entry->ReferenceCount--;

    //
    //  If the reference count is zero, we can delete the
    //  entry
    //
    if ( Entry->ReferenceCount == 0 ) {

        //
        //  Remove the pipe entry from the symbol table
        //
        Error = RemovePipeEntryFromSymbolTable(
                    Entry
                    );

        if ( Error == ERROR_SUCCESS ) {

            //
            //  Delete the pipe entry
            //
            ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );
            Error = DeletePipeEntry( Entry );
        }
    }

#if BIGDBG
    DbgPrint( "    * Pipe Removed.\n" );
#endif

    return Error;
}



LONG
AddPipeEntryToSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    )

/*++

Routine Description:


    Adds a pipe entry to the symbol table at the specified bucket.

    Entries are always added at the head of the chain.

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   Bucket;

    Bucket = HASH( &(PipeEntry->PipeName), BUCKETS_IN_SYMBOL_TABLE );

    PipeEntry->Previous = NULL;
    PipeEntry->Next     = PipeSymbolTable.Bucket[ Bucket ];

    if ( PipeSymbolTable.Bucket[ Bucket ] ) {
        (PipeSymbolTable.Bucket[ Bucket ])->Previous = PipeEntry;
    }

    PipeSymbolTable.Bucket[ Bucket ] = PipeEntry;

    return ERROR_SUCCESS;
}




LONG
RemovePipeEntryFromSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    )

/*++

Routine Description:


    Removes a pipe entry from the symbol table at the specified bucket

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   Bucket;

#if BIGDBG
    DbgPrint( "    * In RemovePipeEntryFromSymbolTable\n" );
#endif

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );

    Bucket = HASH( &(PipeEntry->PipeName), BUCKETS_IN_SYMBOL_TABLE );

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );
    ASSERT( Bucket < BUCKETS_IN_SYMBOL_TABLE );

    //
    //  Remove the entry from the chain
    //
    if ( PipeEntry->Previous ) {
        (PipeEntry->Previous)->Next = PipeEntry->Next;
    }

    if ( PipeEntry->Next ) {
        (PipeEntry->Next)->Previous = PipeEntry->Previous;
    }


    //
    //  If this entry is at the head of the chain, Let the next
    //  entry be the new head.
    //
    ASSERT( PipeSymbolTable.Bucket[ Bucket ] != NULL );
    if ( PipeSymbolTable.Bucket[ Bucket ] == PipeEntry ) {
        PipeSymbolTable.Bucket[ Bucket ] = PipeEntry->Next;
    }

    PipeEntry->Next     = NULL;
    PipeEntry->Previous = NULL;

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );

#if BIGDBG
    DbgPrint( "    * Piped entry removed from symbol table.\n" );
#endif

    return ERROR_SUCCESS;
}




LONG
LookForPipeEntryInSymbolTable(
    IN  PUNICODE_STRING PipeName,
    OUT PPIPE_ENTRY     *PipeEntryUsed
    )
/*++

Routine Description:

    Looks for an entry corresponding to the given name in a particular
    bucket of the pipe symbol table.

    Note that this function always returns ERROR_SUCCESS. To find out
    if the pipe is in the chain or not the returned parameter has to
    be checked.

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeName    -   Supplies the pipe name

    Bucket      -   Supplies the bucket

    PipeEntry   -   Supplies pointer to pointer to pipe entry.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    PPIPE_ENTRY  PipeEntry;
    DWORD        Bucket;

    Bucket = HASH( PipeName, BUCKETS_IN_SYMBOL_TABLE );

    //
    //  Look for the entry
    //
    for ( PipeEntry = PipeSymbolTable.Bucket[ Bucket ];
          PipeEntry && !RtlEqualUnicodeString( PipeName, &(PipeEntry->PipeName), TRUE);
          PipeEntry = PipeEntry->Next );


    *PipeEntryUsed = PipeEntry;

    return ERROR_SUCCESS;
}




DWORD
Hash(
    IN  PUNICODE_STRING  Symbol,
    IN  DWORD            Buckets
    )
/*++

Routine Description:


    Obtains a hash value for a given symbol

Arguments:


    Symbol      -   Supplies the symbol to hash

    Buckets     -   Supplies the number of buckets in the sybol table.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    DWORD   n;
    DWORD   HashValue;
    WCHAR   c;
    LPWSTR  s;

#if BIGDBG
    DbgPrint( "    * Hashing\n" );
#endif

    n         = Symbol->Length/sizeof(WCHAR);
    s         = Symbol->Buffer;
    HashValue = 0;

    while (n--) {

        c = *s++;

        HashValue = HashValue + (c << 1) + (c >> 1) + c;
    }

    return HashValue % Buckets;

}







// *****************************************************************
//
//                  Notification List Handler
//
// *****************************************************************



VOID
NotificationHandler(
    IN  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Handler of a Notification List.

Arguments:


    NotificationList    -   Supplies pointer to the Notification List
                            to handle.

Return Value:

    None

--*/

{

    NTSTATUS        NtStatus;
    DWORD           NumberOfEvents;
    HANDLE          Thread;
    BOOLEAN         KeepOnGoing = TRUE;
    DWORD           Index;
    LARGE_INTEGER   TimeOut;


    ASSERT( NotificationList );

    //
    //  Initially we'll wait on only one event, i.e. the
    //  "wake up" event
    //
    NumberOfEvents = 1;
    NotificationList->TimeOutCount = 0;
    NotificationList->ResetCount = FALSE;

    while ( KeepOnGoing ) {

        TimeOut.QuadPart = Int32x32To64( -10000,
                                         5000*NotificationList->TimeOutCount );

        //
        //  Wait for some event
        //
        NtStatus = NtWaitForMultipleObjects(
                        (CHAR)NumberOfEvents,
                        NotificationList->EventHandle,
                        WaitAny,
                        FALSE,
                        (NotificationList->PendingNotifications > 0) ?
                            &TimeOut : NULL
                        );

        Index = (DWORD)NtStatus;

        if ( (Index < 0) || (Index >= NumberOfEvents) ) {
            Index = 0;
        }

        ASSERT( Index < NumberOfEvents );

        NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
        ASSERT( NT_SUCCESS( NtStatus ) );

#if BIGDBG
        DbgPrint( "WINREG: Notification handler signaled, Index %d\n", Index );
#endif

        try {

            //
            //  If an event was triggered, mark it as a pending notification so
            //  that the NotificationListMaintenance function will notify
            //  the client.
            //
            if ( Index > 0 ) {
                NotificationList->PendingNotifications++;
                NotificationList->Event[Index].Flags |= MUST_NOTIFY;
            }

            //
            //  Notify all the clients with pending notifications and
            //  remove entries for dead clients.
            //
            NumberOfEvents = NotificationListMaintenance( NotificationList );

            if( NotificationList->PendingNotifications != 0 ) {
                if( NotificationList->ResetCount ) {
                    NotificationList->TimeOutCount = 1;
                    NotificationList->ResetCount = FALSE;
                } else {
                    if( NotificationList->TimeOutCount == 0 ) {
                        NotificationList->TimeOutCount = 1;
                    } else {
                        if( NotificationList->TimeOutCount != MAX_TIMEOUT_COUNT ) {
                            NotificationList->TimeOutCount =
                                          NotificationList->TimeOutCount << 1;
                        }
                    }
                }
            } else {
                NotificationList->TimeOutCount = 0;
            }

            //
            //  If the list is empty, then try to take it out of the chain, and
            //  if successful, our job is done.
            //
            if ( NumberOfEvents == 1 ) {

#if BIGDBG
                DbgPrint( "    * Removing the notification list!\n" );
#endif
                //
                //  Make sure that the list is empty.
                //
                ASSERT( NotificationList->EventsInUse == 1 );
                if (NotificationList->EventsInUse == 1) {

                    //
                    //  The list is empty, remove the list from the chain
                    //  and delete it.
                    //
                    RemoveNotificationListFromChain( NotificationList );
                    Thread = NotificationList->HandlerThread;
                    DeleteNotificationList( NotificationList );

                    //
                    //  The list is gone, we can die.
                    //
                    KeepOnGoing = FALSE;
                }
            }

        } except ( NtStatus = GetExceptionCode() ) {

#if DBG
            DbgPrint( "WINREG Error: Exception %x in NotificationHandler\n",
                      NtStatus );
            DbgBreakPoint();
#endif

        }


#if BIGDBG
        if ( KeepOnGoing ) {
            DbgPrint( "WINREG: Notification handler waiting...\n" );
        } else {
            DbgPrint( "WINREG: Notification handler dying...\n" );
        }
#endif

        NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
        ASSERT( NT_SUCCESS( NtStatus ) );

    }

    //
    //  The list is gone, and so must we.
    //
    ExitThread( 0 );

    ASSERT( FALSE );

}



DWORD
NotificationListMaintenance(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Performs all the maintenance necessary in the notification list.
    The maintenance consists of:

    - Notifying all clients with pending notifications.

    - Removing entries in the list for dead clients.

    - Compacting the notification list.

Arguments:


    NotificationList    -   Supplies pointer to the Notification List

Return Value:

    DWORD   -   The new number of events in the list

--*/

{

    LONG                Error;
    DWORD               NumberOfEvents;
    DWORD               Index;
    BOOLEAN             Remove;
    PNOTIFICATION_ENTRY Event;
    NTSTATUS            NtStatus;
    PPIPE_ENTRY         PipeEntry;

#if BIGDBG
    DbgPrint( "    * In NotificationListMaintenance\n" );
    DumpNotificationLists();
#endif

    //
    //  Traverse the list notifying clients if necessary and removing
    //  events that are no longer needed, either because they have
    //  already been notified or because the client is dead.
    //
    for (Index = 1; Index < NotificationList->EventsInUse; Index++ ) {

#if BIGDBG
        DbgPrint( "      - %d\n", Index );
#endif
        Remove = FALSE;
        Event  = &(NotificationList->Event[ Index ]);

        if ( Event->Flags & CLIENT_IS_DEAD ) {

            //
            //  No client, must remove the entry.
            //
            Remove = TRUE;

        } else if ( Event->Flags & MUST_NOTIFY ) {

            //
            //  Must notify this client
            //
            Error = SendEventToClient(
                        Event->ClientEvent,
                        Event->PipeEntry
                        );

            if (Error == ERROR_SUCCESS) {
                //
                //  If successfully notified, remove the entry.
                //
                Remove = TRUE;
                Event->Flags &= ~NOTIFICATION_FAILED;
            } else {
                //
                //  If couldn't notify, set ResetCount if the notification
                //  failed for the first time
                //
                if( ( Event->Flags & NOTIFICATION_FAILED ) == 0 ) {
                    NotificationList->ResetCount = TRUE;
                    Event->Flags |= NOTIFICATION_FAILED;
                }
            }
        }

        //
        //  Remove the entry if no longer needed.
        //
        if ( Remove ) {

            //
            //  Remove the pipe entry
            //
            PipeEntry = Event->PipeEntry;
            RemovePipe( PipeEntry );

            Event->PipeEntry = NULL;

            //
            //  Remove the event
            //
#if BIGDBG
            DbgPrint( "        Cleanup\n" );
#endif

            NtStatus = NtClose( NotificationList->EventHandle[ Index ] );
            ASSERT( NT_SUCCESS( NtStatus ) );
            NotificationList->EventHandle[ Index ] = NULL;

            //
            //  If this was a pending notification, decrement the
            //  counter.
            //
            if ( Event->Flags & MUST_NOTIFY ) {
                NotificationList->PendingNotifications--;
            }
        }
    }


    //
    //  Compact the list.
    //
    Error = CompactNotificationList( NotificationList );

    ASSERT( Error == ERROR_SUCCESS );

    //
    //  Get the new number of entries in the list
    //
    NumberOfEvents = NotificationList->EventsInUse;

#if BIGDBG
    DbgPrint( "    * Maintenance Done (%d)\n", NumberOfEvents );
#endif

    return NumberOfEvents;
}





LONG
SendEventToClient(
    IN  DWORD           ClientEvent,
    IN  PPIPE_ENTRY     PipeEntry
    )
/*++

Routine Description:

    Sends an event to the client via the client's named pipe

Arguments:


    PipeEntry       -   Supplies the pipe entry for the client's named
                        pipe.

    ClientEvent     -   Supplies the event that has to be sent to the
                        client.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.

--*/

{

    HANDLE              Handle;
    LONG                Error = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            NtStatus;

    ASSERT( PipeEntry != NULL );
    ASSERT( PipeEntry->PipeName.Buffer != NULL );

    //
    // Initialize the Obja structure for the named pipe
    //
    InitializeObjectAttributes(
        &Obja,
        &(PipeEntry->PipeName),
        OBJ_CASE_INSENSITIVE,
        NULL,
        PipeEntry->SecurityDescriptor
        );


    //
    // Open our side of the pipe
    //
    NtStatus = NtOpenFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_WRITE,
                    FILE_NON_DIRECTORY_FILE
                    );


    if ( NT_SUCCESS( NtStatus ) ) {

        //
        //  Write the event
        //
        NtStatus = NtWriteFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        &ClientEvent,
                        sizeof(ClientEvent),
                        NULL,
                        NULL
                        );

        if ( NtStatus == STATUS_PENDING ) {
            NtStatus = NtWaitForSingleObject(
                            Handle,
                            FALSE,
                            NULL );
        }

        if ( NT_SUCCESS( NtStatus ) ) {
#if BIGDBG
            DbgPrint( "    --> Client Notified, Event 0x%x\n", ClientEvent );
#endif
            Error = ERROR_SUCCESS;
        } else {
            Error = RtlNtStatusToDosError( NtStatus );
        }


        //
        //  Close our side of the pipe
        //
        NtStatus = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus ) );

    } else {

        //
        //  If we couldn't open the pipe because the pipe does
        //  not exist, there's no point in keep trying.
        //
        if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Error = ERROR_SUCCESS;
        } else {
            Error = RtlNtStatusToDosError( NtStatus );
#if DBG
            DbgPrint( "WINREG: Cannot Open pipe %Z, event %x, status %x\n",
                  &(PipeEntry->PipeName), ClientEvent, NtStatus );
#endif
        }
    }

#if DBG
    if (Error != ERROR_SUCCESS ) {
        DbgPrint( "WINREG: Could not notify client, Error %d\n", Error );
    }
#endif

    return Error;
}


#if BIGDBG

// *****************************************************************
//
//                      Debug Stuff
//
// *****************************************************************


VOID
DumpNotificationLists(
    )
/*++

Routine Description:

    Dumps the notification lists

Arguments:


    None

Return Value:

    None

--*/

{
    PNOTIFICATION_LIST  NotificationList;
    PNOTIFICATION_ENTRY Event;
    DWORD               Index;

    DbgPrint( "        Notification list dump: \n\n" );

    for ( NotificationList = NotificationListChainHead;
          NotificationList;
          NotificationList = NotificationList->Next ) {

        DbgPrint( "        Notification List at 0x%x\n", NotificationList );
        DbgPrint( "        Pending notifications: %d\n", NotificationList->PendingNotifications );

        Event = &(NotificationList->Event[1]);

        for ( Index = 1; Index < NotificationList->EventsInUse; Index++ ) {

            DbgPrint( "          Event %d EventHandle 0x%x Client 0x%x",
                            Index,
                            NotificationList->EventHandle[ Index ],
                            Event->ClientEvent );

            if ( Event->Flags & CLIENT_IS_DEAD ) {
                DbgPrint( " (Dead)\n" );
            } else if ( Event->Flags & MUST_NOTIFY ) {
                DbgPrint( " (Notify)\n" );
            } else {
                DbgPrint( "\n" );
            }

            Event++;
        }

        DbgPrint( "\n");
    }

    DbgPrint( "\n");
}


VOID
DumpPipeTable(
    )
/*++

Routine Description:

    Dumps the pipe table

Arguments:


    None

Return Value:

    None

--*/

{
    DWORD       i;
    PPIPE_ENTRY Entry;

    DbgPrint( "\n\n      Pipes:\n\n" );

    for ( i=0; i < BUCKETS_IN_SYMBOL_TABLE; i++ ) {

        Entry = PipeSymbolTable.Bucket[i];
        if ( Entry ) {
            DbgPrint( "        Bucket %d:\n",i );
            while ( Entry ) {
                DbgPrint( "        %Z (%d)\n", &(Entry->PipeName), Entry->ReferenceCount );
                Entry = Entry->Next;
            }
        }
    }

    DbgPrint( "\n" );
}


#endif  // BIGDBG

#endif   // REMOTE_NOTIFICATION_DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regrpc_server.c ===
#include <regrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regqkey.c ===
/*++




Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regqkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry query key API. That is:

        - BaseRegQueryInfoKey

Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include "regvcls.h"
#include <malloc.h>

#define DEFAULT_CLASS_SIZE          128

//
// Internal prototypes
//

NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength);

void CombineKeyInfo(
    PVOID                   KeyInfo,
    PVOID                   MachineClassKeyInfo,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    DWORD                   dwTotalSubKeys,
    DWORD                   dwTotalValues);



error_status_t
BaseRegQueryInfoKey(
    IN HKEY hKey,
    OUT PUNICODE_STRING lpClass,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    RegQueryInfoKey returns pertinent information about the key
    corresponding to a given key handle.

Arguments:

    hKey - A handle to an open key.

    lpClass - Returns the Class string for the key.

    lpcSubKeys - Returns the number of subkeys for this key .

    lpcbMaxSubKeyLen - Returns the length of the longest subkey name.

    lpcbMaxClassLen  - Returns length of longest subkey class string.

    lpcValues - Returns the number of ValueNames for this key.

    lpcbMaxValueNameLen - Returns the length of the longest ValueName.

    lpcbMaxValueLen - Returns the length of the longest value entry's data
        field.

    lpcbSecurityDescriptor - Returns the length of this key's
        SECURITY_DESCRIPTOR.

    lpftLastWriteTime - Returns the last time that the key or any of its
        value entries was modified.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.


--*/

{
    NTSTATUS                Status;
    ULONG                   BufferLength;
    PVOID                   KeyInfo;
    PVOID                   ClassKeyInfo;
    KEY_INFORMATION_CLASS   KeyInformationClass;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    ULONG                   SecurityDescriptorLength;
    LONG                    Error;
    PDWORD                  pCbMaxClassLen = NULL;
    PDWORD                  pCbSecurityDescriptor = NULL;

    BYTE    PrivateKeyFullInfo[ sizeof( KEY_FULL_INFORMATION ) +
                                        DEFAULT_CLASS_SIZE ];

    BYTE    PrivateClassKeyInfo[ sizeof( KEY_FULL_INFORMATION ) +
                               DEFAULT_CLASS_SIZE ];

    if( (lpClass == NULL )              ||
        (lpcSubKeys == NULL )           ||
        (lpcbMaxSubKeyLen == NULL)      ||
        (lpcValues == NULL)             ||
        (lpcbMaxValueNameLen == NULL)   ||
        (lpcbMaxValueLen == NULL)       ||
        (lpftLastWriteTime == NULL ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( sizeof(KEY_FULL_INFORMATION) >= sizeof(KEY_CACHED_INFORMATION) );

    if( lpcbMaxClassLen != NULL ) {
        pCbMaxClassLen = lpcbMaxClassLen;
    }

    if( lpcbSecurityDescriptor != NULL ) {
        pCbSecurityDescriptor = lpcbSecurityDescriptor;
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        DWORD                   cbMaxClassLen;
        DWORD                   cbSecurityDescriptor;
        //
        // Impersonate the client.
        //

        RPC_IMPERSONATE_CLIENT( NULL );

        // 
        // don't mess with Perf stuff
        //
        if( pCbMaxClassLen == NULL ) {
            pCbMaxClassLen = &cbMaxClassLen;
        }
        if( pCbSecurityDescriptor == NULL ) {
            pCbSecurityDescriptor = &cbSecurityDescriptor;
        }

        Error = PerfRegQueryInfoKey (
                                    hKey,
                                    lpClass,
                                    NULL,
                                    lpcSubKeys,
                                    lpcbMaxSubKeyLen,
                                    pCbMaxClassLen,
                                    lpcValues,
                                    lpcbMaxValueNameLen,
                                    lpcbMaxValueLen,
                                    pCbSecurityDescriptor,
                                    lpftLastWriteTime
                                    );
        RPC_REVERT_TO_SELF();

        return (error_status_t)Error;

    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );


    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyFullInformattion
    //

    if( (lpClass->Buffer == NULL) && (pCbMaxClassLen == NULL) ) {
        KeyInformationClass = KeyCachedInformation;
    } else {
        KeyInformationClass = KeyFullInformation;
    }

    ClassKeyInfo = (PVOID)PrivateClassKeyInfo;
    KeyInfo = (PVOID)PrivateKeyFullInfo;
    BufferLength = sizeof( PrivateKeyFullInfo );


    //
    // Ask Nt for all the meta information about this key.
    //

    Status = QueryKeyInfo(
                hKey,
                KeyInformationClass,
                &KeyInfo,
                BufferLength,
                lpClass->Buffer ? TRUE : FALSE,
                lpClass->MaximumLength
                );


    if( (NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) &&
        (KeyInformationClass == KeyFullInformation)
      ) {

        lpClass->Length = ( USHORT )
                          ( (( PKEY_FULL_INFORMATION )KeyInfo)->ClassLength
                            + sizeof( UNICODE_NULL )
                          );
    }


    if ( NT_SUCCESS( Status )) {

#ifdef LOCAL

        //
        // For special keys in HKCR, we can't just take the information
        // from the kernel -- these keys have properties that come from
        // both the user and machine versions of their keys. To find out
        // if it's a special key, we get more information below
        //
        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            {
                HKEY    hkMachineClass;
                HKEY    hkUserClass;

                BufferLength = sizeof( PrivateClassKeyInfo );

                //
                // we will now need information from both the user
                // and machine locations to find the number of
                // subkeys under this special key -- the machine
                // key is not open yet, so we open it below
                //

                //
                // Open the other key
                //
                Status = BaseRegGetUserAndMachineClass(
                    NULL,
                    hKey,
                    MAXIMUM_ALLOWED,
                    &hkMachineClass,
                    &hkUserClass);

                if (NT_SUCCESS(Status) && (hkUserClass && hkMachineClass)) {

                    DWORD dwTotalSubKeys;
                    HKEY  hkQuery;

                    if (hkUserClass == hKey) {
                        hkQuery = hkMachineClass;
                    } else {
                        hkQuery = hkUserClass;
                    }

                    //
                    // Still need to do this query to find out
                    // the largest subkey in the machine part
                    // as well as other information about the
                    // key such as its largest subkey
                    //
                    Status = QueryKeyInfo(
                        hkQuery,
                        KeyInformationClass,
                        &ClassKeyInfo,
                        BufferLength,
                        FALSE,
                        lpClass->MaximumLength);

                    //
                    // Now we will count the keys
                    //
                    if (NT_SUCCESS(Status)) {

                        Status = ClassKeyCountSubKeys(
                            hKey,
                            hkUserClass,
                            hkMachineClass,
                            0,
                            &dwTotalSubKeys);
                    }

                    NtClose(hkQuery);

                    //
                    // Do not let inability to query information for
                    // machine key cause a complete failure -- we'll
                    // just use the user key's information
                    //
                    if (!NT_SUCCESS(Status)) {

                        //
                        // this key may not exist in the machine hive
                        //
                        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {
                            Status = STATUS_SUCCESS;
                        }

                        if (STATUS_BUFFER_OVERFLOW  == Status) {
                            Status = STATUS_SUCCESS;
                        }
                    } else {

                        ValueState* pValState;

                        //
                        // Find out how many values we have
                        //
                        Status = KeyStateGetValueState(
                            hKey,
                            &pValState);

                        if (NT_SUCCESS(Status)) {

                            //
                            // Combine the information from the two
                            // trees
                            //
                            CombineKeyInfo(
                                KeyInfo,
                                ClassKeyInfo,
                                KeyInformationClass,
                                dwTotalSubKeys,
                                pValState ? pValState->cValues : 0);
                            
                            ValStateRelease(pValState);
                        }
                    }
                }
            }
        }
#endif // LOCAL
    }

    if( NT_SUCCESS( Status )) {

        //
        // don't bother if the caller is not interested in this
        //
        if( pCbSecurityDescriptor != NULL ) {
            ASSERT( lpcbSecurityDescriptor != NULL );
            //
            // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP
            // and DACL. These three are always accessible (or inaccesible)
            // as a set.
            //

            Status = NtQuerySecurityObject(
                        hKey,
                        OWNER_SECURITY_INFORMATION
                        | GROUP_SECURITY_INFORMATION
                        | DACL_SECURITY_INFORMATION,
                        &SecurityDescriptor,
                        0,
                        lpcbSecurityDescriptor
                        );

            //
            // If getting the size of the SECURITY_DESCRIPTOR failed (probably
            // due to the lack of READ_CONTROL access) return zero.
            //

            if( Status != STATUS_BUFFER_TOO_SMALL ) {

                *lpcbSecurityDescriptor = 0;

            } else {

                //
                // Try again to get the size of the key's SECURITY_DESCRIPTOR,
                // this time asking for SACL as well. This should normally
                // fail but may succeed if the caller has SACL access.
                //

                Status = NtQuerySecurityObject(
                            hKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION
                            | SACL_SECURITY_INFORMATION,
                            &SecurityDescriptor,
                            0,
                            &SecurityDescriptorLength
                            );


                if( Status == STATUS_BUFFER_TOO_SMALL ) {

                    //
                    // The caller had SACL access so update the returned
                    // length.
                    //

                    *lpcbSecurityDescriptor = SecurityDescriptorLength;
                }
            }
        }


        if( KeyInformationClass == KeyCachedInformation ) {
            ASSERT( pCbMaxClassLen == NULL );
            *lpcSubKeys             = ((PKEY_CACHED_INFORMATION)KeyInfo)->SubKeys;
            *lpcbMaxSubKeyLen       = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen;
            *lpcValues              = ((PKEY_CACHED_INFORMATION)KeyInfo)->Values;
            *lpcbMaxValueNameLen    = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen;
            *lpcbMaxValueLen        = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen;
            *lpftLastWriteTime      = *( PFILETIME ) &((PKEY_CACHED_INFORMATION)KeyInfo)->LastWriteTime;
            Error = ERROR_SUCCESS;
        } else {
            *lpcSubKeys             = ((PKEY_FULL_INFORMATION)KeyInfo)->SubKeys;
            if( pCbMaxClassLen != NULL ) {
                *lpcbMaxClassLen        = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen;
                ASSERT( pCbMaxClassLen == lpcbMaxClassLen );
            }
            *lpcbMaxSubKeyLen       = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen;
            *lpcValues              = ((PKEY_FULL_INFORMATION)KeyInfo)->Values;
            *lpcbMaxValueNameLen    = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen;
            *lpcbMaxValueLen        = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen;
            *lpftLastWriteTime      = *( PFILETIME ) &((PKEY_FULL_INFORMATION)KeyInfo)->LastWriteTime;



            //
            // Copy/assign remaining output parameters.
            //
            if ( (!lpClass->Buffer) || (lpClass->Length > lpClass->MaximumLength) ) {

                if( lpClass->Buffer != NULL ) {
#ifndef LOCAL
                    lpClass->Buffer = NULL;
#endif //LOCAL
                    Error = (error_status_t)RtlNtStatusToDosError( STATUS_BUFFER_TOO_SMALL );
                } else {
                    //
                    // Caller is not iterest in Class, so return its size only.
                    //
                    Error = ERROR_SUCCESS;
                }

            } else {

                if( ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength != 0 ) {

                    ASSERT( lpClass->Buffer != NULL );
                    RtlMoveMemory(
                        lpClass->Buffer,
                        ((PKEY_FULL_INFORMATION)KeyInfo)->Class,
                        ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength
                        );
                }

                //
                // NUL terminate the class name.
                //

                lpClass->Buffer[ ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength >> 1 ] = UNICODE_NULL;

                Error = ERROR_SUCCESS;
            }
        }

    } else if( Status == STATUS_BUFFER_OVERFLOW ) {

        //
        // A return value of STATUS_BUFFER_OVERFLOW means that the user did
        // not supply enough space for the class. The required space has
        // already been assigned above.
        //
#ifndef LOCAL
        lpClass->Buffer = NULL;
#endif //LOCAL
        Error = ERROR_INVALID_PARAMETER;

    } else {

        //
        // Some other error occurred.
        //

        Error = RtlNtStatusToDosError( Status );
    }

    if( KeyInfo != ( PVOID )PrivateKeyFullInfo ) {

        //
        // Free the buffer and return the Registry return value.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyInfo );
    }

    if( ClassKeyInfo != ( PVOID )PrivateClassKeyInfo ) {

        //
        // Free the buffer and return the Registry return value.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, ClassKeyInfo );
    }

    return (error_status_t)Error;
}

NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength)
/*++

Routine Description:

    Queries the kernel for key information.

Arguments:

    hKey - handle of key for which to query info

    KeyInformationClass - type of info required from the kernel

    KeyInfo - pointer to address of
           buffer for information about key

    BufferLength - size of KeyFullInfo buffer

    fClass - flag set to TRUE if the class for this
        key should be rerieved

    MaxClassLength - maximum size for class data that a caller
        is willing to support. The ppKeyFullInfo buffer may
        point to the address of a buffer that can handle the
        class size of the key, but the caller may want the class
        to fit in some smaller buffer later, so this param lets
        the caller limit that size.  It is ignored if fClass
        is FALSE.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS Status;
    ULONG Result;

    ASSERT( KeyInformationClass == KeyFullInformation ||
            KeyInformationClass == KeyCachedInformation );

    Status = NtQueryKey(
                hKey,
                KeyInformationClass,
                *ppKeyInfo,
                BufferLength,
                &Result);

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the fixed portion of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if ( Status == STATUS_BUFFER_OVERFLOW ) {

        // we cannot hit this on a CachedInfo fixed structure

        ASSERT( KeyInformationClass == KeyFullInformation );
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Key Information.
        //
        //  If the fClass flag is not set, then the caller does not do the
        //  check for the caller specified maximum class length below
        //  and requeries happily.  If the flag is set, we do the check, and
        //  if the class size is bigger than what the caller specified as
        //  the max, we return STATUS_BUFFER_OVERFLOW.
        //

        if ( !fClass || ((ULONG)(MaxClassLength) >=
              (( PKEY_FULL_INFORMATION )*ppKeyInfo )->ClassLength + sizeof( UNICODE_NULL )) ) {

                //
                // Required length is stored in Result -- set our length
                // to the required length and allocate memory for it.
                //

                BufferLength = Result;

                *ppKeyInfo = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                  BufferLength );
                //
                // If the memory allocation fails, return a Registry error.
                //

                if( ! *ppKeyInfo ) {
                    return STATUS_NO_MEMORY;
                }

                //
                // Query for the necessary information about the supplied key.
                //

                Status = NtQueryKey( hKey,
                                     KeyFullInformation,
                                     *ppKeyInfo,
                                     BufferLength,
                                     &Result
                                   );
        }
    }

    return Status;
}

void CombineKeyInfo(
    PVOID                   KeyInfo,
    PVOID                   MachineClassKeyInfo,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    DWORD                   dwTotalSubKeys,
    DWORD                   dwTotalValues)
/*++

Routine Description:

    Combine the information from the user and machine hives
    for a special key

Arguments:

    Status -

    KeyInfo - buffer for  information about user key

    MachineClassKeyInfo - buffer for information about machine key

    KeyClassInformation - type of information present in buffers

    dwTotalSubKeys - total number of subkeys for the two
        in each hive

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    ASSERT( KeyInformationClass == KeyCachedInformation ||
            KeyInformationClass == KeyFullInformation );

    if( KeyInformationClass == KeyCachedInformation ) {
        //
        // Set the number of keys to be the total between the
        // two versions in each hive
        //
        ((PKEY_CACHED_INFORMATION)KeyInfo)->SubKeys = dwTotalSubKeys;
        ((PKEY_CACHED_INFORMATION)KeyInfo)->Values = dwTotalValues;

        //
        // Set our max namelen to the namelen of whichever is biggest
        // between the two hives. Same for class.
        //

        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxNameLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxNameLen;
        }
   
        //
        // Since we also merge values, we must set the value information as well
        //
        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen;
        }

        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen;
        }
    } else {
        //
        // Set the number of keys to be the total between the
        // two versions in each hive
        //
        ((PKEY_FULL_INFORMATION)KeyInfo)->SubKeys = dwTotalSubKeys;
        ((PKEY_FULL_INFORMATION)KeyInfo)->Values = dwTotalValues;

        //
        // Set our max namelen to the namelen of whichever is biggest
        // between the two hives. Same for class.
        //

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxNameLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxNameLen;
        }

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxClassLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxClassLen;
        }
    
        //
        // Since we also merge values, we must set the value information as well
        //
        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen;
        }

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regqval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regqval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry query value API. That is:

        - BaseRegQueryValue
        - BaseRegQueryMultipleValues
        - BaseRegQueryMultipleValues2

Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

Revision History:

    Dragos C. Sambotin (dragoss) 12-Nov-2001
        Add new method to close DoS attack when the server is modifying ldwTotsize
        to a value bigger than the actual buffer size and RPC checks the buffer on return.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"


#define DEFAULT_VALUE_SIZE          128
#define DEFAULT_VALUE_NAME_SIZE     64


error_status_t
BaseRegQueryValue(
    IN HKEY hKey,
    IN PUNICODE_STRING lpValueName,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData OPTIONAL,
    OUT LPDWORD lpcbData  OPTIONAL,
    IN OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    For an open key, given the ID of the value to query, return
    the type, and value.

Arguments:

    hKey - Supplies a handle to the open key.  The value entries returned
        are contained in the key pointed to by this key handle.  Any of the
        predefined reserved handles or a previously opened key handle may be
        used for hKey.

    lpValueName - Supplies a pointer to the name of the value.

    lpType - If present, supplies a pointer to variable to receive the
        type code of value entry.

    lpData -If present, supplies a pointer to a buffer to receive the
        data of the value entry.

    lpcbData - Supplies a pointer to a variable which on input contains
        the size of the buffer lpData points to.  On output, the variable will
        receive the number of bytes returned in lpData.  It must be supplied
        if lpData is, it is ignored otherwise.

    lpcbLen - Return the number of bytes to transmit to the client (used
        by RPC).

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.


--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;
    ULONG                           ResultLength;
    HKEY                            hkQueryKey;

    BYTE    PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION ) +
                                        DEFAULT_VALUE_SIZE ];
#ifdef LOCAL
    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;
#endif LOCAL
    hkQueryKey = hKey;

    if( (lpValueName == NULL)           ||
        (!lpValueName->Length)          ||
        (lpValueName->Length & 1)       ||
        (lpcbData == NULL)              ||
        (lpcbLen == NULL)               ||
        (lpType == NULL) ) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }



    //
    //  If the client gave us a bogus size, patch it.
    //
    if ( ARGUMENT_PRESENT( lpcbData ) && !ARGUMENT_PRESENT( lpData ) ) {
        *lpcbData = 0;
    }


    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        error_status_t Error;

        //
        // Impersonate the client.
        //

        RPC_IMPERSONATE_CLIENT( NULL );

        Error = (error_status_t)PerfRegQueryValue (
                            hKey,
                            lpValueName,
                            NULL,
                            lpType,
                            lpData,
                            lpcbData,
                            lpcbLen
                            );
        RPC_REVERT_TO_SELF();
        return(Error);
    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

    //
    //  Subtract the NULL from the Length. This was added on
    //  the client side so that RPC would transmit it.
    //
    if ( lpValueName->Length > 0 ) {
        lpValueName->Length -= sizeof( UNICODE_NULL );
    }

    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyValueInformationClass = ( ARGUMENT_PRESENT( lpcbData ))?
                               KeyValuePartialInformation :
                               KeyValueBasicInformation;


    KeyValueInformation = PrivateKeyValueInformation;
    BufferLength = sizeof( PrivateKeyValueInformation );

    //
    // Query for the necessary information about the supplied value. This
    // may or may not include the data depending on lpcbData as determined
    // above.
    //
#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hKey,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t) RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkQueryKey = hkUserClasses;
    }

    for (;;) {
#endif

        Status = NtQueryValueKey( hkQueryKey,
                                  lpValueName,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
            );
#ifdef LOCAL
        //
        // If we don't have two classes keys to worry about,
        // just continue as we normally would
        //
        if (!hkUserClasses || !hkMachineClasses) {
            break;
        }
        
        //
        // If we're using machine, then we don't want to repeat
        // since machine is the last resort
        //
        if (hkQueryKey == hkMachineClasses) {
            break;
        }

        //
        // If the key doesn't exist in user, then let's try
        // again in machine
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {
            hkQueryKey = hkMachineClasses;
            continue;
        }

        break;
    }
#endif

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if( ( Status == STATUS_BUFFER_OVERFLOW ) &&
        ( !ARGUMENT_PRESENT( lpData ) ) ) {
        //
        //  STATUS_BUFFER_OVERFLOW means that the API returned all the
        //  information in the fixed portion of the structure
        //  KEY_VALUE_BASIC_INFORMATION or KEY_VALUE_PARTIAL_INFORMATION,
        //  but not the value name or the value data.
        //
        //  If KeyValueInformationClass is equal to KeyValueBasicInformation
        //  then the API would return the value name. But since we are not
        //  interested in the value name (it was supplied by the client), we
        //  can assume that the API succeeded.
        //
        //  If KeyValueInformationClass is equal to KeyValuePartialInformation
        //  then the API would return the value data. But lpData == NULL
        //  means that the client is not interested on the value data, but
        //  just on its size. For this reason, we can also assume that the
        //  API succeeded.
        //

        Status = STATUS_SUCCESS;
    }

    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Value information.
        //  If the caller's buffer is big enough to hold the value data
        //  then allocate a new buffer, and call the NT API again.
        //
        if( ( ( KeyValueInformationClass == KeyValuePartialInformation ) &&
              ( ARGUMENT_PRESENT( lpData ) ) &&
              ( *lpcbData >=
                 (( PKEY_VALUE_PARTIAL_INFORMATION )
                 KeyValueInformation )->DataLength
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                   BufferLength
                                                 );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyValueInformation ) {
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied value.
            //

            Status = NtQueryValueKey( hkQueryKey,
                                      lpValueName,
                                      KeyValueInformationClass,
                                      KeyValueInformation,
                                      BufferLength,
                                      &ResultLength
                                    );
        }
    }

#ifdef LOCAL
    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }
#endif // LOCAL

    if( NT_SUCCESS( Status ) &&
        ARGUMENT_PRESENT( lpData ) ) {
        //
        //  If requested, copy the value data
        //
        if( *lpcbData >= (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->DataLength ) {

            RtlMoveMemory( lpData,
                           (( PKEY_VALUE_PARTIAL_INFORMATION )
                                KeyValueInformation )->Data,
                           (( PKEY_VALUE_PARTIAL_INFORMATION )
                                KeyValueInformation )->DataLength
                         );
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }


    //
    // Certain information is returned on success or in the case of
    // NtQueryValueKey returning STATUS_BUFFER_OVERFLOW.  This information
    // is always available because we always pass the minimum size required for
    // the NtQueryValueKey API.
    //

    if( NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) {

        if( KeyValueInformationClass == KeyValueBasicInformation ) {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_BASIC_INFORMATION )
                            KeyValueInformation )->Type;
            }

        } else {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->Type;
            }

            //
            // Return the value data size
            //
            *lpcbData = (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->DataLength;
        }
    }

    //
    // Transmit all of the data back to the client.
    //

    if( ARGUMENT_PRESENT( lpcbLen ) ) {
        if( NT_SUCCESS( Status ) &&
            ARGUMENT_PRESENT( lpData ) ) {
            *lpcbLen = (( PKEY_VALUE_PARTIAL_INFORMATION )
                        KeyValueInformation )->DataLength;
        } else {
            //
            // The API failed, so make sure that no data is transmitted back
            // to the client. This ensures that the client stub will not
            // attempt to unmarshall data that doesn't exist.
            //

            *lpcbLen = 0;
        }
    }

    //
    //  If memory was allocated, then free it
    //
    if( KeyValueInformation != PrivateKeyValueInformation ) {

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyValueInformation );
    }
    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
BaseRegQueryMultipleValues(
    IN HKEY hKey,
    IN OUT PRVALENT val_list,
    IN DWORD num_vals,
    OUT LPSTR lpvalueBuf,
    IN OUT LPDWORD ldwTotsize
    )
/*++

Routine Description:
    
    Stub: Just calls into the new method. Never changes the 
    ldwTotsize value to a vallue bigger than what was passed in.
    
--*/
{
    ULONG           RequiredLength;
    error_status_t  Error;

    if( ldwTotsize == NULL ) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }

    Error = BaseRegQueryMultipleValues2(hKey,val_list,num_vals,lpvalueBuf,ldwTotsize,&RequiredLength);

    //
    // only for backward compatibility
    //
    if( Error == ERROR_SUCCESS ) {
        *ldwTotsize = RequiredLength;
    } else {
        //
        // The API failed, so make sure that no data is transmitted back
        // to the client. This ensures that the client stub will not
        // attempt to unmarshall data that doesn't exist.
        //

        *ldwTotsize = 0;
    }


    return Error;
}

error_status_t
BaseRegQueryMultipleValues2(
    IN HKEY hKey,
    IN OUT PRVALENT val_list,
    IN DWORD num_vals,
    OUT LPSTR lpvalueBuf,
    IN LPDWORD ldwTotsize,
    OUT LPDWORD ldwRequiredSize
    )
/*++

Routine Description:

    For an open key, atomically queries a set of values.

Arguments:

    hKey - Supplies a handle to the open key. The value entries returned
           are contained in the key pointed to by this key handle. Any of
           the predefined reserved handles or a previously opened key handle
           may be used for hKey.

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. 
                 
    ldwRequiredSize - If lpValueBuf is not large enough to contain all the data, 
                     returns the size of lpValueBuf required to return all the 
                     requested data here. Otherwise this value is not touched.

    

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/
{
    NTSTATUS    Status;
    DWORD       LocalTotSize;
    ULONG       i;

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT)) {

        return((error_status_t)ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (ldwTotsize == NULL)        || 
        (ldwRequiredSize == NULL)   ||
        (num_vals && (val_list == NULL ))
        ) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }

    LocalTotSize = *ldwTotsize;
    //
    //  Subtract the NULLs from the Length. This was added on
    //  the client side so that RPC would transmit it.
    //
    for (i=0; i<num_vals; i++) {
        if( (val_list[i].rv_valuename == NULL) ||
            (val_list[i].rv_valuename->Length & 1) ) {
            return ERROR_INVALID_PARAMETER;
        }
        if (val_list[i].rv_valuename->Length > 0) {
            val_list[i].rv_valuename->Length -= sizeof( UNICODE_NULL );
        }
    }

#ifdef LOCAL

    //
    // For class keys in hkcr, we need to merge the data
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegQueryMultipleClassKeyValues(
            hKey,
            val_list,
            num_vals,
            lpvalueBuf,
            &LocalTotSize,
            ldwRequiredSize);

    } else {

#endif // LOCAL

    Status = NtQueryMultipleValueKey(hKey,
                                     (PKEY_VALUE_ENTRY)val_list,
                                     num_vals,
                                     lpvalueBuf,
                                     &LocalTotSize,
                                     ldwRequiredSize);

#ifdef LOCAL

    }

#endif // LOCAL

    
    return(error_status_t)RtlNtStatusToDosError(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regsec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegSec.c

Abstract:

    This module contains code to apply security to the otherwise unsecured
    top level keys, in fashion that will allow existing consumers access to
    the keys that they need (print, srvmgr, etc.).


Author:

    Richard Ward (richardw) 15 May 1996

Notes:

--*/


#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regsec.h"

#define REGSEC_READ     1
#define REGSEC_WRITE    2


WCHAR                   PerfRemoteRegistryKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
WCHAR                   RemoteRegistryKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg";
WCHAR                   AllowedPathsKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths";
WCHAR                   AllowedExactPathsKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedExactPaths";
WCHAR                   MachineValue[] = L"Machine";
PSECURITY_DESCRIPTOR    RemoteRegistrySD;
PUNICODE_STRING         MachineAllowedPaths;
PUCHAR                  MachineAllowedPathsBase;
ULONG                   MachineAllowedPathsCount;
PUNICODE_STRING         MachineAllowedExactPaths;
PUCHAR                  MachineAllowedExactPathsBase;
ULONG                   MachineAllowedExactPathsCount;
GENERIC_MAPPING         RemoteRegistryMappings;

LARGE_INTEGER           WinregChange;
LARGE_INTEGER           AllowedPathsChange;
LARGE_INTEGER           AllowedExactPathsChange;
RTL_RESOURCE            RegSecReloadLock;





NTSTATUS
RegSecReadSDFromRegistry(
    IN  HANDLE  hKey,
    OUT PSECURITY_DESCRIPTOR *  pSDToUse)
/*++

Routine Description:

    This function checks the registry in the magic place to see if an extra
    ACL has been defined for the pipe being passed in.  If there is one, it
    is translated to a NP acl, then returned.  If there isn't one, or if
    something goes wrong, an NULL acl is returned.

Arguments:

    InterfaceName   name of the pipe to check for, e.g. winreg, etc.

    pSDToUse        returned a pointer to the security decriptor to use.

Return Value:

    STATUS_SUCCESS,
    STATUS_NO_MEMORY,
    Possible other errors from registry apis.


--*/
{
    NTSTATUS                Status ;
    PSECURITY_DESCRIPTOR    pSD;
    ULONG                   cbNeeded;
    ACL_SIZE_INFORMATION    AclSize;
    ULONG                   AceIndex;
    ACCESS_MASK             NewMask;
    PACCESS_ALLOWED_ACE     pAce;
    PACL                    pAcl;
    BOOLEAN                 DaclPresent;
    BOOLEAN                 DaclDefaulted;
    UNICODE_STRING          Interface;
    UNICODE_STRING          Allowed;
    ULONG                   i;
    BOOLEAN                 PipeNameOk;
    PSECURITY_DESCRIPTOR    pNewSD;
    PACL                    pNewAcl;
    PSID                    pSid;
    PSID                    pSidCopy;
    BOOLEAN                 Defaulted;
    PACL                    Acl;
    PSID                    AdminSid = NULL ;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    ULONG                   SizeOfAcl ;

    *pSDToUse = NULL;


    //
    // Son of a gun, someone has established security for this pipe.
    //

    pSD = NULL;

    cbNeeded = 0;
    Status = NtQuerySecurityObject(
                    hKey,
                    DACL_SECURITY_INFORMATION |
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION,
                    NULL,
                    0,
                    &cbNeeded );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        pSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
        if (pSD)
        {
            Status = NtQuerySecurityObject(
                        hKey,
                        DACL_SECURITY_INFORMATION |
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION,
                        pSD,
                        cbNeeded,
                        &cbNeeded );


            if (NT_SUCCESS(Status))
            {
                //
                // Now, the tricky part.  There is no 1-1 mapping of Key
                // permissions to Pipe permissions.  So, we do it here.
                // We walk the DACL, and examine each ACE.  We build a new
                // access mask for each ACE, and set the flags as follows:
                //
                //  if (KEY_READ) GENERIC_READ
                //  if (KEY_WRITE) GENERIC_WRITE
                //

                Status = RtlGetDaclSecurityDescriptor(
                                        pSD,
                                        &DaclPresent,
                                        &pAcl,
                                        &DaclDefaulted);


                //
                // If this failed, or there is no DACL present, then
                // we're in trouble.
                //

                if (!NT_SUCCESS(Status) || !DaclPresent || !pAcl)
                {
                    goto GetSDFromKey_BadAcl;
                }


                Status = RtlQueryInformationAcl(pAcl,
                                                &AclSize,
                                                sizeof(AclSize),
                                                AclSizeInformation);

                if (!NT_SUCCESS(Status))
                {
                    goto GetSDFromKey_BadAcl;
                }

                for (AceIndex = 0; AceIndex < AclSize.AceCount ; AceIndex++ )
                {
                    NewMask = 0;
                    Status = RtlGetAce( pAcl,
                                        AceIndex,
                                        & pAce);

                    //
                    // We don't care what kind of ACE it is, since we
                    // are just mapping the access types, and the access
                    // mask is always at a constant position.
                    //

                    if (NT_SUCCESS(Status))
                    {
                        if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) &&
                            (pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE))
                        {
                            //
                            // Must be an audit or random ACE type.  Skip it.
                            //

                            continue;

                        }


                        if (pAce->Mask & KEY_READ)
                        {
                            NewMask |= REGSEC_READ;
                        }

                        if (pAce->Mask & KEY_WRITE)
                        {
                            NewMask |= REGSEC_WRITE;
                        }

                        pAce->Mask = NewMask;
                    }
                    else
                    {
                        //
                        // Panic:  Bad ACL?
                        //

                        goto GetSDFromKey_BadAcl;
                    }

                }

                //
                // RPC does not understand self-relative SDs, so
                // we have to turn this into an absolute for them to turn
                // back into a self relative.
                //

                pNewSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
                if (!pNewSD)
                {
                    goto GetSDFromKey_BadAcl;
                }

                InitializeSecurityDescriptor(   pNewSD,
                                                SECURITY_DESCRIPTOR_REVISION);

                pNewAcl = (PACL) (((PUCHAR) pNewSD) +
                                    sizeof(SECURITY_DESCRIPTOR) );

                RtlCopyMemory(pNewAcl, pAcl, AclSize.AclBytesInUse);

                SetSecurityDescriptorDacl(pNewSD, TRUE, pNewAcl, FALSE);

                Status = RtlGetOwnerSecurityDescriptor( pSD, &pSid, &Defaulted );

                if ( NT_SUCCESS( Status ) )
                {
                    pSidCopy = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                RtlLengthSid( pSid ) );

                    if ( pSidCopy )
                    {
                        RtlCopyMemory( pSidCopy, pSid, RtlLengthSid( pSid ) );
                    }

                    RtlSetOwnerSecurityDescriptor( pNewSD, pSidCopy, FALSE );
                }

                Status = RtlGetGroupSecurityDescriptor( pSD, &pSid, &Defaulted );

                if ( NT_SUCCESS( Status ) )
                {
                    pSidCopy = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                RtlLengthSid( pSid ) );

                    if ( pSidCopy )
                    {
                        RtlCopyMemory( pSidCopy, pSid, RtlLengthSid( pSid ) );
                    }

                    RtlSetGroupSecurityDescriptor( pNewSD, pSidCopy, FALSE );
                }

                RtlFreeHeap(RtlProcessHeap(), 0, pSD);

                *pSDToUse = pNewSD;
                return(Status);
            }
        }
        return(STATUS_NO_MEMORY);
    }
    else
    {


GetSDFromKey_BadAcl:

        //
        // Free the SD that we have allocated
        //

        if (pSD)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, pSD);
        }

        //
        // Key exists, but there is no security descriptor, or it is unreadable
        // for whatever reason.
        //

        pSD = RtlAllocateHeap(RtlProcessHeap(), 0,
                                sizeof(SECURITY_DESCRIPTOR) );
        if (pSD)
        {
            InitializeSecurityDescriptor( pSD,
                                          SECURITY_DESCRIPTOR_REVISION );

            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0,
                        &AdminSid );


            SizeOfAcl = sizeof( ACL ) + sizeof( ACL ) + sizeof( ACE_HEADER ) + 
                        RtlLengthRequiredSid( 2 );

            Acl = RtlAllocateHeap( RtlProcessHeap(), 0, SizeOfAcl );

            if ( NT_SUCCESS( Status ) &&
                 (Acl != NULL ))
            {
                (VOID) RtlCreateAcl(Acl, 
                                    SizeOfAcl,
                                    ACL_REVISION );

                Status = RtlAddAccessAllowedAce(
                            Acl,
                            ACL_REVISION,
                            REGSEC_READ | REGSEC_WRITE,
                            AdminSid );
                
                if ( NT_SUCCESS( Status ) )
                {
                    Status = RtlSetDaclSecurityDescriptor(
                                pSD,
                                TRUE,
                                Acl,
                                FALSE );
                    
                    if ( NT_SUCCESS( Status ) )
                    {
                        RtlFreeSid( AdminSid );

                        *pSDToUse = pSD;

                        return STATUS_SUCCESS ;
                    }

                }


            }

            if ( AdminSid )
            {
                RtlFreeSid( AdminSid );
            }

            if ( NT_SUCCESS( Status ) )
            {
                Status = STATUS_NO_MEMORY ;
            }
    

        }
        return(STATUS_NO_MEMORY);

    }

    return Status ;


}

NTSTATUS
RegSecCheckIfAclValid(
    VOID
    )
/*++

Routine Description:

    Checks if the local copy of the ACL from the registry is still valid (that is,
    no one has changed it.  If it is gone, the ACL is destroyed.

Arguments:

    None.

Returns:

    STATUS_SUCCESS if the state of the ACL is valid (whether it is present or not),
    other error    if an error occurred.

--*/

{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    PKEY_BASIC_INFORMATION  KeyInfo ;
    HANDLE                  Token ;
    HANDLE                  NullHandle ;
    UCHAR                   Buffer[ sizeof( KEY_BASIC_INFORMATION ) +
                                sizeof( RemoteRegistryKey ) + 16 ];
    NTSTATUS Status ;
    ULONG BufferSize ;


    RtlInitUnicodeString( &UniString, RemoteRegistryKey );

    InitializeObjectAttributes( &ObjAttr,
                                &UniString,
                                OBJ_CASE_INSENSITIVE,
                                NULL, NULL);

    //
    // Open the thread token.  If we're in the middle of an RPC call, we won't be
    // able to open the key (necessarily).  So, revert to local system in order to
    // open successfully.

    Status = NtOpenThreadToken( NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

    if ( ( Status == STATUS_NO_IMPERSONATION_TOKEN ) ||
         ( Status == STATUS_NO_TOKEN ) )
    {
        Token = NULL ;
    }
    else if ( Status == STATUS_SUCCESS )
    {
        NullHandle = NULL ;

        Status = NtSetInformationThread( NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                (ULONG) sizeof( NullHandle ) );


    }
    else
    {
        return Status ;
    }


    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjAttr);

    if ( Token )
    {
        NTSTATUS RestoreStatus;

        RestoreStatus = NtSetInformationThread( NtCurrentThread(),
                                                ThreadImpersonationToken,
                                                (PVOID) &Token,
                                                sizeof( NullHandle ) );

        NtClose( Token );

        if ( !NT_SUCCESS( RestoreStatus ) )
        {
            Status = RestoreStatus ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ||
             ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) )
        {
            //
            // The key is not present.  Either, the key has never been present,
            // in which case we're essentially done, or the key has been deleted.
            // If the key is deleted, we need to get rid of the remote acl.
            //

            if ( WinregChange.QuadPart )
            {
                //
                // Ok, the key has been deleted.  Get the exclusive lock and get to work.
                //

                RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

                //
                // Make sure no one else got through and deleted it already:
                //

                if ( WinregChange.QuadPart )
                {

                    RtlFreeHeap( RtlProcessHeap(), 0, RemoteRegistrySD );

                    RemoteRegistrySD = NULL ;

                    WinregChange.QuadPart = 0 ;

                }

                RtlReleaseResource( &RegSecReloadLock );

            }

            Status = STATUS_SUCCESS ;
        }

        return Status ;
    }

    Status = NtQueryKey( hKey,
                         KeyBasicInformation,
                         Buffer,
                         sizeof( Buffer ),
                         & BufferSize );

    if ( !NT_SUCCESS( Status ) )
    {

        NtClose( hKey );

        return Status ;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION) Buffer ;

    //
    // See if it has changed
    //

    if ( KeyInfo->LastWriteTime.QuadPart > WinregChange.QuadPart )
    {
        RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

        //
        // Since the last check was not safe, try again.  Another thread
        // may have updated things already.
        //

        if ( KeyInfo->LastWriteTime.QuadPart > WinregChange.QuadPart )
        {

            //
            // Ok, this one is out of date.  If there is already an SD
            // allocated, free it.  We can do that, since every other thread
            // either is waiting for a shared access, or has also noticed that
            // it is out of date, and waiting for exclusive access.
            //

            if ( RemoteRegistrySD )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, RemoteRegistrySD );

                RemoteRegistrySD = NULL ;
            }

            Status = RegSecReadSDFromRegistry( hKey, &RemoteRegistrySD );

            if ( NT_SUCCESS( Status ) )
            {
                WinregChange.QuadPart = KeyInfo->LastWriteTime.QuadPart ;
            }
        }

        RtlReleaseResource( &RegSecReloadLock );
    }

    NtClose( hKey );

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSecReadAllowedPath
//
//  Synopsis:   Pull the Allowed paths out of the registry, and set up a
//              table for searching later.  This is a flat list, since the
//              number of elements by default is 2, and shouldn't grow much
//              bigger.
//
//  Arguments:  [hKey]      --
//              [Value]     --
//              [List]      --
//              [ListBase]  --
//              [ListCount] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecReadAllowedPath(
    HANDLE              hKey,
    PWSTR               Value,
    PUNICODE_STRING *   List,
    PUCHAR *            ListBase,
    PULONG              ListCount)
{
    NTSTATUS                Status;
    UNICODE_STRING          UniString;
    PKEY_VALUE_PARTIAL_INFORMATION  pValue;
    ULONG                   Size;
    PWSTR                   Scan;
    ULONG                   StringCount;
    PUNICODE_STRING         Paths;

    //
    // Read the value size:
    //

    RtlInitUnicodeString( &UniString, Value );

    Status = NtQueryValueKey(   hKey,
                                &UniString,
                                KeyValuePartialInformation,
                                NULL,
                                0,
                                &Size );

    if ( !NT_SUCCESS( Status ) && (Status != STATUS_BUFFER_TOO_SMALL))
    {
        if ( (Status == STATUS_OBJECT_PATH_NOT_FOUND) ||
             (Status == STATUS_OBJECT_NAME_NOT_FOUND) )
        {
            return( TRUE );
        }

        return FALSE ;
    }

    //
    // Allocate enough:
    //

    pValue = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

    if ( pValue )
    {
        Status = NtQueryValueKey(   hKey,
                                    &UniString,
                                    KeyValuePartialInformation,
                                    pValue,
                                    Size,
                                    &Size );
        if( !NT_SUCCESS( Status ) ) {
            RtlFreeHeap( RtlProcessHeap(), 0, pValue );
            return FALSE;
        }
    }


    if ( !pValue )
    {
        return( FALSE );
    }


    //
    // Okay, we should have a multi-valued set of paths that we can
    // allow access to despite the access control.
    //

    if ( pValue->Type != REG_MULTI_SZ )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pValue );
        return( FALSE );
    }

    //
    // Scan list, determine how many strings:
    //

    Scan = (PWSTR) pValue->Data;

    StringCount = 0;

    while ( *Scan )
    {
        while ( *Scan )
        {
            Scan ++;
        }

        StringCount ++;

        Scan ++;
    }

    //
    // Allocate enough UNICODE_STRING structs to point to each string
    //

    Paths = RtlAllocateHeap( RtlProcessHeap(), 0,
                                        StringCount * sizeof(UNICODE_STRING) );

    if ( !Paths )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pValue );
        return( FALSE );
    }

    Scan = ( PWSTR ) pValue->Data;

    *ListCount = StringCount;

    StringCount = 0;

    //
    // Set up one UNICODE_STRING per string in the multi_sz,
    //

    while ( *Scan )
    {
        RtlInitUnicodeString( &Paths[ StringCount ],
                              Scan );

        while ( *Scan)
        {
            Scan ++;
        }

        StringCount ++;

        Scan ++;
    }

    //
    // And pass the list back.
    //

    *ListBase = (PUCHAR) pValue;
    *List = Paths;

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   RegSecReadAllowedPaths
//
//  Synopsis:   Reads the allowed paths out of the registry
//
//  Arguments:  (none)
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
RegSecCheckAllowedPaths(
    VOID
    )
{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    NTSTATUS                Status;
    HANDLE                  Token ;
    HANDLE                  NullHandle ;
    PKEY_BASIC_INFORMATION  KeyInfo ;
    UCHAR                   Buffer[ sizeof( KEY_BASIC_INFORMATION ) +
                                sizeof( AllowedExactPathsKey ) + 16 ];
    ULONG                   BufferSize;
    BOOLEAN                 ReadExactPath = FALSE;
    PLARGE_INTEGER          TimeStamp;
    PUNICODE_STRING *       List;
    PUCHAR *                ListBase;
    PULONG                  ListCount;

ReadExact:
    if( ReadExactPath ) {
        RtlInitUnicodeString(&UniString, AllowedExactPathsKey);
        TimeStamp = &AllowedExactPathsChange;
        List = &MachineAllowedExactPaths;
        ListBase = &MachineAllowedExactPathsBase;
        ListCount = &MachineAllowedExactPathsCount;
    } else {
        RtlInitUnicodeString(&UniString, AllowedPathsKey);
        TimeStamp = &AllowedPathsChange;
        List = &MachineAllowedPaths;
        ListBase = &MachineAllowedPathsBase;
        ListCount = &MachineAllowedPathsCount;
    }

    InitializeObjectAttributes( &ObjAttr,
                                &UniString,
                                OBJ_CASE_INSENSITIVE,
                                NULL, NULL);


    //
    // Open the thread token.  If we're in the middle of an RPC call, we won't be
    // able to open the key (necessarily).  So, revert to local system in order to
    // open successfully.

    Status = NtOpenThreadToken( NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

    if ( ( Status == STATUS_NO_IMPERSONATION_TOKEN ) ||
         ( Status == STATUS_NO_TOKEN ) )
    {
        Token = NULL ;
    }
    else if ( Status == STATUS_SUCCESS )
    {
        NullHandle = NULL ;

        Status = NtSetInformationThread( NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                (ULONG) sizeof( NullHandle ) );


    }
    else
    {
        return Status ;
    }

    //
    // Open the key in local system context
    //

    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjAttr);

    //
    // Immediately restore back to the client token.
    //

    if ( Token )
    {
        NTSTATUS RestoreStatus;

        RestoreStatus = NtSetInformationThread( NtCurrentThread(),
                                                ThreadImpersonationToken,
                                                (PVOID) &Token,
                                                sizeof( NullHandle ) );

        NtClose( Token );

        if ( !NT_SUCCESS( RestoreStatus ) )
        {
            Status = RestoreStatus ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ||
             ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) )
        {
            //
            // The key is not present.  Either, the key has never been present,
            // in which case we're essentially done, or the key has been deleted.
            // If the key is deleted, we need to get rid of the remote acl.
            //

            if ( TimeStamp->QuadPart )
            {
                //
                // Ok, the key has been deleted.  Get the exclusive lock and get to work.
                //

                RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

                //
                // Make sure no one else has freed it already:
                //

                if ( TimeStamp->QuadPart )
                {
                    if ( *List )
                    {

                        RtlFreeHeap( RtlProcessHeap(), 0, *List );

                        RtlFreeHeap( RtlProcessHeap(), 0, *ListBase );

                        *List = NULL;

                        *ListBase = NULL;

                    }

                    TimeStamp->QuadPart = 0;

                }

                RtlReleaseResource( &RegSecReloadLock );

            }

            Status = STATUS_SUCCESS ;
            if( !ReadExactPath ) {
                ReadExactPath = TRUE;
                goto ReadExact;
            }
        }

        return Status ;
    }

    Status = NtQueryKey( hKey,
                         KeyBasicInformation,
                         Buffer,
                         sizeof( Buffer ),
                         & BufferSize );

    if ( !NT_SUCCESS( Status ) )
    {

        NtClose( hKey );

        return Status ;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION) Buffer ;

    //
    // See if it has changed
    //

    if ( KeyInfo->LastWriteTime.QuadPart > TimeStamp->QuadPart )
    {
        //
        // Well, it changed.  So, we need to flush out the old (familiar?) stuff,
        // and reload with the new stuff.  So, back to the synchronization games.
        //

        RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

        //
        // Make sure no one else beat us to it
        //

        if ( KeyInfo->LastWriteTime.QuadPart > TimeStamp->QuadPart )
        {
            if ( *List )
            {

                RtlFreeHeap( RtlProcessHeap(), 0, *List );

                RtlFreeHeap( RtlProcessHeap(), 0, *ListBase );

                *List = NULL ;

                *ListBase = NULL ;

            }

            //
            // Read in the paths allowed:
            //

            RegSecReadAllowedPath(  hKey,
                                    MachineValue,
                                    List,
                                    ListBase,
                                    ListCount
                                    );

        }

        RtlReleaseResource( &RegSecReloadLock );
    }


    NtClose( hKey );

    if( !ReadExactPath ) {
        ReadExactPath = TRUE;
        goto ReadExact;
    }

    return STATUS_SUCCESS;

}


//+---------------------------------------------------------------------------
//
//  Function:   InitializeRemoteSecurity
//
//  Synopsis:   Hook to initialize our look-aside stuff
//
//  Arguments:  (none)
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeRemoteSecurity(
    VOID
    )
{
    NTSTATUS Status ;

    try 
    {
        RtlInitializeResource( &RegSecReloadLock );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    RemoteRegistryMappings.GenericRead = REGSEC_READ;
    RemoteRegistryMappings.GenericWrite = REGSEC_WRITE;
    RemoteRegistryMappings.GenericExecute = REGSEC_READ;
    RemoteRegistryMappings.GenericAll = REGSEC_READ | REGSEC_WRITE;

    WinregChange.QuadPart = 0 ;
    AllowedPathsChange.QuadPart = 0 ;
    AllowedExactPathsChange.QuadPart = 0 ;

    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSecCheckRemoteAccess
//
//  Synopsis:   Check remote access against the security descriptor we built
//              on the side.
//
//  Arguments:  [phKey] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecCheckRemoteAccess(
    PRPC_HKEY   phKey)
{
    NTSTATUS    Status;
    ACCESS_MASK Mask;
    NTSTATUS    AccessStatus;
    HANDLE      Token;
    ULONG       Size;
    UCHAR       QuickBuffer[sizeof(PRIVILEGE_SET) + 4 * sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET  PrivSet;
    ULONG       PrivilegeSetLen;

    Status = RegSecCheckIfAclValid();

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    RtlAcquireResourceShared( &RegSecReloadLock, TRUE );

    if ( RemoteRegistrySD )
    {

        //
        // Capture the thread's token
        //

        Status = NtOpenThreadToken(
                                NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

        if ( !NT_SUCCESS(Status) )
        {
            RtlReleaseResource( &RegSecReloadLock );

            return( FALSE );
        }

        PrivSet = (PPRIVILEGE_SET) QuickBuffer;

        PrivilegeSetLen = sizeof( QuickBuffer );

        //
        // Do the access check.
        //

        Status = NtAccessCheck( RemoteRegistrySD,
                                Token,
                                MAXIMUM_ALLOWED,
                                &RemoteRegistryMappings,
                                PrivSet,
                                &PrivilegeSetLen,
                                &Mask,
                                &AccessStatus );

        RtlReleaseResource( &RegSecReloadLock );

        (void) NtClose( Token );

        if ( NT_SUCCESS( Status ) )
        {
            if ( NT_SUCCESS( AccessStatus ) &&
                (Mask & (REGSEC_READ | REGSEC_WRITE)) )
            {
                return( TRUE );
            }

            return( FALSE );

        }
        else 
        {
            return FALSE ;
        }

    }

    RtlReleaseResource( &RegSecReloadLock );

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   RegSecCheckRemotePerfAccess
//
//  Synopsis:   Check remote access against the security descriptor set on the
//              performance access gate key 
//              (SOFTWARE\MICROSOFT\WINDOWS NT\CURRENTVERSION\PERFLIB)
//
//  Arguments:  [phKey] --
//
//  History:    4-29-02   DragosS   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
RegSecGetPerfGateSD(
    VOID
    )
/*++

Routine Description:

    Retrieves the SD set on the performance gate key. It'll be used for the 
    access check against the current thread token

Arguments:

    None.

Returns:

    STATUS_SUCCESS if the state of the ACL is valid (whether it is present or not),
    other error    if an error occurred.

--*/

{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    HANDLE                  Token ;
    HANDLE                  NullHandle ;
    NTSTATUS                Status ;
    PSECURITY_DESCRIPTOR    PerflibSecurity = NULL;

    RtlInitUnicodeString( &UniString, PerfRemoteRegistryKey );

    InitializeObjectAttributes( &ObjAttr,
                                &UniString,
                                OBJ_CASE_INSENSITIVE,
                                NULL, NULL);

    //
    // Open the thread token.  If we're in the middle of an RPC call, we won't be
    // able to open the key (necessarily).  So, revert to local system in order to
    // open successfully.

    Status = NtOpenThreadToken( NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

    if ( ( Status == STATUS_NO_IMPERSONATION_TOKEN ) ||
         ( Status == STATUS_NO_TOKEN ) )
    {
        Token = NULL ;
    }
    else if ( Status == STATUS_SUCCESS )
    {
        NullHandle = NULL ;

        Status = NtSetInformationThread( NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                (ULONG) sizeof( NullHandle ) );


    }
    else
    {
        return NULL;
    }


    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjAttr);

    if ( Token )
    {
        NTSTATUS RestoreStatus;

        RestoreStatus = NtSetInformationThread( NtCurrentThread(),
                                                ThreadImpersonationToken,
                                                (PVOID) &Token,
                                                sizeof( NullHandle ) );

        NtClose( Token );

        if ( !NT_SUCCESS( RestoreStatus ) )
        {
            return NULL;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL;
    }

    //
    // Read (+allocate) the SD from the key
    //

    Status = RegSecReadSDFromRegistry( hKey, &PerflibSecurity );

    NtClose( hKey );
    
    if( !NT_SUCCESS(Status) ) {
        if( PerflibSecurity ) {
            RtlFreeHeap(RtlProcessHeap(), 0, PerflibSecurity);
            PerflibSecurity = NULL;
        }
    }

    return PerflibSecurity;
}

BOOL
RegSecCheckRemotePerfAccess(
    PRPC_HKEY   phKey)
{
    NTSTATUS    Status;
    ACCESS_MASK Mask;
    NTSTATUS    AccessStatus;
    HANDLE      Token;
    ULONG       Size;
    UCHAR       QuickBuffer[sizeof(PRIVILEGE_SET) + 4 * sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET  PrivSet;
    ULONG       PrivilegeSetLen;
    PSECURITY_DESCRIPTOR    PerflibSecurity = NULL;
    
    PerflibSecurity = RegSecGetPerfGateSD();

    if ( PerflibSecurity == NULL )
    {
        return FALSE ;
    }


    //
    // Capture the thread's token
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            MAXIMUM_ALLOWED,
                            TRUE,
                            &Token );

    if ( !NT_SUCCESS(Status) )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, PerflibSecurity);
        return( FALSE );
    }

    PrivSet = (PPRIVILEGE_SET) QuickBuffer;

    PrivilegeSetLen = sizeof( QuickBuffer );

    //
    // Do the access check.
    //

    Status = NtAccessCheck( PerflibSecurity,
                            Token,
                            MAXIMUM_ALLOWED,
                            &RemoteRegistryMappings,
                            PrivSet,
                            &PrivilegeSetLen,
                            &Mask,
                            &AccessStatus );

    RtlFreeHeap(RtlProcessHeap(), 0, PerflibSecurity);

    (void) NtClose( Token );

    if ( NT_SUCCESS( Status ) )
    {
        if ( NT_SUCCESS( AccessStatus ) &&
            (Mask & (REGSEC_READ | REGSEC_WRITE)) )
        {
            return( TRUE );
        }

    }

    return FALSE;

}

//+---------------------------------------------------------------------------
//
//  Function:   RegSecCheckPath
//
//  Synopsis:   Check a specific key path if we should ignore the current
//              ACL.
//
//  Arguments:  [hKey]    --
//              [pSubKey] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecCheckPath(
    HKEY                hKey,
    PUNICODE_STRING     pSubKey)

{
    UNICODE_STRING  Comparator;
    UNICODE_STRING  String;
    ULONG           i;
    ULONG           Count = 0;
    PUNICODE_STRING List;
    BOOL            Success ;
    NTSTATUS        Status ;
    BOOLEAN         ExactPath = FALSE;

    Status = RegSecCheckAllowedPaths();

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( (pSubKey->Buffer == NULL) ||
         (pSubKey->Length == 0 ) ||
         (pSubKey->MaximumLength == 0 ) )
    {
        return FALSE ;
    }

    if( !REGSEC_TEST_HANDLE( hKey, CHECK_MACHINE_PATHS ) )
    {
        return FALSE;
    }

    RtlAcquireResourceShared( &RegSecReloadLock, TRUE );

TryExactPath:

    if( !ExactPath) {
        Count = MachineAllowedPathsCount;
        List = MachineAllowedPaths;
    } else {
        Count = MachineAllowedExactPathsCount;
        List = MachineAllowedExactPaths;
    }

    Success = FALSE;

    for ( i = 0 ; i < Count ; i++ )
    {
        String = *pSubKey;

        //
        // Ah ha, RPC strings often have the NULL included in the length.
        // touch that up.
        //

        while ( (String.Length != 0) && (String.Buffer[ (String.Length / sizeof(WCHAR)) - 1] == L'\0') )
        {
            String.Length -= sizeof(WCHAR) ;
        }


        Comparator = List[ i ];

        //
        // If the Comparator is a prefix of the sub key, allow it (for spooler)
        //

        if ( String.Length > Comparator.Length )
        {
            if( ExactPath ) {
                continue;
            }
            if ( String.Buffer[ Comparator.Length / sizeof(WCHAR) ] == L'\\' )
            {
                //
                // Length-wise, it could be an ancestor
                //

                String.Length = Comparator.Length;

            }
        }

        //
        // If it matches, let it go...
        //

        if ( RtlCompareUnicodeString( &String, &Comparator, TRUE ) == 0 )
        {
            Success = TRUE ;

            break;
        }
    }

    if( (!Success) && (!ExactPath) ) {
        ExactPath = TRUE;
        goto TryExactPath;
    }

    RtlReleaseResource( &RegSecReloadLock ) ;

    return( Success );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regsec.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       regsec.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-16-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __REGSEC_H__
#define __REGSEC_H__


BOOL
RegSecCheckRemoteAccess(
    PRPC_HKEY   phKey);

BOOL
RegSecCheckRemotePerfAccess(
    PRPC_HKEY   phKey);

BOOL
RegSecCheckPath(
    HKEY                hKey,
    PUNICODE_STRING     pSubKey);

BOOL
InitializeRemoteSecurity(
    VOID
    );

#endif // __REGSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regsckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsckey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry APIs to set and get the SECURITY_DESCRIPTOR for a key.  That
    is:

        - BaseRegGetKeySecurity
        - BaseRegSetKeySecurity

Author:

    David J. Gilman (davegi) 10-Feb-1992

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#endif


error_status_t
BaseRegGetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    This API returns a copy of the security descriptor protecting a
    previously opened key.  Based on the caller's access rights and
    privileges, this API returns a security descriptor containing the
    requested security descriptor fields.  To read the supplied key's
    security descriptor the caller must be granted READ_CONTROL access or
    be the owner of the object.  In addition, the caller must have
    SeSecurityPrivilege privilege to read the system ACL.


Arguments:

    hKey - Supplies a handle to a previously opened key.

    SecurityInformation - Supplies the information needed to determine
        the type of security returned in the SECURITY_DESCRIPTOR.

    pSecurityDescriptor - Supplies a pointer to a buffer where the
        requested SECURITY_DESCRIPTOR will be written.

    lpcbSecurityDescriptor - Supplies a pointer to a DWORD which on input
        contains the size, in bytes, of the supplied SECURITY_DESCRIPTOR
        buffer. On output it contains the actual number of bytes required
        by the SECURITY_DESCRIPTOR.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    If the buffer size passed in is too small, the correct value will be
    returned through lpcbSecurityDescriptor and the API will return,
    ERROR_INVALID_PARAMETER.

--*/

{
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    lpSD;
    DWORD                   cbLen;
    DWORD                   Error = ERROR_SUCCESS;
    HKEY                    hPerflibKey = NULL;
    OBJECT_ATTRIBUTES       Obja;

    if( pRpcSecurityDescriptor == NULL ) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
        //
        // For these special cases, get the hKey for Perflib
        // and return the Perflib's Security Info
        //
        UNICODE_STRING  PerflibSubKeyString;
        BOOL            bNeedSACL;

        bNeedSACL = RequestedInformation & SACL_SECURITY_INFORMATION;

        RtlInitUnicodeString (
            &PerflibSubKeyString,
            L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");


        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the key.
        //
        InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        Status = NtOpenKey(
                &hPerflibKey,
                bNeedSACL ?
                    MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY :
                    MAXIMUM_ALLOWED,
                &Obja
                );

        if ( ! NT_SUCCESS( Status )) {

            Error = RtlNtStatusToDosError( Status );
            pRpcSecurityDescriptor->cbInSecurityDescriptor  = 0;
            pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
            return (error_status_t)Error;
        }

        hKey = hPerflibKey;

    } else {
        ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );
    }

    //
    //  Allocate space for the security descriptor
    //
    lpSD = (PSECURITY_DESCRIPTOR)
                RtlAllocateHeap(
                        RtlProcessHeap(), 0,
                        pRpcSecurityDescriptor->cbInSecurityDescriptor
                        );

    if ( !lpSD ) {

        Error = ERROR_OUTOFMEMORY;

    } else {

        Status = NtQuerySecurityObject(
                     hKey,
                     RequestedInformation,
                     lpSD,
                     pRpcSecurityDescriptor->cbInSecurityDescriptor,
                     &cbLen
                     );

        //
        // If the call fails, set the size of the buffer to zero so RPC
        // won't copy any data.
        //
        if( ! NT_SUCCESS( Status )) {

            Error = RtlNtStatusToDosError( Status );

        } else {

            //
            //  Convert the security descriptor to a Self-relative form
            //
            Error = MapSDToRpcSD (
                        lpSD,
                        pRpcSecurityDescriptor
                        );
        }

        if ( Error != ERROR_SUCCESS ) {
            pRpcSecurityDescriptor->cbInSecurityDescriptor  = cbLen;
            pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
        }

        //
        //  Free the buffer that we allocated for the security descriptor
        //
        RtlFreeHeap(
                RtlProcessHeap(), 0,
                lpSD
                );
    }

    if (hPerflibKey) {
        // Close the Perflib that was created in the special cases
        NtClose(hPerflibKey);
    }

    return (error_status_t)Error;
}

error_status_t
BaseRegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    This API can be used to set the security of a previously opened key.
    This call is only successful if the following conditions are met:

    o If the key's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the key's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the key's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    hKey - Supplies a handle to a previously opened key.

    SecurityInformation - Supplies a pointer to a SECURITY_INFORMATION
        structure that specifies the contents of the supplied
        SECURITY_DESCRIPTOR.

    pSecurityDescriptor - Supplies a pointer to the SECURITY_DESCRIPTOR
        to set on the supplied key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS    Status;

    if( pRpcSecurityDescriptor == NULL ||
        pRpcSecurityDescriptor->lpSecurityDescriptor == NULL
        ) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
        //
        // these keys get their security descriptor from
        // other "real" registry keys.
        //
        Status = STATUS_INVALID_HANDLE;
    } else {
        ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

        RPC_IMPERSONATE_CLIENT( NULL );

        //
        // Validate the security descriptor.
        //
        if( RtlValidRelativeSecurityDescriptor((PSECURITY_DESCRIPTOR)(pRpcSecurityDescriptor->lpSecurityDescriptor),
                                                pRpcSecurityDescriptor->cbInSecurityDescriptor,
                                                SecurityInformation )) {
            Status = NtSetSecurityObject(
                        hKey,
                        SecurityInformation,
                        pRpcSecurityDescriptor->lpSecurityDescriptor
                        );
        } else {
            //
            //  We were passed a bogus security descriptor to set.  Bail out
            //

            Status = STATUS_INVALID_PARAMETER;
        }

        RPC_REVERT_TO_SELF();
    }

#ifdef LOCAL
    if (NT_SUCCESS(Status) && gpfnTermsrvSetKeySecurity) {
        gpfnTermsrvSetKeySecurity(hKey,
                                  SecurityInformation,
                                  pRpcSecurityDescriptor->lpSecurityDescriptor);
    }
#endif

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regsrkey.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsrkey.c

Abstract:

    This module contains the save\restore key APIs, that is:

        - RegRestoreKeyW
        - RegSaveKeyW

Author:

    David J. Gilman (davegi) 23-Jan-1992

Notes:



Revision History:

    25-Mar-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.

--*/


#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegRestoreKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpFile,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    Restore the tree in the supplied file onto the key referenced by the
    supplied key handle. The restored tree will overwrite all of the
    contents of the supplied hKey except for its name. Pictorially, if
    the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies a handle to the key where the file is to be restored.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey.

    dwFlags - Supplies an optional flag argument which can be:

                - REG_WHOLE_HIVE_VOLATILE

                    If specified this flag causes a new, volatile
                    (i.e. memory only) hive to be created. In this case
                    the hKey can only refer to a child of HKEY_USERS or
                    HKEY_LOCAL_MACHINE.

                    If not specified, hKey can refer to any key in the
                    Registry.


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    BOOLEAN             ErrorFlag;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;


    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) || (lpFile->Length & 1)) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }


    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );


    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Remember the buffer allocated by RtlDosPathNameToRelativeNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }


    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
            &Obja,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );


    //
    // Open the existing file.
    //
    NtStatus = NtOpenFile(
                    &Handle,
                    GENERIC_READ | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToRelativeNtPathName_U.
    //
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtOpenFile.
    //
    if( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL
        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            HKEY           hkRestoreKey;
            UNICODE_STRING EmptyString = {0, 0, NULL};

            //
            // We need to restore to to user if it exists, 
            // machine if not
            //
            NtStatus = BaseRegOpenClassKey(
                hKey,
                &EmptyString,
                0,
                MAXIMUM_ALLOWED,
                &hkRestoreKey);
            
            if (NT_SUCCESS(NtStatus)) {

                //
                // Now restore to the highest precedence key
                //
                NtStatus = NtRestoreKey( hkRestoreKey, Handle, dwFlags );

                NtClose(hkRestoreKey);
            }
        } else {
            //
            // If this isn't in hkcr, then just restore to the supplied object
            //
            NtStatus = NtRestoreKey( hKey, Handle, dwFlags );
        }

#else // LOCAL
        //
        //  Now call the NT API
        //
        NtStatus = NtRestoreKey( hKey, Handle, dwFlags );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose(Handle);
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

#ifdef LOCAL
    if (NT_SUCCESS(NtStatus) && !(dwFlags & REG_WHOLE_HIVE_VOLATILE) && gpfnTermsrvRestoreKey) {
        gpfnTermsrvRestoreKey(hKey, Handle, dwFlags); 
    }
#endif

    //
    // Map the result of NtRestoreKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}



error_status_t
BaseRegSaveKey(
    IN  HKEY                     hKey,
    IN  PUNICODE_STRING          lpFile,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL
    )
/*++

Routine Description:

    Saves the given key to the specified file.

Arguments:

    hKey                    -   Supplies a handle to the open key.

    lpFile                  -   Supplies the name of the file to save the key to.

    pRpcSecurityAttributes  -   Supplies the security attributes of
                                the file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.



--*/
{

    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;

    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) || (lpFile->Length & 1) ) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }

    if ( ARGUMENT_PRESENT( pRpcSecurityAttributes ) ) {
        if( (pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor == NULL) ||
            (!RtlValidRelativeSecurityDescriptor(   pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor,
                                                    pRpcSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
                                                    0)) ) {
            RPC_REVERT_TO_SELF();
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if( ! ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }
    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                RelativeName.ContainingDirectory,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                        ? pRpcSecurityAttributes
                                ->RpcSecurityDescriptor.lpSecurityDescriptor
                        : NULL
                );



    //
    // Create the file - fail if the file exists.
    //
    NtStatus = NtCreateFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToRelativeNtPathName_U.
    //
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtCreateFile.
    //
    if ( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL

        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            HKEY hkMachineClass;
            HKEY hkUserClass;

            NtStatus = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                MAXIMUM_ALLOWED,
                &hkMachineClass,
                &hkUserClass);

            if (NT_SUCCESS(NtStatus)) {

                //
                // We only need to merge keys if we have
                // more than one key
                //
                if (hkMachineClass && hkUserClass) {
                
                    NtStatus = NtSaveMergedKeys(
                        hkUserClass,
                        hkMachineClass,
                        Handle);

                    //
                    // Clean up the extra handle we opened
                    //
                    if (hkUserClass != hKey) {
                        NtClose(hkUserClass);
                    } else {
                        NtClose(hkMachineClass);
                    }

                } else {
                    //
                    // If there's only one key, use the regular
                    // api
                    //
                    NtStatus = NtSaveKey( hKey, Handle );
                }
            }
        } else {
            //
            // If this isn't in hkcr, just save the regular way
            //
            NtStatus = NtSaveKey( hKey, Handle );
        }
#else // LOCAL
        NtStatus = NtSaveKey( hKey, Handle );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

    //
    // Map the result of NtSaveKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}

error_status_t
BaseRegSaveKeyEx(
    IN  HKEY                     hKey,
    IN  PUNICODE_STRING          lpFile,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    IN  DWORD                    Flags
    )
/*++

Routine Description:

    Saves the given key to the specified file.

Arguments:

    hKey                    -   Supplies a handle to the open key.

    lpFile                  -   Supplies the name of the file to save the key to.

    pRpcSecurityAttributes  -   Supplies the security attributes of
                                the file.

    Flags                   -   Specifies the format the target registry hive will
                                be saved on.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.



--*/
{

    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;

    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) || (lpFile->Length & 1) ) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }

    if ( ARGUMENT_PRESENT( pRpcSecurityAttributes ) ) {
        if( (pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor == NULL) ||
            (!RtlValidRelativeSecurityDescriptor(   pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor,
                                                    pRpcSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
                                                    0)) ) {
            RPC_REVERT_TO_SELF();
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if( ! ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToRelativeNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                RelativeName.ContainingDirectory,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                        ? pRpcSecurityAttributes
                                ->RpcSecurityDescriptor.lpSecurityDescriptor
                        : NULL
                );



    //
    // Create the file - fail if the file exists.
    //
    NtStatus = NtCreateFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToRelativeNtPathName_U.
    //
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtCreateFile.
    //
    if ( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL

        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
            //
            // not supported on merged hives just yet
            //
            NtStatus = STATUS_INVALID_PARAMETER;
        } else {
            //
            // If this isn't in hkcr, just save the regular way
            //
            NtStatus = NtSaveKeyEx( hKey, Handle, Flags );
        }
#else // LOCAL
        NtStatus = NtSaveKeyEx( hKey, Handle, Flags );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

    //
    // Map the result of NtSaveKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regsval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regsval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry set value API.  That is:

        - BaseRegSetValue
Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegSetValue(
    HKEY hKey,
    PUNICODE_STRING lpValueName,
    DWORD dwType,
    LPBYTE lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Set the type and value of an open key.  Changes are not committed
    until the key is flushed.  By "committed" we mean written to disk.
    Changes will be seen by subsequent queries as soon as this call
    returns.

Arguments:

    hKey - Supplies a handle to the open key.  Any of the predefined
        reserved handles or a previously opened key handle may be used for
        hKey.

    lpValueName - Supplies the name of the value to set.  If the ValueName
        is not present, it is added to the key.

    dwType - Supplies the type of information to be stored: REG_SZ, etc.

    lpData - supplies a pointer to a buffer containing the data to set for
        the value entry.

    cbData - Supplies the length (in bytes) of the information to be stored.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    A set may fail due to memory limits - any config entry must fit in
    main memory.  If successful, RegSetValue will set the type, contents,
    and length of the information stored at the specified key.
    KEY_SET_VALUE access is required.

--*/

{
    NTSTATUS   Status;    
    HKEY  hkSet;

#ifdef LOCAL
    PVOID     PreSetData  = NULL;

    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;

#endif


    if( (lpValueName == NULL)   ||
        (lpValueName->Length & 1)) {
        //
        // malicious client/RPC attack
        //
        return ERROR_INVALID_PARAMETER;
    }
    hkSet = hKey;

    //
    //  Subtract the NULL from the Length. This was added on the
    //  client side so that RPC would transmit it.
    //

    if ( lpValueName->Length > 0 ) {
        lpValueName->Length -= sizeof( UNICODE_NULL );
    }
    if ((hKey == HKEY_PERFORMANCE_DATA) ||
        (hKey==HKEY_PERFORMANCE_TEXT) ||
        (hKey==HKEY_PERFORMANCE_NLSTEXT)) {
#ifdef LOCAL
        return(PerfRegSetValue(hKey,
                               lpValueName->Buffer,
                               0,
                               dwType,
                               lpData,
                               cbData));
#else
        return ERROR_ACCESS_DENIED;
#endif
    }

#ifdef LOCAL

    if (gpfnTermsrvSetValueKey && gpfnTermsrvGetPreSetValue ) {

        //
        // Find any pre-set values
        //
        
        Status = gpfnTermsrvGetPreSetValue( hKey,
                                            lpValueName,
                                            dwType,
                                            &PreSetData
                                            );
        
        //
        // Use the pre-set values if they exists
        //
        
        if ( NT_SUCCESS(Status) ) {
            lpData = (( PKEY_VALUE_PARTIAL_INFORMATION ) PreSetData )->Data;
            cbData = (( PKEY_VALUE_PARTIAL_INFORMATION ) PreSetData )->DataLength;
        }
        else {
            PreSetData = NULL;
        }
        
        //
        // Save the Master Copy
        //
        gpfnTermsrvSetValueKey(hKey,
                             lpValueName,
                             0,
                             dwType,
                             lpData,
                             cbData);
            
    }

    if ( PreSetData ) {

        //
        //  Set the value and free any data
        //

        Status = NtSetValueKey(
                       hKey,
                       lpValueName,
                       0,
                       dwType,
                       lpData,
                       cbData
                 );

        RtlFreeHeap( RtlProcessHeap( ), 0, PreSetData );

        return (error_status_t)RtlNtStatusToDosError( Status );
    }
    else
        //
        // No pre-set values, just do original code
        //

#endif

    //
    // Call the Nt API to set the value, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hkSet,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkSet = hkUserClasses;
    }
#endif

    Status = NtSetValueKey(
        hkSet,
        lpValueName,
        0,
        dwType,
        lpData,
        cbData
        );

#ifdef LOCAL

    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }

    //if it is a HKLM\Software\Classes subkey and we get ACCDENIED try to create the
    //key in HKCU\Software\Classes and set value there
    if( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION )  
        && STATUS_ACCESS_DENIED == Status 
        && hkSet == hkMachineClasses 
        && REG_CLASS_IS_SPECIAL_KEY(hKey) ) {
        
        Status = CreateMultipartUserClassKey( hKey, &hkSet );

        if(!NT_SUCCESS(Status)) {
            return ERROR_ACCESS_DENIED;
        }

        Status = NtSetValueKey(
                        hkSet,
                        lpValueName,
                        0,
                        dwType,
                        lpData,
                        cbData
                        );
        
        NtClose(hkSet);

        if(!NT_SUCCESS(Status)) {
            return ERROR_ACCESS_DENIED;
        }
        
    }

#endif // LOCAL

    return (error_status_t) RtlNtStatusToDosError(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regstate.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegState.c

Abstract:

    This module contains helper functions for maintaining
    user mode state for registry objects

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

StateObjectInit

StateObjectListInit
StateObjectListIsEmpty
StateObjectListRemove
StateObjectListFind
StateObjectListAdd
StateObjectListClear

Notes:

    The StateObjectList stores the most frequently accessed
    objects at the head of the list for quick retrieval.  All
    objects in the list must inherit from StateObject, and must
    be distinguishable by a unique 32-bit key.  Duplicate
    objects are not supported, so the client must take care
    not to store duplicates (two objects with the same key) in
    the list.

--*/



#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regstate.h"


VOID StateObjectInit(
    StateObject* pObject,
    PVOID        pvKey)
/*++
Routine Description:

    This function will initialize a StateObject.  All objects
    which inherit from this must call this function before doing
    any custom initialization.

Arguments:

    pObject -- the object to initialize.

    pvKey -- a unique key for the object used for searches and comparisons
        between objects.

Return Value:

    None -- the function does nothing which could fail.

--*/
{
    RtlZeroMemory(pObject, sizeof(*pObject));

    pObject->pvKey = pvKey;
}


VOID StateObjectListInit(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will initialize a StateObjectList.  All objects
    which inherit from this must call this function before doing
    any custom initialization.

Arguments:

    pList -- pointer to list to initialize.

    pvKey -- a unique key that identifies the list.  This parameter is
        necessary since the list itself is a StateObject, which requires a 
        key.  It can be set to 0 if this list will not be searched for
        as part of another list, but should be set otherwise to a unique
        value.

Return Value:

    None -- the function does nothing which could fail.

--*/
{
    StateObjectInit(
        (StateObject*) pList,
        pvKey);

    pList->pHead = NULL;
}


BOOL StateObjectListIsEmpty(StateObjectList* pList)
/*++
Routine Description:

    This function returns information on whether or not this
    list is empty.

Arguments:

    pList -- pointer to list in question

Return Value:

    TRUE if the list is empty,
    FALSE if not.

--*/
{
    return NULL == pList->pHead;
}


StateObject* StateObjectListRemove(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will remove an object from the list --
    it does *not* destroy the object.

Arguments:

    pList -- the list to remove the object from

    pvKey -- a unique key identifying the object to remove

Return Value:

    a pointer to the removed object if successful,
    NULL otherwise

--*/
{
    StateObject* pObject;

    //
    // First, we need to find an object with the desired key
    //

    pObject = StateObjectListFind(
        pList,
        pvKey);

    if (!pObject) {
        return NULL;
    }

    //
    // Now that we've executed the find, the object is at the front
    // of the list -- we can remove it by setting the head to the
    // next object in the list
    //
    pList->pHead = (StateObject*) (pObject->Links.Flink);

    //
    // Make sure the new head's previous pointer is NULL since it
    // has no predecessor
    //
    if (pList->pHead) {
        pList->pHead->Links.Blink  = NULL;
    }

    return pObject;
}

StateObject* StateObjectListFind(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will find an object in the list

Arguments:

    pList -- the list in which to search

    pvKey -- a unique key identifying the object sought

Return Value:

    a pointer to the object if an object with a key matching pvKey is found,
    NULL otherwise

--*/
{
    StateObject* pCurrent;

    //
    // Loop through all objects in the list until we get to the end
    //
    for (pCurrent = pList->pHead;
         pCurrent != NULL;
         pCurrent = (StateObject*) pCurrent->Links.Flink)
    {
        //
        // See if this object's key matches the desired key
        //
        if (pvKey == pCurrent->pvKey) {
            
            PLIST_ENTRY pFlink;
            PLIST_ENTRY pBlink;

            //
            // If the desired object is at the front, this is a no op --
            // we don't have to move anything, just return the object
            //
            if (pCurrent == pList->pHead) {
                return pCurrent;
            }
    
            //
            // We need to move the found object to the front of the list
            //

            //
            // Remove the object from its current position
            // by severing its links
            //
            pBlink = pCurrent->Links.Blink;
            pFlink = pCurrent->Links.Flink;

            if (pBlink) {
                pBlink->Flink = pFlink;
            }

            if (pFlink) {
                pFlink->Blink = pBlink;
            }

            //
            // Re-add it to the front
            //
            StateObjectListAdd(
                pList,
                pCurrent);

            return pCurrent;
        }
    }

    //
    // We never found an object with the desired key above, so its
    // not in the list
    //
    return NULL;
}


VOID StateObjectListAdd(
    StateObjectList* pList,
    StateObject*     pObject)
/*++
Routine Description:

    This function will add an object to the list

Arguments:

    pList -- the list in which to add the object

    pObject -- pointer to an object which has been initialized
        with StateObjectInit; this object will be stored in the list.

Return Value:

    None -- this function does nothing which could fail.

Note:

    Only one object with a particular key should exist in the list.  This
    requirement is not enforced by this function or the list itself, so
    clients need to ensure that they follow this rule.

--*/
{
    //
    // Create the links between the object and what's currently 
    // at the front of the list
    //
    if (pList->pHead) {
        pObject->Links.Flink = (PLIST_ENTRY) pList->pHead;
        pList->pHead->Links.Blink = (PLIST_ENTRY) pObject;
    }

    //
    // Put the object at the front of the list
    //
    pList->pHead = pObject;
    pList->pHead->Links.Blink = NULL;
}


VOID StateObjectListClear(
    StateObjectList* pList,
    PFNDestroyObject pfnDestroy)
/*++
Routine Description:

    This function will remove and destroy all objects
        in the list.

Arguments:

    pList -- the list to clear

    pfnDestroy -- pointer to a function which will be called for
        each object in order to destroy (free resources such as memory,
        kernel objects, etc) it.

Return Value:

    None -- this function does nothing which could fail.

--*/
{
    StateObject* pCurrent;

    //
    // Keep removing objects until the list is empty
    //
    while (!StateObjectListIsEmpty(pList))
    {
        StateObject* pObject;
        
        //
        // Remove whatever's at the front of the list
        //
        pObject = StateObjectListRemove(
            pList,
            pList->pHead->pvKey);

        ASSERT(pObject);

        //
        // Destroy the removed object
        //
        pfnDestroy(pObject);
    }
}


#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regvcls.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegvCls.c

Abstract:

    This module contains helper functions for enumerating, 
    setting, and querying registry values in win32

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

Notes:


--*/


#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"



void ValStateGetPhysicalIndexFromLogical(
    ValueState* pValState,
    HKEY        hkLogicalKey,
    DWORD       dwLogicalIndex,
    PHKEY       phkPhysicalKey,
    DWORD*      pdwPhysicalIndex)
/*++

Routine Description:

    Retrieves a logical index for a value to a physical index

Arguments:

    pValState - value state containing values for a logical key
    hkLogicalKey - logical key we wish to index
    dwLogicalIndex - logical index to map
    phkPhysicalKey - handle to key where value is physically located
    pdwPhysicalIndex - index of value in physical key

Return Value:

    None.

Notes:

--*/
{
    //
    // If no value state is supplied, this means no merging is necessary
    // and we can return the supplied logical index as the correct
    // physical index
    //
    if (!pValState) {
        *pdwPhysicalIndex = dwLogicalIndex;
        *phkPhysicalKey = hkLogicalKey;
    } else {
        *pdwPhysicalIndex = pValState->rgIndex[dwLogicalIndex].dwOffset;
        *phkPhysicalKey = pValState->rgIndex[dwLogicalIndex].fUser ?
            pValState->hkUser :
            pValState->hkMachine;
    }
}


NTSTATUS ValStateSetPhysicalIndexFromLogical(
    ValueState*                     pValState,
    DWORD                           dwLogicalIndex)
/*++

Routine Description:

    Updates a state's mapping of logical indexes to physical indexes

Arguments:

    pValState - value state containing values for a logical key
    dwLogicalIndex - logical index used as a clue for whether
        or not we can used cached values or need to refresh the state -- 
        gives us an idea of what index the caller will be interested in 
        mapping after this call.

Return Value:

    None.

Notes:

--*/
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // If no value state is supplied, this means no merging is necessary
    // and we can return the supplied logical index as the correct
    // physical index
    //
    if (!pValState) {
        return STATUS_SUCCESS;
    }

    if (dwLogicalIndex >= pValState->cValues) {
        
        pValState->fDelete = TRUE;
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Always reset if they try to go backward, or
    // if they skip by more than 1, or if they
    // ask for the same index twice and we're
    // not expecting it
    //
    if ((dwLogicalIndex < pValState->dwCurrent) || 
        (dwLogicalIndex > (pValState->dwCurrent + 1)) ||
        ((dwLogicalIndex == pValState->dwCurrent) && !(pValState->fIgnoreResetOnRetry))) {
    
        Status = ValStateUpdate(pValState);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        pValState->fIgnoreResetOnRetry = FALSE;
    }

    return Status;
}


void ValStateRelease(
    ValueState* pValState)
/*++

Routine Description:

    Frees resources (handles, memory) associated with a value state

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    None.

Notes:

--*/
{
    if (!pValState) {
        return; 
    }

    if (pValState->hkUser && (pValState->hkUser != pValState->hkLogical)) {
        NtClose(pValState->hkUser);
    }

    if (pValState->hkMachine && (pValState->hkMachine != pValState->hkLogical)) {
        NtClose(pValState->hkMachine);
    }

    if (pValState->rgIndex) {
        RegClassHeapFree(pValState->rgIndex);
    }

    RegClassHeapFree(pValState);
}


NTSTATUS ValStateUpdate(ValueState* pValState)
/*++

Routine Description:

    Updates the value state to reflect the current state
        of the logical key's physical state -- it retrieves
        the names of the values for the logical key from
        the kernel, and re-indexes the table to properly
        merge user and machine state

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS             Status;
    DWORD                cUserValues;
    DWORD                cMachineValues;
    DWORD                cMaxValues;
    DWORD                cbMaxNameLen;
    DWORD                cbMaxDataLen;
    DWORD                cbBufferLen;
    ValueLocation*       rgIndex;
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo;

    //
    // Init locals
    //
    cUserValues = 0;
    cMachineValues = 0;
    cbMaxNameLen = 0;
    rgIndex = NULL;

    pValState->cValues = 0;

    //
    // Get information about this value
    //
    Status = GetFixedKeyInfo(
        pValState->hkUser,
        pValState->hkMachine,
        &cUserValues,
        &cMachineValues,
        NULL,
        NULL,
        &cbMaxNameLen);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    cMaxValues = cUserValues + cMachineValues;

    //
    // Nothing to do if there are no Values
    //
    if (!cMaxValues) {
        return STATUS_SUCCESS;
    }

    //
    // Now allocate necessary memory
    // First get memory for index vector
    //
    rgIndex = (ValueLocation*) RegClassHeapAlloc(cMaxValues * sizeof(*rgIndex));

    if (!rgIndex) {
        return STATUS_NO_MEMORY;
    }

    //
    // Now get memory for retrieving names -- first allocate an array 
    // of pointers to values
    //
    ppValueInfo = (PKEY_VALUE_BASIC_INFORMATION*) RegClassHeapAlloc(
        sizeof(*ppValueInfo) * cMaxValues);

    if (!ppValueInfo) {

        RegClassHeapFree(rgIndex);

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(ppValueInfo, sizeof(*ppValueInfo) * cMaxValues);

    cbBufferLen = sizeof(**ppValueInfo) + cbMaxNameLen;

    //
    // Now allocate each individual value
    //
    {
        DWORD dwValue;

        for (dwValue = 0; dwValue < cMaxValues; dwValue++) 
        {
            ppValueInfo[dwValue] = (PKEY_VALUE_BASIC_INFORMATION) RegClassHeapAlloc(
                cbBufferLen);

            if (!(ppValueInfo)[dwValue]) {
                Status = STATUS_NO_MEMORY;
                break;
            }
        }
    }

    //
    // Now fetch the values.  From this point on we are assuming success
    // and updating the index table
    // 
    {

        HKEY  hKeyPhysical;
        DWORD dwLimit;
        DWORD dwLogical;
        BOOL  fUser;

        //
        // Free the existing index table
        //
        if (pValState->rgIndex) {
            RegClassHeapFree(pValState->rgIndex);
        }

        pValState->rgIndex = rgIndex;

        dwLogical = 0;

        for( hKeyPhysical = pValState->hkUser, fUser = TRUE,
                 dwLimit = cUserValues;
             ;
             hKeyPhysical = pValState->hkMachine, fUser = FALSE,
                 dwLimit = cMachineValues)
        {
            DWORD dwPhysical;

            for (dwPhysical = 0; dwPhysical < dwLimit; dwPhysical++) 
            {
                BOOL fNewValue;

                //
                // Ask the kernel for the value
                //
                Status = EnumerateValue(
                    hKeyPhysical,
                    dwPhysical,
                    ppValueInfo[dwLogical],
                    cbBufferLen,
                    NULL);

                //
                // If we encounter an error, just keep going and try to get
                // as many values as we can
                //
                if (!NT_SUCCESS(Status)) {
                    continue;
                }

                //
                // Mark certain attributes about this value that will
                // be important later
                //
                ppValueInfo[dwLogical]->TitleIndex = dwPhysical;
                ppValueInfo[dwLogical]->Type = fUser;
                

                //
                // This will add the value to our sorted list.  Since
                // the list is sorted, it is easy to eliminated duplicates --
                // don't add duplicates -- since we add 
                // user keys first, this allows us to give user values precedence
                // over machine values of the same name.  The logical key
                // index is also incremented if a key is added.
                //
                fNewValue = ValStateAddValueToSortedValues(
                    ppValueInfo,
                    dwLogical);

                if (fNewValue) {
                    dwLogical++;
                }
            }

            //
            // Break out of this loop if we just added the user values
            // since those are the last values we add
            //
            if (!fUser) {
                break;
            }
        }

        pValState->cValues = dwLogical;
    }

    //
    // Now copy the results back to the state's index array
    //
    {

        DWORD dwLogical;

        for (dwLogical = 0; dwLogical < pValState->cValues; dwLogical++)
        {
    
            pValState->rgIndex[dwLogical].dwOffset = 
                ppValueInfo[dwLogical]->TitleIndex;
            
            pValState->rgIndex[dwLogical].fUser =
                ppValueInfo[dwLogical]->Type;
        }
    }

    //
    // Release this
    //
    ValStateReleaseValues(
        ppValueInfo,
        cMaxValues);

    return STATUS_SUCCESS;
}


void ValStateReleaseValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    DWORD                         cMaxValues)
/*++

Routine Description:

    Releases resources associated with the values stored
        in the value state.

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    None.

Notes:

--*/
{
    DWORD dwValue;

    //
    // First, free each individual value
    //
    for (dwValue = 0; dwValue < cMaxValues; dwValue++) 
    {
        //
        // Free memory for this value
        //
        if (ppValueInfo[dwValue]) {
            RegClassHeapFree(ppValueInfo[dwValue]);
        }
    }
    
    //
    // Now free the array that held all the values
    //
    RegClassHeapFree(ppValueInfo);
}



NTSTATUS ValStateInitialize( 
    ValueState** ppValState,
    HKEY         hKey)
/*++

Routine Description:

    Initializes a value state 

Arguments:

    pValState - value state containing values for a logical key
    hKey - logical key whose state this value state will represent

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    ValueState* pValState;
    HKEY        hkUser;
    HKEY        hkMachine;

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    pValState = NULL;

    //
    // Get the user and machine keys
    //
    Status = BaseRegGetUserAndMachineClass(
        NULL,
        hKey,
        MAXIMUM_ALLOWED,
        &hkMachine,
        &hkUser);

    if (NT_SUCCESS(Status)) {

        ASSERT(hkUser || hkMachine);

        //
        // We only need to create a state if there are
        // two keys -- if only one exists, we don't
        // need to do merging
        //
        if (!hkUser || !hkMachine) {
            *ppValState = NULL;
            
            return STATUS_SUCCESS;
        }

        //
        // Get memory for the value state
        //
        pValState = RegClassHeapAlloc( sizeof(*pValState) + 
                                   sizeof(DWORD) * DEFAULT_VALUESTATE_SUBKEY_ALLOC );

        //
        // Be sure to release acquired resources on failure
        //
        if (!pValState) {

            if (hkUser != hKey) {
                NtClose(hkUser);
            } else {
                NtClose(hkMachine);
            }

            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(pValState, sizeof(*pValState));

        pValState->hkUser = hkUser;
        pValState->hkMachine = hkMachine;
        pValState->hkLogical = hKey;
        pValState->fIgnoreResetOnRetry = TRUE;

        //
        // Now update the state to reflect the current registry
        //
        Status = ValStateUpdate(pValState);
    } 

    //
    // On success, set our out param
    //
    if (NT_SUCCESS(Status)) {
        *ppValState = pValState;
    } else {

        if (pValState) {
            ValStateRelease(pValState);
        }
    }

    return Status;

}


BOOL ValStateAddValueToSortedValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    LONG                          lNewValue)
/*++

Routine Description:

    Inserts a retrieved value into the sorted list
        of values in a value state

Arguments:

    pValState - value state containing values for a logical key
    lNewValue - index of newly added value in the sorted list --
        this value needs to be moved elsewhere in the list to maintain
        the sorted nature of the list

Return Value:

    TRUE if the state was added, FALSE if not.

Notes:

--*/
{
    PKEY_VALUE_BASIC_INFORMATION pNewValue;
    LONG                         lFinalSpot;
    LONG                         lCurrent;
    UNICODE_STRING               NewKeyName;

    lFinalSpot = 0;

    pNewValue = ppValueInfo[lNewValue];
            
    NewKeyName.Buffer = pNewValue->Name;
    NewKeyName.Length = (USHORT) pNewValue->NameLength;

    for (lCurrent = lNewValue - 1; lCurrent >= 0; lCurrent--) 
    {
        UNICODE_STRING               CurrentValueName;
        PKEY_VALUE_BASIC_INFORMATION pCurrentValue;
        LONG                         lCompareResult;

        pCurrentValue = ppValueInfo[lCurrent];

        CurrentValueName.Buffer = pCurrentValue->Name;
        CurrentValueName.Length = (USHORT) pCurrentValue->NameLength;

        lCompareResult = RtlCompareUnicodeString(
            &NewKeyName,
            &CurrentValueName,
            TRUE);

        if (lCompareResult < 0) {

            continue;

        } else if (0 == lCompareResult) {
            //
            // If it's a duplicate, don't add it
            //
            return FALSE;
            
        } else {

            lFinalSpot = lCurrent + 1;

            break;
        }
    }

    //
    // Now we know the final spot, add the value
    //
    
    //
    // Move everything up to make room for the new value
    //
    for (lCurrent = lNewValue - 1; lCurrent >= lFinalSpot; lCurrent--) 
    {
        //
        // Move the current value up one
        //
        ppValueInfo[lCurrent + 1] = ppValueInfo[lCurrent];
    }

    //
    // Copy the value to its final destination
    //
    ppValueInfo[lFinalSpot] = pNewValue;

    //
    // This means we've found no duplicate value
    // so we add it
    //
    return TRUE;
}


NTSTATUS KeyStateGetValueState(
    HKEY         hKey,
    ValueState** ppValState)
/*++

Routine Description:

    Gets the value state for a particular key

Arguments:

    hKey - key whose state we need to retrieve
    ppValState - out param pointing to a pointer to the
        retrieved state.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

    ATENTION: Right now, this always creates a new state -- in the future,
    we may want to change this to be cached in a table to avoid reconstructing
    on every call.

--*/
{
    //
    // Now build the value state
    //
    return ValStateInitialize(
        ppValState,
        hKey);
}


NTSTATUS BaseRegGetClassKeyValueState(
    HKEY         hKey,
    DWORD        dwLogicalIndex,
    ValueState** ppValState)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hKey - key whose state we need to retrieve
    dwLogicalIndex - hint that helps us to optimize the state for this
        index so the caller's use of the state is more efficient
    ppValState - out param pointing to a pointer to the
        retrieved state.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    ValueState* pValState;

    //
    // First retrieve the state for this key
    // 
    Status = KeyStateGetValueState(hKey, &pValState);

    if (NT_SUCCESS(Status)) {

        //
        // Now map the logical index to a physical one
        //
        Status = ValStateSetPhysicalIndexFromLogical(pValState, dwLogicalIndex);

        if (!NT_SUCCESS(Status)) {
            ValStateRelease(pValState);
        } else {
            *ppValState = pValState;
        }

    }

    return Status;
}


NTSTATUS EnumerateValue(
    HKEY                            hKey,
    DWORD                           dwValue,
    PKEY_VALUE_BASIC_INFORMATION    pSuggestedBuffer,
    DWORD                           dwSuggestedBufferLength,
    PKEY_VALUE_BASIC_INFORMATION*   ppResult)
/*++

Routine Description:

    Retrieves a value for a physical key from the kernel

Arguments:

    hKey - physical key for which we're trying to read a value
    dwValue - physical index of value to read
    pSuggestedBuffer - basinc info buffer to use by default, may not be large enough
    dwSuggestedBufferLength - size of suggested buffer
    ppResult - pointer to result basic info -- may be allocated by this function if
        suggested buffer was insufficient, which means caller will have to free
        this if it is not the same as the suggested buffer

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS                        Status;
    PKEY_VALUE_BASIC_INFORMATION    pKeyValueInformation;        
    DWORD                           dwResultLength;

    pKeyValueInformation = pSuggestedBuffer;

    //
    // Query for the necessary information about the supplied value.
    //
    Status = NtEnumerateValueKey( hKey,
                                  dwValue,
                                  KeyValueBasicInformation,
                                  pKeyValueInformation,
                                  dwSuggestedBufferLength,
                                  &dwResultLength);
    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if (ppResult && (STATUS_BUFFER_OVERFLOW == Status)) {

        pKeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION) RegClassHeapAlloc(
            dwResultLength);

        if (!pKeyValueInformation) {
            return STATUS_NO_MEMORY;
        }

        //
        // Query for the necessary information about the supplied value.
        //
        Status = NtEnumerateValueKey( hKey,
                                      dwValue,
                                      KeyValueBasicInformation,
                                      pKeyValueInformation,
                                      dwResultLength,
                                      &dwResultLength);

        ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

        if (!NT_SUCCESS(Status)) {
            RegClassHeapFree(pKeyValueInformation);
        }
    }

    if (NT_SUCCESS(Status) && ppResult) {
        *ppResult = pKeyValueInformation;
    }

    return Status;
}


NTSTATUS BaseRegQueryMultipleClassKeyValues(
    HKEY     hKey,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hKey - Supplies a handle to the open key. The value entries returned
           are contained in the key pointed to by this key handle. Any of
           the predefined reserved handles or a previously opened key handle
           may be used for hKey.

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. 

    ldwRequiredLength - If lpValueBuf is not large enough to
                 contain all the data, returns the size of lpValueBuf required
                 to return all the requested data.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    HKEY        hkUser;
    HKEY        hkMachine;
    HKEY        hkQuery;

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    //
    // First, get both user and machine keys
    //
    Status = BaseRegGetUserAndMachineClass(
        NULL,
        hKey,
        MAXIMUM_ALLOWED,
        &hkMachine,
        &hkUser);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If we have both, we call a routine
    // to merge the values
    //
    if (hkMachine && hkUser) {

        Status = BaseRegQueryAndMergeValues(
            hkUser,
            hkMachine,
            val_list,
            num_vals,
            lpvalueBuf,
            ldwTotsize,
            ldwRequiredLength);

        goto cleanup;
    }

    //
    // We have only one key -- query the one with the 
    // highest precedence
    //
    hkQuery = hkUser ? hkUser : hkMachine;

    Status = NtQueryMultipleValueKey(hkQuery,
                                     (PKEY_VALUE_ENTRY)val_list,
                                     num_vals,
                                     lpvalueBuf,
                                     ldwTotsize,
                                     ldwRequiredLength);

cleanup:

    //
    // Close extra kernel object
    //
    if (hKey != hkUser) {
        NtClose(hkUser);
    } else {
        NtClose(hkMachine);
    }

    return Status;
}


NTSTATUS BaseRegQueryAndMergeValues(
    HKEY     hkUser,
    HKEY     hkMachine,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hkUser - user key to query for values
    hkMachine - machine key to query for values

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. 

    ldwRequiredLength - If lpValueBuf is not large enough to
                 contain all the data, returns the size of lpValueBuf required
                 to return all the requested data.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

    ATTENTION: this is non-atomic, unlike the regular RegQueryMultipleValues
    call.  In the future, implementing this in the kernel would make this
    atomic again. 

--*/
{
    NTSTATUS Status;
    DWORD    dwVal;
    BOOL     fOverflow;
    DWORD    dwBufferLength;
    DWORD    dwRequired;
    DWORD    dwKeyInfoLength;
    DWORD    dwBufferUsed;

    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;

    //
    // Initialize locals
    //
    dwBufferLength = *ldwTotsize;
    dwRequired = 0;
    dwBufferUsed = 0;

    fOverflow = FALSE;

    //
    // Validate out params -- we assume that ldwTotsize and
    // ldwRequiredLength were given to us by winreg client,
    // so they should be safe to read / write from. lpValueBuf
    // comes from the caller of the win32 api, so we need to
    // validate it -- in previous versions of NT, this parameter
    // went straight to the kernel, which did the validation and
    // returned an error if it was pointing to inaccessible memory.
    // Since we're accessing it here in user mode, we need to do 
    // our own validation
    //
    if (IsBadWritePtr( lpvalueBuf, dwBufferLength)) 
    {
        return STATUS_ACCESS_VIOLATION;
    }
        
    //
    // First, we need to allocate enough memory to retrieve
    // all the values -- we can't just use lpvalueBuf 
    // because it doesn't include the overhead of the
    // KEY_VALUE_PARTIAL_INFORMATION structure.  If we allocate
    // for the size of lpvalueBuf + the structure overhead,
    // we will always have enough for our queries.
    //
    dwKeyInfoLength = sizeof(*pKeyInfo) * num_vals + *ldwTotsize;
    
    pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
        RegClassHeapAlloc( dwKeyInfoLength);

    if (!pKeyInfo) {
        return STATUS_NO_MEMORY;
    }

    //
    // For each value requested by the caller, try 
    // to retrieve it from user or machine
    //
    for (dwVal = 0; dwVal < num_vals; dwVal++)
    {
        DWORD dwResultLength;
        
        //
        // Round up the used and required lengths to a ULONG boundary --
        // this means that the required size returned to the caller of the win32
        // api can be an overestimation, as much as 3 bytes per requested value.
        // We could do some work to avoid this, but since the kernel returns a rounded
        // up value in dwResultLength, the kernel api is itself overestimating, although
        // it only overestimates by at most 3 bytes over all the values.  We could avoid
        // this by allocating enough memory ahead of time to query the largest value, either
        // as one large preallocation or continually allocating and reallocating, but this will
        // be slower and / or consume more memory
        //
        dwBufferUsed = (dwBufferUsed + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);
        dwRequired = (dwRequired + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);

        //
        // Query the user key first since it has highest precedence
        //
        Status = NtQueryValueKey(
            hkUser,
            val_list[dwVal].rv_valuename,
            KeyValuePartialInformation,
            pKeyInfo,
            dwKeyInfoLength,
            &dwResultLength);

        //
        // Check for errors -- if the value didn't exist, we'll look
        // in machine -- for buffer overflow, we'll proceed as if
        // this succeeded so that we can calculate the required
        // buffer size
        //
        if (!NT_SUCCESS(Status) && 
            (STATUS_BUFFER_OVERFLOW != Status)) {
            
            if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
                goto cleanup;
            }
            
            //
            // If there is no user value, query the machine key
            //
            Status = NtQueryValueKey(
                hkMachine,
                val_list[dwVal].rv_valuename,
                KeyValuePartialInformation,
                pKeyInfo,
                dwKeyInfoLength,
                &dwResultLength);
            
            //
            // Similar error handling to above -- if we don't have enough
            // buffer, pretend we've succeeded so we can calc the required size
            //
            if (!NT_SUCCESS(Status) &&
                (STATUS_BUFFER_OVERFLOW != Status)) {
                goto cleanup;
            }
        }
        
        ASSERT(NT_SUCCESS(Status) || (STATUS_BUFFER_OVERFLOW == Status));
        
        if (NT_SUCCESS(Status)) {
            dwResultLength = pKeyInfo->DataLength;
        }
        
        //
        // Check for buffer overflow
        //
        if ( ( (dwBufferUsed + pKeyInfo->DataLength) <= dwBufferLength) && !fOverflow) {
            
            ASSERT(NT_SUCCESS(Status));
            
            //
            // Copy the data to the fixed part of the client's structure
            //
            val_list[dwVal].rv_valuelen = dwResultLength;
            val_list[dwVal].rv_valueptr = dwRequired;
            val_list[dwVal].rv_type = pKeyInfo->Type;

            //
            // We didn't overflow, so we still have enough room to copy
            // the latest value
            //
            RtlCopyMemory(
                (BYTE*)lpvalueBuf + val_list[dwVal].rv_valueptr,
                &(pKeyInfo->Data),
                dwResultLength);
            
            dwBufferUsed += pKeyInfo->DataLength;
            
        } else {
            //
            // We're out of buffer -- set this flag to
            // signal this state
            //
            fOverflow = TRUE;            
        }
        
        //
        // Update our required length with the size
        // of the data from the current value
        //
        dwRequired += dwResultLength;
    }

    //
    // At this point, we've succeeded in the sense that
    // we've copied all the data or we couldn't due to
    // insufficient buffer but we were able to calculate
    // the required size
    //
    Status = STATUS_SUCCESS;

cleanup:

    //
    // Free the allocated memory
    // 
    RegClassHeapFree(pKeyInfo);

    //
    // If we succeeded, this means we've either copied
    // the data or overflowed and copied the size -- handle
    // both below
    //
    if (NT_SUCCESS(Status)) {

        //
        // Always set this so the caller knows how much
        // was copied or needs to be allocated
        //
        *ldwRequiredLength = dwRequired;
        
        //
        // Return the appropriate error if we overflowed
        //
        if (fOverflow) {
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // Setting this, although winreg client actually
        // ignores this quantity
        //
        *ldwTotsize = dwBufferUsed;
    }

    return Status;
}

#endif LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regvcls.h ===
/*++









Copyright (c) 1992  Microsoft Corporation

Module Name:

    regvcls.h

Abstract:

    This file contains declarations for data structures
    needed for enumerating values under HKEY_CLASSES_ROOT

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#if !defined(_REGVCLS_H_)
#define _REGVCLS_H_

#include "regecls.h"

#define DEFAULT_VALUESTATE_SUBKEY_ALLOC 1

//
// Data types
//

typedef struct _ValueLocation {
    DWORD  dwOffset;
    BOOL   fUser;
} ValueLocation;

typedef struct _ValueState {

    HKEY                            hkLogical;
    HKEY                            hkUser;
    HKEY                            hkMachine;
    DWORD                           dwCurrent;
    DWORD                           cValues;
    unsigned                        fIgnoreResetOnRetry : 1;
    unsigned                        fDelete : 1;
    ValueLocation*                  rgIndex;

} ValueState;

//
// Value enumeration methods
//

void ValStateGetPhysicalIndexFromLogical(
    ValueState* pValState,
    HKEY        hkLogicalKey,
    DWORD       dwLogicalIndex,
    PHKEY       phkPhysicalKey,
    DWORD*      pdwPhysicalIndex);

NTSTATUS ValStateSetPhysicalIndexFromLogical(
    ValueState*                     pValState,
    DWORD                           dwLogicalIndex);

void ValStateRelease(ValueState* pValState);

void ValStateReleaseValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    DWORD                         cMaxValues);

NTSTATUS ValStateUpdate(ValueState* pValState);

NTSTATUS ValStateInitialize( 
    ValueState** ppValState,
    HKEY         hKey);

BOOL ValStateAddValueToSortedValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    LONG                          lNewValue);

NTSTATUS KeyStateGetValueState(
    HKEY         hKey,
    ValueState** ppValState);

NTSTATUS BaseRegGetClassKeyValueState(
    HKEY         hKey,
    DWORD        dwLogicalIndex,
    ValueState** ppValueState);

NTSTATUS EnumerateValue(
    HKEY                            hKey,
    DWORD                           dwValue,
    PKEY_VALUE_BASIC_INFORMATION    pSuggestedBuffer,
    DWORD                           dwSuggestedBufferLength,
    PKEY_VALUE_BASIC_INFORMATION*   ppResult);

//
// Multiple value query routines
//
NTSTATUS BaseRegQueryMultipleClassKeyValues(
    HKEY     hKey,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength);

NTSTATUS BaseRegQueryAndMergeValues(
    HKEY     hkUser,
    HKEY     hkMachine,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength);

#endif // !defined(_REGVCLS_H_)
#endif LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\shutdown.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module contains the server side implementation for the Win32 remote
    shutdown APIs, that is:

        - BaseInitiateSystemShutdown
        - BaseAbortSystemShutdown
        - BaseInitiateSystemShutdownEx

Author:

    Dragos C. Sambotin 18-May-1999

Notes:
    
    These server side APIs are just stubs RPCalling in the winlogon's shutdown
    interface. They are provided only for backward compatibility. When support 
    for older versions is dropped, these stubs can be removed.

Revision History:

--*/


#define UNICODE

#include <rpc.h>
#include "regrpc.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"


ULONG
BaseInitiateSystemShutdown(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN PUNICODE_STRING lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOLEAN bForceAppsClosed,
    IN BOOLEAN bRebootAfterShutdown
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

    lpMessage - message to display during shutdown timeout period.

    dwTimeout - number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
              - If this true, all applications are terminated unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot. FALSE if it should
              - be left in a shutdown state.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    SHUTDOWN_CONTEXT ShutdownContext;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    //
    // do it locally
    //
    ServerName = L"";
    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);

    //
    // delegate the call to the new interface
    //
    
    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewShutdownCallback,
                                                lpMessage,
                                                &ShutdownContext);
    
    RevertToSelf();
    
    return Result;
}

ULONG
BaseInitiateSystemShutdownEx(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN PUNICODE_STRING lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOLEAN bForceAppsClosed,
    IN BOOLEAN bRebootAfterShutdown,
    IN DWORD dwReason
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

    lpMessage - message to display during shutdown timeout period.

    dwTimeout - number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
              - If this true, all applications are terminated unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot. FALSE if it should
              - be left in a shutdown state.

    dwReason    - Reason for initiating the shutdown.  This reason is logged
                        in the eventlog #6006 event.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    SHUTDOWN_CONTEXTEX ShutdownContext;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    // do it locally
    ServerName = L"";
    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    ShutdownContext.dwReason = dwReason;

    //
    // delegate the call to the new interface
    //

    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewShutdownCallbackEx,
                                                lpMessage,
                                                &ShutdownContext);

    RevertToSelf();
    
    return Result;
}

ULONG
BaseAbortSystemShutdown(
    IN PREGISTRY_SERVER_NAME ServerName
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    RPC_BINDING_HANDLE binding;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    //
    // Call the server
    //

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    // do it locally
    ServerName = L"";

    //
    // delegate the call to the new interface
    //
    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewAbortShutdownCallback,
                                                NULL,
                                                NULL);

    RevertToSelf();
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\regstate.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regstate.h

Abstract:

    This file contains declarations for data structures
    needed for maintaining state for registry key objects

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

    This file contains declarations for an object which
    can be stored in a collection.  The collection is a linked
    list, whose most frequently accessed members are at the
    front of the list.  Thus it is optimized for situations
    in which the same object may be asked for repeatedly.

    To use this list, you should create structures which
    inherit from the base object (StateObject).  Each object
    has a key which must be specified when you create a new
    object.  The key is used in searches and removes.  The objects
    must all have disinct keys, but this is not enforced by the list --
    the caller should be sure to avoid duplicates.

    Note that the list does not allocate or free objects --
    it simply allows them to be added, removed, and searched
    for in the list.  You will need to initialize any object
    before putting it into the list with the StateObjectInit
    function.

--*/

#ifdef LOCAL

#if !defined(_REGSTATE_H_)
#define _REGSTATE_H_


//
// Data types
//

//
// StateObject
//
// This is the base type -- any object used with the list must
// inherit from this object
//
typedef struct _StateObject
{
    LIST_ENTRY Links;
    PVOID      pvKey;
} StateObject;

//
// Pointer type for a caller supplied function used to
// destroy objects (de-allocate memory, free resources, etc)
//
typedef VOID (*PFNDestroyObject) (StateObject* pObject);


//
// StateObjectList
//
// This is a linked list of StateObjects, with the most frequently accessed
// elements at the front of the list.  If the same item is
// accessed repeatedly, it is found immediately in search
// operations.  Note that the list is itself a StateObject, so
// the list type can be composed with itself.
//
typedef struct _StateObjectList 
{
    StateObject  Object;
    StateObject* pHead;
} StateObjectList;


//
// Exported prototypes
//

//
// Initializes a StateObject -- must be called before
// the object is used
//
VOID StateObjectInit(
    StateObject* pObject,
    PVOID        pvKey);


//
// Initializes a StateObjectList -- must be called before
// the list is used
//
VOID StateObjectListInit(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Tells whether or not a list is empty
//
BOOL StateObjectListIsEmpty(StateObjectList* pList);

//
// Removes an object from the list
//
StateObject*  StateObjectListRemove(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Finds an object in the list
//
StateObject* StateObjectListFind(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Adds an object to the list
//
VOID StateObjectListAdd(
    StateObjectList* pList,
    StateObject*     pObject);

//
// Removes all objects from the list and 
// destroys them.
//
VOID StateObjectListClear(
    StateObjectList* pList,
    PFNDestroyObject pfnDestroy);
                          

#endif // _REGSTATE_H_

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\server\support.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support functions for the server side of the
    Win32 Registry APIs. That is:

        - PRPC_HKEY_rundown

Author:

    David J. Gilman (davegi) 21-Mar-1992

--*/

#include <rpc.h>
#include "regrpc.h"

error_status_t
BaseRegCloseKeyInternal(
    IN OUT PHKEY phKey 
    );


VOID
RPC_HKEY_rundown (
    IN RPC_HKEY hKey
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{   LONG    Error;

    ASSERT( ((hKey == HKEY_PERFORMANCE_DATA) ||
             (hKey == HKEY_PERFORMANCE_TEXT) ||
             (hKey == HKEY_PERFORMANCE_NLSTEXT)) ||
            !IsPredefinedRegistryHandle( hKey ) );

    CleanDeadClientInfo( hKey );

    Error = BaseRegCloseKeyInternal( &hKey );

    ASSERT( Error == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\apitest\apitest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Apitest.c

Abstract:

    This module contains the function test for the Win32 Registry API.

Author:

    David J. Gilman (davegi) 28-Dec-1991

Environment:

    Windows, Crt - User Mode

Notes:

    This test can be compiled for Unicode by defining the compiler symbol
    UNICODE.

    Since this is a test program it relies on assertions for error checking
    rather than a more robust mechanism.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include "crtools.h"



#define HKEY_ROOT                       HKEY_CURRENT_USER
#define SAVE_RESTORE_FILE               TEXT( "srkey.reg" )
#define KEY_PATH                        \
        TEXT( "TestUser1\\TestUser1_1\\TestUser1_2" )


#define PREDEFINED_HANDLE               HKEY_USERS
#define PREDEFINED_HANDLE_STRING        \
        TEXT( "HKEY_USERS\\.Default\\TestUser1" )


#define KEY_NAME_1                      TEXT( "TestUser1" )
#define KEY_NAME_1_TITLE_INDEX          ( 0 )
#define KEY_NAME_1_CLASS                TEXT( "Test User Class" )
#define KEY_NAME_1_CLASS_LENGTH         LENGTH( KEY_NAME_1_CLASS )

#define KEY_NAME_1_1                    TEXT( "TestUser1_1" )
#define KEY_NAME_1_1_LENGTH             LENGTH( KEY_NAME_1_1 )
#define KEY_NAME_1_1_TITLE_INDEX        ( 0 )
#define KEY_NAME_1_1_CLASS              TEXT( "Test User Class" )
#define KEY_NAME_1_1_CLASS_LENGTH       LENGTH( KEY_NAME_1_1_CLASS )

#define KEY_NAME_1_2                    TEXT( "TestUser1_2" )
#define KEY_NAME_1_2_LENGTH             LENGTH( KEY_NAME_1_2 )
#define KEY_NAME_1_2_TITLE_INDEX        (0 )
#define KEY_NAME_1_2_CLASS              TEXT( "Test User Class" )
#define KEY_NAME_1_2_CLASS_LENGTH       LENGTH( KEY_NAME_1_2_CLASS )

#define VALUE_NAME_1                    TEXT( "One" )
#define VALUE_NAME_1_LENGTH             LENGTH( VALUE_NAME_1 )
#define VALUE_NAME_1_TITLE_INDEX        0
#define VALUE_DATA_1                    "Number One"
#define VALUE_DATA_1_LENGTH             11
#define VALUE_DATA_1_TYPE               REG_SZ

#define VALUE_NAME_2                    TEXT( "Second" )
#define VALUE_NAME_2_LENGTH             LENGTH( VALUE_NAME_2 )
#define VALUE_NAME_2_TITLE_INDEX        ( 0 )
#define VALUE_DATA_2                    ( 2 )
#define VALUE_DATA_2_LENGTH             ( sizeof( VALUE_DATA_2 ))
#define VALUE_DATA_2_TYPE               REG_DWORD

#define MAX_DATA_LENGTH                 ( 32 )

//
// Root handle for apitest's nodes.
//

HKEY    RootHandle;

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: apitest [-?] [-q] [\\machinename]\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?           - display this message.\n"                          \
      "    -q           - quiet - suppresses all output\n"                  \
      "    machinename  - remote machine.\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    InvalidMachineNameMessage =

    "Invalid machine name - %s\n";

//
// Event handle used for synchronization.
//

HANDLE  _EventHandle;
HANDLE  _EventHandle1;
HANDLE  _EventHandle2;

BOOL    Quiet;



VOID
DeleteTree(
    IN HKEY KeyHandle
    )

{
    LONG        Error;
    DWORD       Index;
    HKEY        ChildHandle;


    TSTR        KeyName[ MAX_PATH ];
    DWORD       KeyNameLength;
    TSTR        ClassName[ MAX_PATH ];
    DWORD       ClassNameLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                KeyHandle,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        KeyNameLength = MAX_PATH;

        Error = RegEnumKey(
                    KeyHandle,
                    0,
                    // Index,
                    KeyName,
                    KeyNameLength
                    );
        REG_API_SUCCESS( RegEnumKey );

        Error = RegOpenKey(
                    KeyHandle,
                    KeyName,
                    &ChildHandle
                    );

        REG_API_SUCCESS( RegOpenKey );

        DeleteTree( ChildHandle );

        Error = RegCloseKey(
                    ChildHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}
VOID
DeleteTestTree(
    )

{
    LONG    Error;
    HKEY    KeyHandle;

    Error = RegOpenKey(
                RootHandle,
                KEY_NAME_1,
                &KeyHandle
                );

    if( Error == ERROR_SUCCESS ) {

        DeleteTree( KeyHandle );

        Error = RegCloseKey(
                    KeyHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    RootHandle,
                    KEY_NAME_1
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}

DWORD
NotifyThread(
    LPVOID  Parameters
    )

{
    LONG        Error;
    BOOL        ErrorFlag;
    HANDLE      EventHandle;

    UNREFERENCED_PARAMETER( Parameters );

    //
    // Create the notification event.
    //

    EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( EventHandle != NULL );

    //
    // Set-up an asynchronous notify.
    //

    Error = RegNotifyChangeKeyValue(
                RootHandle,
                FALSE,
                REG_LEGAL_CHANGE_FILTER,
                EventHandle,
                TRUE
                );
    REG_API_SUCCESS( RegNotifyChangeKeyValue );

    //
    // Release the main thread.
    //

    ErrorFlag = SetEvent( _EventHandle );
    ASSERT( ErrorFlag == TRUE );

    //
    // Wait for a notification.
    //

    Error = (LONG)WaitForSingleObject( EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    if( ! Quiet ) {
        printf( "First notification triggered\n" );
    }

    CloseHandle( EventHandle );

    EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( EventHandle != NULL );

    //
    // Set-up an asynchronous notify.
    //

    Error = RegNotifyChangeKeyValue(
                RootHandle,
                FALSE,
                REG_LEGAL_CHANGE_FILTER,
                EventHandle,
                TRUE
                );
    REG_API_SUCCESS( RegNotifyChangeKeyValue );

    //
    // Release the main thread.
    //

    ErrorFlag = SetEvent( _EventHandle1 );
    ASSERT( ErrorFlag == TRUE );

    //
    // Wait for a notification.
    //

    Error = (LONG)WaitForSingleObject( EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    if( ! Quiet ) {
        printf( "Second notification triggered\n" );
    }

    CloseHandle( EventHandle );
    ErrorFlag = SetEvent( _EventHandle2 );
    ASSERT( ErrorFlag == TRUE );




#endif



    return ( DWORD ) TRUE;
}

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

{
    LONG                    Error;
    BOOL                    ErrorFlag;
    DWORD                   Index;

    PTSTR                   MachineName;

    PKEY                    Key;
    TSTR                    NameString[ MAX_PATH ];

    HANDLE                  NotifyThreadHandle;
    DWORD                   ThreadID;

    HKEY                    PredefinedHandle;
    HKEY                    Handle1;
    HKEY                    Handle1_1;
    HKEY                    Handle1_2;

    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    SECURITY_ATTRIBUTES     SecurityAttributes;

    DWORD                   Disposition;
    TSTR                    KeyName[ MAX_PATH ];
    DWORD                   KeyNameLength;
    TSTR                    ClassName[ MAX_PATH ];
    DWORD                   ClassNameLength;
    DWORD                   NumberOfSubKeys;
    DWORD                   MaxSubKeyLength;
    DWORD                   MaxClassLength;
    DWORD                   NumberOfValues;
    DWORD                   MaxValueNameLength;
    DWORD                   MaxValueDataLength;
    DWORD                   SecurityDescriptorLength;
    FILETIME                LastWriteTime;


    TSTR                    ValueName[ MAX_PATH ];
    DWORD                   ValueNameLength;

    BYTE                    Data[ MAX_DATA_LENGTH ];
    DWORD                   DataLength;

    BYTE                    Data_1[ ]   = VALUE_DATA_1;
    DWORD                   Data_2      = VALUE_DATA_2;

    DWORD                   TitleIndex;
    DWORD                   Type;


    UNREFERENCED_PARAMETER( argc );

    //
    // By default, be verbose and operate on the local machine.
    //

    Quiet       = FALSE;
    MachineName = NULL;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Quiet - no output.
            //

            case 'q':

                Quiet = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            MachineName = *argv;
        }
    }

    //
    // If a machine name was passed on the command line, connect to
    // the Registry on that machine else use the local Registry.
    // In either case construct a string representation of the
    // test's main key (i.e. \\machine\HKEY_USERS\.Default\TestUser1 or
    // HKEY_USERS\.Default\TestUser1.
    //

    if( MachineName ) {

        Error = RegConnectRegistry(
                    MachineName,
                    PREDEFINED_HANDLE,
                    &PredefinedHandle
                    );

        REG_API_SUCCESS( RegConnectRegistry );

        strcpy( NameString, MachineName );
        strcat( NameString, "\\\\" );
        strcat( NameString, PREDEFINED_HANDLE_STRING );

    } else {

        PredefinedHandle = PREDEFINED_HANDLE;
        strcpy( NameString, PREDEFINED_HANDLE_STRING );
    }

    //
    // Open ".Default" key as the root for the remainder of the test.
    //

    Error = RegOpenKeyEx(
                PredefinedHandle,
                ".Default",
                REG_OPTION_RESERVED,
                MAXIMUM_ALLOWED,
                &RootHandle
                );
    REG_API_SUCCESS( RegOpenKeyEx );

    //
    // Predefined handle is no longer needed.
    //

    Error = RegCloseKey(
                PredefinedHandle
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Delete the save / restore file (in case it exists from a previous
    // run of the test) as RegSaveKey requires a new file.
    //

    DeleteFile( SAVE_RESTORE_FILE );

    //
    // Remove any leftover keys from previous runs of this test.
    //

    DeleteTestTree( );

    //
    // Use the Win 3.1 API (which calls the Win32 API) to create a path.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_PATH,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    //
    // Close the key so the delete (DeleteTestTree) will work.
    //

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Remove the path.
    //

    DeleteTestTree( );

    //
    // Create the synchronization event.
    //

    _EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle != NULL );

    _EventHandle1 = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle1 != NULL );

    _EventHandle2 = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle2 != NULL );

    //
    // Create the notify thread.
    //

    NotifyThreadHandle = CreateThread(
                            NULL,
                            0,
                            NotifyThread,
                            NULL,
                            0,
                            &ThreadID
                            );
    ASSERT( NotifyThreadHandle != NULL );

    //
    // Wait for the notify thread to create its event.
    //

    Error = (LONG)WaitForSingleObject( _EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    //
    // Use Win 3.1 compatible APIs to create/close, open/close and delete
    // the key TestUser1.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Wait for the notify thread to create its event.
    //

    Error = (LONG)WaitForSingleObject( _EventHandle1, (DWORD)-1 );
    ASSERT( Error == 0 );

    Error = RegOpenKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegOpenKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegDeleteKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    //
    // Use Win32 APIs to create/close, open/close and create (open) the
    // key TestUser1.
    //

    //
    // Allocate and initialize the SecurityDescriptor.
    //

    SecurityDescriptor = malloc( sizeof( SECURITY_DESCRIPTOR ));
    ASSERT( SecurityDescriptor != NULL );
    ErrorFlag = InitializeSecurityDescriptor(
                    SecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
    ASSERT( ErrorFlag == TRUE );

    SecurityAttributes.nLength              = sizeof( SECURITY_ATTRIBUTES );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle       = FALSE;

    Error = RegCreateKeyEx(
                RootHandle,
                KEY_NAME_1,
                0,
                KEY_NAME_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );


    //
    // Wait for the notify thread to create its event.
    //

    Error = RegOpenKeyEx(
                RootHandle,
                KEY_NAME_1,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &Handle1
                );
    REG_API_SUCCESS( RegOpenKeyEx );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegCreateKeyEx(
                RootHandle,
                KEY_NAME_1,
                0,
                KEY_NAME_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                NULL,
                &Handle1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_OPENED_EXISTING_KEY );

    //
    // Get and set the key's SECURITY_DESCRIPTOR. Setting will trigger
    // a notification.
    //

    SecurityDescriptorLength = 0;

    //
    // Get the SECURITY_DESCRIPTOR's length.
    //

    Error = RegGetKeySecurity(
                Handle1,
                OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION
                | DACL_SECURITY_INFORMATION,
                SecurityDescriptor,
                &SecurityDescriptorLength
                );
    ASSERT( Error == ERROR_INSUFFICIENT_BUFFER );

    SecurityDescriptor = realloc(
                            SecurityDescriptor,
                            SecurityDescriptorLength
                            );
    ASSERT( SecurityDescriptor != NULL );
    ErrorFlag = InitializeSecurityDescriptor(
                    SecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
    ASSERT( ErrorFlag == TRUE );

    Error = RegSetKeySecurity(
                Handle1,
                OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION
                | DACL_SECURITY_INFORMATION,
                SecurityDescriptor
                );
    REG_API_SUCCESS( RegSetKeySecurity );

    Error = (LONG)WaitForSingleObject( _EventHandle2, (DWORD)-1 );
    ASSERT( Error == 0 );

    //
    // Reinitialize after the realloc.
    //

    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

    //
    // Create two sub-keys.
    //

    Error = RegCreateKeyEx(
                Handle1,
                KEY_NAME_1_1,
                0,
                KEY_NAME_1_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1_1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    Error = RegCreateKeyEx(
                Handle1,
                KEY_NAME_1_2,
                0,
                KEY_NAME_1_2_CLASS,
                0,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1_2,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    //
    // Enumerate the two sub-keys using the Win 3.1 and the the Win32
    // enumeration APIs.
    //

    KeyNameLength = MAX_PATH;

    Error = RegEnumKey(
                Handle1,
                0,
                KeyName,
                KeyNameLength
                );
    REG_API_SUCCESS( RegEnumKey );

    ASSERT( Compare( KeyName, KEY_NAME_1_1, KEY_NAME_1_1_LENGTH ));

    KeyNameLength   = MAX_PATH;
    ClassNameLength = MAX_PATH;

    Error = RegEnumKeyEx(
                Handle1,
                1,
                KeyName,
                &KeyNameLength,
                NULL,
                ClassName,
                &ClassNameLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegEnumKeyEx );

    ASSERT( Compare( KeyName, KEY_NAME_1_2, KEY_NAME_1_2_LENGTH ));
    ASSERT( KeyNameLength == KEY_NAME_1_2_LENGTH );
    //ASSERT( TitleIndex == KEY_NAME_1_2_TITLE_INDEX );
    ASSERT( Compare( ClassName, KEY_NAME_1_2_CLASS, KEY_NAME_1_2_CLASS_LENGTH ));
    ASSERT( ClassNameLength == KEY_NAME_1_2_CLASS_LENGTH );

    //
    // If the Quiet command line option wasn't set, display the TestUser1 key.
    //

    if( ! Quiet ) {
        Key = ParseKey( NameString );
        REG_API_SUCCESS( Key != NULL );
        DisplayKeys( Key, TRUE, TRUE, TRUE );
        FreeKey( Key );
    }

    //
    // Close the two sub-keys.
    //

    Error = RegCloseKey(
                Handle1_1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegCloseKey(
                Handle1_2
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegFlushKey(
                Handle1
                );

    REG_API_SUCCESS( RegFlushKey );

    //
    // Save the TestUser1 tree to a file.
    //
#if 0
    Error = RegSaveKey(
                Handle1,
                SAVE_RESTORE_FILE,
                SecurityDescriptor
                );
    REG_API_SUCCESS( RegSaveKey );

    RegCloseKey( Handle1 );

    //
    // Delete the TestUser1 tree.
    //

    DeleteTestTree( );


    //
    //  Load TestUser1 from the file
    //
    Error = RegLoadKey(
                RootHandle,
                KEY_NAME_1,
                SAVE_RESTORE_FILE
                );
    REG_API_SUCCESS( RegLoadKey );

    //
    //  Unload TestUser1
    //
    Error = RegUnLoadKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegUnLoadKey );


    //
    // Restore the TestUser1 tree from a file.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    Error = RegRestoreKey(
                Handle1,
                SAVE_RESTORE_FILE,
                0
                );
    REG_API_SUCCESS( RegRestoreKey );
#endif

    //
    // Delete the two sub-keys.
    //

    Error = RegDeleteKey(
                Handle1,
                KEY_NAME_1_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    Error = RegDeleteKey(
                Handle1,
                KEY_NAME_1_2
                );
    REG_API_SUCCESS( RegDeleteKey );

    //
    // Set a value in the TestUser1 key using the Win 3.1 compatible API.
    //

    Error = RegSetValue(
                RootHandle,
                KEY_NAME_1,
                VALUE_DATA_1_TYPE,
                Data_1,
                VALUE_DATA_1_LENGTH
                );
    REG_API_SUCCESS( RegSetValue );

    //
    // Set a value in the TestUser1 key using the Win32 API.
    //
    Error = RegSetValueEx(
                Handle1,
                VALUE_NAME_2,
                0,
                VALUE_DATA_2_TYPE,
                ( PVOID ) &Data_2,
                VALUE_DATA_2_LENGTH
                );
    REG_API_SUCCESS( RegSetValueEx );

    //
    // Commit the Key to the Registry.
    //

    Error = RegFlushKey(
                Handle1
                );
    REG_API_SUCCESS( RegFlushKey );

    //
    // If the Quiet command line option wasn't set, display the TestUser1 key.
    //

    if( ! Quiet ) {
        Key = ParseKey( NameString );
        REG_API_SUCCESS( Key != NULL );
        DisplayKeys( Key, TRUE, TRUE, TRUE );
        FreeKey( Key );
    }

    //
    // Query a value in the TestUser1 key using the Win 3.1 compatible API.
    //

    DataLength = MAX_DATA_LENGTH;

    Error = RegQueryValue(
                RootHandle,
                KEY_NAME_1,
                Data,
                &DataLength
                );
    REG_API_SUCCESS( RegQueryValue );

    ASSERT( Compare( Data, &Data_1, VALUE_DATA_1_LENGTH ));
    ASSERT( DataLength == VALUE_DATA_1_LENGTH );

    //
    // Query a value in the TestUser1 key using the Win32 API.
    //

    DataLength = MAX_DATA_LENGTH;

    Error = RegQueryValueEx(
                Handle1,
                VALUE_NAME_2,
                NULL,
                &Type,
                Data,
                &DataLength
                );
    REG_API_SUCCESS( RegQueryValueEx );

    //ASSERT( TitleIndex == VALUE_NAME_2_TITLE_INDEX );
    ASSERT( Type == VALUE_DATA_2_TYPE );
    ASSERT(( DWORD ) Data[ 0 ] == Data_2 );
    ASSERT( DataLength == VALUE_DATA_2_LENGTH );

    //
    // Query information about the key.
    //

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                Handle1,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    ASSERT( Compare( ClassName, KEY_NAME_1_CLASS, KEY_NAME_1_CLASS_LENGTH ));
    ASSERT( ClassNameLength == KEY_NAME_1_CLASS_LENGTH );
    //ASSERT( TitleIndex == KEY_NAME_1_TITLE_INDEX );
    ASSERT( NumberOfSubKeys == 0 );

    ASSERT( MaxSubKeyLength == 0 );
    ASSERT( MaxClassLength == 0 );


    ASSERT( NumberOfValues == 2 );

    ASSERT( MaxValueNameLength == VALUE_NAME_2_LENGTH * sizeof(WCHAR) );
    ASSERT( MaxValueDataLength == VALUE_DATA_1_LENGTH * sizeof(WCHAR) );

    //
    // Enumerate the values.
    //

    for( Index = 0; Index < 2; Index++ ) {

        ValueNameLength = MAX_PATH;
        DataLength      = MAX_DATA_LENGTH;

        Error = RegEnumValue(
                    Handle1,
                    Index,
                    ValueName,
                    &ValueNameLength,
                    NULL,
                    &Type,
                    Data,
                    &DataLength
                    );
        REG_API_SUCCESS( RegEnumValue );

        //
        // Check specifics depending on the value being queried.
        //

        switch( Index ) {

        case 0:

            //
            // No name - win 3.1 compatible value.
            //

            ASSERT( ValueNameLength == 0 );
            //ASSERT( TitleIndex == VALUE_NAME_1_TITLE_INDEX );
            ASSERT( Type == VALUE_DATA_1_TYPE );
            ASSERT( Compare( Data, Data_1, VALUE_DATA_1_LENGTH ));
            ASSERT( DataLength == VALUE_DATA_1_LENGTH );
            break;

        case 1:

            ASSERT( Compare( ValueName, VALUE_NAME_2, VALUE_NAME_2_LENGTH ));
            ASSERT( ValueNameLength == VALUE_NAME_2_LENGTH );
            //ASSERT( TitleIndex == VALUE_NAME_2_TITLE_INDEX );
            ASSERT( Type == VALUE_DATA_2_TYPE );
            ASSERT(( DWORD ) Data[ 0 ] == Data_2 );
            ASSERT( DataLength == VALUE_DATA_2_LENGTH );
            break;

        default:

            ASSERT_MESSAGE( FALSE, "Valid value enumeration index - " );
        }
    }

    //
    // All done! Get rid of the key and close it.
    //

    Error = RegDeleteKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\crdel\crdel.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Crdel.c

Abstract:

Author:

    David J. Gilman (davegi) 20-Dec-1991

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

//
// KEY_ELEMENT is used to maintain a list of KEYs.
//

typedef struct _KEY_ELEMENT
    KEY_ELEMENT,
    *PKEY_ELEMENT;

struct _KEY_ELEMENT {
    PKEY            Key;
    PKEY_ELEMENT    NextKeyElement;
    };

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: crdel [-?] [-q] key...\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?   - display this message.\n"                                  \
      "    -q   - quiet mode\n"                                             \
      "    key  - name(s) of the key(s) to dump.\n"                         \
    "\n  A key is formed by specifying one of the predefined handles:\n"    \
    "\n         - HKEY_LOCAL_MACHINE\n"                                     \
      "         - HKEY_CLASSES_ROOT\n"                                      \
      "         - HKEY_CURRENT_USER\n"                                      \
      "         - HKEY_USERS\n"                                             \
    "\n  followed by a sub-key name.\n"                                     \
    "\n  An environment variable can be used as shorthand for the\n"        \
    "  predefined handles.  For example,\n"                                 \
    "\n    crdel HKEY_USERS\\davegi\n"                                      \
    "\n  is equivalent to\n"                                                \
    "\n    set HKEY_USERS=hu\n"                                             \
      "    crdel hu\\davegi\n";


PSTR    InvalidKeyMessage =

    "Invalid key - %s\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    DeletingTreeMessage =

    "Deleteing tree %s\n";

VOID
DeleteTree(
    IN HKEY KeyHandle
    )

{
    LONG        Error;
    DWORD       Index;
    HKEY        ChildHandle;


    TSTR        KeyName[ MAX_PATH ];
    DWORD       KeyNameLength;
    TSTR        ClassName[ MAX_PATH ];
    DWORD       ClassNameLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                KeyHandle,
                ClassName,
                &ClassNameLength,
                &TitleIndex,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        KeyNameLength = MAX_PATH;

        Error = RegEnumKey(
                    KeyHandle,
                    0,
                    KeyName,
                    KeyNameLength
                    );
        REG_API_SUCCESS( RegEnumKey );

        Error = RegOpenKeyEx(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    KEY_ALL_ACCESS,
                    &ChildHandle
                    );
        REG_API_SUCCESS( RegOpenKey );

        DeleteTree( ChildHandle );

        Error = RegCloseKey(
                    ChildHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}
VOID
DeleteKey(
    IN PKEY     Key
    )

{
    LONG    Error;

    ASSERT( Key != NULL );
    ASSERT( Key->KeyHandle != NULL );

    DeleteTree( Key->KeyHandle );

    Error = RegDeleteKey(
                Key->Parent->KeyHandle,
                Key->SubKeyName
                );
    REG_API_SUCCESS( RegDeleteKey );
}

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    BOOL            Quiet;
    PKEY            ParsedKey;
    PKEY_ELEMENT    ParsedKeyElement;
    PKEY_ELEMENT    ParsedKeysHead;
    PKEY_ELEMENT    ParsedKeysTail;
    KEY_ELEMENT     Dummy = { NULL, NULL };

    //
    // If CrDel is invoked without any command line options, display
    // the usage message.
    //

    if( argc < 2 ) {

        DisplayMessage( TRUE, UsageMessage );
    }

    //
    // By default the user is prompted.
    //

    Quiet   = FALSE;

    //
    // Use a Dummy KEY structure to simplify the list management.
    // Initialize the head and tail pointers to point to the Dummy.
    //

    ParsedKeysHead = &Dummy;
    ParsedKeysTail = &Dummy;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Do not prompt user for delete.
            //

            case 'q':

                Quiet = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            //
            // The command line argument was not a switch so attempt to parse
            // it into a predefined handle and a sub key.
            //

            ParsedKey = ParseKey( *argv );

            if( ParsedKey ) {

                //
                // If the command line argument was succesfully parsed,
                // allocate and initialize a KEY_ELEMENT, add it to the
                // list and update the tail pointer.
                //

                ParsedKeyElement = ( PKEY_ELEMENT ) malloc(
                                    sizeof( KEY_ELEMENT )
                                    );
                ASSERT( ParsedKeyElement );

                ParsedKeyElement->Key               = ParsedKey;
                ParsedKeyElement->NextKeyElement    = NULL;

                ParsedKeysTail->NextKeyElement = ParsedKeyElement;
                ParsedKeysTail = ParsedKeyElement;


            } else {

                //
                // The command line argument was not succesfully parsed,
                // so display an invalid key message and continue.
                //

                DisplayMessage( FALSE, InvalidKeyMessage, *argv );
            }
        }
    }

    //
    // Command line parsing is complete. Delete the requested keys
    // skipping the Dummy KEY_ELEMENT structure.
    //

    while( ParsedKeysHead = ParsedKeysHead->NextKeyElement ) {

        if( ! Quiet ) {

            DisplayMessage(
                FALSE,
                DeletingTreeMessage,
                ParsedKeysHead->Key->SubKeyFullName
                );
        }

        DeleteKey( ParsedKeysHead->Key );

        //
        // Once the KEY structure's Key is deleted both the KEY and
        // KEY_ELEMENT can be freed.
        //

        FreeKey( ParsedKeysHead->Key );
        free( ParsedKeysHead );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\apitest\tshutdwn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Tshutwnd.c

Abstract:

    This module contains the function test for the System Shutdown APIs

Author:

    Dave Chalmers (davidc) 30-Apr-1992

Environment:

    Windows, Crt - User Mode

Notes:

    Since this is a test program it relies on assertions for error checking
    rather than a more robust mechanism.

--*/

#define MAX_STRING_LENGTH   80

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#ifdef UNICODE
#error This module was designed to be built as ansi only
#endif


VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

{
    LPTSTR  MachineName = NULL;
    WCHAR   UnicodeMachineName[MAX_STRING_LENGTH];
    PWCHAR  pUnicodeMachineName = NULL;
    BOOL    Result;
    BOOL    Failed = FALSE;
    DWORD   Error;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        MachineName = *argv;
    }

    //
    // Get the machine name in unicode
    //

    if (MachineName != NULL) {

        MultiByteToWideChar(0,
                            MachineName, -1,
                            UnicodeMachineName, sizeof(UnicodeMachineName),
                            MB_PRECOMPOSED);

        pUnicodeMachineName = UnicodeMachineName;

        printf("Machine Name(a) = <%s>\n", MachineName);
        printf("Machine Name(u) = <%ws>\n", UnicodeMachineName);

    }


    //
    // Start the test
    //

    printf("Running test again machine <%s>\n\n", MachineName);




    //
    // InitiateSystemShutdown (Ansi)
    //



    printf("Test InitiateSystemShutdown (Ansi)...");


    Result = InitiateSystemShutdownA(
                    MachineName,
                    NULL,           // No message
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }


    Result = InitiateSystemShutdownA(
                    MachineName,
                    "A shutdown message",
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");





    //
    // InitiateSystemShutdown (Unicode)
    //



    printf("Test InitiateSystemShutdown (Unicode)...");


    Result = InitiateSystemShutdownW(
                    pUnicodeMachineName,
                    NULL,           // No message
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }


    Result = InitiateSystemShutdownW(
                    pUnicodeMachineName,
                    L"A shutdown message",
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");





    //
    // AbortSystemShutdown (Ansi)
    //



    printf("Test AbortSystemShutdown (Ansi)...");


    Result = AbortSystemShutdownA(
                    MachineName
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");


    //
    // AbortSystemShutdown (Unicode)
    //



    printf("Test AbortSystemShutdown (Unicode)...");


    Result = AbortSystemShutdownW(
                    pUnicodeMachineName
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");

    return;


    UNREFERENCED_PARAMETER(argc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\inc\crtools.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Crtools.h

Abstract:

    This module is the master header file for the Configuration Registry
    Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <windows.h>
#include <winreg.h>


//
// Additional type to declare string arrays.
//

//
// Assertion/debug macros/functions.
//


#ifdef UNICODE

#define NUL_SIZE    ( 2 )
typedef WCHAR       TSTR;

#else

#define NUL_SIZE    ( 1 )
typedef char        TSTR;

#endif // UNICODE

#if DBG

VOID
CrAssert(
    IN PSTR FailedAssertion,
    IN PSTR FileName,
    IN DWORD LineNumber,
    IN PSTR Message OPTIONAL
    );

#define ASSERT( exp )                                                   \
    if( !( exp ))                                                       \
        CrAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERT_MESSAGE( exp, msg )                                      \
    if( !( exp ))                                                       \
        CrAssert( #exp, __FILE__, __LINE__, msg )

#define ASSERT_IS_KEY( Key )                                            \
    ASSERT( ARGUMENT_PRESENT( Key ));                                   \
    ASSERT( Key->Signature == KEY_SIGNATURE );

#else

#define ASSERT( exp )

#define ASSERT_MESSAGE( msg, exp )

#define ASSERT_IS_KEY( Key )

#endif // DBG


//
// Macro to check for a switch character.
//

#define isswitch( s )                                                   \
    ((( s ) == '-' ) || (( s ) == '/' ))
//
// Macro to check if an argument is present (i.e. non-NULL).
//

#define ARGUMENT_PRESENT( arg )                                         \
    ((( PVOID ) arg ) != (( PVOID ) NULL ))

//
//  Compare two blocks of memory for equality.
//
//  BOOL
//  Compare(
//      IN PVOID Block1,
//      IN PVOID Block2,
//      IN DWORD NumberOfBytes
//      );
//

#define Compare( s1, s2, c )                                            \
    ( memcmp(( PVOID )( s1 ), ( PVOID )( s2 ), ( size_t )( c )) == 0 )

//
// Compute the length (in bytes) of a Unicode string w/o the trailing NUL.
//

#define LENGTH( str )   ( sizeof( str ) -  NUL_SIZE )

//
// Check the success of a Win32 Registry API.
//

#define REG_API_SUCCESS( api )                                          \
    ASSERT_MESSAGE( Error == ERROR_SUCCESS, #api )

//
//
// A KEY structure is used to hold information about a Registry Key.
//

typedef struct _KEY
    KEY,
    *PKEY;

struct _KEY {
    PKEY        Parent;
    HKEY        KeyHandle;
    PSTR        SubKeyName;
    PSTR        SubKeyFullName;
    PSTR        ClassName;
    DWORD       ClassLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyNameLength;
    DWORD       MaxSubKeyClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

#if DBG

    DWORD       Signature;

#endif

};

#define FILE_TIME_STRING_LENGTH     ( 25 * sizeof( TCHAR ))
#define KEY_SIGNATURE               ( 0xABBABAAB )

#define HKEY_CLASSES_ROOT_STRING    "HKEY_CLASSES_ROOT"
#define HKEY_CURRENT_USER_STRING    "HKEY_CURRENT_USER"
#define HKEY_LOCAL_MACHINE_STRING   "HKEY_LOCAL_MACHINE"
#define HKEY_USERS_STRING           "HKEY_USERS"

extern KEY  KeyClassesRoot;
extern KEY  KeyCurrentUser;
extern KEY  KeyLocalMachine;
extern KEY  KeyUsers;


PKEY
AllocateKey(
    IN PSTR MachineName,
    IN PKEY Parent,
    IN PSTR SubKeyName
    );

VOID
DisplayData(
    IN PBYTE ValueData,
    IN DWORD ValueDataLength
    );

VOID
DisplayKey(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data
    );

VOID
DisplayKeys(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data,
    IN BOOL Recurse
    );

VOID
DisplayKeyInformation(
    IN PKEY Key
    );

VOID
DisplayMessage(
    IN BOOL Terminate,
    IN PSTR Format,
    IN ...
    );

VOID
DisplayValues(
    IN PKEY Key,
    IN BOOL Data
    );

PSTR
FormatFileTime(
    IN PFILETIME FileTime OPTIONAL,
    IN PSTR Buffer OPTIONAL
    );

VOID
FreeKey(
    IN PKEY Key
    );

PKEY
ParseKey(
    IN PSTR SubKeyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\assert.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Assert.c

Abstract:

    This module contains the CruAssert function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <conio.h>
#include <stdio.h>

#include "crtools.h"

VOID
CrAssert(
    IN PSTR FailedAssertion,
    IN PSTR FileName,
    IN DWORD LineNumber,
    IN PSTR Message OPTIONAL
    )

/*++

Routine Description:

    Display (on stderr) a string representing the failed assertion. Then
    prompt the user for the appropriate action. An optional message can
    also be displayed.

Arguments:

    FailedAssertion - Supplies the string representing the failed
        assertion.

    FileName - Supplies the string containing the file name of the failed
        assertion.

    LineNumber - Supplies the line number within the file that contains
        the failed assertion.

    Message - Supplies an optional message to be displayed along with the
        failed assertion.

Return Value:

    None.

--*/


{
    int Response;

    while( 1 ) {

        fprintf( stderr,
            "\n*** Assertion failed: %s %s\n***"
            "   Source File: %s, line %ld\n\n",
              Message ? Message : "",
              FailedAssertion,
              FileName,
              LineNumber
            );

        fprintf( stderr,
            "Break, Ignore, Exit Process or Exit Thread (bipt)? "
            );

        Response = getche( );
        fprintf( stderr, "\n\n" );

        switch( Response ) {

            case 'B':
            case 'b':
                DebugBreak( );
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                ExitProcess( -1 );
                break;

            case 'T':
            case 't':
                ExitThread( -1 );
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispdata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispdata.c

Abstract:

    This module contains the DisplayData function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdio.h>

#include "crtools.h"

VOID
DisplayData(
    IN PBYTE ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Display (on stdout) the supplied data in hex and ascii formats, in
    16 byte chunks.

Arguments:

    ValueData - Supplies a pointer to the data to display.

    ValueDataLength - Supplies the number of bytes of data to display.

Return Value:

    None.

--*/

{
    DWORD       DataIndex;
    DWORD       DataIndex2;
    WORD        SeperatorChars;

    ASSERT( ARGUMENT_PRESENT( ValueData ));

    //
    // DataIndex2 tracks multiples of 16.
    //

    DataIndex2 = 0;

    //
    // Display label.
    //

    printf( "Data:\n\n" );

    //
    // Display rows of 16 bytes of data.
    //

    for(
        DataIndex = 0;
        DataIndex < ( ValueDataLength >> 4 );
        DataIndex++,
        DataIndex2 = DataIndex << 4 ) {

        printf( "%08x   "
                "%02x %02x %02x %02x %02x %02x %02x %02x - "
                "%02x %02x %02x %02x %02x %02x %02x %02x  "
                "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                DataIndex2,
                ValueData[ DataIndex2 + 0  ],
                ValueData[ DataIndex2 + 1  ],
                ValueData[ DataIndex2 + 2  ],
                ValueData[ DataIndex2 + 3  ],
                ValueData[ DataIndex2 + 4  ],
                ValueData[ DataIndex2 + 5  ],
                ValueData[ DataIndex2 + 6  ],
                ValueData[ DataIndex2 + 7  ],
                ValueData[ DataIndex2 + 8  ],
                ValueData[ DataIndex2 + 9  ],
                ValueData[ DataIndex2 + 10 ],
                ValueData[ DataIndex2 + 11 ],
                ValueData[ DataIndex2 + 12 ],
                ValueData[ DataIndex2 + 13 ],
                ValueData[ DataIndex2 + 14 ],
                ValueData[ DataIndex2 + 15 ],
                isprint( ValueData[ DataIndex2 + 0  ] )
                    ? ValueData[ DataIndex2 + 0  ]  : '.',
                isprint( ValueData[ DataIndex2 + 1  ] )
                    ? ValueData[ DataIndex2 + 1  ]  : '.',
                isprint( ValueData[ DataIndex2 + 2  ] )
                    ? ValueData[ DataIndex2 + 2  ]  : '.',
                isprint( ValueData[ DataIndex2 + 3  ] )
                    ? ValueData[ DataIndex2 + 3  ]  : '.',
                isprint( ValueData[ DataIndex2 + 4  ] )
                    ? ValueData[ DataIndex2 + 4  ]  : '.',
                isprint( ValueData[ DataIndex2 + 5  ] )
                    ? ValueData[ DataIndex2 + 5  ]  : '.',
                isprint( ValueData[ DataIndex2 + 6  ] )
                    ? ValueData[ DataIndex2 + 6  ]  : '.',
                isprint( ValueData[ DataIndex2 + 7  ] )
                    ? ValueData[ DataIndex2 + 7  ]  : '.',
                isprint( ValueData[ DataIndex2 + 8  ] )
                    ? ValueData[ DataIndex2 + 8  ]  : '.',
                isprint( ValueData[ DataIndex2 + 9  ] )
                    ? ValueData[ DataIndex2 + 9  ]  : '.',
                isprint( ValueData[ DataIndex2 + 10 ] )
                    ? ValueData[ DataIndex2 + 10 ]  : '.',
                isprint( ValueData[ DataIndex2 + 11 ] )
                    ? ValueData[ DataIndex2 + 11 ]  : '.',
                isprint( ValueData[ DataIndex2 + 12 ] )
                    ? ValueData[ DataIndex2 + 12 ]  : '.',
                isprint( ValueData[ DataIndex2 + 13 ] )
                    ? ValueData[ DataIndex2 + 13 ]  : '.',
                isprint( ValueData[ DataIndex2 + 14 ] )
                    ? ValueData[ DataIndex2 + 14 ]  : '.',
                isprint( ValueData[ DataIndex2 + 15 ] )
                    ? ValueData[ DataIndex2 + 15 ]  : '.'
                );
    }

    //
    // If the ValueDataLength is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( ValueDataLength % 16 != 0 ) {

        //
        // No seperator characters displayed so far.
        //

        SeperatorChars = 0;

        printf( "%08x   ", DataIndex << 4 );

        //
        // Display the remaining data, one byte at a time in hex.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < ValueDataLength;
            DataIndex++ ) {

            printf( "%02x ", ValueData[ DataIndex ] );

            //
            // If eight data values have been displayed, print
            // the seperator.
            //

            if( DataIndex % 8 == 7 ) {

                printf( "- " );

                //
                // Remember that two seperator characters were
                // displayed.
                //

                SeperatorChars = 2;
            }
        }

        //
        // Fill with blanks to the printable characters position.
        // That is position 63 less 8 spaces for the 'address',
        // 3 blanks, 3 spaces for each value displayed, possibly
        // two for the seperator plus two blanks at the end.
        //

        printf( "%*c",
                64
                - ( 8 + 3
                + (( DataIndex % 16 ) * 3 )
                + SeperatorChars
                + 2 ), ' ' );

        //
        // Display the remaining data, one byte at a time as
        // printable characters.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < ValueDataLength;
            DataIndex++ ) {

            printf( "%c",
                isprint( ValueData[ DataIndex ] )
                    ? ValueData[ DataIndex ] : '.'
                );

        }
        printf( "\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkey.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

Notes:

    Following is a sample display of a key:


----------------------------------

Key Name:        blech
Class Name:      foobar
Title Index:     12345678
Last Write Time: Wed 08-Jan-1992 11:19:43

Value 1
  Name:          bar
  Title Index:   12345678
  Type:          Double Word (2)
  Data:

00000000   42 55 49 4c 44 3a 20 43 - 6f 6d 70 69 6c 69 6e 67  BUILD: Compiling
00000010   20 64 3a 5c 6e 74 5c 70 - 72 69 76 61 74 65 5c 77   d:\nt\private\w
00000020   69 62 0a 0a 53 74 6f 70 - 2e 20 0a                 ib..Stop. .

Value 2
  Name:          foo
  Title Index:   12345678
  Type:          String (1)
  Data:

00000000   42 55 49 4c 44 3a 20 43 - 6f 6d 70 69 6c 69 6e 67  BUILD: Compiling
00000010   20 64 3a 5c 6e 74 5c 70 - 72 69 76 61 74 65 5c 77   d:\nt\private\w
00000020   69 62 0a 0a 53 74 6f 70 - 2e 20 0a                 ib..Stop. .

----------------------------------

    The first block ("Key Name:...11:19:43") is displayed by DisplayKey
    (dispkey.c).  The second block ("Value 1...Word (2)") is displayed by
    DisplayValues (disval.c) and the third block ("00000000...Stop. .")
    is displayed by DisplayData (dispdata.c).

--*/

#include <stdio.h>

#include "crtools.h"

VOID
DisplayKey(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data
    )

/*++

Routine Description:

    Display (on stdout) information about a Key and optionally about its
    values and data.

Arguments:

    Key - Supplies a pointer to a KEY structure which contains the
        HKEY and sub key name to display.

    Values - Supplies a flag which if TRUE causes all of the Key's values
        to be displayed.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

Return Value:

    None.

--*/

{
    ASSERT( ARGUMENT_PRESENT( Key ));

    DisplayKeyInformation( Key );

    if( Values ) {

        DisplayValues( Key, Data );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\allockey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Allockey.c

Abstract:

    This module contains the AllocateKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>

#include "crtools.h"

PKEY
AllocateKey(
    IN PSTR MachineName,
    IN PKEY Parent,
    IN PSTR SubKeyName
    )


/*++

Routine Description:

    Allocates memory for a KEY structure and initializes it with the
    supplied parent PKEY and a copy of the sub key name.

Arguments:

    Parent - Supplies a PKEY which is the parent of the new Key.

    SubKeyName - Supplies a pointer to a string which is the name of this
        sub key. If the pointer is NULL then Parent refers to a predefined
        key.

    MachineName - Supplies an optional machine name whose Registry is to
        be accessed.

Return Value:

    PKEY - Returns a pointer to the newly allocated and initialized
        sub-key.

--*/

{
    LONG    Error;
    PKEY    Key;
    HKEY    Handle;

    ASSERT( ARGUMENT_PRESENT( Parent ));

    //
    // If a machine name was supplied, connect to that machine and replace
    // the predefined handle with the remote handle.
    //

    if( ARGUMENT_PRESENT( MachineName )) {

        Error = RegConnectRegistry(
                    MachineName,
                    Parent->KeyHandle,
                    &Parent->KeyHandle
                    );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "RegConnectRegistry - " );
            return FALSE;
        }
    }

    //
    // Check for a NULL sub key name and a parent that is a predefined key.
    //

    if( SubKeyName == NULL ) {
#if 0
    if((( SubKeyName == NULL )
        && (( Parent->KeyHandle == HKEY_CLASSES_ROOT )
        ||  ( Parent->KeyHandle == HKEY_CURRENT_USER )
        ||  ( Parent->KeyHandle == HKEY_LOCAL_MACHINE )
        ||  ( Parent->KeyHandle == HKEY_USERS )))) {
#endif
        //
        // There is no sub-key so the handle to open and the KEY object
        // to return is the parent.
        //

        Handle = Parent->KeyHandle;
        Key = Parent;

    } else {


        //
        // Allocate space for the new KEY.
        //

        Key = ( PKEY ) malloc( sizeof( KEY ));

        if( Key == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of Key - " );
            return NULL;
        }

        //
        // Allocate space for the new KEY's full name.
        //

        Key->SubKeyFullName = ( PSTR ) malloc(
                                    strlen( SubKeyName ) + 1
                                    + strlen( Parent->SubKeyFullName )
                                    + sizeof(( TCHAR ) '\\' )
                                    );

        if( Key->SubKeyFullName == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of SubKeyFullName - " );
            return NULL;
        }

        //
        // Capture the full name.
        //

        strcpy( Key->SubKeyFullName, Parent->SubKeyFullName );
        strcat( Key->SubKeyFullName, "\\" );
        strcat( Key->SubKeyFullName, SubKeyName );

        //
        // Allocate space for the new KEY's name.
        //

        Key->SubKeyName = ( PSTR ) malloc( strlen( SubKeyName ) + 1 );

        if( Key->SubKeyName == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of SubKeyName - " );
            return NULL;
        }

        //
        // Capture the name.
        //

        strcpy( Key->SubKeyName, SubKeyName );

        //
        // Initialize the KEY's parent.
        //

        Key->Parent = Parent;

        //
        // Initialize the KEY's signature if under DBG control.
        //

#if DBG

        Key->Signature = KEY_SIGNATURE;

#endif // DBG

        //
        // Attempt to open the sub key.
        //

        Error = RegOpenKeyEx(
            Parent->KeyHandle,
            Key->SubKeyName,
            0,
            KEY_READ,
            &Key->KeyHandle
            );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "RegOpenKey - " );
            return FALSE;
        }

        //
        // Record the handle so that the following query works for either
        // the parent or the child.
        //

        Handle = Key->KeyHandle;
    }

    //
    // At this point Key/Handle either both refer to the Parent or to the
    // newly created subkey.
    //

    ASSERT( Handle == Key->KeyHandle );

    //
    // Query how many bytes are need for the class string. The expected
    // result is to get an ERROR_INVALID_PARAMETER error returned with
    // the ClassLength parameter filled in.
    //

    Key->ClassLength = 0;

    Error = RegQueryInfoKey(
        Handle,
        Key->ClassName,
        &Key->ClassLength,
        NULL,
        &Key->NumberOfSubKeys,
        &Key->MaxSubKeyNameLength,
        &Key->MaxSubKeyClassLength,
        &Key->NumberOfValues,
        &Key->MaxValueNameLength,
        &Key->MaxValueDataLength,
        &Key->SecurityDescriptorLength,
        &Key->LastWriteTime
        );

    //
    // If there is no class string set it to NULL.
    //

    if( Key->ClassLength == 0 ) {

        Key->ClassName = NULL;

    } else {

        //
        // Allocate space for the class string and get all of the info
        // for this key.
        //

        Key->ClassLength++;
        Key->ClassName = ( PSTR ) malloc( Key->ClassLength );

        if( Key->ClassName == NULL ) {

            ASSERT_MESSAGE( FALSE, "malloc of ClassName - " );
            return FALSE;
        }

        Error = RegQueryInfoKey(
            Key->KeyHandle,
            Key->ClassName,
            &Key->ClassLength,
            NULL,
            &Key->NumberOfSubKeys,
            &Key->MaxSubKeyNameLength,
            &Key->MaxSubKeyClassLength,
            &Key->NumberOfValues,
            &Key->MaxValueNameLength,
            &Key->MaxValueDataLength,
            &Key->SecurityDescriptorLength,
            &Key->LastWriteTime
            );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "Could not query all info the sub key" );
            return FALSE;
        }
    }

    return Key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\crdump\crdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Crdump.c

Abstract:

Author:

    David J. Gilman (davegi) 20-Dec-1991

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

//
// KEY_ELEMENT is used to maintain a list of KEYs.
//

typedef struct _KEY_ELEMENT
    KEY_ELEMENT,
    *PKEY_ELEMENT;

struct _KEY_ELEMENT {
    PKEY            Key;
    PKEY_ELEMENT    NextKeyElement;
    };

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: crdump [-?] [-d] [-v] [-r] key...\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?   - display this message.\n"                                  \
      "    -d   - dump all data (implies -v).\n"                            \
      "    -v   - dump all values.\n"                                       \
      "    -r   - recurse through sub keys.\n"                              \
      "    key  - name(s) of the key(s) to dump.\n"                         \
    "\n  A key is formed by specifying one of the predefined handles:\n"    \
    "\n         - HKEY_LOCAL_MACHINE\n"                                     \
      "         - HKEY_CLASSES_ROOT\n"                                      \
      "         - HKEY_CURRENT_USER\n"                                      \
      "         - HKEY_USERS\n"                                             \
    "\n  followed by a sub-key name.\n"                                     \
    "\n  An environment variable can be used as shorthand for the\n"        \
    "  predefined handles.  For example,\n"                                 \
    "\n    crdump HKEY_USERS\\davegi\n"                                     \
    "\n  is equivalent to\n"                                                \
    "\n    set HKEY_USERS=hu\n"                                             \
      "    crdump hu\\davegi\n";


PSTR    InvalidKeyMessage =

    "Invalid key - %s\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    DisplayKeyFailMessage =

    "Could not display key %s\n";

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    BOOL            Values;
    BOOL            Data;
    BOOL            Recurse;
    PKEY            ParsedKey;
    PKEY_ELEMENT    ParsedKeyElement;
    PKEY_ELEMENT    ParsedKeysHead;
    PKEY_ELEMENT    ParsedKeysTail;
    KEY_ELEMENT     Dummy = { NULL, NULL };

    //
    // If CrDump is invoked without any command line options, display
    // the usage message.
    //

    if( argc < 2 ) {

        DisplayMessage( TRUE, UsageMessage );
    }

    //
    // By default, no sub keys, values or data are displayed.
    //

    Recurse = FALSE;
    Values  = FALSE;
    Data    = FALSE;

    //
    // Use a Dummy KEY structure to simplify the list management.
    // Initialize the head and tail pointers to point to the Dummy.
    //

    ParsedKeysHead = &Dummy;
    ParsedKeysTail = &Dummy;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Display data - implies display values.

            case 'd':

                Values  = TRUE;
                Data    = TRUE;
                break;

            //
            // Display sub keys.
            //

            case 'r':

                Recurse = TRUE;
                break;

            //
            // Display values.
            //

            case 'v':

                Values = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            //
            // The command line argument was not a switch so attempt to parse
            // it into a predefined handle and a sub key.
            //

            ParsedKey = ParseKey( *argv );

            if( ParsedKey ) {

                //
                // If the command line argument was succesfully parsed,
                // allocate and initialize a KEY_ELEMENT, add it to the
                // list and update the tail pointer.
                //

                ParsedKeyElement = ( PKEY_ELEMENT ) malloc(
                                    sizeof( KEY_ELEMENT )
                                    );
                ASSERT( ParsedKeyElement );

                ParsedKeyElement->Key               = ParsedKey;
                ParsedKeyElement->NextKeyElement    = NULL;

                ParsedKeysTail->NextKeyElement = ParsedKeyElement;
                ParsedKeysTail = ParsedKeyElement;


            } else {

                //
                // The command line argument was not succesfully parsed,
                // so display an invalid key message and continue.
                //

                DisplayMessage( FALSE, InvalidKeyMessage, *argv );
            }
        }
    }

    //
    // Command line parsing is complete. Display the requested keys
    // skipping the Dummy KEY_ELEMENT structure.
    //

    while( ParsedKeysHead = ParsedKeysHead->NextKeyElement ) {

        DisplayKeys( ParsedKeysHead->Key, Values, Data, Recurse );

        //
        // Once the KEY structure's Key is displayed both the KEY and
        // KEY_ELEMENT can be freed.
        //

        FreeKey( ParsedKeysHead->Key );
        free( ParsedKeysHead );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispkeyi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkeyi.c

Abstract:

    This module contains the DisplayKeyInformation function which is part
    of the Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>
#include <stdlib.h>

#include "crtools.h"

VOID
DisplayKeyInformation(
    IN PKEY Key
    )

/*++

Routine Description:

    Display (on stdout) meta information about a Key.

Arguments:

    Key - Supplies a pointer to a KEY for which information is to be
        displayed.
Return Value:

    None.

--*/

{
    ASSERT( ARGUMENT_PRESENT( Key ));

    printf( "\n"
            "Key Name:          %s\n"
            "Class Name:        %s\n"
            // "Title Index:       %ld\n"
            "Last Write Time:   %s\n",
            Key->SubKeyFullName,
            ( Key->ClassName == NULL ) ? "<NONE>" : Key->ClassName,
            // Key->TitleIndex,
            FormatFileTime( &Key->LastWriteTime, NULL )
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispkeys.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkeys.c

Abstract:

    This module contains the DisplayKeys function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 08-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>
#include "crtools.h"

VOID
DisplayKeys(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data,
    IN BOOL Recurse
    )

/*++

Routine Description:

    Display (on stdout) information about a Key, and optionally about
    its/there values, data and decendants.  Decendants are displayed using
    a deapth first traversal.

Arguments:

    Key - Supplies a pointer to a KEY structure which contains the
        HKEY and sub key name to display.

    Values - Supplies a flag which if TRUE causes all of the Key's values
        to be displayed.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

    Recurse - Supplies a flag which if TRUE causes all of the Key's sub-keys
        to be displayed.

Return Value:

    None.

--*/

{
    LONG        Error;
    PKEY        ChildKey;
    PSTR        ChildSubKeyName;
    DWORD       ChildSubKeyNameLength;
    DWORD       NumberOfSubKeys;

    ASSERT( ARGUMENT_PRESENT( Key ));

    //
    // Display the key.
    //

    DisplayKey( Key, Values, Data );

    //
    // If requested display all of the Key's children, their children etc.
    //

    if( Recurse ) {

        //
        // Allocate space for the largest sub-key name.
        //

        ChildSubKeyName = ( PSTR ) malloc( Key->MaxSubKeyNameLength + 1 );
        if( ! ChildSubKeyName ) {

            ASSERT_MESSAGE( FALSE, "ChildSubKeyName allocated - " );
            return;
        }

        //
        // For each immediate child key, retrieve its name, create a KEY
        // object and recursively call DisplayKeys.
        //

        for(
            NumberOfSubKeys = 0;
            NumberOfSubKeys < Key->NumberOfSubKeys;
            NumberOfSubKeys++ ) {

            ChildSubKeyNameLength = Key->MaxSubKeyNameLength + 1;

            //
            // Retrieve the child's name.
            //

            Error = RegEnumKey(
                        Key->KeyHandle,
                        NumberOfSubKeys,
                        ChildSubKeyName,
                        ChildSubKeyNameLength
                        );

            if( Error != ERROR_SUCCESS ) {

                ASSERT_MESSAGE( FALSE, "RegEnumKey suceeded - " );
                return;
            }

            //
            // Allocate a KEY object.
            //

            ChildKey = AllocateKey( NULL, Key, ChildSubKeyName );

            if( ! ChildKey ) {

                ASSERT_MESSAGE( FALSE, "AllocateKey suceeded - " );
                return;
            }

            DisplayKeys( ChildKey, Values, Data, Recurse );
            FreeKey( ChildKey );
        }

        //
        // Release the child name buffer.
        //

        free( ChildSubKeyName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Dispmsg.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 08-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

VOID
DisplayMessage(
    IN BOOL Terminate,
    IN PSTR Format,
    IN ...
    )

/*++

Routine Description:

    Displays a message on the standard error stream and optionally
    terminates the program.

Arguments:

    Terminate - Supplies a flag which if TRUE causes DisplayMessage to
        terminate the program.

    Format - Supplies a printf style format string.

    ... - Supplies optional arguments, one for each format specifier in
        Format.

Return Value:

    None.

--*/

{
    va_list marker;

    ASSERT( ARGUMENT_PRESENT( Format ));

    va_start( marker, Format );

    vfprintf( stderr, Format, marker );

    va_end( marker );

    if( Terminate ) {
        exit( -1 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\freekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Freekey.c

Abstract:

    This module contains the FreeKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>

#include "crtools.h"

VOID
FreeKey(
    IN PKEY Key
    )

/*++

Routine Description:

    Frees all memory associated with the supplied Key.

Arguments:

    Key - Supplies a pointer to the KEY structure to be freed.

Return Value:

    None.

--*/

{
    LONG    Error;

    ASSERT_IS_KEY( Key );

    //
    // Don't free/closee predefined handles.
    //

    if(
            ( Key->KeyHandle == HKEY_CLASSES_ROOT )
        ||  ( Key->KeyHandle == HKEY_CURRENT_USER )
        ||  ( Key->KeyHandle == HKEY_LOCAL_MACHINE )
        ||  ( Key->KeyHandle == HKEY_USERS )) {

        return;

    }

    Error = RegCloseKey( Key->KeyHandle );
    ASSERT( Error == ERROR_SUCCESS );

    free( Key->ClassName );
    free( Key->SubKeyName );
    free( Key->SubKeyFullName );
    free( Key );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\pdkeys.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdkeys.c

Abstract:

    This module contains the KEY definitions for the the predefined Key
    handles.  It is part of the Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 09-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include "crtools.h"

KEY  KeyClassesRoot     =   {
                            NULL,
                            HKEY_CLASSES_ROOT,
                            HKEY_CLASSES_ROOT_STRING,
                            HKEY_CLASSES_ROOT_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };



KEY  KeyCurrentUser     =   {
                            NULL,
                            HKEY_CURRENT_USER,
                            HKEY_CURRENT_USER_STRING,
                            HKEY_CURRENT_USER_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };

KEY  KeyLocalMachine    =   {
                            NULL,
                            HKEY_LOCAL_MACHINE,
                            HKEY_LOCAL_MACHINE_STRING,
                            HKEY_LOCAL_MACHINE_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };

KEY  KeyUsers           =   {
                            NULL,
                            HKEY_USERS,
                            HKEY_USERS_STRING,
                            HKEY_USERS_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\fmtft.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Fmtft.c

Abstract:

    This module contains the FormatFileTime function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>

#include "crtools.h"

PSTR
FormatFileTime(
    IN PFILETIME FileTime OPTIONAL,
    IN PSTR Buffer OPTIONAL
    )

/*++

Routine Description:

    Format the supplied FILETIME argument into a string. If the FILETIME
    is not supplied, format the current time.

Arguments:

    FileTime - Supplies an optional pointer to the FILETIME to be
        formatted.

    Buffer - Supplies an optional buffer to put the formatted time. This
        buffer nust be at least FILE_TIME_STRING_LENGTH bytes in length.

Return Value:

    PSTR - Returns a pointer to a string containg the formatted time.

Notes:

    If the Buffer is not supplied an static buffer used to store the formatted
    time. Therefore each call to FormatFileTime will overwrite the previous
    results.

--*/
{
    SYSTEMTIME  SystemTime;
    PSTR        BufferPtr;

    static PSTR Months[ ] = {
                            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                            };

    static PSTR Days[ ]   = {
                            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
                            };

    static TSTR StaticBuffer[ FILE_TIME_STRING_LENGTH ];

    //
    // If the FileTime is supplied format that, otherwise format the
    // current time.
    //

    if( ARGUMENT_PRESENT( FileTime )) {

        //
        // Check that the supplied time was a valid FILETIME.
        //

        if( ! FileTimeToSystemTime( FileTime, &SystemTime )) {

            ASSERT_MESSAGE( FALSE, "Invalid FILETIME" );
            return NULL;
        }
    } else {

        GetSystemTime( &SystemTime );
    }

    //
    // If Buffer is supplied use it, otherwise use the static buffer.
    //

    BufferPtr = ( ARGUMENT_PRESENT( Buffer )) ? Buffer : StaticBuffer;

    //
    // DDD dd-MMM-yyyy hh:mm:ss
    //

    //
    // Check that there is room for the formatted string.
    //

    ASSERT( strlen( "DDD dd-MMM-yyyy hh:mm:ss" ) < FILE_TIME_STRING_LENGTH );

    sprintf( BufferPtr,
        "%s %02d-%s-%4d %02d:%02d:%02d",
        Days[ SystemTime.wDayOfWeek ],
        SystemTime.wDay,
        Months[ SystemTime.wMonth - 1 ],
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond
        );

    return BufferPtr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\parsekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Parsekey.c

Abstract:

    This module contains the ParseKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>
#include <string.h>

#include "crtools.h"

//
// PREDEFINED_HANDLE_ENTRYs are used to map strings on the command line
// to real predefined handles.
//

typedef struct _PREDEFINED_HANDLE_ENTRY
    PREDEFINED_HANDLE_ENTRY,
    *PPREDEFINED_HANDLE_ENTRY;

struct _PREDEFINED_HANDLE_ENTRY {
    PKEY        PredefinedKey;
    PSTR        PredefinedHandleName;
};

PKEY
ParseKey(
    IN PSTR SubKeyName
    )

/*++

Routine Description:

    Attempts to parse the supplied Key (string) into a predefined handle
    and a sub key.  If succesful it allocates and returns a KEY structure.

    The form of the supplied Key should be:

       \\machine_name\<predefined_key_name>\sub-key

    where "\\machine_name\" is optional.

Arguments:

    SubKeyName - Supplies the string which contains the key to parse.

Return Value:

    PKEY - Returns a pointer to a KEY structure if the supplied SubKeyName
        was succesfully parsed.

--*/


{

    static PREDEFINED_HANDLE_ENTRY      PredefinedHandleTable[ ] = {
                                &KeyClassesRoot,  HKEY_CLASSES_ROOT_STRING,
                                &KeyCurrentUser,  HKEY_CURRENT_USER_STRING,
                                &KeyLocalMachine, HKEY_LOCAL_MACHINE_STRING,
                                &KeyUsers,        HKEY_USERS_STRING
                            };
    PSTR    Token;
    PSTR    Name;
    PSTR    StrPtr;
    PSTR    MachineNamePtr;
    TSTR    MachineName[ MAX_PATH ];
    WORD    i;
    PKEY    ParsedKey;


    ASSERT( ARGUMENT_PRESENT( SubKeyName ));

    //
    // See if the SubKeyName contains a \\machine name.
    //

    if(( SubKeyName[ 0 ] == '\\' ) && ( SubKeyName[ 1 ] == '\\' )) {

        //
        // Find the end of the machine name.
        //

        StrPtr = strchr( &SubKeyName[ 2 ], '\\' );

        //
        // If the SubKeyName only contained a machine name, its invalid.
        //

        if( *StrPtr == '\0' ) {

            ASSERT_MESSAGE( FALSE, "SubKeyName - " );
            return NULL;

        } else {

            //
            // Copy and NUL terminate the machine name and bump over the '\'
            // that seperates the machine name from predefined handle.
            //

            strncpy( MachineName, SubKeyName, StrPtr - SubKeyName );
            MachineName[ StrPtr - SubKeyName ] = '\0';
            StrPtr++;
            MachineNamePtr = MachineName;
        }

    } else {

        //
        // There is no machine name so parse the string from the beginning.
        //

        StrPtr = SubKeyName;
        MachineNamePtr = NULL;
    }

    //
    // Get the predefined handle from the string (this may be at the
    // beginning of the string or after the machine name).
    //

    Token = strtok( StrPtr, "\\\0" );

    //
    // For each predefined handle, search the table to determine which
    // handle is being referenced.
    //

    for(
        i = 0;
        i < sizeof( PredefinedHandleTable ) / sizeof( PREDEFINED_HANDLE_ENTRY );
        i++ ) {

        //
        // See if the predefined handle name has been mapped in
        // the environment.
        //

        Name = getenv( PredefinedHandleTable[ i ].PredefinedHandleName );

        //
        // If it hasn't been mapped, use the default.
        //

        if( Name == NULL ) {

            Name = PredefinedHandleTable[ i ].PredefinedHandleName;
        }

        //
        // If the Token matches one of the prefined handle names, allocate
        // a KEY structure.
        //

        if( _stricmp( Name, Token ) == 0 ) {

            ParsedKey = AllocateKey(
                            MachineNamePtr,
                            PredefinedHandleTable[ i ].PredefinedKey,
                            strtok( NULL, "\0" )
                            );

            if( ParsedKey != NULL ) {

                return ParsedKey;

            } else {

                ASSERT_MESSAGE( FALSE, "AllocateKey - " );
                return NULL;
            }
        }
    }

    //
    // The supplied Key could not be parsed. That is the first token
    // was not one of the predefined handle names.
    //

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\tools\lib\src\dispval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkey.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>
#include <stdlib.h>

#include "crtools.h"

//
// Ensure that ValueTypeStrings table is correct.
//

//
// Maximum number of registry types.
//

#define NUMBER_OF_REG_TYPES     ( 9 )

#if (  (REG_NONE             != ( 0 )) \
    || (REG_SZ               != ( 1 )) \
    || (REG_EXPAND_SZ        != ( 2 )) \
    || (REG_BINARY           != ( 3 )) \
    || (REG_DWORD            != ( 4 )) \
    || (REG_DWORD_BIG_ENDIAN != ( 5 )) \
    || (REG_LINK             != ( 6 )) \
    || (REG_MULTI_SZ         != ( 7 )) \
    || (REG_RESOURCE_LIST    != ( 8 )))



#error REG_* does not map ValueTypeStrings correctly.

#endif

VOID
DisplayValues(
    IN PKEY Key,
    IN BOOL Data
    )

/*++

Routine Description:

    Display (on stdout) information about a Key's values and optionally
    its data.

Arguments:

    KeyHandle - Supplies a HKEY for which meta information is to be
        displayed.

    Key - Supplies a pointer to a KEY structure where the meta information
        is stored.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

Return Value:

    BOOL

--*/

{
    static PSTR ValueTypeStrings[ ] =   {
                                            TEXT( "None" ),
                                            TEXT( "String" ),
                                            TEXT( "Binary" ),
                                            TEXT( "Double Word" ),
                                            TEXT( "Double Word (big endian)" ),
                                            TEXT( "Symbolic link" ),
                                            TEXT( "Multi-SZ" ),
                                            TEXT( "Resource list" ),
                                            TEXT( "Unknown" )
                                        };


    LONG        Error;
    DWORD       Index;

    PSTR        ValueName;
    DWORD       ValueNameLength;
    DWORD       ValueTitleIndex;
    DWORD       ValueType;
    PBYTE       ValueData;
    DWORD       ValueDataLength;

    ASSERT( ARGUMENT_PRESENT( Key ));

    // Attempt to allocate memory for the largest possible value name.
    //

    ValueName = ( PSTR ) malloc( Key->MaxValueNameLength + 1 );
    if( ValueName == NULL ) {

        ASSERT_MESSAGE( FALSE, "Value name memory allocation - " );
        return;
    }

    //
    // If data is requested, attempt to allocate memory for the largest amount
    // of data.
    //

    if( Data ) {

        ValueData = ( PBYTE ) malloc( Key->MaxValueDataLength + 1 );
        if( ValueData == NULL ) {

            ASSERT_MESSAGE( FALSE, "Value data memory allocation - " );
            return;
        }

    } else {

        ValueData = NULL;
    }

    //
    // For each value in the sub key, enumerate and display its
    // details.
    //

    for( Index = 0; Index < Key->NumberOfValues; Index++ ) {

        //
        // Can't use the Key->Max*Length variables as they will be
        // overwritten by the RegEnumValue API.
        //

        ValueNameLength = Key->MaxValueNameLength + 1;
        ValueDataLength = Key->MaxValueDataLength;

        //
        // Get the name, title index, type and data for the
        // current value.
        //

        Error = RegEnumValue(
                    Key->KeyHandle,
                    Index,
                    ValueName,
                    &ValueNameLength,
                    NULL,
                    &ValueType,
                    ValueData,
                    &ValueDataLength
                    );

        if( Error != ERROR_SUCCESS ) {
            ASSERT_MESSAGE( FALSE, "RegEnumValue - " );
            return;
        }

        //
        // Display the value information.
        //

        printf( "\n"
                "Value %d\n"
                "Name:              %.*s\n"
                // "Title Index:       %ld\n"
                "Type:              %s (%ld)\n"
                "Data Length:       %ld\n",
                Index + 1,
                ( ValueNameLength == 0 ) ? 80 : ValueNameLength,
                ( ValueNameLength == 0 ) ? "<NONE>" : ValueName,
                // ValueTitleIndex,
                ValueTypeStrings[( ValueType < NUMBER_OF_REG_TYPES )
                                ? ValueType
                                : NUMBER_OF_REG_TYPES ],
                ValueType,
                ValueDataLength
                );

        if( Data ) {

            ASSERT( ValueData != NULL );
            DisplayData( ValueData, ValueDataLength );
        }
    }

    //
    // Release the buffers.
    //

    free( ValueName );

    if( ValueData != NULL ) {

        free( ValueData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\seaudit\msaudite\makefile.inc ===
MSAUDITE=$(SDK_INC_PATH)\msaudite.h \
         msaudite.h \
         msg00001.bin \
         msaudite.rc 

TARGETMOVED=$(BASEDIR)\private\ntos\seaudit\msaudite\msaudite.h \
            $(BASEDIR)\private\ntos\seaudit\msaudite\msaudite.rc \
            $(BASEDIR)\private\ntos\seaudit\msaudite\msg00001.bin
         
clean:  
       del /Q /F $(MSAUDITE)
       del /Q /F $(TARGETMOVED)

$(SDK_INC_PATH)\msaudite.h: msaudite.h 
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\strsafe\ntstrsafe\ntstrsafe.c ===
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>

#define NTSTRSAFE_LIB_IMPL
#include <ntstrsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\seaudit\msobjs\makefile.inc ===
MSOBJS=  $(SDK_INC_PATH)\msobjs.h \
         msobjs.h \
	 msg00001.bin \
         msobjs.rc 

TARGETMOVED=$(BASEDIR)\private\ntos\seaudit\msobjs\msobjs.h \
            $(BASEDIR)\private\ntos\seaudit\msobjs\msobjs.rc \
            $(BASEDIR)\private\ntos\seaudit\msobjs\msg00001.bin

clean:  
    del /Q /F $(MSOBJS) 
    del /Q /F $(TARGETMOVED)

$(SDK_INC_PATH)\msobjs.h: msobjs.h
   copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\strsafe\strsafe\strsafe.c ===
#include <stdio.h>

#define STRSAFE_LIB_IMPL
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\stublibs\stublib.h ===
#define EX(x)    \
void             \
x(void) {        \
    return;      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\stublibs\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..

SOURCES=$(TARGETNAME).c
PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(PUBLISH_PATH)\amd64\$(TARGETNAME).lib}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\stublibs\delay\delayimp.cpp ===
#include "windows.h"
#include "delayimp.h"

PUnloadInfo __puiHead;

extern "C"
void
__delayLoadHelper2 (
    void
    )

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\stublibs\rsa32k\rsa32k.c ===
#include <stublib.h>

EX(A_SHAFinal)
EX(A_SHAFinalNS)
EX(A_SHAInit)
EX(A_SHAUpdate)
EX(A_SHAUpdateNS)
EX(CBC)
EX(DES_ECB_LM)
EX(HMACMD5Final)
EX(HMACMD5Init)
EX(HMACMD5Update)
EX(MD4Final)
EX(MD4Init)
EX(MD4Update)
EX(MD5Final)
EX(MD5Init)
EX(MD5Update)
EX(des)
EX(desexpand128to192)
EX(deskey)
EX(desx)
EX(desxkey)
EX(rc4)
EX(rc4_key)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\stublibs\rsa32\rsa32.c ===
#include <stublib.h>

EX(A_SHAFinal)
EX(A_SHAFinalNS)
EX(A_SHAInit)
EX(A_SHAUpdate)
EX(A_SHAUpdateNS)
EX(DES_ECB_LM)
EX(MD4Final)
EX(MD4Init)
EX(MD4Update)
EX(MD5Final)
EX(MD5Init)
EX(MD5Update)
EX(rc4)
EX(rc4_key)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\apiinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apiinit.c

Abstract:

    This module contains the code to initialize the ApiPort of the
    Server side of the Client-Server Runtime Subsystem to the Session
    Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

static SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY NtAuthority       = SECURITY_NT_AUTHORITY;

NTSTATUS
CsrApiPortInitialize( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    CLIENT_ID ClientId;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD ServerThread;
    HANDLE EventHandle;
    ULONG Length;
    PSID SeWorldSid;
    PSID SeRestrictedSid; 
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Dacl;

	// Though this function does not seem to cleanup on failure, failure
	// will cause Csrss to exit, so any allocated memory will be freed and
	// any open handle will be closed.


    Length = CsrDirectoryName.Length +
             sizeof( CSR_API_PORT_NAME ) +
             sizeof( OBJ_NAME_PATH_SEPARATOR );
    CsrApiPortName.Buffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), Length );
    if (CsrApiPortName.Buffer == NULL) {
        return( STATUS_NO_MEMORY );
        }
    CsrApiPortName.Length = 0;
    CsrApiPortName.MaximumLength = (USHORT)Length;
    RtlAppendUnicodeStringToString( &CsrApiPortName, &CsrDirectoryName );
    RtlAppendUnicodeToString( &CsrApiPortName, L"\\" );
    RtlAppendUnicodeToString( &CsrApiPortName, CSR_API_PORT_NAME );

    IF_CSR_DEBUG( INIT ) {
        DbgPrint( "CSRSS: Creating %wZ port and associated threads\n",
                  &CsrApiPortName );
        DbgPrint( "CSRSS: sizeof( CONNECTINFO ) == %ld  sizeof( API_MSG ) == %ld\n",
                  sizeof( CSR_API_CONNECTINFO ),
                  sizeof( CSR_API_MSG )
                );
        }

    //
    // create a security descriptor that allows all access
    //

    SeWorldSid = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), RtlLengthRequiredSid( 1 ) );
    if (SeWorldSid == NULL) {
        return( STATUS_NO_MEMORY );
        }

    RtlInitializeSid( SeWorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( SeWorldSid, 0 )) = SECURITY_WORLD_RID;

    Status = RtlAllocateAndInitializeSid(&NtAuthority ,
								         1,
                                         SECURITY_RESTRICTED_CODE_RID,
                                         0, 0, 0, 0, 0, 0, 0,
                                         &SeRestrictedSid);
	if (!NT_SUCCESS(Status)){
		return Status;
	}

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             2 * (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( SeWorldSid ) +
             RtlLengthSid( SeRestrictedSid ) +
             8; // The 8 is just for good measure
    SecurityDescriptor = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), Length);
    if (SecurityDescriptor == NULL) {
        return( STATUS_NO_MEMORY );
        }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    RtlCreateAcl( Dacl, Length - SECURITY_DESCRIPTOR_MIN_LENGTH, ACL_REVISION2);

    RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_CONNECT|READ_CONTROL|SYNCHRONIZE,
                 SeWorldSid
                 );

    RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_CONNECT|READ_CONTROL|SYNCHRONIZE,
                 SeRestrictedSid
                 );

    RtlSetDaclSecurityDescriptor (
                 SecurityDescriptor,
                 TRUE,
                 Dacl,
                 FALSE
                 );

    InitializeObjectAttributes( &ObjectAttributes, &CsrApiPortName, 0,
                                NULL, SecurityDescriptor );
    Status = NtCreatePort( &CsrApiPort,
                           &ObjectAttributes,
                           sizeof( CSR_API_CONNECTINFO ),
                           sizeof( CSR_API_MSG ),
                           4096 * 16
                         );
    if (!NT_SUCCESS(Status)){
        return Status;
    }
    //
    // clean up security stuff
    //

    RtlFreeHeap( CsrHeap, 0, SeWorldSid );
    RtlFreeHeap( CsrHeap, 0, SeRestrictedSid );
    RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );

    Status = NtCreateEvent(&EventHandle,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE
                           );
    if (!NT_SUCCESS(Status)){
        return Status;
    }
    //
    // Create the inital request thread
    //

    Status = RtlCreateUserThread( NtCurrentProcess(),
                                  NULL,
                                  TRUE,
                                  0,
                                  0,
                                  0,
                                  CsrApiRequestThread,
                                  (PVOID)EventHandle,
                                  &Thread,
                                  &ClientId
                                );
    if (!NT_SUCCESS(Status)){
        return Status;
    }

    CsrAddStaticServerThread(Thread,&ClientId,CSR_STATIC_API_THREAD);

    ListHead = &CsrRootProcess->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ServerThread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        Status = NtResumeThread( ServerThread->ThreadHandle, NULL );
        if (ServerThread->Flags & CSR_STATIC_API_THREAD) {
            Status = NtWaitForSingleObject(EventHandle,FALSE,NULL);
            ASSERT( NT_SUCCESS( Status ) );
        }
        ListNext = ListNext->Flink;
    }
    NtClose(EventHandle);


    return( Status );
}

HANDLE
CsrQueryApiPort(VOID)
{
    return CsrApiPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\csrdebug.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrdebug.c

Abstract:

    This module implements CSR Debug Services.

Author:

    Mark Lucovsky (markl) 02-Apr-1991


Revision History:

--*/

#include "csrsrv.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

PIMAGE_DEBUG_DIRECTORY
CsrpLocateDebugSection(
    IN HANDLE ProcessHandle,
    IN PVOID Base
    );

NTSTATUS
CsrDebugProcess(
    IN ULONG TargetProcessId,
    IN PCLIENT_ID DebugUserInterface,
    IN PCSR_ATTACH_COMPLETE_ROUTINE AttachCompleteRoutine
    )
{
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
CsrDebugProcessStop(
    IN ULONG TargetProcessId,
    IN PCLIENT_ID DebugUserInterface)
/*++

Routine Description:

    This procedure stops debugging a process

Arguments:

    ProcessId - Supplies the address of the process being debugged.
    DebugUserInterface - Client that issued the call

Return Value:

    NTSTATUS

--*/
{
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\csrss\csrss.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csrss.c

Abstract:

    This is the main startup module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

VOID
DisableErrorPopups(
    VOID
    )
{

    ULONG NewMode;

    NewMode = 0;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessDefaultHardErrorMode,
        (PVOID) &NewMode,
        sizeof(NewMode)
        );
}

int
_cdecl
main(
    IN ULONG argc,
    IN PCH argv[],
    IN PCH envp[],
    IN ULONG DebugFlag OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG ErrorResponse;
    KPRIORITY SetBasePriority;


    SetBasePriority = FOREGROUND_BASE_PRIORITY + 4;
    Status = NtSetInformationProcess (NtCurrentProcess(),
                                      ProcessBasePriority,
                                      (PVOID) &SetBasePriority,
                                      sizeof(SetBasePriority));
    ASSERT (NT_SUCCESS (Status));

    Status = CsrServerInitialization( argc, argv );

    if (!NT_SUCCESS( Status )) {
        IF_DEBUG {
	    DbgPrint( "CSRSS: Unable to initialize server.  status == %X\n",
		      Status
                    );
        }

	NtTerminateProcess( NtCurrentProcess(), Status );
    }

    DisableErrorPopups();

    if (NtCurrentPeb()->SessionId == 0) {
        //
        // Make terminating the root csrss fatal
        //
        RtlSetProcessIsCritical(TRUE, NULL, FALSE);
    }

    NtTerminateThread( NtCurrentThread(), Status );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\csrsrv.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrsrv.h

Abstract:

    Main include file for Server side of the Client Server Runtime (CSR)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

//
// Include definitions common between the Client and Server portions.
//

#include <csr.h>

//
// Include definitions specific to the Server portion.
//

#include <ntcsrsrv.h>

#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

//
// Define debugging flags and macro for testing them.  All debug code
// should be contained within a IF_CSR_DEBUG macro call so that when
// the system is compiled with debug code disabled, none of the code
// is generated.
//

#if DBG
#define CSR_DEBUG_INIT              0x00000001
#define CSR_DEBUG_LPC               0x00000002
#define CSR_DEBUG_FLAG3             0x00000004
#define CSR_DEBUG_FLAG4             0x00000008
#define CSR_DEBUG_FLAG5             0x00000010
#define CSR_DEBUG_FLAG6             0x00000020
#define CSR_DEBUG_FLAG7             0x00000040
#define CSR_DEBUG_FLAG8             0x00000080
#define CSR_DEBUG_FLAG9             0x00000100
#define CSR_DEBUG_FLAG10            0x00000200
#define CSR_DEBUG_FLAG11            0x00000400
#define CSR_DEBUG_FLAG12            0x00000800
#define CSR_DEBUG_FLAG13            0x00001000
#define CSR_DEBUG_FLAG14            0x00002000
#define CSR_DEBUG_FLAG15            0x00004000
#define CSR_DEBUG_FLAG16            0x00008000
#define CSR_DEBUG_FLAG17            0x00010000
#define CSR_DEBUG_FLAG18            0x00020000
#define CSR_DEBUG_FLAG19            0x00040000
#define CSR_DEBUG_FLAG20            0x00080000
#define CSR_DEBUG_FLAG21            0x00100000
#define CSR_DEBUG_FLAG22            0x00200000
#define CSR_DEBUG_FLAG23            0x00400000
#define CSR_DEBUG_FLAG24            0x00800000
#define CSR_DEBUG_FLAG25            0x01000000
#define CSR_DEBUG_FLAG26            0x02000000
#define CSR_DEBUG_FLAG27            0x04000000
#define CSR_DEBUG_FLAG28            0x08000000
#define CSR_DEBUG_FLAG29            0x10000000
#define CSR_DEBUG_FLAG30            0x20000000
#define CSR_DEBUG_FLAG31            0x40000000
#define CSR_DEBUG_FLAG32            0x80000000

ULONG CsrDebug;

#define IF_CSR_DEBUG( ComponentFlag ) \
    if (CsrDebug & (CSR_DEBUG_ ## ComponentFlag))

#define SafeBreakPoint()                    \
    if (NtCurrentPeb()->BeingDebugged) {    \
        DbgBreakPoint();                    \
    }

#else
#define IF_CSR_DEBUG( ComponentFlag ) if (FALSE)

#define SafeBreakPoint()

#endif

#if DBG

#define CSRSS_PROTECT_HANDLES 1

BOOLEAN
ProtectHandle(
    HANDLE hObject
    );

BOOLEAN
UnProtectHandle(
    HANDLE hObject
    );

#else

#define CSRSS_PROTECT_HANDLES 0

#define ProtectHandle( hObject )
#define UnProtectHandle( hObject )

#endif


//
// Include NT Session Manager and Debug SubSystem Interfaces
//

#include <ntsm.h>
typedef BOOLEAN (*PSB_API_ROUTINE)( IN PSBAPIMSG SbApiMsg );

//
// Global data accessed by Client-Server Runtime Server
//

PVOID CsrHeap;

HANDLE CsrObjectDirectory;

#define CSR_SBAPI_PORT_NAME L"SbApiPort"

UNICODE_STRING CsrDirectoryName;
UNICODE_STRING CsrApiPortName;
UNICODE_STRING CsrSbApiPortName;

HANDLE CsrApiPort;
HANDLE CsrSbApiPort;
HANDLE CsrSmApiPort;

ULONG CsrMaxApiRequestThreads;

#define CSR_MAX_THREADS 16

#define CSR_STATIC_API_THREAD    0x00000010

PCSR_THREAD CsrSbApiRequestThreadPtr;

#define FIRST_SEQUENCE_COUNT   5

//
// Routines defined in srvinit.c
//


//
// Hydra Specific Globals and prototypes
//

#define SESSION_ROOT    L"\\Sessions"
#define DOSDEVICES      L"\\DosDevices"
#define MAX_SESSION_PATH   256
ULONG SessionId;
HANDLE SessionObjectDirectory;
HANDLE DosDevicesDirectory;
HANDLE BNOLinksDirectory;
HANDLE SessionsObjectDirectory;

NTSTATUS
CsrCreateSessionObjectDirectory( ULONG SessionID );

//
// The CsrNtSysInfo global variable contains NT specific constants of
// interest, such as page size, allocation granularity, etc.  It is filled
// in once during process initialization.
//

SYSTEM_BASIC_INFORMATION CsrNtSysInfo;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + CsrNtSysInfo.PageSize - 1) & ~(CsrNtSysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(CsrNtSysInfo.PageSize - 1))

#define QUAD_ALIGN(VALUE) ( ((ULONG_PTR)(VALUE) + 7) & ~7 )

NTSTATUS
CsrParseServerCommandLine(
    IN ULONG argc,
    IN PCH argv[]
    );

NTSTATUS
CsrServerDllInitialization(
    IN PCSR_SERVER_DLL LoadedServerDll
    );

NTSTATUS
CsrSrvUnusedFunction(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
CsrEnablePrivileges(
    VOID
    );


//
// Routines define in srvdebug.c
//

#if DBG

#else

#endif // DBG



//
// Routines defined in sbinit.c
//

NTSTATUS
CsrSbApiPortInitialize( VOID );


VOID
CsrSbApiPortTerminate(
    NTSTATUS Status
    );

//
// Routines defined in sbreqst.c
//

NTSTATUS
CsrSbApiRequestThread(
    IN PVOID Parameter
    );

//
// Routines defined in sbapi.c
//

BOOLEAN
CsrSbCreateSession(
    IN PSBAPIMSG Msg
    );

BOOLEAN
CsrSbTerminateSession(
    IN PSBAPIMSG Msg
    );

BOOLEAN
CsrSbForeignSessionComplete(
    IN PSBAPIMSG Msg
    );

//
// Routines defined in session.c
//

RTL_CRITICAL_SECTION CsrNtSessionLock;
LIST_ENTRY CsrNtSessionList;

#define LockNtSessionList() RtlEnterCriticalSection( &CsrNtSessionLock )
#define UnlockNtSessionList() RtlLeaveCriticalSection( &CsrNtSessionLock )

NTSTATUS
CsrInitializeNtSessionList( VOID );

PCSR_NT_SESSION
CsrAllocateNtSession(
    ULONG SessionId
    );

VOID
CsrReferenceNtSession(
    PCSR_NT_SESSION Session
    );

VOID
CsrDereferenceNtSession(
    PCSR_NT_SESSION Session,
    NTSTATUS ExitStatus
    );


//
// Routines defined in apiinit.c
//

NTSTATUS
CsrApiPortInitialize( VOID );


//
// Routines defined in apireqst.c
//

NTSTATUS
CsrApiRequestThread(
    IN PVOID Parameter
    );

BOOLEAN
CsrCaptureArguments(
    IN PCSR_THREAD t,
    IN PCSR_API_MSG m
    );

VOID
CsrReleaseCapturedArguments(
    IN PCSR_API_MSG m
    );

ULONG
CsrSrvNullApiCall(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// Routines and data defined in srvloadr.c
//

#define CSR_MAX_SERVER_DLL 4

PCSR_SERVER_DLL CsrLoadedServerDll[ CSR_MAX_SERVER_DLL ];

ULONG CsrTotalPerProcessDataLength;
HANDLE CsrSrvSharedSection;
ULONG CsrSrvSharedSectionSize;
PVOID CsrSrvSharedSectionBase;
PVOID CsrSrvSharedSectionHeap;
PVOID *CsrSrvSharedStaticServerData;

#define CSR_BASE_PATH   L"\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Subsystems\\CSRSS"
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))


NTSTATUS
CsrLoadServerDll(
    IN PCH ModuleName,
    IN PCH InitRoutineString,
    IN ULONG ServerDllIndex
    );

ULONG
CsrSrvClientConnect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


NTSTATUS
CsrSrvCreateSharedSection(
    IN PCH SizeParameter
    );


NTSTATUS
CsrSrvAttachSharedSection(
    IN PCSR_PROCESS Process OPTIONAL,
    OUT PCSR_API_CONNECTINFO p
    );

//
// Routines and data defined in process.c
//

//
// The CsrProcessStructureLock critical section protects all of the link
// fields of the Windows Process objects.  You must own this lock to examine
// or modify any of the following fields of the CSR_PROCESS structure:
//
//      ListLink
//
//  It also protects the following variables:
//
//      CsrRootProcess
//

RTL_CRITICAL_SECTION CsrProcessStructureLock;
#define AcquireProcessStructureLock() RtlEnterCriticalSection( &CsrProcessStructureLock )
#define ReleaseProcessStructureLock() RtlLeaveCriticalSection( &CsrProcessStructureLock )
#define ProcessStructureListLocked() \
    (CsrProcessStructureLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread)

//
// The following is a dummy process that acts as the root of the Windows Process
// Structure.  It has a ClientId of -1.-1 so it does not conflict with actual
// Windows Processes.  All processes created via the session manager are children
// of this process, as are all orphaned processes.  The ListLink field of this
// process is the head of a list of all Windows Processes.
//

PCSR_PROCESS CsrRootProcess;

//
// reference/dereference thread are public in ntcsrsrv.h
//

VOID
CsrLockedReferenceProcess(
    PCSR_PROCESS p
    );

VOID
CsrLockedReferenceThread(
    PCSR_THREAD t
    );

VOID
CsrLockedDereferenceProcess(
    PCSR_PROCESS p
    );

VOID
CsrLockedDereferenceThread(
    PCSR_THREAD t
    );

NTSTATUS
CsrInitializeProcessStructure( VOID );

PCSR_PROCESS
CsrAllocateProcess( VOID );

VOID
CsrDeallocateProcess(
    IN PCSR_PROCESS Process
    );

VOID
CsrInsertProcess(
    IN PCSR_PROCESS CallingProcess,
    IN PCSR_PROCESS Process
    );

VOID
CsrRemoveProcess(
    IN PCSR_PROCESS Process
    );

PCSR_THREAD
CsrAllocateThread(
    IN PCSR_PROCESS Process
    );

VOID
CsrDeallocateThread(
    IN PCSR_THREAD Thread
    );

VOID
CsrInsertThread(
    IN PCSR_PROCESS Process,
    IN PCSR_THREAD Thread
    );

VOID
CsrRemoveThread(
    IN PCSR_THREAD Thread
    );

PCSR_THREAD
CsrLocateThreadByClientId(
    OUT PCSR_PROCESS *Process,
    IN PCLIENT_ID ClientId
    );

PCSR_THREAD
CsrLocateServerThread(
    IN PCLIENT_ID ClientId);

//
// Routines and data defined in csrdebug.c
//

VOID
CsrSuspendProcess(
    IN PCSR_PROCESS Process
    );

VOID
CsrResumeProcess(
    IN PCSR_PROCESS Process
    );


//
// Routines and data defined in wait.c
//

#define AcquireWaitListsLock() RtlEnterCriticalSection( &CsrWaitListsLock )
#define ReleaseWaitListsLock() RtlLeaveCriticalSection( &CsrWaitListsLock )

RTL_CRITICAL_SECTION CsrWaitListsLock;

BOOLEAN
CsrInitializeWait(
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    OUT PCSR_WAIT_BLOCK *WaitBlockPtr
    );

BOOLEAN
CsrNotifyWaitBlock(
    IN PCSR_WAIT_BLOCK WaitBlock,
    IN PLIST_ENTRY WaitQueue,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags,
    IN BOOLEAN DereferenceThread
    );


ULONG CsrBaseTag;
ULONG CsrSharedBaseTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrBaseTag, t ))

#define TMP_TAG 0
#define INIT_TAG 1
#define CAPTURE_TAG 2
#define PROCESS_TAG 3
#define THREAD_TAG 4
#define SECURITY_TAG 5
#define SESSION_TAG 6
#define WAIT_TAG 7

#define MAKE_SHARED_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrSharedBaseTag, t ))
#define SHR_INIT_TAG 0

//
// Routines and data defined in process.c
//

BOOLEAN
CsrSbCreateProcess(
    IN OUT PSBAPIMSG m
    );

#if DBG
typedef struct _LPC_TRACK_NODE {
    PORT_MESSAGE Message;
    NTSTATUS Status;
    CLIENT_ID ClientCid;
    CLIENT_ID ServerCid;
    USHORT MessageType;
} LPC_TRACK_NODE, *PLPC_TRACK_NODE;

RTL_CRITICAL_SECTION CsrTrackLpcLock;
ULONG LpcTrackIndex;
LPC_TRACK_NODE LpcTrackNodes[4096];
#endif

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*(a)))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\sbapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbapi.c

Abstract:

    This module contains the implementations of the Sb API calls exported
    by the Server side of the Client-Server Runtime Subsystem to the
    Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"


BOOLEAN
CsrSbCreateSession(
    IN PSBAPIMSG Msg
    )
{
    PSBCREATESESSION a = &Msg->u.CreateSession;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    PVOID ProcessDataPtr;
    ULONG i;
    NTSTATUS Status;
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    KERNEL_USER_TIMES TimeInfo;


    ProcessHandle = a->ProcessInformation.Process;
    ThreadHandle = a->ProcessInformation.Thread;

    AcquireProcessStructureLock();
    Process = CsrAllocateProcess();
    if (Process == NULL) {
        Msg->ReturnedStatus = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( TRUE );
        }

    Status = NtSetInformationProcess(
                ProcessHandle,
                ProcessExceptionPort,
                &CsrApiPort,
                sizeof(HANDLE)
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( (BOOLEAN)STATUS_NO_MEMORY );
        }

    //
    // capture the thread's createtime so that we can use
    // this as a sequence number
    //

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( (BOOLEAN)Status );
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrDeallocateProcess( Process );
        Msg->ReturnedStatus = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( TRUE );
        }

    Thread->CreateTime = TimeInfo.CreateTime;
    Thread->ClientId = a->ProcessInformation.ClientId;
    Thread->ThreadHandle = a->ProcessInformation.Thread;

ProtectHandle(Thread->ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );

    //
    // this needs a little more thought
    //
    Process->NtSession = CsrAllocateNtSession( a->SessionId );

    Process->ClientId = a->ProcessInformation.ClientId;
    Process->ProcessHandle = a->ProcessInformation.Process;

    CsrSetBackgroundPriority(Process);

    //
    // initialize each DLL's per process data area.
    //

    ProcessDataPtr = (PVOID)QUAD_ALIGN(&Process->ServerDllPerProcessData[CSR_MAX_SERVER_DLL]);
    for (i = 0; i < CSR_MAX_SERVER_DLL; i++) {
        if (CsrLoadedServerDll[i] != NULL && CsrLoadedServerDll[i]->PerProcessDataLength) {
            Process->ServerDllPerProcessData[i] = ProcessDataPtr;
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + CsrLoadedServerDll[i]->PerProcessDataLength);
        } else {
            Process->ServerDllPerProcessData[i] = NULL;
        }
    }

    CsrInsertProcess(NULL, Process);
    Msg->ReturnedStatus = NtResumeThread(a->ProcessInformation.Thread, NULL);
    ReleaseProcessStructureLock();
    return( TRUE );
}

BOOLEAN
CsrSbTerminateSession(
    IN PSBAPIMSG Msg
    )
{
    PSBTERMINATESESSION a = &Msg->u.TerminateSession;

    Msg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
    return( TRUE );
}

BOOLEAN
CsrSbForeignSessionComplete(
    IN PSBAPIMSG Msg
    )
{
    PSBFOREIGNSESSIONCOMPLETE a = &Msg->u.ForeignSessionComplete;

    Msg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\apireqst.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apireqst.c

Abstract:

    This module contains the Request thread procedure for the Server side
    of the Client-Server Runtime Subsystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"
#include <ntos.h>

NTSTATUS
CsrApiHandleConnectionRequest(
    IN PCSR_API_MSG Message
    );

EXCEPTION_DISPOSITION
CsrUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

#if DBG
ULONG GetNextTrackIndex(
    VOID)
{
    ULONG NextIndex;

    RtlEnterCriticalSection(&CsrTrackLpcLock);
    NextIndex = LpcTrackIndex++ % ARRAY_SIZE(LpcTrackNodes);
    RtlLeaveCriticalSection(&CsrTrackLpcLock);

    //
    // Do some initialization of the slot we're going to be working with.
    //
    RtlZeroMemory(&LpcTrackNodes[NextIndex], sizeof(LPC_TRACK_NODE));
    LpcTrackNodes[NextIndex].Status = (NTSTATUS)-1;
    LpcTrackNodes[NextIndex].ClientCid = NtCurrentTeb()->RealClientId;
    LpcTrackNodes[NextIndex].ServerCid = NtCurrentTeb()->ClientId;

    return NextIndex;
}

#endif

ULONG CsrpDynamicThreadTotal;
ULONG CsrpStaticThreadCount;

PCSR_THREAD CsrConnectToUser(
    VOID)
{
    static BOOLEAN (*ClientThreadSetupRoutine)(VOID) = NULL;
    NTSTATUS Status;
    ANSI_STRING DllName;
    UNICODE_STRING DllName_U;
    STRING ProcedureName;
    HANDLE UserClientModuleHandle;
    PTEB Teb;
    PCSR_THREAD Thread;
    BOOLEAN fConnected;
    PVOID TempClientThreadSetupRoutine;

    if (ClientThreadSetupRoutine == NULL) {
        RtlInitAnsiString(&DllName, "user32");
        Status = RtlAnsiStringToUnicodeString(&DllName_U, &DllName, TRUE);
        if (!NT_SUCCESS(Status)) {
            return NULL;
        }

        Status = LdrGetDllHandle(
                    UNICODE_NULL,
                    NULL,
                    &DllName_U,
                    (PVOID *)&UserClientModuleHandle
                    );

        RtlFreeUnicodeString(&DllName_U);

        if ( NT_SUCCESS(Status) ) {
            RtlInitString(&ProcedureName,"ClientThreadSetup");
            Status = LdrGetProcedureAddress(
                            UserClientModuleHandle,
                            &ProcedureName,
                            0L,
                            &TempClientThreadSetupRoutine
                            );
            if (!NT_SUCCESS(Status)){
                return NULL;
            }
            InterlockedCompareExchangePointer((PVOID *)&ClientThreadSetupRoutine, TempClientThreadSetupRoutine, NULL);
        } else {
            return NULL;
        }
    }

    try {
        fConnected = ClientThreadSetupRoutine();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        fConnected = FALSE;
    }
    if (!fConnected) {
        IF_DEBUG {
            DbgPrint("CSRSS: CsrConnectToUser failed\n");
        }

        return NULL;
    }

    /*
     * Set up CSR_THREAD pointer in the TEB
     */
    Teb = NtCurrentTeb();
    AcquireProcessStructureLock();
    Thread = CsrLocateServerThread(&Teb->ClientId);
    ReleaseProcessStructureLock();
    if (Thread) {
        Teb->CsrClientThread = Thread;
    }

    return Thread;
}

NTSTATUS
CsrpCheckRequestThreads(VOID)
{
    //
    // See if we need to create a new thread for api requests.
    //
    // Don't create a thread if we're in the middle of debugger
    // initialization, which would cause the thread to be
    // lost to the debugger.
    //
    // If we are not a dynamic api request thread, then decrement
    // the static thread count. If it underflows, then create a temporary
    // request thread
    //

    if (!InterlockedDecrement(&CsrpStaticThreadCount)) {
        if (CsrpDynamicThreadTotal < CsrMaxApiRequestThreads) {
            HANDLE QuickThread;
            CLIENT_ID ClientId;
            NTSTATUS CreateStatus;
            NTSTATUS Status1;


            //
            // If we are ready to create quick threads, then create one
            //

            CreateStatus = RtlCreateUserThread(NtCurrentProcess(),
                                               NULL,
                                               TRUE,
                                               0,
                                               0,
                                               0,
                                               CsrApiRequestThread,
                                               NULL,
                                               &QuickThread,
                                               &ClientId);
            if (NT_SUCCESS(CreateStatus)) {
                InterlockedIncrement(&CsrpStaticThreadCount);
                InterlockedIncrement(&CsrpDynamicThreadTotal);
                if (CsrAddStaticServerThread(QuickThread, &ClientId, CSR_STATIC_API_THREAD)) {
                    NtResumeThread(QuickThread, NULL);
                } else {
                    InterlockedDecrement(&CsrpStaticThreadCount);
                    InterlockedDecrement(&CsrpDynamicThreadTotal);

                    Status1 = NtTerminateThread (QuickThread, 0);
                    ASSERT (NT_SUCCESS (Status1));

                    Status1 = NtWaitForSingleObject (QuickThread, FALSE, NULL);
                    ASSERT (NT_SUCCESS (Status1));

                    RtlFreeUserThreadStack (NtCurrentProcess (), QuickThread);

                    Status1 = NtClose (QuickThread);
                    ASSERT (NT_SUCCESS (Status1));


                    return STATUS_UNSUCCESSFUL;
                }
            }
        }
    }

    return STATUS_SUCCESS;
}

VOID
ReplyToMessage (
    IN HANDLE Port,
    IN PPORT_MESSAGE m
   )
{
    NTSTATUS Status;
    LARGE_INTEGER DelayTime;

    while (1) {
        Status = NtReplyPort (CsrApiPort,
                              (PPORT_MESSAGE)m);
        if (Status == STATUS_NO_MEMORY) {

            KdPrint (("CSRSS: Failed to reply to calling thread, retrying.\n"));
                     DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                     NtDelayExecution (FALSE, &DelayTime);
                 continue;
        }
        break;
    }
}


typedef struct _QUEUED_HARD_ERROR {
    LIST_ENTRY ListEntry;
    PCSR_THREAD Thread;
    HARDERROR_MSG m;
} QUEUED_HARD_ERROR, *PQUEUED_HARD_ERROR;

#define MAX_CONCURRENT_HARD_ERRORS 3
#define MAX_OUTSTANDING_HARD_ERRORS 100

VOID
QueueHardError (
    IN PCSR_THREAD Thread,
    IN PHARDERROR_MSG m,
    IN ULONG ml
    )
{
    static LONG OutstandingHardErrors = 0;
    static LIST_ENTRY QueuedList = {&QueuedList, &QueuedList};
    PQUEUED_HARD_ERROR qm = NULL;
    NTSTATUS Status;
    LONG OldCount;
    ULONG i;
    PCSR_SERVER_DLL LoadedServerDll;


    //
    // Reference the thread if there is one as the hard error routines dereference in an async routine sometimes.
    //
    if (Thread != NULL) {
        CsrReferenceThread (Thread);
    }

    //
    // Mark the message as unhandled
    //

    m->Response = (ULONG)ResponseNotHandled;

    while (1) {
        OldCount = OutstandingHardErrors;

        //
        // If we already have a lot of hard errors active then queue this new one
        //
        if (OldCount >= MAX_CONCURRENT_HARD_ERRORS) {

            if (qm == NULL) {
                
                //
                // If too many hard errors are queued already. Drop this one.
                // We do this check while not owning a lock but this doesn';t matter.
                // We will stopp roughly at this level and it doesn't matter if we are a little off.
                //
                if (OldCount <= MAX_OUTSTANDING_HARD_ERRORS) {
                    qm = RtlAllocateHeap (CsrHeap, 0, ml + FIELD_OFFSET (QUEUED_HARD_ERROR, m));
                }

                if (qm == NULL) {

                    ReplyToMessage (CsrApiPort, (PPORT_MESSAGE)m);

                    if (Thread != NULL) {
                        CsrDereferenceThread (Thread);
                    }
                    return;
                }

                RtlCopyMemory (&qm->m, m, ml);
                qm->Thread = Thread;
            }

            AcquireProcessStructureLock ();
            if (InterlockedCompareExchange (&OutstandingHardErrors, OldCount + 1, OldCount) == OldCount) {
                InsertTailList (&QueuedList, &qm->ListEntry);
                qm = NULL;
            }
            ReleaseProcessStructureLock ();

            if (qm == NULL) {
                return;
            }
        } else if (InterlockedCompareExchange (&OutstandingHardErrors, OldCount + 1, OldCount) == OldCount) {

            while (1) {
                //
                // Only call the handler if there are other
                // request threads available to handle
                // message processing.
                //

                CsrpCheckRequestThreads();
                if (CsrpStaticThreadCount > 0) {
                    for (i = 0; i < CSR_MAX_SERVER_DLL; i++) {
                        LoadedServerDll = CsrLoadedServerDll[i];
                        if (LoadedServerDll && LoadedServerDll->HardErrorRoutine) {

                            (*LoadedServerDll->HardErrorRoutine)(Thread, m);
                            if (m->Response != (ULONG)ResponseNotHandled) {
                                break;
                            }
                        }
                    }
                }
                InterlockedIncrement (&CsrpStaticThreadCount);


                if (m->Response != (ULONG)-1) {
                    ReplyToMessage (CsrApiPort, (PPORT_MESSAGE)m);

                    //
                    // Release the thread reference if there was one.
                    //

                    if (Thread != NULL) {
                        CsrDereferenceThread (Thread);
                    }
                }


                if (qm != NULL) {
                    RtlFreeHeap (CsrHeap, 0, qm);
                    qm = NULL;
                }

                OldCount = InterlockedDecrement (&OutstandingHardErrors);
                if (OldCount < MAX_CONCURRENT_HARD_ERRORS) {
                    return;
                }

                AcquireProcessStructureLock ();

                ASSERT (!IsListEmpty (&QueuedList));

                qm = CONTAINING_RECORD (RemoveHeadList (&QueuedList), QUEUED_HARD_ERROR, ListEntry);

                ReleaseProcessStructureLock ();

                if (qm == NULL) {
                    return;
                }
                m = &qm->m;
                Thread = qm->Thread;
            }
        }
    }
}

NTSTATUS
CsrApiRequestThread(
    IN PVOID Parameter)
{
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    PCSR_THREAD MyThread;
    CSR_API_MSG ReceiveMsg;
    PCSR_API_MSG ReplyMsg;
    HANDLE ReplyPortHandle;
    PCSR_SERVER_DLL LoadedServerDll;
    PTEB Teb;
    ULONG ServerDllIndex;
    ULONG ApiTableIndex;
    CSR_REPLY_STATUS ReplyStatus;
    ULONG i;
    PVOID PortContext;
    USHORT MessageType;
    ULONG  ApiNumber;
    PLPC_CLIENT_DIED_MSG CdMsg;
#if DBG
    ULONG Index;
#endif

    Teb = NtCurrentTeb();
    ReplyMsg = NULL;
    ReplyPortHandle = CsrApiPort;

    //
    // Try to connect to USER.
    //

    while (!CsrConnectToUser()) {
        LARGE_INTEGER TimeOut;

        //
        // The connect failed.  The best thing to do is sleep for
        // 30 seconds and retry the connect.  Clear the
        // initialized bit in the TEB so the retry can
        // succeed.
        //

        Teb->Win32ClientInfo[0] = 0;
        TimeOut.QuadPart = Int32x32To64(30000, -10000);
        NtDelayExecution(FALSE, &TimeOut);
    }
    MyThread = Teb->CsrClientThread;

    if (Parameter) {
        Status = NtSetEvent((HANDLE)Parameter, NULL);
        ASSERT(NT_SUCCESS(Status));
        InterlockedIncrement(&CsrpStaticThreadCount);
        InterlockedIncrement(&CsrpDynamicThreadTotal);
    }

    while (TRUE) {
        NtCurrentTeb()->RealClientId = NtCurrentTeb()->ClientId;

        ASSERT(NtCurrentTeb()->CountOfOwnedCriticalSections == 0);

        while (1) {
            Status = NtReplyWaitReceivePort(CsrApiPort,
                                            &PortContext,
                                            (PPORT_MESSAGE)ReplyMsg,
                                            (PPORT_MESSAGE)&ReceiveMsg);
            if (Status == STATUS_NO_MEMORY) {
                LARGE_INTEGER DelayTime;

                if (ReplyMsg != NULL) {
                    KdPrint (("CSRSS: Failed to reply to calling thread, retrying.\n"));
                }
                DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                NtDelayExecution (FALSE, &DelayTime);
                continue;
            }
            break;
        }

        if (Status != STATUS_SUCCESS) {
            if (NT_SUCCESS(Status)) {
#if DBG
                DbgPrint("NtReplyWaitReceivePort returned \"success\" status 0x%x\n", Status);
#endif
                continue;       // Try again if alerted or a failure
            }

            IF_DEBUG {
                if (Status == STATUS_INVALID_CID ||
                    Status == STATUS_UNSUCCESSFUL ||
                    (Status == STATUS_INVALID_HANDLE &&
                     ReplyPortHandle != CsrApiPort
                    )
                   ) {
                    }
                else {
                    DbgPrint( "CSRSS: ReceivePort failed - Status == %X\n", Status );
                    DbgPrint( "CSRSS: ReplyPortHandle %lx CsrApiPort %lx\n", ReplyPortHandle, CsrApiPort );
                    }
                }

            //
            // Ignore if client went away.
            //

            ReplyMsg = NULL;
            ReplyPortHandle = CsrApiPort;
            continue;
        }

        ASSERT(ReceiveMsg.h.u1.s1.TotalLength >= sizeof (PORT_MESSAGE));
        ASSERT(sizeof (ReceiveMsg) > ReceiveMsg.h.u1.s1.TotalLength);

        RtlZeroMemory (((PUCHAR)&ReceiveMsg) + ReceiveMsg.h.u1.s1.TotalLength, sizeof (ReceiveMsg) - ReceiveMsg.h.u1.s1.TotalLength);

        NtCurrentTeb()->RealClientId = ReceiveMsg.h.ClientId;
        MessageType = ReceiveMsg.h.u2.s2.Type;

#if DBG
        Index = GetNextTrackIndex();
        LpcTrackNodes[Index].MessageType = MessageType;
        LpcTrackNodes[Index].ClientCid = ReceiveMsg.h.ClientId;
        LpcTrackNodes[Index].Message = ReceiveMsg.h;
#endif

        //
        // Check to see if this is a connection request and handle.
        //

        if (MessageType == LPC_CONNECTION_REQUEST) {
            NTSTATUS ConnectionStatus;

            ConnectionStatus = CsrApiHandleConnectionRequest(&ReceiveMsg);
#if DBG
            LpcTrackNodes[Index].Status = ConnectionStatus;
#endif
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            continue;
        }

        //
        // Lookup the client thread structure using the client id
        //
        AcquireProcessStructureLock();
        Thread = CsrLocateThreadByClientId(&Process, &ReceiveMsg.h.ClientId);
        if (!Thread) {
            ReleaseProcessStructureLock();
            if (MessageType == LPC_EXCEPTION) {
                ReplyMsg = &ReceiveMsg;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg->ReturnValue = DBG_CONTINUE;
            } else if (MessageType == LPC_CLIENT_DIED ||
                       MessageType == LPC_PORT_CLOSED) {
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = NULL;
            } else {
                //
                // This must be a non-csr thread calling us. Tell it to get
                // lost (unless this is a hard error).
                //
                if (MessageType == LPC_ERROR_EVENT) {
                    PHARDERROR_MSG m;

                    m = (PHARDERROR_MSG)&ReceiveMsg;
                    QueueHardError (NULL, m, sizeof (ReceiveMsg));

                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = NULL;
                    continue;
                } else {
                    ReplyPortHandle = CsrApiPort;
                    if (MessageType == LPC_REQUEST) {
                        ReplyMsg = &ReceiveMsg;
                        ReplyMsg->ReturnValue = STATUS_ILLEGAL_FUNCTION;
                    } else if (MessageType == LPC_DATAGRAM) {
                        //
                        // If this is a datagram, make the api call
                        //
                        //
                        // There is no thread so there can't be a mapped section for it.
                        // Make sure the capture stuff is off.
                        //
                        ReceiveMsg.CaptureBuffer = NULL;
                        ApiNumber = ReceiveMsg.ApiNumber;
                        ServerDllIndex =
                            CSR_APINUMBER_TO_SERVERDLLINDEX(ApiNumber);
                        if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
                            (LoadedServerDll = CsrLoadedServerDll[ServerDllIndex]) == NULL) {
                            IF_DEBUG {
                                DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                                        ServerDllIndex, LoadedServerDll
                                        );
                                DbgBreakPoint();
                            }

                            ReplyPortHandle = CsrApiPort;
                            ReplyMsg = NULL;
                            continue;
                        } else {
                            ApiTableIndex =
                                CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) -
                                LoadedServerDll->ApiNumberBase;
                            if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase) {
                                IF_DEBUG {
                                    DbgPrint( "CSRSS: %lx is invalid ApiTableIndex for %Z\n",
                                            LoadedServerDll->ApiNumberBase + ApiTableIndex,
                                            &LoadedServerDll->ModuleName
                                            );
                                }

                                ReplyPortHandle = CsrApiPort;
                                ReplyMsg = NULL;
                                continue;
                            }
                        }

#if DBG
                        IF_CSR_DEBUG( LPC ) {
                            DbgPrint( "[%02x] CSRSS: [%02x,%02x] - %s Api called from %08x\n",
                                    NtCurrentTeb()->ClientId.UniqueThread,
                                    ReceiveMsg.h.ClientId.UniqueProcess,
                                    ReceiveMsg.h.ClientId.UniqueThread,
                                    LoadedServerDll->ApiNameTable[ ApiTableIndex ],
                                    Thread
                                    );
                        }
#endif

                        ReceiveMsg.ReturnValue = STATUS_SUCCESS;

                        CsrpCheckRequestThreads();

                        ReplyPortHandle = CsrApiPort;
                        ReplyMsg = NULL;
                        try {

                            (*(LoadedServerDll->ApiDispatchTable[ApiTableIndex]))(
                                    &ReceiveMsg,
                                    &ReplyStatus);
                        } except (CsrUnhandledExceptionFilter(GetExceptionInformation())) {
                        }
                        InterlockedIncrement(&CsrpStaticThreadCount);
                    } else {
                        ReplyMsg = NULL;
                    }
                }
            }

            continue;
        }

        //
        // See if this is a client died message. If so,
        // callout and then teardown thread/process structures.
        // this is how ExitThread is seen by CSR.
        //
        // LPC_CLIENT_DIED is caused by ExitProcess.  ExitProcess
        // calls TerminateProcess, which terminates all of the process's
        // threads except the caller.  this termination generates
        // LPC_CLIENT_DIED.
        //

        ReplyPortHandle = CsrApiPort;

        if (MessageType != LPC_REQUEST) {
            if (MessageType == LPC_CLIENT_DIED) {
                CdMsg = (PLPC_CLIENT_DIED_MSG)&ReceiveMsg;
                if (CdMsg->CreateTime.QuadPart == Thread->CreateTime.QuadPart) {
                    ReplyPortHandle = Thread->Process->ClientPort;

                    CsrLockedReferenceThread(Thread);
                    Status = CsrDestroyThread(&ReceiveMsg.h.ClientId);

                    //
                    // if this thread is it, then we also need to dereference
                    // the process since it will not be going through the
                    // normal destroy process path.
                    //

                    if (Process->ThreadCount == 1) {
                        CsrDestroyProcess(&Thread->ClientId, 0);
                    }
                    CsrLockedDereferenceThread(Thread);
                }
                ReleaseProcessStructureLock();
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = NULL;
                continue;
            }

            CsrLockedReferenceThread(Thread);
            ReleaseProcessStructureLock();

            //
            // If this is an exception message, terminate the process.
            //

            if (MessageType == LPC_EXCEPTION) {
                PDBGKM_APIMSG m;

                NtTerminateProcess(Process->ProcessHandle, STATUS_ABANDONED);
                Status = CsrDestroyProcess(&ReceiveMsg.h.ClientId, STATUS_ABANDONED);
                m = (PDBGKM_APIMSG)&ReceiveMsg;
                m->ReturnedStatus = DBG_CONTINUE;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = &ReceiveMsg;
                CsrDereferenceThread(Thread);
                continue;
            }

            //
            // If this is a hard error message, return to caller.
            //

            if (MessageType == LPC_ERROR_EVENT) {
                PHARDERROR_MSG m;

                m = (PHARDERROR_MSG)&ReceiveMsg;
                QueueHardError (Thread, m, sizeof (ReceiveMsg));

            }

            CsrDereferenceThread (Thread);
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            continue;
        }

        CsrLockedReferenceThread(Thread);
        ReleaseProcessStructureLock();

        ApiNumber = ReceiveMsg.ApiNumber;
        ServerDllIndex =
            CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber );
        if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
            (LoadedServerDll = CsrLoadedServerDll[ ServerDllIndex ]) == NULL
           ) {
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                          ServerDllIndex, LoadedServerDll
                        );
                SafeBreakPoint();
                }

            ReplyMsg = &ReceiveMsg;
            ReplyPortHandle = CsrApiPort;
            ReplyMsg->ReturnValue = STATUS_ILLEGAL_FUNCTION;
            CsrDereferenceThread(Thread);
            continue;
        } else {
            ApiTableIndex =
                CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) -
                LoadedServerDll->ApiNumberBase;
            if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: %lx is invalid ApiTableIndex for %Z\n",
                              LoadedServerDll->ApiNumberBase + ApiTableIndex,
                              &LoadedServerDll->ModuleName
                            );
                    SafeBreakPoint();
                }

                ReplyMsg = &ReceiveMsg;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg->ReturnValue = STATUS_ILLEGAL_FUNCTION;
                CsrDereferenceThread(Thread);
                continue;
            }
        }

#if DBG
        IF_CSR_DEBUG( LPC ) {
            DbgPrint( "[%02x] CSRSS: [%02x,%02x] - %s Api called from %08x\n",
                      NtCurrentTeb()->ClientId.UniqueThread,
                      ReceiveMsg.h.ClientId.UniqueProcess,
                      ReceiveMsg.h.ClientId.UniqueThread,
                      LoadedServerDll->ApiNameTable[ ApiTableIndex ],
                      Thread
                    );
        }
#endif

        ReplyMsg = &ReceiveMsg;
        ReplyPortHandle = Thread->Process->ClientPort;

        ReceiveMsg.ReturnValue = STATUS_SUCCESS;
        if (ReceiveMsg.CaptureBuffer != NULL) {
            if (!CsrCaptureArguments( Thread, &ReceiveMsg )) {
                CsrDereferenceThread(Thread);
                goto failit;
            }
        }



        Teb->CsrClientThread = (PVOID)Thread;

        ReplyStatus = CsrReplyImmediate;

        CsrpCheckRequestThreads ();

        try {
            ReplyMsg->ReturnValue =
                (*(LoadedServerDll->ApiDispatchTable[ ApiTableIndex ]))(&ReceiveMsg,
                                                                        &ReplyStatus);
        } except (CsrUnhandledExceptionFilter (GetExceptionInformation ())){
            //
            // We don't get here as the filter makes this a fatal error
            //
        }

        InterlockedIncrement (&CsrpStaticThreadCount);

        Teb->CsrClientThread = (PVOID)MyThread;

        if (ReplyStatus == CsrReplyImmediate) {
            //
            // free captured arguments if a capture buffer was allocated
            // AND we're replying to the message now (no wait block has
            // been created).
            //

            if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                CsrReleaseCapturedArguments( &ReceiveMsg );
            }
            CsrDereferenceThread(Thread);
        } else if (ReplyStatus == CsrClientDied) {
            NTSTATUS Status;

            while (1) {
                Status = NtReplyPort (ReplyPortHandle,
                                      (PPORT_MESSAGE)ReplyMsg);
                if (Status == STATUS_NO_MEMORY) {
                    LARGE_INTEGER DelayTime;

                    KdPrint (("CSRSS: Failed to reply to calling thread, retrying.\n"));
                    DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                    NtDelayExecution (FALSE, &DelayTime);
                    continue;
                }
                break;
            }
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            CsrDereferenceThread(Thread);
        } else if (ReplyStatus == CsrReplyPending) {
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
        } else if (ReplyStatus == CsrServerReplied) {
            if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                CsrReleaseCapturedArguments( &ReceiveMsg );
            }
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            CsrDereferenceThread(Thread);
        } else {
            if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                CsrReleaseCapturedArguments( &ReceiveMsg );
            }
            CsrDereferenceThread(Thread);
        }

failit:;
    }

    NtTerminateThread(NtCurrentThread(), Status);
    return Status;
}

NTSTATUS
CsrCallServerFromServer(
    PCSR_API_MSG ReceiveMsg,
    PCSR_API_MSG ReplyMsg
    )

/*++

Routine Description:

    This function dispatches an API call the same way CsrApiRequestThread
    does, but it does it as a direct call, not an LPC connect.  It is used
    by the csr dll when the server is calling a dll function.  We don't
    worry about process serialization here because none of the process APIs
    can be called from the server.

Arguments:

    ReceiveMessage - Pointer to the API request message received.

    ReplyMessage - Pointer to the API request message to return.

Return Value:

    Status Code

--*/

{
    ULONG ServerDllIndex;
    ULONG ApiTableIndex;
    PCSR_SERVER_DLL LoadedServerDll;
    CSR_REPLY_STATUS ReplyStatus;

    ServerDllIndex =
        CSR_APINUMBER_TO_SERVERDLLINDEX( ReceiveMsg->ApiNumber );
    if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
        (LoadedServerDll = CsrLoadedServerDll[ ServerDllIndex ]) == NULL
       ) {
        IF_DEBUG {
            DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                      ServerDllIndex, LoadedServerDll
                    );
            // DbgBreakPoint();
            }

        ReplyMsg->ReturnValue = STATUS_ILLEGAL_FUNCTION;
        return STATUS_ILLEGAL_FUNCTION;
        }
    else {
        ApiTableIndex =
            CSR_APINUMBER_TO_APITABLEINDEX( ReceiveMsg->ApiNumber ) -
            LoadedServerDll->ApiNumberBase;
        if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase ||
            (LoadedServerDll->ApiServerValidTable &&
            !LoadedServerDll->ApiServerValidTable[ ApiTableIndex ])) {
#if DBG
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx (%s) is invalid ApiTableIndex for %Z or is an invalid API to call from the server.\n",
                          LoadedServerDll->ApiNumberBase + ApiTableIndex,
                          (LoadedServerDll->ApiNameTable &&
                           LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                          ) ? LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                            : "*** UNKNOWN ***",
                          &LoadedServerDll->ModuleName
                        );
                DbgBreakPoint();
                }
#endif

            ReplyMsg->ReturnValue = STATUS_ILLEGAL_FUNCTION;
            return STATUS_ILLEGAL_FUNCTION;
            }
        }

#if DBG
    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: %s Api Request received from server process\n",
                  LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                );
        }
#endif
    try {
        ReplyMsg->ReturnValue =
            (*(LoadedServerDll->ApiDispatchTable[ ApiTableIndex ]))(
                ReceiveMsg,
                &ReplyStatus
                );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ReplyMsg->ReturnValue = STATUS_ACCESS_VIOLATION;
        }

    return STATUS_SUCCESS;
}

BOOLEAN
CsrCaptureArguments(
    IN PCSR_THREAD t,
    IN PCSR_API_MSG m
    )
{
    PCSR_CAPTURE_HEADER ClientCaptureBuffer;
    PCSR_CAPTURE_HEADER ServerCaptureBuffer = NULL;
    PULONG_PTR PointerOffsets;
    ULONG Length, CountPointers;
    ULONG_PTR PointerDelta, Pointer;
    ULONG i;

    ClientCaptureBuffer = m->CaptureBuffer;
    m->ReturnValue = STATUS_SUCCESS;

    if ((PCH)ClientCaptureBuffer < t->Process->ClientViewBase ||
        (PCH)ClientCaptureBuffer > (t->Process->ClientViewBounds - FIELD_OFFSET(CSR_CAPTURE_HEADER,MessagePointerOffsets))) {
        IF_DEBUG {
            DbgPrint( "*** CSRSS: CaptureBuffer outside of ClientView 1\n" );
            SafeBreakPoint();
        }

        m->ReturnValue = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    try {

        Length = ClientCaptureBuffer->Length;
        if (((PCH)ClientCaptureBuffer + Length) < (PCH)ClientCaptureBuffer ||
            ((PCH)ClientCaptureBuffer + Length) > t->Process->ClientViewBounds) {
            IF_DEBUG {
                DbgPrint( "*** CSRSS: CaptureBuffer outside of ClientView 2\n" );
                SafeBreakPoint();
            }

            m->ReturnValue = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        CountPointers = ClientCaptureBuffer->CountMessagePointers;
        if (Length < FIELD_OFFSET(CSR_CAPTURE_HEADER, MessagePointerOffsets) + CountPointers * sizeof(PVOID) ||
            CountPointers > MAXUSHORT) {
            IF_DEBUG {
                DbgPrint( "*** CSRSS: CaptureBuffer %p has bad length\n", ClientCaptureBuffer );
                SafeBreakPoint();
            }

            m->ReturnValue = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        ServerCaptureBuffer = RtlAllocateHeap (CsrHeap, MAKE_TAG (CAPTURE_TAG), Length);
        if (ServerCaptureBuffer == NULL) {
            m->ReturnValue = STATUS_NO_MEMORY;
            return FALSE;
        }

        RtlCopyMemory (ServerCaptureBuffer, ClientCaptureBuffer, Length);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        IF_DEBUG {
            DbgPrint( "*** CSRSS: Took exception during capture %x\n", GetExceptionCode ());
            SafeBreakPoint();
        }
        if (ServerCaptureBuffer != NULL) {
            RtlFreeHeap (CsrHeap, 0, ServerCaptureBuffer);
        }
        m->ReturnValue = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    ServerCaptureBuffer->Length = Length;
    ServerCaptureBuffer->CountMessagePointers = CountPointers;

    PointerDelta = (ULONG_PTR)ServerCaptureBuffer - (ULONG_PTR)ClientCaptureBuffer;

    PointerOffsets = ServerCaptureBuffer->MessagePointerOffsets;
    for (i = CountPointers; i > 0; i--) {
        Pointer = *PointerOffsets++;
        if (Pointer != 0) {
            //
            // If the pointer is outside the LPC message or before the message data reject it.
            // Reject unaligned pointers within the message also.
            //
            if ((ULONG_PTR)Pointer > sizeof (CSR_API_MSG) - sizeof (PVOID) ||
                (ULONG_PTR)Pointer < FIELD_OFFSET (CSR_API_MSG, u) ||
                (((ULONG_PTR)Pointer&(sizeof (PVOID)-1))) != 0) {
                m->ReturnValue = STATUS_INVALID_PARAMETER;
                IF_DEBUG {
                    DbgPrint( "*** CSRSS: CaptureBuffer MessagePointer outside of message\n" );
                    SafeBreakPoint();
                }
                break;
            }

            //
            // The strings are captured as well as the pointers so make sure they were within the captured range.
            //
            Pointer += (ULONG_PTR)m;
            if ((PCH)*(PULONG_PTR)Pointer >= (PCH)&ClientCaptureBuffer->MessagePointerOffsets[CountPointers] &&
                (PCH)*(PULONG_PTR)Pointer <= (PCH)ClientCaptureBuffer + Length - sizeof (PVOID)) {
                *(PULONG_PTR)Pointer += PointerDelta;
            } else {
                IF_DEBUG {
                    DbgPrint( "*** CSRSS: CaptureBuffer MessagePointer outside of ClientView\n" );
                    SafeBreakPoint();
                }
                m->ReturnValue = STATUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    if (m->ReturnValue != STATUS_SUCCESS) {
        RtlFreeHeap (CsrHeap, 0, ServerCaptureBuffer);
        return FALSE ;
    } else {
        ServerCaptureBuffer->RelatedCaptureBuffer = ClientCaptureBuffer;
        m->CaptureBuffer = ServerCaptureBuffer;
        return TRUE;
    }
}

VOID
CsrReleaseCapturedArguments(
    IN PCSR_API_MSG m
    )
{
    PCSR_CAPTURE_HEADER ClientCaptureBuffer;
    PCSR_CAPTURE_HEADER ServerCaptureBuffer;
    PULONG_PTR PointerOffsets;
    ULONG CountPointers;
    ULONG_PTR PointerDelta, Pointer;

    ServerCaptureBuffer = m->CaptureBuffer;
    ClientCaptureBuffer = ServerCaptureBuffer->RelatedCaptureBuffer;
    if (ServerCaptureBuffer == NULL) {
        return;
    }
    ServerCaptureBuffer->RelatedCaptureBuffer = NULL;

    PointerDelta = (ULONG_PTR)ClientCaptureBuffer - (ULONG_PTR)ServerCaptureBuffer;

    PointerOffsets = ServerCaptureBuffer->MessagePointerOffsets;
    CountPointers = ServerCaptureBuffer->CountMessagePointers;
    while (CountPointers--) {
        Pointer = *PointerOffsets++;
        if (Pointer != 0) {
            Pointer += (ULONG_PTR)m;
            *(PULONG_PTR)Pointer += PointerDelta;
        }
    }

    try {
        RtlCopyMemory (ClientCaptureBuffer,
                       ServerCaptureBuffer,
                       ServerCaptureBuffer->Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SafeBreakPoint();
        m->ReturnValue = GetExceptionCode ();
    }

    RtlFreeHeap( CsrHeap, 0, ServerCaptureBuffer );
}



BOOLEAN
CsrValidateMessageBuffer(
    IN CONST CSR_API_MSG* m,
    IN VOID CONST * CONST * Buffer,
    IN ULONG Count,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine validates the given message buffer within the capture
    buffer of the CSR_API_MSG structure. The message buffer must be valid
    and of the correct size. This function should be called to validate
    any buffer allocated through CsrCaptureMessageBuffer.

Arguments:

    m - Pointer to CSR_API_MSG.

    Buffer - Pointer to message buffer.

    Count - number of elements in buffer.

    Size - size of each element in buffer.

Return Value:

    TRUE  - if message buffer is valid and of correct size.
    FALSE - otherwise.

--*/

{
    ULONG i;
    ULONG_PTR Length;
    ULONG_PTR EndOfBuffer;
    ULONG_PTR Offset;
    PCSR_CAPTURE_HEADER CaptureBuffer = m->CaptureBuffer;

    //
    // Check for buffer length overflow. Also, Size should not be 0.
    //

    if (Size && Count <= MAXULONG / Size) {

        //
        // If buffer is empty, we're done
        //

        Length = Count * Size;
        if (*Buffer == NULL && Length == 0) {
            return TRUE;
        }

        //
        // Make sure we have a capture area
        //

        if (CaptureBuffer) {

            //
            // Check for buffer length exceeding capture area size
            //

            EndOfBuffer = (ULONG_PTR)CaptureBuffer + CaptureBuffer->Length;
            if (Length <= (EndOfBuffer - (ULONG_PTR)(*Buffer))) {

                //
                // Search for buffer in capture area
                //

                Offset = (ULONG_PTR)Buffer - (ULONG_PTR)m;
                for (i = 0; i < CaptureBuffer->CountMessagePointers; i++) {
                    if (CaptureBuffer->MessagePointerOffsets[i] == Offset) {
                        return TRUE;
                    }
                }
            }
        } else {
            //
            // If this is called from the CSRSS process vis CsrCallServerFromServer,
            // then CaptureBuffer is NULL.  Verify that the caller is the CSRSS process.
            //
            if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
                return TRUE;
            }
        }
    }


    IF_DEBUG {
        DbgPrint("CSRSRV: Bad message buffer %p\n", m);
        SafeBreakPoint();
        }

    return FALSE;
}


BOOLEAN
CsrValidateMessageString(
    IN CONST CSR_API_MSG* m,
    IN CONST PCWSTR *Buffer
    ) {
    PCSR_CAPTURE_HEADER CaptureBuffer = m->CaptureBuffer;
    ULONG_PTR EndOfBuffer;
    ULONG_PTR Offset;
    ULONG i;
    PWCHAR cp;

    //
    // Make sure we have a capture area
    //

    cp = (PWCHAR)*Buffer;
    if (cp == NULL) {
        return TRUE;
    }

    if (CaptureBuffer) {

        //
        // Search for buffer in capture area
        //

        Offset = (ULONG_PTR)Buffer - (ULONG_PTR)m;
        for (i = 0; i < CaptureBuffer->CountMessagePointers; i++) {
            if (CaptureBuffer->MessagePointerOffsets[i] == Offset) {
                break;
            }
        }

        if (i >= CaptureBuffer->CountMessagePointers) {
            SafeBreakPoint();
            return FALSE;
        }

        //
        // Check unicode alignment.
        //

        if (((ULONG_PTR)cp & (sizeof (WCHAR) - 1)) != 0) {
            SafeBreakPoint();
            return FALSE;
        }

        //
        // Check for buffer length exceeding capture area size
        //

        EndOfBuffer = (ULONG_PTR)CaptureBuffer + CaptureBuffer->Length;

        //
        // The buffer is valid if we see a null before the end of the buffer
        //
        while (1) {
            if (cp < (PWCHAR)EndOfBuffer) {
                if (*cp == L'\0') {
                    return TRUE;
                }
            } else {
                SafeBreakPoint();
                return FALSE;
            }
            cp++;
        }
    } else {
        //
        // If this is called from the CSRSS process vis CsrCallServerFromServer,
        // then CaptureBuffer is NULL. Verify that the caller is the CSRSS process.
        //
        if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
            return TRUE;
        }
    }

    KdPrint(("CSRSRV: Bad message string %p\n", m));
    ASSERT(FALSE);

    return FALSE;
}

NTSTATUS
CsrApiHandleConnectionRequest(
    IN PCSR_API_MSG Message)
{
    NTSTATUS Status;
    REMOTE_PORT_VIEW ClientView;
    BOOLEAN AcceptConnection;
    HANDLE PortHandle;
    PCSR_PROCESS Process = NULL;
    PCSR_THREAD Thread;
    PCSR_API_CONNECTINFO ConnectionInformation;

    ConnectionInformation = &Message->ConnectionRequest;
    AcceptConnection = FALSE;

    AcquireProcessStructureLock();
    Thread = CsrLocateThreadByClientId(NULL, &Message->h.ClientId);
    if (Thread != NULL && (Process = Thread->Process) != NULL) {
        CsrLockedReferenceProcess(Process);
        Status = CsrSrvAttachSharedSection(Process, ConnectionInformation);
        if (NT_SUCCESS(Status)) {
#if DBG
            ConnectionInformation->DebugFlags = CsrDebug;
#endif
            AcceptConnection = TRUE;
        }
    }

    ReleaseProcessStructureLock();

    ClientView.Length = sizeof(ClientView);
    ClientView.ViewSize = 0;
    ClientView.ViewBase = 0;
    ConnectionInformation->ServerProcessId = NtCurrentTeb()->ClientId.UniqueProcess;
    Status = NtAcceptConnectPort(&PortHandle,
                                 AcceptConnection ? (PVOID)UlongToPtr(Process->SequenceNumber) : 0,
                                 &Message->h,
                                 AcceptConnection,
                                 NULL,
                                 &ClientView);
    if (NT_SUCCESS(Status) && AcceptConnection) {
        IF_CSR_DEBUG(LPC) {
            DbgPrint("CSRSS: ClientId: %lx.%lx has ClientView: Base=%p, Size=%lx\n",
                     Message->h.ClientId.UniqueProcess,
                     Message->h.ClientId.UniqueThread,
                     ClientView.ViewBase,
                     ClientView.ViewSize);
        }

        Process->ClientPort = PortHandle;
        Process->ClientViewBase = (PCH)ClientView.ViewBase;
        Process->ClientViewBounds = (PCH)ClientView.ViewBase + ClientView.ViewSize;
        Status = NtCompleteConnectPort(PortHandle);
        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrint("CSRSS: NtCompleteConnectPort - failed.  Status == %X\n",
                     Status);
#endif
        }
    } else {
        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrint("CSRSS: NtAcceptConnectPort - failed.  Status == %X\n",
                     Status);
#endif
        } else {
#if DBG
            DbgPrint("CSRSS: Rejecting Connection Request from ClientId: %lx.%lx\n",
                     Message->h.ClientId.UniqueProcess,
                     Message->h.ClientId.UniqueThread);
#endif
        }
    }

#if DBG
    {
        ULONG Index = GetNextTrackIndex();

        LpcTrackNodes[Index].Status = Status;
    }
#endif

    if (Process != NULL) {
        CsrDereferenceProcess(Process);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\sbinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbinit.c

Abstract:

    This module contains the code to initialize the SbApiPort of the
    Server side of the Client-Server Runtime Subsystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

NTSTATUS
CsrCreateLocalSystemSD( PSECURITY_DESCRIPTOR *ppSD )
{
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pLocalSystemSid;
    ULONG Length;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl;

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pLocalSystemSid
             );

    if (!NT_SUCCESS(Status)){
        pLocalSystemSid = NULL;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( pLocalSystemSid );

    pSD = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), Length);

    if (pSD == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    pDacl = (PACL)((PCHAR)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateSecurityDescriptor(
                pSD,
                SECURITY_DESCRIPTOR_REVISION
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlCreateAcl(
                pDacl,
                Length - SECURITY_DESCRIPTOR_MIN_LENGTH,
                ACL_REVISION2
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlAddAccessAllowedAce (
                 pDacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 pLocalSystemSid
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlSetDaclSecurityDescriptor (
                 pSD,
                 TRUE,
                 pDacl,
                 FALSE
             );

    if (NT_SUCCESS(Status)){
        *ppSD = pSD;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_EXIT;
    }

CSR_CREATE_LOCAL_SYSTEM_SD_ERROR:

    if (pSD != NULL) {
        RtlFreeHeap( CsrHeap, 0, pSD );
    }

CSR_CREATE_LOCAL_SYSTEM_SD_EXIT:

    if (pLocalSystemSid != NULL) {
        RtlFreeSid( pLocalSystemSid );
    }

    return Status;
}

NTSTATUS
CsrSbApiPortInitialize( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    CLIENT_ID ClientId;
    ULONG n;
    PSECURITY_DESCRIPTOR pCsrSbApiPortSD;

    n = CsrDirectoryName.Length +
        sizeof( CSR_SBAPI_PORT_NAME ) +
        sizeof( OBJ_NAME_PATH_SEPARATOR );
    CsrSbApiPortName.Buffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), n );
    if (CsrSbApiPortName.Buffer == NULL) {
        return( STATUS_NO_MEMORY );
        }
    CsrSbApiPortName.Length = 0;
    CsrSbApiPortName.MaximumLength = (USHORT)n;
    RtlAppendUnicodeStringToString( &CsrSbApiPortName, &CsrDirectoryName );
    RtlAppendUnicodeToString( &CsrSbApiPortName, L"\\" );
    RtlAppendUnicodeToString( &CsrSbApiPortName, CSR_SBAPI_PORT_NAME );

    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: Creating %wZ port and associated thread\n",
                  &CsrSbApiPortName );
        }

    Status = CsrCreateLocalSystemSD( &pCsrSbApiPortSD );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeObjectAttributes( &ObjectAttributes, &CsrSbApiPortName, 0,
                                NULL, pCsrSbApiPortSD );
    Status = NtCreatePort( &CsrSbApiPort,
                           &ObjectAttributes,
                           sizeof( SBCONNECTINFO ),
                           sizeof( SBAPIMSG ),
                           sizeof( SBAPIMSG ) * 32
                         );

    if (pCsrSbApiPortSD != NULL) {
        RtlFreeHeap( CsrHeap, 0, pCsrSbApiPortSD );
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = RtlCreateUserThread( NtCurrentProcess(),
                                  NULL,
                                  TRUE,
                                  0,
                                  0,
                                  0,
                                  CsrSbApiRequestThread,
                                  NULL,
                                  &Thread,
                                  &ClientId
                                );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    CsrSbApiRequestThreadPtr = CsrAddStaticServerThread(Thread,&ClientId,0);

    Status = NtResumeThread( Thread, NULL );

    return( Status );
}


VOID
CsrSbApiPortTerminate(
    NTSTATUS Status
    )
{
    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: Closing Sb port and associated thread\n" );
        }
    NtTerminateThread( CsrSbApiRequestThreadPtr->ThreadHandle,
                       Status
                     );

    NtClose( CsrSbApiPort );
    NtClose( CsrSmApiPort );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\process.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module contains the worker routines called to create and
    maintain the application process structure for the Client-Server
    Runtime Subsystem to the Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 10-Oct-1990

Revision History:

--*/


#include "csrsrv.h"
#include <wchar.h>
// ProcessSequenceCount will never be a value less than FIRST_SEQUENCE_COUNT
// currently GDI needs 0 - 4 to be reserved.

ULONG ProcessSequenceCount = FIRST_SEQUENCE_COUNT;

#define THREAD_HASH_SIZE 256
#define THREAD_ID_TO_HASH(id)   (HandleToUlong(id)&(THREAD_HASH_SIZE-1))
LIST_ENTRY CsrThreadHashTable[THREAD_HASH_SIZE];


SECURITY_QUALITY_OF_SERVICE CsrSecurityQos = {
    sizeof(SECURITY_QUALITY_OF_SERVICE), SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING, FALSE
};

PCSR_PROCESS
FindProcessForShutdown(
    PLUID CallerLuid
    );

NTSTATUS
ReadUnicodeString(HANDLE ProcessHandle,
                  PUNICODE_STRING RemoteString,
                  PUNICODE_STRING LocalString
                  );

VOID
CsrpSetToNormalPriority(
    VOID
    )
{
    KPRIORITY SetBasePriority;

    SetBasePriority = FOREGROUND_BASE_PRIORITY + 4;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );
}

VOID
CsrpSetToShutdownPriority(
    VOID
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    KPRIORITY SetBasePriority;

    Status = RtlAdjustPrivilege(
                 SE_INC_BASE_PRIORITY_PRIVILEGE,
                 TRUE,
                 FALSE,
                 &WasEnabled);

    if (!NT_SUCCESS(Status))
        return;

    SetBasePriority = FOREGROUND_BASE_PRIORITY + 6;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );
}

VOID
CsrSetForegroundPriority(
    IN PCSR_PROCESS Process
    )
{
    PROCESS_FOREGROUND_BACKGROUND Fg;

    Fg.Foreground = TRUE;

    NtSetInformationProcess(
            Process->ProcessHandle,
            ProcessForegroundInformation,
            (PVOID)&Fg,
            sizeof(Fg)
            );
}

VOID
CsrSetBackgroundPriority(
    IN PCSR_PROCESS Process
    )
{
    PROCESS_FOREGROUND_BACKGROUND Fg;

    Fg.Foreground = FALSE;

    NtSetInformationProcess(
            Process->ProcessHandle,
            ProcessForegroundInformation,
            (PVOID)&Fg,
            sizeof(Fg)
            );
}


//
// Though this function does not seem to cleanup on failure, failure
// will cause Csrss to exit, so any allocated memory will be freed and
// any open handle will be closed.
//

NTSTATUS
CsrInitializeProcessStructure(
    VOID)
{
    NTSTATUS Status;
    ULONG i;

    Status = RtlInitializeCriticalSection(&CsrProcessStructureLock);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    CsrRootProcess = CsrAllocateProcess();
    if (CsrRootProcess == NULL) {
        return STATUS_NO_MEMORY;
    }

    InitializeListHead( &CsrRootProcess->ListLink );
    CsrRootProcess->ProcessHandle = (HANDLE) -1;
    CsrRootProcess->ClientId = NtCurrentTeb()->ClientId;
    for (i = 0; i < THREAD_HASH_SIZE; i++) {
        InitializeListHead(&CsrThreadHashTable[i]);
    }

    Status = RtlInitializeCriticalSection(&CsrWaitListsLock);

    return Status;
}


PCSR_PROCESS
CsrAllocateProcess(
    VOID)
{
    PCSR_PROCESS Process;
    ULONG ProcessSize;

    //
    // Allocate an Windows Process Object.  At the end of the process
    // structure is an array of pointers to each server DLL's per process
    // data.  The per process data is contained in the memory after the
    // array.
    //

    ProcessSize = (ULONG)QUAD_ALIGN(sizeof( CSR_PROCESS ) +
            (CSR_MAX_SERVER_DLL * sizeof(PVOID))) + CsrTotalPerProcessDataLength;
    Process = (PCSR_PROCESS)RtlAllocateHeap( CsrHeap, MAKE_TAG( PROCESS_TAG ),
                                             ProcessSize
                                           );
    if (Process == NULL) {
        return( NULL );
        }

    //
    // Initialize the fields of the process object
    //

    RtlZeroMemory( Process, ProcessSize);

    //
    // grab the ProcessSequenceNumber and increment it, making sure that it
    // is never less than FIRST_SEQUENCE_COUNT.
    //

    Process->SequenceNumber = ProcessSequenceCount++;

    if (ProcessSequenceCount < FIRST_SEQUENCE_COUNT)
        ProcessSequenceCount = FIRST_SEQUENCE_COUNT;

    CsrLockedReferenceProcess(Process);

    InitializeListHead( &Process->ThreadList );
    return( Process );
}


VOID
CsrDeallocateProcess(
    IN PCSR_PROCESS Process
    )
{
    RtlFreeHeap( CsrHeap, 0, Process );
}

//
// NOTE: The process structure lock must be held when calling this routine.
//
VOID
CsrInsertProcess(
    IN PCSR_PROCESS CallingProcess,
    IN PCSR_PROCESS Process
    )
{
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG i;

    ASSERT(ProcessStructureListLocked());

    InsertTailList( &CsrRootProcess->ListLink, &Process->ListLink );

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[i];
        if (LoadedServerDll && LoadedServerDll->AddProcessRoutine) {
            (*LoadedServerDll->AddProcessRoutine)(CallingProcess, Process);
            }
        }
}


//
// NOTE: The process structure lock must be held when calling this routine.
//
VOID
CsrRemoveProcess(
    IN PCSR_PROCESS Process
    )
{
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG i;

    ASSERT(ProcessStructureListLocked());

    RemoveEntryList( &Process->ListLink );
    ReleaseProcessStructureLock();

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[i];
        if (LoadedServerDll && LoadedServerDll->DisconnectRoutine) {
            (LoadedServerDll->DisconnectRoutine)(Process);
            }
        }

}

NTSTATUS
CsrCreateProcess(
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN PCSR_NT_SESSION Session,
    IN ULONG DebugFlags,
    IN PCLIENT_ID DebugUserInterface OPTIONAL
    )
{
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    NTSTATUS Status;
    ULONG i;
    PVOID ProcessDataPtr;
    CLIENT_ID CallingClientId;
    PCSR_THREAD CallingThread;
    PCSR_PROCESS CallingProcess;
    KERNEL_USER_TIMES TimeInfo;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    //
    // remember the client id of the calling process.
    //

    CallingClientId = CallingThread->ClientId;

    AcquireProcessStructureLock();

    //
    // look for calling thread.
    //

    CallingThread = CsrLocateThreadByClientId(&CallingProcess, &CallingClientId);
    if (CallingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    Process = CsrAllocateProcess();
    if (Process == NULL) {
        Status = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( Status );
        }

    //
    // copy per-process data from parent to child
    //

    CallingProcess = (CSR_SERVER_QUERYCLIENTTHREAD())->Process;
    ProcessDataPtr = (PVOID)QUAD_ALIGN(&Process->ServerDllPerProcessData[CSR_MAX_SERVER_DLL]);
    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        if (CsrLoadedServerDll[i] != NULL && CsrLoadedServerDll[i]->PerProcessDataLength) {
            Process->ServerDllPerProcessData[i] = ProcessDataPtr;
            RtlMoveMemory(ProcessDataPtr,
                          CallingProcess->ServerDllPerProcessData[i],
                          CsrLoadedServerDll[i]->PerProcessDataLength
                         );
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + CsrLoadedServerDll[i]->PerProcessDataLength);
        }
        else {
            Process->ServerDllPerProcessData[i] = NULL;
        }
    }

    Status = NtSetInformationProcess(
                ProcessHandle,
                ProcessExceptionPort,
                (PVOID)&CsrApiPort,
                sizeof(HANDLE)
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    //
    // If we are creating a process group, the group leader has the same
    // process id and sequence number of itself. If the leader dies and
    // his pid is recycled, the sequence number mismatch will prevent it
    // from being viewed as a group leader.
    //

    if ( DebugFlags & CSR_CREATE_PROCESS_GROUP ) {
        Process->ProcessGroupId = HandleToUlong(ClientId->UniqueProcess);
        Process->ProcessGroupSequence = Process->SequenceNumber;
        }
    else {
        Process->ProcessGroupId = CallingProcess->ProcessGroupId;
        Process->ProcessGroupSequence = CallingProcess->ProcessGroupSequence;
        }

    if ( DebugFlags & CSR_PROCESS_CONSOLEAPP ) {
        Process->Flags |= CSR_PROCESS_CONSOLEAPP;
        }

    DebugFlags &= ~(CSR_PROCESS_CONSOLEAPP | CSR_CREATE_PROCESS_GROUP);

    if ( !DebugFlags && CallingProcess->DebugFlags & CSR_DEBUG_PROCESS_TREE ) {
        Process->DebugFlags = CSR_DEBUG_PROCESS_TREE;
        Process->DebugUserInterface = CallingProcess->DebugUserInterface;
        }
    if ( DebugFlags & (CSR_DEBUG_THIS_PROCESS | CSR_DEBUG_PROCESS_TREE) &&
         ARGUMENT_PRESENT(DebugUserInterface) ) {
        Process->DebugFlags = DebugFlags;
        Process->DebugUserInterface = *DebugUserInterface;
        }


    if ( Process->DebugFlags ) {

        //
        // Process is being debugged, so set up debug port
        //

        Status = NtSetInformationProcess(
                    ProcessHandle,
                    ProcessDebugPort,
                    (PVOID)&CsrApiPort,
                    sizeof(HANDLE)
                    );
        ASSERT(NT_SUCCESS(Status));
        if ( !NT_SUCCESS(Status) ) {
            CsrDeallocateProcess( Process );
            ReleaseProcessStructureLock();
            return( STATUS_NO_MEMORY );
            }
        }
    //
    // capture the thread's createtime so that we can use
    // this as a sequence number
    //

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( Status );
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = ThreadHandle;

    ProtectHandle(ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );

    CsrReferenceNtSession(Session);
    Process->NtSession = Session;

    Process->ClientId = *ClientId;
    Process->ProcessHandle = ProcessHandle;

    CsrSetBackgroundPriority(Process);

    Process->ShutdownLevel = 0x00000280;

    CsrInsertProcess((CSR_SERVER_QUERYCLIENTTHREAD())->Process, Process);
    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


NTSTATUS
CsrDestroyProcess(
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ExitStatus
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD DyingThread;
    PCSR_PROCESS DyingProcess;

    CLIENT_ID DyingClientId;

    DyingClientId = *ClientId;

    AcquireProcessStructureLock();


    DyingThread = CsrLocateThreadByClientId( &DyingProcess,
                                             &DyingClientId
                                           );
    if (DyingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    // prevent multiple destroys from causing problems. Scottlu and Markl
    // beleive all known race conditions are now fixed. This is simply a
    // precaution since we know that if this happens we process reference
    // count underflow
    //

    if ( DyingProcess->Flags & CSR_PROCESS_DESTROYED ) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    DyingProcess->Flags |= CSR_PROCESS_DESTROYED;

    ListHead = &DyingProcess->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        DyingThread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        if ( DyingThread->Flags & CSR_THREAD_DESTROYED ) {
            ListNext = ListNext->Flink;
            continue;
            }
        else {
            DyingThread->Flags |= CSR_THREAD_DESTROYED;
            }
        AcquireWaitListsLock();
        if (DyingThread->WaitBlock != NULL) {
            CsrNotifyWaitBlock(DyingThread->WaitBlock,
                               NULL,
                               NULL,
                               NULL,
                               CSR_PROCESS_TERMINATING,
                               TRUE
                              );
            }
        ReleaseWaitListsLock();
        CsrLockedDereferenceThread(DyingThread);
        ListNext = ListHead->Flink;
        }

    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


NTSTATUS
CsrCreateThread(
    IN PCSR_PROCESS Process,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN BOOLEAN ValidateCaller
    )
{
    PCSR_THREAD Thread;
    CLIENT_ID CallingClientId;
    PCSR_THREAD CallingThread;
    PCSR_PROCESS CallingProcess;
    KERNEL_USER_TIMES TimeInfo;
    NTSTATUS Status;

    if (ValidateCaller)
    {
        CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

        //
        // remember the client id of the calling process.
        //

        CallingClientId = CallingThread->ClientId;

        AcquireProcessStructureLock();

        //
        // look for calling thread.
        //

        CallingThread = CsrLocateThreadByClientId( &CallingProcess,
                                                   &CallingClientId
                                                 );
        if (CallingThread == NULL) {
            ReleaseProcessStructureLock();
            return STATUS_THREAD_IS_TERMINATING;
        }
    } else {
        AcquireProcessStructureLock();
	}
    
    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ReleaseProcessStructureLock();
        return( Status );
        }

    if (Process->Flags & CSR_PROCESS_DESTROYED) {
        IF_DEBUG {
            DbgPrint("CSRSS: CsrCreateThread - process %p is destroyed\n", Process);
            }
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = ThreadHandle;

    ProtectHandle(ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );
    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}

NTSTATUS
CsrCreateRemoteThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId
    )
{
    PCSR_THREAD Thread;
    PCSR_PROCESS Process;
    NTSTATUS Status;
    HANDLE hThread;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return( Status );
        }

    Status = CsrLockProcessByClientId( ClientId->UniqueProcess,
                                       &Process
                                     );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    //
    // Don't create the thread structure if the thread
    // has already terminated.
    //

    if ( TimeInfo.ExitTime.QuadPart != 0 ) {
        CsrUnlockProcess( Process );
        return( STATUS_THREAD_IS_TERMINATING );
    }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrUnlockProcess( Process );
        return( STATUS_NO_MEMORY );
        }
    Status = NtDuplicateObject(
                NtCurrentProcess(),
                ThreadHandle,
                NtCurrentProcess(),
                &hThread,
                0L,
                0L,
                DUPLICATE_SAME_ACCESS
                );
    if (!NT_SUCCESS(Status)) {
        hThread = ThreadHandle;
    }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = hThread;

    ProtectHandle(hThread);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );
    CsrUnlockProcess( Process );
    return STATUS_SUCCESS;
}


NTSTATUS
CsrDestroyThread(
    IN PCLIENT_ID ClientId
    )
{
    CLIENT_ID DyingClientId;
    PCSR_THREAD DyingThread;
    PCSR_PROCESS DyingProcess;

    DyingClientId = *ClientId;

    AcquireProcessStructureLock();

    DyingThread = CsrLocateThreadByClientId( &DyingProcess,
                                             &DyingClientId
                                           );
    if (DyingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    if ( DyingThread->Flags & CSR_THREAD_DESTROYED ) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
        }
    else {
        DyingThread->Flags |= CSR_THREAD_DESTROYED;
        }

    AcquireWaitListsLock();
    if (DyingThread->WaitBlock != NULL) {
        CsrNotifyWaitBlock(DyingThread->WaitBlock,
                           NULL,
                           NULL,
                           NULL,
                           CSR_PROCESS_TERMINATING,
                           TRUE
                          );
        }
    ReleaseWaitListsLock();
    CsrLockedDereferenceThread(DyingThread);

    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


PCSR_THREAD
CsrAllocateThread(
    IN PCSR_PROCESS Process
    )
{
    PCSR_THREAD Thread;
    ULONG ThreadSize;

    //
    // Allocate an Windows Thread Object.
    //

    ThreadSize = QUAD_ALIGN(sizeof( CSR_THREAD ));
    Thread = (PCSR_THREAD)RtlAllocateHeap( CsrHeap, MAKE_TAG( THREAD_TAG ),
                                           ThreadSize
                                         );
    if (Thread == NULL) {
        return( NULL );
        }

    //
    // Initialize the fields of the thread object
    //

    RtlZeroMemory( Thread, ThreadSize );

    CsrLockedReferenceThread(Thread);
    CsrLockedReferenceProcess(Process);
    Thread->Process = Process;

    return( Thread );
}


VOID
CsrDeallocateThread(
    IN PCSR_THREAD Thread
    )
{
    ASSERT (Thread->WaitBlock == NULL);
    RtlFreeHeap( CsrHeap, 0, Thread );
}


//
// NOTE: The process structure lock must be held while calling this routine.
//
VOID
CsrInsertThread(
    IN PCSR_PROCESS Process,
    IN PCSR_THREAD Thread)
{
    ULONG i;
    
    ASSERT(ProcessStructureListLocked());

    InsertTailList(&Process->ThreadList, &Thread->Link);
    Process->ThreadCount++;
    i = THREAD_ID_TO_HASH(Thread->ClientId.UniqueThread);
    InsertHeadList(&CsrThreadHashTable[i], &Thread->HashLinks);
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
VOID
CsrRemoveThread(
    IN PCSR_THREAD Thread)
{
    ASSERT(ProcessStructureListLocked());

    RemoveEntryList(&Thread->Link);
    Thread->Process->ThreadCount--;

    if (Thread->HashLinks.Flink) {
        RemoveEntryList(&Thread->HashLinks);
    }

    //
    // If this is the last thread, then make sure we undo the reference
    // that this thread had on the process.
    //
    if (Thread->Process->ThreadCount == 0) {
        if (!(Thread->Process->Flags & CSR_PROCESS_LASTTHREADOK)) {
            Thread->Process->Flags |= CSR_PROCESS_LASTTHREADOK;
            CsrLockedDereferenceProcess(Thread->Process);
        }
    }

    Thread->Flags |= CSR_THREAD_TERMINATING;
}


NTSTATUS
CsrLockProcessByClientId(
    IN HANDLE UniqueProcessId,
    OUT PCSR_PROCESS *Process
    )
{
    NTSTATUS Status;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS ProcessPtr;


    AcquireProcessStructureLock();

    ASSERT( Process != NULL );
    *Process = NULL;

    Status = STATUS_UNSUCCESSFUL;
    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead;
    do  {
        ProcessPtr = CONTAINING_RECORD( ListNext, CSR_PROCESS, ListLink );
        if (ProcessPtr->ClientId.UniqueProcess == UniqueProcessId) {
            Status = STATUS_SUCCESS;
            break;
            }
        ListNext = ListNext->Flink;
        } while (ListNext != ListHead);

    if (NT_SUCCESS( Status )) {
        CsrLockedReferenceProcess(ProcessPtr);
        *Process = ProcessPtr;
        }
    else {
        ReleaseProcessStructureLock();
        }

    return( Status );
}

NTSTATUS
CsrUnlockProcess(
    IN PCSR_PROCESS Process
    )
{
    CsrLockedDereferenceProcess( Process );
    ReleaseProcessStructureLock();
    return( STATUS_SUCCESS );
}

NTSTATUS
CsrLockThreadByClientId(
    IN HANDLE UniqueThreadId,
    OUT PCSR_THREAD *Thread)
{
    NTSTATUS Status;
    ULONG Index;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD ThreadPtr;

    AcquireProcessStructureLock();

    ASSERT(Thread != NULL);

    Index = THREAD_ID_TO_HASH(UniqueThreadId);

    ListHead = &CsrThreadHashTable[Index];
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ThreadPtr = CONTAINING_RECORD( ListNext, CSR_THREAD, HashLinks );
        if (ThreadPtr->ClientId.UniqueThread == UniqueThreadId &&
             !(ThreadPtr->Flags & CSR_THREAD_DESTROYED)) {
            break;
        }

        ListNext = ListNext->Flink;
    }

    if (ListNext != ListHead) {
        *Thread = ThreadPtr;
        Status = STATUS_SUCCESS;
        CsrLockedReferenceThread(ThreadPtr);
    } else {
        Status = STATUS_UNSUCCESSFUL;
        ReleaseProcessStructureLock();
    }

    return Status;
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
NTSTATUS
CsrUnlockThread(
    IN PCSR_THREAD Thread)
{
    ASSERT(ProcessStructureListLocked());

    CsrLockedDereferenceThread(Thread);
    ReleaseProcessStructureLock();

    return STATUS_SUCCESS;
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
PCSR_THREAD
CsrLocateThreadByClientId(
    OUT PCSR_PROCESS *Process OPTIONAL,
    IN PCLIENT_ID ClientId)
{
    ULONG Index;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD Thread;

    ASSERT(ProcessStructureListLocked());

    Index = THREAD_ID_TO_HASH(ClientId->UniqueThread);

    if (ARGUMENT_PRESENT(Process)) {
        *Process = NULL;
    }

    ListHead = &CsrThreadHashTable[Index];
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, HashLinks );
        if (Thread->ClientId.UniqueThread == ClientId->UniqueThread &&
            Thread->ClientId.UniqueProcess == ClientId->UniqueProcess) {
            if (ARGUMENT_PRESENT(Process)) {
                *Process = Thread->Process;
            }

            return Thread;
        }

        ListNext = ListNext->Flink;
    }

    return NULL;
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
PCSR_THREAD
CsrLocateServerThread(
    IN PCLIENT_ID ClientId)
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD Thread;

    ListHead = &CsrRootProcess->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        if (Thread->ClientId.UniqueThread == ClientId->UniqueThread) {
            return Thread;
        }

        ListNext = ListNext->Flink;
    }

    return NULL;
}

BOOLEAN
CsrImpersonateClient(
    IN PCSR_THREAD Thread)
{
    NTSTATUS Status;
    PCSR_THREAD CallingThread;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    if (Thread == NULL) {
        Thread = CallingThread;
        if (Thread == NULL) {
            return FALSE;
        }
    }

    Status = NtImpersonateThread(NtCurrentThread(),
                                 Thread->ThreadHandle,
                                 &CsrSecurityQos);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: Can't impersonate client thread - Status = %lx\n",
                     Status);
            if (Status != STATUS_BAD_IMPERSONATION_LEVEL) {
                DbgBreakPoint();
            }
        }

        return FALSE;
    }

    //
    // Keep track of recursion by printer drivers.
    //
    if (CallingThread != NULL) {
        ++CallingThread->ImpersonateCount;
    }

    return TRUE;
}

BOOLEAN
CsrRevertToSelf(
    VOID)
{
    HANDLE NewToken;
    NTSTATUS Status;
    PCSR_THREAD CallingThread;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    //
    // Keep track of recursion by printer drivers.
    //
    if (CallingThread != NULL) {
        if (CallingThread->ImpersonateCount == 0) {
            IF_DEBUG {
                DbgPrint( "CSRSS: CsrRevertToSelf called while not impersonating\n" );
                DbgBreakPoint();
            }

            return FALSE;
        }

        if (--CallingThread->ImpersonateCount > 0) {
            return TRUE;
        }
    }

    NewToken = NULL;
    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID)&NewToken,
                                    (ULONG)sizeof(HANDLE));
    ASSERT(NT_SUCCESS(Status));
    return NT_SUCCESS(Status);
}

/*++

Routine Description:

    This function must be called by client DLL's whenever they create a
    thread that runs in the context of CSR.  This function is not called
    for server threads that are attached to a client in the "server
    handle" field.  This function replaces the old static thread tables.

Arguments:

    ThreadHandle - Supplies a handle to the thread.

    ClientId - Supplies the address of the thread's client id.

    Flags - Not Used.

Return Value:

    Returns the address of the static server thread created by this
    function.

--*/

PVOID
CsrAddStaticServerThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN ULONG Flags
    )
{
    PCSR_THREAD Thread;

    AcquireProcessStructureLock();

    ASSERT(CsrRootProcess != NULL);
    Thread = CsrAllocateThread(CsrRootProcess);
    if (Thread) {
        Thread->ThreadHandle = ThreadHandle;

        ProtectHandle(ThreadHandle);

        Thread->ClientId = *ClientId;
        Thread->Flags = Flags;
        InsertTailList(&CsrRootProcess->ThreadList, &Thread->Link);
        CsrRootProcess->ThreadCount++;
    }

    ReleaseProcessStructureLock();
    return (PVOID)Thread;
}

NTSTATUS
CsrExecServerThread(
    IN PUSER_THREAD_START_ROUTINE StartAddress,
    IN ULONG Flags
    )
{
    PCSR_THREAD Thread;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;

    AcquireProcessStructureLock();

    ASSERT(CsrRootProcess != NULL);
    Thread = CsrAllocateThread(CsrRootProcess);
    if (Thread == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 FALSE,
                                 0,
                                 0,
                                 0,
                                 (PUSER_THREAD_START_ROUTINE)StartAddress,
                                 NULL,
                                 &ThreadHandle,
                                 &ClientId);
    if (NT_SUCCESS(Status)) {
        Thread->ThreadHandle = ThreadHandle;

        ProtectHandle(ThreadHandle);

        Thread->ClientId = ClientId;
        Thread->Flags = Flags;
        InsertTailList(&CsrRootProcess->ThreadList, &Thread->Link);
        CsrRootProcess->ThreadCount++;
    } else {
        CsrDeallocateThread(Thread);
    }

Exit:
    ReleaseProcessStructureLock();
    return Status;
}



VOID
CsrReferenceThread(
    PCSR_THREAD t
    )
{
    ASSERT (t != NULL);

    AcquireProcessStructureLock();

    ASSERT((t->Flags & CSR_THREAD_DESTROYED) == 0);
    ASSERT(t->ReferenceCount != 0);

    t->ReferenceCount++;
    ReleaseProcessStructureLock();
}

VOID
CsrProcessRefcountZero(
    PCSR_PROCESS p
    )
{
    ASSERT (p != NULL);

    CsrRemoveProcess(p);
    if (p->NtSession) {
        CsrDereferenceNtSession(p->NtSession,0);
    }

    //
    // process might not have made it through dll init routine.
    //

    if ( p->ClientPort ) {
        NtClose(p->ClientPort);
    }
    NtClose(p->ProcessHandle );
    CsrDeallocateProcess(p);
}

VOID
CsrDereferenceProcess(
    PCSR_PROCESS p
    )
{
    LONG LockCount;

    ASSERT (p != NULL);

    AcquireProcessStructureLock();

    LockCount = --(p->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrProcessRefcountZero(p);
    } else {
        ReleaseProcessStructureLock();
    }
}

VOID
CsrThreadRefcountZero(
    PCSR_THREAD t
    )
{
    PCSR_PROCESS p;
    NTSTATUS Status;

    ASSERT (t != NULL);
    p = t->Process;
    ASSERT (p != NULL);

    CsrRemoveThread(t);

    ReleaseProcessStructureLock();

    UnProtectHandle(t->ThreadHandle);
    Status = NtClose(t->ThreadHandle);
    ASSERT(NT_SUCCESS(Status));
    CsrDeallocateThread(t);

    CsrDereferenceProcess(p);
}

ULONG
CsrDereferenceThread(
    PCSR_THREAD t)
{
    ULONG LockCount;

    
    ASSERT (t != NULL);

    AcquireProcessStructureLock();

    ASSERT(t->ReferenceCount > 0);

    LockCount = --(t->ReferenceCount);
    if (!LockCount) {
        CsrThreadRefcountZero(t);
    } else {
        ReleaseProcessStructureLock();
    }

    return LockCount;
}

VOID
CsrLockedReferenceProcess(
    PCSR_PROCESS p)
{
    ASSERT (p != NULL);
    p->ReferenceCount++;
}

VOID
CsrLockedReferenceThread(
    PCSR_THREAD t)
{
    ASSERT (t != NULL);
    t->ReferenceCount++;
}

VOID
CsrLockedDereferenceProcess(
    PCSR_PROCESS p)
{
    LONG LockCount;

    ASSERT (p != NULL);

    LockCount = --(p->ReferenceCount);

    ASSERT(LockCount >= 0);
    if (!LockCount) {
        CsrProcessRefcountZero(p);
        AcquireProcessStructureLock();
    }
}

VOID
CsrLockedDereferenceThread(
    PCSR_THREAD t
    )
{
    LONG LockCount;

    ASSERT (t != NULL);

    LockCount = --(t->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrThreadRefcountZero(t);
        AcquireProcessStructureLock();
    }
}

//
// This routine will shutdown processes so either a logoff or a shutdown can
// occur. This simply calls the shutdown process handlers for each .dll until
// one .dll recognizes this process and will shut it down. Only the processes
// with the passed sid are shutdown.
//

NTSTATUS
CsrShutdownProcesses(
    PLUID CallerLuid,
    ULONG Flags
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    ULONG i;
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG Command;
    BOOLEAN fFirstPass;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    AcquireProcessStructureLock();

    //
    // Mark the root process as system context.
    //
    CsrRootProcess->ShutdownFlags |= SHUTDOWN_SYSTEMCONTEXT;

    //
    // Clear all the bits indicating that shutdown has visited the existing
    // processes.
    //
    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Process = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        Process->Flags &= ~CSR_PROCESS_SHUTDOWNSKIP;
        Process->ShutdownFlags = 0;
        ListNext = ListNext->Flink;
    }

    CsrpSetToShutdownPriority();
    while (TRUE) {
        //
        // Find the next process to shutdown.
        //
        Process = FindProcessForShutdown(CallerLuid);
        if (Process == NULL) {
            ReleaseProcessStructureLock();
            Status = STATUS_SUCCESS;
            break;
        }

        CsrLockedReferenceProcess(Process);

        fFirstPass = TRUE;
TryAgain:
        for (i = 0; i < CSR_MAX_SERVER_DLL; i++) {
            LoadedServerDll = CsrLoadedServerDll[i];
            if (LoadedServerDll && LoadedServerDll->ShutdownProcessRoutine) {
                //
                // Release process structure lock before calling off.
                // CSR_PROCESS structure is still reference counted.
                //
                ReleaseProcessStructureLock();
                Command = (*LoadedServerDll->ShutdownProcessRoutine)(Process,
                                                                     Flags,
                                                                     fFirstPass);
                AcquireProcessStructureLock();

                if (Command == SHUTDOWN_KNOWN_PROCESS) {
                    //
                    // Process structure is unlocked.
                    //
                    break;
                } else if (Command == SHUTDOWN_UNKNOWN_PROCESS) {
                    //
                    // Process structure is locked.
                    //
                    continue;
                } else if (Command == SHUTDOWN_CANCEL) {
#if DBG
                    if (Flags & 4) {
                        DbgPrint("Process %x cancelled forced shutdown\n",
                                 Process->ClientId.UniqueProcess);
                        DbgBreakPoint();
                    }
#endif
                    //
                    // Unlock process structure.
                    //
                    ReleaseProcessStructureLock();
                    Status = STATUS_CANCELLED;
                    goto ExitLoop;
                }
            }
        }

        //
        // No subsystem has an exact match. Now go through them again and
        // let them know there was no exact match. Some .dll should terminate
        // it for us (most likely, console).
        //
        if (fFirstPass && Command == SHUTDOWN_UNKNOWN_PROCESS) {
            fFirstPass = FALSE;
            goto TryAgain;
        }

        //
        // Dereference this process structure if nothing knows about it.
        //
        if (i == CSR_MAX_SERVER_DLL) {
            CsrLockedDereferenceProcess(Process);
        }
    }

ExitLoop:

    CsrpSetToNormalPriority();

    return Status;
}

PCSR_PROCESS
FindProcessForShutdown(
    PLUID CallerLuid)
{
    LUID ProcessLuid;
    LUID SystemLuid = SYSTEM_LUID;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    PCSR_PROCESS ProcessT = NULL;
    PCSR_THREAD Thread;
    ULONG dwLevel = 0;
    NTSTATUS Status;

    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Process = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        ListNext = ListNext->Flink;

        //
        // If we've visited this process already, then skip it.
        //
        if (Process->Flags & CSR_PROCESS_SHUTDOWNSKIP) {
            continue;
        }

        //
        // See if this process is running under the passed sid. If not, mark
        // it as visited and continue.
        //
        Status = CsrGetProcessLuid(Process->ProcessHandle, &ProcessLuid);
        if (Status == STATUS_ACCESS_DENIED && Process->ThreadCount > 0) {
            //
            // Impersonate one of the threads and try again.
            //
            Thread = CONTAINING_RECORD(Process->ThreadList.Flink, CSR_THREAD, Link);
            if (CsrImpersonateClient(Thread)) {
                Status = CsrGetProcessLuid(NULL, &ProcessLuid);
                CsrRevertToSelf();
            } else {
                Status = STATUS_BAD_IMPERSONATION_LEVEL;
            }
        }

        if (!NT_SUCCESS(Status)) {
            //
            // We don't have access to this process's luid, so skip it.
            //
            Process->Flags |= CSR_PROCESS_SHUTDOWNSKIP;
            continue;
        }

        //
        // Is it equal to the system context luid? If so, we want to
        // remember this because we don't terminate this process: we only
        // notify them.
        //
        if (RtlEqualLuid(&ProcessLuid, &SystemLuid)) {
            Process->ShutdownFlags |= SHUTDOWN_SYSTEMCONTEXT;
        } else {
            //
            // See if this process's luid is the same as the luid we're supposed
            // to shut down (CallerSid).
            //
            if (!RtlEqualLuid(&ProcessLuid, CallerLuid)) {
                //
                // If not equal to either, mark it as such.
                //
                Process->ShutdownFlags |= SHUTDOWN_OTHERCONTEXT;
            }
        }

        if (Process->ShutdownLevel > dwLevel || ProcessT == NULL) {
            dwLevel = Process->ShutdownLevel;
            ProcessT = Process;
        }
    }

    if (ProcessT != NULL) {
        ProcessT->Flags |= CSR_PROCESS_SHUTDOWNSKIP;
        return ProcessT;
    }

    return NULL;
}

NTSTATUS
CsrGetProcessLuid(
    HANDLE ProcessHandle,
    PLUID LuidProcess
    )
{
    HANDLE UserToken = NULL;
    PTOKEN_STATISTICS pStats;
    ULONG BytesRequired;
    NTSTATUS Status, CloseStatus;

    if (ProcessHandle == NULL) {

        //
        // Check for a thread token first
        //

        Status = NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY, FALSE,
                &UserToken);

        if (!NT_SUCCESS(Status)) {
            if (Status != STATUS_NO_TOKEN)
                return Status;

            //
            // No thread token, go to the process
            //

            ProcessHandle = NtCurrentProcess();
            UserToken = NULL;
            }
        }

    if (UserToken == NULL) {
        Status = NtOpenProcessToken(ProcessHandle, TOKEN_QUERY, &UserToken);
        if (!NT_SUCCESS(Status))
            return Status;
        }

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenStatistics,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        NtClose(UserToken);
        return Status;
        }

    //
    // Allocate space for the user info
    //

    pStats = (PTOKEN_STATISTICS)RtlAllocateHeap(CsrHeap, MAKE_TAG( TMP_TAG ), BytesRequired);
    if (pStats == NULL) {
        NtClose(UserToken);
        return Status;
        }

    //
    // Read in the user info
    //

    Status = NtQueryInformationToken(
                 UserToken,             // Handle
                 TokenStatistics,       // TokenInformationClass
                 pStats,                // TokenInformation
                 BytesRequired,         // TokenInformationLength
                 &BytesRequired         // ReturnLength
                 );

    //
    // We're finished with the token handle
    //

    CloseStatus = NtClose(UserToken);
    ASSERT(NT_SUCCESS(CloseStatus));

    //
    // Return the authentication LUID
    //

    *LuidProcess = pStats->AuthenticationId;

    RtlFreeHeap(CsrHeap, 0, pStats);
    return Status;
}

VOID
CsrSetCallingSpooler(
    BOOLEAN fSet)
{
    //
    // Obsolete function that may be called by third part drivers.
    //

    UNREFERENCED_PARAMETER(fSet);
}

//
// This routine creates a process based on a message passed in to sb port.
// Used by smss to have Posix and OS/2 apps created in the appropriate
// (terminal server) session.
//

BOOLEAN
CsrSbCreateProcess(
    IN OUT PSBAPIMSG m
    )
{
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PROCESS_SESSION_INFORMATION ProcessInfo;
    PSBCREATEPROCESS a = &(m->u.CreateProcess);
    HANDLE RemoteProcess = NULL;
    CLIENT_ID RemoteClientId;
    UNICODE_STRING ImageFileName, DefaultLibPath, CurrentDirectory, CommandLine;
    PVOID DefaultEnvironment = NULL;
    PROCESS_BASIC_INFORMATION ProcInfo;
    OBJECT_ATTRIBUTES ObjA;

    RtlInitUnicodeString(&ImageFileName,NULL);
    RtlInitUnicodeString(&DefaultLibPath,NULL);
    RtlInitUnicodeString(&CurrentDirectory,NULL);
    RtlInitUnicodeString(&CommandLine,NULL);

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessBasicInformation,
                                       &ProcInfo,
                                       sizeof(ProcInfo),
                                       NULL
                                       );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtQueryInformationProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    RemoteClientId.UniqueProcess = (HANDLE)ProcInfo.InheritedFromUniqueProcessId;
    RemoteClientId.UniqueThread = NULL;

    Status = NtOpenProcess(&RemoteProcess,
                           PROCESS_ALL_ACCESS,
                           &ObjA,
                           &RemoteClientId);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtOpenProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    //
    // Read pointer parameters from calling process's virtual memory
    //

    Status = ReadUnicodeString(RemoteProcess,a->i.ImageFileName,&ImageFileName);


    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString ImageFileName failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.DefaultLibPath,&DefaultLibPath);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString DefaultLibPath failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.CurrentDirectory,&CurrentDirectory);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString CurrentDirectory failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.CommandLine,&CommandLine);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString CommandLine failed - Status = %lx\n", Status );
        goto Done;
    }

    //
    // Copy our environment to be used by new process
    //
    Status = RtlCreateEnvironment(TRUE, &DefaultEnvironment);

    if (!NT_SUCCESS( Status )) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: Can't create environemnt\n");
        goto Done;
    }

    Status = RtlCreateProcessParameters( &ProcessParameters,
                                         &ImageFileName,
                                         DefaultLibPath.Length == 0 ?
                                            NULL : &DefaultLibPath,
                                         &CurrentDirectory,
                                         &CommandLine,
                                         DefaultEnvironment,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL
                                       );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: RtlCreateProcessParameters failed - Status = %lx\n", Status );
        goto Done;
    }
    if (a->i.Flags & SMP_DEBUG_FLAG) {
        ProcessParameters->DebugFlags = TRUE;
        }
    else {
        ProcessParameters->DebugFlags = a->i.DefaultDebugFlags;
        }

    if ( a->i.Flags & SMP_SUBSYSTEM_FLAG ) {
        ProcessParameters->Flags |= RTL_USER_PROC_RESERVE_1MB;
        }

    ProcessInformation.Length = sizeof( RTL_USER_PROCESS_INFORMATION );
    Status = RtlCreateUserProcess( &ImageFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   ProcessParameters,
                                   NULL,
                                   NULL,
                                   RemoteProcess, // set smss as the parent
                                   FALSE,
                                   NULL,
                                   NULL,
                                   &ProcessInformation
                                 );

    RtlDestroyProcessParameters( ProcessParameters );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: RtlCreateUserProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    if (IsTerminalServer()) {

        //
        // Set the MuSessionId in the PEB of the new process
        //

        ProcessInfo.SessionId = NtCurrentPeb()->SessionId;
        if (ProcessInfo.SessionId) {
            PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
            UNICODE_STRING UnicodeString;
            OBJECT_ATTRIBUTES Attributes;
            HANDLE DirectoryHandle = NULL;
            WCHAR szSessionString[MAX_SESSION_PATH];

            //
            // Change the devmap of the process to per session.
            //
            swprintf(szSessionString, L"%ws\\%ld%ws", SESSION_ROOT, NtCurrentPeb()->SessionId, DOSDEVICES);
            RtlInitUnicodeString(&UnicodeString, szSessionString);

            InitializeObjectAttributes(&Attributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
            Status = NtOpenDirectoryObject(&DirectoryHandle,
                                           DIRECTORY_ALL_ACCESS,
                                           &Attributes);
            if (!NT_SUCCESS(Status)) {
                DbgPrint("CSRSS: NtOpenDirectoryObject failed in CsrSbCreateProcess - status = %lx\n", Status);
                goto Done;
            }

            ProcessDeviceMapInfo.Set.DirectoryHandle = DirectoryHandle;
            Status = NtSetInformationProcess(ProcessInformation.Process,
                                             ProcessDeviceMap,
                                             &ProcessDeviceMapInfo.Set,
                                             sizeof(ProcessDeviceMapInfo.Set));
            if (!NT_SUCCESS( Status )) {
                DbgPrint("CSRSS: NtSetInformationProcess failed in CsrSbCreateProcess - status = %lx\n", Status);
                if (DirectoryHandle) {
                    NtClose(DirectoryHandle);
                }

                goto Done;
            }

            if (DirectoryHandle) {
                NtClose(DirectoryHandle);
            }
        }

        Status = NtSetInformationProcess( ProcessInformation.Process,
                                          ProcessSessionInformation,
                                          &ProcessInfo, sizeof( ProcessInfo ));

        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "CSRSS: CsrSrvCreateProcess: NtSetInformationProcess failed - Status = %lx\n", Status );
            goto Done;
        }
    }

    if (!(a->i.Flags & SMP_DONT_START)) {
        if (ProcessInformation.ImageInformation.SubSystemType !=
            IMAGE_SUBSYSTEM_NATIVE
           ) {
            NtTerminateProcess( ProcessInformation.Process,
                                STATUS_INVALID_IMAGE_FORMAT
                              );

            NtWaitForSingleObject( ProcessInformation.Thread, FALSE, NULL );

            NtClose( ProcessInformation.Thread );
            NtClose( ProcessInformation.Process );

            Status = STATUS_INVALID_IMAGE_FORMAT;
            goto Done;
        }

        Status = NtResumeThread( ProcessInformation.Thread, NULL );
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "CSRSS: CsrSrvCreateProcess - NtResumeThread failed Status %lx\n",Status );
            goto Done;
        }

        if (!(a->i.Flags & SMP_ASYNC_FLAG)) {
            NtWaitForSingleObject( ProcessInformation.Thread, FALSE, NULL );
        }

        NtClose( ProcessInformation.Thread );
        NtClose( ProcessInformation.Process );

    }

    //
    // Copy output parameters to message
    //
    a->o.SubSystemType = ProcessInformation.ImageInformation.SubSystemType;
    a->o.ClientId.UniqueProcess = ProcessInformation.ClientId.UniqueProcess;
    a->o.ClientId.UniqueThread = ProcessInformation.ClientId.UniqueThread;

    //
    // Convert handles to caller's process
    //

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ProcessInformation.Process,
                                RemoteProcess,
                                &a->o.Process,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtDuplicateObject failed for process - Status = %lx\n", Status );
        goto Done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ProcessInformation.Thread,
                                RemoteProcess,
                                &a->o.Thread,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtDuplicateObject failed for thread - Status = %lx\n", Status );
        goto Done;
    }

Done:
    if (NULL != ImageFileName.Buffer)
        RtlFreeHeap(CsrHeap,0,ImageFileName.Buffer);
    if (NULL != DefaultLibPath.Buffer)
        RtlFreeHeap(CsrHeap,0,DefaultLibPath.Buffer);
    if (NULL != CurrentDirectory.Buffer)
        RtlFreeHeap(CsrHeap,0,CurrentDirectory.Buffer);
    if (NULL != CommandLine.Buffer)
        RtlFreeHeap(CsrHeap,0,CommandLine.Buffer);
    if (NULL != RemoteProcess)
        NtClose(RemoteProcess);

    m->ReturnedStatus = Status;
    return TRUE;
}

//
// This routine will copy a UNICODE_STRING from a remote process to this one
//
NTSTATUS
ReadUnicodeString(HANDLE ProcessHandle,
                  PUNICODE_STRING RemoteString,
                  PUNICODE_STRING LocalString
                  )
{
    PWSTR Buffer = NULL;
    NTSTATUS Status;

    RtlInitUnicodeString(LocalString, NULL);

    if (NULL != RemoteString) {
        Status = NtReadVirtualMemory(ProcessHandle,
                                     RemoteString,
                                     LocalString,
                                     sizeof(UNICODE_STRING),
                                     NULL);

        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "CSRSS: ReadUnicodeString: NtReadVirtualMemory failed - Status = %lx\n", Status );
            return Status;
        }

        if ((0 != LocalString->Length) && (NULL != LocalString->Buffer)) {
            Buffer = RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( PROCESS_TAG ),
                                      LocalString->Length + sizeof(WCHAR)
                                      );

            if (Buffer == NULL) {
                return STATUS_NO_MEMORY;
            }

            Status = NtReadVirtualMemory(ProcessHandle,
                                         LocalString->Buffer,
                                         Buffer,
                                         LocalString->Length + sizeof(WCHAR),
                                         NULL);

            if ( !NT_SUCCESS( Status ) ) {
                DbgPrint( "CSRSS: ReadUnicodeString: NtReadVirtualMemory Buffer failed - Status = %lx\n", Status );

                RtlFreeHeap(CsrHeap,0,Buffer);
                LocalString->Buffer = NULL;   // don't want caller to free this

                return Status;
            }

            LocalString->Buffer = Buffer;
        }
    }

    return STATUS_SUCCESS;
}

#if CSRSS_PROTECT_HANDLES
BOOLEAN
ProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = TRUE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}


BOOLEAN
UnProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = FALSE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}
#endif // CSRSS_PROTECT_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\sbreqst.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbreqst.c

Abstract:

    This module contains the Server Request thread procedure for the Sb
    API calls exported by the Server side of the Client-Server Runtime
    Subsystem to the Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"

PSB_API_ROUTINE CsrServerSbApiDispatch[ SbMaxApiNumber+1 ] = {
    CsrSbCreateSession,
    CsrSbTerminateSession,
    CsrSbForeignSessionComplete,
    CsrSbCreateProcess,
    NULL
};

#if DBG
PSZ CsrServerSbApiName[ SbMaxApiNumber+1 ] = {
    "SbCreateSession",
    "SbTerminateSession",
    "SbForeignSessionComplete",
    "SbCreateProcess",
    "Unknown Csr Sb Api Number"
};
#endif // DBG


NTSTATUS
CsrSbApiHandleConnectionRequest(
    IN PSBAPIMSG Message
    );


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

NTSTATUS
CsrSbApiRequestThread(
    IN PVOID Parameter
    )
{
    NTSTATUS Status;
    SBAPIMSG ReceiveMsg;
    PSBAPIMSG ReplyMsg;
    HANDLE hConnectionPort;

    ReplyMsg = NULL;
    while (TRUE) {
        while (1) {
            Status = NtReplyWaitReceivePort (CsrSbApiPort,
                                             (PVOID)(&hConnectionPort),
                                             (PPORT_MESSAGE)ReplyMsg,
                                             (PPORT_MESSAGE)&ReceiveMsg);
            if (Status == STATUS_NO_MEMORY) {
                LARGE_INTEGER DelayTime;

                if (ReplyMsg != NULL) {
                    KdPrint (("CSRSS: Failed to reply to calling thread, retrying.\n"));
                }
                DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                NtDelayExecution (FALSE, &DelayTime);
                continue;
            }
            break;
        }

        if (Status != 0) {
            if (NT_SUCCESS( Status )) {
                continue;       // Try again if alerted or a failure
                }
            else {
                IF_DEBUG {
                    DbgPrint( "CSRSS: ReceivePort failed - Status == %X\n", Status );
                    }
                ReplyMsg = NULL;
                continue;
                }
            }

        //
        // Check to see if this is a connection request and handle
        //

        if (ReceiveMsg.h.u2.s2.Type == LPC_CONNECTION_REQUEST) {
            CsrSbApiHandleConnectionRequest( &ReceiveMsg );
            ReplyMsg = NULL;
            continue;
            }



        if (ReceiveMsg.h.u2.s2.Type == LPC_CLIENT_DIED ) {

            ReplyMsg = NULL;
            continue;
            }

        if (ReceiveMsg.h.u2.s2.Type == LPC_PORT_CLOSED ) {

            //
            // Close the handle to the connection's server communication port object
            //

            if (hConnectionPort != NULL) {
                NtClose( hConnectionPort );
                }
            ReplyMsg = NULL;
            continue;
            }

        if ((ULONG)ReceiveMsg.ApiNumber >= SbMaxApiNumber) {
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx is invalid Sb ApiNumber\n",
                          ReceiveMsg.ApiNumber
                        );
                }

            ReceiveMsg.ApiNumber = SbMaxApiNumber;
            }


        ReplyMsg = &ReceiveMsg;
        if (ReceiveMsg.ApiNumber < SbMaxApiNumber) {
            if (!(*CsrServerSbApiDispatch[ ReceiveMsg.ApiNumber ])( &ReceiveMsg )) {
                ReplyMsg = NULL;
                }
            }
        else {
            ReplyMsg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
            }

        }

    NtTerminateThread( NtCurrentThread(), Status );

    return( Status );   // Remove no return value warning.
    Parameter;          // Remove unreferenced parameter warning.
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

NTSTATUS
CsrSbApiHandleConnectionRequest(
    IN PSBAPIMSG Message
    )
{
    NTSTATUS st;
    REMOTE_PORT_VIEW ClientView;
    HANDLE CommunicationPort;

    //
    // The protocol for a subsystem is to connect to the session manager,
    // then to listen and accept a connection from the session manager
    //

    ClientView.Length = sizeof(ClientView);
    st = NtAcceptConnectPort(
            &CommunicationPort,
            NULL,
            (PPORT_MESSAGE)Message,
            TRUE,
            NULL,
            &ClientView
            );

    if ( !NT_SUCCESS(st) ) {
        KdPrint(("CSRSS: Sb Accept Connection failed %lx\n",st));
        return st;
    }

    st = NtCompleteConnectPort(CommunicationPort);

    if ( !NT_SUCCESS(st) ) {
        KdPrint(("CSRSS: Sb Complete Connection failed %lx\n",st));
    }

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\session.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    session.c

Abstract:

    This module contains the worker routines called by the Sb API
    Request routines in sbapi.c to create and delete sessions.  Also
    called whenever an application process creates a new child process
    within the same session.

Author:

    Steve Wood (stevewo) 08-Oct-1990

Revision History:

--*/


#include "csrsrv.h"

NTSTATUS
CsrInitializeNtSessionList( VOID )
{
    NTSTATUS Status;

    InitializeListHead( &CsrNtSessionList );

    Status = RtlInitializeCriticalSection( &CsrNtSessionLock );
    return( Status );
}


PCSR_NT_SESSION
CsrAllocateNtSession(
    ULONG SessionId
    )
{
    PCSR_NT_SESSION Session;

    Session = RtlAllocateHeap( CsrHeap, MAKE_TAG( SESSION_TAG ), sizeof( CSR_NT_SESSION ) );
    ASSERT( Session != NULL );

    if (Session != NULL) {
        Session->SessionId = SessionId;
        Session->ReferenceCount = 1;
        LockNtSessionList();
        InsertHeadList( &CsrNtSessionList, &Session->SessionLink );
        UnlockNtSessionList();
        }

    return( Session );
}

VOID
CsrReferenceNtSession(
    PCSR_NT_SESSION Session
    )
{
    LockNtSessionList();

    ASSERT( !IsListEmpty( &Session->SessionLink ) );
    ASSERT( Session->SessionId != 0 );
    ASSERT( Session->ReferenceCount != 0 );
    Session->ReferenceCount++;
    UnlockNtSessionList();
}

VOID
CsrDereferenceNtSession(
    PCSR_NT_SESSION Session,
    NTSTATUS ExitStatus
    )
{
    LockNtSessionList();

    ASSERT( !IsListEmpty( &Session->SessionLink ) );
    ASSERT( Session->SessionId != 0 );
    ASSERT( Session->ReferenceCount != 0 );

    if (--Session->ReferenceCount == 0) {
        RemoveEntryList( &Session->SessionLink );
        UnlockNtSessionList();
        SmSessionComplete(CsrSmApiPort,Session->SessionId,ExitStatus);
        RtlFreeHeap( CsrHeap, 0, Session );
        }
    else {
        UnlockNtSessionList();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\srvloadr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvloadr.c

Abstract:

    This is the server DLL loader module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 08-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"
#include "windows.h"

#ifdef _IA64_
#include <ntia64.h>
#endif // _IA64_

EXCEPTION_DISPOSITION
CsrUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    UNICODE_STRING UnicodeParameter;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    BOOLEAN WasEnabled;
    NTSTATUS Status;
    LONG lReturn = EXCEPTION_EXECUTE_HANDLER;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;

    //
    // Terminating will cause sm's wait to sense that we crashed. This will
    // result in a clean shutdown due to sm's hard error logic
    //

    Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                               &KernelDebuggerInfo,
                               sizeof(KernelDebuggerInfo),
                               NULL
                             );

    //
    // Under Hydra, we don't want to shutdown the system just
    // because the Win32 subsystem is going away.  In case of non-console CSRSS,
    // causing the process to terminate is sufficient.
    //
    if ((NtCurrentPeb()->SessionId == 0) || 
          (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)) {

        lReturn = RtlUnhandledExceptionFilter(ExceptionInfo);

        if (lReturn != EXCEPTION_CONTINUE_EXECUTION)
        {
            //
            // We are hosed, so raise a fatal system error to shutdown the system.
            // (Basically a user mode KeBugCheck).
            //

            Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                         (BOOLEAN)TRUE,
                                         TRUE,
                                         &WasEnabled
                                       );

            if (Status == STATUS_NO_TOKEN) {

                //
                // No thread token, use the process token
                //

                Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                             (BOOLEAN)TRUE,
                                             FALSE,
                                             &WasEnabled
                                           );
                }

            RtlInitUnicodeString( &UnicodeParameter, L"Windows SubSystem" );
            Parameters[ 0 ] = (ULONG_PTR)&UnicodeParameter;
            Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
            Parameters[ 2 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;
            Parameters[ 3 ] = (ULONG_PTR)ExceptionInfo->ContextRecord;
            Status = NtRaiseHardError( STATUS_SYSTEM_PROCESS_TERMINATED,
                                       4,
                                       1,
                                       Parameters,
                                       OptionShutdownSystem,
                                       &Response
                                     );
        }
    }

    if (lReturn != EXCEPTION_CONTINUE_EXECUTION)
    {
        //
        // If this returns, giveup
        //

        NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);
    }

    return lReturn;
}


NTSTATUS
CsrLoadServerDll(
    IN PCH ModuleName,
    IN PCH InitRoutineString,
    IN ULONG ServerDllIndex
    )
{
    NTSTATUS Status;
    ANSI_STRING ModuleNameString;
    UNICODE_STRING ModuleNameString_U;
    HANDLE ModuleHandle;
    PCSR_SERVER_DLL LoadedServerDll;
    STRING ProcedureNameString;
    PCSR_SERVER_DLL_INIT_ROUTINE ServerDllInitialization;
    ULONG n;

    if (ServerDllIndex >= CSR_MAX_SERVER_DLL) {
        return( STATUS_TOO_MANY_NAMES );
        }

    if (CsrLoadedServerDll[ ServerDllIndex ] != NULL) {
        return( STATUS_INVALID_PARAMETER );
        }

    ASSERT( ModuleName != NULL );
    RtlInitAnsiString( &ModuleNameString, ModuleName );

    if (ServerDllIndex != CSRSRV_SERVERDLL_INDEX) {
        Status = RtlAnsiStringToUnicodeString(&ModuleNameString_U, &ModuleNameString, TRUE);
        if (!NT_SUCCESS(Status)) {
            return Status;
            }
        Status = LdrLoadDll( UNICODE_NULL, NULL, &ModuleNameString_U, &ModuleHandle );
        if ( !NT_SUCCESS(Status) ) {

            PUNICODE_STRING ErrorStrings[2];
            UNICODE_STRING ErrorDllPath;
            ULONG ErrorResponse;
            NTSTATUS ErrorStatus;

            ErrorStrings[0] = &ModuleNameString_U;
            ErrorStrings[1] = &ErrorDllPath;
            RtlInitUnicodeString(&ErrorDllPath,L"Default Load Path");

            //
            // need to get image name
            //

            ErrorStatus = NtRaiseHardError(
                            (NTSTATUS)STATUS_DLL_NOT_FOUND,
                            2,
                            0x00000003,
                            (PULONG_PTR)ErrorStrings,
                            OptionOk,
                            &ErrorResponse
                            );

            }
        RtlFreeUnicodeString(&ModuleNameString_U);
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }
    else {
        ModuleHandle = NULL;
        }

    n = sizeof( *LoadedServerDll ) + ModuleNameString.MaximumLength;

    LoadedServerDll = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), n );
    if (LoadedServerDll == NULL) {
        if (ModuleHandle != NULL) {
            LdrUnloadDll( ModuleHandle );
            }

        return( STATUS_NO_MEMORY );
        }

    RtlZeroMemory( LoadedServerDll, n );
    LoadedServerDll->SharedStaticServerData = CsrSrvSharedSectionHeap;
    LoadedServerDll->Length = n;
    LoadedServerDll->ModuleName.Length = ModuleNameString.Length;
    LoadedServerDll->ModuleName.MaximumLength = ModuleNameString.MaximumLength;
    LoadedServerDll->ModuleName.Buffer = (PCH)(LoadedServerDll+1);
    if (ModuleNameString.Length != 0) {
        strncpy( LoadedServerDll->ModuleName.Buffer,
                 ModuleNameString.Buffer,
                 ModuleNameString.Length
               );
        }

    LoadedServerDll->ServerDllIndex = ServerDllIndex;
    LoadedServerDll->ModuleHandle = ModuleHandle;

    if (ModuleHandle != NULL) {

        RtlInitString(
            &ProcedureNameString,
            (InitRoutineString == NULL) ? "ServerDllInitialization" : InitRoutineString);

        Status = LdrGetProcedureAddress( ModuleHandle,
                                         &ProcedureNameString,
                                         0,
                                         (PVOID *) &ServerDllInitialization
                                       );
        }
    else {
        ServerDllInitialization = CsrServerDllInitialization;
        Status = STATUS_SUCCESS;
        }

    if (NT_SUCCESS( Status )) {
        try {
            Status = (*ServerDllInitialization)( LoadedServerDll );
            }
        except ( CsrUnhandledExceptionFilter( GetExceptionInformation() ) ){
            Status = GetExceptionCode();
            }
        if (NT_SUCCESS( Status )) {
            CsrTotalPerProcessDataLength += (ULONG)QUAD_ALIGN(LoadedServerDll->PerProcessDataLength);

            CsrLoadedServerDll[ LoadedServerDll->ServerDllIndex ] =
                LoadedServerDll;
            if ( LoadedServerDll->SharedStaticServerData != CsrSrvSharedSectionHeap ) {
                CsrSrvSharedStaticServerData[LoadedServerDll->ServerDllIndex] = LoadedServerDll->SharedStaticServerData;
                }
            }
        else {
            if (ModuleHandle != NULL) {
                LdrUnloadDll( ModuleHandle );
                }

            RtlFreeHeap( CsrHeap, 0, LoadedServerDll );
            }
        }
    else {
        if (ModuleHandle != NULL) {
            LdrUnloadDll( ModuleHandle );
            }

        RtlFreeHeap( CsrHeap, 0, LoadedServerDll );
        }

    return( Status );
}


ULONG
CsrSrvClientConnect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PCSR_CLIENTCONNECT_MSG a = (PCSR_CLIENTCONNECT_MSG)&m->u.ApiMessageData;
    PCSR_SERVER_DLL LoadedServerDll;

    *ReplyStatus = CsrReplyImmediate;

    if (a->ServerDllIndex >= CSR_MAX_SERVER_DLL) {
        return( STATUS_TOO_MANY_NAMES );
        }

    if (CsrLoadedServerDll[ a->ServerDllIndex ] == NULL) {
        return( STATUS_INVALID_PARAMETER );
        }

    if (!CsrValidateMessageBuffer(m, &a->ConnectionInformation, a->ConnectionInformationLength, sizeof(BYTE))) {
        return( STATUS_INVALID_PARAMETER );
        }

    LoadedServerDll = CsrLoadedServerDll[ a->ServerDllIndex ];

    if (LoadedServerDll->ConnectRoutine) {

        Status = (LoadedServerDll->ConnectRoutine)(
                        (CSR_SERVER_QUERYCLIENTTHREAD())->Process,
                        a->ConnectionInformation,
                        &a->ConnectionInformationLength
                        );
        }
    else {
        Status = STATUS_SUCCESS;
        }

    return( Status );
}


NTSTATUS
CsrSrvCreateSharedSection(
    IN PCH SizeParameter
    )
{
    NTSTATUS Status;
    LARGE_INTEGER SectionSize;
    SIZE_T ViewSize;
    ULONG HeapSize;
    ULONG AllocationAttributes;
    PCH s;
    ULONG FirstCsr = (NtCurrentPeb()->SessionId == 0);

#if defined(_WIN64)
    PVOID BaseAddress;
    SIZE_T RegionSize;
#endif

    if (SizeParameter == NULL) {
        return STATUS_INVALID_PARAMETER;
        }

    s = SizeParameter;
    while (*s) {
        if (*s == ',') {
            *s++ = '\0';
            break;
            }
        else {
            s++;
            }
        }


    if (!*s) {
        return( STATUS_INVALID_PARAMETER );
        }

    Status = RtlCharToInteger( SizeParameter,
                               0,
                               &HeapSize
                             );
    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    HeapSize = ROUND_UP_TO_PAGES( HeapSize * 1024 );
    CsrSrvSharedSectionSize = HeapSize;

    SectionSize.LowPart = CsrSrvSharedSectionSize;
    SectionSize.HighPart = 0;

    if (FirstCsr) {
        AllocationAttributes = SEC_BASED | SEC_RESERVE;
    }
    else {
        AllocationAttributes = SEC_RESERVE;
    }

    Status = NtCreateSection( &CsrSrvSharedSection,
                              SECTION_ALL_ACCESS,
                              (POBJECT_ATTRIBUTES) NULL,
                              &SectionSize,
                              PAGE_EXECUTE_READWRITE,
                              AllocationAttributes,
                              (HANDLE) NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    ViewSize = 0;

#if defined(_WIN64)
    CsrSrvSharedSectionBase = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
#else
    if (FirstCsr) {
        CsrSrvSharedSectionBase = NULL;
    }
    else {

        //
        // Retrieve the value of CsrSrvSharedSectionBase from registry
        // This is saved by the First CSRSS process and used by others
        //


        HANDLE hKey;
        OBJECT_ATTRIBUTES   Obja;
        ULONG               Attributes;
        UNICODE_STRING      KeyName;

        Attributes = OBJ_CASE_INSENSITIVE;

        RtlInitUnicodeString( &KeyName, CSR_BASE_PATH );

        InitializeObjectAttributes(&Obja,
                                   &KeyName,
                                   Attributes,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&hKey,
                           KEY_READ,
                           &Obja);

        if (NT_SUCCESS(Status)) {

            ULONG  BufferLength;
            ULONG  ResultLength;
            BYTE   PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION ) +
                                                + sizeof(DWORD) ];

            BufferLength = sizeof( PrivateKeyValueInformation );

            RtlInitUnicodeString( &KeyName, L"CsrSrvSharedSectionBase" );

            if (NT_SUCCESS(Status = NtQueryValueKey( hKey,
                                                    &KeyName,
                                                    KeyValuePartialInformation,
                                                    PrivateKeyValueInformation,
                                                    BufferLength,
                                                    &ResultLength
                                                    ))) {

                RtlCopyMemory( &CsrSrvSharedSectionBase,
                   (( PKEY_VALUE_PARTIAL_INFORMATION )
                        PrivateKeyValueInformation )->Data,
                   (( PKEY_VALUE_PARTIAL_INFORMATION )
                        PrivateKeyValueInformation )->DataLength
                 );

            }

            ASSERT(NT_SUCCESS(Status));

            NtClose(hKey);

        }

        if (!NT_SUCCESS(Status)) {

            ASSERT(NT_SUCCESS(Status));

            return Status;
        }

    }
#endif

#if defined(_WIN64)

    //
    // For compatibility reasons, on Win64 the csrss shared section
    // needs to be at an address below 2GB.  Since it is difficult to
    // find an address in the middle of the address space that is
    // guaranteed to be available in all processes, the memory
    // manager reserves an address at the top of the 2GB range.
    // To use this memory, CSRSS first unreserves the memory and
    // then maps in the section.  A possible race condition exists
    // if another thread tries to allocate the memory at the same
    // time, but this is highly unlikely since in the current NT
    // code the mapping and unmapping will always occur in DLL_PROCESS_ATTACH
    // in kernel32.dll.  This code executes when the first thread
    // of the process is initialized, and all newly created threads
    // are blocked untill this code completes.
    //

    BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
    RegionSize = CsrSrvSharedSectionSize;

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                 &BaseAddress,
                                 &RegionSize,
                                 MEM_RELEASE
                                );

    if (!NT_SUCCESS(Status)) {
        NtClose( CsrSrvSharedSection );
        return Status;
    }
#endif

    Status = NtMapViewOfSection( CsrSrvSharedSection,
                                 NtCurrentProcess(),
                                 &CsrSrvSharedSectionBase,
                                 0,     // Zerobits?
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 MEM_TOP_DOWN,
                                 PAGE_EXECUTE_READWRITE
                               );
    if (!NT_SUCCESS( Status )) {

#if defined(_WIN64)

        //
        // For this code to execute, either the race condition
        // described above occured for some unknown reason or
        // the memory manager or process is corrupt.  With the lack
        // of an atomic uncommit and map, the best that can be done is
        // try to reallocate the memory.  If this fails, everything
        // is hopeless.
        //

        BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
        RegionSize = CsrSrvSharedSectionSize;
        NtAllocateVirtualMemory(NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                &RegionSize,
                                MEM_RESERVE,
                                PAGE_READONLY
                               );
#endif

        NtClose( CsrSrvSharedSection );
        return( Status );
        }
    CsrSrvSharedSectionHeap = CsrSrvSharedSectionBase;

    if (IsTerminalServer() && FirstCsr) {
        //
        //save CsrSrvSharedSectionBase in registry for other csrs
        //
        HKEY hKey;
        OBJECT_ATTRIBUTES   Obja;
        ULONG               Attributes;
        UNICODE_STRING      KeyName;
        DWORD               dwDisposition;

        Attributes = OBJ_CASE_INSENSITIVE;

        RtlInitUnicodeString( &KeyName, CSR_BASE_PATH );

        InitializeObjectAttributes(&Obja,
                                   &KeyName,
                                   Attributes,
                                   NULL,
                                   NULL);


        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &Obja,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &dwDisposition);



        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString( &KeyName, L"CsrSrvSharedSectionBase" );

            Status =  NtSetValueKey(
                            hKey,
                            &KeyName,
                            0,
                            REG_DWORD,
                            (LPBYTE)&CsrSrvSharedSectionBase,
                            sizeof(CsrSrvSharedSectionBase)
                            );

            ASSERT(NT_SUCCESS(Status));

            NtClose(hKey);
        } else {

            ASSERT(NT_SUCCESS(Status));

        }

    }

    if (RtlCreateHeap( HEAP_ZERO_MEMORY | HEAP_CLASS_7,
                       CsrSrvSharedSectionHeap,
                       HeapSize,
                       4*1024,
                       0,
                       0
                     ) == NULL
       ) {
        NtUnmapViewOfSection( NtCurrentProcess(),
                              CsrSrvSharedSectionBase
                            );
        NtClose( CsrSrvSharedSection );
        return( STATUS_NO_MEMORY );
        }

    CsrSharedBaseTag = RtlCreateTagHeap( CsrSrvSharedSectionHeap,
                                         0,
                                         L"CSRSHR!",
                                         L"!CSRSHR\0"
                                         L"INIT\0"
                                       );
    CsrSrvSharedStaticServerData = (PVOID *)RtlAllocateHeap(
                                            CsrSrvSharedSectionHeap,
                                            MAKE_SHARED_TAG( SHR_INIT_TAG ),
                                            CSR_MAX_SERVER_DLL * sizeof(PVOID)
                                            );

	if (CsrSrvSharedStaticServerData == NULL) {
		return STATUS_NO_MEMORY;
	}
    NtCurrentPeb()->ReadOnlySharedMemoryBase = CsrSrvSharedSectionBase;
    NtCurrentPeb()->ReadOnlySharedMemoryHeap = CsrSrvSharedSectionHeap;
    NtCurrentPeb()->ReadOnlyStaticServerData = (PVOID *)CsrSrvSharedStaticServerData;

    return( STATUS_SUCCESS );
}


NTSTATUS
CsrSrvAttachSharedSection(
    IN PCSR_PROCESS Process OPTIONAL,
    OUT PCSR_API_CONNECTINFO p
    )
{
    NTSTATUS Status;
    SIZE_T ViewSize;

#if defined(_WIN64)
    PVOID BaseAddress;
    SIZE_T RegionSize;
#endif

    if (ARGUMENT_PRESENT( Process )) {

#if defined(_WIN64)

        BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
        RegionSize = CsrSrvSharedSectionSize;

        Status = NtFreeVirtualMemory(Process->ProcessHandle,
                                     &BaseAddress,
                                     &RegionSize,
                                     MEM_RELEASE
                                    );
        if(!NT_SUCCESS(Status)) {
           return Status;
           }
#endif

        ViewSize = 0;
        Status = NtMapViewOfSection( CsrSrvSharedSection,
                                     Process->ProcessHandle,
                                     &CsrSrvSharedSectionBase,
                                     0,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     SEC_NO_CHANGE,
                                     PAGE_EXECUTE_READ
                                   );
        if (!NT_SUCCESS( Status )) {

#if defined(_WIN64)
            BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
            RegionSize = CsrSrvSharedSectionSize;

            NtAllocateVirtualMemory(Process->ProcessHandle,
                                    &BaseAddress,
                                    0,
                                    &RegionSize,
                                    MEM_RESERVE,
                                    PAGE_READONLY
                                   );
#endif

            return( Status );
            }
        }

    p->SharedSectionBase = CsrSrvSharedSectionBase;
    p->SharedSectionHeap = CsrSrvSharedSectionHeap;
    p->SharedStaticServerData = CsrSrvSharedStaticServerData;

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\client\smdllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smdllp.h

Abstract:

    Session Manager Dll Private Types and Prototypes

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#ifndef _SMSRVP_
#define _SMSRVP_

#include <nt.h>
#include <ntrtl.h>
#include <ntsm.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include "sm.h"

#endif // _SMDLLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\wait.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module contains the primitives to implement the Wait functions
    on the Server side of the Client-Server Runtime Subsystem to the
    Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"

BOOLEAN
CsrInitializeWait(
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    OUT PCSR_WAIT_BLOCK *WaitBlockPtr
    )

{
    ULONG Length;
    PCSR_WAIT_BLOCK WaitBlock;

    Length = sizeof( *WaitBlock ) - sizeof( WaitBlock->WaitReplyMessage ) +
             WaitReplyMessage->h.u1.s1.TotalLength;

    WaitBlock = RtlAllocateHeap( CsrHeap, MAKE_TAG( WAIT_TAG ), Length );
    if (WaitBlock == NULL) {
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_NO_MEMORY;
        return( FALSE );
    }

    WaitBlock->Length = Length;
    WaitBlock->WaitingThread = WaitingThread;
    WaitBlock->WaitParameter = WaitParameter;
    WaitBlock->WaitRoutine = WaitRoutine;
    WaitBlock->Link.Flink = WaitBlock->Link.Blink = NULL;
    RtlCopyMemory( &WaitBlock->WaitReplyMessage,
                   WaitReplyMessage,
                   WaitReplyMessage->h.u1.s1.TotalLength
                 );
    *WaitBlockPtr = WaitBlock;
    return TRUE;
}

BOOLEAN
CsrCreateWait(
    IN PLIST_ENTRY WaitQueue,
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter)
{
    PCSR_WAIT_BLOCK WaitBlock;

    if (!CsrInitializeWait( WaitRoutine,
                            WaitingThread,
                            WaitReplyMessage,
                            WaitParameter,
                            &WaitBlock
                          )
       ) {
        return FALSE;
        }

    AcquireWaitListsLock();

    if ( WaitingThread->Flags & CSR_THREAD_DESTROYED ) {
        RtlFreeHeap( CsrHeap, 0, WaitBlock );
        ReleaseWaitListsLock();
        return FALSE;
    }

    WaitingThread->WaitBlock = WaitBlock;

    InsertTailList( WaitQueue, &WaitBlock->Link );

    ReleaseWaitListsLock();
    return( TRUE );
}


BOOLEAN
CsrNotifyWaitBlock(
    IN PCSR_WAIT_BLOCK WaitBlock,
    IN PLIST_ENTRY WaitQueue,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags,
    IN BOOLEAN DereferenceThread
    )
{
    if ((*WaitBlock->WaitRoutine)( WaitQueue,
                                   WaitBlock->WaitingThread,
                                   &WaitBlock->WaitReplyMessage,
                                   WaitBlock->WaitParameter,
                                   SatisfyParameter1,
                                   SatisfyParameter2,
                                   WaitFlags
                                 )
       ) {

        //
        // we don't take any locks other than the waitlist lock
        // because the only thing we have to worry about is the thread
        // going away beneath us and that's prevented by having
        // DestroyThread and DestroyProcess take the waitlist lock.
        //

        WaitBlock->WaitingThread->WaitBlock = NULL;
        if (WaitBlock->WaitReplyMessage.CaptureBuffer != NULL) {
            CsrReleaseCapturedArguments(&WaitBlock->WaitReplyMessage);
        }
        while (1) {
            NTSTATUS Status;

            Status = NtReplyPort (WaitBlock->WaitingThread->Process->ClientPort,
                                  (PPORT_MESSAGE)&WaitBlock->WaitReplyMessage);

            if (Status == STATUS_NO_MEMORY) {
                LARGE_INTEGER DelayTime;

                KdPrint (("CSRSS: Failed to reply to calling thread, retrying.\n"));
                DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                NtDelayExecution (FALSE, &DelayTime);
                continue;
            }
            break;
        }

        if (DereferenceThread) {
            if ( WaitBlock->Link.Flink ) {
                RemoveEntryList( &WaitBlock->Link );
                }
            CsrDereferenceThread(WaitBlock->WaitingThread);
            RtlFreeHeap( CsrHeap, 0, WaitBlock );
            }
        else {

            //
            // indicate that this wait has been satisfied.  when the
            // console unwinds to the point where it can release the
            // console lock, it will dereference the thread.
            //

            WaitBlock->WaitRoutine = NULL;
            }
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

BOOLEAN
CsrNotifyWait(
    IN PLIST_ENTRY WaitQueue,
    IN BOOLEAN SatisfyAll,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;
    BOOLEAN Result;

    Result = FALSE;

    AcquireWaitListsLock();

    ListHead = WaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (WaitBlock->WaitRoutine) {
            Result |= CsrNotifyWaitBlock( WaitBlock,
                                          WaitQueue,
                                          SatisfyParameter1,
                                          SatisfyParameter2,
                                          0,
                                          FALSE
                                        );
            if (!SatisfyAll) {
                break;
                }
            }
        }

    ReleaseWaitListsLock();
    return( Result );
}

VOID
CsrDereferenceWait(
    IN PLIST_ENTRY WaitQueue
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;

    AcquireProcessStructureLock();
    AcquireWaitListsLock();

    ListHead = WaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (!WaitBlock->WaitRoutine) {
            if ( WaitBlock->Link.Flink ) {
                RemoveEntryList( &WaitBlock->Link );
                }
            CsrDereferenceThread(WaitBlock->WaitingThread);
            RtlFreeHeap( CsrHeap, 0, WaitBlock );
            }
        }

    ReleaseWaitListsLock();
    ReleaseProcessStructureLock();
}

VOID
CsrMoveSatisfiedWait(
    IN PLIST_ENTRY DstWaitQueue,
    IN PLIST_ENTRY SrcWaitQueue
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;

    AcquireWaitListsLock();

    ListHead = SrcWaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (!WaitBlock->WaitRoutine) {
            RemoveEntryList( &WaitBlock->Link );
            InsertTailList( DstWaitQueue, &WaitBlock->Link );
            }
        }

    ReleaseWaitListsLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\client\sm6432.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sm6432.c

Abstract:

    Session Manager Client Support APIs for Wow64 executable (32-bit images running
    on Win64)

Author:

    Samer Arafeh (samera) 20-Sep-2001

Revision History:

--*/

#if defined(_X86_)

/*
 * Enable LPC port-messages to have compatible layout between the 32-bit and 64-bit worlds.
 */
#define USE_LPC6432    1
#define BUILD_WOW6432  1

#include "smdllp.h"
#include "smp6432.h"
#include <string.h>



NTSTATUS
SmpThunkUserProcessInfoTo64 (
    IN PRTL_USER_PROCESS_INFORMATION UserProcessInformation32,
    OUT PRTL_USER_PROCESS_INFORMATION64 UserProcessInformation64
    )

/*++

Routine Description:

    This routine thunks RTL_PROCESS_USER_INFORMATION structure from 32-bit 
    structure offsets in Win64 structure offsets.

Arguments:

    UserProcessInformation32 - 32-bit Input structure.
    
    UserProcessInformation64 - 64-bit Output structure allocated by the caller.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT (UserProcessInformation32)) {

        try {
            
            UserProcessInformation64->Length = sizeof (RTL_USER_PROCESS_INFORMATION64);
            UserProcessInformation64->Process = (LONGLONG)UserProcessInformation32->Process;
            UserProcessInformation64->Thread = (LONGLONG)UserProcessInformation32->Thread;
            UserProcessInformation64->ClientId.UniqueProcess = (ULONGLONG)UserProcessInformation32->ClientId.UniqueProcess;
            UserProcessInformation64->ClientId.UniqueThread = (ULONGLONG)UserProcessInformation32->ClientId.UniqueThread;

            UserProcessInformation64->ImageInformation.TransferAddress = (ULONGLONG)UserProcessInformation32->ImageInformation.TransferAddress;
            UserProcessInformation64->ImageInformation.ZeroBits = UserProcessInformation32->ImageInformation.ZeroBits;
            UserProcessInformation64->ImageInformation.MaximumStackSize = UserProcessInformation32->ImageInformation.MaximumStackSize;
            UserProcessInformation64->ImageInformation.CommittedStackSize = UserProcessInformation32->ImageInformation.CommittedStackSize;
            UserProcessInformation64->ImageInformation.SubSystemType = UserProcessInformation32->ImageInformation.SubSystemType;
            UserProcessInformation64->ImageInformation.SubSystemVersion = UserProcessInformation32->ImageInformation.SubSystemVersion;
            UserProcessInformation64->ImageInformation.GpValue = UserProcessInformation32->ImageInformation.GpValue;
            UserProcessInformation64->ImageInformation.ImageCharacteristics = UserProcessInformation32->ImageInformation.ImageCharacteristics;
            UserProcessInformation64->ImageInformation.DllCharacteristics = UserProcessInformation32->ImageInformation.DllCharacteristics;
            UserProcessInformation64->ImageInformation.Machine = UserProcessInformation32->ImageInformation.Machine;
            UserProcessInformation64->ImageInformation.ImageContainsCode = UserProcessInformation32->ImageInformation.ImageContainsCode;
            UserProcessInformation64->ImageInformation.Spare1 = UserProcessInformation32->ImageInformation.Spare1;
            UserProcessInformation64->ImageInformation.LoaderFlags = UserProcessInformation32->ImageInformation.LoaderFlags;
            RtlCopyMemory (&UserProcessInformation64->ImageInformation.Reserved,
                           &UserProcessInformation32->ImageInformation.Reserved,
                           sizeof (UserProcessInformation32->ImageInformation.Reserved));
        
        } except (EXCEPTION_EXECUTE_HANDLER) {
              NtStatus = GetExceptionCode ();
        }
    } else {
        
        UserProcessInformation64 = (PRTL_USER_PROCESS_INFORMATION64)UserProcessInformation32;
    }

    return NtStatus;
}


BOOLEAN
SmpIsWow64Process (
    VOID
    )

/*++

Routine Description:

    This routine detects whether the currently executing process is running inside
    Wow64. The routine caches the result.

Arguments:

    None.
    
Return Value:

    BOOLEAN.

--*/

{
    NTSTATUS NtStatus;
    PVOID Peb32;
    static BOOLEAN RunningInsideWow64 = -1;

    if (RunningInsideWow64 == (BOOLEAN)-1) {

        NtStatus = NtQueryInformationProcess (
            NtCurrentProcess (),
            ProcessWow64Information,
            &Peb32,
            sizeof (Peb32),
            NULL
            );

        if (NT_SUCCESS (NtStatus)) {
            if (Peb32 != NULL) {
                RunningInsideWow64 = TRUE;
            } else {
                RunningInsideWow64 = FALSE;
            }
        } else {
            RunningInsideWow64 = FALSE;
        }
    }

    return RunningInsideWow64;
}



NTSTATUS
SmpWow64ExecPgm(
    IN HANDLE SmApiPort,
    IN PRTL_USER_PROCESS_INFORMATION ProcessInformation32,
    IN BOOLEAN DebugFlag
    )

/*++

Routine Description:

    This routine allows a process to start a process using the
    facilities provided by the NT Session manager.

    This function closes all handles passed to it.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    ProcessInformation32 - Supplies a process description as returned
        by RtlCreateUserProcess.

    DebugFlag - Supplies and optional parameter which if set indicates
        that the caller wants to debug this process and act as its
        debug user interface.

Return Value:

    NSTATUS.

--*/

{
    NTSTATUS st;

    SMAPIMSG64 SmApiMsg;
    PSMEXECPGM64 args;
    RTL_USER_PROCESS_INFORMATION64 ProcessInformation64;


    args = &SmApiMsg.u.ExecPgm;

    st = SmpThunkUserProcessInfoTo64 (ProcessInformation32,
                                      &ProcessInformation64);
    if (NT_SUCCESS (st)) {
        
        args->DebugFlag = DebugFlag;

        SmApiMsg.ApiNumber = SmExecPgmApi;
        SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
        SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
        SmApiMsg.h.u2.ZeroInit = 0L;

        st = NtRequestWaitReplyPort(
                SmApiPort,
                (PPORT_MESSAGE) &SmApiMsg,
                (PPORT_MESSAGE) &SmApiMsg
                );

        if ( NT_SUCCESS(st) ) {
            st = SmApiMsg.ReturnedStatus;
        } else {
            KdPrint(("SmExecPgm: NtRequestWaitReply Failed %lx\n",st));
        }

        NtClose(ProcessInformation32->Process);
        NtClose(ProcessInformation32->Thread);
    }

    return st;
}


NTSTATUS
SmpWow64LoadDeferedSubsystem(
    IN HANDLE SmApiPort,
    IN PUNICODE_STRING DeferedSubsystem
    )

/*++

Routine Description:

    This routine allows a process to start a defered subsystem.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    DeferedSubsystem - Supplies the name of the defered subsystem to load.

Return Value:

    NSTATUS.

--*/

{
    NTSTATUS st;

    SMAPIMSG64 SmApiMsg;
    PSMLOADDEFERED args;

    if ( DeferedSubsystem->Length >> 1 > SMP_MAXIMUM_SUBSYSTEM_NAME ) {
        return STATUS_INVALID_PARAMETER;
        }

    args = &SmApiMsg.u.LoadDefered;
    args->SubsystemNameLength = DeferedSubsystem->Length;
    
    RtlZeroMemory(args->SubsystemName, sizeof (args->SubsystemName));
    RtlCopyMemory(args->SubsystemName,DeferedSubsystem->Buffer,DeferedSubsystem->Length);

    SmApiMsg.ApiNumber = SmLoadDeferedSubsystemApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        KdPrint(("SmExecPgm: NtRequestWaitReply Failed %lx\n",st));
    }

    return st;

}


NTSTATUS
SmpWow64SessionComplete(
    IN HANDLE SmApiPort,
    IN ULONG SessionId,
    IN NTSTATUS CompletionStatus
    )

/*++

Routine Description:

    This routine is used to report completion of a session to
    the NT Session manager.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    SessionId - Supplies the session id of the session which is now completed.

    CompletionStatus - Supplies the completion status of the session.

Return Value:

    NSTATUS.

--*/

{
    NTSTATUS st;

    SMAPIMSG64 SmApiMsg;
    PSMSESSIONCOMPLETE args;

    args = &SmApiMsg.u.SessionComplete;

    args->SessionId = SessionId;
    args->CompletionStatus = CompletionStatus;

    SmApiMsg.ApiNumber = SmSessionCompleteApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        KdPrint(("SmCompleteSession: NtRequestWaitReply Failed %lx\n",st));
    }

    return st;
}


NTSTATUS
SmpWow64StartCsr(
    IN HANDLE SmApiPort,
    OUT PULONG pMuSessionId,
    IN PUNICODE_STRING InitialCommand,
    OUT PULONG_PTR pInitialCommandProcessId,
    OUT PULONG_PTR pWindowsSubSysProcessId
    )

/*++

Routine Description:

    This routine allows TERMSRV to start a new CSR.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    MuSessionId - Hydra Terminal Session Id to start CSR in.

    InitialCommand - String for Initial Command (for debug)

    pInitialCommandProcessId - pointer to Process Id of initial command.

    pWindowsSubSysProcessId - pointer to Process Id of Windows subsystem.

Return Value:

    NSTATUS.

--*/

{
    NTSTATUS st;

    SMAPIMSG64 SmApiMsg;
    PSMSTARTCSR64 args;

    args = &SmApiMsg.u.StartCsr;

    args->MuSessionId = *pMuSessionId; //Sm will reassign the actuall sessionID

    if ( InitialCommand &&
         ( InitialCommand->Length >> 1 > SMP_MAXIMUM_INITIAL_COMMAND ) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( !InitialCommand ) {
        args->InitialCommandLength = 0;
    }
    else {
        args->InitialCommandLength = InitialCommand->Length;
        
        RtlZeroMemory(args->InitialCommand, sizeof (args->InitialCommand));
        RtlCopyMemory(args->InitialCommand,InitialCommand->Buffer,InitialCommand->Length);
    }

    SmApiMsg.ApiNumber = SmStartCsrApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        DbgPrint("SmStartCsr: NtRequestWaitReply Failed %lx\n",st);
    }

    *pInitialCommandProcessId = (ULONG)args->InitialCommandProcessId;
    *pWindowsSubSysProcessId = (ULONG)args->WindowsSubSysProcessId;
    *pMuSessionId = args->MuSessionId;

    return st;

}


NTSTATUS
SmpWow64StopCsr(
    IN HANDLE SmApiPort,
    IN ULONG MuSessionId
    )

/*++

Routine Description:

    This routine allows TERMSRV to stop a CSR.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    MuSessionId - Terminal Server Session Id to stop

Return Value:

    NSTATUS.

--*/

{
    NTSTATUS st;

    SMAPIMSG64 SmApiMsg;
    PSMSTOPCSR args;

    args = &SmApiMsg.u.StopCsr;

    args->MuSessionId = MuSessionId;

    SmApiMsg.ApiNumber = SmStopCsrApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        DbgPrint("SmStopCsr: NtRequestWaitReply Failed %lx\n",st);
    }

    return st;

}

#endif // #if defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\client\smcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smcsup.c

Abstract:

    Session Manager Client Support APIs

Author:

    Mark Lucovsky (markl) 05-Oct-1989

Revision History:

--*/

#include "smdllp.h"
#include <string.h>

NTSTATUS
SmConnectToSm(
    IN PUNICODE_STRING SbApiPortName OPTIONAL,
    IN HANDLE SbApiPort OPTIONAL,
    IN ULONG SbImageType OPTIONAL,
    OUT PHANDLE SmApiPort
    )

/*++

Routine Description:

    This function is used to connect to the NT Session Manager

Arguments:

    SbApiPortName - Supplies the name of the sub system's session management
        API port (for Sb APIs). That the session manager is to connect with.

    SbApiPort - Supplies a port handle to the connection port where the
        subsystem's session management (Sb) APIs are exported.

    SbImageType - Supplies the image type that the connecting subsystem
        serves.

    SmApiPort - Returns the communication port which is connected to the
        session manager and over which Sm APIs may be made.

Return Value:

    TBD.

--*/

{
    NTSTATUS st;
    UNICODE_STRING PortName;
    ULONG ConnectInfoLength;
    PSBCONNECTINFO ConnectInfo;
    SBAPIMSG Message;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;


    RtlInitUnicodeString(&PortName,L"\\SmApiPort");
    ConnectInfoLength = sizeof(SBCONNECTINFO);
    ConnectInfo = &Message.ConnectionRequest;

    //
    // Subsystems must specify an SbApiPortName
    //

    if ( ARGUMENT_PRESENT(SbApiPortName) ) {

        if ( !ARGUMENT_PRESENT(SbApiPort) ) {
            return STATUS_INVALID_PARAMETER_MIX;
        }
        if ( !SbImageType ) {
            return STATUS_INVALID_PARAMETER_MIX;
        }

        RtlCopyMemory(
            ConnectInfo->EmulationSubSystemPortName,
            SbApiPortName->Buffer,
            SbApiPortName->Length
            );
        ConnectInfo->EmulationSubSystemPortName[SbApiPortName->Length>>1] = UNICODE_NULL;
        ConnectInfo->SubsystemImageType = SbImageType;

    } else {
        ConnectInfo->EmulationSubSystemPortName[0] = UNICODE_NULL;
        ConnectInfo->SubsystemImageType = 0;
    }

    st = NtConnectPort(
            SmApiPort,
            &PortName,
            &DynamicQos,
            NULL,
            NULL,
            NULL,
            ConnectInfo,
            &ConnectInfoLength
            );

    if ( !NT_SUCCESS(st) ) {
        KdPrint(("SmConnectToSm: Connect to Sm failed %lx\n",st));
        return st;
    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\csr\server\srvinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvinit.c

Abstract:

    This is the main initialization module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 08-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"
#include <windows.h>
#include <stdio.h>
#include <wow64reg.h>

CONST PCSR_API_ROUTINE CsrServerApiDispatchTable[CsrpMaxApiNumber] = {
    (PCSR_API_ROUTINE)CsrSrvClientConnect,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction
};

BOOLEAN CsrServerApiServerValidTable[CsrpMaxApiNumber] = {
    TRUE,  // CsrSrvClientConnect,
    FALSE, // CsrSrvUnusedFunction,
    FALSE, // CsrSrvUnusedFunction,
    FALSE, // CsrSrvUnusedFunction,
    FALSE  // CsrSrvUnusedFunction,
};

#if DBG
CONST PSZ CsrServerApiNameTable[CsrpMaxApiNumber] = {
    "ClientConnect",
    "CsrSrvUnusedFunction",
    "CsrSrvUnusedFunction",
    "CsrSrvUnusedFunction",
    "CsrSrvUnusedFunction",
};
#endif

NTSTATUS
CsrSetProcessSecurity(
    VOID
    );

NTSTATUS
CsrSetDirectorySecurity(
    IN HANDLE DirectoryHandle
    );

NTSTATUS
GetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
FreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CsrPopulateDosDevicesDirectory(
    HANDLE NewDirectoryHandle,
    PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
    );



// Though this function does not seem to cleanup on failure, failure
// will cause CSRSS to exit, so any allocated memory will be freed and
// any open handle will be closed.

NTSTATUS
CsrServerInitialization(
    IN ULONG argc,
    IN PCH argv[]
    )
{
    NTSTATUS Status;
    ULONG i;
    PVOID ProcessDataPtr;
    PCSR_SERVER_DLL LoadedServerDll;
#if DBG
    BOOLEAN bIsRemoteSession =  NtCurrentPeb()->SessionId != 0;
#endif

    //
    // Initialize Wow64 stuffs
    //
#ifdef _WIN64
    InitializeWow64OnBoot(1);
#endif

    //
    // Save away system information in a global variable
    //

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &CsrNtSysInfo,
                                       sizeof( CsrNtSysInfo ),
                                       NULL
                                     );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    // Use the process heap for memory allocation.
    //

    CsrHeap = RtlProcessHeap();
    CsrBaseTag = RtlCreateTagHeap( CsrHeap,
                                   0,
                                   L"CSRSS!",
                                   L"TMP\0"
                                   L"INIT\0"
                                   L"CAPTURE\0"
                                   L"PROCESS\0"
                                   L"THREAD\0"
                                   L"SECURITY\0"
                                   L"SESSION\0"
                                   L"WAIT\0"
                                 );


    //
    // Set up CSRSS process security
    //

    Status = CsrSetProcessSecurity();
    ASSERT(NT_SUCCESS(Status) || bIsRemoteSession);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize the Session List
    //

    Status = CsrInitializeNtSessionList();
    ASSERT(NT_SUCCESS(Status) || bIsRemoteSession);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize the Process List
    //

    Status = CsrInitializeProcessStructure();
    ASSERT(NT_SUCCESS(Status) || bIsRemoteSession);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Process the command line arguments
    //

    Status = CsrParseServerCommandLine(argc, argv);
    ASSERT(NT_SUCCESS(Status) || bIsRemoteSession);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#if DBG
    Status = RtlInitializeCriticalSection(&CsrTrackLpcLock);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    LpcTrackIndex = 0;
#endif


    //
    // Fix up per-process data for root process
    //

    ProcessDataPtr = (PCSR_PROCESS)RtlAllocateHeap( CsrHeap,
                                                    MAKE_TAG( PROCESS_TAG ) | HEAP_ZERO_MEMORY,
                                                    CsrTotalPerProcessDataLength
                                                  );

    if (ProcessDataPtr == NULL) {
                return STATUS_NO_MEMORY;
    }

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->PerProcessDataLength) {
            CsrRootProcess->ServerDllPerProcessData[i] = ProcessDataPtr;
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + LoadedServerDll->PerProcessDataLength);
        }
        else {
            CsrRootProcess->ServerDllPerProcessData[i] = NULL;
        }
    }

    //
    // Let server dlls know about the root process.
    //

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->AddProcessRoutine) {
            (*LoadedServerDll->AddProcessRoutine)( NULL, CsrRootProcess );
        }
    }

    //
    // Initialize the Windows Server API Port, and one or more
    // request threads.
    //

    Status = CsrApiPortInitialize();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Initialize the Server Session Manager API Port and one
    // request thread.
    //

    Status = CsrSbApiPortInitialize();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession);
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Connect to the session manager so we can start foreign sessions
    //

    Status = SmConnectToSm( &CsrSbApiPortName,
                            CsrSbApiPort,
                            IMAGE_SUBSYSTEM_WINDOWS_GUI,
                            &CsrSmApiPort
                          );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    //  Only on Console (HYDRA)
    //
    if (NtCurrentPeb()->SessionId == 0) {
        Status = NtSetDefaultHardErrorPort(CsrApiPort);
    }

    return( Status );
}

NTSTATUS
CsrParseServerCommandLine(
    IN ULONG argc,
    IN PCH argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG i, ServerDllIndex;
    PCH KeyName, KeyValue, s;
    PCH InitRoutine;

    CsrTotalPerProcessDataLength = 0;
    CsrObjectDirectory = NULL;
    CsrMaxApiRequestThreads = CSR_MAX_THREADS;


    SessionId = NtCurrentPeb()->SessionId;


    //
    // Create session specific object directories
    //


    Status = CsrCreateSessionObjectDirectory ( SessionId );

    if (!NT_SUCCESS(Status)) {

       if (SessionId == 0) {
           ASSERT( NT_SUCCESS( Status ) );
           DbgPrint("CSRSS: CsrCreateSessionObjectDirectory failed status = %lx\n", Status);
       } else {
           DbgPrint("CSRSS: CsrCreateSessionObjectDirectory failed status = %lx\n", Status);
           return Status;
       }
    }


    for (i=1; i<argc ; i++) {
        KeyName = argv[ i ];
        KeyValue = NULL;
        while (*KeyName) {
            if (*KeyName == '=') {
                *KeyName++ = '\0';
                KeyValue = KeyName;
                break;
                }

            KeyName++;
            }
        KeyName = argv[ i ];

        if (!_stricmp( KeyName, "ObjectDirectory" )) {
            ANSI_STRING AnsiString;
            ULONG attributes;
            CHAR SessionDirectory[MAX_SESSION_PATH];


            if (SessionId != 0) {

                //
                // Non-Console session
                //

                _snprintf(SessionDirectory, sizeof (SessionDirectory), "%ws\\%ld%s", SESSION_ROOT, SessionId, KeyValue);
                SessionDirectory[MAX_SESSION_PATH-1] = '\0';
            }

            //
            // Create an object directory in the object name space with the
            // name specified.   It will be the root for all object names
            // created by the Server side of the Client Server Runtime
            // SubSystem.
            //
            attributes =  OBJ_OPENIF | OBJ_CASE_INSENSITIVE;

            if (SessionId == 0) {
               attributes |= OBJ_PERMANENT;
               RtlInitString( &AnsiString, KeyValue );
            } else {
               RtlInitString( &AnsiString, SessionDirectory );
            }

            Status = RtlAnsiStringToUnicodeString( &CsrDirectoryName, &AnsiString, TRUE );
            ASSERT(NT_SUCCESS(Status) || SessionId != 0);
            if (!NT_SUCCESS( Status )) {
                break;
            }
            InitializeObjectAttributes( &ObjectAttributes,
                                        &CsrDirectoryName,
                                        attributes,
                                        NULL,
                                        NULL
                                      );
            Status = NtCreateDirectoryObject( &CsrObjectDirectory,
                                              DIRECTORY_ALL_ACCESS,
                                              &ObjectAttributes
                                            );
            if (!NT_SUCCESS( Status )) {
                break;
                }
            Status = CsrSetDirectorySecurity( CsrObjectDirectory );
            if (!NT_SUCCESS( Status )) {
                break;
                }
            }
        else
        if (!_stricmp( KeyName, "SubSystemType" )) {
            }
        else
        if (!_stricmp( KeyName, "MaxRequestThreads" )) {
            Status = RtlCharToInteger( KeyValue,
                                       0,
                                       &CsrMaxApiRequestThreads
                                     );
            }
        else
        if (!_stricmp( KeyName, "RequestThreads" )) {
#if 0
            Status = RtlCharToInteger( KeyValue,
                                       0,
                                       &CsrNumberApiRequestThreads
                                     );
#else
            //
            // wait until hive change !
            //

            Status = STATUS_SUCCESS;

#endif
            }
        else
        if (!_stricmp( KeyName, "ProfileControl" )) {
            }
        else
        if (!_stricmp( KeyName, "SharedSection" )) {
            Status = CsrSrvCreateSharedSection( KeyValue );
            if (!NT_SUCCESS( Status )) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: *** Invalid syntax for %s=%s (Status == %X)\n",
                              KeyName,
                              KeyValue,
                              Status
                            );
                    }
                                return Status;
                }
            Status = CsrLoadServerDll( "CSRSS", NULL, CSRSRV_SERVERDLL_INDEX );
            }
        else
        if (!_stricmp( KeyName, "ServerDLL" )) {
            s = KeyValue;
            InitRoutine = NULL;

            Status = STATUS_INVALID_PARAMETER;
            while (*s) {
                if ((*s == ':') && (InitRoutine == NULL)) {
                    *s++ = '\0';
                    InitRoutine = s;
                }

                if (*s++ == ',') {
                    Status = RtlCharToInteger ( s, 10, &ServerDllIndex );
                    if (NT_SUCCESS( Status )) {
                        s[ -1 ] = '\0';
                        }

                    break;
                    }
                }

            if (!NT_SUCCESS( Status )) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: *** Invalid syntax for ServerDll=%s (Status == %X)\n",
                              KeyValue,
                              Status
                            );
                    }
                }
            else {
                IF_CSR_DEBUG( INIT) {
                    DbgPrint( "CSRSS: Loading ServerDll=%s:%s\n", KeyValue, InitRoutine );
                    }

                Status = CsrLoadServerDll( KeyValue, InitRoutine, ServerDllIndex);

                if (!NT_SUCCESS( Status )) {
                    IF_DEBUG {
                        DbgPrint( "CSRSS: *** Failed loading ServerDll=%s (Status == 0x%x)\n",
                                  KeyValue,
                                  Status
                                );
                        }
                    return Status;
                    }
                }
            }
        else
        //
        // This is a temporary hack until Windows & Console are friends.
        //
        if (!_stricmp( KeyName, "Windows" )) {
            }
        else {
            Status = STATUS_INVALID_PARAMETER;
            }
        }

    return( Status );
}


NTSTATUS
CsrServerDllInitialization(
    IN PCSR_SERVER_DLL LoadedServerDll
    )
{
    LoadedServerDll->ApiNumberBase = CSRSRV_FIRST_API_NUMBER;
    LoadedServerDll->MaxApiNumber = CsrpMaxApiNumber;
    LoadedServerDll->ApiDispatchTable = CsrServerApiDispatchTable;
    LoadedServerDll->ApiServerValidTable = CsrServerApiServerValidTable;
#if DBG
    LoadedServerDll->ApiNameTable = CsrServerApiNameTable;
#endif
    LoadedServerDll->PerProcessDataLength = 0;
    LoadedServerDll->ConnectRoutine = NULL;
    LoadedServerDll->DisconnectRoutine = NULL;

    return( STATUS_SUCCESS );
}

NTSTATUS
CsrSrvUnusedFunction(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    IF_DEBUG {
        DbgPrint("CSRSS: Calling obsolete function %x\n", m->ApiNumber);
        }
    return STATUS_INVALID_PARAMETER;
}


NTSTATUS
CsrSetProcessSecurity(
    VOID
    )
{
    HANDLE Token;
    NTSTATUS Status;
    PTOKEN_USER User = NULL;
    ULONG LengthSid, Length;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PACL Dacl;

    //
    // Open the token and get the system sid
    //

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = NtQueryInformationToken (Token,
                                      TokenUser,
                                      NULL,
                                      0,
                                      &Length);

    User = (PTOKEN_USER)RtlAllocateHeap (CsrHeap,
                                         MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                         Length);
    if (User == NULL) {
        NtClose( Token );
        Status = STATUS_NO_MEMORY;
        goto error_cleanup;
    }

    Status = NtQueryInformationToken( Token,
                                      TokenUser,
                                      User,
                                      Length,
                                      &Length
                                    );

    NtClose( Token );

    if (!NT_SUCCESS(Status)) {
        goto error_cleanup;
    }
    LengthSid = RtlLengthSid( User->User.Sid );

    //
    // Allocate a buffer to hold the SD
    //

    SecurityDescriptor = RtlAllocateHeap (CsrHeap,
                                          MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                          SECURITY_DESCRIPTOR_MIN_LENGTH +
                                          sizeof(ACL) + LengthSid +
                                          sizeof(ACCESS_ALLOWED_ACE));
    if (SecurityDescriptor == NULL) {
        Status = STATUS_NO_MEMORY;
        goto error_cleanup;
    }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);


    //
    // Create the SD
    //

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: SD creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    Status = RtlCreateAcl( Dacl,
                           sizeof(ACL) + LengthSid + sizeof(ACCESS_ALLOWED_ACE),
                           ACL_REVISION2);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: DACL creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    Status = RtlAddAccessAllowedAce( Dacl,
                                     ACL_REVISION,
                                     ( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                       PROCESS_DUP_HANDLE | PROCESS_TERMINATE | PROCESS_SET_PORT |
                                       READ_CONTROL | PROCESS_QUERY_INFORMATION ),
                                     User->User.Sid);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }


    //
    // Set DACL to NULL to deny all access
    //

    Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor,
                                          TRUE,
                                          Dacl,
                                          FALSE);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set DACL failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    //
    // Put the DACL onto the process
    //

    Status = NtSetSecurityObject(NtCurrentProcess(),
                                 DACL_SECURITY_INFORMATION,
                                 SecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set process DACL failed - status = %lx\n", Status);
        }
    }

    //
    // Cleanup
    //

error_cleanup:

    if (SecurityDescriptor != NULL) {
        RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );
    }
    if (User != NULL) {
        RtlFreeHeap( CsrHeap, 0, User );
    }

    return Status;
}

NTSTATUS
CsrSetDirectorySecurity(
    IN HANDLE DirectoryHandle
    )
{
    PSID WorldSid = NULL;
    PSID SystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    ULONG AclLength;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PACL Dacl;

    //
    // Get the SIDs for world and system
    //

    Status = RtlAllocateAndInitializeSid( &WorldAuthority,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &WorldSid
                                        );
    if (!NT_SUCCESS(Status)) {
        WorldSid = NULL;
        goto error_cleanup;
    }

    Status = RtlAllocateAndInitializeSid( &NtAuthority,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &SystemSid
                                        );
    if (!NT_SUCCESS(Status)) {
        SystemSid = NULL;
        goto error_cleanup;
    }

    //
    // Allocate a buffer to hold the SD
    //

    AclLength = sizeof(ACL) +
                RtlLengthSid( WorldSid ) +
                RtlLengthSid( SystemSid ) +
                2 * sizeof(ACCESS_ALLOWED_ACE);

    SecurityDescriptor = RtlAllocateHeap( CsrHeap,
                                          MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                          SECURITY_DESCRIPTOR_MIN_LENGTH +
                                          AclLength
                                        );
    if (SecurityDescriptor == NULL) {
        Status = STATUS_NO_MEMORY;
        goto error_cleanup;
    }

    //
    // Create the SD
    //

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: SD creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    //
    // Create the DACL
    //

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    RtlCreateAcl( Dacl,
                  AclLength,
                  ACL_REVISION
                );
    Status = RtlAddAccessAllowedAce( Dacl,
                ACL_REVISION,
                STANDARD_RIGHTS_READ | DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
                WorldSid
                );
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    Status = RtlAddAccessAllowedAce( Dacl,
                ACL_REVISION,
                DIRECTORY_ALL_ACCESS,
                SystemSid
                );
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    //
    // Set DACL into the SD
    //

    Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor,
                                          TRUE,
                                          Dacl,
                                          FALSE);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set DACL failed - status = %lx\n", Status);
        }
        goto error_cleanup;
    }

    //
    // Put the DACL onto the direcory
    //

    Status = NtSetSecurityObject(DirectoryHandle,
                                 DACL_SECURITY_INFORMATION,
                                 SecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set directory DACL failed - status = %lx\n", Status);
        }
    }

    //
    // Cleanup
    //

error_cleanup:
    if (SecurityDescriptor != NULL) {
        RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );
    }
    if (WorldSid != NULL) {
        RtlFreeSid( WorldSid );
    }
    if (SystemSid != NULL) {
        RtlFreeSid( SystemSid );
    }

    return Status;
}

/*******************************************************************************
 *
 *  CsrPopulateDosDevices
 *
 *  Populate the new session specific DosDevices Directory. This is an
 *  export called by ntuser\server when a connection is completed.
 *
 *  The security descriptor on the sessions \DosDevices should already
 *  have been set.
 *
 * ENTRY:
 *   HANDLE NewDosDevicesDirectory - Session specific DosDevices Directory
 *   PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrPopulateDosDevices(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
    PROCESS_DEVICEMAP_INFORMATION GlobalProcessDeviceMapInfo;

    //
    // Get the global ProcessDeviceMap. We will use this to only add
    // non-network drive letters to the session specific dos devices
    // directory
    //

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &GlobalProcessDeviceMapInfo.Query,
                                        sizeof( GlobalProcessDeviceMapInfo.Query ),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtQueryInformationProcess failed in CsrPopulateDosDevices - status = %lx\n", Status);
       return Status;

    }

    //
    //  Set the CSRSS's ProcessDeviceMap to the newly created DosDevices Directory
    //

    ProcessDeviceMapInfo.Set.DirectoryHandle = DosDevicesDirectory;

    Status = NtSetInformationProcess( NtCurrentProcess(),
                                      ProcessDeviceMap,
                                      &ProcessDeviceMapInfo.Set,
                                      sizeof( ProcessDeviceMapInfo.Set )
                                    );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtSetInformationProcess failed in CsrPopulateDosDevices - status = %lx\n", Status);
       return Status;

    }

    //
    // Populate the session specfic DosDevices Directory
    //

    Status = CsrPopulateDosDevicesDirectory( DosDevicesDirectory, &GlobalProcessDeviceMapInfo );

    return Status;
}


/*******************************************************************************
 *
 *  CsrPopulateDosDevicesDirectory
 *
 *  Populate the new session specific DosDevices Direcotory
 *
 * ENTRY:
 *   HANDLE NewDosDevicesDirectory - Session specific DosDevices Directory
 *   PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrPopulateDosDevicesDirectory( HANDLE NewDirectoryHandle,
                                PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo )
{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING Target;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = NULL;
    HANDLE LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    ULONG DirInfoBufferLength = 16384; //16K
    PVOID DirInfoBuffer = NULL;
    WCHAR lpTargetPath[ 4096 ];
    ULONG Context;
    ULONG ReturnedLength = 0;
    ULONG DosDeviceDriveIndex = 0;
    WCHAR DosDeviceDriveLetter;

    //
    // Open the global DosDevices Directory. This used to populate the
    // the session specific DosDevices Directory
    //
    RtlInitUnicodeString( &UnicodeString, L"\\GLOBAL??" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtOpenDirectoryObject failed in CsrPopulateDosDevicesDirectory - status = %lx\n", Status);
       return Status;
    }




Restart:

    Context = 0;

    DirInfoBuffer = RtlAllocateHeap( CsrHeap,
                                     MAKE_TAG( PROCESS_TAG ) | HEAP_ZERO_MEMORY,
                                     DirInfoBufferLength
                                     );

    if (DirInfoBuffer == NULL) {
       Status =  STATUS_NO_MEMORY;
       goto cleanup;
    }


    while (TRUE) {

       DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

       Status = NtQueryDirectoryObject( DirectoryHandle,
                                       (PVOID)DirInfo,
                                       DirInfoBufferLength,
                                       FALSE,
                                       FALSE,
                                       &Context,
                                       &ReturnedLength
                                     );


       //
       //  Check the status of the operation.
       //

       if (!NT_SUCCESS( Status )) {
               if (Status == STATUS_BUFFER_TOO_SMALL) {
                    DirInfoBufferLength = ReturnedLength;
                    RtlFreeHeap( CsrHeap, 0, DirInfoBuffer );
                    goto Restart;
               }

               if (Status == STATUS_NO_MORE_ENTRIES) {
                   Status = STATUS_SUCCESS;
                   }

               break;
       }

       while (DirInfo->Name.Length != 0) {


           if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {




              InitializeObjectAttributes( &Attributes,
                                          &DirInfo->Name,
                                          OBJ_CASE_INSENSITIVE,
                                          DirectoryHandle,
                                          NULL
                                        );

              Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                                 SYMBOLIC_LINK_QUERY,
                                                 &Attributes
                                               );
              if (NT_SUCCESS( Status )) {
                  Target.Buffer = lpTargetPath;
                  Target.Length = 0;
                  Target.MaximumLength = 4096;
                  ReturnedLength = 0;
                  Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                      &Target,
                                                      &ReturnedLength
                                                    );
                  NtClose( LinkHandle );
                  if (NT_SUCCESS( Status )) {

                      //
                      // We only want to add Non-DOSDEVICE_DRIVE_REMOTE symbolic
                      // links to the session specific directory
                      //
                      if ((DirInfo->Name.Length == 2 * sizeof( WCHAR )) &&
                          (DirInfo->Name.Buffer[ 1 ] == L':')) {

                          DosDeviceDriveLetter = RtlUpcaseUnicodeChar( DirInfo->Name.Buffer[ 0 ] );

                          if ((DosDeviceDriveLetter >= L'A') && (DosDeviceDriveLetter <= L'Z')) {

                              DosDeviceDriveIndex = DosDeviceDriveLetter - L'A';
                              if ( (
                                       (pGlobalProcessDeviceMapInfo->Query.DriveType[DosDeviceDriveIndex] == DOSDEVICE_DRIVE_REMOTE)
                                       &&
                                       !(
                                           //Need to populate the Netware gateway drive
                                           ((Target.Length >= 13) && ((_wcsnicmp(Target.Buffer,L"\\Device\\NwRdr",13)==0)))
                                           &&
                                           ((Target.Length >= 16) && (Target.Buffer[15] != L':'))
                                       )
                                   )
                                   ||
                                   (
                                       (pGlobalProcessDeviceMapInfo->Query.DriveType[DosDeviceDriveIndex] == DOSDEVICE_DRIVE_CALCULATE)
                                       &&
                                       (
                                           ((Target.Length > 4) && (!_wcsnicmp(Target.Buffer,L"\\??\\",4)))
                                           ||
                                           ((Target.Length >= 14) && (!_wcsnicmp(Target.Buffer,L"\\Device\\WinDfs",14)))
                                       )
                                   )
                                 )

                              {
                                   //Skip remote drives and virtual drives (subst)
                                   DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR) DirInfo) + sizeof(OBJECT_DIRECTORY_INFORMATION));
                                   continue;
                              }
                          }
                      }

                     //
                     // Create the new Symbolic Link
                     //
                     // The security on the new link is inherited
                     // from the parent directory, which is setup
                     // at create time.
                     //

                     InitializeObjectAttributes( &Attributes,
                                                 &DirInfo->Name,
                                                 0,
                                                 NewDirectoryHandle,
                                                 NULL // Default security
                                                 );

                     Target.MaximumLength = Target.Length + sizeof( WCHAR );

                     Attributes.Attributes |= OBJ_PERMANENT;

                     Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                                          SYMBOLIC_LINK_ALL_ACCESS,
                                                          &Attributes,
                                                          &Target
                                                        );

                     Target.MaximumLength = 4096;

                     // Don't close the handles. Cleaned up when CSRSS goes away


                     if (!NT_SUCCESS( Status )) {
#if DBG
                            DbgPrint("CSRSS: Symbolic link creation failed in CsrPopulateDosDevicesDirectory for Name %ws and Target %ws- status = %lx for Session %ld\n", DirInfo->Name.Buffer, Target.Buffer, Status,NtCurrentPeb()->SessionId);
#endif
                            ASSERT(FALSE);
                     }
                     else {
                         NtClose( LinkHandle );
                     }

                  }
              }
           }

           DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR) DirInfo) + sizeof(OBJECT_DIRECTORY_INFORMATION));
       }
    }

cleanup:

     if (DirectoryHandle) {
        NtClose(DirectoryHandle);
     }

     if (DirInfoBuffer) {
        RtlFreeHeap( CsrHeap, 0, DirInfoBuffer );
     }

     return Status;
}


/*******************************************************************************
 *
 *  CsrCreateSessionObjectDirectory
 *
 *  Creates \Sessions\<SessionId> and \Sessions\<SessionId>\DosDevices
 *  Object Directories
 *
 * ENTRY:
 *   ULONG SessionId
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrCreateSessionObjectDirectory( ULONG SessionId )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR szString[MAX_SESSION_PATH];
    WCHAR szTargetString[MAX_SESSION_PATH];
    UNICODE_STRING UnicodeString, LinkTarget;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SymbolicLinkHandle;
    SECURITY_DESCRIPTOR DosDevicesSD;


    /*
     *   \Sessions\BNOLINKS\0 -> \BaseNamedObjects
     *   \Sessions\BNOLINKS\6 -> \Sessions\6\BaseNamedObjects
     *   \Sessions\BNOLINKS\7 -> \Sessions\7\BaseNamedObjects
     */


    //
    //Create/Open the \\Sessions\BNOLINKS directory
    //
    swprintf(szString,L"%ws\\BNOLINKS",SESSION_ROOT);

    RtlInitUnicodeString( &UnicodeString, szString );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                NULL
                              );

    Status = NtCreateDirectoryObject( &BNOLinksDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       return Status;

    }

    //
    // Create a symbolic link \\Sessions\BNOLINKS\<sessionid> pointing
    // to the session specific BaseNamedObjects directory
    // This symbolic link will be used by proccesses that want to e.g. access a
    // event in another session. This will be done by using the following
    // naming convention : Session\\<sessionid>\\ObjectName
    //

    swprintf(szString,L"%ld",SessionId);

    RtlInitUnicodeString( &UnicodeString, szString );

    if (SessionId == 0) {

       RtlInitUnicodeString( &LinkTarget, L"\\BaseNamedObjects" );

    } else {

        swprintf(szTargetString,L"%ws\\%ld\\BaseNamedObjects",SESSION_ROOT,SessionId);
        RtlInitUnicodeString(&LinkTarget, szTargetString);

    }

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                (HANDLE)BNOLinksDirectory,
                                NULL);

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &Obja,
                                         &LinkTarget );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateSymbolicLinkObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       return Status;

    }

    //
    //  Create the security descriptor to use for the object directories
    //

    Status = GetDosDevicesProtection( &DosDevicesSD );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    // Create the Sessions\\<sessionid directory
    //

    swprintf(szString,L"%ws\\%ld",SESSION_ROOT,SessionId);

    RtlInitUnicodeString( &UnicodeString, szString );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                &DosDevicesSD
                              );

    Status = NtCreateDirectoryObject( &SessionObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       FreeDosDevicesProtection( &DosDevicesSD );
       return Status;

    }

    RtlInitUnicodeString( &UnicodeString, L"DosDevices" );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                SessionObjectDirectory,
                                &DosDevicesSD
                              );

    //
    // Create the Session specific DosDevices Directory
    //

    Status = NtCreateDirectoryObject( &DosDevicesDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );
    if (!NT_SUCCESS( Status )) {
         DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
         FreeDosDevicesProtection( &DosDevicesSD );
         return Status;

    }

    FreeDosDevicesProtection( &DosDevicesSD );
    return Status;
}


NTSTATUS
GetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine builds a security descriptor for use in creating
    the \DosDevices object directory.  The protection of \DosDevices
    must establish inheritable protection which will dictate how
    dos devices created via the DefineDosDevice() and
    IoCreateUnprotectedSymbolicLink() apis can be managed.

    The protection assigned is dependent upon an administrable registry
    key:

        Key: \hkey_local_machine\System\CurrentControlSet\Control\Session Manager
        Value: [REG_DWORD] ProtectionMode

    If this value is 0x1, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            The creator of a Dos device may delete it.
            Note that this protects system-defined LPTs and COMs so that only
                administrators may redirect them.  However, anyone may add
                additional printers and direct them to wherever they would
                like.

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read | Write (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   Execute                (Inherit Only)
                    Grant:  Admins:  All Access             (Inherit Only)
                    Grant:  System:  All Access             (Inherit Only)
                    Grant:  Owner:   All Access             (Inherit Only)

    If this value is 0x0, or not present, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            Anyone may delete Dos devices created with either DefineDosDevice()
                or IoCreateUnprotectedSymbolicLink().  This is how network drives
                and LPTs are created (but not COMs).

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read | Write (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   All Access             (Inherit Only)


Arguments:

    SecurityDescriptor - The address of a security descriptor to be
        initialized and filled in.  When this security descriptor is no
        longer needed, you should call FreeDosDevicesProtection() to
        free the protection information.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG aceIndex, aclLength;
    PACL dacl = NULL;
    PACE_HEADER ace;
    ACCESS_MASK accessMask;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID LocalSystemSid;
    PSID WorldSid;
    PSID CreatorOwnerSid;
    PSID AliasAdminsSid;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES Obja;
    ULONG ProtectionMode = 0;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR ValueBuffer[ 32 ];
    ULONG ResultLength;
    HANDLE KeyHandle;

    UCHAR inheritOnlyFlags = (OBJECT_INHERIT_ACE    |
                              CONTAINER_INHERIT_ACE |
                              INHERIT_ONLY_ACE
                             );

    UCHAR inheritFlags = (OBJECT_INHERIT_ACE    |
                          CONTAINER_INHERIT_ACE
                         );


    Status = RtlCreateSecurityDescriptor( SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 );

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &WorldAuthority,
                 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &WorldSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &AliasAdminsSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        RtlFreeSid( WorldSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }


    Status = RtlAllocateAndInitializeSid(
                 &CreatorAuthority,
                 1,
                 SECURITY_CREATOR_OWNER_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &CreatorOwnerSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        RtlFreeSid( WorldSid );
        RtlFreeSid( AliasAdminsSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    InitializeObjectAttributes( &Obja,
                                &NameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey( &KeyHandle,
                        KEY_READ,
                        &Obja
                      );

    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &NameString, L"ProtectionMode" );
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &NameString,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( ValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS(Status)) {
            if (KeyValueInformation->Type == REG_DWORD &&
                *(PULONG)KeyValueInformation->Data) {
                ProtectionMode = *(PULONG)KeyValueInformation->Data;

             }
        }

        NtClose( KeyHandle );
    }



    if (ProtectionMode & 0x00000003) {

        //
        // If ProtectionMode is set to 1 or 2 Terminal Server
        // locks down sessions tight.
        //
        //  Dacl:
        //          Grant:  System:  All Access             (With Inherit)
        //          Grant:  Admins:  All Access             (With Inherit)
        //          Grant:  Owner:   All Access             (Inherit Only)
        //          Grant:  World:   No Access
        //

        aclLength = sizeof( ACL )                           +
                    3 * sizeof( ACCESS_ALLOWED_ACE )        +
                    RtlLengthSid( LocalSystemSid )          +
                    RtlLengthSid( AliasAdminsSid )          +
                    RtlLengthSid( CreatorOwnerSid );

        dacl = (PACL)RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                      aclLength );

        if (dacl == NULL) {
            Status =  STATUS_NO_MEMORY;
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        aceIndex = 0;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, LocalSystemSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritFlags;

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, AliasAdminsSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritFlags;

        //
        //  Inherit only ACE at the end of the ACL
        //          Owner
        //

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, CreatorOwnerSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

    } else {

        //
        //  DACL:
        //          Grant:  World:   Execute | Read | Write (No Inherit)
        //          Grant:  System:  All Access             (No Inherit)
        //          Grant:  World:   All Access             (Inherit Only)
        //

        aclLength = sizeof( ACL )                           +
                    3 * sizeof( ACCESS_ALLOWED_ACE )        +
                    (2*RtlLengthSid( WorldSid ))            +
                    RtlLengthSid( LocalSystemSid );

        dacl = (PACL)RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                      aclLength );

        if (dacl == NULL) {
            ASSERT( NT_SUCCESS( Status ) );
            Status =  STATUS_NO_MEMORY;
            goto cleanup;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        //
        //  Non-inheritable ACEs first
        //      World
        //      System
        //

        aceIndex = 0;
        accessMask = (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, WorldSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, LocalSystemSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        //
        //  Inheritable ACEs at the end of the ACL
        //          World
        //

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, WorldSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

       if (!NT_SUCCESS( Status )) {
          ASSERT( NT_SUCCESS( Status ) );
          goto cleanup;
       }
    }

cleanup:
    if (!NT_SUCCESS( Status ) && (dacl != NULL)) {
       RtlFreeHeap( CsrHeap, 0, dacl);
    }

    RtlFreeSid( LocalSystemSid );
    RtlFreeSid( WorldSid );
    RtlFreeSid( AliasAdminsSid );
    RtlFreeSid( CreatorOwnerSid );
    if (!NT_SUCCESS( Status )) {
         DbgPrint("CSRSS: GetDosDevicesProtection failed - status = %lx\n", Status);
         ASSERT( NT_SUCCESS( Status ) );
    }

    return Status;
}


VOID
FreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees memory allocated via GetDosDevicesProtection().

Arguments:

    SecurityDescriptor - The address of a security descriptor initialized by
        GetDosDevicesProtection().

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PACL Dacl = NULL;
    BOOLEAN DaclPresent, Defaulted;

    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                           &DaclPresent,
                                           &Dacl,
                                           &Defaulted);

    ASSERT(NT_SUCCESS(Status));
    ASSERT(DaclPresent);
    ASSERT(Dacl != NULL);
    if (NT_SUCCESS(Status) && Dacl != NULL) {
        RtlFreeHeap(CsrHeap, 0, Dacl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\client\smstub.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smstub.c

Abstract:

    Session Manager Client Support APIs

Author:

    Mark Lucovsky (markl) 05-Oct-1989

Revision History:

    Samer Arafeh (samera) 24-Oct-2001      
        - Implement Wow64 support.
    

--*/

#include "smdllp.h"
#include <string.h>
#include "smp6432.h"


NTSTATUS
SmExecPgm(
    IN HANDLE SmApiPort,
    IN PRTL_USER_PROCESS_INFORMATION ProcessInformation,
    IN BOOLEAN DebugFlag
    )

/*++

Routine Description:

    This routine allows a process to start a process using the
    facilities provided by the NT Session manager.

    This function closes all handles passed to it.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    ProcessInformation - Supplies a process description as returned
        by RtlCreateUserProcess.

    DebugFlag - Supplies and optional parameter which if set indicates
        that the caller wants to debug this process and act as its
        debug user interface.

Return Value:

    TBD.

--*/

{
    NTSTATUS st;

    SMAPIMSG SmApiMsg;
    PSMEXECPGM args;

#if defined(_X86_)
    if (SmpIsWow64Process () == TRUE) {
        return SmpWow64ExecPgm (
            SmApiPort,
            ProcessInformation,
            DebugFlag);
    }
#endif

    args = &SmApiMsg.u.ExecPgm;

    args->ProcessInformation = *ProcessInformation;

    args->DebugFlag = DebugFlag;

    SmApiMsg.ApiNumber = SmExecPgmApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        KdPrint(("SmExecPgm: NtRequestWaitReply Failed %lx\n",st));
    }

    NtClose(ProcessInformation->Process);
    NtClose(ProcessInformation->Thread);
    return st;

}

NTSTATUS
NTAPI
SmLoadDeferedSubsystem(
    IN HANDLE SmApiPort,
    IN PUNICODE_STRING DeferedSubsystem
    )

/*++

Routine Description:

    This routine allows a process to start a defered subsystem.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    DeferedSubsystem - Supplies the name of the defered subsystem to load.

Return Value:

    TBD.

--*/

{
    NTSTATUS st;

    SMAPIMSG SmApiMsg;
    PSMLOADDEFERED args;

#if defined(_X86_)
    if (SmpIsWow64Process () == TRUE) {
        return SmpWow64LoadDeferedSubsystem (
            SmApiPort,
            DeferedSubsystem
            );
    }
#endif

    if ( DeferedSubsystem->Length >> 1 > SMP_MAXIMUM_SUBSYSTEM_NAME ) {
        return STATUS_INVALID_PARAMETER;
        }

    args = &SmApiMsg.u.LoadDefered;
    args->SubsystemNameLength = DeferedSubsystem->Length;
    RtlCopyMemory(args->SubsystemName,DeferedSubsystem->Buffer,DeferedSubsystem->Length);

    SmApiMsg.ApiNumber = SmLoadDeferedSubsystemApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        KdPrint(("SmExecPgm: NtRequestWaitReply Failed %lx\n",st));
    }

    return st;

}


NTSTATUS
SmSessionComplete(
    IN HANDLE SmApiPort,
    IN ULONG SessionId,
    IN NTSTATUS CompletionStatus
    )

/*++

Routine Description:

    This routine is used to report completion of a session to
    the NT Session manager.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    SessionId - Supplies the session id of the session which is now completed.

    CompletionStatus - Supplies the completion status of the session.

Return Value:

    TBD.

--*/

{
    NTSTATUS st;

    SMAPIMSG SmApiMsg;
    PSMSESSIONCOMPLETE args;

#if defined(_X86_)
    if (SmpIsWow64Process () == TRUE) {
        return SmpWow64SessionComplete (
            SmApiPort,
            SessionId,
            CompletionStatus
            );
    }
#endif    
    
    args = &SmApiMsg.u.SessionComplete;

    args->SessionId = SessionId;
    args->CompletionStatus = CompletionStatus;

    SmApiMsg.ApiNumber = SmSessionCompleteApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        KdPrint(("SmCompleteSession: NtRequestWaitReply Failed %lx\n",st));
    }

    return st;
}

NTSTATUS
SmStartCsr(
    IN HANDLE SmApiPort,
    OUT PULONG pMuSessionId,
    IN PUNICODE_STRING InitialCommand,
    OUT PULONG_PTR pInitialCommandProcessId,
    OUT PULONG_PTR pWindowsSubSysProcessId
    )

/*++

Routine Description:

    This routine allows TERMSRV to start a new CSR.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    MuSessionId - Hydra Terminal Session Id to start CSR in.

    InitialCommand - String for Initial Command (for debug)

    pInitialCommandProcessId - pointer to Process Id of initial command.

    pWindowsSubSysProcessId - pointer to Process Id of Windows subsystem.

Return Value:

    Whether it worked.

--*/

{
    NTSTATUS st;

    SMAPIMSG SmApiMsg;
    PSMSTARTCSR args;

#if defined(_X86_)
    if (SmpIsWow64Process () == TRUE) {        
        return SmpWow64StartCsr (
            SmApiPort,
            pMuSessionId,
            InitialCommand,
            pInitialCommandProcessId,
            pWindowsSubSysProcessId
            );
    }
#endif

    args = &SmApiMsg.u.StartCsr;

    args->MuSessionId = *pMuSessionId; //Sm will reassign the actuall sessionID

    if ( InitialCommand &&
         ( InitialCommand->Length >> 1 > SMP_MAXIMUM_INITIAL_COMMAND ) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( !InitialCommand ) {
        args->InitialCommandLength = 0;
    }
    else {
        args->InitialCommandLength = InitialCommand->Length;
        RtlCopyMemory(args->InitialCommand,InitialCommand->Buffer,InitialCommand->Length);
    }

    SmApiMsg.ApiNumber = SmStartCsrApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        DbgPrint("SmStartCsr: NtRequestWaitReply Failed %lx\n",st);
    }

    *pInitialCommandProcessId = args->InitialCommandProcessId;
    *pWindowsSubSysProcessId = args->WindowsSubSysProcessId;
    *pMuSessionId = args->MuSessionId;

    return st;

}


NTSTATUS
SmStopCsr(
    IN HANDLE SmApiPort,
    IN ULONG MuSessionId
    )

/*++

Routine Description:

    This routine allows TERMSRV to stop a CSR.

Arguments:

    SmApiPort - Supplies a handle to a communications port connected
        to the Session Manager.

    MuSessionId - Terminal Server Session Id to stop

Return Value:

    Whether it worked.

--*/

{
    NTSTATUS st;

    SMAPIMSG SmApiMsg;
    PSMSTOPCSR args;

#if defined(_X86_)
    if (SmpIsWow64Process () == TRUE) {
        return SmpWow64StopCsr (
            SmApiPort,
            MuSessionId
            );
    }
#endif

    args = &SmApiMsg.u.StopCsr;

    args->MuSessionId = MuSessionId;

    SmApiMsg.ApiNumber = SmStopCsrApi;
    SmApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SmApiMsg.h.u1.s1.TotalLength = sizeof(SmApiMsg);
    SmApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            SmApiPort,
            (PPORT_MESSAGE) &SmApiMsg,
            (PPORT_MESSAGE) &SmApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SmApiMsg.ReturnedStatus;
    } else {
        DbgPrint("SmStopCsr: NtRequestWaitReply Failed %lx\n",st);
    }

    return st;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\inc\sm.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sm.h

Abstract:

    Session Manager Types and Prototypes

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#ifndef _SM_
#define _SM_




//
// Message formats used by clients of the session manager.
//

typedef struct _SMCONNECTINFO {
    ULONG ImageType;
} SMCONNECTINFO, *PSMCONNECTINFO;

typedef enum _SMAPINUMBER {
    SmCreateForeignSessionApi,
    SmSessionCompleteApi,
    SmTerminateForeignSessionApi,
    SmExecPgmApi,
    SmLoadDeferedSubsystemApi,
    SmStartCsrApi,
    SmStopCsrApi,
    SmMaxApiNumber
} SMAPINUMBER;

typedef struct _SMCREATEFOREIGNSESSION {
    ULONG ForeignSessionId;
    ULONG SourceSessionId;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    CLIENT_ID DebugUiClientId;
} SMCREATEFOREIGNSESSION, *PSMCREATEFOREIGNSESSION;

typedef struct _SMSESSIONCOMPLETE {
    ULONG SessionId;
    NTSTATUS CompletionStatus;
} SMSESSIONCOMPLETE, *PSMSESSIONCOMPLETE;

typedef struct _SMTERMINATEFOREIGNSESSION {
    ULONG Tbd;
} SMTERMINATEFOREIGNSESSION, *PSMTERMINATEFOREIGNSESSION;



typedef struct _SMEXECPGM {
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    BOOLEAN DebugFlag;
} SMEXECPGM, *PSMEXECPGM;

#define SMP_MAXIMUM_SUBSYSTEM_NAME 32

typedef struct _SMLOADDEFERED {
    ULONG SubsystemNameLength;
    WCHAR SubsystemName[SMP_MAXIMUM_SUBSYSTEM_NAME];
} SMLOADDEFERED, *PSMLOADDEFERED;

#define SMP_MAXIMUM_INITIAL_COMMAND 128
typedef struct _SMSTARTCSR {
    ULONG  MuSessionId;
    ULONG  InitialCommandLength;
    WCHAR  InitialCommand[SMP_MAXIMUM_INITIAL_COMMAND];
    ULONG_PTR  InitialCommandProcessId;
    ULONG_PTR  WindowsSubSysProcessId;
} SMSTARTCSR, *PSMSTARTCSR;

typedef struct _SMSTOPCSR {
    ULONG  MuSessionId;
} SMSTOPCSR, *PSMSTOPCSR;

typedef struct _SMAPIMSG {
    PORT_MESSAGE h;
    SMAPINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        SMCREATEFOREIGNSESSION CreateForeignSession;
        SMSESSIONCOMPLETE SessionComplete;
        SMTERMINATEFOREIGNSESSION TerminateForeignComplete;
        SMEXECPGM ExecPgm;
        SMLOADDEFERED LoadDefered;
        SMSTARTCSR StartCsr;
        SMSTOPCSR StopCsr;
    } u;
} SMAPIMSG, *PSMAPIMSG;

typedef union _SMMESSAGE_SIZE {
        DBGKM_APIMSG m1;
        SMAPIMSG m2;
        SBAPIMSG m3;
} SMMESSAGE_SIZE;


#endif // _SM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smcrash.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smcrash.c

Abstract:

    Routines related to crashdump creation.

Author:

    Matthew D Hendel (math) 28-Aug-2000

Revision History:

--*/

#include "smsrvp.h"
#include <ntiodump.h>
#include <stdio.h>
#include <string.h>
    

#define REVIEW KdBreakPoint
#define CRASHDUMP_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl"


typedef struct _CRASH_PARAMETERS {
    UNICODE_STRING DumpFileName;
    UNICODE_STRING MiniDumpDir;
    ULONG Overwrite;
    ULONG TempDestination;
} CRASH_PARAMETERS, *PCRASH_PARAMETERS;


//
// These are the first two fields of a crashdump file.
//

typedef struct _SMP_DUMP_HEADER_SIGNATURE {
    ULONG Signature;
    ULONG ValidDump;
} SMP_DUMP_HEADER_SIGNATURE, *PSMP_DUMP_HEADER_SIGNATURE;

//
// Verify that these fields haven't changed location.
//

C_ASSERT (FIELD_OFFSET (SMP_DUMP_HEADER_SIGNATURE, Signature) ==
          FIELD_OFFSET (DUMP_HEADER, Signature));
C_ASSERT (FIELD_OFFSET (SMP_DUMP_HEADER_SIGNATURE, ValidDump) ==
          FIELD_OFFSET (DUMP_HEADER, ValidDump));

//
// Forward declarations
//

BOOLEAN
SmpQueryFileExists(
    IN PUNICODE_STRING FileName
    );
    
NTSTATUS
SmpCanCopyCrashDump(
    IN PDUMP_HEADER DumpHeader,
    IN PCRASH_PARAMETERS Parameters,
    IN PUNICODE_STRING PageFileName,
    IN ULONGLONG PageFileSize,
    OUT PUNICODE_STRING DumpFile
    );
    
NTSTATUS
SmpGetCrashParameters(
    IN PDUMP_HEADER DumpHeader,
    OUT PCRASH_PARAMETERS CrashParameters
    );

NTSTATUS
SmpCopyDumpFile(
    IN PDUMP_HEADER MemoryDump,
    IN HANDLE PageFile,
    IN PUNICODE_STRING DumpFileName
    );



//
// Functions
//


PVOID
SmpAllocateString(
    IN SIZE_T Length
    )
{
    return RtlAllocateHeap (RtlProcessHeap(),
                            MAKE_TAG( INIT_TAG ),
                            Length);
}

VOID
SmpFreeString(
    IN PVOID Pointer
    )
{
    RtlFreeHeap (RtlProcessHeap(),
                 0,
                 Pointer);
}


NTSTATUS
SmpSetDumpSecurity(
    IN HANDLE File
    )
/*++

Routine Description:

    Set the correct security descriptors for the dump file. The security
    descriptors are:

        Everybody - None.

        LocalSystem - Generic-All, Delete, Write-Dac, Write-Owner

        Admin - Generic-All, Delete, Write-Dac, Write-Owner. Admin is owner.

Arguments:

    File - Supplies a handle to the dump file whose security descriptors
        will be set.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY ;
    PSID EveryoneSid = NULL;
    PSID LocalSystemSid = NULL;
    PSID AdminSid = NULL;
    UCHAR DescriptorBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    UCHAR AclBuffer[1024];
    PACL Acl;
    PSECURITY_DESCRIPTOR SecurityDescriptor;



    Acl = (PACL)AclBuffer;
    SecurityDescriptor = (PSECURITY_DESCRIPTOR)DescriptorBuffer;


    RtlAllocateAndInitializeSid( &WorldAuthority, 1, SECURITY_WORLD_RID,
                                0, 0, 0, 0, 0, 0, 0, &EveryoneSid );

    RtlAllocateAndInitializeSid( &NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0, &LocalSystemSid );

    RtlAllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0, &AdminSid );

    //
    // You can be fancy and compute the exact size, but since the
    // security descriptor capture code has to do that anyway, why
    // do it twice?
    //

    RtlCreateSecurityDescriptor (SecurityDescriptor,
                                 SECURITY_DESCRIPTOR_REVISION);
                                 
    RtlCreateAcl (Acl, 1024, ACL_REVISION);

#if 0
    //
    // anybody can delete it
    //

    RtlAddAccessAllowedAce (Acl,
                            ACL_REVISION,
                            DELETE,
                            EveryoneSid);
#endif

    //
    // Administrator and system have full control
    //

    RtlAddAccessAllowedAce (Acl,
                            ACL_REVISION,
                            GENERIC_ALL | DELETE | WRITE_DAC | WRITE_OWNER,
                            AdminSid);

    RtlAddAccessAllowedAce (Acl,
                            ACL_REVISION,
                            GENERIC_ALL | DELETE | WRITE_DAC | WRITE_OWNER,
                            LocalSystemSid);

    RtlSetDaclSecurityDescriptor (SecurityDescriptor, TRUE, Acl, FALSE);
    RtlSetOwnerSecurityDescriptor (SecurityDescriptor, AdminSid, FALSE);

    Status = NtSetSecurityObject (File,
                         DACL_SECURITY_INFORMATION,
                         SecurityDescriptor);

    RtlFreeHeap (RtlProcessHeap(), 0, EveryoneSid);
    RtlFreeHeap (RtlProcessHeap(), 0, LocalSystemSid);
    RtlFreeHeap (RtlProcessHeap(), 0, AdminSid);

    return Status;
}


VOID
SmpInitializeVolumePath(
    IN PUNICODE_STRING FileOnVolume,
    OUT PUNICODE_STRING VolumePath
    )
{
    ULONG n;
    PWSTR s;
    
    *VolumePath = *FileOnVolume;
    n = VolumePath->Length;
    VolumePath->Length = 0;
    s = VolumePath->Buffer;

    while (n) {

        if (*s++ == L':' && *s == OBJ_NAME_PATH_SEPARATOR) {
            s++;
            break;
        }
        else {
            n -= sizeof( WCHAR );
        }
    }

    VolumePath->Length = (USHORT)((PCHAR)s - (PCHAR)VolumePath->Buffer);
}

NTSTATUS
SmpQueryPathFromRegistry(
    IN HANDLE Key,
    IN PWSTR Value,
    IN PWSTR DefaultValue,
    OUT PUNICODE_STRING Path
    )
{
    NTSTATUS Status;
    UNICODE_STRING ValueName;
    ULONG KeyValueLength;
    UCHAR KeyValueBuffer [VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    WCHAR Buffer[258];
    UNICODE_STRING TempString;
    UNICODE_STRING ExpandedString;
    PWSTR DosPathName;
    BOOLEAN Succ;


    DosPathName = NULL;
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    
    RtlInitUnicodeString (&ValueName, Value);
    KeyValueLength = sizeof (KeyValueBuffer);
    Status = NtQueryValueKey (Key,
                              &ValueName,
                              KeyValuePartialInformation,
                              KeyValueInfo,
                              KeyValueLength,
                              &KeyValueLength);


    if (NT_SUCCESS (Status)) {

        if (KeyValueInfo->Type == REG_EXPAND_SZ) {

            TempString.Length = (USHORT)KeyValueLength;
            TempString.MaximumLength = (USHORT)KeyValueLength;
            TempString.Buffer = (PWSTR)KeyValueInfo->Data;

            ExpandedString.Length = 0;
            ExpandedString.MaximumLength = sizeof (Buffer);
            ExpandedString.Buffer = Buffer;

            Status = RtlExpandEnvironmentStrings_U (NULL,
                                                    &TempString,
                                                    &ExpandedString,
                                                    NULL);
            if (NT_SUCCESS (Status)) {
                DosPathName = ExpandedString.Buffer;
            }
            
        } else if (KeyValueInfo->Type == REG_SZ) {
            DosPathName = (PWSTR)KeyValueInfo->Data;
        }
    }

    if (!DosPathName) {
        DosPathName = DefaultValue;
    }
    
    Succ = RtlDosPathNameToNtPathName_U (DosPathName, Path, NULL, NULL);

    return (Succ ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SmpQueryDwordFromRegistry(
    IN HANDLE Key,
    IN PWSTR Value,
    IN ULONG DefaultValue,
    OUT PULONG Dword
    )
{
    NTSTATUS Status;
    UNICODE_STRING ValueName;
    ULONG KeyValueLength;
    UCHAR KeyValueBuffer [VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    RtlInitUnicodeString (&ValueName, L"Overwrite");
    KeyValueLength = sizeof (KeyValueBuffer);
    Status = NtQueryValueKey (Key,
                              &ValueName,
                              KeyValuePartialInformation,
                              KeyValueInfo,
                              KeyValueLength,
                              &KeyValueLength);

    if (NT_SUCCESS (Status) && KeyValueInfo->Type == REG_DWORD) {
        *Dword = *(PULONG)KeyValueInfo->Data;
    } else {
        *Dword = DefaultValue;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SmpCreateUnicodeString(
    IN PUNICODE_STRING String,
    IN PWSTR InitString,
    IN ULONG MaximumLength
    )
{
    if (MaximumLength == -1) {
        MaximumLength = (wcslen (InitString) + 1) * 2;
    }
    
    if (MaximumLength >= UNICODE_STRING_MAX_CHARS) {
        return STATUS_NO_MEMORY;
    }
    String->Buffer = RtlAllocateStringRoutine (MaximumLength + 1);
    if (String->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    String->MaximumLength = (USHORT)MaximumLength;

    if (InitString) {
        wcscpy (String->Buffer, InitString);
        String->Length = (USHORT)wcslen (String->Buffer) * sizeof (WCHAR);
    } else {
        String->Length = 0;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SmpCreateTempFile(
    IN PUNICODE_STRING Directory,
    IN PWSTR Prefix,
    OUT PUNICODE_STRING TempFileName
    )
{
    ULONG i;
    ULONG Tick;
    WCHAR Buffer [260];
    UNICODE_STRING FileName;
    NTSTATUS Status;

    Tick = NtGetTickCount ();
    
    for (i = 0; i < 100; i++) {
    
        swprintf (Buffer,
                  L"%s\\%s%4.4x.tmp",
                  Directory->Buffer,
                  Prefix,
                  (Tick + i) & 0xFFFF);

        Status = RtlDosPathNameToNtPathName_U (Buffer,
                                               &FileName,
                                               NULL,
                                               NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if (!SmpQueryFileExists (&FileName)) {
            *TempFileName = FileName;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_UNSUCCESSFUL;
}
    
NTSTATUS
SmpQueryVolumeFreeSpace(
    IN PUNICODE_STRING FileOnVolume,
    OUT PULONGLONG VolumeFreeSpace
    )
{
    NTSTATUS Status;
    UNICODE_STRING VolumePath;
    PWCHAR s;
    ULONG n;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONGLONG AvailableBytes;
    
    //
    // Create an unicode string (VolumePath) containing only the
    // volume path from the pagefile name description (e.g. we get
    // "C:\" from "C:\pagefile.sys".
    //

    VolumePath = *FileOnVolume;
    n = VolumePath.Length;
    VolumePath.Length = 0;
    s = VolumePath.Buffer;

    while (n) {

        if (*s++ == L':' && *s == OBJ_NAME_PATH_SEPARATOR) {
            s++;
            break;
        }
        else {
            n -= sizeof( WCHAR );
        }
    }

    VolumePath.Length = (USHORT)((PCHAR)s - (PCHAR)VolumePath.Buffer);
    InitializeObjectAttributes( &ObjectAttributes,
                                &VolumePath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenFile( &Handle,
                         (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile( Handle,
                                           &IoStatusBlock,
                                           &SizeInfo,
                                           sizeof( SizeInfo ),
                                           FileFsSizeInformation
                                         );
    NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    // Compute the AvailableBytes on the volume.
    // Deal with 64 bit sizes.
    //

    AvailableBytes = SizeInfo.AvailableAllocationUnits.QuadPart *
                     SizeInfo.SectorsPerAllocationUnit *
                     SizeInfo.BytesPerSector;

    *VolumeFreeSpace = AvailableBytes;

    return STATUS_SUCCESS;
    
}


BOOLEAN
SmpQuerySameVolume(
    IN PUNICODE_STRING FileName1,
    IN PUNICODE_STRING FileName2
    )
/*++

Routine Description:

    Check if FileName1 and FileName2 are on the same volume.

Arguments:

    FileName1 - Supplies the name of the first file to open.

    FileName2 - Supplies the name of the second file to check against.

Return Value:

    TRUE - If the files are on the same volume.

    FALSE - Otherwise.

--*/
{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG SerialNumber;
    struct {
        FILE_FS_VOLUME_INFORMATION Volume;
        WCHAR Buffer [100];
    } VolumeInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING VolumePath;

    SmpInitializeVolumePath (FileName1, &VolumePath);
    InitializeObjectAttributes (&ObjectAttributes,
                                &VolumePath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&Handle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    Status = NtQueryVolumeInformationFile (Handle,
                                           &IoStatusBlock,
                                           &VolumeInfo,
                                           sizeof (VolumeInfo),
                                           FileFsVolumeInformation);

    if (!NT_SUCCESS (Status)) {
        NtClose (Handle);
        return FALSE;
    }

    SerialNumber = VolumeInfo.Volume.VolumeSerialNumber;
    NtClose (Handle);

    SmpInitializeVolumePath (FileName2, &VolumePath);
    InitializeObjectAttributes (&ObjectAttributes,
                                &VolumePath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&Handle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    Status = NtQueryVolumeInformationFile (Handle,
                                           &IoStatusBlock,
                                           &VolumeInfo,
                                           sizeof (VolumeInfo),
                                           FileFsVolumeInformation);
    NtClose (Handle);
    
    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    return ((SerialNumber == VolumeInfo.Volume.VolumeSerialNumber) ? TRUE : FALSE);
}


NTSTATUS
SmpSetEndOfFile(
    IN HANDLE File,
    IN ULONGLONG EndOfFile
    )
/*++

Routine Description:

    Expand or truncate a file to a specific size.

Arguments:

    File - Supplies the file handle of the file to be expanded
        or truncated.

    EndOfFile - Supplies the final size of the file.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    FILE_END_OF_FILE_INFORMATION EndOfFileInfo;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    IO_STATUS_BLOCK IoStatusBlock;
                                  
    EndOfFileInfo.EndOfFile.QuadPart = EndOfFile;
    Status = NtSetInformationFile (File,
                                   &IoStatusBlock,
                                   &EndOfFileInfo,
                                   sizeof (EndOfFileInfo),
                                   FileEndOfFileInformation);

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    AllocationInfo.AllocationSize.QuadPart = EndOfFile;
    Status = NtSetInformationFile (File,
                                   &IoStatusBlock,
                                   &AllocationInfo,
                                   sizeof (AllocationInfo),
                                   FileAllocationInformation);

    return Status;
}


NTSTATUS
SmpQueryFileSize(
    IN HANDLE FileHandle,
    OUT PULONGLONG FileSize
    )
/*++

Routine Description:

    Query the size of the specified file.

Arguments:

    FileHandle - Supplies a handle to the file whose size is
            to be querried.

    FileSize - Supplies a pointer to a buffer where the size is
            copied.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;
    
    Status = NtQueryInformationFile (FileHandle,
                                     &IoStatusBlock,
                                     &StandardInfo,
                                     sizeof (StandardInfo),
                                     FileStandardInformation);

    if (NT_SUCCESS (Status)) {
        *FileSize = StandardInfo.AllocationSize.QuadPart;
    }

    return Status;
}


BOOLEAN
SmpQueryFileExists(
    IN PUNICODE_STRING FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    
    
    InitializeObjectAttributes (&ObjectAttributes,
                                FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&Handle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    NtClose (Handle);

    return TRUE;
}


BOOLEAN
SmpCheckForCrashDump(
    IN PUNICODE_STRING PageFileName
    )
/*++

Routine Description:

    Check the paging file to see if there is a valid crashdump
    in it. This can only be done before we call NtCreatePagingFile.

Arguments:

    PageFileName - Name of the paging file we are about to create.

Return Value:

    TRUE - If the paging file contains a valid crashdump.

    FALSE - If the paging file does not contain a valid crashdump.

--*/
{
    NTSTATUS Status;
    HANDLE PageFile;
    HANDLE Key;
    BOOLEAN Copied;
    DUMP_HEADER DumpHeader;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONGLONG PageFileSize;
    UNICODE_STRING String;
    CRASH_PARAMETERS CrashParameters;
    UNICODE_STRING DumpFileName;
    BOOLEAN ClosePageFile;
    BOOLEAN CloseKey;

    RtlZeroMemory (&CrashParameters, sizeof (CRASH_PARAMETERS));
    RtlZeroMemory (&DumpFileName, sizeof (UNICODE_STRING));
    PageFile = (HANDLE)-1;
    ClosePageFile = FALSE;
    Key = (HANDLE)-1;
    CloseKey = FALSE;
    Copied = FALSE;
    

    InitializeObjectAttributes (&ObjectAttributes,
                                PageFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&PageFile,
                         GENERIC_READ | GENERIC_WRITE |
                            DELETE | WRITE_DAC | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS (Status)) {
        Copied = FALSE;
        goto done;
    } else {
        ClosePageFile = TRUE;
    }

    Status = SmpQueryFileSize (PageFile, &PageFileSize);

    if (!NT_SUCCESS (Status)) {
        PageFileSize = 0;
    }

    Status = NtReadFile (PageFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         &DumpHeader,
                         sizeof (DUMP_HEADER),
                         NULL,
                         NULL);

    if (NT_SUCCESS (Status) &&
        DumpHeader.Signature == DUMP_SIGNATURE &&
        DumpHeader.ValidDump == DUMP_VALID_DUMP) {

        Status = SmpGetCrashParameters (&DumpHeader, &CrashParameters);

        if (NT_SUCCESS (Status)) {
            Status = SmpCanCopyCrashDump (&DumpHeader,
                                          &CrashParameters,
                                          PageFileName,
                                          PageFileSize,
                                          &DumpFileName);

            if (NT_SUCCESS (Status)) {

                Status = SmpCopyDumpFile (&DumpHeader,
                                          PageFile,
                                          &DumpFileName);

                if (NT_SUCCESS (Status)) {
                    Copied = TRUE;
                }
            }
        }
    }

    NtClose (PageFile);
    PageFile = (HANDLE) -1;
    ClosePageFile = FALSE;
        
    if (Copied) {

        //
        // It is not necessary to create a new pagefile of the same
        // size as the old one. The function NtCreatePagingFile will
        // completely desroy the old paging file.
        //
        
        //
        // If we successfully copied, we want to create
        // a volitile registry key that others can use
        // to locate the dump file.
        //

        RtlInitUnicodeString (&String, CRASHDUMP_KEY L"\\MachineCrash");
        InitializeObjectAttributes (&ObjectAttributes,
                                    &String,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);
                                    
        Status = NtCreateKey (&Key,
                              KEY_READ | KEY_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              REG_OPTION_VOLATILE,
                              NULL);

        if (NT_SUCCESS (Status)) {

            CloseKey = TRUE;

            //
            // We are setting volatile key CrashControl\MachineCrash\DumpFile
            // to the name of the dump file.
            //

            RtlInitUnicodeString (&String, L"DumpFile");
            Status = NtSetValueKey (Key,
                                    &String,
                                    0,
                                    REG_SZ,
                                    &DumpFileName.Buffer[4],
                                    DumpFileName.Length - (3 * sizeof (WCHAR)));

            RtlInitUnicodeString (&String, L"TempDestination");
            Status = NtSetValueKey (Key,
                                    &String,
                                    0,
                                    REG_DWORD,
                                    &CrashParameters.TempDestination,
                                    sizeof (CrashParameters.TempDestination));
                                    
            NtClose (Key);
            Key = (HANDLE) -1;
            CloseKey = FALSE;
        }
    }

done:

    //
    // Cleanup and return
    //

    if (CrashParameters.DumpFileName.Length != 0) {
        RtlFreeUnicodeString (&CrashParameters.DumpFileName);
    }

    if (CrashParameters.MiniDumpDir.Length != 0) {
        RtlFreeUnicodeString (&CrashParameters.MiniDumpDir);
    }

    if (ClosePageFile) {
        NtClose (PageFile);
    }

    if (CloseKey) {
        NtClose (Key);
    }
        
    return Copied;
}


NTSTATUS
SmpGetCrashParameters(
    IN PDUMP_HEADER DumpHeader,
    OUT PCRASH_PARAMETERS CrashParameters
    )
/*++

Routine Description:

    Get the parameters for the crashdump from
    the registry.

Arguments:

    DumpHeader - Pointer to the mapped dump headers.

    CrashParameters - Supplies a buffer where the crash parameters
        should be copied.
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    HANDLE Key;
    BOOLEAN CloseKey;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR DefaultPath[260];

    Key = (HANDLE) -1;
    CloseKey = FALSE;

    RtlInitUnicodeString (&KeyName, CRASHDUMP_KEY);
    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    Status = NtOpenKey (&Key, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS (Status)) {
        CloseKey = TRUE;
    } else {
        goto done;
    }
    
    swprintf (DefaultPath, L"%s\\MEMORY.DMP", SmpSystemRoot.Buffer);

    Status = SmpQueryPathFromRegistry (Key,
                                       L"DumpFile",
                                       DefaultPath,
                                       &CrashParameters->DumpFileName);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    swprintf (DefaultPath, L"%s\\Minidump", SmpSystemRoot.Buffer);
    
    Status = SmpQueryPathFromRegistry (Key,
                                       L"MiniDumpDir",
                                       DefaultPath,
                                       &CrashParameters->MiniDumpDir);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    Status = SmpQueryDwordFromRegistry (Key,
                                       L"Overwrite",
                                       1,
                                       &CrashParameters->Overwrite);
    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // This value is initialized by SmpCanCopyCrashDump.
    //
        
    CrashParameters->TempDestination = FALSE;
    Status = STATUS_SUCCESS;

done:
    if (CloseKey) {
        NtClose (Key);
    }
    
    return Status;
}


NTSTATUS
SmpCopyDumpFile(
    IN PDUMP_HEADER MemoryDump,
    IN HANDLE PageFile,
    IN PUNICODE_STRING DumpFileName
    )
/*++

Routine Description:

    Copy the dump file from the pagefile to the crash dump file.

Arguments:

    DumpHeader - Pointer to the beginning of the crashdump header.

    PageFile - Pointer to an opened handle to the pagefile that contains
        the dump.

    DumpFileName -

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONGLONG DumpFileSize;
    struct {
        FILE_RENAME_INFORMATION Rename;
        WCHAR Buffer[255];
    } RenameInfoBuffer;
    PFILE_RENAME_INFORMATION RenameInfo;
    ULONG RenameInfoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInformation;

    RenameInfo = &RenameInfoBuffer.Rename;
    DumpFileSize = MemoryDump->RequiredDumpSpace.QuadPart;

    Status = SmpSetEndOfFile (PageFile, DumpFileSize);
    
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    RenameInfoSize = sizeof (FILE_RENAME_INFORMATION) + DumpFileName->Length;
    
    RenameInfo->ReplaceIfExists = TRUE;
    RenameInfo->RootDirectory = NULL;
    RenameInfo->FileNameLength = DumpFileName->Length;
    wcscpy (RenameInfo->FileName, DumpFileName->Buffer);

    Status = NtSetInformationFile (PageFile,
                                   &IoStatusBlock,
                                   RenameInfo,
                                   RenameInfoSize,
                                   FileRenameInformation);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Reset the file SYSTEM and HIDDEN attributes.
    //
    
    Status = NtQueryInformationFile (PageFile,
                                     &IoStatusBlock,
                                     &BasicInformation,
                                     sizeof (BasicInformation),
                                     FileBasicInformation);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    BasicInformation.FileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
    BasicInformation.FileAttributes &= ~FILE_ATTRIBUTE_SYSTEM;

    Status = NtSetInformationFile (PageFile,
                                   &IoStatusBlock,
                                   &BasicInformation,
                                   sizeof (BasicInformation),
                                   FileBasicInformation);

    //
    // Reset the file security.
    //
    
    Status = SmpSetDumpSecurity (PageFile);
           
    return Status;
}




NTSTATUS
SmpCanCopyCrashDump(
    IN PDUMP_HEADER DumpHeader,
    IN PCRASH_PARAMETERS CrashParameters,
    IN PUNICODE_STRING PageFileName,
    IN ULONGLONG PageFileSize,
    OUT PUNICODE_STRING DumpFileName
    )
/*++

Routine Description:

    Figure out whether it's ok to copy the dump file or not.

Arguments:

    DumpHeader - Supplies the header to the dump file.

    CrashParameters - Supplies the parameters required to copy the file.

    DumpFileName - Supplies a unicode string buffer that the crashdump
            will be copied to.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BOOLEAN SameVolume;
    BOOLEAN UseTempFile;
    ULONGLONG CrashFileSize;
    ULONGLONG VolumeFreeSpace;

    UseTempFile = FALSE;

    if (DumpHeader->DumpType == DUMP_TYPE_TRIAGE) {
        UseTempFile = TRUE;
    } else {
        SameVolume = SmpQuerySameVolume (PageFileName,
                                         &CrashParameters->DumpFileName);

        
        if (SameVolume) {

            //
            // If we're on the same volume and there is an existing dump file
            // then :
            //     if overwrite flag was not set, fail.
            //     otherwise, reclaim the space for this file.
            //
            
            if (SmpQueryFileExists (&CrashParameters->DumpFileName)) {

                if (CrashParameters->Overwrite) {

                    SmpDeleteFile (&CrashParameters->DumpFileName);

                } else {

                    return STATUS_UNSUCCESSFUL;
                }
            }
        } else {

            //
            // We're not on the same volume, so we'll need to create a temp
            // file. 
            //
            
            UseTempFile = TRUE;
        }
    }

    CrashFileSize = DumpHeader->RequiredDumpSpace.QuadPart;

    Status = SmpQueryVolumeFreeSpace (&CrashParameters->DumpFileName,
                                      &VolumeFreeSpace);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // The space reserved by the pagefile is already taken into account here.
    // Do not add it in (a second time) here.
    //
    
    if (CrashFileSize < VolumeFreeSpace) {
        if (!UseTempFile) {
            Status = SmpCreateUnicodeString (DumpFileName,
                                             CrashParameters->DumpFileName.Buffer,
                                              -1);
        } else {
            Status = SmpCreateTempFile (&SmpSystemRoot, L"DUMP", DumpFileName);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CrashParameters->TempDestination = UseTempFile;
    
    if (!NT_SUCCESS (Status)) {

        //
        // NB: Log an error saying we were unable
        // to copy the crashdump for some reason.
        //
    }
    
    return Status;
}


const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = SmpAllocateString;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = SmpFreeString;





#if 0


__cdecl
main(
    )
{
    BOOLEAN CopiedDump;
    UNICODE_STRING PageFile;

    RtlInitUnicodeString (&SmpSystemRoot,
                          L"C:\\WINNT");
                          
    RtlDosPathNameToNtPathName_U (L"C:\\Public\\crashdmp.teo\\memory.dmp",
                                  &PageFile,
                                  NULL,
                                  NULL);
                                
    CopiedDump = SmpCheckForCrashDump (&PageFile);
}


#endif // TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\client\smp6432.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    smp6432.h

Abstract:

    Session Manager Types and Prototypes for Wow64

Author:

    Samer Arafeh  (samera) 20-Sep-2001

Revision History:

--*/


#ifndef _SMP6432_
#define _SMP6432_

#if defined(_X86_)

//
// Message formats used by Wow64 clients of the session manager.
//

typedef struct _SMCREATEFOREIGNSESSION64 {
    ULONG ForeignSessionId;
    ULONG SourceSessionId;
    RTL_USER_PROCESS_INFORMATION64 ProcessInformation;
    CLIENT_ID64 DebugUiClientId;
} SMCREATEFOREIGNSESSION64, *PSMCREATEFOREIGNSESSION64;



typedef struct _SMEXECPGM64 {
    RTL_USER_PROCESS_INFORMATION64 ProcessInformation;
    BOOLEAN DebugFlag;
} SMEXECPGM64, *PSMEXECPGM64;

typedef struct _SMSTARTCSR64 {
    ULONG  MuSessionId;
    ULONG  InitialCommandLength;
    WCHAR  InitialCommand[SMP_MAXIMUM_INITIAL_COMMAND];
    ULONGLONG InitialCommandProcessId;
    ULONGLONG WindowsSubSysProcessId;
} SMSTARTCSR64, *PSMSTARTCSR64;

typedef struct _SMAPIMSG64 {
    PORT_MESSAGE h;
    SMAPINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        SMCREATEFOREIGNSESSION64 CreateForeignSession;
        SMSESSIONCOMPLETE SessionComplete;
        SMTERMINATEFOREIGNSESSION TerminateForeignComplete;
        SMEXECPGM64 ExecPgm;
        SMLOADDEFERED LoadDefered;
        SMSTARTCSR64 StartCsr;
        SMSTOPCSR StopCsr;
    } u;
} SMAPIMSG64, *PSMAPIMSG64;



BOOLEAN
SmpIsWow64Process (
    VOID
    );

NTSTATUS
SmpWow64ExecPgm(
    IN HANDLE SmApiPort,
    IN PRTL_USER_PROCESS_INFORMATION ProcessInformation32,
    IN BOOLEAN DebugFlag
    );


NTSTATUS
SmpWow64LoadDeferedSubsystem(
    IN HANDLE SmApiPort,
    IN PUNICODE_STRING DeferedSubsystem
    );


NTSTATUS
SmpWow64SessionComplete(
    IN HANDLE SmApiPort,
    IN ULONG SessionId,
    IN NTSTATUS CompletionStatus
    );


NTSTATUS
SmpWow64StartCsr(
    IN HANDLE SmApiPort,
    OUT PULONG pMuSessionId,
    IN PUNICODE_STRING InitialCommand,
    OUT PULONG_PTR pInitialCommandProcessId,
    OUT PULONG_PTR pWindowsSubSysProcessId
    );


NTSTATUS
SmpWow64StopCsr(
    IN HANDLE SmApiPort,
    IN ULONG MuSessionId
    );

#endif // _X86_

#endif // _SMP6432_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\sminit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sminit.c

Abstract:

    Session Manager Initialization

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"
#include "pagefile.h"

#include <stdio.h>
#include <string.h>
#include <safeboot.h>
#include <wow64t.h>

#if defined(REMOTE_BOOT)
#include <windows.h>
#ifdef DeleteFile
#undef DeleteFile
#endif
#include <shdcom.h>     // CSC definitions
#endif // defined(REMOTE_BOOT)

#include "sfcfiles.h"

void
SmpDisplayString( char *s );

//
// Protection mode flags
//

#define SMP_NO_PROTECTION           (0x0)
#define SMP_STANDARD_PROTECTION     (0x1)
#define SMP_PROTECTION_REQUIRED     (SMP_STANDARD_PROTECTION)

#define REMOTE_BOOT_CFG_FILE L"RemoteBoot.cfg"

//
// Shows where was SmpInit execution when it returned
// with an error code. This aids debugging smss crashes a lot.
//

ULONG SmpInitProgressByLine;
NTSTATUS SmpInitReturnStatus;
PVOID SmpInitLastCall;

#define SAVE_SMPINIT_STATUS(caller, status) {  \
                                               \
        SmpInitProgressByLine = __LINE__;      \
        SmpInitReturnStatus = (status);        \
        SmpInitLastCall = (PVOID)(caller);     \
    }



PSECURITY_DESCRIPTOR SmpPrimarySecurityDescriptor;
SECURITY_DESCRIPTOR SmpPrimarySDBody;
PSECURITY_DESCRIPTOR SmpLiberalSecurityDescriptor;
SECURITY_DESCRIPTOR SmpLiberalSDBody;
PSECURITY_DESCRIPTOR SmpKnownDllsSecurityDescriptor;
SECURITY_DESCRIPTOR SmpKnownDllsSDBody;
PSECURITY_DESCRIPTOR SmpApiPortSecurityDescriptor;
SECURITY_DESCRIPTOR SmpApiPortSDBody;
ULONG SmpProtectionMode = SMP_STANDARD_PROTECTION;
UCHAR TmpBuffer[ 1024 + 2 * DOS_MAX_PATH_LENGTH * sizeof(WCHAR)];
ULONG AttachedSessionId = (-1);

#if defined(REMOTE_BOOT)
WCHAR wszRemoteBootCfgFile[DOS_MAX_PATH_LENGTH];
#endif // defined(REMOTE_BOOT)

#if DBG
BOOLEAN SmpEnableDots = FALSE;
#else
BOOLEAN SmpEnableDots = TRUE;
#endif


WCHAR InitialCommandBuffer[ 256 ];

UNICODE_STRING SmpDebugKeyword;
UNICODE_STRING SmpASyncKeyword;
UNICODE_STRING SmpAutoChkKeyword;
#if defined(REMOTE_BOOT)
UNICODE_STRING SmpAutoFmtKeyword;
#endif // defined(REMOTE_BOOT)
UNICODE_STRING SmpKnownDllPath;
#ifdef _WIN64
UNICODE_STRING SmpKnownDllPath32;
#endif

HANDLE SmpWindowsSubSysProcess;
ULONG_PTR SmpWindowsSubSysProcessId;
ULONG_PTR SmpInitialCommandProcessId;
UNICODE_STRING PosixName;
UNICODE_STRING Os2Name;
BOOLEAN RegPosixSingleInstance; // Make Softway Work.
ULONG SmpAllowProtectedRenames;
BOOLEAN MiniNTBoot = FALSE;
ULONG SmpCalledConfigEnv = 0;

LIST_ENTRY SmpBootExecuteList;
LIST_ENTRY SmpSetupExecuteList;
LIST_ENTRY SmpPagingFileList;
LIST_ENTRY SmpDosDevicesList;
LIST_ENTRY SmpFileRenameList;
LIST_ENTRY SmpKnownDllsList;
LIST_ENTRY SmpExcludeKnownDllsList;
LIST_ENTRY SmpSubSystemList;
LIST_ENTRY SmpSubSystemsToLoad;
LIST_ENTRY SmpSubSystemsToDefer;
LIST_ENTRY SmpExecuteList;

NTSTATUS
SmpCreateSecurityDescriptors(
    IN BOOLEAN InitialCall
    );

NTSTATUS
SmpLoadDataFromRegistry(
    OUT PUNICODE_STRING InitialCommand
    );

NTSTATUS
SmpCreateDynamicEnvironmentVariables(
    VOID
    );

NTSTATUS
SmpConfigureProtectionMode(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureAllowProtectedRenames(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureObjectDirectories(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureExecute(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureFileRenames(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureMemoryMgmt(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureDosDevices(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureKnownDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureExcludeKnownDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureSubSystems(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SmpConfigureEnvironment(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

ULONGLONG
SmpGetFileVersion(
    IN HANDLE FileHandle,
    IN PUNICODE_STRING FileName
    );

NTSTATUS
SmpCallCsrCreateProcess(
    IN OUT PSBAPIMSG m,
    IN size_t ArgLength,
    IN HANDLE CommunicationPort
    );


RTL_QUERY_REGISTRY_TABLE SmpRegistryConfigurationTable[] = {

    //
    // Note that the SmpConfigureProtectionMode entry should preceed others
    // to ensure we set up the right protection for use by the others.
    //

    {SmpConfigureProtectionMode, 0,
     L"ProtectionMode",          NULL,
     REG_DWORD, (PVOID)0, 0},

    {SmpConfigureAllowProtectedRenames, RTL_QUERY_REGISTRY_DELETE,
     L"AllowProtectedRenames",   NULL,
     REG_DWORD, (PVOID)0, 0},

    {SmpConfigureObjectDirectories, 0,
     L"ObjectDirectories",          NULL,
     REG_MULTI_SZ, (PVOID)L"\\Windows\0\\RPC Control\0", 0},

    {SmpConfigureExecute,       0,
     L"BootExecute",            &SmpBootExecuteList,
     REG_MULTI_SZ, L"autocheck AutoChk.exe *\0", 0},

    {SmpConfigureExecute,       RTL_QUERY_REGISTRY_TOPKEY,
     L"SetupExecute",           &SmpSetupExecuteList,
     REG_NONE, NULL, 0},

    {SmpConfigureFileRenames,   RTL_QUERY_REGISTRY_DELETE,
     L"PendingFileRenameOperations",   &SmpFileRenameList,
     REG_NONE, NULL, 0},

    {SmpConfigureFileRenames,   RTL_QUERY_REGISTRY_DELETE,
     L"PendingFileRenameOperations2",   &SmpFileRenameList,
     REG_NONE, NULL, 0},

    {SmpConfigureExcludeKnownDlls, 0,
     L"ExcludeFromKnownDlls",   &SmpExcludeKnownDllsList,
     REG_MULTI_SZ, L"\0", 0},

    {NULL,                      RTL_QUERY_REGISTRY_SUBKEY,
     L"Memory Management",      NULL,
     REG_NONE, NULL, 0},

    {SmpConfigureMemoryMgmt,    0,
     L"PagingFiles",            &SmpPagingFileList,
     REG_MULTI_SZ, L"?:\\pagefile.sys\0", 0},

    {SmpConfigureDosDevices,    RTL_QUERY_REGISTRY_SUBKEY,
     L"DOS Devices",            &SmpDosDevicesList,
     REG_NONE, NULL, 0},

    {SmpConfigureKnownDlls,     RTL_QUERY_REGISTRY_SUBKEY,
     L"KnownDlls",              &SmpKnownDllsList,
     REG_NONE, NULL, 0},

    //
    // NOTICE-2002/05/23-ELi
    // SmpConfigureEnvironment assumes that it will be called twice
    // If you change the number of times SmpConfigureEnvironment is called,
    // then make sure that you do not break SmpConfigureEnvironment.
    // see bug 318452 in the old Windows NT Bugs RAID database for the
    // reason why SmpConfigureEnvironment is called twice.
    //

    //
    // this needs to happen twice so that forward references to environment
    // variables, which may be defined under the Environment registry key, are
    // properly resolved
    //

    {SmpConfigureEnvironment,   RTL_QUERY_REGISTRY_SUBKEY,
     L"Environment",            NULL,
     REG_NONE, NULL, 0},

    {SmpConfigureEnvironment,   RTL_QUERY_REGISTRY_SUBKEY,
     L"Environment",            NULL,
     REG_NONE, NULL, 0},

    {SmpConfigureSubSystems,    RTL_QUERY_REGISTRY_SUBKEY,
     L"SubSystems",             &SmpSubSystemList,
     REG_NONE, NULL, 0},

    {SmpConfigureSubSystems,    RTL_QUERY_REGISTRY_NOEXPAND,
     L"Required",               &SmpSubSystemList,
     REG_MULTI_SZ, L"Debug\0Windows\0", 0},

    {SmpConfigureSubSystems,    RTL_QUERY_REGISTRY_NOEXPAND,
     L"Optional",               &SmpSubSystemList,
     REG_NONE, NULL, 0},

    {SmpConfigureSubSystems,    0,
     L"Kmode",                  &SmpSubSystemList,
     REG_NONE, NULL, 0},

    {SmpConfigureExecute,       RTL_QUERY_REGISTRY_TOPKEY,
     L"Execute",                &SmpExecuteList,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};


NTSTATUS
SmpInvokeAutoChk(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING Arguments,
    IN ULONG Flags
    );

#if defined(REMOTE_BOOT)
NTSTATUS
SmpInvokeAutoFmt(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING Arguments,
    IN ULONG Flags
    );
#endif // defined(REMOTE_BOOT)

NTSTATUS
SmpLoadSubSystem(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    OUT PULONG_PTR pWindowsSubSysProcessId,
    IN ULONG Flags
    );

NTSTATUS
SmpExecuteCommand(
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    OUT PULONG_PTR pWindowsSubSysProcessId,
    IN ULONG Flags
    );

NTSTATUS
SmpInitializeDosDevices( VOID );

NTSTATUS
SmpInitializeKnownDlls( VOID );

NTSTATUS
SmpInitializeKnownDllPath(
    IN PUNICODE_STRING KnownDllPath,
    IN PVOID ValueData,
    IN ULONG ValueLength);

NTSTATUS
SmpInitializeKnownDllsInternal(
    IN PUNICODE_STRING ObjectDirectoryName,
    IN PUNICODE_STRING KnownDllPath
    );


#if defined(REMOTE_BOOT)
NTSTATUS
SmpExecuteCommandLineArguments( VOID );
#endif // defined(REMOTE_BOOT)

VOID
SmpProcessFileRenames( VOID );

NTSTATUS
SmpParseToken(
    IN PUNICODE_STRING Source,
    IN BOOLEAN RemainderOfSource,
    OUT PUNICODE_STRING Token
    );

NTSTATUS
SmpParseCommandLine(
    IN PUNICODE_STRING CommandLine,
    OUT PULONG Flags,
    OUT PUNICODE_STRING ImageFileName,
    OUT PUNICODE_STRING ImageFileDirectory OPTIONAL,
    OUT PUNICODE_STRING Arguments
    );

#define SMP_DEBUG_FLAG      0x00000001
#define SMP_ASYNC_FLAG      0x00000002
#define SMP_AUTOCHK_FLAG    0x00000004
#define SMP_SUBSYSTEM_FLAG  0x00000008
#define SMP_IMAGE_NOT_FOUND 0x00000010
#define SMP_DONT_START      0x00000020
#if defined(REMOTE_BOOT)
#define SMP_AUTOFMT_FLAG    0x00000040
#endif // defined(REMOTE_BOOT)
#define SMP_POSIX_SI_FLAG   0x00000080
#define SMP_POSIX_FLAG      0x00000100
#define SMP_OS2_FLAG        0x00000200

ULONG
SmpConvertInteger(
    IN PWSTR String
    );

VOID
SmpTranslateSystemPartitionInformation( VOID );


#if defined(REMOTE_BOOT)
//
// Useful functions for iterating thru directories and files
//
typedef enum {
    NormalReturn,   // if the whole process completes uninterrupted
    EnumFileError,  // if an error occurs while enumerating files
    CallbackReturn  // if the callback returns FALSE, causing termination
} ENUMFILESRESULT;

typedef BOOLEAN (*ENUMFILESPROC) (
    IN  PWSTR,
    IN  PFILE_BOTH_DIR_INFORMATION,
    OUT PULONG,
    IN  PVOID
    );

typedef struct {
    PVOID           OptionalPtr;
    ENUMFILESPROC   EnumProc;
} RECURSION_DATA, *PRECURSION_DATA;



ENUMFILESRESULT
SmpEnumFiles(
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer
    );

ENUMFILESRESULT
SmpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer       OPTIONAL
    );

VOID
SmpConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2
    );

BOOLEAN
SmppRecursiveEnumProc (
    IN  PWSTR                      DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    );

BOOLEAN
SmpDelEnumFile(
    IN  PWSTR                      DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

#endif // defined(REMOTE_BOOT)



//
// routines
//



BOOLEAN
SmpQueryRegistrySosOption(
    VOID
    )

/*++

Routine Description:

    This function queries the registry to determine if the loadoptions
    boot environment variable contains the string "SOS".

    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control:SystemStartOptions

Arguments:

    None.

Return Value:

    TRUE if "SOS" was set.  Otherwise FALSE.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    UCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;

    //
    // Open the registry key.
    //

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString(&KeyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control");

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't open control key: 0x%x\n",
                   Status));

        return FALSE;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString(&ValueName, L"SystemStartOptions");
    Status = NtQueryValueKey(Key,
                             &ValueName,
                             KeyValuePartialInformation,
                             (PVOID)KeyValueInfo,
                             sizeof (ValueBuffer),
                             &ValueLength);

    ASSERT(ValueLength < VALUE_BUFFER_SIZE);

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't query value key: 0x%x\n",
                   Status));

        return FALSE;
    }

    //
    // Check is "sos" or "SOS" ois specified.
    //

    if (NULL != wcsstr((PWCHAR)&KeyValueInfo->Data, L"SOS") ||
        NULL != wcsstr((PWCHAR)&KeyValueInfo->Data, L"sos")) {
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
SmpInit(
    OUT PUNICODE_STRING InitialCommand,
    OUT PHANDLE WindowsSubSystem
    )
{
    NTSTATUS st;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE SmpApiConnectionPort;
    UNICODE_STRING Unicode;
    NTSTATUS Status, Status2;
    ULONG HardErrorMode;
    UNICODE_STRING UnicodeString;
    HANDLE VolumeSafeEvent;

    SmBaseTag = RtlCreateTagHeap( RtlProcessHeap(),
                                  0,
                                  L"SMSS!",
                                  L"INIT\0"
                                  L"DBG\0"
                                  L"SM\0"
                                );
    //
    // Make sure we specify hard error popups
    //

    HardErrorMode = 1;
    NtSetInformationProcess( NtCurrentProcess(),
                             ProcessDefaultHardErrorMode,
                             (PVOID) &HardErrorMode,
                             sizeof( HardErrorMode )
                           );

    RtlInitUnicodeString( &SmpSubsystemName, L"NT-Session Manager" );


    RtlInitializeCriticalSection(&SmpKnownSubSysLock);
    InitializeListHead(&SmpKnownSubSysHead);

    RtlInitializeCriticalSection(&SmpSessionListLock);
    InitializeListHead(&SmpSessionListHead);
    SmpNextSessionId = 1;
    SmpNextSessionIdScanMode = FALSE;
    SmpDbgSsLoaded = FALSE;

    //
    // Initialize security descriptors to grant wide access
    // (protection mode not yet read in from registry).
    //

    st = SmpCreateSecurityDescriptors( TRUE );
    if (!NT_SUCCESS(st)) {

        SAVE_SMPINIT_STATUS (SmpCreateSecurityDescriptors, st);
        return(st);
    }

    InitializeListHead(&NativeProcessList);

    SmpHeap = RtlProcessHeap();

    RtlInitUnicodeString( &PosixName, L"POSIX" );
    RtlInitUnicodeString( &Os2Name, L"OS2" );

    RtlInitUnicodeString( &Unicode, L"\\SmApiPort" );
    InitializeObjectAttributes( &ObjA, &Unicode, 0, NULL, SmpApiPortSecurityDescriptor);

    st = NtCreatePort(
            &SmpApiConnectionPort,
            &ObjA,
            sizeof(SBCONNECTINFO),
            sizeof(SMMESSAGE_SIZE),
            sizeof(SBAPIMSG) * 32
            );
    ASSERT( NT_SUCCESS(st) );

    SmpDebugPort = SmpApiConnectionPort;

    st = RtlCreateUserThread(
            NtCurrentProcess(),
            NULL,
            FALSE,
            0L,
            0L,
            0L,
            SmpApiLoop,
            (PVOID) SmpApiConnectionPort,
            NULL,
            NULL
            );
    ASSERT( NT_SUCCESS(st) );

    st = RtlCreateUserThread(
            NtCurrentProcess(),
            NULL,
            FALSE,
            0L,
            0L,
            0L,
            SmpApiLoop,
            (PVOID) SmpApiConnectionPort,
            NULL,
            NULL
            );
    ASSERT( NT_SUCCESS(st) );



    //
    // Create a event to signal that volume are safe for write access opens.
    // Call this event 'VolumesSafeForWriteAccess'.  This event will be
    // signalled after AUTOCHK/AUTOCONV/AUTOFMT have done their business.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Device\\VolumesSafeForWriteAccess");

    InitializeObjectAttributes( &ObjA,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                NULL,
                                NULL
                              );

    Status2 = NtCreateEvent( &VolumeSafeEvent,
                             EVENT_ALL_ACCESS,
                             &ObjA,
                             NotificationEvent,
                             FALSE
                           );
    if (!NT_SUCCESS( Status2 )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to create %wZ event - Status == %lx\n",
                   &UnicodeString,
                   Status2));

        ASSERT( NT_SUCCESS(Status2) );
    }

    //
    // Configure the system
    //

    Status = SmpLoadDataFromRegistry( InitialCommand );

    if (NT_SUCCESS( Status )) {
        
        *WindowsSubSystem = SmpWindowsSubSysProcess;
    }

    //
    // AUTOCHK/AUTOCONV/AUTOFMT are finished.
    //

    if (NT_SUCCESS(Status2)) {
        NtSetEvent(VolumeSafeEvent, NULL);
        NtClose(VolumeSafeEvent);
    }

    return( Status );
}


NTSTATUS
SmpLoadDataFromRegistry(
    OUT PUNICODE_STRING InitialCommand
    )

/*++

Routine Description:

    This function loads all of the configurable data for the NT Session
    Manager from the registry.

Arguments:

    None

Return Value:

    Status of operation

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;
    PVOID OriginalEnvironment;
    ULONG MuSessionId = 0;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    UNICODE_STRING SessionDirName;
#if defined(REMOTE_BOOT)
    HANDLE RdrHandle = NULL;
    IO_STATUS_BLOCK Iosb;
    SHADOWINFO ShadowInfo;
#endif // defined(REMOTE_BOOT)


    RtlInitUnicodeString( &SmpDebugKeyword, L"debug" );
    RtlInitUnicodeString( &SmpASyncKeyword, L"async" );
    RtlInitUnicodeString( &SmpAutoChkKeyword, L"autocheck" );
#if defined(REMOTE_BOOT)
    RtlInitUnicodeString( &SmpAutoFmtKeyword, L"autoformat" );
#endif // defined(REMOTE_BOOT)

    InitializeListHead( &SmpBootExecuteList );
    InitializeListHead( &SmpSetupExecuteList );
    InitializeListHead( &SmpPagingFileList );
    InitializeListHead( &SmpDosDevicesList );
    InitializeListHead( &SmpFileRenameList );
    InitializeListHead( &SmpKnownDllsList );
    InitializeListHead( &SmpExcludeKnownDllsList );
    InitializeListHead( &SmpSubSystemList );
    InitializeListHead( &SmpSubSystemsToLoad );
    InitializeListHead( &SmpSubSystemsToDefer );
    InitializeListHead( &SmpExecuteList );

    SmpPagingFileInitialize ();

    Status = RtlCreateEnvironment( TRUE, &SmpDefaultEnvironment );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to allocate default environment - Status == %X\n",
                   Status));


        SAVE_SMPINIT_STATUS (RtlCreateEnvironment, Status);
        return( Status );
        }

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\MiniNT" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenKey( &Key, KEY_ALL_ACCESS, &ObjectAttributes );

    if (NT_SUCCESS( Status )) {
        NtClose( Key );
        MiniNTBoot = TRUE;
    }

    if (MiniNTBoot) {
        DbgPrint("SMSS: !!! MiniNT Boot !!!\n");
    }

    //
    // before the environment is created we MUST delete the
    // safemode reg value
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &Key, KEY_ALL_ACCESS, &ObjectAttributes );
    if (NT_SUCCESS( Status )) {
        RtlInitUnicodeString( &KeyName, L"SAFEBOOT_OPTION" );
        NtDeleteValueKey( Key, &KeyName );
        NtClose( Key );
    }

    //
    // In order to track growth in smpdefaultenvironment, make it sm's environment
    // while doing the registry groveling and then restore it
    //

    OriginalEnvironment = NtCurrentPeb()->ProcessParameters->Environment;
    NtCurrentPeb()->ProcessParameters->Environment = SmpDefaultEnvironment;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     L"Session Manager",
                                     SmpRegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );

    SmpDefaultEnvironment = NtCurrentPeb()->ProcessParameters->Environment;
    NtCurrentPeb()->ProcessParameters->Environment = OriginalEnvironment;

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: RtlQueryRegistryValues failed - Status == %lx\n",
                   Status));

        SAVE_SMPINIT_STATUS (RtlQueryRegistryValues, Status);
        return( Status );
        }

    Status = SmpInitializeDosDevices();
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to initialize DosDevices configuration - Status == %lx\n",
                   Status));

        SAVE_SMPINIT_STATUS (SmpInitializeDosDevices, Status);
        return( Status );
        }

    //
    // Create the root "Sessions Directory". This is the container for all session
    // specific directories. Each session specific CSRSS during startup will
    // create a <sessionid> direcotry under "\Sessions". "\Sessions\<sessionid>
    // directory will be the container for that session.
    //

    RtlInitUnicodeString( &SessionDirName, L"\\Sessions" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &SessionDirName,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
                                NULL,
                                SmpPrimarySecurityDescriptor
                              );

    if (!NT_SUCCESS(Status = NtCreateDirectoryObject( &SmpSessionsObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &ObjectAttributes
                                    ))) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to create %wZ object directory - Status == %lx\n",
                   &SessionDirName,
                   Status));

        SAVE_SMPINIT_STATUS (NtCreateDirectoryObject, Status);
        return Status;
    }


#if defined(REMOTE_BOOT)
    //
    // On a remote boot client, the client-side cache is already initialized.
    // We need to tell CSC not to cache database handles during the next phase
    // so that autochk can run.
    //

    if (SmpNetboot) {

        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING RdrNameString;

        RtlInitUnicodeString( &RdrNameString, L"\\Device\\LanmanRedirector" );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &RdrNameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &RdrHandle,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                    &ObjectAttributes,
                    &Iosb,
                    NULL,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );
        if ( !NT_SUCCESS(Status) ) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SmpLoadDataFromRegistry: Unable to open redirector: %x\n",
                       Status));

            RdrHandle = NULL;
            }
        else {

            ShadowInfo.uOp = SHADOW_CHANGE_HANDLE_CACHING_STATE;
            ShadowInfo.uStatus = FALSE;

            Status = NtDeviceIoControlFile(
                        RdrHandle,
                        NULL,
                        NULL,
                        NULL,
                        &Iosb,
                        IOCTL_DO_SHADOW_MAINTENANCE,
                        &ShadowInfo,
                        sizeof(ShadowInfo),
                        NULL,
                        0
                        );

            if ( NT_SUCCESS(Status) ) {
                Status = Iosb.Status;
                }
            if ( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SmpLoadDataFromRegistry: Unable to IOCTL CSC: %x\n",
                           Status));
                }
            }
        }

    Status = SmpExecuteCommandLineArguments();
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to process command line arguments - Status == %lx\n",
                   Status));

        return( Status );
        }
#endif // defined(REMOTE_BOOT)

    Head = &SmpBootExecuteList;
    while (!IsListEmpty( Head )) {
        Next = RemoveHeadList( Head );
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: BootExecute( %wZ )\n", &p->Name );
#endif
        SmpExecuteCommand( &p->Name, 0, NULL, 0 );
        if (p->AnsiValue)    { RtlFreeHeap( RtlProcessHeap(), 0, p->AnsiValue ); }
        if (p->Value.Buffer) { RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer ); }
        RtlFreeHeap( RtlProcessHeap(), 0, p );
        }

#if defined(REMOTE_BOOT)
    //
    // On a remote boot client, we can now reenable CSC handle caching.
    //

    if (SmpNetboot && (RdrHandle != NULL)) {

        ShadowInfo.uOp = SHADOW_CHANGE_HANDLE_CACHING_STATE;
        ShadowInfo.uStatus = TRUE;

        Status = NtDeviceIoControlFile(
                    RdrHandle,
                    NULL,
                    NULL,
                    NULL,
                    &Iosb,
                    IOCTL_DO_SHADOW_MAINTENANCE,
                    &ShadowInfo,
                    sizeof(ShadowInfo),
                    NULL,
                    0
                    );

        if ( NT_SUCCESS(Status) ) {
            Status = Iosb.Status;
            }
        if ( !NT_SUCCESS(Status) ) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SmpLoadDataFromRegistry: Unable to IOCTL CSC (2): %x\n",
                       Status));
            }
        }
#endif // defined(REMOTE_BOOT)

    if (!MiniNTBoot) {
        SmpProcessFileRenames();
    }

    //
    //  Begin process of verifying system DLL's
    //

    Status = SmpInitializeKnownDlls();
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to initialize KnownDll configuration - Status == %lx\n",
                   Status));

        SAVE_SMPINIT_STATUS (SmpInitializeKnownDlls, Status);
        return( Status );
        }

    //
    // Create paging files.
    //

    if (! MiniNTBoot) {

        Head = &SmpPagingFileList;

        try {

            //
            // Process the list of paging file descriptors
            // read from registry.
            //

            while (! IsListEmpty (Head)) {

                Next = RemoveHeadList (Head);

                p = CONTAINING_RECORD (Next,
                                       SMP_REGISTRY_VALUE,
                                       Entry);

                SmpCreatePagingFileDescriptor (&p->Name);


                if (p->AnsiValue)    { RtlFreeHeap( RtlProcessHeap(), 0, p->AnsiValue ); }
                if (p->Value.Buffer) { RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer ); }
                RtlFreeHeap (RtlProcessHeap(), 0, p);
            }

            //
            // Create any paging files specified.
            //

            SmpCreatePagingFiles();
        }
        except (SmpPagingFileExceptionFilter (_exception_code(), _exception_info())) {

            //
            // Nothing.
            //
        }
    }

    //
    // Finish registry initialization
    //

    NtInitializeRegistry(REG_INIT_BOOT_SM);

    Status = SmpCreateDynamicEnvironmentVariables( );
    if (!NT_SUCCESS( Status )) {
        
        SAVE_SMPINIT_STATUS (SmpCreateDynamicEnvironmentVariables, Status);
        return Status;
        }


    //
    // Load subsystems for the console session. Console always has
    // MuSessionId = 0
    //
    Status = SmpLoadSubSystemsForMuSession( &MuSessionId,
                 &SmpWindowsSubSysProcessId, InitialCommand );

    ASSERT(MuSessionId == 0);

    if (! NT_SUCCESS(Status)) {
        
        SAVE_SMPINIT_STATUS (SmpLoadSubSystemsForMuSession, Status);
    }

    return( Status );
}


NTSTATUS
SmpLoadSubSystemsForMuSession(
    PULONG pMuSessionId,
    PULONG_PTR pWindowsSubSysProcessId,
    PUNICODE_STRING InitialCommand )

/*++

Routine Description:

    This function starts all of the configured subsystems for the
    specified Multi-User Session.  For regular NT this routine is called once
    to start CSRSS etc. For Terminal Server, this routine is called every time
    we want to start a new Multi-User Session to start session specific subsystems

Arguments:


Return Value:

    Status of operation

--*/

{
    NTSTATUS Status = 0, Status1;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;

    //
    // Translate the system partition information stored during IoInitSystem into
    // a DOS path and store in Win32-standard location.
    //

    SmpTranslateSystemPartitionInformation();

    //
    // Second pass of execution.
    //

    Next = SmpSetupExecuteList.Flink;
    while( Next != &SmpSetupExecuteList ) {
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: SetupExecute( %wZ )\n", &p->Name );
#endif
        SmpExecuteCommand( &p->Name, 0, NULL, 0 );

        //
        // Note this function is reentrant and is called every time we start
        // a new Multi-User Session.
        //

        Next = Next->Flink;
    }

    Next = SmpSubSystemList.Flink;
    while ( Next != &SmpSubSystemList ) {
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
        if ( !_wcsicmp( p->Name.Buffer, L"Kmode" )) {
            BOOLEAN TranslationStatus;
            UNICODE_STRING FileName;
            UNICODE_STRING Win32kFileName;

            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                    p->Value.Buffer,
                                    &FileName,
                                    NULL,
                                    NULL
                                    );

            if ( TranslationStatus ) {
                PVOID State;

                Status = SmpAcquirePrivilege( SE_LOAD_DRIVER_PRIVILEGE, &State );
                if (NT_SUCCESS( Status )) {


                    //
                    // Create a session space before loading any extended
                    // service table providers.  This call will create a session
                    // space for the Multi-User session. The session mananger
                    // will see the instance of the newly created session space
                    // after this call. Once session manager is done creating
                    // CSRSS and winlogon it will detach itself from this
                    // session space.
                    //

                    ASSERT( AttachedSessionId == -1 );

                    Status = NtSetSystemInformation(
                                SystemSessionCreate,
                                (PVOID)pMuSessionId,
                                sizeof(*pMuSessionId)
                                );

                    if ( !NT_SUCCESS(Status) ) {
                        KdPrintEx((DPFLTR_SMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "SMSS: Session space creation failed\n"));

                        //
                        // Do not load any subsystems without SessionSpace.
                        //

                        SmpReleasePrivilege( State );
                        RtlFreeHeap(RtlProcessHeap(), 0, FileName.Buffer);
                        return( Status );
                    };

                    AttachedSessionId = *pMuSessionId;

                    RtlInitUnicodeString(&Win32kFileName,L"\\SystemRoot\\System32\\win32k.sys");

                    Status = NtSetSystemInformation(
                                SystemExtendServiceTableInformation,
                                (PVOID)&Win32kFileName,
                                sizeof(Win32kFileName)
                                );
                    RtlFreeHeap(RtlProcessHeap(), 0, FileName.Buffer);
                    SmpReleasePrivilege( State );
                    if ( !NT_SUCCESS(Status) ) {

                        //
                        // Do not load any subsystems without WIN32K!
                        //

                        KdPrintEx((DPFLTR_SMSS_ID,
                                   DPFLTR_ERROR_LEVEL,
                                   "SMSS: Load of WIN32K failed.\n"));

                        return( Status );
                        }
                    }
                else {
                    RtlFreeHeap(RtlProcessHeap(), 0, FileName.Buffer);
                    }
                }
            else {
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                }
            }
#if SMP_SHOW_REGISTRY_DATA
            DbgPrint( "SMSS: Unused SubSystem( %wZ = %wZ )\n", &p->Name, &p->Value );
#endif
            Next = Next->Flink;
        }

    Next = SmpSubSystemsToLoad.Flink;
    while ( Next != &SmpSubSystemsToLoad ) {
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: Loaded SubSystem( %wZ = %wZ )\n", &p->Name, &p->Value );
#endif
        if (!_wcsicmp( p->Name.Buffer, L"debug" )) {
            Status = SmpExecuteCommand( &p->Value, *pMuSessionId, pWindowsSubSysProcessId, SMP_SUBSYSTEM_FLAG | SMP_DEBUG_FLAG );
        }
        else {
            Status = SmpExecuteCommand( &p->Value, *pMuSessionId, pWindowsSubSysProcessId, SMP_SUBSYSTEM_FLAG );
        }

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint ("SMSS: Subsystem execute failed (%WZ)\n", &p->Value);
            return( Status );
        }

        Next = Next->Flink;
    }

    Head = &SmpExecuteList;
    if ( !IsListEmpty( Head ) ) {
        Next = Head->Blink;
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );

        *InitialCommand = p->Name;

        //
        // This path is only taken when people want to run ntsd -p -1 winlogon
        //
        // This is nearly impossible to do in a race free manner. In some
        // cases, we can get in a state where we can not properly fail
        // a debug API. This is due to the subsystem switch that occurs
        // when ntsd is invoked on csr. If csr is relatively idle, this
        // does not occur. If it is active when you attach, then we can get
        // into a potential race. The slimy fix is to do a 5 second delay
        // if the command line is anything other that the default.
        //

            {
                LARGE_INTEGER DelayTime;
                DelayTime.QuadPart = Int32x32To64( 5000, -10000 );
                NtDelayExecution(
                    FALSE,
                    &DelayTime
                    );
            }
        }
    else {
        RtlInitUnicodeString( InitialCommand, L"winlogon.exe" );
        InitialCommandBuffer[ 0 ] = UNICODE_NULL;
        Status1 = LdrQueryImageFileExecutionOptions( InitialCommand,
                                                     L"Debugger",
                                                     REG_SZ,
                                                     InitialCommandBuffer,
                                                     sizeof( InitialCommandBuffer ) - InitialCommand->Length - sizeof (WCHAR),
                                                     NULL);
        if (NT_SUCCESS (Status1) && InitialCommandBuffer[ 0 ] != UNICODE_NULL) {
            wcscat( InitialCommandBuffer, L" " );
            wcscat( InitialCommandBuffer, InitialCommand->Buffer );
            RtlInitUnicodeString( InitialCommand, InitialCommandBuffer );
        }
    }

    Next = SmpExecuteList.Flink;
    while( Next != &SmpExecuteList ) {

        //
        // We do not want to execute the last entry. It's
        // the winlogon initial command.
        //

        if( Next == SmpExecuteList.Blink ) {
            Next = Next->Flink;
            continue;
        }

        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: Execute( %wZ )\n", &p->Name );
#endif
        SmpExecuteCommand( &p->Name, *pMuSessionId, NULL, 0 );
        Next = Next->Flink;
    }

#if SMP_SHOW_REGISTRY_DATA
    DbgPrint( "SMSS: InitialCommand( %wZ )\n", InitialCommand );
#endif

    return( Status );
}


NTSTATUS
SmpCreateDynamicEnvironmentVariables(
    VOID
    )
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    PWSTR ValueData;
    WCHAR ValueBuffer[ 256 ];
    WCHAR ValueBuffer1[ 256 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    HANDLE Key, Key1;

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof( SystemInfo ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to query system basic information - %x\n",
                   Status));

        return Status;
        }

    Status = NtQuerySystemInformation( SystemProcessorInformation,
                                       &ProcessorInfo,
                                       sizeof( ProcessorInfo ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to query system processor information - %x\n",
                   Status));

        return Status;
        }

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &Key, KEY_ALL_ACCESS, &ObjectAttributes );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open %wZ - %x\n",
                   &KeyName,
                   Status));

        return Status;
        }

    RtlInitUnicodeString( &ValueName, L"OS" );
    ValueData = L"Windows_NT";
    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueData,
                            (wcslen( ValueData ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }

    RtlInitUnicodeString( &ValueName, L"PROCESSOR_ARCHITECTURE" );
    switch( ProcessorInfo.ProcessorArchitecture ) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        ValueData = L"x86";
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        ValueData = L"IA64";
        break;

    case PROCESSOR_ARCHITECTURE_AMD64:
        ValueData = L"AMD64";
        break;

    default:
        ValueData = L"Unknown";
        break;
    }

    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueData,
                            (wcslen( ValueData ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }

    RtlInitUnicodeString( &ValueName, L"PROCESSOR_LEVEL" );
    switch( ProcessorInfo.ProcessorArchitecture ) {
    case PROCESSOR_ARCHITECTURE_INTEL:
    case PROCESSOR_ARCHITECTURE_IA64:
    case PROCESSOR_ARCHITECTURE_AMD64:
    default:
        //
        // All others use a single level number
        //
        swprintf( ValueBuffer, L"%u", ProcessorInfo.ProcessorLevel );
        break;
    }
    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueBuffer,
                            (wcslen( ValueBuffer ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\Hardware\\Description\\System\\CentralProcessor\\0" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &Key1, KEY_READ, &ObjectAttributes );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open %wZ - %x\n",
                   &KeyName,
                   Status));

        goto failexit;
        }
    RtlInitUnicodeString( &ValueName, L"Identifier" );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    Status = NtQueryValueKey( Key1,
                              &ValueName,
                              KeyValuePartialInformation,
                              (PVOID)KeyValueInfo,
                              sizeof( ValueBuffer ),
                              &ValueLength
                             );
    if (!NT_SUCCESS( Status )) {
        NtClose( Key1 );
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to read %wZ\\%wZ - %x\n",
                   &KeyName,
                   &ValueName,
                   Status));

        goto failexit;
        }

    ValueData = (PWSTR)KeyValueInfo->Data;
    RtlInitUnicodeString( &ValueName, L"VendorIdentifier" );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer1;
    Status = NtQueryValueKey( Key1,
                              &ValueName,
                              KeyValuePartialInformation,
                              (PVOID)KeyValueInfo,
                              sizeof( ValueBuffer1 ),
                              &ValueLength
                             );
    NtClose( Key1 );
    if (NT_SUCCESS( Status )) {
        swprintf( ValueData + wcslen( ValueData ),
                  L", %ws",
                  (PWSTR)KeyValueInfo->Data
                );
        }

    RtlInitUnicodeString( &ValueName, L"PROCESSOR_IDENTIFIER" );
    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueData,
                            (wcslen( ValueData ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }

    RtlInitUnicodeString( &ValueName, L"PROCESSOR_REVISION" );
    switch( ProcessorInfo.ProcessorArchitecture ) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        if ((ProcessorInfo.ProcessorRevision >> 8) == 0xFF) {
            //
            // Intel 386/486 are An stepping format
            //
            swprintf( ValueBuffer, L"%02x",
                      ProcessorInfo.ProcessorRevision & 0xFF
                    );
            _wcsupr( ValueBuffer );
            break;
        }

        //
        // Post-486 processors will fall through
        //

    case PROCESSOR_ARCHITECTURE_IA64:
    case PROCESSOR_ARCHITECTURE_AMD64:
        //
        // Modern X86 processors, IA64 and Amd64 use a fixed point
        // binary number.  Output is 4 hex digits, no formatting.
        //
        swprintf( ValueBuffer, L"%04x", ProcessorInfo.ProcessorRevision );
        break;

    default:
        //
        // All others use a single revision number
        //
        swprintf( ValueBuffer, L"%u", ProcessorInfo.ProcessorRevision );
        break;
    }

    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueBuffer,
                            (wcslen( ValueBuffer ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }

    RtlInitUnicodeString( &ValueName, L"NUMBER_OF_PROCESSORS" );
    swprintf( ValueBuffer, L"%u", SystemInfo.NumberOfProcessors );
    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_SZ,
                            ValueBuffer,
                            (wcslen( ValueBuffer ) + 1) * sizeof( WCHAR )
                          );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed writing %wZ environment variable - %x\n",
                   &ValueName,
                   Status));

        goto failexit;
        }


    //
    // get the safeboot option
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Safeboot\\Option" );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenKey( &Key1, KEY_ALL_ACCESS, &ObjectAttributes );
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &ValueName, L"OptionValue" );
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey(
            Key1,
            &ValueName,
            KeyValuePartialInformation,
            (PVOID)KeyValueInfo,
            sizeof(ValueBuffer),
            &ValueLength
            );
        NtClose( Key1 );
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString( &ValueName, L"SAFEBOOT_OPTION" );
            switch (*(PULONG)(KeyValueInfo->Data)) {
                case SAFEBOOT_MINIMAL:
                    wcscpy(ValueBuffer,SAFEBOOT_MINIMAL_STR_W);
                    break;

                case SAFEBOOT_NETWORK:
                    wcscpy(ValueBuffer,SAFEBOOT_NETWORK_STR_W);
                    break;

                case SAFEBOOT_DSREPAIR:
                    wcscpy(ValueBuffer,SAFEBOOT_DSREPAIR_STR_W);
                    break;
            }
            Status = NtSetValueKey(
                Key,
                &ValueName,
                0,
                REG_SZ,
                ValueBuffer,
                (wcslen(ValueBuffer)+1) * sizeof( WCHAR )
                );
            if (!NT_SUCCESS( Status )) {
                KdPrintEx((DPFLTR_SMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SMSS: Failed writing %wZ environment variable - %x\n",
                           &ValueName,
                           Status));

                goto failexit;
            }
        } else {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Failed querying safeboot option = %x\n",
                       Status));
        }
    }
    Status = STATUS_SUCCESS;

failexit:
    NtClose( Key );
    return Status;
}


NTSTATUS
SmpInitializeDosDevices( VOID )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE LinkHandle;
    SECURITY_DESCRIPTOR_CONTROL OriginalSdControl=0;

    //
    // Do DosDevices initialization - the directory object is created in I/O init
    //

    RtlInitUnicodeString( &UnicodeString, L"\\??" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
                                NULL,
                                NULL
                              );
    Status = NtOpenDirectoryObject( &SmpDosDevicesObjectDirectory,
                                    DIRECTORY_ALL_ACCESS,
                                    &ObjectAttributes
                                    );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open %wZ directory - Status == %lx\n",
                   &UnicodeString,
                   Status));

        return( Status );
        }


    //
    // Process the list of defined DOS devices and create their
    // associated symbolic links in the \DosDevices object directory.
    //

    Head = &SmpDosDevicesList;
    while (!IsListEmpty( Head )) {
        Next = RemoveHeadList( Head );
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: DosDevices( %wZ = %wZ )\n", &p->Name, &p->Value );
#endif
        InitializeObjectAttributes( &ObjectAttributes,
                                    &p->Name,
                                    OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_OPENIF,
                                    SmpDosDevicesObjectDirectory,
                                    SmpPrimarySecurityDescriptor
                                  );
        SmpSetDaclDefaulted( &ObjectAttributes, &OriginalSdControl );  //Use inheritable protection if available
        Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                             SYMBOLIC_LINK_ALL_ACCESS,
                                             &ObjectAttributes,
                                             &p->Value
                                           );

        if (Status == STATUS_OBJECT_NAME_EXISTS) {
            NtMakeTemporaryObject( LinkHandle );
            NtClose( LinkHandle );
            if (p->Value.Length != 0) {
                ObjectAttributes.Attributes &= ~OBJ_OPENIF;
                Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                                     SYMBOLIC_LINK_ALL_ACCESS,
                                                     &ObjectAttributes,
                                                     &p->Value
                                                   );
                }
            else {
                Status = STATUS_SUCCESS;
                }
            }
        SmpRestoreDaclDefaulted( &ObjectAttributes, OriginalSdControl );

        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to create %wZ => %wZ symbolic link object - Status == 0x%lx\n",
                       &p->Name,
                       &p->Value,
                       Status));

            return( Status );
            }

        NtClose( LinkHandle );

        if (p->AnsiValue)    { RtlFreeHeap( RtlProcessHeap(), 0, p->AnsiValue ); }
        if (p->Value.Buffer) { RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer ); }
        RtlFreeHeap( RtlProcessHeap(), 0, p );
        }

    return( Status );
}


VOID
SmpProcessModuleImports(
    IN PVOID Parameter,
    IN PCHAR ModuleName
    )
{
    NTSTATUS Status;
    WCHAR NameBuffer[ DOS_MAX_PATH_LENGTH ];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    PWSTR Name, Value;
    ULONG n;
    PWSTR s;

    //
    // Skip NTDLL.DLL as it is implicitly added to KnownDll list by kernel
    // before SMSS.EXE is started.
    //
    if (!_stricmp( ModuleName, "ntdll.dll" )) {
        return;
    }

    RtlInitAnsiString( &AnsiString, ModuleName );
    UnicodeString.Buffer = NameBuffer;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = sizeof( NameBuffer );

    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    if (!NT_SUCCESS( Status )) {
        return;
    }
    UnicodeString.MaximumLength = (USHORT)(UnicodeString.Length + sizeof( UNICODE_NULL ));

    s = UnicodeString.Buffer;
    n = 0;
    while (n < UnicodeString.Length) {
        if (*s == L'.') {
            break;
        } else {
            n += sizeof( WCHAR );
            s += 1;
        }
    }

    Value = UnicodeString.Buffer;
    Name = UnicodeString.Buffer + (UnicodeString.MaximumLength / sizeof( WCHAR ));
    n = n / sizeof( WCHAR );

    if ((Name - Value) + n >= DOS_MAX_PATH_LENGTH) {
        return;
    }
    wcsncpy( Name, Value, n );
    Name[ n ] = UNICODE_NULL;

    Status = SmpSaveRegistryValue( (PLIST_ENTRY)&SmpKnownDllsList,
                                   Name,
                                   Value,
                                   TRUE
                                 );
    if (Status == STATUS_OBJECT_NAME_EXISTS || !NT_SUCCESS( Status )) {
        return;
    }

    return;
}


NTSTATUS
SmpInitializeKnownDlls( VOID )
{
    NTSTATUS Status;
    UNICODE_STRING DirectoryObjectName;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;

    RtlInitUnicodeString( &DirectoryObjectName, L"\\KnownDlls" );

    Status = SmpInitializeKnownDllsInternal(
        &DirectoryObjectName,
        &SmpKnownDllPath);

#ifdef _WIN64
    if (!MiniNTBoot && NT_SUCCESS(Status))
    {
        RtlInitUnicodeString( &DirectoryObjectName, L"\\KnownDlls32" );

        Status = SmpInitializeKnownDllsInternal(
            &DirectoryObjectName,
            &SmpKnownDllPath32);
    }
#endif

    Head = &SmpKnownDllsList;
    while (!IsListEmpty( Head )) {
        Next = RemoveHeadList( Head );
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
        if (p->AnsiValue)    { RtlFreeHeap( RtlProcessHeap(), 0, p->AnsiValue ); }
        if (p->Value.Buffer) { RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer ); }
        RtlFreeHeap( RtlProcessHeap(), 0, p );
        }

    return Status;
}



NTSTATUS
SmpInitializeKnownDllsInternal(
    IN PUNICODE_STRING ObjectDirectoryName,
    IN PUNICODE_STRING KnownDllPath
    )
{
    NTSTATUS Status, Status1;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;
    PSMP_REGISTRY_VALUE pExclude;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE LinkHandle, FileHandle, SectionHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileName;
    SECURITY_DESCRIPTOR_CONTROL OriginalSdControl;
    USHORT ImageCharacteristics;
    HANDLE KnownDllFileDirectory = NULL;
    HANDLE KnownDllObjectDirectory = NULL;


    FileName.Buffer = NULL;

    //
    // Create \KnownDllsxx object directory
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                ObjectDirectoryName,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
                                NULL,
                                SmpKnownDllsSecurityDescriptor);

    Status = NtCreateDirectoryObject (&KnownDllObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &ObjectAttributes);
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to create %wZ directory - Status == %lx\n",
                   ObjectDirectoryName,
                   Status));

        return Status;
    }

    //
    // Open a handle to the file system directory that contains all the
    // known DLL files so we can do relative opens.
    //

    if (!RtlDosPathNameToNtPathName_U (KnownDllPath->Buffer,
                                       &FileName,
                                       NULL,
                                       NULL)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to to convert %wZ to an Nt path\n",
                   KnownDllPath));

        Status = STATUS_OBJECT_NAME_INVALID;
        goto exit_and_free;
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    //
    // Open a handle to the known dll file directory. Don't allow
    // deletes of the directory.
    //

    Status = NtOpenFile (&KnownDllFileDirectory,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open a handle to the KnownDll directory (%wZ) - Status == %lx\n",
                   KnownDllPath,
                   Status));

        KnownDllFileDirectory = NULL;
        goto exit_and_free;
    }

    RtlInitUnicodeString (&UnicodeString, L"KnownDllPath");
    InitializeObjectAttributes (&ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
                                KnownDllObjectDirectory,
                                SmpPrimarySecurityDescriptor);

    SmpSetDaclDefaulted (&ObjectAttributes, &OriginalSdControl);   //Use inheritable protection if available

    Status = NtCreateSymbolicLinkObject (&LinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         KnownDllPath);

    SmpRestoreDaclDefaulted (&ObjectAttributes, OriginalSdControl);

    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to create %wZ symbolic link - Status == %lx\n",
                   &UnicodeString,
                   Status));

        LinkHandle = NULL;
        goto exit_and_free;
    }

    Status1 = NtClose (LinkHandle);
    ASSERT (NT_SUCCESS (Status1));

    Head = &SmpKnownDllsList;
    Next = Head->Flink;
    while (Next != Head) {
        HANDLE ObjectDirectory;

        ObjectDirectory = NULL;
        p = CONTAINING_RECORD (Next,
                               SMP_REGISTRY_VALUE,
                               Entry);

        pExclude = SmpFindRegistryValue (&SmpExcludeKnownDllsList, p->Name.Buffer);
        if (pExclude == NULL) {
            pExclude = SmpFindRegistryValue (&SmpExcludeKnownDllsList, p->Value.Buffer);
        }

        if (pExclude != NULL) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
#if SMP_SHOW_REGISTRY_DATA
            DbgPrint( "SMSS: KnownDll( %wZ = %wZ )\n", &p->Name, &p->Value );
#endif
            InitializeObjectAttributes (&ObjectAttributes,
                                        &p->Value,
                                        OBJ_CASE_INSENSITIVE,
                                        KnownDllFileDirectory,
                                        NULL);

            Status = NtOpenFile (&FileHandle,
                                 SYNCHRONIZE | FILE_EXECUTE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_DELETE,
                                 FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if (NT_SUCCESS (Status)) {

            //
            // We want the side effects of this call (import
            // callout, but don't want to checksum anymore, so supress with
            // handle tag bit
            //

            ObjectDirectory = KnownDllObjectDirectory;
            Status = LdrVerifyImageMatchesChecksum ((HANDLE)((UINT_PTR)FileHandle|1),
                                                    SmpProcessModuleImports,
                                                    Next,
                                                    &ImageCharacteristics);
            if ( Status == STATUS_IMAGE_CHECKSUM_MISMATCH ) {

                ULONG_PTR ErrorParameters;
                ULONG ErrorResponse;

                //
                // Hard error time. One of the know DLL's is corrupt !
                //

                ErrorParameters = (ULONG_PTR)(&p->Value);

                NtRaiseHardError (Status,
                                  1,
                                  1,
                                  &ErrorParameters,
                                  OptionOk,
                                  &ErrorResponse);
            } else if (ImageCharacteristics & IMAGE_FILE_DLL) {
                InitializeObjectAttributes (&ObjectAttributes,
                                            &p->Value,
                                            OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                            ObjectDirectory,
                                            SmpLiberalSecurityDescriptor);

                SmpSetDaclDefaulted( &ObjectAttributes, &OriginalSdControl );  //use inheritable protection if available

                Status = NtCreateSection (&SectionHandle,
                                          SECTION_ALL_ACCESS,
                                          &ObjectAttributes,
                                          NULL,
                                          PAGE_EXECUTE,
                                          SEC_IMAGE,
                                          FileHandle);

                SmpRestoreDaclDefaulted (&ObjectAttributes, OriginalSdControl);

                if (!NT_SUCCESS (Status)) {
                    KdPrintEx((DPFLTR_SMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "SMSS: CreateSection for KnownDll %wZ failed - Status == %lx\n",
                               &p->Value,
                               Status));
                } else {
                    Status1 = NtClose (SectionHandle);
                    ASSERT (NT_SUCCESS (Status1));
                }
            } else {
                KdPrintEx((DPFLTR_SMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SMSS: Ignoring %wZ as KnownDll since it is not a DLL\n",
                           &p->Value));
            }

            Status1 = NtClose (FileHandle);
            ASSERT (NT_SUCCESS (Status1));
        }

        Next = Next->Flink;

        //
        // Note that section remains open. This will keep it around.
        // Maybe this should be a permenent section ?
        //
    }

    Status = STATUS_SUCCESS;

exit_and_free:

    if (KnownDllObjectDirectory != NULL) {
        Status1 = NtClose (KnownDllObjectDirectory);
        ASSERT (NT_SUCCESS (Status1));
    }

    if (KnownDllFileDirectory != NULL) {
        Status1 = NtClose (KnownDllFileDirectory);
        ASSERT (NT_SUCCESS (Status1));
    }

    if (FileName.Buffer != NULL) {
        RtlFreeHeap (RtlProcessHeap (), 0, FileName.Buffer);
    }
    return Status;
}

NTSTATUS
SmpSetProtectedFilesEnvVars(
    IN BOOLEAN SetEnvVar
    )
/*++

Routine Description:

    This function sets some environment variables that are not part of the
    default environment.  (These environment variables are normally set by
    winlogon.)  The environment variables need to be set for us to resolve
    all the environment variables in our protected files list.

    Note that SFC mirrors the data into the location below since smss can't
    get at the actual variable location

    The variables are:

    ProgramFiles
    CommonProgramFiles

    ProgramFiles(x86)
    CommonProgramFiles(x86)

Arguments:

    SetEnvVar - if TRUE, we should query the registry for this variables and
                set them.  if FALSE, we should clear the environment variables


Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING EnvVar;
    UNICODE_STRING EnvVarValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    ULONG Count;

    PCWSTR RegistryValues[] = {
          L"ProgramFilesDir"
        , L"CommonFilesDir"
#ifdef WX86
        , L"ProgramFilesDir(x86)"
        , L"CommonFilesDir(x86)"
#endif
    };

    PCWSTR EnvVars[] = {
          L"ProgramFiles"
        , L"CommonProgramFiles"
#ifdef WX86
        , L"ProgramFiles(x86)"
        , L"CommonProgramFiles(x86)"
#endif
    };

    #define EnvVarCount  sizeof(RegistryValues)/sizeof(PCWSTR)

    if (SetEnvVar) {


        //
        // Open the registry key.
        //

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        RtlInitUnicodeString(&KeyName,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\SFC");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: can't open control key: 0x%x\n",
                       Status));

            return Status;
        }

        //
        // Query the key values.
        //
        for (Count = 0; Count < EnvVarCount; Count++) {

            RtlInitUnicodeString(&ValueName, RegistryValues[Count]);
            Status = NtQueryValueKey(Key,
                                     &ValueName,
                                     KeyValuePartialInformation,
                                     (PVOID)KeyValueInfo,
                                     sizeof (ValueBuffer),
                                     &ValueLength);

            ASSERT(ValueLength < VALUE_BUFFER_SIZE);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SMSS: can't query value key %ws: 0x%x\n",
                           RegistryValues[Count],
                           Status));

            } else {


                ASSERT(KeyValueInfo->Type == REG_SZ);

                RtlInitUnicodeString(&EnvVar, EnvVars[Count]);

                EnvVarValue.Length = (USHORT)KeyValueInfo->DataLength;
                EnvVarValue.MaximumLength = (USHORT)KeyValueInfo->DataLength;
                EnvVarValue.Buffer = (PWSTR)KeyValueInfo->Data;

                Status = RtlSetEnvironmentVariable( NULL,
                                                    &EnvVar,
                                                    &EnvVarValue
                                                   );

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "SMSS: can't set environment variable %ws: 0x%x\n",
                               EnvVars[Count],
                               Status));
                }

            }

        }

        NtClose(Key);

    } else {
        //
        // clear out the variables
        //
        for (Count = 0; Count < EnvVarCount; Count++) {

            RtlInitUnicodeString(&EnvVar,      EnvVars[Count]);
            RtlInitUnicodeString(&EnvVarValue, NULL);

            Status = RtlSetEnvironmentVariable( NULL,
                                                &EnvVar,
                                                &EnvVarValue
                                               );

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SMSS: can't clear environment variable %ws: 0x%x\n",
                           EnvVars[Count],
                           Status));
            }
        }
    }

    return Status;
}

NTSTATUS
SmpGetProtectedFiles(
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount,
    OUT PVOID *hModule
    )
{
    NTSTATUS Status;
    UNICODE_STRING DllName;
    STRING ProcedureName;
    PSFCGETFILES pSfcGetFiles;

	ASSERT(hModule != NULL);
    *hModule = NULL;
    RtlInitUnicodeString( &DllName, L"sfcfiles.dll" );

    Status = LdrLoadDll(
        NULL,
        NULL,
        &DllName,
        hModule
        );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: LdrLoadDll failed for %ws, ec=%lx\n",
                   DllName.Buffer,
                   Status));

        return Status;
    }

    RtlInitString( &ProcedureName, "SfcGetFiles" );

    Status = LdrGetProcedureAddress(
        *hModule,
        &ProcedureName,
        0,
        (PVOID*)&pSfcGetFiles
        );
    if (NT_SUCCESS(Status)) {
#if SMP_SHOW_REGISTRY_DATA
		DbgPrint( "SMSS: sfcfile.dll loaded successfully, address=%08x\n", *hModule );
#endif

		Status = pSfcGetFiles( Files, FileCount );
	}
	else {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: LdrGetProcedureAddress failed for %ws, ec=%lx\n",
                   ProcedureName.Buffer,
                   Status));

		LdrUnloadDll(*hModule);
		*hModule = NULL;
    }

	return Status;
}


LONG
SpecialStringCompare(
    PUNICODE_STRING s1,
    PUNICODE_STRING s2
    )
{
    UNICODE_STRING tmp;


    if (s1->Buffer[0] != L'!') {
        return RtlCompareUnicodeString( s1, s2, TRUE );
    }

    tmp.Length = s1->Length - sizeof(WCHAR);
    tmp.MaximumLength = s1->MaximumLength - sizeof(WCHAR);
    tmp.Buffer = s1->Buffer + 1;

    return RtlCompareUnicodeString( &tmp, s2, TRUE );
}


VOID
SmpProcessFileRenames( VOID )
{
    NTSTATUS Status,OpenStatus;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE OldFileHandle,SetAttributesHandle;
    PFILE_RENAME_INFORMATION RenameInformation;
    FILE_DISPOSITION_INFORMATION DeleteInformation;
    FILE_INFORMATION_CLASS SetInfoClass;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG SetInfoLength;
    PVOID SetInfoBuffer;
    PWSTR s;
    BOOLEAN WasEnabled;
    UNICODE_STRING NewName;
    ULONG i;
    UNICODE_STRING ProtFileName = {0};
    UNICODE_STRING Tier2Name;
    UNICODE_STRING ProtName;
    PPROTECT_FILE_ENTRY Tier2Files;
    ULONG CountTier2Files;
    PVOID hModule = NULL;
    BOOLEAN EnvVarSet;


    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,
                                 FALSE,
                                 &WasEnabled
                               );
    if (!NT_SUCCESS( Status )) {
        WasEnabled = TRUE;
    }

    if (SmpAllowProtectedRenames == 0) {
        Status = SmpGetProtectedFiles( &Tier2Files, &CountTier2Files, &hModule );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpGetProtectedFiles failed, ec=%08x\n",
                       Status));

            SmpAllowProtectedRenames = 1;
        }
    }

    //
    // our list of protected files includes environment variables that are not
    // in the default environment, they are normally set by winlogon.  Set
    // those environment variables temporarily until we process the file rename
    // section, then we can clear them out again.
    //
    EnvVarSet = TRUE;
    Status = SmpSetProtectedFilesEnvVars( TRUE );
    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: SmpSetProtectedFilesEnvVars failed, ec=%08x\n",
                   Status));

        EnvVarSet = FALSE;
    }

    //
    // Process the list of file rename operations.
    //

    Head = &SmpFileRenameList;
    while (!IsListEmpty( Head )) {
        Next = RemoveHeadList( Head );
        p = CONTAINING_RECORD( Next, SMP_REGISTRY_VALUE, Entry );

#if SMP_SHOW_REGISTRY_DATA
        DbgPrint( "SMSS: FileRename( [%wZ] => [%wZ] )\n", &p->Name, &p->Value );
#endif

        //
        // ignore any file that is protected
        //

        if (SmpAllowProtectedRenames == 0) {
            ProtName.MaximumLength = 256 * sizeof(WCHAR);
            ProtName.Buffer = (PWSTR) RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), ProtName.MaximumLength );
            if (ProtName.Buffer) {
                for (i=0; i<CountTier2Files; i++) {
                    //
                    // if the file name is prefixed by the '@' character
                    // then we ignore the check and say the file is ok
                    //
                    if (p->Name.Buffer[0] == '@' || p->Value.Buffer[0] == L'@') {
                        break;
                    }
                    //
                    // convert the tier2 file name to an nt style file name
                    //
                    RtlInitUnicodeString(&Tier2Name,Tier2Files[i].FileName);
                    ProtName.Length = 0;
                    RtlZeroMemory( ProtName.Buffer, ProtName.MaximumLength );
                    if (ProtName.Buffer == NULL) {
                        continue;
                    }
                    Status = RtlExpandEnvironmentStrings_U(
                        NULL,
                        &Tier2Name,
                        &ProtName,
                        NULL
                        );
                    if (!NT_SUCCESS(Status)) {
                        continue;
                    }
                    if (!RtlDosPathNameToNtPathName_U( ProtName.Buffer, &ProtFileName, NULL, NULL )) {
                        continue;
                    }
                    //
                    // check for matches against both file names
                    //
                    if (SpecialStringCompare( &p->Name, &ProtFileName ) == 0 ||
                        SpecialStringCompare( &p->Value, &ProtFileName ) == 0)
                    {
                        break;
                    }
                    RtlFreeUnicodeString(&ProtFileName);
                    ProtFileName.Buffer = NULL;
                }
                RtlFreeHeap( RtlProcessHeap(), 0, ProtName.Buffer );
                if (i < CountTier2Files) {
                    if (p->Name.Buffer[0] == L'@' || p->Value.Buffer[0] == L'@') {
                    } else {
#if SMP_SHOW_REGISTRY_DATA
                        DbgPrint( "SMSS: Skipping rename because it is protected\n" );
#endif
                        //
                        // delete the source file so we don't leave any turds
                        //
                        if (p->Value.Length > 0 && ProtFileName.Buffer && SpecialStringCompare( &p->Name, &ProtFileName ) != 0) {
                            InitializeObjectAttributes(
                                &ObjectAttributes,
                                &p->Name,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );
                            Status = NtOpenFile(
                                &OldFileHandle,
                                (ACCESS_MASK)DELETE | SYNCHRONIZE,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_SYNCHRONOUS_IO_NONALERT
                                );
                            if (NT_SUCCESS( Status )) {
                                SetInfoClass = FileDispositionInformation;
                                SetInfoLength = sizeof( DeleteInformation );
                                SetInfoBuffer = &DeleteInformation;
                                DeleteInformation.DeleteFile = TRUE;
                                Status = NtSetInformationFile(
                                    OldFileHandle,
                                    &IoStatusBlock,
                                    SetInfoBuffer,
                                    SetInfoLength,
                                    SetInfoClass
                                    );
                                NtClose( OldFileHandle );
                            }
                        }
                        RtlFreeHeap( RtlProcessHeap(), 0, p );
                        RtlFreeUnicodeString(&ProtFileName);
                        ProtFileName.Buffer = NULL;
                        continue;
                    }
                } else {
#if SMP_SHOW_REGISTRY_DATA
                    DbgPrint( "SMSS: File is not in the protected list\n" );
#endif
                }
                if (ProtFileName.Buffer) {
                    RtlFreeUnicodeString(&ProtFileName);
                    ProtFileName.Buffer = NULL;
                }
            }
        }

        //
        // Open the file for delete access
        //

        if (p->Value.Length == 0 && p->Name.Buffer[0] == '@') {
            p->Name.Buffer += 1;
            p->Name.Length -= sizeof(WCHAR);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &p->Name,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtOpenFile( &OldFileHandle,
                             (ACCESS_MASK)DELETE | SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT
                           );
        if (NT_SUCCESS( Status )) {
            if (p->Value.Length == 0) {
                SetInfoClass = FileDispositionInformation;
                SetInfoLength = sizeof( DeleteInformation );
                SetInfoBuffer = &DeleteInformation;
                DeleteInformation.DeleteFile = TRUE;
                RenameInformation = NULL;
            } else {
                SetInfoClass = FileRenameInformation;
                SetInfoLength = p->Value.Length +
                                    sizeof( *RenameInformation );
                s = p->Value.Buffer;
                if (*s == L'!' || *s == L'@') {
                    s++;
                    SetInfoLength -= sizeof( UNICODE_NULL );
                }

                SetInfoBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ),
                                                 SetInfoLength
                                               );

                if (SetInfoBuffer != NULL) {
                    RenameInformation = SetInfoBuffer;
                    RenameInformation->ReplaceIfExists = (BOOLEAN)(s != p->Value.Buffer);
                    RenameInformation->RootDirectory = NULL;
                    RenameInformation->FileNameLength = SetInfoLength - sizeof( *RenameInformation );
                    RtlCopyMemory( RenameInformation->FileName,
                                   s,
                                   RenameInformation->FileNameLength
                                 );
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }

            if (NT_SUCCESS( Status )) {
                Status = NtSetInformationFile( OldFileHandle,
                                               &IoStatusBlock,
                                               SetInfoBuffer,
                                               SetInfoLength,
                                               SetInfoClass
                                             );
                if (!NT_SUCCESS( Status ) && SetInfoClass == FileRenameInformation && Status == STATUS_OBJECT_NAME_COLLISION && RenameInformation->ReplaceIfExists ) {
                    KdPrintEx((DPFLTR_SMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "\nSMSS: %wZ => %wZ failed - Status == %x, Possible readonly target\n",
                               &p->Name,
                               &p->Value,
                               Status));

                    //
                    // A rename was attempted, but the source existing file is readonly.
                    // this is a problem because folks that use movefileex to do delayed
                    // renames expect this to work and can leave a machine unbootable if
                    // the rename fails
                    //

                    //
                    // Open the file for Write Attributes access
                    //

                    NewName.Length = p->Value.Length - sizeof(L'!');
                    NewName.MaximumLength = p->Value.MaximumLength - sizeof(L'!');
                    NewName.Buffer = s;;

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &NewName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

                    OpenStatus = NtOpenFile( &SetAttributesHandle,
                                             (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                             &ObjectAttributes,
                                             &IoStatusBlock,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             FILE_SYNCHRONOUS_IO_NONALERT
                                           );
                    if (NT_SUCCESS( OpenStatus )) {
                        KdPrintEx((DPFLTR_SMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "     SMSS: Open Existing Success\n"));

                        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
                        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

                        OpenStatus = NtSetInformationFile(
                                        SetAttributesHandle,
                                        &IoStatusBlock,
                                        &BasicInfo,
                                        sizeof(BasicInfo),
                                        FileBasicInformation
                                        );
                        NtClose( SetAttributesHandle );
                        if ( NT_SUCCESS(OpenStatus) ) {
                            KdPrintEx((DPFLTR_SMSS_ID,
                                       DPFLTR_INFO_LEVEL,
                                       "     SMSS: Set To NORMAL OK\n"));

                            Status = NtSetInformationFile( OldFileHandle,
                                                           &IoStatusBlock,
                                                           SetInfoBuffer,
                                                           SetInfoLength,
                                                           SetInfoClass
                                                         );

                            if ( NT_SUCCESS(Status) ) {
                                KdPrintEx((DPFLTR_SMSS_ID,
                                           DPFLTR_INFO_LEVEL,
                                           "     SMSS: Re-Rename Worked OK\n"));
                                }
                            else {
                                KdPrintEx((DPFLTR_SMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "     SMSS: Re-Rename Failed - Status == %x\n",
                                           Status));
                                }
                            }
                        else {
                            KdPrintEx((DPFLTR_SMSS_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       "     SMSS: Set To NORMAL Failed - Status == %x\n",
                                       OpenStatus));
                            }
                        }
                    else {
                        KdPrintEx((DPFLTR_SMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "     SMSS: Open Existing file Failed - Status == %x\n",
                                   OpenStatus));
                        }
                    }
                }

            NtClose( OldFileHandle );
            }

        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: %wZ => %wZ failed - Status == %x\n",
                       &p->Name,
                       &p->Value,
                       Status));
            }
        else
        if (p->Value.Length == 0) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SMSS: %wZ (deleted)\n",
                       &p->Name ));
            }
        else {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SMSS: %wZ (renamed to) %wZ\n",
                       &p->Name,
                       &p->Value ));
            }

        if (p->AnsiValue)    { RtlFreeHeap( RtlProcessHeap(), 0, p->AnsiValue ); }
        if (p->Value.Buffer) { RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer ); }
        RtlFreeHeap( RtlProcessHeap(), 0, p );
    }

    if (EnvVarSet) {
        SmpSetProtectedFilesEnvVars( FALSE );
    }

    if (!WasEnabled) {
        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     FALSE,
                                     FALSE,
                                     &WasEnabled
                                   );
    }

    if (hModule) {
        LdrUnloadDll( hModule );
    }

    return;
}


NTSTATUS
SmpConfigureObjectDirectories(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PWSTR s;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING RpcControl;
    UNICODE_STRING Windows;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE DirectoryHandle;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    UNREFERENCED_PARAMETER( Context );

    RtlInitUnicodeString( &RpcControl, L"\\RPC Control");
    RtlInitUnicodeString( &Windows, L"\\Windows");
#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "ObjectDirectories", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( ValueType );
    UNREFERENCED_PARAMETER( ValueLength );
#endif
    s = (PWSTR)ValueData;
    while (*s) {
        RtlInitUnicodeString( &UnicodeString, s );

        //
        // This is NOT how I would choose to do this if starting from
        // scratch, but we are very close to shipping Daytona and I
        // needed to get the right protection on these objects.
        //

        SecurityDescriptor = SmpPrimarySecurityDescriptor;
        if (RtlEqualString( (PSTRING)&UnicodeString, (PSTRING)&RpcControl, TRUE ) ||
            RtlEqualString( (PSTRING)&UnicodeString, (PSTRING)&Windows, TRUE)  ) {
            SecurityDescriptor = SmpLiberalSecurityDescriptor;
        }

        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
                                    NULL,
                                    SecurityDescriptor
                                  );
        Status = NtCreateDirectoryObject( &DirectoryHandle,
                                          DIRECTORY_ALL_ACCESS,
                                          &ObjectAttributes
                                        );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to create %wZ object directory - Status == %lx\n",
                       &UnicodeString,
                       Status));
            }
        else {
            NtClose( DirectoryHandle );
            }

        while (*s++) {
            }
        }

    //
    // We dont care if the creates failed.
    //

    return( STATUS_SUCCESS );
}

NTSTATUS
SmpConfigureExecute(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "Execute", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( ValueType );
    UNREFERENCED_PARAMETER( ValueLength );
#endif
    return (SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                  ValueData,
                                  NULL,
                                  TRUE
                                )
           );
}

NTSTATUS
SmpConfigureMemoryMgmt(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "MemoryMgmt", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( ValueType );
    UNREFERENCED_PARAMETER( ValueLength );
#endif
    return (SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                  ValueData,
                                  NULL,
                                  TRUE
                                )
           );
}

NTSTATUS
SmpConfigureFileRenames(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    static PWSTR OldName = NULL;

    UNREFERENCED_PARAMETER( Context );
#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "FileRenameOperation", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueType );
#endif

    //
    // This routine gets called for each string in the MULTI_SZ. The
    // first string we get is the old name, the next string is the new name.
    //
    if (OldName == NULL) {
        //
        // Save a pointer to the old name, we'll need it on the next
        // callback.
        //
        OldName = ValueData;
        return(STATUS_SUCCESS);
    } else {
        Status = SmpSaveRegistryValue((PLIST_ENTRY)EntryContext,
                                      OldName,
                                      ValueData,
                                      FALSE);
        if (!NT_SUCCESS(Status)) {
#if SMP_SHOW_REGISTRY_DATA
            DbgPrint("SMSS: SmpSaveRegistryValue returned %08lx for FileRenameOperation\n", Status);
            DbgPrint("SMSS:     %ws %ws\n", OldName, ValueData);
#endif
        }
        OldName = NULL;
        return(Status);
    }
}

NTSTATUS
SmpConfigureDosDevices(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "DosDevices", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueType );
    UNREFERENCED_PARAMETER( ValueLength );
#endif
    return (SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                  ValueName,
                                  ValueData,
                                  TRUE
                                )
           );
}


NTSTATUS
SmpInitializeKnownDllPath(
    IN PUNICODE_STRING KnownDllPath,
    IN PVOID ValueData,
    IN ULONG ValueLength)
{
    KnownDllPath->Buffer = RtlAllocateHeap(
        RtlProcessHeap(),
        MAKE_TAG( INIT_TAG ),
        ValueLength);

    if (KnownDllPath->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    KnownDllPath->Length = (USHORT)( ValueLength - sizeof( UNICODE_NULL ) );
    KnownDllPath->MaximumLength = (USHORT)ValueLength;
    RtlCopyMemory(
        KnownDllPath->Buffer,
        ValueData,
        ValueLength);

    return STATUS_SUCCESS;
}




NTSTATUS
SmpConfigureKnownDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "KnownDlls", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueType );
#endif
    if (!_wcsicmp( ValueName, L"DllDirectory" )) {
        return SmpInitializeKnownDllPath( &SmpKnownDllPath,
                                          ValueData,
                                          ValueLength
                                        );
    }
#ifdef _WIN64
    if (!MiniNTBoot && !_wcsicmp( ValueName, L"DllDirectory32" )) {
        return SmpInitializeKnownDllPath( &SmpKnownDllPath32,
                                          ValueData,
                                          ValueLength
                                        );
    }
#endif
    else {
        return (SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                      ValueName,
                                      ValueData,
                                      TRUE
                                    )
               );
        }
}

NTSTATUS
SmpConfigureExcludeKnownDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "ExcludeKnownDlls", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueType );
#endif
    if (ValueType == REG_MULTI_SZ || ValueType == REG_SZ) {
        PWSTR s;

        s = (PWSTR)ValueData;
        while (*s != UNICODE_NULL) {
            Status = SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                           s,
                                           NULL,
                                           TRUE
                                         );
            if (!NT_SUCCESS( Status ) || ValueType == REG_SZ) {
                return Status;
                }

            while (*s++ != UNICODE_NULL) {
                }
            }
        }

    return( STATUS_SUCCESS );
}

NTSTATUS
SmpConfigureEnvironment(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( EntryContext );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "Environment", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueType );
#endif


    RtlInitUnicodeString( &Name, ValueName );
    RtlInitUnicodeString( &Value, ValueData );

    Status = RtlSetEnvironmentVariable( NULL,
                                        &Name,
                                        &Value
                                      );

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: 'SET %wZ = %wZ' failed - Status == %lx\n",
                   &Name,
                   &Value,
                   Status));

        return( Status );
    }

    if (!_wcsicmp( ValueName, L"Path" )) {

        SmpCalledConfigEnv++;

        //
        // Check if this is the second time this function is invoked
        // This routine is called twice to resolve forward references to
        // other environment variables defined in this key
        //

        if( SmpCalledConfigEnv == 2 ) {

            SmpDefaultLibPathBuffer = RtlAllocateHeap(
                                        RtlProcessHeap(),
                                        MAKE_TAG( INIT_TAG ),
                                        ValueLength
                                        );
            if ( !SmpDefaultLibPathBuffer ) {
                return ( STATUS_NO_MEMORY );
            }

            RtlCopyMemory( SmpDefaultLibPathBuffer,
                           ValueData,
                           ValueLength
                         );

            RtlInitUnicodeString( &SmpDefaultLibPath, SmpDefaultLibPathBuffer );
        }
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
SmpConfigureSubSystems(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{

    UNREFERENCED_PARAMETER( Context );

#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "SubSystems", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueLength );
#endif

    if (!_wcsicmp( ValueName, L"Required" ) || !_wcsicmp( ValueName, L"Optional" )) {
        if (ValueType == REG_MULTI_SZ) {
            //
            // Here if processing Required= or Optional= values, since they are
            // the only REG_MULTI_SZ value types under the SubSystem key.
            //
            PSMP_REGISTRY_VALUE p;
            PWSTR s;

            s = (PWSTR)ValueData;
            while (*s != UNICODE_NULL) {
                p = SmpFindRegistryValue( (PLIST_ENTRY)EntryContext,
                                          s
                                        );
                if (p != NULL) {
                    RemoveEntryList( &p->Entry );


                    //
                    // Required Subsystems are loaded. Optional subsystems are
                    // defered.
                    //

                    if (!_wcsicmp( ValueName, L"Required" ) ) {
                        InsertTailList( &SmpSubSystemsToLoad, &p->Entry );
                        }
                    else {
                        InsertTailList( &SmpSubSystemsToDefer, &p->Entry );
                        }
                    }
                else {
                    KdPrintEx((DPFLTR_SMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "SMSS: Invalid subsystem name - %ws\n",
                               s));
                    }

                while (*s++ != UNICODE_NULL) {
                    }
                }
            }

        return( STATUS_SUCCESS );
        }
    else if (!_wcsicmp( ValueName, L"PosixSingleInstance" ) &&
        (ValueType == REG_DWORD)) {
        RegPosixSingleInstance = TRUE;
#if 0
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SMSS: Single Instance Posix Subsystem Configured\n"));
#endif
        return( STATUS_SUCCESS );
    }
    else {
        return (SmpSaveRegistryValue( (PLIST_ENTRY)EntryContext,
                                      ValueName,
                                      ValueData,
                                      TRUE
                                    )
               );
        }
}


NTSTATUS
SmpParseToken(
    IN PUNICODE_STRING Source,
    IN BOOLEAN RemainderOfSource,
    OUT PUNICODE_STRING Token
    )
{
    PWSTR s, s1;
    ULONG i, cb;

    RtlInitUnicodeString( Token, NULL );
    s = Source->Buffer;
    if (Source->Length == 0) {
        return( STATUS_SUCCESS );
    }

    i = 0;
    while ((USHORT)i < Source->Length && *s <= L' ') {
        s++;
        i += 2;
    }

    if (RemainderOfSource) {
        cb = Source->Length - (i * sizeof( WCHAR ));
        s1 = (PWSTR)((PCHAR)s + cb);
        i = Source->Length / sizeof( WCHAR );
    } else {
        s1 = s;
        while ((USHORT)i < Source->Length && *s1 > L' ') {
            s1++;
            i += 2;
        }
        cb = (ULONG)((PCHAR)s1 - (PCHAR)s);
        while ((USHORT)i < Source->Length && *s1 <= L' ') {
            s1++;
            i += 2;
        }
    }

    if (cb > 0) {
        Token->Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), cb + sizeof( UNICODE_NULL ) );
        if (Token->Buffer == NULL) {
            return( STATUS_NO_MEMORY );
        }

        Token->Length = (USHORT)cb;
        Token->MaximumLength = (USHORT)(cb + sizeof( UNICODE_NULL ));
        RtlCopyMemory( Token->Buffer, s, cb );
        Token->Buffer[ cb / sizeof( WCHAR ) ] = UNICODE_NULL;
    }

    Source->Length -= (USHORT)((PCHAR)s1 - (PCHAR)Source->Buffer);
    Source->Buffer = s1;
    return( STATUS_SUCCESS );
}


NTSTATUS
SmpParseCommandLine(
    IN PUNICODE_STRING CommandLine,
    OUT PULONG Flags OPTIONAL,
    OUT PUNICODE_STRING ImageFileName,
    OUT PUNICODE_STRING ImageFileDirectory,
    OUT PUNICODE_STRING Arguments
    )
{
    NTSTATUS Status;
    UNICODE_STRING Input, Token;
    UNICODE_STRING PathVariableName;
    UNICODE_STRING PathVariableValue;
    PWSTR DosFilePart;
    WCHAR FullDosPathBuffer[ DOS_MAX_PATH_LENGTH ];
    ULONG SpResult;

    RtlInitUnicodeString( ImageFileName, NULL );
    RtlInitUnicodeString( Arguments, NULL );

    if (ARGUMENT_PRESENT( ImageFileDirectory )) {
        RtlInitUnicodeString( ImageFileDirectory, NULL );
        }

    //
    // make sure lib path has systemroot\system32. Otherwise, the system will
    // not boot properly
    //

    if ( !SmpSystemRoot.Length ) {
        UNICODE_STRING NewLibString;

        RtlInitUnicodeString( &SmpSystemRoot,USER_SHARED_DATA->NtSystemRoot );


        NewLibString.Length = 0;
        NewLibString.MaximumLength =
            SmpSystemRoot.MaximumLength +
            20 +                          // length of \system32;
            SmpDefaultLibPath.MaximumLength;

        NewLibString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(),
                                MAKE_TAG( INIT_TAG ),
                                NewLibString.MaximumLength
                                );

        if ( NewLibString.Buffer ) {
            RtlAppendUnicodeStringToString(&NewLibString,&SmpSystemRoot );
            RtlAppendUnicodeToString(&NewLibString,L"\\system32;");
            RtlAppendUnicodeStringToString(&NewLibString,&SmpDefaultLibPath );

            RtlFreeHeap(RtlProcessHeap(), 0, SmpDefaultLibPath.Buffer );

            SmpDefaultLibPath = NewLibString;
            }
        }

    Input = *CommandLine;
    while (TRUE) {
        Status = SmpParseToken( &Input, FALSE, &Token );
        if (!NT_SUCCESS( Status ) || Token.Buffer == NULL) {
            return( STATUS_UNSUCCESSFUL );
            }

        if (ARGUMENT_PRESENT( Flags )) {
            if (RtlEqualUnicodeString( &Token, &SmpDebugKeyword, TRUE )) {
                *Flags |= SMP_DEBUG_FLAG;
                RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
                continue;
                }
            else
            if (RtlEqualUnicodeString( &Token, &SmpASyncKeyword, TRUE )) {
                *Flags |= SMP_ASYNC_FLAG;
                RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
                continue;
                }
            else
            if (RtlEqualUnicodeString( &Token, &SmpAutoChkKeyword, TRUE )) {
                *Flags |= SMP_AUTOCHK_FLAG;
                RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
                continue;
                }
#if defined(REMOTE_BOOT)
            else
            if (RtlEqualUnicodeString( &Token, &SmpAutoFmtKeyword, TRUE )) {
                *Flags |= SMP_AUTOFMT_FLAG;
                RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
                continue;
                }
#endif // defined(REMOTE_BOOT)
            }

        SpResult = 0;
        RtlInitUnicodeString( &PathVariableName, L"Path" );
        PathVariableValue.Length = 0;
        PathVariableValue.MaximumLength = 4096;
        PathVariableValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ),
                                                    PathVariableValue.MaximumLength
                                                  );
        if (PathVariableValue.Buffer == NULL) {
           RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        Status = RtlQueryEnvironmentVariable_U( SmpDefaultEnvironment,
                                                &PathVariableName,
                                                &PathVariableValue
                                              );
        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            RtlFreeHeap( RtlProcessHeap(), 0, PathVariableValue.Buffer );
            PathVariableValue.MaximumLength = PathVariableValue.Length + 2;
            PathVariableValue.Length = 0;
            PathVariableValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ),
                                                        PathVariableValue.MaximumLength
                                                      );
           if (PathVariableValue.Buffer == NULL) {
               RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
               return STATUS_INSUFFICIENT_RESOURCES;
           }

            Status = RtlQueryEnvironmentVariable_U( SmpDefaultEnvironment,
                                                    &PathVariableName,
                                                    &PathVariableValue
                                                  );
            }
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: %wZ environment variable not defined.\n",
                       &PathVariableName));

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        else
        if (!ARGUMENT_PRESENT( Flags ) ||
#pragma prefast(suppress: 209, "This *does* take a byte count--not a character count")
            !(SpResult = RtlDosSearchPath_U( PathVariableValue.Buffer,
                                 Token.Buffer,
                                 L".exe",
                                 sizeof( FullDosPathBuffer ),
                                 FullDosPathBuffer,
                                 &DosFilePart
                               ))
           ) {
            if (!ARGUMENT_PRESENT( Flags )) {
                wcscpy( FullDosPathBuffer, Token.Buffer );
                }
            else {

                if ( !SpResult ) {

                    //
                    // The search path call failed. Now try the call again using
                    // the default lib path. This always has systemroot\system32
                    // at the front.
                    //
#pragma prefast(suppress: 209, "This *does* take a byte count--not a character count")
                    SpResult = RtlDosSearchPath_U(
                                 SmpDefaultLibPath.Buffer,
                                 Token.Buffer,
                                 L".exe",
                                 sizeof( FullDosPathBuffer ),
                                 FullDosPathBuffer,
                                 &DosFilePart
                               );
                    }
                if ( !SpResult ) {
                    *Flags |= SMP_IMAGE_NOT_FOUND;
                    *ImageFileName = Token;
                    RtlFreeHeap( RtlProcessHeap(), 0, PathVariableValue.Buffer );
                    return( STATUS_SUCCESS );
                    }
                }
            }

        RtlFreeHeap( RtlProcessHeap(), 0, Token.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, PathVariableValue.Buffer );
        if (NT_SUCCESS( Status ) &&
            !RtlDosPathNameToNtPathName_U( FullDosPathBuffer,
                                           ImageFileName,
                                           NULL,
                                           NULL
                                         )
           ) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to translate %ws into an NT File Name\n",
                       FullDosPathBuffer));

            Status = STATUS_OBJECT_PATH_INVALID;
            }

        if (!NT_SUCCESS( Status )) {
            return( Status );
            }

        if (ARGUMENT_PRESENT( ImageFileDirectory )) {
            if (DosFilePart > FullDosPathBuffer) {
                *--DosFilePart = UNICODE_NULL;
                RtlCreateUnicodeString( ImageFileDirectory,
                                        FullDosPathBuffer
                                      );
                }
            else {
                RtlInitUnicodeString( ImageFileDirectory, NULL );
                }
            }

        break;
        }

    Status = SmpParseToken( &Input, TRUE, Arguments );
    return( Status );
}


ULONG
SmpConvertInteger(
    IN PWSTR String
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG Value;

    RtlInitUnicodeString( &UnicodeString, String );
    Status = RtlUnicodeStringToInteger( &UnicodeString, 0, &Value );
    if (NT_SUCCESS( Status )) {
        return( Value );
        }
    else {
        return( 0 );
        }
}


NTSTATUS
SmpExecuteImage(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    IN ULONG Flags,
    IN OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation OPTIONAL
    )

/*++

Routine Description:

    This function creates and starts a process specified by the
    CommandLine parameter.  After starting the process, the procedure
    will optionally wait for the first thread in the process to
    terminate.

Arguments:

    ImageFileName - Supplies the full NT path for the image file to
        execute.  Presumably computed or extracted from the first
        token of the CommandLine.

    CommandLine - Supplies the command line to execute.  The first blank
        separate token on the command line must be a fully qualified NT
        Path name of an image file to execute.

    Flags - Supplies information about how to invoke the command.

    ProcessInformation - Optional parameter, which if specified, receives
        information for images invoked with the SMP_ASYNC_FLAG.  Ignore
        if this flag is not set.

Return Value:

    Status of operation

--*/

{
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION MyProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
#if 0
    BOOLEAN ImageWhacked;
#endif
    if (!ARGUMENT_PRESENT( ProcessInformation )) {
        ProcessInformation = &MyProcessInformation;
        }


#if 0
    //
    // this seems to break setup's sense of what SystemRoot is
    ImageWhacked = FALSE;
    if ( ImageFileName && ImageFileName->Length > 8 ) {
        if (    ImageFileName->Buffer[0] == L'\\'
            &&  ImageFileName->Buffer[1] == L'?'
            &&  ImageFileName->Buffer[2] == L'?'
            &&  ImageFileName->Buffer[3] == L'\\' ) {
            ImageWhacked = TRUE;
            ImageFileName->Buffer[1] = L'\\';
            }
        }
#endif

    Status = RtlCreateProcessParameters( &ProcessParameters,
                                         ImageFileName,
                                         (SmpDefaultLibPath.Length == 0 ?
                                                   NULL : &SmpDefaultLibPath
                                         ),
                                         CurrentDirectory,
                                         CommandLine,
                                         SmpDefaultEnvironment,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL
                                       );

#if 0
    if ( ImageWhacked ) {
        ImageFileName->Buffer[1] = L'?';
        }
#endif

    ASSERTMSG( "RtlCreateProcessParameters", NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: RtlCreateProcessParameters failed for %wZ - Status == %lx\n",
                   ImageFileName,
                   Status));

        return( Status );
    }
    if (Flags & SMP_DEBUG_FLAG) {
        ProcessParameters->DebugFlags = TRUE;
        }
    else {
        ProcessParameters->DebugFlags = SmpDebug;
        }

    if ( Flags & SMP_SUBSYSTEM_FLAG ) {
        ProcessParameters->Flags |= RTL_USER_PROC_RESERVE_1MB;
        }

    ProcessInformation->Length = sizeof( RTL_USER_PROCESS_INFORMATION );
    Status = RtlCreateUserProcess( ImageFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   ProcessParameters,
                                   NULL,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   ProcessInformation
                                 );
    RtlDestroyProcessParameters( ProcessParameters );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Failed load of %wZ - Status  == %lx\n",
                   ImageFileName,
                   Status));

        return( Status );
        }

    //
    // Set the MuSessionId in the PEB of the new process.
    //

    Status = SmpSetProcessMuSessionId( ProcessInformation->Process, MuSessionId );

    if (!(Flags & SMP_DONT_START)) {
        if (ProcessInformation->ImageInformation.SubSystemType !=
            IMAGE_SUBSYSTEM_NATIVE
           ) {
            NtTerminateProcess( ProcessInformation->Process,
                                STATUS_INVALID_IMAGE_FORMAT
                              );
            NtWaitForSingleObject( ProcessInformation->Thread, FALSE, NULL );
            NtClose( ProcessInformation->Thread );
            NtClose( ProcessInformation->Process );
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Not an NT image - %wZ\n",
                       ImageFileName));

            return( STATUS_INVALID_IMAGE_FORMAT );
            }

        NtResumeThread( ProcessInformation->Thread, NULL );

        if (!(Flags & SMP_ASYNC_FLAG)) {
            NtWaitForSingleObject( ProcessInformation->Thread, FALSE, NULL );
            }

        NtClose( ProcessInformation->Thread );
        NtClose( ProcessInformation->Process );
        }

    return( Status );
}


NTSTATUS
SmpExecuteCommand(
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    OUT PULONG_PTR pWindowsSubSysProcessId,
    IN ULONG Flags
    )
/*++

Routine Description:

    This function is called to execute a command.

    The format of CommandLine is:

        Nt-Path-To-AutoChk.exe Nt-Path-To-Disk-Partition

    If the NT path to the disk partition is an asterisk, then invoke
    the AutoChk.exe utility on all hard disk partitions.

#if defined(REMOTE_BOOT)
                      -or-

        Nt-Path-To-AutoFmt.exe Nt-Path-To-Disk-Partition
#endif // defined(REMOTE_BOOT)

Arguments:

    CommandLine - Supplies the Command line to invoke.

    Flags - Specifies the type of command and options.

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING ImageFileName;
    UNICODE_STRING CurrentDirectory;
    UNICODE_STRING Arguments;

    if (Flags & SMP_DEBUG_FLAG) {
        return( STATUS_SUCCESS );
    }

    Status = SmpParseCommandLine( CommandLine,
                                  &Flags,
                                  &ImageFileName,
                                  &CurrentDirectory,
                                  &Arguments
                                );

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: SmpParseCommand( %wZ ) failed - Status == %lx\n",
                   CommandLine,
                   Status));

        return( Status );
        }

    if (Flags & SMP_AUTOCHK_FLAG) {
        Status = SmpInvokeAutoChk( &ImageFileName, &CurrentDirectory, &Arguments, Flags );
        }
#if defined(REMOTE_BOOT)
    else
    if (Flags & SMP_AUTOFMT_FLAG) {
        Status = SmpInvokeAutoFmt( &ImageFileName, &CurrentDirectory, &Arguments, Flags );
        }
#endif // defined(REMOTE_BOOT)
    else
    if (Flags & SMP_SUBSYSTEM_FLAG) {
        Status = SmpLoadSubSystem( &ImageFileName, &CurrentDirectory, CommandLine, MuSessionId, pWindowsSubSysProcessId, Flags );
        }
    else {
        if (Flags & SMP_IMAGE_NOT_FOUND) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Image file (%wZ) not found\n",
                       &ImageFileName));

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        else {
            Status = SmpExecuteImage( &ImageFileName,
                                      &CurrentDirectory,
                                      CommandLine,
                                      MuSessionId,
                                      Flags,
                                      NULL
                                    );
            }
        }

    // ImageFileName may be returned even
    // when SMP_IMAGE_NOT_FOUND flag is set
    if (ImageFileName.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, ImageFileName.Buffer );
        if (CurrentDirectory.Buffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, CurrentDirectory.Buffer );
            }
        }

    if (Arguments.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Arguments.Buffer );
        }

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Command '%wZ' failed - Status == %x\n",
                   CommandLine,
                   Status));
        }

    return( Status );
}

BOOLEAN
SmpSaveAndClearBootStatusData(
    OUT PBOOLEAN BootOkay,
    OUT PBOOLEAN ShutdownOkay
    )
/*++

Routine Description:

    This routine saves the boot status flags in the boot status data and then
    sets the data file to indicate a successful boot and shutdown.  This is 
    used to avoid triggering auto-recovery in the loader if autoconvert or 
    autochk reboots the machine as part of its run.  
    
    The caller is responsible for calling SmpRestoreBootStatusData if the 
    auto* program allows boot to continue.

Arguments:

    BootOkay - the status of the boot
    
    ShutdownOkay - the status of the shutdown    

Return Value:

    TRUE if the values were saved and should be restored.
    FALSE if an error occurred and no values were saved.
    
--*/        
{
    NTSTATUS Status;

    PVOID BootStatusDataHandle;

    *BootOkay = FALSE;
    *ShutdownOkay = FALSE;

    Status = RtlLockBootStatusData(&BootStatusDataHandle);
    
    if(NT_SUCCESS(Status)) {

        BOOLEAN t = TRUE;

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                TRUE,
                                RtlBsdItemBootGood,
                                BootOkay,
                                sizeof(BOOLEAN),
                                NULL);

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                TRUE,
                                RtlBsdItemBootShutdown,
                                ShutdownOkay,
                                sizeof(BOOLEAN),
                                NULL);

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                FALSE,
                                RtlBsdItemBootGood,
                                &t,
                                sizeof(BOOLEAN),
                                NULL);

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                FALSE,
                                RtlBsdItemBootShutdown,
                                &t,
                                sizeof(BOOLEAN),
                                NULL);

        RtlUnlockBootStatusData(BootStatusDataHandle);

        return TRUE;
    }

    return FALSE;
}

VOID
SmpRestoreBootStatusData(
    IN BOOLEAN BootOkay,
    IN BOOLEAN ShutdownOkay
    )
/*++

Routine Description:

    This routine restores the boot status flags in the boot status data to
    the provided values.
    
Arguments:

    BootOkay - the status of the boot
    
    ShutdownOkay - the status of the shutdown    

Return Value:

    none.
    
--*/        
{
    NTSTATUS Status;

    PVOID BootStatusDataHandle;

    Status = RtlLockBootStatusData(&BootStatusDataHandle);
    
    if(NT_SUCCESS(Status)) {

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                FALSE,
                                RtlBsdItemBootGood,
                                &BootOkay,
                                sizeof(BOOLEAN),
                                NULL);

        RtlGetSetBootStatusData(BootStatusDataHandle,
                                FALSE,
                                RtlBsdItemBootShutdown,
                                &ShutdownOkay,
                                sizeof(BOOLEAN),
                                NULL);

        RtlUnlockBootStatusData(BootStatusDataHandle);
    }

    return;
}


NTSTATUS
SmpInvokeAutoChk(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING Arguments,
    IN ULONG Flags
    )
{
    NTSTATUS Status;

    CHAR DisplayBuffer[ MAXIMUM_FILENAME_LENGTH ];
    ANSI_STRING AnsiDisplayString;
    UNICODE_STRING DisplayString;

    UNICODE_STRING CmdLine;
    WCHAR CmdLineBuffer[ 2 * MAXIMUM_FILENAME_LENGTH ];

    BOOLEAN BootStatusDataSaved = FALSE;
    BOOLEAN BootOkay;
    BOOLEAN ShutdownOkay;

    //
    // Query the system environment variable "osloadoptions" to determine
    // if SOS is specified.  What for though?  No one is using it.
    //

    if (SmpQueryRegistrySosOption() != FALSE) {
        SmpEnableDots = FALSE;
    }

    if (Flags & SMP_IMAGE_NOT_FOUND) {
        sprintf( DisplayBuffer,
                 "%wZ program not found - skipping AUTOCHECK\n",
                 ImageFileName
               );

        RtlInitAnsiString( &AnsiDisplayString, DisplayBuffer );
        Status = RtlAnsiStringToUnicodeString( &DisplayString,
                                               &AnsiDisplayString,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status )) {
            NtDisplayString( &DisplayString );
            RtlFreeUnicodeString( &DisplayString );
            }

        return( STATUS_SUCCESS );
        }

    //
    // Save away the boot & shutdown status flags in the boot status data 
    // and restore them after autochk returns.  This way if autochk forces
    // a reboot the loader won't put up the autorecovery menu.
    //

    BootStatusDataSaved = SmpSaveAndClearBootStatusData(&BootOkay,
                                                        &ShutdownOkay);

    CmdLine.Buffer = CmdLineBuffer;
    CmdLine.MaximumLength = sizeof( CmdLineBuffer );
    CmdLine.Length = 0;
    RtlAppendUnicodeStringToString( &CmdLine, ImageFileName );
    RtlAppendUnicodeToString( &CmdLine, L" " );
    RtlAppendUnicodeStringToString( &CmdLine, Arguments );
    SmpExecuteImage( ImageFileName,
                     CurrentDirectory,
                     &CmdLine,
                     0,          // MuSessionId
                     Flags & ~SMP_AUTOCHK_FLAG,
                     NULL
                   );

    //
    // If autochk doesn't shut us down then we end up back here.  Restore the 
    // values we saved.
    //

    if(BootStatusDataSaved) {
        SmpRestoreBootStatusData(BootOkay, ShutdownOkay);
    }

    return( STATUS_SUCCESS );
}

#if defined(REMOTE_BOOT)
NTSTATUS
SmpInvokeAutoFmt(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING Arguments,
    IN ULONG Flags
    )
{
    NTSTATUS Status;
    CHAR DisplayBuffer[ MAXIMUM_FILENAME_LENGTH ];
    ANSI_STRING AnsiDisplayString;
    UNICODE_STRING DisplayString;
    UNICODE_STRING CmdLine;
    WCHAR CmdLineBuffer[ 2 * MAXIMUM_FILENAME_LENGTH ];

    BOOLEAN BootStatusDataSaved;
    BOOLEAN BootOkay;
    BOOLEAN ShutdownOkay;

    //
    // Query the system environment variable "osloadoptions" to determine
    // if SOS is specified.
    //

    if (SmpQueryRegistrySosOption() != FALSE) {
        SmpEnableDots = FALSE;
    }

    if (Flags & SMP_IMAGE_NOT_FOUND) {
        sprintf( DisplayBuffer,
                 "%wZ program not found - skipping AUTOFMT\n",
                 ImageFileName
               );

        RtlInitAnsiString( &AnsiDisplayString, DisplayBuffer );
        Status = RtlAnsiStringToUnicodeString( &DisplayString,
                                               &AnsiDisplayString,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status )) {
            NtDisplayString( &DisplayString );
            RtlFreeUnicodeString( &DisplayString );
            }

        return( STATUS_SUCCESS );
        }

    BootStatusDataSaved = SmpSaveAndClearBootStatusData(&BootOkay,
                                                        &ShutdownOkay);

    CmdLine.Buffer = CmdLineBuffer;
    CmdLine.MaximumLength = sizeof( CmdLineBuffer );
    CmdLine.Length = 0;
    RtlAppendUnicodeStringToString( &CmdLine, ImageFileName );
    RtlAppendUnicodeToString( &CmdLine, L" " );
    RtlAppendUnicodeStringToString( &CmdLine, Arguments );

    SmpExecuteImage( ImageFileName,
                     CurrentDirectory,
                     &CmdLine,
                     0, //Console MuSessionId
                     Flags & ~SMP_AUTOFMT_FLAG,
                     NULL
                   );

    if(BootStatusDataSaved) {
        SmpRestoreBootStatusData(BootOkay, ShutdownOkay);
    }

    return( STATUS_SUCCESS );
}
#endif // defined(REMOTE_BOOT)


NTSTATUS
SmpLoadSubSystem(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    OUT PULONG_PTR pWindowsSubSysProcessId,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function loads and starts the specified system service
    emulation subsystem. The system freezes until the loaded subsystem
    completes the subsystem connection protocol by connecting to SM,
    and then accepting a connection from SM.

    For terminal server, the subsystem is started by csrss so that the
    correct session is used.

Arguments:

    CommandLine - Supplies the command line to execute the subsystem.

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PSMPKNOWNSUBSYS KnownSubSys = NULL;
    PSMPKNOWNSUBSYS TargetSubSys = NULL;
    PSMPKNOWNSUBSYS CreatorSubSys = NULL;
    LARGE_INTEGER Timeout;
    ULONG SubsysMuSessionId = MuSessionId;
    PVOID State;
    NTSTATUS AcquirePrivilegeStatus = STATUS_SUCCESS;

    if (Flags & SMP_IMAGE_NOT_FOUND) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to find subsystem - %wZ\n",
                   ImageFileName));

        return( STATUS_OBJECT_NAME_NOT_FOUND );
        }

    //
    // Check for single instance POSIX subsystem
    //
    if (Flags & SMP_POSIX_SI_FLAG) {
        // Run only one copy using the console Logon Id
        SubsysMuSessionId = 0;
    }

    //
    // There is a race condition on hydra loading subsystems. Two
    // requests can be received from the same MuSessionId to load
    // the same subsystem. There is a window in hydra since the
    // ImageType == 0xFFFFFFFF until the newly started subsystem connects
    // back. Non-hydra didn't have this problem since the optional
    // subsystem entry was destroyed once started. Hydra does not do this
    // since multiple sessions may want to start an optional subsystem.
    //
    // To close this window, on hydra this value is looked up based on
    // the MuSessionId to see if any subsystems are starting.
    // If so, we wait for the Active event. We can then
    // run our checks for the subsystem already being loaded. This has
    // the effect of serializing the startup of a subsystem on hydra
    // per MuSessionId, but not across the system. IE: Posix and
    // OS2 can't start at the same time, but will wait until
    // the other has started on a MuSessionId basis.
    //
    // We also use the SmpKnownSubSysLock to handle existing
    // race conditions since we have multiple SmpApiLoop() threads.
    //

    RtlEnterCriticalSection( &SmpKnownSubSysLock );

    do {

        TargetSubSys = SmpLocateKnownSubSysByType(
                           SubsysMuSessionId,
                           0xFFFFFFFF
                           );

        if( TargetSubSys ) {
            HANDLE hEvent = TargetSubSys->Active;
            RtlLeaveCriticalSection( &SmpKnownSubSysLock );
            Status = NtWaitForSingleObject( hEvent, FALSE, NULL );
            RtlEnterCriticalSection( &SmpKnownSubSysLock );
            SmpDeferenceKnownSubSys(TargetSubSys);
        }

    } while ( TargetSubSys != NULL );

    if (Flags & SMP_POSIX_FLAG) {
        TargetSubSys = SmpLocateKnownSubSysByType(
                           SubsysMuSessionId,
                           IMAGE_SUBSYSTEM_POSIX_CUI
                           );

        if( TargetSubSys ) {
            SmpDeferenceKnownSubSys(TargetSubSys);
            RtlLeaveCriticalSection( &SmpKnownSubSysLock );
            return( STATUS_SUCCESS );
        }
    }

    if (Flags & SMP_OS2_FLAG) {
        TargetSubSys = SmpLocateKnownSubSysByType(
                           SubsysMuSessionId,
                           IMAGE_SUBSYSTEM_OS2_CUI
                           );

        if( TargetSubSys ) {
            SmpDeferenceKnownSubSys(TargetSubSys);
            RtlLeaveCriticalSection( &SmpKnownSubSysLock );
            return( STATUS_SUCCESS );
        }
    }

    //
    // Create and register KnownSubSys entry before releasing the lock
    // so that other threads will see that we are starting a subsystem
    // on this MuSessionId.
    //
    KnownSubSys = RtlAllocateHeap( SmpHeap, MAKE_TAG( INIT_TAG ), sizeof( SMPKNOWNSUBSYS ) );
    if ( KnownSubSys == NULL ) {
        RtlLeaveCriticalSection( &SmpKnownSubSysLock );
        return( STATUS_NO_MEMORY );
    }


    KnownSubSys->Deleting = FALSE;
    KnownSubSys->Process = NULL;
    KnownSubSys->Active = NULL;
    KnownSubSys->MuSessionId = SubsysMuSessionId;
    KnownSubSys->ImageType = (ULONG)0xFFFFFFFF;
    KnownSubSys->SmApiCommunicationPort = (HANDLE) NULL;
    KnownSubSys->SbApiCommunicationPort = (HANDLE) NULL;
    KnownSubSys->RefCount = 1;

    Status = NtCreateEvent( &KnownSubSys->Active,
                            EVENT_ALL_ACCESS,
                            NULL,
                            NotificationEvent,
                            FALSE
                          );

    if( !NT_SUCCESS(Status) ) {
        RtlFreeHeap( SmpHeap, 0, KnownSubSys );
        RtlLeaveCriticalSection( &SmpKnownSubSysLock );
        return( STATUS_NO_MEMORY );
    }

    InsertHeadList( &SmpKnownSubSysHead, &KnownSubSys->Links );

    RtlLeaveCriticalSection( &SmpKnownSubSysLock );

    Flags |= SMP_DONT_START;

    if (((Flags & SMP_OS2_FLAG) || (Flags & SMP_POSIX_FLAG))) {

        SBAPIMSG m;
        PSBCREATEPROCESS args = &m.u.CreateProcess;

        //
        // Create it in csrss instead.
        //

        CreatorSubSys = SmpLocateKnownSubSysByType(SubsysMuSessionId,
                                                   IMAGE_SUBSYSTEM_WINDOWS_GUI);

        //
        // CSRSS must have been started.
        //

        if (CreatorSubSys == NULL) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - SmpLocateKnownSubSysByType Failed\n"));

            goto cleanup2;
        }

        args->i.ImageFileName = ImageFileName;
        args->i.CurrentDirectory = CurrentDirectory;
        args->i.CommandLine = CommandLine;
        args->i.DefaultLibPath = (SmpDefaultLibPath.Length == 0 ?
                                NULL : &SmpDefaultLibPath
                                );
        args->i.Flags = Flags;
        args->i.DefaultDebugFlags = SmpDebug;

        Status = SmpCallCsrCreateProcess(&m,
                                         sizeof(*args),
                                         CreatorSubSys->SbApiCommunicationPort
                                         );

        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - SmpCallCsrCreateProcess Failed with  Status %lx\n",
                       Status));

            goto cleanup2;
        }

        //
        // Copy the output parameters to where smss expects them.
        //

        ProcessInformation.Process = args->o.Process;
        ProcessInformation.Thread = args->o.Thread;
        ProcessInformation.ClientId.UniqueProcess = args->o.ClientId.UniqueProcess;
        ProcessInformation.ClientId.UniqueThread = args->o.ClientId.UniqueThread;
        ProcessInformation.ImageInformation.SubSystemType = args->o.SubSystemType;

    } else {
        Status = SmpExecuteImage( ImageFileName,
                                  CurrentDirectory,
                                  CommandLine,
                                  SubsysMuSessionId,
                                  Flags,
                                  &ProcessInformation
                                  );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - SmpExecuteImage Failed with  Status %lx\n",
                       Status));

            goto cleanup2;
        }
    }

    KnownSubSys->Process = ProcessInformation.Process;
    KnownSubSys->InitialClientId = ProcessInformation.ClientId;

    //
    // Now that we have the process all set, make sure that the
    // subsystem is either an NT native app, or an app type of
    // a previously loaded subsystem.
    //

    if (ProcessInformation.ImageInformation.SubSystemType !=
                IMAGE_SUBSYSTEM_NATIVE ) {
        SBAPIMSG SbApiMsg;
        PSBCREATESESSION args;
        ULONG SessionId;

        args = &SbApiMsg.u.CreateSession;

        args->ProcessInformation = ProcessInformation;
        args->DebugSession = 0;
        args->DebugUiClientId.UniqueProcess = NULL;
        args->DebugUiClientId.UniqueThread = NULL;

        TargetSubSys = SmpLocateKnownSubSysByType(
                      MuSessionId,
                      ProcessInformation.ImageInformation.SubSystemType
                      );
        if ( !TargetSubSys ) {
            Status = STATUS_NO_SUCH_PACKAGE;
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - SmpLocateKnownSubSysByType Failed with  Status %lx for sessionid %ld\n",
                       Status,
                       MuSessionId));

            goto cleanup;
            }
        //
        // Transfer the handles to the subsystem responsible for this
        // process.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    ProcessInformation.Process,
                                    TargetSubSys->Process,
                                    &args->ProcessInformation.Process,
                                    PROCESS_ALL_ACCESS,
                                    0,
                                    0
                                  );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - NtDuplicateObject Failed with  Status %lx for sessionid %ld\n",
                       Status,
                       MuSessionId));

            goto cleanup;
            }

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    ProcessInformation.Thread,
                                    TargetSubSys->Process,
                                    &args->ProcessInformation.Thread,
                                    THREAD_ALL_ACCESS,
                                    0,
                                    0
                                  );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - NtDuplicateObject Failed with  Status %lx for sessionid %ld\n",
                       Status,
                       MuSessionId));

            goto cleanup;
            }

        SessionId = SmpAllocateSessionId( TargetSubSys,
                                          NULL
                                        );

        args->SessionId = SessionId;

        SbApiMsg.ApiNumber = SbCreateSessionApi;
        SbApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
        SbApiMsg.h.u1.s1.TotalLength = sizeof(SbApiMsg);
        SbApiMsg.h.u2.ZeroInit = 0L;

        Status = NtRequestWaitReplyPort(
                TargetSubSys->SbApiCommunicationPort,
                (PPORT_MESSAGE) &SbApiMsg,
                (PPORT_MESSAGE) &SbApiMsg
                );

        if (NT_SUCCESS( Status )) {
            Status = SbApiMsg.ReturnedStatus;
            }

        if (!NT_SUCCESS( Status )) {
            SmpDeleteSession( SessionId);
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - NtRequestWaitReplyPort Failed with  Status %lx for sessionid %ld\n",
                       Status,
                       MuSessionId));

            goto cleanup;
            }
        }
    else {
        if ( pWindowsSubSysProcessId ) {

            if ( *pWindowsSubSysProcessId == (ULONG_PTR)NULL ) {

                *pWindowsSubSysProcessId = (ULONG_PTR)
                    ProcessInformation.ClientId.UniqueProcess;
            }
        }
        if ( !MuSessionId ) { // Only for console
            SmpWindowsSubSysProcessId = (ULONG_PTR)
                ProcessInformation.ClientId.UniqueProcess;
            SmpWindowsSubSysProcess = ProcessInformation.Process;
        }
    }

    ASSERTMSG( "NtCreateEvent", NT_SUCCESS( Status ) );

    Status = NtResumeThread( ProcessInformation.Thread, NULL );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: SmpLoadSubSystem - NtResumeThread failed Status %lx\n",
                   Status));

        goto cleanup;
    }


    if(MuSessionId != 0) {

        //
        // Wait a max of 60 seconds for the subsystem to connect.
        //

        Timeout = RtlEnlargedIntegerMultiply( 60000, -10000 );
        Status = NtWaitForSingleObject( KnownSubSys->Active, FALSE, &Timeout );
        if ( !SmpCheckDuplicateMuSessionId( MuSessionId ) ) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SMSS: SmpLoadSubSystem - session deleted\n"));

            return( STATUS_DELETE_PENDING );
        }

        if (Status != STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpLoadSubSystem - Timeout waiting for subsystem connect with Status %lx for sessionid %ld \n",
                       Status,
                       MuSessionId));

            goto cleanup;
        }

    } else {

        NtWaitForSingleObject( KnownSubSys->Active, FALSE, NULL );

    }

    // Close this now since we never need it again
    NtClose( ProcessInformation.Thread );

    RtlEnterCriticalSection( &SmpKnownSubSysLock );
    if (KnownSubSys) {
        SmpDeferenceKnownSubSys(KnownSubSys);
    }
    if (TargetSubSys) {
        SmpDeferenceKnownSubSys(TargetSubSys);
    }
    if (CreatorSubSys) {
        SmpDeferenceKnownSubSys(CreatorSubSys);
    }
    RtlLeaveCriticalSection( &SmpKnownSubSysLock );

    return STATUS_SUCCESS;

cleanup:

    if ((AttachedSessionId != (-1))
        && !(Flags & SMP_POSIX_FLAG)
        && !(Flags & SMP_OS2_FLAG)
        && NT_SUCCESS(AcquirePrivilegeStatus = SmpAcquirePrivilege( SE_LOAD_DRIVER_PRIVILEGE, &State ))) {

        NTSTATUS St;
        //
        // If we are attached to a session space, leave it
        // so we can create a new one
        //

        if (NT_SUCCESS(St = NtSetSystemInformation(
                            SystemSessionDetach,
                            (PVOID)&AttachedSessionId,
                            sizeof(MuSessionId)
                            ))) {

            AttachedSessionId = (-1);

        } else {

            //
            // This has to succeed otherwise we will bugcheck while trying to
            // create another session
            //
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: SmpStartCsr, Couldn't Detach from Session Space. Status=%x\n",
                       St));

            ASSERT(NT_SUCCESS(St));
        }

        SmpReleasePrivilege( State );
    }
    else
    {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SMSS: Did not detach from Session Space: SessionId=%x Flags=%x Status=%x\n",
                   AttachedSessionId,
                   Flags,
                   AcquirePrivilegeStatus));
    }


    // There is a lot of cleanup that must be done here
    NtTerminateProcess( ProcessInformation.Process, Status );
    NtClose( ProcessInformation.Thread );

cleanup2:

    RtlEnterCriticalSection( &SmpKnownSubSysLock );
    if (TargetSubSys) {
        SmpDeferenceKnownSubSys(TargetSubSys);
    }
    if (CreatorSubSys) {
        SmpDeferenceKnownSubSys(CreatorSubSys);
    }
    RemoveEntryList( &KnownSubSys->Links );
    NtSetEvent( KnownSubSys->Active, NULL );
    KnownSubSys->Deleting = TRUE;
    SmpDeferenceKnownSubSys(KnownSubSys);
    RtlLeaveCriticalSection( &SmpKnownSubSysLock );

    return( Status );

}


NTSTATUS
SmpExecuteInitialCommand(
    IN ULONG MuSessionId,
    IN PUNICODE_STRING InitialCommand,
    OUT PHANDLE InitialCommandProcess,
    OUT PULONG_PTR InitialCommandProcessId
    )
{
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    ULONG Flags;
    UNICODE_STRING ImageFileName;
    UNICODE_STRING CurrentDirectory;
    UNICODE_STRING Arguments;
    static HANDLE SmApiPort = NULL;

    if ( SmApiPort == NULL ) {
        Status = SmConnectToSm( NULL,
                            NULL,
                            0,
                            &SmApiPort
                          );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to connect to SM - Status == %lx\n",
                       Status));

            return( Status );
        }
    }

    Flags = 0;
    Status = SmpParseCommandLine( InitialCommand,
                                  &Flags,
                                  &ImageFileName,
                                  &CurrentDirectory,
                                  &Arguments
                                );
    if (Flags & SMP_IMAGE_NOT_FOUND) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Initial command image (%wZ) not found\n",
                   &ImageFileName));

        if (ImageFileName.Buffer)
            RtlFreeHeap( RtlProcessHeap(), 0, ImageFileName.Buffer );
        return( STATUS_OBJECT_NAME_NOT_FOUND );
        }

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: SmpParseCommand( %wZ ) failed - Status == %lx\n",
                   InitialCommand,
                   Status));

        return( Status );
        }

    Status = SmpExecuteImage( &ImageFileName,
                              &CurrentDirectory,
                              InitialCommand,
                              MuSessionId,
                              SMP_DONT_START,
                              &ProcessInformation
                            );
    if (ImageFileName.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, ImageFileName.Buffer );
        if (CurrentDirectory.Buffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, CurrentDirectory.Buffer );
            }
        }

    if (Arguments.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Arguments.Buffer );
        }
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ProcessInformation.Process,
                                NtCurrentProcess(),
                                InitialCommandProcess,
                                PROCESS_ALL_ACCESS,
                                0,
                                0
                              );

    if (!NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: DupObject Failed. Status == %lx\n",
                   Status));

        NtTerminateProcess( ProcessInformation.Process, Status );
        NtResumeThread( ProcessInformation.Thread, NULL );
        NtClose( ProcessInformation.Thread );
        NtClose( ProcessInformation.Process );
        return( Status );
        }

    if ( InitialCommandProcessId != NULL )
        *InitialCommandProcessId =
            (ULONG_PTR)ProcessInformation.ClientId.UniqueProcess;
    if ( !MuSessionId )
        SmpInitialCommandProcessId =
            (ULONG_PTR)ProcessInformation.ClientId.UniqueProcess;
    Status = SmExecPgm( SmApiPort,
                        &ProcessInformation,
                        FALSE
                      );

    if (!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: SmExecPgm Failed. Status == %lx\n",
                   Status));

        return( Status );
        }

    return( Status );
}


void
SmpDisplayString( char *s )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitAnsiString( &AnsiString, s );

    RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );

    NtDisplayString( &UnicodeString );

    RtlFreeUnicodeString( &UnicodeString );
}

NTSTATUS
SmpLoadDeferedSubsystem(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )
{

    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PSMP_REGISTRY_VALUE p;
    UNICODE_STRING DeferedName;
    PSMLOADDEFERED args;
    ULONG MuSessionId;
    ULONG Flags;

    args = &SmApiMsg->u.LoadDefered;

    DeferedName.Length = (USHORT)args->SubsystemNameLength;
    DeferedName.MaximumLength = (USHORT)args->SubsystemNameLength;
    DeferedName.Buffer = args->SubsystemName;

    Head = &SmpSubSystemsToDefer;

    //
    // Get the pointer to the client process's Terminal Server session.
    //

    SmpGetProcessMuSessionId( CallingClient->ClientProcessHandle, &MuSessionId );
    if ( !SmpCheckDuplicateMuSessionId( MuSessionId ) ) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Defered subsystem load ( %wZ ) for MuSessionId %u, status=0x%x\n",
                   &DeferedName,
                   MuSessionId,
                   STATUS_OBJECT_NAME_NOT_FOUND));

        return( STATUS_OBJECT_NAME_NOT_FOUND );
    }

    Next = Head->Flink;
    while (Next != Head ) {
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
        if ( RtlEqualUnicodeString(&DeferedName,&p->Name,TRUE)) {

            //
            // This is it. Load the subsystem...
            //
            // To keep from loading multiple subsystems, we must
            // flag the type so we can see if its running.
            // This is only a problem with "Optional" subsystems.
            // Other optional subsystems can still be added, but
            // they may have startup race conditions.
            //

            Flags = SMP_SUBSYSTEM_FLAG;

            if ( RtlEqualUnicodeString(&DeferedName,&PosixName,TRUE)) {
                Flags |= SMP_POSIX_FLAG;
            }

            if ( RtlEqualUnicodeString(&DeferedName,&Os2Name,TRUE)) {
                Flags |= SMP_OS2_FLAG;
            }

            if (RegPosixSingleInstance &&
                RtlEqualUnicodeString(&DeferedName,&PosixName,TRUE)) {
                Flags |= SMP_POSIX_SI_FLAG;
            }

            Status = SmpExecuteCommand( &p->Value, MuSessionId, NULL, Flags );

            return Status;

            }
        Next = Next->Flink;
        }

    return STATUS_OBJECT_NAME_NOT_FOUND;
}


NTSTATUS
SmpConfigureProtectionMode(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This function is a dispatch routine for the QueryRegistry call
    (see SmpRegistryConfigurationTable[] earlier in this file).

    The purpose of this routine is to read the Base Object Protection
    Mode out of the registry.  This information is kept in

    Key Name: \\Hkey_Local_Machine\System\CurrentControlSet\SessionManager
    Value:    ProtectionMode [REG_DWORD]

    The value is a flag word, with the following flags defined:

        SMP_NO_PROTECTION  - No base object protection
        SMP_STANDARD_PROTECTION - Apply standard base
            object protection

    This information will be placed in the global variable
    SmpProtectionMode.

    No value, or an invalid value length or type results in no base
    object protection being applied.

Arguments:

    None.

Return Value:


--*/
{


#if SMP_SHOW_REGISTRY_DATA
    SmpDumpQuery( L"SMSS", "BaseObjectsProtection", ValueName, ValueType, ValueData, ValueLength );
#else
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( ValueType );
#endif



    if (ValueLength != sizeof(ULONG)) {

        //
        // Key value not valid. Run protected
        //

        SmpProtectionMode = SMP_STANDARD_PROTECTION;

    } else {


        SmpProtectionMode = (*((PULONG)(ValueData)));

        //
        // Change the security descriptors
        //

    }
    (VOID)SmpCreateSecurityDescriptors( FALSE );

    return( STATUS_SUCCESS );
}


NTSTATUS
SmpConfigureAllowProtectedRenames(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    if (ValueLength != sizeof(ULONG)) {
        SmpAllowProtectedRenames = 0;
    } else {
        SmpAllowProtectedRenames = (*((PULONG)(ValueData)));
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
SmpCreateSecurityDescriptors(
    IN BOOLEAN InitialCall
    )

/*++

Routine Description:

    This function allocates and initializes security descriptors
    used in SM.

    The security descriptors include:

        SmpPrimarySecurityDescriptor - (global variable) This is
            used to assign protection to objects created by
            SM that need to be accessed by others, but not modified.
            This descriptor grants the following access:

                    Grant:  World:   Execute | Read  (Inherit)
                    Grant:  Restricted:   Execute | Read (Inherit)
                    Grant:  Admin:   All Access      (Inherit)
                    Grant:  Owner:   All Access      (Inherit Only)

        SmpLiberalSecurityDescriptor = (globalVariable) This is used
            to assign protection objects created by SM that need
            to be modified by others (such as writing to a shared
            memory section).
            This descriptor grants the following access:

                    Grant:  World:   Execute | Read | Write (Inherit)
                    Grant:  Restricted: Execute | Read | Write (Inherit)
                    Grant:  Admin:   All Access             (Inherit)
                    Grant:  Owner:   All Access             (Inherit Only)

        SmpKnownDllsSecurityDescriptor = (globalVariable) This is used
            to assign protection to the \KnownDlls object directory.
            This descriptor grants the following access:

                    Grant:  World:   Execute                (No Inherit)
                    Grant:  Restricted: Execute             (No Inherit)
                    Grant:  Admin:   All Access             (Inherit)
                    Grant:  World:   Execute | Read | Write (Inherit Only)
                    Grant:  Restricted: Execute | Read | Write (Inherit Only)


        Note that System is an administrator, so granting Admin an
        access also grants System that access.

Arguments:

    InitialCall - Indicates whether this routine is being called for
        the first time, or is being called to change the security
        descriptors as a result of a protection mode change.

            TRUE - being called for first time.
            FALSE - being called a subsequent time.

    (global variables:  SmpBaseObjectsUnprotected)

Return Value:

    STATUS_SUCCESS - The security descriptor(s) have been allocated
        and initialized.

    STATUS_NO_MEMORY - couldn't allocate memory for a security
        descriptor.

--*/

{
    NTSTATUS
        Status;

    PSID
        WorldSid = NULL,
        AdminSid = NULL,
        LocalSystemSid = NULL,
        RestrictedSid = NULL,
        OwnerSid = NULL;

    SID_IDENTIFIER_AUTHORITY
        WorldAuthority = SECURITY_WORLD_SID_AUTHORITY,
        NtAuthority = SECURITY_NT_AUTHORITY,
        CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    ACCESS_MASK
        AdminAccess = (GENERIC_ALL),
        WorldAccess  = (GENERIC_EXECUTE | GENERIC_READ),
        OwnerAccess  = (GENERIC_ALL),
        RestrictedAccess = (GENERIC_EXECUTE | GENERIC_READ);

    UCHAR
        InheritOnlyFlags = (OBJECT_INHERIT_ACE           |
                               CONTAINER_INHERIT_ACE     |
                               INHERIT_ONLY_ACE);

    ULONG
        AceIndex,
        AclLength;

    PACL
        Acl;

    PACE_HEADER
        Ace;

    BOOLEAN
        ProtectionRequired = FALSE;


    if (InitialCall) {

        //
        // Now init the security descriptors for no protection.
        // If told to, we will change these to have protection.
        //

        // Primary

        SmpPrimarySecurityDescriptor = &SmpPrimarySDBody;
        Status = RtlCreateSecurityDescriptor (
                    SmpPrimarySecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
        ASSERT( NT_SUCCESS(Status) );
#pragma prefast(suppress: 248, "Protection enabled via registry")
        Status = RtlSetDaclSecurityDescriptor (
                     SmpPrimarySecurityDescriptor,
                     TRUE,                  //DaclPresent,
                     NULL,                  //Dacl (no protection)
                     FALSE                  //DaclDefaulted OPTIONAL
                     );
        ASSERT( NT_SUCCESS(Status) );


        // Liberal

        SmpLiberalSecurityDescriptor = &SmpLiberalSDBody;
        Status = RtlCreateSecurityDescriptor (
                    SmpLiberalSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
        ASSERT( NT_SUCCESS(Status) );
#pragma prefast(suppress: 248, "Protection enabled via registry")
        Status = RtlSetDaclSecurityDescriptor (
                     SmpLiberalSecurityDescriptor,
                     TRUE,                  //DaclPresent,
                     NULL,                  //Dacl (no protection)
                     FALSE                  //DaclDefaulted OPTIONAL
                     );
        ASSERT( NT_SUCCESS(Status) );

        // KnownDlls

        SmpKnownDllsSecurityDescriptor = &SmpKnownDllsSDBody;
        Status = RtlCreateSecurityDescriptor (
                    SmpKnownDllsSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
        ASSERT( NT_SUCCESS(Status) );
#pragma prefast(suppress: 248, "Protection enabled via registry")
        Status = RtlSetDaclSecurityDescriptor (
                     SmpKnownDllsSecurityDescriptor,
                     TRUE,                  //DaclPresent,
                     NULL,                  //Dacl (no protection)
                     FALSE                  //DaclDefaulted OPTIONAL
                     );
        ASSERT( NT_SUCCESS(Status) );

        // ApiPort

        SmpApiPortSecurityDescriptor = &SmpApiPortSDBody;
        Status = RtlCreateSecurityDescriptor (
                    SmpApiPortSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
        ASSERT( NT_SUCCESS(Status) );
#pragma prefast(suppress: 248, "Protection enabled via registry")
        Status = RtlSetDaclSecurityDescriptor (
                     SmpApiPortSecurityDescriptor,
                     TRUE,                  //DaclPresent,
                     NULL,                  //Dacl
                     FALSE                  //DaclDefaulted OPTIONAL
                     );
        ASSERT( NT_SUCCESS(Status) );
    }



    if ((SmpProtectionMode & SMP_PROTECTION_REQUIRED) != 0) {
        ProtectionRequired = TRUE;
    }

    if (!InitialCall && !ProtectionRequired) {
        return(STATUS_SUCCESS);
    }



    if (InitialCall || ProtectionRequired) {

        //
        // We need to set up the ApiPort protection, and maybe
        // others.
        //

        Status = RtlAllocateAndInitializeSid (&WorldAuthority,
                                              1,
                                              SECURITY_WORLD_RID,
                                              0, 0, 0, 0, 0, 0, 0,
                                              &WorldSid);

        if (!NT_SUCCESS (Status)) {
            WorldSid = NULL;
            goto exit_and_free;
        }

        Status = RtlAllocateAndInitializeSid (&NtAuthority,
                                              2,
                                              SECURITY_BUILTIN_DOMAIN_RID,
                                              DOMAIN_ALIAS_RID_ADMINS,
                                              0, 0, 0, 0, 0, 0,
                                              &AdminSid);

        if (!NT_SUCCESS (Status)) {
            AdminSid = NULL;
            goto exit_and_free;
        }


        Status = RtlAllocateAndInitializeSid (&CreatorAuthority,
                                              1,
                                              SECURITY_CREATOR_OWNER_RID,
                                              0, 0, 0, 0, 0, 0, 0,
                                              &OwnerSid);

        if (!NT_SUCCESS (Status)) {
            OwnerSid = NULL;
            goto exit_and_free;
        }

        Status = RtlAllocateAndInitializeSid (&NtAuthority,
                                              1,
                                              SECURITY_RESTRICTED_CODE_RID,
                                              0, 0, 0, 0, 0, 0, 0,
                                              &RestrictedSid);

        if (!NT_SUCCESS (Status)) {
            RestrictedSid = NULL;
            goto exit_and_free;
        }

        Status = RtlAllocateAndInitializeSid (&NtAuthority,
                                              1,
                                              SECURITY_LOCAL_SYSTEM_RID,
                                              0, 0, 0, 0, 0, 0, 0,
                                              &LocalSystemSid);

        if (!NT_SUCCESS (Status)) {
            LocalSystemSid = NULL;
            goto exit_and_free;
        }


        //
        // Build the ApiPort security descriptor only
        // if this is the initial call
        //

        if (InitialCall) {

            AdminAccess = GENERIC_ALL;

            AclLength = sizeof( ACL )                       +
                        2 * sizeof( ACCESS_ALLOWED_ACE )    +
                        RtlLengthSid( LocalSystemSid )      +
                        RtlLengthSid( AdminSid );

            Acl = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), AclLength );

            if (Acl == NULL) {
                Status = STATUS_NO_MEMORY;
            }

            if (NT_SUCCESS(Status)) {

                //
                // Create the ACL, then add each ACE
                //

                Status = RtlCreateAcl (Acl, AclLength, ACL_REVISION2 );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Only Non-inheritable ACEs in this ACL
                //      Admin
                //


                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );

                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, LocalSystemSid );
                ASSERT( NT_SUCCESS(Status) );


                Status = RtlSetDaclSecurityDescriptor (SmpApiPortSecurityDescriptor,
                                                       TRUE,                  //DaclPresent,
                                                       Acl,                   //Dacl
                                                       FALSE);                //DaclDefaulted OPTIONAL
                ASSERT( NT_SUCCESS(Status) );
            }

            //
            // Build the KnownDlls security descriptor
            //


            AdminAccess = GENERIC_ALL;

            AclLength = sizeof( ACL )                    +
                        6 * sizeof( ACCESS_ALLOWED_ACE ) +
                        (2*RtlLengthSid( WorldSid ))     +
                        (2*RtlLengthSid( RestrictedSid ))+
                        (2*RtlLengthSid( AdminSid ));

            Acl = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), AclLength );

            if (Acl == NULL) {
                Status = STATUS_NO_MEMORY;
            }

            if (NT_SUCCESS(Status)) {

                //
                // Create the ACL
                //

                Status = RtlCreateAcl (Acl, AclLength, ACL_REVISION2 );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Add the non-inheritable ACEs first
                //      World
                //      Restricted
                //      Admin
                //

                AceIndex = 0;
                WorldAccess  = GENERIC_EXECUTE;
                RestrictedAccess = GENERIC_EXECUTE;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Put the inherit only ACEs at at the end
                //      World
                //      Restricted
                //      Admin
                //

                AceIndex++;
                WorldAccess  = GENERIC_EXECUTE | GENERIC_READ | GENERIC_WRITE;
                RestrictedAccess = GENERIC_EXECUTE | GENERIC_READ | GENERIC_WRITE;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;


                //
                // Put the Acl in the security descriptor
                //

                Status = RtlSetDaclSecurityDescriptor (SmpKnownDllsSecurityDescriptor,
                                                       TRUE,                  //DaclPresent,
                                                       Acl,                   //Dacl
                                                       FALSE);                //DaclDefaulted OPTIONAL
                ASSERT( NT_SUCCESS(Status) );
            }


        }


        //
        // The remaining security descriptors are only
        // built if we are running with the correct in
        // protection mode set.  Notice that we only
        // put protection on if standard protection is
        // also specified.   Otherwise, there is no protection
        // on the objects, and nothing should fail.
        //

        if (SmpProtectionMode & SMP_STANDARD_PROTECTION) {

            //
            // Build the primary Security descriptor
            //

            WorldAccess  = GENERIC_EXECUTE | GENERIC_READ;
            RestrictedAccess = GENERIC_EXECUTE | GENERIC_READ;
            AdminAccess  = GENERIC_ALL;
            OwnerAccess  = GENERIC_ALL;

            AclLength = sizeof( ACL )                       +
                        7 * sizeof( ACCESS_ALLOWED_ACE )    +
                        (2*RtlLengthSid( WorldSid ))        +
                        (2*RtlLengthSid( RestrictedSid ))   +
                        (2*RtlLengthSid( AdminSid ))        +
                        RtlLengthSid( OwnerSid );

            Acl = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), AclLength );

            if (Acl == NULL) {
                Status = STATUS_NO_MEMORY;
            }

            if (NT_SUCCESS(Status)) {

                //
                // Create the ACL, then add each ACE
                //

                Status = RtlCreateAcl (Acl, AclLength, ACL_REVISION2 );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Non-inheritable ACEs first
                //      World
                //      Restricted
                //      Admin
                //

                AceIndex = 0;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Inheritable ACEs at end of ACE
                //      World
                //      Restricted
                //      Admin
                //      Owner

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, OwnerAccess, OwnerSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;



                Status = RtlSetDaclSecurityDescriptor (
                                             SmpPrimarySecurityDescriptor,
                                             TRUE,                  //DaclPresent,
                                             Acl,                   //Dacl
                                             FALSE                  //DaclDefaulted OPTIONAL
                                             );
                ASSERT( NT_SUCCESS(Status) );
            }

            //
            // Build the liberal security descriptor
            //


            AdminAccess = GENERIC_ALL;
            WorldAccess  = GENERIC_EXECUTE | GENERIC_READ | GENERIC_WRITE;
            RestrictedAccess = GENERIC_EXECUTE | GENERIC_READ | GENERIC_WRITE;

            AclLength = sizeof( ACL )                    +
                        7 * sizeof( ACCESS_ALLOWED_ACE ) +
                        (2*RtlLengthSid( WorldSid ))     +
                        (2*RtlLengthSid( RestrictedSid ))+
                        (2*RtlLengthSid( AdminSid ))     +
                        RtlLengthSid( OwnerSid );

            Acl = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), AclLength );

            if (Acl == NULL) {
                Status = STATUS_NO_MEMORY;
            }

            if (NT_SUCCESS(Status)) {

                //
                // Create the ACL
                //

                Status = RtlCreateAcl (Acl, AclLength, ACL_REVISION2 );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Add the non-inheritable ACEs first
                //      World
                //      Restricted
                //      Admin
                //

                AceIndex = 0;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );

                //
                // Put the inherit only ACEs at at the end
                //      World
                //      Restricted
                //      Admin
                //      Owner
                //

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, WorldAccess, WorldSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, AdminAccess, AdminSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;

                AceIndex++;
                Status = RtlAddAccessAllowedAce ( Acl, ACL_REVISION2, OwnerAccess, OwnerSid );
                ASSERT( NT_SUCCESS(Status) );
                Status = RtlGetAce( Acl, AceIndex, (PVOID)&Ace );
                ASSERT( NT_SUCCESS(Status) );
                Ace->AceFlags = InheritOnlyFlags;


                //
                // Put the Acl in the security descriptor
                //

                Status = RtlSetDaclSecurityDescriptor (SmpLiberalSecurityDescriptor,
                                                       TRUE,                  //DaclPresent,
                                                       Acl,                   //Dacl
                                                       FALSE);                //DaclDefaulted OPTIONAL
                ASSERT( NT_SUCCESS(Status) );
            }
        }
    }

exit_and_free:

    if (OwnerSid != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, OwnerSid );
    }

    if (AdminSid != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, AdminSid );
    }

    if (WorldSid != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, WorldSid );
    }

    if (LocalSystemSid != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, LocalSystemSid );
    }

    if (RestrictedSid != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, RestrictedSid );
    }

    return( Status );

}

VOID
SmpTranslateSystemPartitionInformation( VOID )

/*++

Routine Description:

    This routine translates the NT device path for the system partition (stored
    during IoInitSystem) into a DOS path, and stores the resulting REG_SZ 'BootDir'
    value under HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    UCHAR ValueBuffer[ VALUE_BUFFER_SIZE ];
    ULONG ValueLength;
    UNICODE_STRING SystemPartitionString;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UCHAR DirInfoBuffer[ sizeof(OBJECT_DIRECTORY_INFORMATION) + (256 + sizeof("SymbolicLink")) * sizeof(WCHAR) ];
    UNICODE_STRING LinkTypeName;
    BOOLEAN RestartScan;
    ULONG Context;
    HANDLE SymbolicLinkHandle;
    WCHAR UnicodeBuffer[ MAXIMUM_FILENAME_LENGTH ];
    UNICODE_STRING LinkTarget;


    //
    // Retrieve 'SystemPartition' value stored under HKLM\SYSTEM\Setup
    //

    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\System\\Setup");
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't open system setup key for reading: 0x%x\n",
                   Status));

        return;
    }

    RtlInitUnicodeString(&UnicodeString, L"SystemPartition");
    Status = NtQueryValueKey(Key,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             sizeof(ValueBuffer),
                             &ValueLength
                            );

    NtClose(Key);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't query SystemPartition value: 0x%x\n",
                   Status));

        return;
    }

    RtlInitUnicodeString(&SystemPartitionString,
                         (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer)->Data)
                        );

    //
    // Next, examine objects in the DosDevices directory, looking for one that's a symbolic link
    // to the system partition.
    //

    LinkTarget.Buffer = UnicodeBuffer;

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;
    RestartScan = TRUE;
    RtlInitUnicodeString(&LinkTypeName, L"SymbolicLink");


    while (TRUE) {

        Status = NtQueryDirectoryObject(SmpDosDevicesObjectDirectory,
                                        DirInfo,
                                        sizeof(DirInfoBuffer),
                                        TRUE,
                                        RestartScan,
                                        &Context,
                                        NULL
                                       );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        if (RtlEqualUnicodeString(&DirInfo->TypeName, &LinkTypeName, TRUE) &&
            (DirInfo->Name.Length == 2 * sizeof(WCHAR)) &&
            (DirInfo->Name.Buffer[1] == L':')) {

            //
            // We have a drive letter--check the NT device name it's linked to.
            //

            InitializeObjectAttributes(&ObjectAttributes,
                                       &DirInfo->Name,
                                       OBJ_CASE_INSENSITIVE,
                                       SmpDosDevicesObjectDirectory,
                                       NULL
                                      );

            Status = NtOpenSymbolicLinkObject(&SymbolicLinkHandle,
                                              SYMBOLIC_LINK_ALL_ACCESS,
                                              &ObjectAttributes
                                             );

            if (NT_SUCCESS(Status)) {

                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof(UnicodeBuffer);

                Status = NtQuerySymbolicLinkObject(SymbolicLinkHandle,
                                                   &LinkTarget,
                                                   NULL
                                                  );
                NtClose(SymbolicLinkHandle);

                //
                // The last part of the test below handles the remote boot case,
                // where the system partition is on a redirected drive.
                //

                if (NT_SUCCESS(Status) &&
                     ( RtlEqualUnicodeString(&SystemPartitionString, &LinkTarget, TRUE)
                        || (RtlPrefixUnicodeString(&SystemPartitionString, &LinkTarget, TRUE)
                             && (LinkTarget.Buffer[SystemPartitionString.Length / sizeof(WCHAR)] == L'\\')) )
                   ) {

                     //
                     // We've found the drive letter corresponding to the system partition.
                     //
                     break;
                }
            }
        }

        RestartScan = FALSE;
    }


    if (!NT_SUCCESS(Status)) {
#if defined (_WIN64)
        if (Status == STATUS_NO_MORE_ENTRIES) {
            DirInfo->Name.Buffer = (PWCHAR)(DirInfo+1);
            DirInfo->Name.Buffer[0] = USER_SHARED_DATA->NtSystemRoot[0];
            DirInfo->Name.Buffer[1] = USER_SHARED_DATA->NtSystemRoot[1];
        } else {
#endif
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't find drive letter for system partition\n"));        
        return;
#if defined (_WIN64)
        }
#endif
    }

    //
    // Now write out the DOS path for the system partition to
    // HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup
    //

    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: can't open software setup key for writing: 0x%x\n",
                   Status));

        return;
    }

    wcsncpy(UnicodeBuffer, DirInfo->Name.Buffer, 2);
    UnicodeBuffer[2] = L'\\';
    UnicodeBuffer[3] = L'\0';

    RtlInitUnicodeString(&UnicodeString, L"BootDir");

    Status = NtSetValueKey(Key,
                           &UnicodeString,
                           0,
                           REG_SZ,
                           UnicodeBuffer,
                           4 * sizeof(WCHAR)
                          );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: couldn't write BootDir value: 0x%x\n",
                   Status));
    }

    NtClose(Key);
}

#if defined(REMOTE_BOOT)
NTSTATUS
SmpExecuteCommandLineArguments( VOID )

/*++

Routine Description:

    This routine processes any command line arguments that were passed to SMSS.exe.
    Currently the only valid ones are netboot commands.

Arguments:

    None.

Return Value:

    Success or not.

--*/

{
    UNICODE_STRING CfgFileName;
    UNICODE_STRING MbrName;
    UNICODE_STRING AutoFmtCmd;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES KeyObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    NTSTATUS Status;
    ULONG BootSerialNumber;
    ULONG DiskSignature;
    ULONG CmdFlags;
    ULONG Length;
    LARGE_INTEGER ByteOffset;
    PUCHAR AlignedBuffer;
    ON_DISK_MBR OnDiskMbr;
    BOOLEAN WasEnabled;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    ULONG Repartition;
    ULONG Disk;
    ULONG Partition;
    ULONG CSCPartition;
    PWCHAR pWchar;

    if (!SmpNetboot || SmpNetbootDisconnected) {
        return STATUS_SUCCESS;
    }

    //
    // Open the remoteboot.cfg file
    //

    RtlInitUnicodeString(&UnicodeString, L"\\SystemRoot");

    InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );

    Status = NtOpenSymbolicLinkObject(&FileHandle,
                                      (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                      &ObjectAttributes
                                     );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Could not open symbolic link (Status 0x%x) -- quitting.\n",
                   Status));

        Status = STATUS_SUCCESS;
        goto CleanUp;
    }

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = sizeof(TmpBuffer);
    UnicodeString.Buffer = (PWCHAR)TmpBuffer;
    Status = NtQuerySymbolicLinkObject(FileHandle,
                                       &UnicodeString,
                                       NULL
                                      );

    NtClose(FileHandle);
    FileHandle = NULL;

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Could not get symbolic link name (Status 0x%x) -- quitting.\n",
                   Status));

        Status = STATUS_SUCCESS;
        goto CleanUp;
    }

    ASSERT(((wcslen((PWCHAR)TmpBuffer) * sizeof(WCHAR)) - sizeof(L"BootDrive")) <
           (sizeof(wszRemoteBootCfgFile) - sizeof(REMOTE_BOOT_CFG_FILE))
          );

    wcscpy(wszRemoteBootCfgFile, (PWCHAR)TmpBuffer);

    pWchar = wcsstr(wszRemoteBootCfgFile, L"BootDrive");
    ASSERT(pWchar != NULL);
    *pWchar = UNICODE_NULL;

    wcscat(wszRemoteBootCfgFile, REMOTE_BOOT_CFG_FILE);

    CfgFileName.Length = wcslen(wszRemoteBootCfgFile) * sizeof(WCHAR);
    CfgFileName.MaximumLength = sizeof(wszRemoteBootCfgFile);
    CfgFileName.Buffer = wszRemoteBootCfgFile;

    InitializeObjectAttributes(
       &ObjectAttributes,
       &CfgFileName,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );

    Status = NtOpenFile( &FileHandle,
                         GENERIC_WRITE | GENERIC_READ | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS
                       );

    //
    // If it does not exist, then set the flags for reformatting and repinning.
    //
    if (!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Could not open file (status 0x%x) -- creating it.\n",
                   Status));

        //
        // Create the remoteboot.cfg in the system32\config directory if it does not exist.
        //

CreateFile:

        Status = NtCreateFile( &FileHandle,
                               GENERIC_WRITE | GENERIC_READ | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_HIDDEN,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OVERWRITE_IF,
                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS,
                               NULL,
                               0
                             );

        if (!NT_SUCCESS(Status)) {
            //
            // Something is really wrong, we will just exit and hope all is good.
            // DEADISSUE, HISTORICAL CODE ONLY: This OK?
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Could not create file (Status 0x%x) -- quitting.\n",
                       Status));

            Status = STATUS_SUCCESS;
            goto CleanUp;
        }

        SmpAutoFormat = TRUE;
        BootSerialNumber = 1;

    } else {

        Status = NtReadFile( FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             &BootSerialNumber,
                             sizeof(ULONG),
                             NULL,
                             NULL
                           );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Could not read file (Status 0x%x) -- creating it.\n",
                       Status));

            NtClose( FileHandle );
            goto CreateFile;
        }

        BootSerialNumber++;
    }



    //
    // Process each command
    //
    if (SmpAutoFormat) {

        //
        // Read from the registry if it is ok to reformat, or just leave the disk alone.
        //
        Repartition = 1;

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\RemoteBoot");

        InitializeObjectAttributes(&KeyObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&Key, KEY_READ, &KeyObjectAttributes);

        if (NT_SUCCESS(Status)) {

            //
            // Query the key value.
            //
            RtlInitUnicodeString(&UnicodeString, L"Repartition");
            Status = NtQueryValueKey(Key,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     (PVOID)KeyValueInfo,
                                     sizeof (ValueBuffer),
                                     &ValueLength);

            if (NT_SUCCESS(Status)) {
                ASSERT(ValueLength <= VALUE_BUFFER_SIZE);
                Repartition = *((PULONG)KeyValueInfo->Data);
            }

            NtClose(Key);
        }

        SmpGetHarddiskBootPartition(&Disk, &Partition);

        if (Repartition) {

            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SMSS: Autoformatting local disk.\n"));

            NtClose(FileHandle);

            //
            // Repartition the disk.
            //
            SmpPartitionDisk(Disk, &Partition);

            //
            // Call autoformat on the partition
            //
            swprintf((PWSTR)TmpBuffer,
                     L"autoformat autofmt \\Device\\Harddisk%d\\Partition%d /Q /fs:ntfs",
                     Disk,
                     Partition
                    );
            AutoFmtCmd.Buffer = (PWSTR)TmpBuffer;
            AutoFmtCmd.MaximumLength = sizeof(TmpBuffer);
            AutoFmtCmd.Length = wcslen((PWSTR)TmpBuffer) * sizeof(WCHAR);
            CmdFlags = 0;

            Status = SmpExecuteCommand(&AutoFmtCmd, 0, NULL, CmdFlags);

            if (!NT_SUCCESS(Status)) {
                //
                // Big Trouble....
                // CSC is disabled if we get here, so just keep on booting.
                //
                Status = STATUS_SUCCESS;
                goto CleanUp;
            }

        } else {

            SmpFindCSCPartition(Disk, &CSCPartition);

            if (CSCPartition != 0) {
                //
                // Just blow away the CSC directory so we can refresh it
                //
                swprintf((PWSTR)TmpBuffer,
                         L"\\Device\\Harddisk%d\\Partition%d%ws",
                         Disk,
                         CSCPartition,
                         REMOTE_BOOT_IMIRROR_PATH_W REMOTE_BOOT_CSC_SUBDIR_W
                        );

                SmpEnumFilesRecursive(
                    (PWSTR)TmpBuffer,
                    SmpDelEnumFile,
                    &Status,
                    NULL
                    );

                if (!NT_SUCCESS(Status)) {
                    //
                    // Ignore this error, and hope that the next boot will fix.  Just keep booting this
                    // time and hope.
                    //
                    Status = STATUS_SUCCESS;
                    goto CleanUp;
                }

            }

        }

        //
        // Copy the NtLdr to the local disk
        //
        SourceHandle = SmpOpenDir( TRUE, TRUE, L"\\" );
        if (SourceHandle == NULL) {
            Status = STATUS_SUCCESS;
            goto CleanUp;
        }


        swprintf((PWSTR)TmpBuffer,
                 L"\\Device\\Harddisk%d\\Partition%d",
                 Disk,
                 Partition
                );

        RtlInitUnicodeString(&UnicodeString, (PWSTR)TmpBuffer);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        Status = NtCreateFile( &TargetHandle,
                               GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0
                             );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to open a handle to the (%ws) directory - Status == %lx\n",
                       UnicodeString.Buffer,
                       Status));

            Status = STATUS_SUCCESS;
            NtClose(SourceHandle);
            goto CleanUp;
        }

        //
        // If any of the copies fail, there is nothing we can really do.
        //
        RtlInitUnicodeString(&UnicodeString, L"ntldr");
        Status = SmpCopyFile(SourceHandle, TargetHandle, &UnicodeString);

        RtlInitUnicodeString(&UnicodeString, L"boot.ini");
        Status = SmpCopyFile(SourceHandle, TargetHandle, &UnicodeString);

        RtlInitUnicodeString(&UnicodeString, L"bootfont.bin");
        Status = SmpCopyFile(SourceHandle, TargetHandle, &UnicodeString);

        RtlInitUnicodeString(&UnicodeString, L"ntdetect.com");
        Status = SmpCopyFile(SourceHandle, TargetHandle, &UnicodeString);

        NtClose(SourceHandle);
        NtClose(TargetHandle);

        //
        // Read Master Boot Record and get disk serial number.
        //

        swprintf((PWSTR)TmpBuffer,
                 L"\\Device\\Harddisk%d\\Partition0",
                 Disk
                );


        MbrName.Buffer = (PWSTR)TmpBuffer;
        MbrName.MaximumLength = (wcslen((PWSTR)TmpBuffer) + 1) * sizeof(WCHAR);
        MbrName.Length = MbrName.MaximumLength - sizeof(WCHAR);

        InitializeObjectAttributes(
           &ObjectAttributes,
           &MbrName,
           OBJ_CASE_INSENSITIVE,
           NULL,
           NULL
           );

        Status = NtCreateFile( &FileHandle,
                               GENERIC_READ | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0
                             );

        if (!NT_SUCCESS(Status)) {
            //
            // Something iswrong, but we are running w/o caching, so it should be ok.
            //
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Could not create file (Status 0x%x).\n",
                       Status));

            Status = STATUS_SUCCESS;
            goto CleanUp;
        }

        ASSERT(sizeof(ON_DISK_MBR) == 512);
        AlignedBuffer = ALIGN(TmpBuffer, 512);

        Status = NtReadFile( FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             AlignedBuffer,
                             sizeof(ON_DISK_MBR),
                             NULL,
                             NULL
                           );

        NtClose( FileHandle );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Could not read file (Status 0x%x) -- creating it.\n",
                       Status));

            goto CreateFile;
        }

        RtlCopyMemory(&OnDiskMbr,AlignedBuffer,sizeof(ON_DISK_MBR));

        ASSERT(U_USHORT(OnDiskMbr.AA55Signature) == 0xAA55);

        DiskSignature = U_ULONG(OnDiskMbr.NTFTSignature);

        InitializeObjectAttributes(
           &ObjectAttributes,
           &CfgFileName,
           OBJ_CASE_INSENSITIVE,
           NULL,
           NULL
           );

        Status = NtOpenFile( &FileHandle,
                             GENERIC_WRITE | GENERIC_READ | SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS
                           );

        if (!NT_SUCCESS(Status)) {
            //
            // Big Trouble....
            // CSC is disabled if we get here, so just keep on booting.
            //

            Status = STATUS_SUCCESS;
            goto CleanUp;
        }

    }


    //
    // Update the information
    //
    ByteOffset.LowPart = 0;
    ByteOffset.HighPart = 0;

    NtWriteFile( FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &BootSerialNumber,
                 sizeof(ULONG),
                 &ByteOffset,
                 NULL
               );

    if (SmpAutoFormat) {
        ByteOffset.LowPart = sizeof(ULONG);

        NtWriteFile( FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     &DiskSignature,
                     sizeof(DiskSignature),
                     &ByteOffset,
                     NULL
                   );
    }

    ByteOffset.LowPart = sizeof(ULONG) + sizeof(ULONG);

    NtWriteFile( FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 SmpHalName,
                 sizeof(SmpHalName),
                 &ByteOffset,
                 NULL
               );

    NtClose(FileHandle);

    if (SmpAutoFormat) {

        //
        // Reboot the machine to start CSC
        //
        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     TRUE,
                                     &WasEnabled
                                   );

        if (Status == STATUS_NO_TOKEN) {

            //
            // No thread token, use the process token
            //

            Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                         (BOOLEAN)TRUE,
                                         FALSE,
                                         &WasEnabled
                                       );
            }
        NtShutdownSystem(ShutdownReboot);
    }

    Status = STATUS_SUCCESS;

CleanUp:

    return Status;
}


ENUMFILESRESULT
SmpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
{
    RECURSION_DATA RecursionData;

    RecursionData.OptionalPtr = p1;
    RecursionData.EnumProc    = EnumFilesProc;

    return SmpEnumFiles(
                DirName,
                SmppRecursiveEnumProc,
                ReturnData,
                &RecursionData
                );
}


BOOLEAN
SmppRecursiveEnumProc (
    IN  PWSTR                      DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )
{
    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    NTSTATUS        Status;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    PRECURSION_DATA RecursionData;

    RecursionData = (PRECURSION_DATA) Param;

    //
    // Build the full file or dir path
    //

    temp = (PWSTR)(TmpBuffer + (sizeof(TmpBuffer)/2));
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp, FileInfo->FileName, Len);
    temp[Len] = 0;

    wcscpy((PWSTR)TmpBuffer, DirName);
    SmpConcatenatePaths((PWSTR)TmpBuffer, temp);


    //
    // For directories, recurse
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;

        } else {
            //
            // Recurse through subdirectory
            //

            FullPath = RtlAllocateHeap(RtlProcessHeap(),
                                       MAKE_TAG( INIT_TAG ),
                                       (wcslen((PWSTR)TmpBuffer)+1) * sizeof(WCHAR)
                                      );
            if (FullPath == NULL) {
                *ret = EnumFileError;
                return FALSE;
            }

            wcscpy(FullPath, (PWSTR)TmpBuffer);

            EnumResult = SmpEnumFilesRecursive (
                                FullPath,
                                RecursionData->EnumProc,
                                &ReturnData,
                                RecursionData->OptionalPtr
                                );

            RtlFreeHeap( RtlProcessHeap(), 0, FullPath );

            if (EnumResult != NormalReturn) {
                *ret = EnumResult;
                return FALSE;
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    return b;
}


VOID
SmpConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2
    )
{
    BOOLEAN NeedBackslash = TRUE;
    ULONG l = wcslen(Path1);

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == L'\\')) {

        NeedBackslash = FALSE;
    }

    if(*Path2 == L'\\') {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    if(NeedBackslash) {
        wcscat(Path1,L"\\");
    }
    wcscat(Path1,Path2);
}

BOOLEAN
SmpDelEnumFile(
    IN  PWSTR                      DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
{
    PWSTR FileName;
    PWSTR p;
    UNICODE_STRING UnicodeString;

    //
    // Ignore subdirectories
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;    // continue processing
    }

    //
    // We have to make a copy of the filename, because the info struct
    // we get isn't NULL-terminated.
    //
    FileName = RtlAllocateHeap(RtlProcessHeap(),
                               MAKE_TAG( INIT_TAG ),
                               FileInfo->FileNameLength + sizeof(WCHAR)
                              );
    if (FileName == NULL) {
        *ret = EnumFileError;
        return TRUE;
    }

    wcsncpy(FileName, FileInfo->FileName, FileInfo->FileNameLength);

    FileName[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Point to temporary buffer for pathname.
    //
    p = (PWSTR)TmpBuffer;

    //
    // Build up the full name of the file to delete.
    //
    wcscpy(p,DirName);
    SmpConcatenatePaths(p,FileName);

    //
    // Prepare to open the file.
    //
    RtlInitUnicodeString(&UnicodeString, p);

    //
    // Ignore return status of delete
    //
    SmpDeleteFile(&UnicodeString);

    RtlFreeHeap( RtlProcessHeap(), 0, FileName );

    return TRUE;    // continue processing
}

ENUMFILESRESULT
SmpEnumFiles(
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
/*++

Routine Description:

    This routine processes every file (and subdirectory) in the directory
    specified by 'DirName'. Each entry is sent to the callback function
    'EnumFilesProc' for processing.  If the callback returns TRUE, processing
    continues, otherwise processing terminates.

Arguments:

    DirName       - Supplies the directory name containing the files/subdirectories
                    to be processed.

    EnumFilesProc - Callback function to be called for each file/subdirectory.
                    The function must have the following prototype:

                    BOOLEAN EnumFilesProc(
                        IN  PWSTR,
                        IN  PFILE_BOTH_DIR_INFORMATION,
                        OUT PULONG
                        );

    ReturnData    - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination (See below).

    p1 - Optional pointer, to be passed to the callback function.

Return Value:

    This function can return one of three values.  The data stored in
    'ReturnData' depends upon which value is returned:

        NormalReturn   - if the whole process completes uninterrupted
                         (ReturnData is not used)
        EnumFileError  - if an error occurs while enumerating files
                         (ReturnData contains the error code)
        CallbackReturn - if the callback returns FALSE, causing termination
                         (ReturnData contains data defined by the callback)

--*/
{
    HANDLE                     hFindFile;
    NTSTATUS                   Status;
    UNICODE_STRING             PathName;
    OBJECT_ATTRIBUTES          Obja;
    IO_STATUS_BLOCK            IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    BOOLEAN                    bStartScan;
    ENUMFILESRESULT            ret;

    //
    // Prepare to open the directory
    //
    RtlInitUnicodeString(&PathName, DirName);
    InitializeObjectAttributes(
       &Obja,
       &PathName,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );


    //
    // Open the specified directory for list access
    //
    Status = NtOpenFile(
        &hFindFile,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open directory %ws for list (%lx)\n",
                   DirName,
                   Status));

        *ReturnData = Status;
        return EnumFileError;
    }


    DirectoryInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG( INIT_TAG ),
                                    DOS_MAX_PATH_LENGTH * 2 + sizeof(FILE_BOTH_DIR_INFORMATION)
                                   );
    if(!DirectoryInfo) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to allocate memory for SpEnumFiles()\n"));

        *ReturnData = STATUS_INSUFFICIENT_RESOURCES;
        return EnumFileError;
    }

    bStartScan = TRUE;
    while(TRUE) {
        Status = NtQueryDirectoryFile(
            hFindFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            DirectoryInfo,
            (DOS_MAX_PATH_LENGTH * 2 + sizeof(FILE_BOTH_DIR_INFORMATION)),
            FileBothDirectoryInformation,
            TRUE,
            NULL,
            bStartScan
            );

        if(Status == STATUS_NO_MORE_FILES) {

            ret = NormalReturn;
            break;

        } else if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SMSS: Unable to query directory %ws (%lx)\n",
                       DirName,
                       Status));

            *ReturnData = Status;
            ret = EnumFileError;
            break;
        }

        if(bStartScan) {
            bStartScan = FALSE;
        }

        //
        // Now pass this entry off to our callback function for processing
        //
        if(!EnumFilesProc(DirName, DirectoryInfo, ReturnData, p1)) {

            ret = CallbackReturn;
            break;
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, DirectoryInfo );
    NtClose(hFindFile);
    return ret;
}

#endif // defined(REMOTE_BOOT)


NTSTATUS
SmpDeleteFile(
    IN PUNICODE_STRING pFile
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_BASIC_INFORMATION       BasicInfo;

    InitializeObjectAttributes(
       &Obja,
       pFile,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );


    //
    // Attempt to open the file.
    //
    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)(DELETE | FILE_WRITE_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
              );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to open %ws for delete (%lx)\n",
                   pFile->Buffer,
                   Status));

        return(Status);
    }

    //
    //  Change the file attribute to normal
    //

    RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
    BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &BasicInfo,
                                  sizeof(BasicInfo),
                                  FileBasicInformation
                                 );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SMSS: Unable to change attribute of %ls. Status = (%lx)\n",
                   pFile->Buffer,
                   Status));

        return(Status);
    }

    //
    // Set up for delete and call worker to do it.
    //
    #undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &Disposition,
                                  sizeof(Disposition),
                                  FileDispositionInformation
                                 );

    //
    // Clean up and return.
    //
    NtClose(Handle);
    return(Status);
}

NTSTATUS
SmpCallCsrCreateProcess(
    IN OUT PSBAPIMSG m,
    IN size_t ArgLength,
    IN HANDLE CommunicationPort
    )
/*++

Routine Description:

    This function sends a message to CSR telling to start a process

Arguments:

    m - message to send
    ArgLength - length of argument struct inside message
    CommunicationPort - LPC port to send to

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;

    m->h.u1.s1.DataLength = ArgLength + 8;
    m->h.u1.s1.TotalLength = sizeof(SBAPIMSG);
    m->h.u2.ZeroInit = 0L;

    m->ApiNumber = SbCreateProcessApi;

    Status = NtRequestWaitReplyPort(CommunicationPort,
                                    (PPORT_MESSAGE) m,
                                    (PPORT_MESSAGE) m
                                    );

    if (NT_SUCCESS( Status )) {
        Status = m->ReturnedStatus;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\dbgloop.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgloop.c

Abstract:

    Debug Subsystem Listen and API loops

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"


EXCEPTION_DISPOSITION
DbgpUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{

    UNICODE_STRING UnicodeParameter;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    BOOLEAN WasEnabled;
    NTSTATUS Status;

    //
    // Terminating will cause sm's wait to sense that we crashed. This will
    // result in a clean shutdown due to sm's hard error logic.
    //

    Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                 (BOOLEAN)TRUE,
                                 TRUE,
                                 &WasEnabled
                               );

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token.
        //

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     FALSE,
                                     &WasEnabled
                                   );
        }

    RtlInitUnicodeString( &UnicodeParameter, L"Session Manager" );
    Parameters[ 0 ] = (ULONG_PTR)&UnicodeParameter;
    Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
    Parameters[ 2 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;
    Parameters[ 3 ] = (ULONG_PTR)ExceptionInfo->ContextRecord;
    Status = NtRaiseHardError( STATUS_SYSTEM_PROCESS_TERMINATED,
                               4,
                               1,
                               Parameters,
                               OptionShutdownSystem,
                               &Response
                             );

    //
    // If this returns, give up.
    //

    NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\pagefile.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pagefile.h

Abstract:

    Session Manager page file related private types and prototypes.

Author:

    Silviu Calinoiu (silviuc) 12-Apr-2001

Revision History:

--*/

#ifndef _PAGEFILE_H_
#define _PAGEFILE_H_

/*++

General algorithm for creating paging files.

Possible paging file specifiers (in registry) are:

    a. ?:\pagefile.sys 
    b. ?:\pagefile.sys MIN MAX
    c. x:\pagefile.sys 
    d. x:\pagefile.sys MIN MAX
    e. multiple paging file specifiers
    f. no paging file specifier
    
    If MIN or MAX are zero or not present this is a specifier of 
    a system managed paging file.
    
    If we cannot convert a size (MIN or MAX) to a decimal number
    the specifier will be ignored.
    
    If we did not manage to create a single paging file but there
    were specifiers (although invalid) we will assume one specifier
    of type `?:\pagefile.sys'.

    A specifier of type `?:\pagefile.sys' must be alone.
    
Algorithm for `?:\pagefile.sys'.

    1. Query all volumes and sort them in decreasing order of
       available free space.
    2. Determine the ideal paging file size based on RAM, etc. We will
       use either this size or the maximum free space available on a
       volume as the size of the paging file.
    3. Iterate all volumes and try to create a paging file with
       the ideal size. If successful exit.
    4. Iterate all volumes and try to create a paging file with
       a size smaller than the ideal size. On each volume we loop
       trying with smaller and smaller sizes. If successful exit.
    5. Bail out.
    
    Note that in 99% of the cases algorithm will stop on the first volume
    from step (3). 
    
Algorithm for `?:\pagefile.sys MIN MAX'.

    1. Query all volumes and sort them in decreasing order of
       available free space.
    2. Iterate all volumes and try to create a paging file with
       the specified size or maximum free space available. 
       On each volume we loop trying with smaller and smaller sizes. 
       If successful exit.
    3. Iterate all volumes and try to create a paging file with
       a size smaller than the ideal size. On each volume we loop
       trying with smaller and smaller sizes. If successful exit.
    4. Bail out.
    
    Note that in 99% of the cases algorithm will stop on the first volume
    from step (2). 
    
Algorithm for creating a paging file for `x:\pagefile.sys'.

    1. Determine the ideal paging file size based on RAM, etc.
    2. Try to create it with ideal size or free space available 
       on the specified drive. Try with smaller and smaller sizes if needed.
    3. If after processing all specifiers we did not manage to create
       even a single paging file treat this as if a `?:\pagefile.sys' 
       descriptor was specified in the registry.       

Algorithm for creating a paging file for `x:\pagefile.sys MIN MAX'.

    1. Try to create it on that particular drive with the specified sizes
       or the available free space on the specified volume.
    2. If unsuccessfull use smaller sizes.
    3. If after processing all specifiers we did not manage to create
       even a single paging file treat this as if a `?:\pagefile.sys' 
       descriptor was specified in the registry.       

Algorithm for creating a paging file for `multiple page files' descriptor.

    1. Try to create it on the particular drives with the specified sizes.
       We assume this is an advanced user and we do not overwrite the
       settings at all.
    2. If we did not manage to create even a single paging file we
       will treat this as a `?:\pagefile.sys' descriptor.       

Algorithm for creating a paging file for `null' descriptor.

    1. No work. User requested to boot without a paging file.

--*/

//
// PAGING_FILE_DESCRIPTOR
//
// Name - name of the pagefile. The format is `X:\pagefile.sys' where X is
//     either a drive letter or `?'.
//
// Specifier - the registry string specifier for the paging file.
//
// Created - true if we managed to create a paging file for this descriptor.
//
// DefaultSize - true if we created the paging file based on a default descriptor.
//     This is used for emergency situations.
//
// SystemManaged - true if we need to create a system managed paging file using
//     this descriptor (we will decide what is the ideal size).
//
// SizeTrimmed - true if while validating the paging file sizes we trimmed them
//     for any reason.
//
// AnyDrive - true if the registry specifier starts with `?:\'.
//
// CrashdumpChecked - true if we checked for a crashdump in this paging file.
//

typedef struct _PAGING_FILE_DESCRIPTOR {

    LIST_ENTRY List;

    UNICODE_STRING Name;
    UNICODE_STRING Specifier;
    
    LARGE_INTEGER MinSize;
    LARGE_INTEGER MaxSize;
    
    LARGE_INTEGER RealMinSize;
    LARGE_INTEGER RealMaxSize;

    struct {
        ULONG Created : 1;
        ULONG DefaultSize : 1;
        ULONG SystemManaged : 1;
        ULONG SizeTrimmed : 1;
        ULONG AnyDrive : 1;
        ULONG Emergency : 1;
        ULONG CrashdumpChecked : 1;
    };

} PAGING_FILE_DESCRIPTOR, * PPAGING_FILE_DESCRIPTOR;

//
// VOLUME_DESCRIPTOR
//
// Initialized - true if this volume descriptor was completely initialized
//     (e.g. free space computed, crash dump processing, etc.).
//
// PagingFileCreated - true if during this boot session we have create
//     a paging file on this volume.
// 
// PagingFilePresent - true if this volume contains a stale paging file
//     for which we need to do crashdump processing.
//
// BootVolume - true if this is the boot volume.
//
// PagingFileCount - number of paging files created on this volume.
//

typedef struct _VOLUME_DESCRIPTOR {

    LIST_ENTRY List;

    struct {
        ULONG Initialized : 1;
        ULONG PagingFilePresent : 1;
        ULONG PagingFileCreated : 1;
        ULONG BootVolume : 1;
        ULONG PagingFileCount : 4; // based on MAXIMUM_NUMBER_OF_PAGING_FILES
    };

    WCHAR DriveLetter;
    LARGE_INTEGER FreeSpace;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

} VOLUME_DESCRIPTOR, * PVOLUME_DESCRIPTOR;

//
// Exported (out of module) functions.
//

VOID
SmpPagingFileInitialize (
    VOID
    );

NTSTATUS
SmpCreatePagingFileDescriptor(
    IN PUNICODE_STRING PagingFileSpecifier
    );

NTSTATUS
SmpCreatePagingFiles (
    VOID
    );

ULONG
SmpPagingFileExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    );

#endif // _PAGEFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\pagefile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pagefile.c

Abstract:

    Session manager page file creation routines.

Author:

    Silviu Calinoiu (silviuc) 12-Apr-2001

Revision History:

--*/

#include "smsrvp.h"
#include <ntosp.h>  //  Only for the interlocked functions. 
#include "pagefile.h"

//
// issue: silviuc: DbgPrintEx calls active on free builds (controlled by kd_smss_mask)
// We want to do this temporarily for easy debugging in case there are issues.
//
      
#ifdef KdPrintEx
#undef KdPrintEx
#define KdPrintEx(_x_) DbgPrintEx _x_
#endif

//
// Debugging aids. Since smss is very difficult to debug (cannot attach
// a user mode debugger we need to leave some traces to understand
// postmortem from kernel debugger what went wrong.
//

#define DEBUG_LOG_SIZE 32

typedef struct _DEBUG_LOG_ENTRY {

    ULONG Line;
    NTSTATUS Status;
    PCHAR Description;
    PVOID Context;

} DEBUG_LOG_ENTRY;

DEBUG_LOG_ENTRY DebugLog [DEBUG_LOG_SIZE];
LONG DebugLogIndex;

#define DEBUG_LOG_EVENT(_Status, _Message, _Context)   {    \
                                                            \
        LONG I = InterlockedIncrement (&DebugLogIndex);     \
        I %= DEBUG_LOG_SIZE;                                \
        DebugLog[I].Line = __LINE__;                        \
        DebugLog[I].Status = _Status;                       \
        DebugLog[I].Description = _Message;                 \
        DebugLog[I].Context = (PVOID)_Context;              \
    }

//
// Internal functions
//

VOID
SmpMakeSystemManagedPagingFileDescriptor (
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor
    );

VOID
SmpMakeDefaultPagingFileDescriptor (
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor
    );

PVOLUME_DESCRIPTOR
SmpSearchVolumeDescriptor (
    WCHAR DriveLetter
    );

NTSTATUS
SmpValidatePagingFileSizes(
    IN PPAGING_FILE_DESCRIPTOR Descriptor
    );

NTSTATUS
SmpCreatePagingFileOnAnyDrive(
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor,
    IN PLARGE_INTEGER SizeDelta,
    IN PLARGE_INTEGER MinimumSize
    );

NTSTATUS
SmpCreatePagingFileOnFixedDrive(
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor,
    IN PLARGE_INTEGER SizeDelta,
    IN PLARGE_INTEGER MinimumSize
    );

NTSTATUS
SmpCreateSystemManagedPagingFile (
    PPAGING_FILE_DESCRIPTOR Descriptor,
    BOOLEAN DecreaseSize
    );

NTSTATUS
SmpCreateEmergencyPagingFile (
    VOID
    );

BOOLEAN
SmpIsPossiblePagingFile (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING PageFileName
    );

NTSTATUS
SmpGetPagingFileSize (
    PUNICODE_STRING PageFileName,
    PLARGE_INTEGER PageFileSize
    );

NTSTATUS
SmpGetVolumeFreeSpace (
    PVOLUME_DESCRIPTOR Volume
    );

NTSTATUS
SmpDeleteStalePagingFiles (
    VOID
    );

NTSTATUS
SmpDeletePagingFile (
    PUNICODE_STRING PageFileName
    );

//
// Standard page file name. 
//

#define STANDARD_PAGING_FILE_NAME L"\\??\\?:\\pagefile.sys"
#define STANDARD_DRIVE_LETTER_OFFSET 4

//
// Maximum number of possible paging files. Limit comes from kernel.
//

#define MAXIMUM_NUMBER_OF_PAGING_FILES 16

//
// Minimum free space on disk. Used to avoid a situation where
// a paging file uses the entire disk space.
//

#define MINIMUM_REQUIRED_FREE_SPACE_ON_DISK (32 * 0x100000)

//
// Paging file creation retry constants.
//

#define MINIMUM_PAGING_FILE_SIZE (16 * 0x100000)
#define PAGING_FILE_SIZE_DELTA (16 * 0x100000)

//
// Paging file attributes
//

#define PAGING_FILE_ATTRIBUTES (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

//
// Volume descriptors
//

LIST_ENTRY SmpVolumeDescriptorList;

//
// Paging file descriptors
//

ULONG SmpNumberOfPagingFiles;
LIST_ENTRY SmpPagingFileDescriptorList;

//
// True if there was at least one paging file registry
// specifier even if it was ill-formed and it did not
// end up as a paging file descriptor.
//

BOOLEAN SmpRegistrySpecifierPresent;

//
// Exception information in case something was raised.
//

ULONG SmpPagingExceptionCode;
PVOID SmpPagingExceptionRecord;

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
SmpPagingFileInitialize (
    VOID
    )
{
    InitializeListHead (&SmpPagingFileDescriptorList);
    InitializeListHead (&SmpVolumeDescriptorList);
}


NTSTATUS
SmpCreatePagingFileDescriptor(
    IN PUNICODE_STRING PagingFileSpecifier
    )
/*++

Routine Description:

    This function is called during configuration to add a paging file
    to the structures describing pagefiles. Later SmpCreatePagingFiles
    will create the paging files based on these descriptions.

    The format of PagingFileSpec is:

        NAME MIN_SIZE MAX_SIZE (sizes specified in Mb)
        NAME                   (system managed paging file)
        NAME 0 0               (system managed paging file)
        
    If an error is encountered while converting the string to min/max size    
    the registry specifier will be ignored.
    
    If the specifier is a duplicate (a `?:\' specifier already present
    it will be ignored.
    
Arguments:

    PagingFileSpecifier - Unicode string that specifies the paging file name
        and size. The string is allocated during registry read and is assumed
        that this function takes ownership of it (w.r.t. freeing etc.).

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING PagingFileName;
    UNICODE_STRING Arguments;
    ULONG MinSize;
    ULONG MaxSize;
    PWSTR ArgSave, Arg2;
    USHORT I;
    BOOLEAN SystemManaged;
    BOOLEAN ZeroSizesSpecified;
    PPAGING_FILE_DESCRIPTOR Descriptor;

    //
    // Limit the number of registry specifiers.
    //

    if (SmpNumberOfPagingFiles >= MAXIMUM_NUMBER_OF_PAGING_FILES) {

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Too many paging files specified - %d\n",
                    SmpNumberOfPagingFiles));

        return STATUS_TOO_MANY_PAGING_FILES;
    }

    //
    // Parse the pagefile specification into file name
    // and a string with the min and max size (e.g. "min max").
    // Necessary buffers for PagingFileName and Arguments are
    // allocated in the parsing routine.
    //

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Paging file specifier `%wZ' \n",
                PagingFileSpecifier));

    Status = SmpParseCommandLine (PagingFileSpecifier,
                                  NULL,
                                  &PagingFileName,
                                  NULL,
                                  &Arguments);

    if (! NT_SUCCESS(Status)) {

        DEBUG_LOG_EVENT (Status, 
                         "parsing specified failed",
                         PagingFileSpecifier);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: SmpParseCommandLine(%wZ) failed with status %X \n",
                    PagingFileSpecifier,
                    Status));

        return Status;
    }

    //
    // We have encountered at least one registry specifier so far.
    // This is the right place to initialize this to true because if
    // we want no paging file at all the command above will fail and return
    // and will leave this variable false. If it is false we will not
    // attempt to create an emergency paging file.
    //

    SmpRegistrySpecifierPresent = TRUE;

    //
    // Convert the string sizes into integers representing pagefile
    // size in Mb. If the `Arguments' string is null or has "0 0" as sizes
    // it means we need to create a pagefile using the RAM size.
    //

    MinSize = 0;
    MaxSize = 0;
    SystemManaged = FALSE;
    ZeroSizesSpecified = FALSE;

    if (Arguments.Buffer) {

        //
        // If we picked up some numbers in the Arguments buffer check out
        // if there are only space and strings there.
        //

        ZeroSizesSpecified = TRUE;

        for (I = 0; I < Arguments.Length / sizeof(WCHAR); I += 1) {
            
            if (Arguments.Buffer[I] != L' ' && 
                Arguments.Buffer[I] != L'\t' && 
                Arguments.Buffer[I] != L'0') {

                ZeroSizesSpecified = FALSE;
                break;
            }
        }
    }

    if (Arguments.Buffer == NULL || ZeroSizesSpecified) {

            SystemManaged = TRUE;
    }
    else {

        //
        // We need to read two decimal numbers from the Arguments string.
        // If we encounter any errors while converting the string to a number
        // we will skip the entire specifier.
        //

        Status = RtlUnicodeStringToInteger (&Arguments, 0, &MinSize);

        if (! NT_SUCCESS(Status)) {
            
            DEBUG_LOG_EVENT (Status, NULL, NULL);

            RtlFreeUnicodeString (&PagingFileName);
            RtlFreeUnicodeString (&Arguments);
            return Status;
        }
        else {

            ArgSave = Arguments.Buffer;
            Arg2 = ArgSave;

            while (*Arg2 != UNICODE_NULL) {

                if (*Arg2++ == L' ') {

                    Arguments.Length -= (USHORT)((PCHAR)Arg2 - (PCHAR)ArgSave);
                    Arguments.Buffer = Arg2;
                    
                    Status = RtlUnicodeStringToInteger (&Arguments, 0, &MaxSize);

                    if (! NT_SUCCESS (Status)) {

                        DEBUG_LOG_EVENT (Status, NULL, NULL);

                        RtlFreeUnicodeString (&PagingFileName);
                        RtlFreeUnicodeString (&Arguments);
                        return Status;
                    }

                    Arguments.Buffer = ArgSave;
                    break;
                }
            }
        }
    }

    //
    // We do not need the temporary buffer created by the parsing routine
    // anymore.
    //

    RtlFreeUnicodeString (&Arguments);
    
    //
    // Save name and values just parsed into a pagefile descriptor
    // structure and return. We do not perform any validation on the
    // size here because all this will happen when the paging file
    // gets created.
    //

    Descriptor = (PPAGING_FILE_DESCRIPTOR) RtlAllocateHeap (RtlProcessHeap(), 
                                                            HEAP_ZERO_MEMORY,
                                                            sizeof *Descriptor);

    if (Descriptor == NULL) {

        RtlFreeUnicodeString (&PagingFileName);
        return STATUS_NO_MEMORY;
    }

    Descriptor->Specifier = *PagingFileSpecifier;
    Descriptor->Name = PagingFileName;
    Descriptor->MinSize.QuadPart = (LONGLONG)MinSize * 0x100000;
    Descriptor->MaxSize.QuadPart = (LONGLONG)MaxSize * 0x100000;
    Descriptor->SystemManaged = SystemManaged;

    Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = 
        RtlUpcaseUnicodeChar (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET]);

    if (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] == L'?') {
        Descriptor->AnyDrive = 1;
    }

    //
    // Avoid adding a duplicate to the descriptor list.
    //

    {
        PLIST_ENTRY Current;
        PPAGING_FILE_DESCRIPTOR FileDescriptor;
        BOOLEAN SkipDescriptor;

        Current = SmpPagingFileDescriptorList.Flink;
        SkipDescriptor = FALSE;

        while (Current != &SmpPagingFileDescriptorList) {

            FileDescriptor = CONTAINING_RECORD (Current,
                                                PAGING_FILE_DESCRIPTOR,
                                                List);
            Current = Current->Flink;

            //
            // Only one `?:\' descriptor is allowed. All others are skipped.
            //
            
            if (FileDescriptor->AnyDrive && Descriptor->AnyDrive) {
                SkipDescriptor = TRUE;
                break;
            }
            
            //
            // We allow descriptors on same volume. 
            //
#if 0
            if (FileDescriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] == 
                Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET]) {

                SkipDescriptor = TRUE;
                break;
            }
#endif
        }

        if (SkipDescriptor) {

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Skipping duplicate specifier `%wZ' \n",
                        PagingFileSpecifier));

            RtlFreeUnicodeString (&PagingFileName);
            RtlFreeHeap (RtlProcessHeap(), 0, Descriptor);
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Finally add new descriptor to the list.
    //

    InsertTailList (&SmpPagingFileDescriptorList, &(Descriptor->List));
    SmpNumberOfPagingFiles += 1;

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Created descriptor for `%wZ' (`%wZ') \n",
                PagingFileSpecifier, 
                &(Descriptor->Name)));

    return STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

NTSTATUS
SmpCreateVolumeDescriptors (
    VOID
    )
/*++

Routine description:

    This routine iterates all drive letters and creates a small descriptor for
    each volume that can host a page file (not a floppy, not removable and not
    remote volume). In each descriptor we store the free space available which is
    used to compute the volume with largest amount of free space.
    
Parameters:

    None.
    
Return value:

    STATUS_SUCCESS if it managed to find and query at least one volume.
    STATUS_UNEXPECTED_IO_ERROR if no volume was found and queried.
        
--*/
{
    WCHAR Drive;
    WCHAR StartDrive;
    NTSTATUS Status;
    UNICODE_STRING VolumePath;
    WCHAR Buffer[8];
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE VolumeHandle;
    PVOLUME_DESCRIPTOR Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
    BOOLEAN BootVolumeFound;
    
    //
    // Make sure we start with an empty list of volume descriptors.
    //

    ASSERT (IsListEmpty (&SmpVolumeDescriptorList));

    //
    // Query ProcessDeviceMap. We are interested in the DriveMap
    // bitmap so that we can figure out what drive letters are
    // legal.
    //

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof(ProcessDeviceMapInfo.Query),
                                        NULL);

    if (! NT_SUCCESS(Status)) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Query(ProcessDeviceMap) failed with status %X \n",
                    Status));

        return Status;
    }

    //
    // Create a template volume path.
    //

    wcscpy (Buffer, L"\\??\\A:\\");
    VolumePath.Buffer = Buffer;
    VolumePath.Length = wcslen(VolumePath.Buffer) * sizeof(WCHAR);
    VolumePath.MaximumLength = VolumePath.Length + sizeof(WCHAR);

    //
    // The first possible drive letter. 
    //

    StartDrive = L'C';

#if defined(i386)
    //
    // PC-9800 Series support.
    //
    
    if (IsNEC_98) {
        StartDrive = L'A';
    }
#endif // defined(i386)

    //
    // Iterate all possible drive letters.
    //

    BootVolumeFound = FALSE;

    for (Drive = StartDrive; Drive <= L'Z'; Drive += 1) {

        //
        // Skip invalid drive letters.
        //

        if ((ProcessDeviceMapInfo.Query.DriveMap & (1 << (Drive - L'A'))) == 0) {
            continue;
        }

        VolumePath.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = Drive;
        
        InitializeObjectAttributes (&ObjectAttributes,
                                    &VolumePath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        Status = NtOpenFile (&VolumeHandle,
                             (ACCESS_MASK)FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);

        if (! NT_SUCCESS(Status)) {
            
            DEBUG_LOG_EVENT (Status, NULL, NULL);
            
            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Open volume `%wZ' failed with status %X \n",
                        &VolumePath,
                        Status));
            continue;
        }

        //
        // Get volume characteristics.
        //

        Status = NtQueryVolumeInformationFile (VolumeHandle,
                                               &IoStatusBlock,
                                               &DeviceInfo,
                                               sizeof (DeviceInfo),
                                               FileFsDeviceInformation);

        if (! NT_SUCCESS(Status)) {
            
            DEBUG_LOG_EVENT (Status, NULL, NULL);

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Query volume `%wZ' (handle %p) for "
                        "device info failed with status %X \n",
                        &VolumePath,
                        VolumeHandle,
                        Status));
            
            NtClose (VolumeHandle);
            continue;
        }
        
        //
        // Reject volumes that cannot store a paging file.
        //
        
        if (DeviceInfo.Characteristics & (FILE_FLOPPY_DISKETTE  |
                                          FILE_READ_ONLY_DEVICE |
                                          FILE_REMOTE_DEVICE    |
                                          FILE_REMOVABLE_MEDIA  )) {

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Volume `%wZ' (%X) cannot store a paging file \n",
                        &VolumePath,
                        DeviceInfo.Characteristics));
            
            NtClose (VolumeHandle);
            continue;
        }
        
        //
        // Create a volume descriptor entry.
        //

        Volume = (PVOLUME_DESCRIPTOR) RtlAllocateHeap (RtlProcessHeap(), 
                                                       HEAP_ZERO_MEMORY, 
                                                       sizeof *Volume);

        if (Volume == NULL) {
            
            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Failed to allocate a volume descriptor (%u bytes) \n", 
                        sizeof *Volume));
            
            NtClose (VolumeHandle);
            continue;
        }

        Volume->DriveLetter = Drive;
        Volume->DeviceInfo = DeviceInfo;
        
        //
        // Check if this is the boot volume.
        //

        if (RtlUpcaseUnicodeChar(Volume->DriveLetter) == 
            RtlUpcaseUnicodeChar(USER_SHARED_DATA->NtSystemRoot[0])) {

            ASSERT (BootVolumeFound == FALSE);

            Volume->BootVolume = 1;
            BootVolumeFound = TRUE;
        }                                                           

        //
        // Determine the size parameters of the volume.
        //

        Status = NtQueryVolumeInformationFile (VolumeHandle,
                                               &IoStatusBlock,
                                               &SizeInfo,
                                               sizeof (SizeInfo),
                                               FileFsSizeInformation);

        if (! NT_SUCCESS(Status)) {

            DEBUG_LOG_EVENT (Status, NULL, NULL);

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Query volume `%wZ' (handle %p) for "
                        "size failed with status %X \n",
                        &VolumePath,
                        VolumeHandle,
                        Status));
            
            RtlFreeHeap (RtlProcessHeap(), 0, Volume);
            NtClose (VolumeHandle);
            continue;
        }

        //
        // We do not need the volume handle anymore.
        //

        NtClose (VolumeHandle);

        //
        // Compute free space on volume.
        //

        Volume->FreeSpace = RtlExtendedIntegerMultiply (SizeInfo.AvailableAllocationUnits,
                                                        SizeInfo.SectorsPerAllocationUnit);

        Volume->FreeSpace = RtlExtendedIntegerMultiply (Volume->FreeSpace,
                                                        SizeInfo.BytesPerSector);

        //
        // Trim a little bit free space on volume to make sure a paging file
        // will not use absolutely everything on disk.
        //

        if (Volume->FreeSpace.QuadPart > MINIMUM_REQUIRED_FREE_SPACE_ON_DISK) {
            Volume->FreeSpace.QuadPart -= MINIMUM_REQUIRED_FREE_SPACE_ON_DISK;
        } else {
            Volume->FreeSpace.QuadPart = 0;
        }

        //
        // Insert the new volume descriptor in decreasing order of
        // amount of free space.
        //

        {
            BOOLEAN Inserted = FALSE;

            //
            // silviuc: insert volumes in letter order instead of free space order
            // Note that this is the current NT4, W2000, Whistler behavior.
            // We do this because if we insert descriptors in free space order there
            // are issues for ?:\pagefile.sys type of descriptors. The way it is
            // written the algorithm would have the tendency to create in time
            // after several reboot a pagefile on each volume even if only one is
            // used each time. To fix this we need smart page file deletion routine
            // for stale files. Since nobody uses ?:\ anyway (not yet) we will fix
            // these together.
            //
#if 0 
            PLIST_ENTRY Current;
            PVOLUME_DESCRIPTOR Descriptor;
            
            Current = SmpVolumeDescriptorList.Flink;

            while (Current != &SmpVolumeDescriptorList) {

                Descriptor = CONTAINING_RECORD (Current,
                                                VOLUME_DESCRIPTOR,
                                                List);
                Current = Current->Flink;

                ASSERT (Descriptor->Initialized == TRUE);
                ASSERT (Descriptor->DriveLetter >= L'A' && Descriptor->DriveLetter <= L'Z');

                if (Descriptor->FreeSpace.QuadPart < Volume->FreeSpace.QuadPart) {
                    
                    Inserted = TRUE;

                    Volume->List.Flink = &(Descriptor->List);
                    Volume->List.Blink = Descriptor->List.Blink;

                    Descriptor->List.Blink->Flink = &(Volume->List);
                    Descriptor->List.Blink = &(Volume->List);
                    
                    break;
                }
            }
#endif // #if 0

            if (! Inserted) {
                InsertTailList (&SmpVolumeDescriptorList, &(Volume->List));
            }

            Volume->Initialized = TRUE;
        }
        
        KdPrintEx ((DPFLTR_SMSS_ID, DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Created volume descriptor for`%wZ' \n",
                    &VolumePath));
    }

    //
    // We should have found at least the boot volume.
    //

    ASSERT (BootVolumeFound == TRUE);

    //
    // We should have something in the descriptor list by now.
    //

    ASSERT (! IsListEmpty (&SmpVolumeDescriptorList));

    if (IsListEmpty (&SmpVolumeDescriptorList)) {
        Status = STATUS_UNEXPECTED_IO_ERROR;
    }
    else {
        Status = STATUS_SUCCESS;
    }

    return Status;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

NTSTATUS
SmpCreatePagingFiles (
    VOID
    )
/*++

Routine Description:

    This function creates pagefiles according to the specifications
    read from the registry.

Arguments:

    None.

Return Value:

    Returns the status of the last pagefile creation operation.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY Current;
    PPAGING_FILE_DESCRIPTOR Descriptor;
    BOOLEAN Created;
    LARGE_INTEGER SizeDelta;
    LARGE_INTEGER MinimumSize;

    //
    // We will let the system run without a pagefile if this is
    // what the user wants even if it is risky. If we had registry
    // specifier but we did not end up with descriptors we postpone 
    // action for a while. Lower in the function we will deal with
    // this case.
    //

    if (SmpNumberOfPagingFiles == 0 && SmpRegistrySpecifierPresent == FALSE) {

        ASSERT (IsListEmpty(&SmpPagingFileDescriptorList));

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: No paging file was requested \n"));

        return STATUS_SUCCESS;
    }

    //
    // Create volume descriptors for all valid volumes. The list of
    // volumes is sorted in decreasing order of free space and therefore
    // will come in handy when deciding on which volume we can create
    // a paging file with highest chances of success.
    //

    Status = SmpCreateVolumeDescriptors ();

    if (! NT_SUCCESS(Status)) {
        
        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failed to create volume descriptors (status %X) \n", 
                    Status));

        return Status;
    }

    //
    // Create paging files based on registry descriptors.
    //

    Current = SmpPagingFileDescriptorList.Flink;
    Created = FALSE;

    while (Current != &SmpPagingFileDescriptorList) {

        Descriptor = CONTAINING_RECORD (Current,
                                        PAGING_FILE_DESCRIPTOR,
                                        List);

        Current = Current->Flink;

        if (Descriptor->SystemManaged) {

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Creating a system managed paging file (`%wZ') \n",
                        &(Descriptor->Name)));

            Status = SmpCreateSystemManagedPagingFile (Descriptor, FALSE);

            if (! NT_SUCCESS(Status)) {
                
                //
                // Try again but this time allow decrease in size.
                //

                KdPrintEx ((DPFLTR_SMSS_ID,
                            DPFLTR_INFO_LEVEL,
                            "SMSS:PFILE: Trying lower sizes for (`%wZ') \n",
                            &(Descriptor->Name)));

                Status = SmpCreateSystemManagedPagingFile (Descriptor, TRUE);
            }
        }
        else {

            SmpValidatePagingFileSizes(Descriptor);

            SizeDelta.QuadPart = (LONGLONG)PAGING_FILE_SIZE_DELTA;

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Creating a normal paging file (`%wZ') \n",
                        &(Descriptor->Name)));

            if (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] == L'?') {

                MinimumSize.QuadPart = Descriptor->MinSize.QuadPart;

                Status = SmpCreatePagingFileOnAnyDrive (Descriptor,
                                                        &SizeDelta,
                                                        &MinimumSize);

                if (!NT_SUCCESS(Status)) {
                    
                    KdPrintEx ((DPFLTR_SMSS_ID,
                                DPFLTR_INFO_LEVEL,
                                "SMSS:PFILE: Trying lower sizes for (`%wZ') \n",
                                &(Descriptor->Name)));

                    MinimumSize.QuadPart = (LONGLONG)MINIMUM_PAGING_FILE_SIZE;

                    Status = SmpCreatePagingFileOnAnyDrive (Descriptor,
                                                            &SizeDelta,
                                                            &MinimumSize);
                }
            }
            else {

                MinimumSize.QuadPart = (LONGLONG)MINIMUM_PAGING_FILE_SIZE;

                Status = SmpCreatePagingFileOnFixedDrive (Descriptor,
                                                          &SizeDelta,
                                                          &MinimumSize);
            }
        }

        if (NT_SUCCESS(Status)) {
            Created = TRUE;
        }
    }

    //
    // If we did not manage to create even a single paging file
    // assume we had a `?:\pagefile.sys' specifier.
    //

    if (! Created) {

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Creating emergency paging file. \n"));

        Status = SmpCreateEmergencyPagingFile ();
    }

    //
    // Delete any paging files that are not going to be used.
    //
    // silviuc: danger to delete user files having pagefile.sys name
    // Plus it does not work for other nonstandard pagefile names.
    // To do it the right way we need to have a registry key with the
    // names of the pagefiles created on previous boot and delete whatever 
    // is not used on the current boot.
    //

#if 0
    SmpDeleteStalePagingFiles ();
#endif
    
    return Status;
}
    

NTSTATUS
SmpCreateEmergencyPagingFile (
    VOID
    )
/*++

Routine Description:

    This routine creates a paging file of type `?:\pagefile.sys' 
    (on any drive with system decided size or less). It will create
    its own descriptor and put it at first element of paging file
    descriptor list.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or various error codes.

--*/
{
    PPAGING_FILE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    CHAR Buffer [64];

    Descriptor = (PPAGING_FILE_DESCRIPTOR) RtlAllocateHeap (RtlProcessHeap(),
                                                            HEAP_ZERO_MEMORY,
                                                            sizeof *Descriptor);

    if (Descriptor == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlInitUnicodeString (&(Descriptor->Name), NULL);
    RtlInitUnicodeString (&(Descriptor->Specifier), NULL);

    wcscpy ((PWSTR)Buffer, STANDARD_PAGING_FILE_NAME);
    ASSERT (sizeof(Buffer) > wcslen(STANDARD_PAGING_FILE_NAME) * sizeof(WCHAR));
    Descriptor->Name.Buffer = (PWSTR)Buffer;
    Descriptor->Name.Length = wcslen((PWSTR)Buffer) * sizeof(WCHAR);
    Descriptor->Name.MaximumLength = Descriptor->Name.Length + sizeof(WCHAR);
    
    Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = L'?';
    Descriptor->SystemManaged = 1;
    Descriptor->Emergency = 1;
    Descriptor->AnyDrive = 1;

    SmpNumberOfPagingFiles += 1;
    InsertHeadList (&SmpPagingFileDescriptorList, &(Descriptor->List));

    Status = SmpCreateSystemManagedPagingFile (Descriptor, TRUE);

    return Status;
}


NTSTATUS
SmpCreateSystemManagedPagingFile (
    PPAGING_FILE_DESCRIPTOR Descriptor,
    BOOLEAN DecreaseSize
    )
/*++

Routine Description:

    This routine creates a system managed paging file.

Arguments:

    Descriptor: paging file descriptor.
    
    DecreaseSize: true if size from descriptor can be decreased.

Return Value:

    Returns the status of the pagefile creation operation.

--*/
{
    LARGE_INTEGER SizeDelta;
    LARGE_INTEGER MinimumSize;
    NTSTATUS Status;

    ASSERT (SmpNumberOfPagingFiles >= 1);
    ASSERT (!IsListEmpty(&SmpPagingFileDescriptorList));
    ASSERT (Descriptor->SystemManaged == 1);

    SmpMakeSystemManagedPagingFileDescriptor (Descriptor);

    SmpValidatePagingFileSizes(Descriptor);

    SizeDelta.QuadPart = (LONGLONG)PAGING_FILE_SIZE_DELTA;

    if (DecreaseSize) {
        MinimumSize.QuadPart = (LONGLONG)MINIMUM_PAGING_FILE_SIZE;
    }
    else {
        MinimumSize.QuadPart = Descriptor->MinSize.QuadPart;
    }
    
    if (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] == L'?') {
        
        Status = SmpCreatePagingFileOnAnyDrive (Descriptor,
                                                &SizeDelta,
                                                &MinimumSize);
    }
    else {

        Status = SmpCreatePagingFileOnFixedDrive (Descriptor,
                                                  &SizeDelta,
                                                  &MinimumSize);
    }

    return Status;
}


NTSTATUS
SmpCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority OPTIONAL
    )
/*++

Routine Description:

    This routine is a wrapper around NtCreatePagingFile useful
    in case we need to add some debugging code.

Arguments:

    Same arguments as NtCreatePagingFile.

Return Value:

    Status of the pagefile creation operation.

--*/
{
    NTSTATUS Status;

    Status = NtCreatePagingFile (PageFileName,
                                 MinimumSize,
                                 MaximumSize,
                                 Priority);
    if (! NT_SUCCESS(Status)) {

        DEBUG_LOG_EVENT (Status, "failed", PageFileName);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: NtCreatePagingFile (%wZ, %I64X, %I64X) failed with %X \n", 
                    PageFileName,
                    MinimumSize->QuadPart,
                    MaximumSize->QuadPart,
                    Status));
    }
    else {

        DEBUG_LOG_EVENT (Status, "success", PageFileName);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: NtCreatePagingFile (%wZ, %I64X, %I64X) succeeded. \n", 
                    PageFileName,
                    MinimumSize->QuadPart,
                    MaximumSize->QuadPart));
    }

    return Status;
}


NTSTATUS
SmpCreatePagingFileOnFixedDrive (
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor,
    IN PLARGE_INTEGER SizeDelta,
    IN PLARGE_INTEGER MinimumSize
    )
/*++

Routine Description:

    This routine creates a pagefile based on Descriptor. The descriptor
    is assumed to have in the Name field a file name prefixed by a drive 
    letter (e.g. `c:\pagefile.sys'). The function will try to create the
    pagefile on the specified drive. If this cannot be done due to space
    limitations the function will try smaller sizes down to the absolute
    minimum size specified as a parameter.

    Note that the function can be forced to not retry with smaller sizes by
    specifying a MinimumSize that is equal to Descriptor->MinSize.

Arguments:
    
    Descriptor: paging file descriptor.
    
    SizeDelta: size is decreased by this quantity before retrying
        in case we did not manage to create the paging file with requested size.
        
    MinimumSize: the function will try down to this size. 

Return Value:

    STATUS_SUCCESS if page file has been created. Various error codes 
    if it fails.

--*/
{
    NTSTATUS Status;
    PVOLUME_DESCRIPTOR Volume;
    LARGE_INTEGER RealFreeSpace;
    BOOLEAN FoundPagingFile;

    ASSERT (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] != L'?');

    FoundPagingFile = FALSE;

    //
    // Get the volume descriptor for this paging file descriptor.
    //

    Volume = SmpSearchVolumeDescriptor (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET]);

    if (Volume == NULL) {
        
        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: No volume descriptor for `%wZ' \n", 
                    &(Descriptor->Name)));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Before creating the paging file, check if there is a
    // crashdump in it. If so, SmpCheckForCrashDump will
    // do whatever is necessary to process the crashdump.
    //
     
    if (Volume->BootVolume) {

        if (Descriptor->CrashdumpChecked == 0) {

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Checking for crash dump in `%wZ' on boot volume \n", 
                        &(Descriptor->Name)));

            SmpCheckForCrashDump (&(Descriptor->Name));

            Status = SmpGetVolumeFreeSpace (Volume);

            if (!NT_SUCCESS(Status)) {

                DEBUG_LOG_EVENT (Status, NULL, NULL);

                KdPrintEx ((DPFLTR_SMSS_ID,
                            DPFLTR_INFO_LEVEL,
                            "SMSS:PFILE: Failed to query free space for boot volume `%wC'\n", 
                            Volume->DriveLetter));

            }
            
            Descriptor->CrashdumpChecked = 1;
        }
    }
    else {

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Skipping crash dump checking for `%wZ' on non boot volume `%wC' \n", 
                    &(Descriptor->Name),
                    Volume->DriveLetter));

    }
    
#if 0 // allow multiple pagefiles on the same drive
    if (Volume->PagingFileCreated) {
        
        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Paging file already created for volume %wc \n", 
                    Volume->DriveLetter));

        return STATUS_INVALID_PARAMETER;
    }
#endif

    //
    // Get the size of the future paging file if it exists.
    // In case of error (e.g. paging file does not exist yet)
    // RealFreeSpace will contain zero.
    //

    Descriptor->RealMinSize.QuadPart = Descriptor->MinSize.QuadPart;
    Descriptor->RealMaxSize.QuadPart = Descriptor->MaxSize.QuadPart;

    Status = SmpGetPagingFileSize (&(Descriptor->Name),
                                   &RealFreeSpace);

    if (RealFreeSpace.QuadPart > 0) {
        FoundPagingFile = TRUE;
    }

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Detected size %I64X for future paging file `%wZ'\n", 
                RealFreeSpace.QuadPart,
                &(Descriptor->Name)));

    //
    // Adjust the free space with the size of the paging file.
    //

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Free space on volume `%wC' is %I64X \n", 
                Volume->DriveLetter,
                Volume->FreeSpace.QuadPart));

    RealFreeSpace.QuadPart += Volume->FreeSpace.QuadPart;

    if (Descriptor->RealMinSize.QuadPart > RealFreeSpace.QuadPart) {
        Descriptor->RealMinSize.QuadPart = RealFreeSpace.QuadPart;
    }

    if (Descriptor->RealMaxSize.QuadPart > RealFreeSpace.QuadPart) {
        Descriptor->RealMaxSize.QuadPart = RealFreeSpace.QuadPart;
    }

    //
    // Create the paging file.
    //

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: min %I64X, max %I64X, real min %I64X \n", 
                Descriptor->RealMinSize.QuadPart,
                Descriptor->RealMaxSize.QuadPart,
                MinimumSize->QuadPart));

    while (Descriptor->RealMinSize.QuadPart >= MinimumSize->QuadPart) {

        Status = SmpCreatePagingFile (&(Descriptor->Name),
                                      &(Descriptor->RealMinSize),
                                      &(Descriptor->RealMaxSize),
                                      0);

        if (NT_SUCCESS(Status)) {

            Descriptor->Created = TRUE;
            Volume->PagingFileCreated = TRUE;
            Volume->PagingFileCount += 1;

            break;
        }

        Descriptor->RealMinSize.QuadPart -= SizeDelta->QuadPart;
    }
    
    if (Descriptor->RealMinSize.QuadPart < MinimumSize->QuadPart) {
        
        //
        // If are here we did not manage to create a paging file. This
        // can happen for various reasons. For example the initial
        // paging file descriptor had a size that was too small (usually
        // sizes below 16Mb are rejected). For these cases we have to 
        // delete any paging file left on the drive.
        //

        if (FoundPagingFile) {
            
            SmpDeletePagingFile (&(Descriptor->Name));
        }

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failing for min %I64X, max %I64X, real min %I64X \n", 
                    Descriptor->RealMinSize.QuadPart,
                    Descriptor->RealMaxSize.QuadPart,
                    MinimumSize->QuadPart));

        return STATUS_DISK_FULL;
    }
    else {
        return Status;
    }
}


NTSTATUS
SmpCreatePagingFileOnAnyDrive(
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor,
    IN PLARGE_INTEGER SizeDelta,
    IN PLARGE_INTEGER MinimumSize
    )
/*++

Routine Description:

    This function creates a pagefile based on Descriptor. The descriptor
    is assumed to have in the Name field a file name prefixed by `?' 
    (e.g. `?:\pagefile.sys'). The function will try to create the
    pagefile on any drive. If this cannot be done due to space
    limitations the function will try smaller sizes down to the absolute
    minimum size specified as a parameter.
    
    Note that the function can be forced to not retry with smaller sizes by
    specifying an AbsoluteMinSizeInMb that is equal to Descriptor->MinSizeInMb.

Arguments:
    
    Descriptor: paging file descriptor.
    
    SizeDelta: size is decreased by this quantity before retrying
        in case we did not manage to create the paging file with requested size.
        
    MinimumSize: the function will try down to this size. 

Return Value:

    NT_SUCCESS if page file has been created. Various error codes if it
    fails.

--*/
{
    PLIST_ENTRY Current;
    PVOLUME_DESCRIPTOR Volume;
    NTSTATUS Status;

    ASSERT (Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] == L'?');

    //
    // Iterate the sorted list of volume descriptors.
    //

    Current = SmpVolumeDescriptorList.Flink;

    Status = STATUS_DISK_FULL;

    while (Current != &SmpVolumeDescriptorList) {

        Volume = CONTAINING_RECORD (Current,
                                    VOLUME_DESCRIPTOR,
                                    List);

        Current = Current->Flink;

        ASSERT (Volume->Initialized == TRUE);
        ASSERT (Volume->DriveLetter >= L'A' && Volume->DriveLetter <= L'Z');

        Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = Volume->DriveLetter;

        Status = SmpCreatePagingFileOnFixedDrive (Descriptor,
                                                  SizeDelta,
                                                  MinimumSize);

        if (NT_SUCCESS(Status)) {
            break;
        }

        Descriptor->Name.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = L'?';
    }

    return Status;
}


NTSTATUS
SmpValidatePagingFileSizes(
    IN PPAGING_FILE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This function validates the min/max paging file sizes specified.
    It takes into consideration the architecture, the type of kernel
    (pae vs. nonpae), multiboot scenarios, etc..

Arguments:

    Descriptor: paging file descriptor.

Return Value:

    NT_SUCCESS if we have succesfully decided what are the proper sizes.
    In case of success the Min/MaxSize fileds of the paging file descriptor
    will get filled with proper sizes.

--*/
{
    NTSTATUS Status;
    ULONGLONG MinSize;
    ULONGLONG MaxSize;
    const ULONGLONG SIZE_1_MB = 0x100000;
    const ULONGLONG SIZE_1_GB = 1024 * SIZE_1_MB;
    const ULONGLONG SIZE_1_TB = 1024 * SIZE_1_GB;
    BOOLEAN SizeTrimmed = FALSE;;

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Validating sizes for `%wZ' %I64X %I64X\n", 
                &(Descriptor->Name),
                Descriptor->MinSize.QuadPart,
                Descriptor->MaxSize.QuadPart));

    MinSize = (ULONGLONG)(Descriptor->MinSize.QuadPart);
    MaxSize = (ULONGLONG)(Descriptor->MaxSize.QuadPart);

    //
    // Make sure max is bigger than min.
    //

    if (MinSize > MaxSize) {
        MaxSize = MinSize;
    }

    //
    // Check if min/max sizes are not too big.
    //

    Status = STATUS_SUCCESS;

#if defined(i386)

    //
    // X86 32 bits supports max 4095 Mb per pagefile
    // X86 PAE supports 16 Tb per pagefile
    //
    // If USER_SHARED_DATA structure has not been initialized
    // we will use the standard x86 limits.
    //

    if (USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED]) {

        //
        // We are in PAE mode.
        //

        if (MinSize > 16 * SIZE_1_TB) {
            SizeTrimmed = TRUE;
            MinSize = 16 * SIZE_1_TB;
        }

        if (MaxSize > 16 * SIZE_1_TB) {
            SizeTrimmed = TRUE;
            MaxSize = 16 * SIZE_1_TB;
        }
    }
    else {

        //
        // Standard x86 mode.
        //

        if (MinSize > 4095 * SIZE_1_MB) {
            SizeTrimmed = TRUE;
            MinSize = 4095 * SIZE_1_MB;
        }

        if (MaxSize > 4095 * SIZE_1_MB) {
            SizeTrimmed = TRUE;
            MaxSize = 4095 * SIZE_1_MB;
        }
    }

#elif defined(_WIN64)

    //
    // IA64, AXP64 support 32 Tb per pagefile
    // AMD64 supports 16 Tb per pagefile
    //
    // We will use for all cases 16 Tb which is anyway a huge
    // number for the foreseeable future.
    //

    if (MinSize > 16 * SIZE_1_TB) {
        SizeTrimmed = TRUE;
        MinSize = 16 * SIZE_1_TB;
    }

    if (MaxSize > 16 * SIZE_1_TB) {
        SizeTrimmed = TRUE;
        MaxSize = 16 * SIZE_1_TB;
    }
#else

    //
    // If we did not recognize the architecture we play it
    // as safe as possible.
    //

    if (MinSize > 4095 * SIZE_1_MB) {
        SizeTrimmed = TRUE;
        MinSize = 4095 * SIZE_1_MB;
    }

    if (MaxSize > 4095 * SIZE_1_MB) {
        SizeTrimmed = TRUE;
        MaxSize = 4095 * SIZE_1_MB;
    }

#endif

    if (SizeTrimmed) {
        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Trimmed size of `%wZ' to maximum allowed \n", 
                    &(Descriptor->Name)));
    }

    if (SizeTrimmed) {
        Descriptor->SizeTrimmed = 1;
    }

    Descriptor->MinSize.QuadPart = (LONGLONG)MinSize;
    Descriptor->MaxSize.QuadPart = (LONGLONG)MaxSize;

    return Status;
}


PVOLUME_DESCRIPTOR
SmpSearchVolumeDescriptor (
    WCHAR DriveLetter
    )
{
    PLIST_ENTRY Current;
    PVOLUME_DESCRIPTOR Volume;

    DriveLetter = RtlUpcaseUnicodeChar(DriveLetter);
    Current = SmpVolumeDescriptorList.Flink;

    while (Current != &SmpVolumeDescriptorList) {

        Volume = CONTAINING_RECORD (Current,
                                    VOLUME_DESCRIPTOR,
                                    List);

        Current = Current->Flink;

        ASSERT (Volume->Initialized == TRUE);
        ASSERT (Volume->DriveLetter >= L'A' && Volume->DriveLetter <= L'Z');

        if (Volume->DriveLetter == DriveLetter) {
            return Volume;
        }
    }

    return NULL;
}


VOID
SmpMakeSystemManagedPagingFileDescriptor (
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor
    )
{
    NTSTATUS Status;
    ULONGLONG MinSize;
    ULONGLONG MaxSize;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    ULONGLONG Ram;
    const ULONGLONG SIZE_1_MB = 0x100000;
    const ULONGLONG SIZE_1_GB = 1024 * SIZE_1_MB;

    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &SystemInformation,
                                       sizeof SystemInformation,
                                       NULL);

    if (! NT_SUCCESS (Status)) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: NtQuerySystemInformation failed with %x \n",
                    Status));
        
        SmpMakeDefaultPagingFileDescriptor (Descriptor);
    }
    else {

        Ram = (ULONGLONG)(SystemInformation.NumberOfPhysicalPages) *
              SystemInformation.PageSize;

        //
        // RAM      Min     Max
        //
        // <  1Gb   1.5 x   3 x
        // >= 1Gb   1 x     3 x
        //

        if (Ram < SIZE_1_GB) {

            MinSize = 3 * Ram / 2;
            MaxSize = 3 * Ram;
        }
        else {

            MinSize = Ram;
            MaxSize = 3 * Ram;
        }

        Descriptor->MinSize.QuadPart = (LONGLONG)MinSize;
        Descriptor->MaxSize.QuadPart = (LONGLONG)MaxSize;
        Descriptor->SystemManaged = 1;
    }
}


VOID
SmpMakeDefaultPagingFileDescriptor (
    IN OUT PPAGING_FILE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This function is called if we failed to come up with paging
    file descriptors. It will create some default settings that will
    be used to create a pagefile.

Arguments:

    EmergencyDesriptor: pointer to one paging file descriptor that will
        be filled with some emergency values.

Return Value:

    None. This function will always succeed.

--*/
{
    const ULONGLONG SIZE_1_MB = 0x100000;

    Descriptor->MinSize.QuadPart = (LONGLONG)128 * SIZE_1_MB;
    Descriptor->MaxSize.QuadPart = (LONGLONG)128 * SIZE_1_MB;
    Descriptor->DefaultSize = 1;
}


NTSTATUS
SmpDeleteStalePagingFiles (
    VOID
    )
/*++

Routine Description:

    This routine iterates all volumes from volume descriptor list and
    deletes stale paging files. If we created a new one on top of the old 
    one we will skip of course.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or various error codes.

--*/
{
    PLIST_ENTRY Current;
    PVOLUME_DESCRIPTOR Volume;
    UNICODE_STRING PageFileName;
    CHAR Buffer [64];
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE PageFileHandle;
    NTSTATUS Status;
    FILE_DISPOSITION_INFORMATION Disposition;

    Current = SmpVolumeDescriptorList.Flink;

    while (Current != &SmpVolumeDescriptorList) {

        Volume = CONTAINING_RECORD (Current,
                                    VOLUME_DESCRIPTOR,
                                    List);

        Current = Current->Flink;

        ASSERT (Volume->Initialized == TRUE);
        ASSERT (Volume->DriveLetter >= L'A' && Volume->DriveLetter <= L'Z');

        if (Volume->PagingFilePresent == 1 && Volume->PagingFileCreated == 0) {

            wcscpy ((PWSTR)Buffer, STANDARD_PAGING_FILE_NAME);
            ASSERT (sizeof(Buffer) > wcslen(STANDARD_PAGING_FILE_NAME) * sizeof(WCHAR));

            PageFileName.Buffer = (PWSTR)Buffer;
            PageFileName.Length = wcslen((PWSTR)Buffer) * sizeof(WCHAR);
            PageFileName.MaximumLength = PageFileName.Length + sizeof(WCHAR);
            PageFileName.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = Volume->DriveLetter;

            InitializeObjectAttributes (&ObjectAttributes,
                                        &PageFileName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL);

            //
            // We check the paging file attributes and if these are not the typical
            // ones (hidden and system) we will skip this file.
            //

            if (! SmpIsPossiblePagingFile (&ObjectAttributes, &PageFileName)) {
                continue;
            }

            //
            // Open the paging file for deletion.
            //

            Status = NtOpenFile (&PageFileHandle,
                                 (ACCESS_MASK)DELETE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 FILE_SHARE_DELETE |
                                 FILE_SHARE_READ |
                                 FILE_SHARE_WRITE,
                                 FILE_NON_DIRECTORY_FILE);

            if (! NT_SUCCESS (Status)) {

                DEBUG_LOG_EVENT (Status, NULL, NULL);

                KdPrintEx ((DPFLTR_SMSS_ID,
                            DPFLTR_INFO_LEVEL,
                            "SMSS:PFILE: Failed to open page file `%wZ' for "
                            "deletion (status %X)\n", 
                            &PageFileName,
                            Status));

            }
            else {

                Disposition.DeleteFile = TRUE;

                Status = NtSetInformationFile (PageFileHandle,
                                               &IoStatusBlock,
                                               &Disposition,
                                               sizeof( Disposition ),
                                               FileDispositionInformation);

                if (NT_SUCCESS(Status)) {

                    DEBUG_LOG_EVENT (Status, NULL, NULL);

                    KdPrintEx ((DPFLTR_SMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SMSS:PFILE: Deleted stale paging file - %wZ\n",
                               &PageFileName));
                }
                else {

                    DEBUG_LOG_EVENT (Status, NULL, NULL);

                    KdPrintEx ((DPFLTR_SMSS_ID,
                                DPFLTR_INFO_LEVEL,
                                "SMSS:PFILE: Failed to delete page file `%wZ' "
                                "(status %X)\n", 
                                &PageFileName,
                                Status));
                }

                NtClose(PageFileHandle);
            }
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SmpDeletePagingFile (
    PUNICODE_STRING PageFileName
    )
/*++

Routine Description:

    This routine deletes the paging file described by name.

Arguments:

    Descriptor: Paging file name.

Return Value:

    STATUS_SUCCESS or various error codes.

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE PageFileHandle;
    NTSTATUS Status;
    FILE_DISPOSITION_INFORMATION Disposition;

    InitializeObjectAttributes (&ObjectAttributes,
                                PageFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    //
    // Open the paging file for deletion.
    //

    Status = NtOpenFile (&PageFileHandle,
                         (ACCESS_MASK)DELETE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE |
                         FILE_SHARE_READ |
                         FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE);

    if (! NT_SUCCESS (Status)) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failed to open for deletion page file `%wZ' "
                    "(status %X)\n", 
                    PageFileName,
                    Status));
    }
    else {

        Disposition.DeleteFile = TRUE;

        Status = NtSetInformationFile (PageFileHandle,
                                       &IoStatusBlock,
                                       &Disposition,
                                       sizeof( Disposition ),
                                       FileDispositionInformation);

        if (NT_SUCCESS(Status)) {

            DEBUG_LOG_EVENT (Status, NULL, NULL);

            KdPrintEx ((DPFLTR_SMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SMSS:PFILE: Deleted stale paging file - %wZ\n",
                       PageFileName));
        }
        else {

            DEBUG_LOG_EVENT (Status, NULL, NULL);

            KdPrintEx ((DPFLTR_SMSS_ID,
                        DPFLTR_INFO_LEVEL,
                        "SMSS:PFILE: Failed to delete page file `%wZ' "
                        "(status %X)\n", 
                        PageFileName,
                        Status));
        }

        NtClose(PageFileHandle);
    }

    return Status;
}


BOOLEAN
SmpIsPossiblePagingFile (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING PageFileName
    )
/*++

Routine Description:

    This routine checks if the file passed as a parameter has typical
    paging file attributes (system and hidden). If not then it is likely
    that (a) user changed attirbutes or (b) this is not a pagefile but rather
    a user file with this name.

Arguments:

    ObjectAttributes
    
    PageFileName

Return Value:

    True if this is likely to be a paging file, false otherwise.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE PageFileHandle;
    NTSTATUS Status;
    FILE_BASIC_INFORMATION FileInfo;

    Status = NtOpenFile (&PageFileHandle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT);

    if (! NT_SUCCESS( Status )) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failed to open for query file `%wZ' with status %X \n", 
                    PageFileName,
                    Status));
        
        return FALSE;
    }

    Status = NtQueryInformationFile (PageFileHandle,
                                     &IoStatusBlock,
                                     &FileInfo,
                                     sizeof (FileInfo),
                                     FileBasicInformation);

    if (! NT_SUCCESS( Status )) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failed to query for attributes file `%wZ' with status %X \n", 
                    PageFileName,
                    Status));

        NtClose (PageFileHandle);
        return FALSE;
    }

    //
    // Close handle since we do not need it anymore.
    //

    NtClose (PageFileHandle);

    //
    // If the attributes are not system and hidden this is not likely to be a
    // pagefile. Either the user changed attributes on the pagefile or it is
    // not a pagefile at all.
    //

    if ((FileInfo.FileAttributes & PAGING_FILE_ATTRIBUTES) != PAGING_FILE_ATTRIBUTES) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


NTSTATUS
SmpGetPagingFileSize (
    PUNICODE_STRING PageFileName,
    PLARGE_INTEGER PageFileSize
    )
/*++

Routine Description:

    This routine checks if the file passed as a parameter exists and gets
    its file size. This will be used to correct the free space available
    on a volume.

Arguments:

    PageFileName
    
    PageFileSize

Return Value:

    STATUS_SUCCESS if we managed to open a paging file and query the size.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE PageFileHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    FILE_STANDARD_INFORMATION FileSizeInfo;

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Trying to get size for `%wZ'\n", 
                PageFileName));

    PageFileSize->QuadPart = 0;

    InitializeObjectAttributes (&ObjectAttributes,
                                PageFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&PageFileHandle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT);

    if (! NT_SUCCESS( Status )) {

        DEBUG_LOG_EVENT (Status, NULL, PageFileName);

        return Status;
    }

    Status = NtQueryInformationFile (PageFileHandle,
                                     &IoStatusBlock,
                                     &FileSizeInfo,
                                     sizeof (FileSizeInfo),
                                     FileStandardInformation);

    if (! NT_SUCCESS( Status )) {
        
        DEBUG_LOG_EVENT (Status, NULL, PageFileName);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Failed query for size potential pagefile `%wZ' with status %X \n", 
                    PageFileName,
                    Status));
        
        NtClose (PageFileHandle);
        return Status;
    }

    //
    // We do not need the paging file handle anymore.
    //

    NtClose (PageFileHandle);

    //
    // Return size.
    //

    PageFileSize->QuadPart = FileSizeInfo.AllocationSize.QuadPart;

    return STATUS_SUCCESS;
}


NTSTATUS
SmpGetVolumeFreeSpace (
    PVOLUME_DESCRIPTOR Volume
    )
/*++

Routine Description:

    This routine computes the amount of free space on a volume.

Arguments:

    Volume
    
    FreeSpace

Return Value:

    STATUS_SUCCESS if we managed to query the free space size.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING VolumePath;
    WCHAR Buffer[8];
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE VolumeHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    
    //
    // This function gets called only for boot volumes that contain
    // crashdumps. Crashdump processing will modify the free space
    // computed when the volume descriptor has been created.
    //

    ASSERT (Volume->BootVolume == 1);

    //
    // Create a template volume path.
    //

    wcscpy (Buffer, L"\\??\\A:\\");
    VolumePath.Buffer = Buffer;
    VolumePath.Length = wcslen(VolumePath.Buffer) * sizeof(WCHAR);
    VolumePath.MaximumLength = VolumePath.Length + sizeof(WCHAR);
    VolumePath.Buffer[STANDARD_DRIVE_LETTER_OFFSET] = Volume->DriveLetter;

    KdPrintEx ((DPFLTR_SMSS_ID,
                DPFLTR_INFO_LEVEL,
                "SMSS:PFILE: Querying volume `%wZ' for free space \n",
                &VolumePath));

    InitializeObjectAttributes (&ObjectAttributes,
                                &VolumePath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile (&VolumeHandle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);

    if (! NT_SUCCESS(Status)) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Open volume `%wZ' failed with status %X \n",
                    &VolumePath,
                    Status));

        return Status;
    }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile (VolumeHandle,
                                           &IoStatusBlock,
                                           &SizeInfo,
                                           sizeof (SizeInfo),
                                           FileFsSizeInformation);

    if (! NT_SUCCESS(Status)) {

        DEBUG_LOG_EVENT (Status, NULL, NULL);

        KdPrintEx ((DPFLTR_SMSS_ID,
                    DPFLTR_INFO_LEVEL,
                    "SMSS:PFILE: Query volume `%wZ' (handle %p) for "
                    "size failed with status %X \n",
                    &VolumePath,
                    VolumeHandle,
                    Status));

        NtClose (VolumeHandle);
        return Status;
    }

    //
    // We do not need the volume handle anymore.
    //

    NtClose (VolumeHandle);

    //
    // Compute free space on volume.
    //

    Volume->FreeSpace = RtlExtendedIntegerMultiply (SizeInfo.AvailableAllocationUnits,
                                                    SizeInfo.SectorsPerAllocationUnit);

    Volume->FreeSpace = RtlExtendedIntegerMultiply (Volume->FreeSpace,
                                                    SizeInfo.BytesPerSector);

    //
    // Trim a little bit free space on volume to make sure a paging file
    // will not use absolutely everything on disk.
    //

    if (Volume->FreeSpace.QuadPart > MINIMUM_REQUIRED_FREE_SPACE_ON_DISK) {
        Volume->FreeSpace.QuadPart -= MINIMUM_REQUIRED_FREE_SPACE_ON_DISK;
    }
    else {
        Volume->FreeSpace.QuadPart = 0;
    }

    return STATUS_SUCCESS;
}


ULONG
SmpPagingFileExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    )
/*++

Routine Description:

    This routine filters any exception that might occur in paging
    file creation code paths.

Arguments:

    ExceptionCode
    
    ExceptionRecord

Return Value:

    EXCEPTION_CONTINUE_SEARCH for most of the cases since we want smss
    to crash so that we can investigate what was going on.

--*/
{
    //
    // Save exception information for debugging.
    //

    SmpPagingExceptionCode = ExceptionCode;
    SmpPagingExceptionRecord = ExceptionRecord;
    
    //
    // We print this message no matter what because we want to know
    // what happened if smss crashes.
    //

    DbgPrint ("SMSS:PFILE: unexpected exception %X with record %p \n",
              ExceptionCode,
              ExceptionRecord);

#if DBG
    DbgBreakPoint ();
#endif

    return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smloop.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smloop.c

Abstract:

    Session Manager Listen and API loops

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"

#include <ntosp.h>  //  Only for the interlocked functions. 


#define SM_WORKER_THREADS_LIMIT 4

ULONG_PTR SmUniqueProcessId;

LONG SmpCurrentThreadsLimit = SM_WORKER_THREADS_LIMIT;
LONG SmWorkerThreadsAvailable = 0;
LONG SmTotalApiThreads = 0;

PSMP_CLIENT_CONTEXT SmpDeferredFreeList = NULL;


NTSTATUS
SmpHandleConnectionRequest(
    IN HANDLE ConnectionPort,
    IN PSBAPIMSG Message
    );


PSMAPI SmpApiDispatch[SmMaxApiNumber] = {
    SmpCreateForeignSession,
    SmpSessionComplete,
    SmpTerminateForeignSession,
    SmpExecPgm,
    SmpLoadDeferedSubsystem,
    SmpStartCsr,
    SmpStopCsr
    };


#if DBG
PSZ SmpApiName[ SmMaxApiNumber+1 ] = {
    "SmCreateForeignSession",
    "SmSessionComplete",
    "SmTerminateForeignSession",
    "SmExecPgm",
    "SmLoadDeferedSubsystem",
    "SmStartCsr",
    "SmStopCsr",
    "Unknown Sm Api Number"
};
#endif // DBG

EXCEPTION_DISPOSITION
DbgpUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

VOID
SmpFlushDeferredList()
{
    PSMP_CLIENT_CONTEXT Head = SmpDeferredFreeList;

    SmpDeferredFreeList = NULL;

    while (Head != NULL) {

        PSMP_CLIENT_CONTEXT ClientContext = Head;
        NTSTATUS Status;
        Head = Head->Link;

        if (ClientContext->ClientProcessHandle) {
           Status = NtClose( ClientContext->ClientProcessHandle );
           ASSERT(NT_SUCCESS(Status));
        }
        Status = NtClose( ClientContext->ServerPortHandle );
        ASSERT(NT_SUCCESS(Status));
        RtlFreeHeap( SmpHeap, 0, ClientContext );
    }

    SmpCurrentThreadsLimit = SM_WORKER_THREADS_LIMIT;
}

VOID
SmpPushDeferredClientContext(
    PSMP_CLIENT_CONTEXT ClientContext
    )
{
    PSMP_CLIENT_CONTEXT CapturedHead;

    do {
        
        CapturedHead = SmpDeferredFreeList;

        ClientContext->Link = CapturedHead;

    } while ( InterlockedCompareExchangePointer(&SmpDeferredFreeList, ClientContext, CapturedHead) != CapturedHead );
    
    SmpCurrentThreadsLimit = 1;
}



NTSTATUS
SmpApiLoop (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This is the main Session Manager API Loop. It
    services session manager API requests.

Arguments:

    ThreadParameter - Supplies a handle to the API port used
        to receive session manager API requests.

Return Value:

    None.

--*/

{
    PSMAPIMSG SmApiReplyMsg;
    SMMESSAGE_SIZE MsgBuf;

    PSMAPIMSG SmApiMsg;
    NTSTATUS Status;
    HANDLE ConnectionPort;
    PSMP_CLIENT_CONTEXT ClientContext;
    PSMPKNOWNSUBSYS KnownSubSys;
    PROCESS_BASIC_INFORMATION ProcessInfo;

    InterlockedIncrement(&SmTotalApiThreads);

    RtlSetThreadIsCritical(TRUE, NULL, TRUE);

    NtQueryInformationProcess( NtCurrentProcess(),
                               ProcessBasicInformation,
                               &ProcessInfo,
                               sizeof(ProcessInfo),
                               NULL );
    SmUniqueProcessId = ProcessInfo.UniqueProcessId;

    ConnectionPort = (HANDLE) ThreadParameter;

    SmApiMsg = (PSMAPIMSG)&MsgBuf;
    SmApiReplyMsg = NULL;
    try {
        for(;;) {

            {
                LONG CapturedThreads;

                do {

                    CapturedThreads = SmWorkerThreadsAvailable;

                    if (CapturedThreads >= SmpCurrentThreadsLimit) {

                        if (SmApiReplyMsg) {

                            while (1) {
                                Status = NtReplyPort (ConnectionPort,
                                                      (PPORT_MESSAGE) SmApiReplyMsg);
                                if (Status == STATUS_NO_MEMORY) {
                                    LARGE_INTEGER DelayTime;

                                    KdPrint (("SMSS: Failed to reply to calling thread, retrying.\n"));
                                    DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                                    NtDelayExecution (FALSE, &DelayTime);
                                    continue;
                                }
                                break;
                            }

                        }

                        InterlockedDecrement(&SmTotalApiThreads);
                        RtlSetThreadIsCritical(FALSE, NULL, TRUE);

                        RtlExitUserThread(STATUS_SUCCESS);

                        //
                        //  RtlExitUserThread never returns
                        //
                    }

                } while ( InterlockedCompareExchange(&SmWorkerThreadsAvailable, CapturedThreads + 1, CapturedThreads) !=  CapturedThreads);

            }
            
            if (SmTotalApiThreads == 1) {

                SmpFlushDeferredList();
            }

            while (1) {
                Status = NtReplyWaitReceivePort (ConnectionPort,
                                                 &ClientContext,
                                                 (PPORT_MESSAGE) SmApiReplyMsg,
                                                 (PPORT_MESSAGE) SmApiMsg);
                //
                // If we get an out of memory error then just wait instead of looping
                //
                if (Status == STATUS_NO_MEMORY) {
                    LARGE_INTEGER DelayTime;

                    if (SmApiReplyMsg != NULL) {
                        KdPrint (("SMSS: Failed to reply to calling thread, retrying.\n"));
                    }
                    DelayTime.QuadPart = Int32x32To64 (5000, -10000);
                    NtDelayExecution (FALSE, &DelayTime);
                    continue;
                }
                break;
            }

            //
            //  Launching at the same time a several subsystems can deadlock smss
            //  if it has only two worker threads.
            //  We create more threads if there is no server thread available
            //

            if (InterlockedDecrement(&SmWorkerThreadsAvailable) == 0) {
                
                NTSTATUS st = RtlCreateUserThread(
                        NtCurrentProcess(),
                        NULL,
                        FALSE,
                        0L,
                        0L,
                        0L,
                        SmpApiLoop,
                        (PVOID) ThreadParameter,
                        NULL,
                        NULL
                        );
            }

            if (!NT_SUCCESS (Status)) {
                SmApiReplyMsg = NULL;
                continue;
            } else if ( SmApiMsg->h.u2.s2.Type == LPC_CONNECTION_REQUEST ) {
                SmpHandleConnectionRequest( ConnectionPort,
                                            (PSBAPIMSG) SmApiMsg
                                          );
                SmApiReplyMsg = NULL;
            } else if ( SmApiMsg->h.u2.s2.Type == LPC_PORT_CLOSED ) {
                if (ClientContext) {
                   SmpPushDeferredClientContext(ClientContext);
                }
                SmApiReplyMsg = NULL;
            } else {

                if ( !ClientContext ) {
                    SmApiReplyMsg = NULL;
                    continue;
                }

                KnownSubSys = ClientContext->KnownSubSys;

                SmApiMsg->ReturnedStatus = STATUS_PENDING;

                if ((ULONG) SmApiMsg->ApiNumber >= (ULONG) SmMaxApiNumber ) {

                    Status = STATUS_NOT_IMPLEMENTED;

                } else {

                    switch (SmApiMsg->ApiNumber) {
                        case SmExecPgmApi :
                            Status = (SmpApiDispatch[SmApiMsg->ApiNumber])(
                                          SmApiMsg,
                                          ClientContext,
                                          ConnectionPort);
                            break;

                        case SmLoadDeferedSubsystemApi :
                            Status = (SmpApiDispatch[SmApiMsg->ApiNumber])(
                                          SmApiMsg,
                                          ClientContext,
                                          ConnectionPort);
                            break;


                        case SmStopCsrApi :
                        case SmStartCsrApi :

                            // 
                            // These Api's can only be called from a system process
                            //
                            if (ClientContext->SecurityContext == UNKNOWN_CONTEXT) {
                                // 
                                // Initialize the client security context
                                //
                                ClientContext->SecurityContext =
                                             SmpClientSecurityContext ((PPORT_MESSAGE)SmApiMsg,
                                                                       ClientContext->ServerPortHandle);
                            }

                            if (ClientContext->SecurityContext == SYSTEM_CONTEXT) {

                                Status = (SmpApiDispatch[SmApiMsg->ApiNumber])(
                                              SmApiMsg,
                                              ClientContext,
                                              ConnectionPort);
                                                                
                            } else {
#if DBG
                               KdPrint(("SMSS: Calling Sm Terminal Server Api from Non-System context.Status = STATUS_ACCESS_DENIED\n"));
#endif

                               Status = STATUS_ACCESS_DENIED;

                            }
                            break;

                        case SmCreateForeignSessionApi :
                        case SmSessionCompleteApi :
                        case SmTerminateForeignSessionApi :
                            if (!KnownSubSys) {
                                Status = STATUS_INVALID_PARAMETER;
                            } else {

                                Status =
                                    (SmpApiDispatch[SmApiMsg->ApiNumber])(
                                         SmApiMsg,
                                         ClientContext,
                                         ConnectionPort);
                            }
                            break;

                    }

                }

                SmApiMsg->ReturnedStatus = Status;
                SmApiReplyMsg = SmApiMsg;
            }
        }
    } except (DbgpUnhandledExceptionFilter( GetExceptionInformation() )) {
        ;
    }

    //
    // Make the compiler happy
    //

    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
SmpHandleConnectionRequest(
    IN HANDLE ConnectionPort,
    IN PSBAPIMSG Message
    )

/*++

Routine Description:

    This routine handles connection requests from either known subsystems,
    or other clients. Other clients are admin processes.

    The protocol for connection from a known subsystem is:

        capture the name of the subsystem's Sb API port

        Accept the connection

        Connect to the subsystems Sb API port

        Store the communication port handle in the known subsystem database

        signal the event associated with the known subsystem

    The protocol for others is to simply validate and accept the connection
    request.

Arguments:

Return Value:

    None.

--*/

{
    NTSTATUS st;
    HANDLE CommunicationPort;
    REMOTE_PORT_VIEW ClientView;
    PSBCONNECTINFO ConnectInfo;
    ULONG ConnectInfoLength;
    PSMPKNOWNSUBSYS KnownSubSys, KnownSubSys2;
    BOOLEAN Accept;
    UNICODE_STRING SubSystemPort;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    PSMP_CLIENT_CONTEXT ClientContext;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ClientProcessHandle=NULL;
    ULONG MuSessionId = 0;

    //
    // Set up the security quality of service parameters to use over the
    // sb API port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityIdentification;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;


    Accept = TRUE; // Assume we will accept
    //
    // Get MuSessionId of the client if session manager is not connecting to itself
    //
    if ( (ULONG_PTR) Message->h.ClientId.UniqueProcess == SmUniqueProcessId ) {
        KnownSubSys = NULL;
        ClientProcessHandle = NULL;
    } else {
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        st = NtOpenProcess( &ClientProcessHandle, PROCESS_QUERY_INFORMATION,
                            &ObjA, &Message->h.ClientId );
        if (NT_SUCCESS (st)) {
           SmpGetProcessMuSessionId( ClientProcessHandle, &MuSessionId );
        } else {
           Accept = FALSE;
        }
    }

    ConnectInfo = &Message->ConnectionRequest;
    KnownSubSys = SmpLocateKnownSubSysByCid(&Message->h.ClientId);

    if ( (KnownSubSys) && (Accept == TRUE) ) {
        KnownSubSys2 = SmpLocateKnownSubSysByType(MuSessionId, ConnectInfo->SubsystemImageType);


        if (KnownSubSys2 == KnownSubSys ) {
            Accept = FALSE;
            KdPrint(("SMSS: Connection from SubSystem rejected\n"));
            KdPrint(("SMSS: Image type already being served\n"));
        } else {
            KnownSubSys->ImageType = ConnectInfo->SubsystemImageType;
        }
        if (KnownSubSys2) {
            RtlEnterCriticalSection( &SmpKnownSubSysLock );
            SmpDeferenceKnownSubSys(KnownSubSys2);
            RtlLeaveCriticalSection( &SmpKnownSubSysLock );
        }
    }

    if (Accept) {
        ClientContext = RtlAllocateHeap(SmpHeap, MAKE_TAG( SM_TAG ), sizeof(SMP_CLIENT_CONTEXT));
        if ( ClientContext ) {
            ClientContext->ClientProcessHandle = ClientProcessHandle;
            ClientContext->KnownSubSys = KnownSubSys;

            //
            // The sm apis used by Terminal Server to start and stop CSR
            // do not get called from known subsystems and are restricted
            // to system processes only.
            //

            ClientContext->SecurityContext = UNKNOWN_CONTEXT;
            ClientContext->ServerPortHandle = NULL;
        } else {
            Accept = FALSE;
        }
    }

    ClientView.Length = sizeof(ClientView);
    st = NtAcceptConnectPort(
            &CommunicationPort,
            ClientContext,
            (PPORT_MESSAGE)Message,
            Accept,
            NULL,
            &ClientView
            );

    if ( Accept ) {        

        if (NT_SUCCESS (st)) {
            if (ClientContext) {

                ClientContext->ServerPortHandle = CommunicationPort;

            }
        

            if ( KnownSubSys ) {
                KnownSubSys->SmApiCommunicationPort = CommunicationPort;
            }

            st = NtCompleteConnectPort(CommunicationPort);
            if (!NT_SUCCESS(st)) {
               
                if ( KnownSubSys ) {
                   KnownSubSys->SmApiCommunicationPort = NULL;
                   RtlEnterCriticalSection( &SmpKnownSubSysLock );
                   SmpDeferenceKnownSubSys(KnownSubSys);
                   RtlLeaveCriticalSection( &SmpKnownSubSysLock );
               }
               
               return st;
            }

            //
            // Connect Back to subsystem.
            //

            if ( KnownSubSys ) {
                ConnectInfo->EmulationSubSystemPortName[
                   sizeof (ConnectInfo->EmulationSubSystemPortName)/sizeof (WCHAR) - 1] = '\0';
                RtlCreateUnicodeString( &SubSystemPort,
                                        ConnectInfo->EmulationSubSystemPortName
                                      );
                ConnectInfoLength = sizeof( *ConnectInfo );

                st = NtConnectPort(
                        &KnownSubSys->SbApiCommunicationPort,
                        &SubSystemPort,
                        &DynamicQos,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );
                if ( !NT_SUCCESS(st) ) {
                    KdPrint(("SMSS: Connect back to Sb %wZ failed %lx\n",&SubSystemPort,st));
                }

                RtlFreeUnicodeString( &SubSystemPort );
                NtSetEvent(KnownSubSys->Active,NULL);
            }
        } else {
            if (ClientProcessHandle) {
               NtClose( ClientProcessHandle );
            }
            RtlFreeHeap( SmpHeap, 0, ClientContext );
        }
    } else {
        if (ClientProcessHandle) {
            NtClose( ClientProcessHandle );
        }
    }
    if (KnownSubSys) {
        RtlEnterCriticalSection( &SmpKnownSubSysLock );
        SmpDeferenceKnownSubSys(KnownSubSys);
        RtlLeaveCriticalSection( &SmpKnownSubSysLock );
    }

    return st;
}


PSMPKNOWNSUBSYS
SmpLocateKnownSubSysByCid(
    IN PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function scans the known subsystem table looking for
    a matching client id (just UniqueProcess portion). If found,
    than the connection request is from a known subsystem and
    accept is always granted. Otherwise, it must be an administrative
    process.

Arguments:

    ClientId - Supplies the ClientId whose UniqueProcess field is to be used
        in the known subsystem scan.

Return Value:

    NULL - The ClientId does not match a known subsystem.

    NON-NULL - Returns the address of the known subsystem.

--*/

{

    PSMPKNOWNSUBSYS KnownSubSys = NULL;
    PLIST_ENTRY Next;

    //
    // Acquire known subsystem lock.
    //

    RtlEnterCriticalSection(&SmpKnownSubSysLock);

    Next = SmpKnownSubSysHead.Flink;

    while ( Next != &SmpKnownSubSysHead ) {

        KnownSubSys = CONTAINING_RECORD(Next,SMPKNOWNSUBSYS,Links);
        Next = Next->Flink;


            if ( (KnownSubSys->InitialClientId.UniqueProcess == ClientId->UniqueProcess) &&
                !KnownSubSys->Deleting ) {
               SmpReferenceKnownSubSys(KnownSubSys);
               break;
        } else {
            KnownSubSys = NULL;
        }
    }

    //
    // Unlock known subsystems.
    //

    RtlLeaveCriticalSection(&SmpKnownSubSysLock);

    return KnownSubSys;
}


PSMPKNOWNSUBSYS
SmpLocateKnownSubSysByType(
    IN ULONG MuSessionId,
    IN ULONG ImageType
    )

/*++

Routine Description:

    This function scans the known subsystem table looking for
    a matching image type.

Arguments:

    ImageType - Supplies the image type whose subsystem is to be located.

Return Value:

    NULL - The image type does not match a known subsystem.

    NON-NULL - Returns the address of the known subsystem.

--*/

{

    PSMPKNOWNSUBSYS KnownSubSys = NULL;
    PLIST_ENTRY Next;

    //
    // Aquire known subsystem lock
    //

    RtlEnterCriticalSection(&SmpKnownSubSysLock);

    Next = SmpKnownSubSysHead.Flink;

    while ( Next != &SmpKnownSubSysHead ) {

        KnownSubSys = CONTAINING_RECORD(Next,SMPKNOWNSUBSYS,Links);
        Next = Next->Flink;


            if ( (KnownSubSys->ImageType == ImageType) &&
             !KnownSubSys->Deleting                &&
               (KnownSubSys->MuSessionId == MuSessionId) ) {
                SmpReferenceKnownSubSys(KnownSubSys);
                break;
        } else {
            KnownSubSys = NULL;
        }
    }

    //
    // Unlock known subsystems.
    //

    RtlLeaveCriticalSection(&SmpKnownSubSysLock);

    return KnownSubSys;
}

ENUMSECURITYCONTEXT
SmpClientSecurityContext (
    IN PPORT_MESSAGE Message,
    IN HANDLE ServerPortHandle
    )
/*++

Routine Description:

    Impersonate the client and check if it is running under system security context

Arguments:

 PPORT_MESSAGE          - LPC message pointer
 ServerPortHandle       - LPC Port Handle

Return Value:

 SYSTEM_CONTEXT - Client is running under system LUID
 NONSYSTEM_CONTEXT - Failure or client is not running under system LUID

--*/

{
    NTSTATUS NtStatus ;
    HANDLE ImpersonationToken;
    HANDLE TokenHandle;
    TOKEN_STATISTICS TokenStatisticsInformation;
    ULONG Size;
    ENUMSECURITYCONTEXT retval = NONSYSTEM_CONTEXT;
    LUID SystemAuthenticationId = SYSTEM_LUID;
    

    NtStatus = NtImpersonateClientOfPort(ServerPortHandle,
                                        Message);

    if (!NT_SUCCESS(NtStatus)) {

#if DBG
        KdPrint(( "SMSS: NtImpersonateClientOfPort failed: 0x%lX\n",
                        NtStatus)) ;
#endif

        return NONSYSTEM_CONTEXT ;
    }

    //
    // Get the Token Handle.
    //

    if (NT_SUCCESS(NtOpenThreadToken (NtCurrentThread(),
                                     TOKEN_IMPERSONATE | TOKEN_QUERY,
                                     FALSE,
                                     &TokenHandle) == FALSE)) {

        
        if (NT_SUCCESS(NtQueryInformationToken(
                                 TokenHandle,
                                 TokenStatistics,
                                 &TokenStatisticsInformation,
                                 sizeof(TokenStatisticsInformation),
                                 &Size
                                 ))) {

            if ( RtlEqualLuid ( &TokenStatisticsInformation.AuthenticationId,
                                    &SystemAuthenticationId ) ) {

                retval = SYSTEM_CONTEXT;

            }
                

        }

        
        NtClose(TokenHandle);


    } else {

#if DBG
        KdPrint(( "SMSS:  OpenThreadToken failed\n")) ;
#endif

    }


    //
    //Revert to Self
    //
    
    ImpersonationToken = 0;

    NtStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &ImpersonationToken,
                                      sizeof(HANDLE));

#if DBG
    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(( "SMSS:  NtSetInformationThread : %lx\n", NtStatus));
    }
#endif // DBG


    return retval;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smsbapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smsbapi.c

Abstract:

    Session Manager stubs which call subsystems.

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"

#if DBG
PCHAR SmpSubSystemNames[] = {
    "Unknown",
    "Native",
    "Windows",
    "Posix",
    "OS/2"
};
#endif

NTSTATUS
SmpSbCreateSession (
    IN PSMPSESSION SourceSession OPTIONAL,
    IN PSMPKNOWNSUBSYS CreatorSubsystem OPTIONAL,
    IN PRTL_USER_PROCESS_INFORMATION ProcessInformation,
    IN ULONG DebugSession OPTIONAL,
    IN PCLIENT_ID DebugUiClientId OPTIONAL
    )
{
    NTSTATUS st;
    PSMPKNOWNSUBSYS KnownSubSys;
    SBAPIMSG SbApiMsg;
    PSBCREATESESSION args;
    ULONG SessionId;
    PSMPPROCESS Process;
    ULONG MuSessionId;

    args = &SbApiMsg.u.CreateSession;

    args->ProcessInformation = *ProcessInformation;
    args->DebugSession = DebugSession;

    if (ARGUMENT_PRESENT(DebugUiClientId)) {
        args->DebugUiClientId = *DebugUiClientId;
    } else {
        args->DebugUiClientId.UniqueProcess = NULL;
        args->DebugUiClientId.UniqueThread = NULL;
    }

    //
    // Get MuSessionId for the target process.
    //

    SmpGetProcessMuSessionId( ProcessInformation->Process, &MuSessionId );

    if ( !SmpCheckDuplicateMuSessionId( MuSessionId ) ) {
        NtClose(ProcessInformation->Process);
        NtClose(ProcessInformation->Thread);
        KdPrint(( "SMSS: CreateSession status=%x\n", STATUS_OBJECT_NAME_NOT_FOUND ));
        return( STATUS_OBJECT_NAME_NOT_FOUND );
    }
    KnownSubSys = SmpLocateKnownSubSysByType(
                      MuSessionId,
                      ProcessInformation->ImageInformation.SubSystemType
                      );

    //
    // If we can't find the sybsystem, we just fail.
    //
    if ( !KnownSubSys ) {

        if (ProcessInformation->ImageInformation.SubSystemType !=
                IMAGE_SUBSYSTEM_NATIVE ) {
#if DBG
            DbgPrint( "SMSS: %s SubSystem has not been started.\n",
                      SmpSubSystemNames[ ProcessInformation->ImageInformation.SubSystemType ]
                    );
#endif
            NtClose(ProcessInformation->Process);
            NtClose(ProcessInformation->Thread);
            return STATUS_UNSUCCESSFUL;
        }


        if ( args->DebugUiClientId.UniqueProcess != NULL ||
             args->DebugUiClientId.UniqueThread != NULL ) {

            if ( SmpDbgSsLoaded ) {

                //
                // This is a native process.
                // Create a process and insert it in the hash list.
                //

                Process = RtlAllocateHeap(SmpHeap, MAKE_TAG( SM_TAG ), sizeof(SMPPROCESS));
                if (! Process) {
#if DBG
                  DbgPrint("Unable to initialize debugging for Native App %lx.%lx -- out of memory\n",
                           ProcessInformation->ClientId.UniqueProcess,
                           ProcessInformation->ClientId.UniqueThread);
#endif
                  NtClose(ProcessInformation->Process);
                  NtClose(ProcessInformation->Thread);
                  return STATUS_NO_MEMORY;
                }
                
                Process->DebugUiClientId = args->DebugUiClientId;
                Process->ConnectionKey = ProcessInformation->ClientId;

                InsertHeadList(&NativeProcessList,&Process->Links);

#if DBG
                DbgPrint("Native Debug App %lx.%lx\n",
                         Process->ConnectionKey.UniqueProcess,
                         Process->ConnectionKey.UniqueThread
                  );
#endif

                //
                // Process is being debugged, so set up debug port.
                //

                st = NtSetInformationProcess(
                  ProcessInformation->Process,
                  ProcessDebugPort,
                  &SmpDebugPort,
                  sizeof(HANDLE)
                  );

                ASSERT(NT_SUCCESS(st));
            }
        }

        //
        // Start closing handles.
        //

        NtClose(ProcessInformation->Process);

        NtResumeThread(ProcessInformation->Thread,NULL);

        NtClose(ProcessInformation->Thread);

        return STATUS_SUCCESS;
    }


    //
    // Transfer the handles to the subsystem responsible for this process.
    //

    st = NtDuplicateObject(
            NtCurrentProcess(),
            ProcessInformation->Process,
            KnownSubSys->Process,
            &args->ProcessInformation.Process,
            PROCESS_ALL_ACCESS,
            0,
            0
            );

    if ( !NT_SUCCESS(st) ) {

#if DBG
        DbgPrint("SmpSbCreateSession: NtDuplicateObject (Process) Failed %lx\n",st);
#endif

        NtClose(ProcessInformation->Process);
        NtClose(ProcessInformation->Thread);
        RtlEnterCriticalSection( &SmpKnownSubSysLock );
        SmpDeferenceKnownSubSys(KnownSubSys);
        RtlLeaveCriticalSection( &SmpKnownSubSysLock );
        return st;
    }

    st = NtDuplicateObject(
            NtCurrentProcess(),
            ProcessInformation->Thread,
            KnownSubSys->Process,
            &args->ProcessInformation.Thread,
            THREAD_ALL_ACCESS,
            0,
            0
            );

    if ( !NT_SUCCESS(st) ) {

        //
        // Need to do more here.
        //

        NtClose(ProcessInformation->Process);
        NtClose(ProcessInformation->Thread);
        RtlEnterCriticalSection( &SmpKnownSubSysLock );
        SmpDeferenceKnownSubSys(KnownSubSys);
        RtlLeaveCriticalSection( &SmpKnownSubSysLock );
#if DBG
        DbgPrint("SmpSbCreateSession: NtDuplicateObject (Thread) Failed %lx\n",st);
#endif
        return st;
    }

    NtClose(ProcessInformation->Process);
    NtClose(ProcessInformation->Thread);

    SessionId = SmpAllocateSessionId(
                    KnownSubSys,
                    CreatorSubsystem
                    );

    args->SessionId = SessionId;

    SbApiMsg.ApiNumber = SbCreateSessionApi;
    SbApiMsg.h.u1.s1.DataLength = sizeof(*args) + 8;
    SbApiMsg.h.u1.s1.TotalLength = sizeof(SbApiMsg);
    SbApiMsg.h.u2.ZeroInit = 0L;

    st = NtRequestWaitReplyPort(
            KnownSubSys->SbApiCommunicationPort,
            (PPORT_MESSAGE) &SbApiMsg,
            (PPORT_MESSAGE) &SbApiMsg
            );

    if ( NT_SUCCESS(st) ) {
        st = SbApiMsg.ReturnedStatus;
    } else {
#if DBG
        DbgPrint("SmpSbCreateSession: NtRequestWaitReply Failed %lx\n",st);
#endif
    }

    if ( !NT_SUCCESS(st) ) {
        SmpDeleteSession(SessionId);
    }
    RtlEnterCriticalSection( &SmpKnownSubSysLock );
    SmpDeferenceKnownSubSys(KnownSubSys);
    RtlLeaveCriticalSection( &SmpKnownSubSysLock );
    return st;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smsesnid.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smsesnid.c

Abstract:

    Session Manager Session ID Management

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"
#include <string.h>


ULONG
SmpAllocateSessionId(
    IN PSMPKNOWNSUBSYS OwningSubsystem,
    IN PSMPKNOWNSUBSYS CreatorSubsystem OPTIONAL
    )

/*++

Routine Description:

    This function allocates a session ID.

Arguments:

    OwningSubsystem - Supplies the address of the subsystem that should
        become the owner of this session.

    CreatorSubsystem - An optional parameter that supplies
        the address of the subsystem requesting the creation of this
        session.  This subsystem is notified when the session completes.

Return Value:

    This function returns the session ID for this session.

--*/

{

    ULONG SessionId;
    PLIST_ENTRY SessionIdListInsertPoint;
    PSMPSESSION Session;

    RtlEnterCriticalSection(&SmpSessionListLock);

    //
    // SessionIds are allocated by incrementing a 32 bit counter.
    // If the counter wraps, then session IDs are allocated by
    // scanning the sorted list of current session IDs for a hole.
    //

    SessionId = SmpNextSessionId++;
    SessionIdListInsertPoint = SmpSessionListHead.Blink;

    if ( !SmpNextSessionIdScanMode ) {

        if ( SmpNextSessionId == 0 ) {

            //
            // We have used up 32 bits worth of session IDs so
            // enable scan mode session ID allocation.
            //

            SmpNextSessionIdScanMode = TRUE;
        }

    } else {

        //
        // Compute a session ID by scanning the sorted session ID list
        // until a hole is found. When an ID is found, then save it,
        // and recalculate the insert point.
        //

#if DBG
        DbgPrint("SMSS: SessionId's Wrapped\n");
        DbgBreakPoint();
#endif

    }

    Session = RtlAllocateHeap(SmpHeap, MAKE_TAG( SM_TAG ), sizeof(SMPSESSION));

    if (Session) {
      Session->SessionId = SessionId;
      Session->OwningSubsystem = OwningSubsystem;
      Session->CreatorSubsystem = CreatorSubsystem;

      InsertTailList(SessionIdListInsertPoint,&Session->SortedSessionIdListLinks);
    } else {
      DbgPrint("SMSS: Unable to keep track of session ID -- no memory available\n");
    }
    
    RtlLeaveCriticalSection(&SmpSessionListLock);

    return SessionId;
}


PSMPSESSION
SmpSessionIdToSession(
    IN ULONG SessionId
    )

/*++

Routine Description:

    This function locates the session structure for the specified
    session ID.

    It is assumed that the caller holds the session list lock.

Arguments:

    SessionId - Supplies the session ID to locate the structure for.

Return Value:

    NULL - No session matches the specified session.

    NON-NULL - Returns a pointer to the session structure associated with
        the specified session ID.

--*/

{

    PLIST_ENTRY Next;
    PSMPSESSION Session;

    Next = SmpSessionListHead.Flink;
    while ( Next != &SmpSessionListHead ) {
        Session = CONTAINING_RECORD(Next, SMPSESSION, SortedSessionIdListLinks );

        if ( Session->SessionId == SessionId ) {
            return Session;
        }
        Next = Session->SortedSessionIdListLinks.Flink;
    }

    return NULL;
}


VOID
SmpDeleteSession(
    IN ULONG SessionId
    )

/*++

Routine Description:

    This function locates and deletes a session ID.

Arguments:

    SessionId - Supplies the session ID to delete.

Return Value:

    None.

--*/

{
    PSMPSESSION Session;

    RtlEnterCriticalSection(&SmpSessionListLock);

    Session = SmpSessionIdToSession(SessionId);

    if ( Session ) {

        RemoveEntryList(&Session->SortedSessionIdListLinks);

        RtlLeaveCriticalSection(&SmpSessionListLock);

        RtlFreeHeap(SmpHeap,0,Session);

    } else {

        RtlLeaveCriticalSection(&SmpSessionListLock);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smsmapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smsmapi.c

Abstract:

    Implementation of Session Manager Sm APIs.

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"


NTSTATUS
SmpCreateForeignSession(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )
{
    UNREFERENCED_PARAMETER (SmApiMsg);
    UNREFERENCED_PARAMETER (CallingClient);
    UNREFERENCED_PARAMETER (CallPort);

    return STATUS_NOT_IMPLEMENTED;
}





NTSTATUS
SmpSessionComplete(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )

/*++

Routine Description:

    This API is called by a subsystem to report that a session is
    complete. A check is made to ensure that the calling subsystem
    owns the completed session. If so then the session is deleted.

Arguments:

    SmApiMsg - Supplies the API message.

    CallingClient - Supplies the address of the context block for the calling
        client.

    CallPort  - The port over which the call was received.

Return Value:

    NTSTATUS.

--*/

{
    PSMPSESSION Session;
    PSMSESSIONCOMPLETE args;
    NTSTATUS st;

    UNREFERENCED_PARAMETER (CallPort);

    args = &SmApiMsg->u.SessionComplete;

    RtlEnterCriticalSection(&SmpSessionListLock);

    Session = SmpSessionIdToSession(args->SessionId);

    RtlLeaveCriticalSection(&SmpSessionListLock);

    //
    // If a session is found, then ensure that calling subsystem is its
    // owner.
    //

    if ( Session ) {

        if ( Session->OwningSubsystem == CallingClient->KnownSubSys ) {

            SmpDeleteSession(args->SessionId);
            st = STATUS_SUCCESS;

        } else {

            st = STATUS_INVALID_PARAMETER;

        }

    } else {

        st = STATUS_INVALID_PARAMETER;

    }

    return st;
}


NTSTATUS
SmpTerminateForeignSession(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )
{
    UNREFERENCED_PARAMETER (SmApiMsg);
    UNREFERENCED_PARAMETER (CallingClient);
    UNREFERENCED_PARAMETER (CallPort);

    return STATUS_NOT_IMPLEMENTED;
}




NTSTATUS
SmpExecPgm(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )
{
    NTSTATUS st;
    HANDLE SourceProcess;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSMEXECPGM args;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PCLIENT_ID DebugUiClientId;

    UNREFERENCED_PARAMETER (CallingClient);
    UNREFERENCED_PARAMETER (CallPort);

    //
    // Open a handle to the calling process so the
    // handles that it is passing can be duplicated.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    st = NtOpenProcess(
            &SourceProcess,
            PROCESS_DUP_HANDLE,
            &ObjectAttributes,
            &SmApiMsg->h.ClientId
            );

    if (!NT_SUCCESS(st) ) {
        DbgPrint("SmExecPgm: NtOpenProcess Failed %lx\n",st);
        return st;
    }

    args = &SmApiMsg->u.ExecPgm;

    ProcessInformation = args->ProcessInformation;

    //
    // Get all handles in our table.
    //

    st = NtDuplicateObject(
            SourceProcess,
            args->ProcessInformation.Process,
            NtCurrentProcess(),
            &ProcessInformation.Process,
            PROCESS_ALL_ACCESS,
            0,
            0
            );

    if ( !NT_SUCCESS(st) ) {
        NtClose(SourceProcess);
        DbgPrint("SmExecPgm: NtDuplicateObject (Process) Failed %lx\n",st);
        return st;
    }

    st = NtDuplicateObject(
            SourceProcess,
            args->ProcessInformation.Thread,
            NtCurrentProcess(),
            &ProcessInformation.Thread,
            THREAD_ALL_ACCESS,
            0,
            0
            );

    if ( !NT_SUCCESS(st) ) {
        NtClose(ProcessInformation.Process);
        NtClose(SourceProcess);
        DbgPrint("SmExecPgm: NtDuplicateObject (Thread) Failed %lx\n",st);
        return st;
    }

    //
    // Done getting the handles, so close our handle to the calling
    // process and call the appropriate subsystem to start the process.
    //

    NtClose(SourceProcess);

    //
    // All handles passed are closed by SmpSbCreateSession.
    //

    if ( args->DebugFlag ) {
        DebugUiClientId = &SmApiMsg->h.ClientId;
    } else {
        DebugUiClientId = NULL;
    }

    st = SmpSbCreateSession(
            NULL,
            NULL,
            &ProcessInformation,
            0L,
            DebugUiClientId
            );

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smpartit.c ===
#if defined(REMOTE_BOOT)
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sminit.c

Abstract:

    Session Manager Initialization

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"
#include <stdio.h>
#include <string.h>
#include <safeboot.h>
#include <ntdddisk.h>


VOID
SmpGetHarddiskBootPartition(
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber
    )
/*++

Routine Description:

    This routine searches the each partition on each hard disk for
    one which has the active bit set, returning the first one encountered.

Arguments:

    DiskNumber - The harddisk number.

    PartitionNumber - The partition number.

Return Value:

    None

--*/

{
    PARTITION_INFORMATION PartitionInfo;
    WCHAR NameBuffer[80];
    HANDLE Handle;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;

    *DiskNumber = 0;
    while (TRUE) {

        //
        // First check if there is any disk there at all by opening partition 0
        //
        *PartitionNumber = 0;

        swprintf(NameBuffer, L"\\Device\\Harddisk%d\\Partition%d", *DiskNumber, *PartitionNumber);

        RtlInitUnicodeString(&UnicodeString, NameBuffer);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        Status = NtCreateFile( &Handle,
                               (ACCESS_MASK)FILE_GENERIC_READ,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0
                             );

        if (!NT_SUCCESS(Status)) {
            KdPrint(("SMSS: GetBootPartition: Harddisk%d\\Partition0 for read failed (Status 0x%x).\n", *DiskNumber, Status));
            *PartitionNumber = 1;
            *DiskNumber = 0;
            return;
        }

        NtClose(Handle);

        //
        // Now, for each partition, check if it is marked 'active'
        //
        while (TRUE) {

            *PartitionNumber = *PartitionNumber + 1;

            swprintf(NameBuffer, L"\\Device\\Harddisk%d\\Partition%d", *DiskNumber, *PartitionNumber);

            RtlInitUnicodeString(&UnicodeString, NameBuffer);

            InitializeObjectAttributes(
                &ObjectAttributes,
                &UnicodeString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );


            Status = NtCreateFile( &Handle,
                                   (ACCESS_MASK)FILE_GENERIC_READ,
                                   &ObjectAttributes,
                                   &IoStatus,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0
                                 );

            if (!NT_SUCCESS(Status)) {
                break;
            }

            Status = NtDeviceIoControlFile(Handle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatus,
                                           IOCTL_DISK_GET_PARTITION_INFO,
                                           NULL,
                                           0,
                                           &PartitionInfo,
                                           sizeof(PARTITION_INFORMATION)
                                          );

            NtClose(Handle);

            if (!NT_SUCCESS(Status)) {
                break;
            }

            if (PartitionInfo.BootIndicator) {
                return;
            }

        }
        *DiskNumber = *DiskNumber + 1;
    }

}

VOID
SmpPartitionDisk(
    IN ULONG DiskNumber,
    OUT PULONG PartitionNumber
    )
/*++

Routine Description:

    This routine

Arguments:

    DiskNumber - The harddisk number.

    PartitionNumber - The partition number.

Return Value:

    None

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    PUCHAR AlignedBuffer;
    ULONG Length;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    PDRIVE_LAYOUT_INFORMATION OrigDriveLayout;
    PPARTITION_INFORMATION Pte;
    PPARTITION_INFORMATION StartPte;
    ULONG LargestPart;
    ULONG StartPart;
    ULONG Part;
    LARGE_INTEGER LargestBlock;
    LARGE_INTEGER OffsetEnd;
    UCHAR TmpBuffer[80];
    NTSTATUS Status;
    BOOLEAN MadeChanges;
    BOOLEAN WasEnabled;

    //
    // Get the layout of the drive.
    //
    swprintf((PWSTR)TmpBuffer, L"\\Device\\Harddisk%d\\Partition0", DiskNumber);

    RtlInitUnicodeString(&UnicodeString, (PWSTR)TmpBuffer);

    InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );


    Status = NtCreateFile( &Handle,
                           (ACCESS_MASK)FILE_GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0
                         );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SMSS: Could not open Harddisk%d\\Partition0 for read (Status 0x%x).\n", DiskNumber, Status));
        return;
    }


    //
    // We really only need 4 partition numbers worth, but for debugging
    // purposes I want to see more than just the first 4, so get the first 20.
    //

    Length = sizeof(DRIVE_LAYOUT_INFORMATION) + 20 * sizeof(PARTITION_INFORMATION);

    DriveLayout = (PDRIVE_LAYOUT_INFORMATION)RtlAllocateHeap(RtlProcessHeap(),
                                                             MAKE_TAG( INIT_TAG ),
                                                             Length
                                                            );

    if (DriveLayout == NULL) {
        KdPrint(("SMSS: Could not allocate memory for drive layout (Status 0x%x).\n", Status));
        NtClose(Handle);
        return;
    }

    OrigDriveLayout = (PDRIVE_LAYOUT_INFORMATION)RtlAllocateHeap(RtlProcessHeap(),
                                                                 MAKE_TAG( INIT_TAG ),
                                                                 Length
                                                                );

    if (OrigDriveLayout == NULL) {
        KdPrint(("SMSS: Could not allocate memory for drive layout 2 (Status 0x%x).\n", Status));
        RtlFreeHeap( RtlProcessHeap(), 0, DriveLayout );
        NtClose(Handle);
        return;
    }

    Status = NtDeviceIoControlFile(
               Handle,
               NULL,
               NULL,
               NULL,
               &IoStatusBlock,
               IOCTL_DISK_GET_DRIVE_LAYOUT,
               NULL,
               0,
               (PUCHAR)DriveLayout,
               Length
               );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SMSS: Could not get drive layout (Status 0x%x).\n", Status));
        RtlFreeHeap( RtlProcessHeap(), 0, OrigDriveLayout );
        RtlFreeHeap( RtlProcessHeap(), 0, DriveLayout );
        NtClose(Handle);
        return;
    }

    memcpy(OrigDriveLayout, DriveLayout, Length);

#if DBG

    KdPrint(("SMSS:Starting drive layout\n"));
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        KdPrint(("SMSS: Partition: %d\n", Part + 1));
        KdPrint(("SMSS: Pte->PartitionType = 0x%x\n", Pte->PartitionType));
        KdPrint(("SMSS: Pte->StartingOffset = 0x%x\n", Pte->StartingOffset));
        KdPrint(("SMSS: Pte->PartitionLength = 0x%x\n", Pte->PartitionLength));
        KdPrint(("SMSS: Pte->HiddenSectors = 0x%x\n", Pte->HiddenSectors));
        KdPrint(("SMSS: Pte->PartitionNumber = 0x%x\n", Pte->PartitionNumber));
        KdPrint(("SMSS: Pte->BootIndicator = 0x%x\n", Pte->BootIndicator));
        KdPrint(("SMSS: Pte->RecognizedPartition = 0x%x\n\n", Pte->RecognizedPartition));

    }

#endif


    //
    // Just ignore extended partitions
    //
    DriveLayout->PartitionCount = 4;

    //
    // Go thru the partitions, and for any recognized type, label it as unused.
    //
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        if (!IsRecognizedPartition(Pte->PartitionType) &&
            !IsContainerPartition(Pte->PartitionType)) {
            continue;
        }

        Pte->PartitionType = PARTITION_ENTRY_UNUSED;
        Pte->BootIndicator = FALSE;
    }


#if DBG

    KdPrint(("SMSS: Layout after clearing known partitions.\n"));
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        KdPrint(("SMSS: Partition: %d\n", Part + 1));
        KdPrint(("SMSS: Pte->PartitionType = 0x%x\n", Pte->PartitionType));
        KdPrint(("SMSS: Pte->StartingOffset = 0x%x\n", Pte->StartingOffset));
        KdPrint(("SMSS: Pte->PartitionLength = 0x%x\n", Pte->PartitionLength));
        KdPrint(("SMSS: Pte->HiddenSectors = 0x%x\n", Pte->HiddenSectors));
        KdPrint(("SMSS: Pte->PartitionNumber = 0x%x\n", Pte->PartitionNumber));
        KdPrint(("SMSS: Pte->BootIndicator = 0x%x\n", Pte->BootIndicator));
        KdPrint(("SMSS: Pte->RecognizedPartition = 0x%x\n\n", Pte->RecognizedPartition));

    }

#endif

    //
    // Merge unused partitions that are adjacent.
    //
    for (StartPart = 0; StartPart < DriveLayout->PartitionCount; StartPart++) {

        StartPte = &(DriveLayout->PartitionEntry[StartPart]);

        if ((StartPte->PartitionType != PARTITION_ENTRY_UNUSED) ||
            RtlLargeIntegerEqualTo(StartPte->PartitionLength, RtlConvertUlongToLargeInteger(0))) {
            continue;
        }

        OffsetEnd = RtlLargeIntegerAdd(StartPte->StartingOffset, StartPte->PartitionLength);

        for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

            if (Part == StartPart) {
                continue;
            }

            Pte = &(DriveLayout->PartitionEntry[Part]);

            if (RtlLargeIntegerEqualTo(OffsetEnd, Pte->StartingOffset)) {

                //
                // Merge the blocks
                //
                StartPte->PartitionLength = RtlLargeIntegerAdd(StartPte->PartitionLength,
                                                               Pte->PartitionLength
                                                              );
                OffsetEnd = RtlLargeIntegerAdd(OffsetEnd, Pte->PartitionLength);

                Pte->PartitionType = PARTITION_ENTRY_UNUSED;
                Pte->StartingOffset = RtlConvertUlongToLargeInteger(0);
                Pte->PartitionLength = RtlConvertUlongToLargeInteger(0);
                Pte->HiddenSectors = 0;
                Pte->PartitionNumber = 0;
                Pte->BootIndicator = FALSE;
                Pte->RecognizedPartition = FALSE;
                Part = (ULONG)-1; // will get ++'d to 0 at the bottom of the loop.

            }
        }

    }

    //
    // Find the largest block that is unused.
    //

    LargestPart = 0;
    LargestBlock = RtlConvertUlongToLargeInteger(0);
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        if ((Pte->PartitionType == PARTITION_ENTRY_UNUSED) &&
            RtlLargeIntegerGreaterThan(Pte->PartitionLength, LargestBlock)) {
            LargestPart = Part;
            LargestBlock = Pte->PartitionLength;
        }

    }

#if DBG

    KdPrint(("SMSS: Layout after merging largest block.\n"));
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        KdPrint(("SMSS: Partition: %d\n", Part + 1));
        KdPrint(("SMSS: Pte->PartitionType = 0x%x\n", Pte->PartitionType));
        KdPrint(("SMSS: Pte->StartingOffset = 0x%x\n", Pte->StartingOffset));
        KdPrint(("SMSS: Pte->PartitionLength = 0x%x\n", Pte->PartitionLength));
        KdPrint(("SMSS: Pte->HiddenSectors = 0x%x\n", Pte->HiddenSectors));
        KdPrint(("SMSS: Pte->PartitionNumber = 0x%x\n", Pte->PartitionNumber));
        KdPrint(("SMSS: Pte->BootIndicator = 0x%x\n", Pte->BootIndicator));
        KdPrint(("SMSS: Pte->RecognizedPartition = 0x%x\n\n", Pte->RecognizedPartition));

    }

#endif


    //
    // Set the partition type for the new partition
    //
    DriveLayout->PartitionEntry[LargestPart].PartitionType = PARTITION_IFS;
    DriveLayout->PartitionEntry[LargestPart].BootIndicator = TRUE;

#if DBG

    KdPrint(("SMSS: Final Layout\n"));
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        Pte = &(DriveLayout->PartitionEntry[Part]);

        KdPrint(("SMSS: Partition: %d\n", Part + 1));
        KdPrint(("SMSS: Pte->PartitionType = 0x%x\n", Pte->PartitionType));
        KdPrint(("SMSS: Pte->StartingOffset = 0x%x\n", Pte->StartingOffset));
        KdPrint(("SMSS: Pte->PartitionLength = 0x%x\n", Pte->PartitionLength));
        KdPrint(("SMSS: Pte->HiddenSectors = 0x%x\n", Pte->HiddenSectors));
        KdPrint(("SMSS: Pte->PartitionNumber = 0x%x\n", Pte->PartitionNumber));
        KdPrint(("SMSS: Pte->BootIndicator = 0x%x\n", Pte->BootIndicator));
        KdPrint(("SMSS: Pte->RecognizedPartition = 0x%x\n\n", Pte->RecognizedPartition));

    }

#endif


    MadeChanges = FALSE;
    for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {

        if (memcmp(&(DriveLayout->PartitionEntry[Part]),
            &(OrigDriveLayout->PartitionEntry[Part]),
            sizeof(PARTITION_INFORMATION))) {
            MadeChanges = TRUE;
            break;
        }

    }

    if (MadeChanges) {

        KdPrint(("SMSS: Repartitioning disk.\n"));

        //
        // Mark partitions for rewrite.
        //

        for (Part = 0; Part < DriveLayout->PartitionCount; Part++) {
            DriveLayout->PartitionEntry[Part].RewritePartition = TRUE;
        }

        //
        // Submit IOCTL to set new partition information
        //
        Status = NtDeviceIoControlFile(
                   Handle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   IOCTL_DISK_SET_DRIVE_LAYOUT,
                   DriveLayout,
                   Length,
                   NULL,
                   0
                   );

        if (!NT_SUCCESS(Status)) {
            RtlFreeHeap( RtlProcessHeap(), 0, OrigDriveLayout );
            RtlFreeHeap( RtlProcessHeap(), 0, DriveLayout );
            NtClose(Handle);
            KdPrint(("SMSS: Could not set drive layout (Status 0x%x).\n", Status));
            return;
        }
    }

    *PartitionNumber = DriveLayout->PartitionEntry[LargestPart].PartitionNumber;

    RtlFreeHeap( RtlProcessHeap(), 0, OrigDriveLayout );
    RtlFreeHeap( RtlProcessHeap(), 0, DriveLayout );
    NtClose(Handle);
    return;
}


VOID
SmpFindCSCPartition(
    IN ULONG DiskNumber,
    OUT PULONG PartitionNumber
    )
/*++

Routine Description:

    This routine searches the each partition on each hard disk for
    one which has the CSC directory.

Arguments:

    DiskNumber - The harddisk number.

    PartitionNumber - The partition number.  Will be 0 if no CSC directory is found on the disk.

Return Value:

    None

--*/

{
    WCHAR NameBuffer[80];
    HANDLE Handle;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    ULONG Part;

    Part = 0;
    *PartitionNumber = 0;
    while (TRUE) {

        Part++;

        //
        // First see if the partition exists by opening it.
        //
        swprintf(NameBuffer,
                 L"\\Device\\Harddisk%d\\Partition%d",
                 DiskNumber,
                 Part
                );

        RtlInitUnicodeString(&UnicodeString, NameBuffer);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile( &Handle,
                               (ACCESS_MASK)FILE_GENERIC_READ,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0
                             );

        if (!NT_SUCCESS(Status)) {
            return;
        }

        NtClose(Handle);

        wcscat(NameBuffer, REMOTE_BOOT_IMIRROR_PATH_W REMOTE_BOOT_CSC_SUBDIR_W);

        RtlInitUnicodeString(&UnicodeString, NameBuffer);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtOpenFile(&Handle,
                            FILE_READ_DATA | SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatus,
                            FILE_SHARE_READ,
                            FILE_DIRECTORY_FILE
                           );

        if (NT_SUCCESS(Status)) {
            NtClose(Handle);
            *PartitionNumber = Part;
            return;
        }

    }

}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smss.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smss.c

Abstract:


Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"

#if defined(REMOTE_BOOT)
char SmpFormatKeyword[] = "NETBOOTFORMAT";
char SmpDisconnectedKeyword[] = "NETBOOTDISCONNECTED";
char SmpNetbootKeyword[] = "NETBOOT";
char SmpHalKeyword[] = "NETBOOTHAL";

BOOLEAN SmpAutoFormat = FALSE;
BOOLEAN SmpNetboot = FALSE;
BOOLEAN SmpNetbootDisconnected = FALSE;
char SmpHalName[MAX_HAL_NAME_LENGTH + 1] = "";
#endif // defined(REMOTE_BOOT)

void
SmpTerminate(
    ULONG_PTR       Parameters[]
    );

EXCEPTION_DISPOSITION
SmpUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    ULONG_PTR                   Parameters[]
    );

void
__cdecl main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    )
{
    NTSTATUS Status;
    KPRIORITY SetBasePriority;
    UNICODE_STRING InitialCommand, DebugInitialCommand, UnicodeParameter;
    HANDLE ProcessHandles[ 2 ];
    ULONG_PTR Parameters[ 4 ];
    PROCESS_BASIC_INFORMATION ProcessInfo;
    ULONG MuSessionId = 0; // First instance (console) has MuSessionId = 0

    RtlSetProcessIsCritical(TRUE, NULL, TRUE);
    RtlSetThreadIsCritical(TRUE, NULL, TRUE);

    SetBasePriority = FOREGROUND_BASE_PRIORITY+2;

    Status = NtSetInformationProcess( NtCurrentProcess(),
                                      ProcessBasePriority,
                                      (PVOID) &SetBasePriority,
                                       sizeof( SetBasePriority )
                                    );
    ASSERT(NT_SUCCESS(Status));


    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) DebugParameter )) {
        SmpDebug = DebugParameter;
    }

    try {
        Parameters[ 0 ] = (ULONG_PTR)&UnicodeParameter;
        Parameters[ 1 ] = 0;
        Parameters[ 2 ] = 0;
        Parameters[ 3 ] = 0;


        Status = SmpInit( &InitialCommand, &ProcessHandles[ 0 ] );
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "SMSS: SmpInit return failure - Status == %x\n", Status ));
            RtlInitUnicodeString( &UnicodeParameter, L"Session Manager Initialization" );
            Parameters[ 1 ] = (ULONG)Status;

        } else {
            SYSTEM_FLAGS_INFORMATION FlagInfo;

            Status = NtQuerySystemInformation( SystemFlagsInformation,
                                               &FlagInfo,
                                              sizeof( FlagInfo ),
                                              NULL);

            ASSERT(NT_SUCCESS(Status));
            if (FlagInfo.Flags & (FLG_DEBUG_INITIAL_COMMAND | FLG_DEBUG_INITIAL_COMMAND_EX) ) {
                DebugInitialCommand.MaximumLength = InitialCommand.Length + 64;
                DebugInitialCommand.Length = 0;
                DebugInitialCommand.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                              MAKE_TAG( INIT_TAG ),
                                                              DebugInitialCommand.MaximumLength
                                                            );
                if (DebugInitialCommand.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    KdPrint(( "SMSS: SmpInit heap allocation failed\n"));
                } else {
                    if (FlagInfo.Flags & FLG_ENABLE_CSRDEBUG) {

                        RtlAppendUnicodeToString( &DebugInitialCommand, L"ntsd -isd -p -1 -d " );
                    } else {
                        RtlAppendUnicodeToString( &DebugInitialCommand, L"ntsd -isd -d " );
                    }

                    if (FlagInfo.Flags & FLG_DEBUG_INITIAL_COMMAND_EX ) {
                        RtlAppendUnicodeToString( &DebugInitialCommand, L"-g -x " );
                    }

                    RtlAppendUnicodeStringToString( &DebugInitialCommand, &InitialCommand );
                    InitialCommand = DebugInitialCommand;
                }
            }

            if (NT_SUCCESS( Status )) {
                Status = SmpExecuteInitialCommand( 0L, &InitialCommand, &ProcessHandles[ 1 ], NULL );
            }

            if (NT_SUCCESS( Status )) {

                //
                // Detach the session manager from the session space as soon as
                // we have executed the initial command (winlogon).
                //

                PVOID State;

                Status = SmpAcquirePrivilege( SE_LOAD_DRIVER_PRIVILEGE, &State );

                if (NT_SUCCESS( Status )) {

                    //
                    // If we are attached to a session space, leave it
                    // so we can create a new one
                    //
                    if(  (AttachedSessionId != (-1)) ) {
                        Status = NtSetSystemInformation(
                                    SystemSessionDetach,
                                    (PVOID)&AttachedSessionId,
                                    sizeof(MuSessionId)
                                    );
                        ASSERT(NT_SUCCESS(Status));
                        AttachedSessionId = (-1);
                    }

                    SmpReleasePrivilege( State );
                }

            }

            if (NT_SUCCESS( Status )) {
                Status = NtWaitForMultipleObjects( 2,
                                                   ProcessHandles,
                                                   WaitAny,
                                                   FALSE,
                                                   NULL
                                                 );
            }

            if (Status == STATUS_WAIT_0) {
                RtlInitUnicodeString( &UnicodeParameter, L"Windows SubSystem" );
                Status = NtQueryInformationProcess( ProcessHandles[ 0 ],
                                                    ProcessBasicInformation,
                                                    &ProcessInfo,
                                                    sizeof( ProcessInfo ),
                                                    NULL
                                                  );

                KdPrint(( "SMSS: Windows subsystem terminated when it wasn't supposed to.\n" ));
            } else {
                RtlInitUnicodeString( &UnicodeParameter, L"Windows Logon Process" );
                if (Status == STATUS_WAIT_1) {
                    Status = NtQueryInformationProcess( ProcessHandles[ 1 ],
                                                        ProcessBasicInformation,
                                                        &ProcessInfo,
                                                        sizeof( ProcessInfo ),
                                                        NULL
                                                      );
                } else {
                    ProcessInfo.ExitStatus = Status;
                    Status = STATUS_SUCCESS;
                }

                KdPrint(( "SMSS: Initial command '%wZ' terminated when it wasn't supposed to.\n", &InitialCommand ));
            }

            if (NT_SUCCESS( Status )) {
                Parameters[ 1 ] = (ULONG)ProcessInfo.ExitStatus;
            } else {
                Parameters[ 1 ] = (ULONG)STATUS_UNSUCCESSFUL;
            }
        }

    }    except( SmpUnhandledExceptionFilter( GetExceptionInformation(), Parameters ) ) {
            /* not reached */
    }

    SmpTerminate(Parameters);
    /* not reached */
}

void
SmpTerminate(
    ULONG_PTR Parameters[]
    )
{
    NTSTATUS Status;
    ULONG    Response;
    BOOLEAN  WasEnabled;

    //
    // We are hosed, so raise a fatal system error to shutdown the system.
    // (Basically a user mode KeBugCheck).
    //

    Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                 (BOOLEAN)TRUE,
                                 TRUE,
                                 &WasEnabled
                               );

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token.
        //

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     FALSE,
                                     &WasEnabled
                                   );
        }


    Status = NtRaiseHardError( STATUS_SYSTEM_PROCESS_TERMINATED,
                               4,
                               1,
                               Parameters,
                               OptionShutdownSystem,
                               &Response
                             );

    //
    // If this returns, give up.
    //

    NtTerminateProcess( NtCurrentProcess(), Status );
}


EXCEPTION_DISPOSITION
SmpUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    ULONG_PTR                   Parameters[]
    )
{
    UNICODE_STRING  ExUnicodeParameter;

#if DBG
    DbgPrint( "SMSS: Unhandled exception - Status == %x  IP == %x\n",
              ExceptionInfo->ExceptionRecord->ExceptionCode,
              ExceptionInfo->ExceptionRecord->ExceptionAddress
            );
    DbgPrint( "      Memory Address: %x  Read/Write: %x\n",
              ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ],
              ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ]
            );

    DbgBreakPoint();
#endif

    RtlInitUnicodeString( &ExUnicodeParameter, L"Unhandled Exception in Session Manager" );
    Parameters[ 0 ] = (ULONG_PTR)&ExUnicodeParameter;
    Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
    Parameters[ 2 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;
    Parameters[ 3 ] = (ULONG_PTR)ExceptionInfo->ContextRecord;

    //
    // SmpTerminate will raise a hard error with the exception info still valid.
    //

    SmpTerminate(Parameters);

    // not reached

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smutil.c

Abstract:

    Session Manager Utility Functions

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#include "smsrvp.h"



NTSTATUS
SmpSaveRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL,
    IN BOOLEAN CheckForDuplicate
    )
{
    PLIST_ENTRY Next;
    PSMP_REGISTRY_VALUE p;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;
    ANSI_STRING AnsiString;

    RtlInitUnicodeString( &UnicodeName, Name );
    RtlInitUnicodeString( &UnicodeValue, Value );
    if (CheckForDuplicate) {
        Next = ListHead->Flink;
        p = NULL;
        while ( Next != ListHead ) {
            p = CONTAINING_RECORD( Next,
                                   SMP_REGISTRY_VALUE,
                                   Entry
                                 );
            if (!RtlCompareUnicodeString( &p->Name, &UnicodeName, TRUE )) {
                if ((!ARGUMENT_PRESENT( Value ) && p->Value.Buffer == NULL) ||
                    (ARGUMENT_PRESENT( Value ) &&
                     !RtlCompareUnicodeString( &p->Value, &UnicodeValue, TRUE )
                    )
                   ) {
                    return( STATUS_OBJECT_NAME_EXISTS );
                }

                break;
            }

            Next = Next->Flink;
            p = NULL;
        }
    } else {
        p = NULL;
    }

    if (p == NULL) {
        p = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), sizeof( *p ) + UnicodeName.MaximumLength );
        if (p == NULL) {
            return( STATUS_NO_MEMORY );
        }

        InitializeListHead( &p->Entry );
        p->Name.Buffer = (PWSTR)(p+1);
        p->Name.Length = UnicodeName.Length;
        p->Name.MaximumLength = UnicodeName.MaximumLength;
        p->AnsiValue = NULL;
        RtlCopyMemory( p->Name.Buffer,
                       UnicodeName.Buffer,
                       UnicodeName.MaximumLength
                     );
        p->Value.Buffer = NULL;
        InsertTailList( ListHead, &p->Entry );
    }

    if (p->Value.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer );
    }

    if (ARGUMENT_PRESENT( Value )) {
        p->Value.Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ),
                                                  UnicodeValue.MaximumLength
                                                );
        if (p->Value.Buffer == NULL) {
            RemoveEntryList( &p->Entry );
            RtlFreeHeap( RtlProcessHeap(), 0, p );
            return( STATUS_NO_MEMORY );
        }

        p->Value.Length = UnicodeValue.Length;
        p->Value.MaximumLength = UnicodeValue.MaximumLength;
        RtlCopyMemory( p->Value.Buffer,
                       UnicodeValue.Buffer,
                       UnicodeValue.MaximumLength
                     );
        p->AnsiValue = (LPSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               MAKE_TAG( INIT_TAG ),
                                               (UnicodeValue.Length / sizeof( WCHAR )) + 1
                                             );
        if (p->AnsiValue == NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, p->Value.Buffer );
            RemoveEntryList( &p->Entry );
            RtlFreeHeap( RtlProcessHeap(), 0, p );
            return( STATUS_NO_MEMORY );
        }

        AnsiString.Buffer = p->AnsiValue;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = (UnicodeValue.Length / sizeof( WCHAR )) + 1;
        RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeValue, FALSE );
    } else {
        RtlInitUnicodeString( &p->Value, NULL );
    }

    return( STATUS_SUCCESS );
}



PSMP_REGISTRY_VALUE
SmpFindRegistryValue(
    IN PLIST_ENTRY ListHead,
    IN PWSTR Name
    )
{
    PLIST_ENTRY Next;
    PSMP_REGISTRY_VALUE p;
    UNICODE_STRING UnicodeName;

    RtlInitUnicodeString( &UnicodeName, Name );
    Next = ListHead->Flink;
    while ( Next != ListHead ) {
        p = CONTAINING_RECORD( Next,
                               SMP_REGISTRY_VALUE,
                               Entry
                             );
        if (!RtlCompareUnicodeString( &p->Name, &UnicodeName, TRUE )) {
            return( p );
            }

        Next = Next->Flink;
        }

    return( NULL );
}

typedef struct _SMP_ACQUIRE_STATE {
    HANDLE Token;
    PTOKEN_PRIVILEGES OldPrivileges;
    PTOKEN_PRIVILEGES NewPrivileges;
    UCHAR OldPrivBuffer[ 1024 ];
} SMP_ACQUIRE_STATE, *PSMP_ACQUIRE_STATE;

NTSTATUS
SmpAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    )
{
    PSMP_ACQUIRE_STATE State;
    ULONG cbNeeded;
    LUID LuidPrivilege;
    NTSTATUS Status;

    //
    // Make sure we have access to adjust and to get the old token privileges.
    //

    *ReturnedState = NULL;
    State = RtlAllocateHeap( RtlProcessHeap(),
                             MAKE_TAG( INIT_TAG ),
                             sizeof(SMP_ACQUIRE_STATE) +
                             sizeof(TOKEN_PRIVILEGES) +
                                (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES)
                           );
    if (State == NULL) {
        return STATUS_NO_MEMORY;
        }
    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &State->Token
                );

    if ( !NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, State );
        return Status;
        }

    State->NewPrivileges = (PTOKEN_PRIVILEGES)(State+1);
    State->OldPrivileges = (PTOKEN_PRIVILEGES)(State->OldPrivBuffer);

    //
    // Initialize the privilege adjustment structure.
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);
    State->NewPrivileges->PrivilegeCount = 1;
    State->NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    State->NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege.
    //

    cbNeeded = sizeof( State->OldPrivBuffer );
    Status = NtAdjustPrivilegesToken( State->Token,
                                      FALSE,
                                      State->NewPrivileges,
                                      cbNeeded,
                                      State->OldPrivileges,
                                      &cbNeeded
                                    );



    if (Status == STATUS_BUFFER_TOO_SMALL) {
        State->OldPrivileges = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( INIT_TAG ), cbNeeded );
        if (State->OldPrivileges  == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            Status = NtAdjustPrivilegesToken( State->Token,
                                              FALSE,
                                              State->NewPrivileges,
                                              cbNeeded,
                                              State->OldPrivileges,
                                              &cbNeeded
                                            );
            }
        }

    //
    // STATUS_NOT_ALL_ASSIGNED means that the privilege isn't
    // in the token, so we can't proceed.
    //
    // This is a warning level status, so map it to an error status.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
        }


    if (!NT_SUCCESS( Status )) {
        if (State->OldPrivileges != (PTOKEN_PRIVILEGES)(State->OldPrivBuffer)) {
            RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
            }

        NtClose( State->Token );
        RtlFreeHeap( RtlProcessHeap(), 0, State );
        return Status;
        }

    *ReturnedState = State;
    return STATUS_SUCCESS;
}


VOID
SmpReleasePrivilege(
    PVOID StatePointer
    )
{
    PSMP_ACQUIRE_STATE State = (PSMP_ACQUIRE_STATE)StatePointer;

    NtAdjustPrivilegesToken( State->Token,
                             FALSE,
                             State->OldPrivileges,
                             0,
                             NULL,
                             NULL
                           );

    if (State->OldPrivileges != (PTOKEN_PRIVILEGES)(State->OldPrivBuffer)) {
        RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
        }

    NtClose( State->Token );
    RtlFreeHeap( RtlProcessHeap(), 0, State );
    return;
}


#if SMP_SHOW_REGISTRY_DATA
VOID
SmpDumpQuery(
    IN PWSTR ModId,
    IN PCHAR RoutineName,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    )
{
    PWSTR s;

    if (ValueName == NULL) {
        DbgPrint( "%ws: SmpConfigure%s( %ws )\n", ModId, RoutineName );
        return;
        }

    if (ValueData == NULL) {
        DbgPrint( "%ws: SmpConfigure%s( %ws, %ws NULL ValueData )\n", ModId, RoutineName, ValueName );
        return;
        }

    s = (PWSTR)ValueData;
    DbgPrint( "%ws: SmpConfigure%s( %ws, %u, (%u) ", ModId, RoutineName, ValueName, ValueType, ValueLength );
    if (ValueType == REG_SZ || ValueType == REG_EXPAND_SZ || ValueType == REG_MULTI_SZ) {
        while (*s) {
            if (s != (PWSTR)ValueData) {
                DbgPrint( ", " );
                }
            DbgPrint( "'%ws'", s );
            while(*s++) {
                }
            if (ValueType != REG_MULTI_SZ) {
                break;
                }
            }
        }
    else {
        DbgPrint( "*** non-string data (%08lx)", *(PULONG)ValueData );
        }

    DbgPrint( "\n" );
}
#endif


ULONG
SmpQueryNtGlobalFlag(
    VOID
    )

/*++

Routine Description:

    This function queries the registry to get the current NtGlobalFlag value.

    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager:GlobalFlag

Arguments:

    None.

Return Value:

    Global flag value or zero.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    UCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;

    //
    // Open the registry key.
    //

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SMSS: can't open session manager key: 0x%x\n", Status));
        return 0;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString(&ValueName, L"GlobalFlag");
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        sizeof (ValueBuffer),
        &ValueLength
        );

    ASSERT(ValueLength < VALUE_BUFFER_SIZE);

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SMSS: can't query value key: 0x%x\n", Status));
        return 0;
    }

    return *((PULONG)&KeyValueInfo->Data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\smsrvp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smsrvp.h

Abstract:

    Session Manager Private Types and Prototypes

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#ifndef _SMSRVP_
#define _SMSRVP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsm.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include <stdlib.h>
#if defined(REMOTE_BOOT)
#include <remboot.h>
#endif // defined(REMOTE_BOOT)
#include "sm.h"

#pragma warning(3:4101)         // Unreferenced local variable

#define SMP_SHOW_REGISTRY_DATA 0

//
// VOID
// SmpSetDaclDefaulted(
//      IN  POBJECT_ATTRIBUTES              ObjectAttributes,
//      OUT PSECURITY_DESCRIPTOR_CONTROL    CurrentSdControl
//      )
//
// Description:
//
//      This routine will set the DaclDefaulted flag of the DACL passed
//      via the ObjectAttributes parameter.  If the ObjectAttributes do
//      not include a SecurityDescriptor, then no action is taken.
//
// Parameters:
//
//      ObjectAttributes - The object attributes whose security descriptor is
//          to have its DaclDefaulted flag set.
//
//      CurrentSdControl - Receives the current value of the security descriptor's
//          control flags.  This may be used in a subsequent call to
//          SmpRestoreDaclDefaulted() to restore the flag to its original state.
//

#define SmpSetDaclDefaulted( OA, SDC )                                          \
    if( (OA)->SecurityDescriptor != NULL) {                                     \
        (*SDC) = ((PISECURITY_DESCRIPTOR)((OA)->SecurityDescriptor))->Control &  \
                    SE_DACL_DEFAULTED;                                          \
        ((PISECURITY_DESCRIPTOR)((OA)->SecurityDescriptor))->Control |=         \
            SE_DACL_DEFAULTED;                                                  \
    }


//
// VOID
// SmpRestoreDaclDefaulted(
//      IN  POBJECT_ATTRIBUTES              ObjectAttributes,
//      IN  SECURITY_DESCRIPTOR_CONTROL     OriginalSdControl
//      )
//
// Description:
//
//      This routine will set the DaclDefaulted flag of the DACL back to
//      a prior state (indicated by the value in OriginalSdControl).
//
// Parameters:
//
//      ObjectAttributes - The object attributes whose security descriptor is
//          to have its DaclDefaulted flag restored.  If the object attributes
//          have no security descriptor, then no action is taken.
//
//      OriginalSdControl - The original value of the security descriptor's
//          control flags.  This typically is obtained via a prior call to
//          SmpSetDaclDefaulted().
//

#define SmpRestoreDaclDefaulted( OA, SDC )                                      \
    if( (OA)->SecurityDescriptor != NULL) {                                     \
        ((PISECURITY_DESCRIPTOR)((OA)->SecurityDescriptor))->Control =          \
            (((PISECURITY_DESCRIPTOR)((OA)->SecurityDescriptor))->Control  &    \
             ~SE_DACL_DEFAULTED)    |                                           \
            (SDC & SE_DACL_DEFAULTED);                                          \
    }



//
// VOID
// SmpReferenceKnownSubSys(
//      IN  PSMPKNOWNSUBSYS              KnownSubSys
//      )
//
// Description:
//
//      This routine Increments the Refcount for a KnownSubSys
//      to prevent him from being deleted while still in use.
//      The KnownSubSystem lock must be held while using thie macro
//
// Parameters:
//
//      KnownSubSys - The SMPKNOWNSUBSYS structure to referemce.
//


#define SmpReferenceKnownSubSys( KS )    KS->RefCount++ 


//
// VOID
// SmpDereferenceKnownSubSys(
//      IN  PSMPKNOWNSUBSYS              KnownSubSys
//      )
//
// Description:
//
//      This routine decrements the Refcount for a KnownSubSys
//      If the KnownSubSys is bein deleted and refcount goes to
//      Zero, then cleanup is done and KnownSubSys is freed.
//      The KnownSubSystem lock must be held while using thie macro
//
// Parameters:
//
//      KnownSubSys - The SMPKNOWNSUBSYS structure to dereference.
//


#define SmpDeferenceKnownSubSys( KS )                                  \
        if ((--KS->RefCount) == 0 && KS->Deleting) { \
            if (KS->Active) {NtClose(KS->Active);}  \
            if (KS->Process) {NtClose(KS->Process);}  \
            if (KS->SbApiCommunicationPort) {NtClose(KS->SbApiCommunicationPort);}  \
            RtlFreeHeap(SmpHeap, 0, KS); \
        }

//
// Types
//

typedef struct _SMP_REGISTRY_VALUE {
    LIST_ENTRY Entry;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    LPSTR AnsiValue;
} SMP_REGISTRY_VALUE, *PSMP_REGISTRY_VALUE;

typedef struct _SMPKNOWNSUBSYS {
    LIST_ENTRY Links;
    HANDLE Active;
    HANDLE Process;
    ULONG ImageType;
    HANDLE SmApiCommunicationPort;
    HANDLE SbApiCommunicationPort;
    CLIENT_ID InitialClientId;
    ULONG MuSessionId;
    BOOLEAN Deleting;
    ULONG RefCount;
} SMPKNOWNSUBSYS, *PSMPKNOWNSUBSYS;

typedef enum {
    UNKNOWN_CONTEXT,
    NONSYSTEM_CONTEXT,
    SYSTEM_CONTEXT
} ENUMSECURITYCONTEXT;

typedef struct _SMP_CLIENT_CONTEXT {

    struct _SMP_CLIENT_CONTEXT * Link;
    
    PSMPKNOWNSUBSYS KnownSubSys;
    HANDLE ClientProcessHandle;
    HANDLE ServerPortHandle;
    ENUMSECURITYCONTEXT SecurityContext;
} SMP_CLIENT_CONTEXT, *PSMP_CLIENT_CONTEXT;


typedef struct _SMPSESSION {
    LIST_ENTRY SortedSessionIdListLinks;
    ULONG SessionId;
    PSMPKNOWNSUBSYS OwningSubsystem;
    PSMPKNOWNSUBSYS CreatorSubsystem;
} SMPSESSION, *PSMPSESSION;

typedef struct _SMPPROCESS {
    LIST_ENTRY Links;
    CLIENT_ID DebugUiClientId;
    CLIENT_ID ConnectionKey;
} SMPPROCESS, *PSMPPROCESS;

//
// Define structure for an on-disk master boot record. (pulled from
// private\windows\setup\textmode\kernel\sppartit.h)
//
typedef struct _ON_DISK_PTE {
    UCHAR ActiveFlag;
    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;
    UCHAR SystemId;
    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;
    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];
} ON_DISK_PTE, *PON_DISK_PTE;
typedef struct _ON_DISK_MBR {
    UCHAR       BootCode[440];
    UCHAR       NTFTSignature[4];
    UCHAR       Filler[2];
    ON_DISK_PTE PartitionTable[4];
    UCHAR       AA55Signature[2];
} ON_DISK_MBR, *PON_DISK_MBR;


//
// Global Data
//

RTL_CRITICAL_SECTION SmpKnownSubSysLock;
LIST_ENTRY SmpKnownSubSysHead;

LIST_ENTRY NativeProcessList;

RTL_CRITICAL_SECTION SmpSessionListLock;
LIST_ENTRY SmpSessionListHead;
ULONG SmpNextSessionId;
BOOLEAN  SmpNextSessionIdScanMode;

ULONG SmpDebug;
HANDLE SmpDebugPort;
BOOLEAN SmpDbgSsLoaded;
PDBGSS_INITIALIZE_ROUTINE SmpDbgInitRoutine;
PDBGSS_HANDLE_MSG_ROUTINE SmpDbgHandleMsgRoutine;

UNICODE_STRING SmpSubsystemName;
UNICODE_STRING SmpKnownDllPath;
HANDLE SmpDosDevicesObjectDirectory;
HANDLE SmpSessionsObjectDirectory;

PVOID SmpHeap;

LUID SmpTcbPrivilege;

PVOID SmpDefaultEnvironment;

PTOKEN_OWNER SmpSmOwnerSid;
ULONG SmpSmOwnerSidLength;

UNICODE_STRING SmpDefaultLibPath;
WCHAR *SmpDefaultLibPathBuffer;

UNICODE_STRING SmpSystemRoot;
WCHAR *SmpSystemRootBuffer;

#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))

#if defined(REMOTE_BOOT)
#define MAX_HAL_NAME_LENGTH 30 // Keep in sync with definition in setupblk.h
extern BOOLEAN SmpAutoFormat;
extern BOOLEAN SmpRepin;
extern BOOLEAN SmpNetboot;
extern BOOLEAN SmpNetbootDisconnected;
extern CHAR SmpHalName[MAX_HAL_NAME_LENGTH + 1];
#endif // defined(REMOTE_BOOT)

extern ULONG AttachedSessionId;

//
// Session Manager Apis
//

typedef
NTSTATUS
(* PSMAPI)(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );


NTSTATUS
SmpCreateForeignSession(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

NTSTATUS
SmpSessionComplete(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

NTSTATUS
SmpTerminateForeignSession(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

NTSTATUS
SmpExecPgm(                         // Temporary Hack
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

NTSTATUS
SmpLoadDeferedSubsystem(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

NTSTATUS
SmpStartCsr(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );
NTSTATUS
SmpStopCsr(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    );

ENUMSECURITYCONTEXT
SmpClientSecurityContext (
    IN PPORT_MESSAGE Message,
    IN HANDLE ServerPortHandle
    );

//
// Private Prototypes
//

NTSTATUS
SmpExecuteInitialCommand(
    IN ULONG MuSessionId,
    IN PUNICODE_STRING InitialCommand,
    OUT PHANDLE InitialCommandProcess,
    OUT PULONG_PTR InitialCommandProcessId
    );

NTSTATUS
SmpApiLoop (
    IN PVOID ThreadParameter
    );

NTSTATUS
SmpInit(
    OUT PUNICODE_STRING InitialCommand,
    OUT PHANDLE WindowsSubSystem
    );

NTSTATUS
SmpExecuteImage(
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING CurrentDirectory,
    IN PUNICODE_STRING CommandLine,
    IN ULONG MuSessionId,
    IN ULONG Flags,
    IN OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation OPTIONAL
    );

NTSTATUS
SmpLoadDbgSs(
    IN PUNICODE_STRING DbgSsName
    );

PSMPKNOWNSUBSYS
SmpLocateKnownSubSysByCid(
    IN PCLIENT_ID ClientId
    );

PSMPKNOWNSUBSYS
SmpLocateKnownSubSysByType(
    IN ULONG MuSessionId,
    IN ULONG ImageType
    );

ULONG
SmpAllocateSessionId(
    IN PSMPKNOWNSUBSYS OwningSubsystem,
    IN PSMPKNOWNSUBSYS CreatorSubsystem OPTIONAL
    );

PSMPSESSION
SmpSessionIdToSession(
    IN ULONG SessionId
    );

VOID
SmpDeleteSession(
    IN ULONG SessionId
    );

HANDLE
SmpOpenDir(
    BOOLEAN IsDosName,
    BOOLEAN IsSynchronous,
    PWSTR DirName
    );

NTSTATUS
SmpCopyFile(
    HANDLE SrcDirHandle,
    HANDLE DstDirHandle,
    PUNICODE_STRING FileName
    );

NTSTATUS
SmpDeleteFile(
    IN PUNICODE_STRING pFile
    );

#if SMP_SHOW_REGISTRY_DATA
VOID
SmpDumpQuery(
    IN PWSTR ModId,
    IN PCHAR RoutineName,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );
#endif

#define ALIGN(p,val) (PVOID)((((ULONG_PTR)(p) + (val) - 1)) & (~((val) - 1)))
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))


#if defined(REMOTE_BOOT)
VOID
SmpGetHarddiskBootPartition(
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber
    );

VOID
SmpPartitionDisk(
    IN ULONG DiskNumber,
    OUT PULONG PartitionNumber
    );

VOID
SmpFindCSCPartition(
    IN ULONG DiskNumber,
    OUT PULONG PartitionNumber
    );
#endif // defined(REMOTE_BOOT)



//
// Stubs for Hydra specific API's
//

NTSTATUS
SmpLoadSubSystemsForMuSession(
    OUT PULONG pMuSessionId,
    OUT PULONG_PTR WindowsSubSysProcessId,
    IN OUT PUNICODE_STRING InitialCommand );

NTSTATUS
SmpGetProcessMuSessionId(
    IN HANDLE Process,
    OUT PULONG pMuSessionId );

NTSTATUS
SmpSetProcessMuSessionId(
    IN HANDLE Process,
    IN ULONG MuSessionId );

BOOLEAN
SmpCheckDuplicateMuSessionId(
    IN ULONG MuSessionId );

//
// Stubs for Sb APIs
//

NTSTATUS
SmpSbCreateSession (
    IN PSMPSESSION SourceSession OPTIONAL,
    IN PSMPKNOWNSUBSYS CreatorSubsystem OPTIONAL,
    IN PRTL_USER_PROCESS_INFORMATION ProcessInformation,
    IN ULONG DebugSession OPTIONAL,
    IN PCLIENT_ID DebugUiClientId OPTIONAL
    );

ULONG SmBaseTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( SmBaseTag, t ))

#define INIT_TAG 0
#define DBG_TAG 1
#define SM_TAG 2

//
// Utility Routines (smutil.c)
//

NTSTATUS
SmpSaveRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL,
    IN BOOLEAN CheckForDuplicate
    );

PSMP_REGISTRY_VALUE
SmpFindRegistryValue(
    IN PLIST_ENTRY ListHead,
    IN PWSTR Name
    );

NTSTATUS
SmpAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    );

VOID
SmpReleasePrivilege(
    PVOID StatePointer
    );

//
// String parsing routine from sminit.c
//

NTSTATUS
SmpParseCommandLine(
    IN PUNICODE_STRING CommandLine,
    OUT PULONG Flags,
    OUT PUNICODE_STRING ImageFileName,
    OUT PUNICODE_STRING ImageFileDirectory OPTIONAL,
    OUT PUNICODE_STRING Arguments
    );

//
// Crashdump routines from smcrash.c
//

BOOLEAN
SmpCheckForCrashDump(
    IN PUNICODE_STRING PageFileName
    );

#endif // _SMSRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\cpl\resource.h ===
#define IDI_SFCCPL                      101
#define IDS_SFCCPL_NAME                 102
#define IDS_SFCCPL_DESC                 103
#define IDD_SFC_DISABLE                 104
#define IDD_SFC_SCAN                    105
#define IDC_DISABLE_NORMAL              106
#define IDC_DISABLE_ASK                 107
#define IDC_DISABLE_ONCE                108
#define IDC_DISABLE_NOPOPUPS            109
#define IDC_SCAN_NORMAL                 110
#define IDC_SCAN_ALWAYS                 111
#define IDC_SCAN_ONCE                   112
#define IDC_SCAN_NOW                    113
#define IDD_SFC_MISC                    114
#define IDC_QUOTA                       115
#define IDC_CACHE_DIR                   116
#define IDC_DEBUG_LEVEL                 117
#define IDC_BUGCHECK                    118
#define IDC_CHANGE_LOG                  119
#define IDC_SHOW_PROGRESS               120
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\cpl\sfccpl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Implementation of System File Checker initialization code.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

--*/

#include <windows.h>
#include <commctrl.h>
#include <cpl.h>
#include <stdlib.h>
#include <sfcapip.h>
#include "resource.h"


#define DLLCACHE_DIR L"%SystemRoot%\\system32\\DllCache"
#define DLGFORWARD(_nm) INT_PTR CALLBACK _nm(HWND,UINT,WPARAM,LPARAM)

#define MySetDlgItemText(hDlg, itemId, msgText) { \
            insideSetDlgItemText = TRUE; \
            SetDlgItemText(hDlg, itemId, msgText); \
            insideSetDlgItemText = FALSE; \
        }

#define MySetDlgItemInt(hDlg, itemId, msgText,signed) { \
            insideSetDlgItemText = TRUE; \
            SetDlgItemInt(hDlg, itemId, msgText,signed); \
            insideSetDlgItemText = FALSE; \
        }


typedef struct _SFC_PAGES {
    DWORD ResId;
    DLGPROC DlgProc;
} SFC_PAGES, *PSFC_PAGES;


HMODULE SfcInstanceHandle;
BOOL insideSetDlgItemText;
HANDLE RpcHandle;

DLGFORWARD(SfcDisableDlgProc);
DLGFORWARD(SfcScanDlgProc);
DLGFORWARD(SfcMiscDlgProc);

SFC_PAGES SfcPages[] =
{
    { IDD_SFC_DISABLE, SfcDisableDlgProc },
    { IDD_SFC_SCAN,    SfcScanDlgProc    },
    { IDD_SFC_MISC,    SfcMiscDlgProc    }
};

#define CountPages (sizeof(SfcPages)/sizeof(SFC_PAGES))

ULONG SFCQuota;
ULONG SFCDisable;
ULONG SFCScan;
ULONG SFCBugcheck;
ULONG SFCNoPopUps;
ULONG SFCDebug;
ULONG SFCShowProgress;
ULONG SFCChangeLog;
WCHAR SFCDllCacheDir[MAX_PATH*2];


DWORD
SfcDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        SfcInstanceHandle = hInstance;
        DisableThreadLibraryCalls( hInstance );
    }
    return TRUE;
}

void
SetChangeFlag(
    HWND hDlg,
    BOOL Enable
    )
{
    HWND hwndPropSheet = GetParent( hDlg );
    if (Enable) {
        PropSheet_Changed( hwndPropSheet, hDlg );
    } else {
        PropSheet_UnChanged( hwndPropSheet, hDlg );
    }
}


DWORD
SfcQueryRegDword(
    LPWSTR KeyName,
    LPWSTR ValueName
    )
{
    HKEY hKey;
    DWORD val;
    DWORD sz = sizeof(DWORD);


    if (RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey ) != ERROR_SUCCESS) {
        return 0;
    }

    if (RegQueryValueEx( hKey, ValueName, NULL, NULL, (LPBYTE)&val, &sz )  != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return 0;
    }

    RegCloseKey( hKey );
    return val;
}


PWSTR
SfcQueryRegString(
    LPWSTR KeyName,
    LPWSTR ValueName
    )
{
    HKEY hKey;
    DWORD sz = 0;
    PWSTR val;


    if (RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey ) != ERROR_SUCCESS) {
        return 0;
    }

    if (RegQueryValueEx( hKey, ValueName, NULL, NULL, NULL, &sz ) != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return NULL;
    }

    val = malloc( sz+16 );
    if (val == NULL) {
        return NULL;
    }

    if (RegQueryValueEx( hKey, ValueName, NULL, NULL, (LPBYTE)val, &sz ) != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return NULL;
    }

    RegCloseKey( hKey );
    return val;
}


DWORD
SfcWriteRegDword(
    LPWSTR KeyName,
    LPWSTR ValueName,
    ULONG Value
    )
{
    HKEY hKey;


    if (RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey ) != ERROR_SUCCESS) {
        return 0;
    }

    if (RegSetValueEx( hKey, ValueName, 0, REG_DWORD, (LPBYTE)&Value, sizeof(DWORD) )  != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return 0;
    }

    RegCloseKey( hKey );
    return 0;
}


DWORD
SfcWriteRegString(
    LPWSTR KeyName,
    LPWSTR ValueName,
    PWSTR Value
    )
{
    HKEY hKey;


    if (RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey ) != ERROR_SUCCESS) {
        return 0;
    }

    if (RegSetValueEx( hKey, ValueName, 0, REG_SZ, (LPBYTE)Value, (wcslen(Value)+1)*sizeof(WCHAR) )  != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return 0;
    }

    RegCloseKey( hKey );
    return 0;
}


void
SaveRegValues(
    void
    )
{
    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDebug",
        SFCDebug
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDisable",
        SFCDisable
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCScan",
        SFCScan
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCQuota",
        SFCQuota
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCBugcheck",
        SFCBugcheck
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SfcShowProgress",
        SFCShowProgress
        );

    SfcWriteRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SfcChangeLog",
        SFCChangeLog
        );

    SfcWriteRegString(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDllCacheDir",
        SFCDllCacheDir
        );
}


void
InititlaizeRegValues(
    void
    )
{
    PWSTR s;


    SFCDebug = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDebug"
        );

    SFCDisable = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDisable"
        );

    SFCScan = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCScan"
        );

    SFCQuota = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCQuota"
        );

    SFCBugcheck = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCBugcheck"
        );

    SFCShowProgress = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SfcShowProgress"
        );

    SFCChangeLog = SfcQueryRegDword(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SfcChangeLog"
        );

    s = SfcQueryRegString(
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        L"SFCDllCacheDir"
        );
    if (s == NULL) {
        //ExpandEnvironmentStrings( DLLCACHE_DIR, SFCDllCacheDir, sizeof(SFCDllCacheDir)/sizeof(WCHAR) );
        wcscpy( SFCDllCacheDir, DLLCACHE_DIR );
    } else {
        //ExpandEnvironmentStrings( s, SFCDllCacheDir, sizeof(SFCDllCacheDir)/sizeof(WCHAR) );
        wcscpy( SFCDllCacheDir, s );
        free( s );
    }
}


INT_PTR
CALLBACK
SfcDisableDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            switch (SFCDisable) {
                case SFC_DISABLE_NORMAL:
                    CheckDlgButton( hwndDlg, IDC_DISABLE_NORMAL, BST_CHECKED );
                    break;

                case SFC_DISABLE_ASK:
                    CheckDlgButton( hwndDlg, IDC_DISABLE_ASK, BST_CHECKED );
                    break;

                case SFC_DISABLE_ONCE:
                    CheckDlgButton( hwndDlg, IDC_DISABLE_ONCE, BST_CHECKED );
                    break;

                case SFC_DISABLE_NOPOPUPS:
                    CheckDlgButton( hwndDlg, IDC_DISABLE_NOPOPUPS, BST_CHECKED );
                    break;
            }
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_DISABLE_NORMAL:
                case IDC_DISABLE_ASK:
                case IDC_DISABLE_ONCE:
                case IDC_DISABLE_NOPOPUPS:
                    SetChangeFlag( hwndDlg, TRUE );
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    if (IsDlgButtonChecked( hwndDlg, IDC_DISABLE_NORMAL )) {
                        SFCDisable = SFC_DISABLE_NORMAL;
                    } else if (IsDlgButtonChecked( hwndDlg, IDC_DISABLE_ASK )) {
                        SFCDisable = SFC_DISABLE_ASK;
                    } else if (IsDlgButtonChecked( hwndDlg, IDC_DISABLE_ONCE )) {
                        SFCDisable = SFC_DISABLE_ONCE;
                    } else if (IsDlgButtonChecked( hwndDlg, IDC_DISABLE_NOPOPUPS )) {
                        SFCDisable = SFC_DISABLE_NOPOPUPS;
                    }
                    SaveRegValues();
                    SetChangeFlag( hwndDlg, FALSE );
                    return PSNRET_NOERROR;
            }
            break;
    }
    return FALSE;
}


INT_PTR
CALLBACK
SfcScanDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            switch (SFCScan) {
                case SFC_SCAN_NORMAL:
                    CheckDlgButton( hwndDlg, IDC_SCAN_NORMAL, BST_CHECKED );
                    break;

                case SFC_SCAN_ALWAYS:
                    CheckDlgButton( hwndDlg, IDC_SCAN_ALWAYS, BST_CHECKED );
                    break;

                case SFC_SCAN_ONCE:
                    CheckDlgButton( hwndDlg, IDC_SCAN_ONCE, BST_CHECKED );
                    break;
            }
            CheckDlgButton( hwndDlg, IDC_SHOW_PROGRESS, SFCShowProgress ? BST_CHECKED : BST_UNCHECKED );
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_SCAN_NORMAL:
                case IDC_SCAN_NOW:
                case IDC_SCAN_ALWAYS:
                case IDC_SCAN_ONCE:
                case IDC_SHOW_PROGRESS:
                    SetChangeFlag( hwndDlg, TRUE );
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    if (IsDlgButtonChecked( hwndDlg, IDC_SCAN_NOW )) {
                        SfcInitiateScan( RpcHandle, 0 );
                        SetChangeFlag( hwndDlg, FALSE );
                        return PSNRET_NOERROR;
                    }
                    if (IsDlgButtonChecked( hwndDlg, IDC_SCAN_NORMAL )) {
                        SFCScan = SFC_SCAN_NORMAL;
                    } else if (IsDlgButtonChecked( hwndDlg, IDC_SCAN_ALWAYS )) {
                        SFCScan = SFC_SCAN_ALWAYS;
                    } else if (IsDlgButtonChecked( hwndDlg, IDC_SCAN_ONCE )) {
                        SFCScan = SFC_SCAN_ONCE;
                    }
                    if (IsDlgButtonChecked( hwndDlg, IDC_SHOW_PROGRESS )) {
                        SFCShowProgress = 1;
                    } else {
                        SFCShowProgress = 0;
                    }
                    SaveRegValues();
                    SetChangeFlag( hwndDlg, FALSE );
                    return PSNRET_NOERROR;
            }
            break;
    }
    return FALSE;
}


INT_PTR
CALLBACK
SfcMiscDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            MySetDlgItemInt( hwndDlg, IDC_QUOTA, SFCQuota, FALSE );
            MySetDlgItemText( hwndDlg, IDC_CACHE_DIR, SFCDllCacheDir );
            MySetDlgItemInt( hwndDlg, IDC_DEBUG_LEVEL, SFCDebug, FALSE );
            CheckDlgButton( hwndDlg, IDC_BUGCHECK, SFCBugcheck ? BST_CHECKED : BST_UNCHECKED );
            CheckDlgButton( hwndDlg, IDC_CHANGE_LOG, SFCChangeLog ? BST_CHECKED : BST_UNCHECKED );
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_BUGCHECK:
                case IDC_CHANGE_LOG:
                    SetChangeFlag( hwndDlg, TRUE );
                    return TRUE;

                case IDC_QUOTA:
                case IDC_DEBUG_LEVEL:
                case IDC_CACHE_DIR:
                    if (HIWORD(wParam) == EN_CHANGE && !insideSetDlgItemText) {
                        SetChangeFlag( hwndDlg, TRUE );
                        return TRUE;
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    if (IsDlgButtonChecked( hwndDlg, IDC_BUGCHECK )) {
                        SFCBugcheck = 1;
                    } else {
                        SFCBugcheck = 0;
                    }
                    if (IsDlgButtonChecked( hwndDlg, IDC_CHANGE_LOG )) {
                        SFCChangeLog = 1;
                    } else {
                        SFCChangeLog = 0;
                    }
                    SFCQuota = GetDlgItemInt( hwndDlg, IDC_QUOTA, NULL, FALSE );
                    SFCDebug = GetDlgItemInt( hwndDlg, IDC_DEBUG_LEVEL, NULL, FALSE );
                    GetDlgItemText( hwndDlg, IDC_CACHE_DIR, SFCDllCacheDir, sizeof(SFCDllCacheDir)/sizeof(WCHAR) );
                    SaveRegValues();
                    SetChangeFlag( hwndDlg, FALSE );
                    return PSNRET_NOERROR;
            }
            break;
    }
    return FALSE;
}


void
CreateSfcProperySheet(
    HWND hwnd
    )
{
    DWORD i;
    PROPSHEETHEADER psh;
    LPPROPSHEETPAGE psp;


    RpcHandle = SfcConnectToServer( NULL );

    psp = malloc( sizeof(PROPSHEETPAGE)*CountPages );
    if (psp == NULL) {
        return;
    }

    for (i=0; i<CountPages; i++) {
        psp[i].dwSize              = sizeof(PROPSHEETPAGE);
        psp[i].dwFlags             = i == 0 ? PSP_PREMATURE : PSP_DEFAULT;
        psp[i].hInstance           = SfcInstanceHandle;
        psp[i].pszTemplate         = MAKEINTRESOURCE(SfcPages[i].ResId);
        psp[i].pszIcon             = NULL;
        psp[i].pszTitle            = NULL;
        psp[i].pfnDlgProc          = SfcPages[i].DlgProc;
        psp[i].lParam              = 0;
        psp[i].pfnCallback         = NULL;
        psp[i].pcRefParent         = NULL;
        psp[i].pszHeaderTitle      = NULL;
        psp[i].pszHeaderSubTitle   = NULL;
    }

    psh.dwSize              = sizeof(PROPSHEETHEADER);
    psh.dwFlags             = PSH_PROPSHEETPAGE;
    psh.hwndParent          = hwnd;
    psh.hInstance           = SfcInstanceHandle;
    psh.pszIcon             = MAKEINTRESOURCE(IDI_SFCCPL);
    psh.pszCaption          = MAKEINTRESOURCE(IDS_SFCCPL_DESC);
    psh.nPages              = CountPages;
    psh.nStartPage          = 0;
    psh.ppsp                = psp;
    psh.pfnCallback         = NULL;
    psh.pszbmWatermark      = NULL;
    psh.hplWatermark        = NULL;
    psh.pszbmHeader         = NULL;

    PropertySheet( &psh );
}


LONG
CALLBACK
CPlApplet(
    HWND hwndCPl,
    UINT uMsg,
    LPARAM lParam1,
    LPARAM lParam2
    )
{
    int i;
    LPCPLINFO CPlInfo;

    i = (int) lParam1;

    switch (uMsg) {
        case CPL_INIT:
            InititlaizeRegValues();
            return TRUE;

        case CPL_GETCOUNT:
            return 1;

        case CPL_INQUIRE:
            CPlInfo = (LPCPLINFO) lParam2;
            CPlInfo->lData = 0;
            CPlInfo->idIcon = IDI_SFCCPL;
            CPlInfo->idName = IDS_SFCCPL_NAME;
            CPlInfo->idInfo = IDS_SFCCPL_DESC;
            break;

        case CPL_DBLCLK:
            CreateSfcProperySheet( hwndCPl );
            break;

        case CPL_STOP:
            break;

        case CPL_EXIT:
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\apicli.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    apicli.c

Abstract:

    Windows File Protection client side APIs.

Author:

    Wesley Witt (wesw) 27-May-1999

Revision History:
    
    Andrew Ritz (andrewr) 5-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// global RPC binding handle because some client API's don't require you to
// specify an RPC handle
//
HANDLE _pRpcHandle;

//
// these macros are used by each client side api to
// ensure that we have a valid rpc handle.  if the
// calling application chooses to not call SfcConnectToServer
// they connect to the local server and save the handle
// in a global for future use.
//
#define EnsureGoodConnectionHandleStatus(_h)\
    if (_h == NULL) {\
        if (_pRpcHandle == NULL) {\
            _pRpcHandle = SfcConnectToServer( NULL );\
            if (_pRpcHandle == NULL) {\
                return RPC_S_SERVER_UNAVAILABLE;\
            }\
        }\
        _h = _pRpcHandle;\
    }

#define EnsureGoodConnectionHandleBool(_h)\
    if (_h == NULL) {\
        if (_pRpcHandle == NULL) {\
            _pRpcHandle = SfcConnectToServer( NULL );\
            if (_pRpcHandle == NULL) {\
                SetLastError(RPC_S_SERVER_UNAVAILABLE);\
				return FALSE;\
            }\
        }\
        _h = _pRpcHandle;\
    }


void
ClientApiInit(
    void
    )
{
#ifndef _WIN64
    SfcInitPathTranslator();
#endif  // _WIN64
}

void
ClientApiCleanup(
    void
    )
/*++

Routine Description:

    RPC cleanup wrapper routine called by client side when done with server side
    connection that was previously established with SfcConnectToServer().
    
Arguments:
    
    None

Return Value:

    none.
    
--*/
{
    if (_pRpcHandle) {
        SfcClose( _pRpcHandle );
        _pRpcHandle = NULL;
    }

#ifndef _WIN64
    SfcCleanupPathTranslator(TRUE);
#endif  // _WIN64
}


HANDLE
WINAPI
SfcConnectToServer(
    IN PCWSTR ServerName
    )
/*++

Routine Description:

    RPC attachment routine.
    
Arguments:
    
    ServerName - NULL terminated unicode string specifying server to connect to

Return Value:

    an RPC binding handle on success, else NULL.
    
--*/
{
    RPC_STATUS Status;
    RPC_BINDING_HANDLE RpcHandle = NULL;
    PWSTR szStringBinding = NULL;
    RPC_SECURITY_QOS qos;
    PWSTR szPrincName = NULL;
    PSID pSid = NULL;

    if (ServerName) {
        Status = ERROR_CALL_NOT_IMPLEMENTED;
        goto exit;
    }

    //
    // We need to get the name of the local system account for mutual authentication to the server
    //
    Status = SfcCreateSid(WinLocalSystemSid, &pSid);

    if(Status != ERROR_SUCCESS) {
        goto exit;
    }

    Status = SfcGetSidName(pSid, &szPrincName);

    if(Status != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // Compose a binding string using LRPC protocol and WFP's endpoint name
    //
    Status = RpcStringBindingCompose(
        NULL, 
        L"ncalrpc", 
        NULL,
        SFC_RPC_ENDPOINT,
        NULL,
        &szStringBinding
        );

    if(Status != RPC_S_OK) {
        szStringBinding = NULL;
        goto exit;
    }

    //
    // Connect and get the binding handle
    //
    Status = RpcBindingFromStringBinding(szStringBinding, &RpcHandle);

    if(Status != RPC_S_OK) {
        RpcHandle = NULL;
        goto exit;
    }

    //
    // Make RPC use mutual authentication
    //
    RtlZeroMemory(&qos, sizeof(qos));
    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;

    Status = RpcBindingSetAuthInfoEx(
        RpcHandle,
        szPrincName,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  // used anyway with ncalrpc
        RPC_C_AUTHN_WINNT,
        NULL,                           // current process credentials
        RPC_C_AUTHZ_NONE,
        &qos
        );

    if(Status != RPC_S_OK) {
        RpcBindingFree(&RpcHandle);
        RpcHandle = NULL;
        goto exit;
    }

exit:
    if(szStringBinding != NULL) {
        RpcStringFree(&szStringBinding);
    }

    MemFree(szPrincName);
    MemFree(pSid);
    SetLastError(Status);
    return RpcHandle;
}


VOID
SfcClose(
    IN HANDLE RpcHandle
    )

/*++

Routine Description:

    RPC cleanup routine.
    
Arguments:
    
    RpcHandle - RPC binding handle to the SFC server

Return Value:

    None.
    
--*/
{
    RpcBindingFree(&RpcHandle);
}


DWORD
WINAPI
SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
/*++

Routine Description:

    Routine to exempt a given file from the specified file change.  This 
    routine is used by certain clients to allow files to be deleted from
    the system, etc.
    
Arguments:
    
    RpcHandle - RPC binding handle to the SFC server
    FileName  - NULL terminated unicode string specifying full filename of the
                file to be exempted
    ExpectedChangeType - SFC_ACTION_* mask listing the file changes to exempt

Return Value:

    Win32 error code indicating outcome.
    
--*/
{
#ifndef _WIN64

    DWORD dwError = ERROR_SUCCESS;
    UNICODE_STRING Path = { 0 };
    NTSTATUS Status;

    if(NULL == FileName || 0 == FileName[0]) {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    EnsureGoodConnectionHandleStatus( RpcHandle );
    Status = SfcRedirectPath(FileName, &Path);

    if(!NT_SUCCESS(Status))
    {
        dwError = RtlNtStatusToDosError(Status);
        goto exit;
    }

    ASSERT(Path.Buffer != NULL);
    dwError = SfcCli_FileException( RpcHandle, Path.Buffer, ExpectedChangeType );

exit:
    MemFree(Path.Buffer);
    return dwError;

#else  // _WIN64

    EnsureGoodConnectionHandleStatus( RpcHandle );
    return SfcCli_FileException( RpcHandle, FileName, ExpectedChangeType );

#endif  // _WIN64
}


DWORD
WINAPI
SfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    )
/*++

Routine Description:

    Routine to start some sort scan on the system.
    
Arguments:
    
    RpcHandle - RPC binding handle to the SFC server
    ScanWhen  - flag indicating when to scan.  This parameter is currently
                unused.
    
Return Value:

    Win32 error code indicating outcome.
    
--*/
{
    UNREFERENCED_PARAMETER(ScanWhen);

    EnsureGoodConnectionHandleStatus( RpcHandle );
    return SfcCli_InitiateScan( RpcHandle, ScanWhen );
}


BOOL
WINAPI
SfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context OPTIONAL
    )
/*++

Routine Description:

    Routine to install one or more protected system files onto the system at 
    the protected location.  A client can use this API to request that WFP
    install the specified operating system files as appropriate (instead of the
    client redistributing the operating system files!)  The caller specifies a
    callback routine and a context structure that is called once per file.
    
Arguments:
    
    RpcHandle  - RPC binding handle to the SFC server
    FileNames  - a list of NULL seperated unicode strings, terminated by two 
                 NULL characters
    AllowUI    - a BOOL indicating whether UI is allowed or not.  If this value
                 is TRUE, then any prompts for UI cause the API call to fail.
    ClassName  - NULL terminated unicode string indicating the window classname
                 for the parent window
    WindowName - NULL terminated unicode string indicating the window name for
                 the parent window for any UI that may be displayed
    SfcNotificationCallback - pointer to a callback routine that is called once
                 per file.
    Context    - opaque pointer to caller defined context structure that is 
                 passed through to the callback routine.
    
Return Value:

    TRUE for success, FALSE for error.  last error code contains a Win32 error 
    code on failure.
    
--*/
{
    DWORD rVal = ERROR_SUCCESS;
    PCWSTR fname;
    ULONG cnt = 0, cntold = 0;
    ULONG sz = 0;
    PFILEINSTALL_STATUS cs = NULL;
    DWORD StatusSize = 0;
    UNICODE_STRING Path = { 0 };

#ifndef _WIN64
    //
    // must translate the paths
    //
    PWSTR szTranslatedFiles = NULL;
#endif
    
    //
    // parameter validation
    //
    if((SfcNotificationCallback == NULL) ||
       (FileNames == NULL)) {
        rVal = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // 1. if a windowname is specified, a classname should be specified
    // 2. if a classname is specified, a windowname should be specified
    // 3. if we don't allow UI, then windowname and classname should both be
    //    NULL.
    //
    if ((WindowName && !ClassName) 
        || (ClassName && !WindowName)
        || (!AllowUI && (ClassName || WindowName))) {
        rVal = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // validate RPC handle
    //
    EnsureGoodConnectionHandleBool( RpcHandle );

    //
    // check out how large of a buffer to send over
    //

    try {
#ifdef _WIN64

        for(fname = FileNames; *fname; ++cntold) {

            DWORD StringLength;
            StringLength = wcslen(fname) + 1;
            sz += StringLength * sizeof(WCHAR);
            fname += StringLength;
        }

#else
        //
        // must translate paths before calling the server
        //
        PWSTR szNewBuf = NULL;

        for(fname = FileNames; *fname; fname += wcslen(fname) + 1, ++cntold) {
            NTSTATUS Status;

            Status = SfcRedirectPath(fname, &Path);

            if(!NT_SUCCESS(Status))
            {
                rVal = RtlNtStatusToDosError(Status);
                goto exit;
            }

            if(NULL == szTranslatedFiles)
            {
                szNewBuf = (PWSTR) MemAlloc(Path.Length + 2 * sizeof(WCHAR));
            }
            else
            {
                szNewBuf = (PWSTR) MemReAlloc(sz + Path.Length + 2 * sizeof(WCHAR), szTranslatedFiles);
            }

            if(szNewBuf != NULL)
            {
                szTranslatedFiles = szNewBuf;
                RtlCopyMemory((PCHAR) szTranslatedFiles + sz, Path.Buffer, Path.Length + sizeof(WCHAR));
                sz += Path.Length + sizeof(WCHAR);
            }

            MemFree(Path.Buffer);
            RtlZeroMemory(&Path, sizeof(Path));

            if(NULL == szNewBuf)
            {
                rVal = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }

        //
        //set the last null
        //
        if(szTranslatedFiles != NULL)
        {
            szTranslatedFiles[sz / sizeof(WCHAR)] = L'\0';
        }

#endif
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rVal = RtlNtStatusToDosError(GetExceptionCode());
        goto exit;
    }

    if(0 == cntold)
    {
        //
        // not files to install
        //
        rVal = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // for terminating NULL
    //
    sz+=sizeof(WCHAR);

    //
    // make the RPC call to install the files
    //
    rVal = SfcCli_InstallProtectedFiles(
        RpcHandle,
#ifdef _WIN64
        (LPBYTE)FileNames,
#else
        (LPBYTE)szTranslatedFiles,
#endif
        sz,
        (LPBYTE*)&cs,
        &StatusSize,
        &cnt,
        AllowUI,
        ClassName,
        WindowName
        );

    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }
    
    //
    // we should have gotten back the same amount of status information as the 
    // number of files that we passed in
    // 
    ASSERT(cnt == cntold);

    //
    // call the callback function once for each file, now that we've completed
    // copying the files in the list.  We pass the caller a structure which 
    // indicates the success of copying each individual file in the list.
    //
    for (fname = FileNames, sz=0; sz<cnt; sz++, fname += wcslen(fname) + 1) {
        LPEXCEPTION_POINTERS ExceptionPointers = NULL;
        try {
            NTSTATUS Status;
            BOOL b;
            //
            // don't use the (possibly reditected) file names returned from the server
            //
            Status = SfcAllocUnicodeStringFromPath(fname, &Path);

            if(!NT_SUCCESS(Status))
            {
                rVal = RtlNtStatusToDosError(Status);
                goto exit;
            }

            cs[sz].FileName = Path.Buffer;
            b = SfcNotificationCallback( &cs[sz], Context );
            MemFree(Path.Buffer);
            RtlZeroMemory(&Path, sizeof(Path));

            if (!b) {
                //
                // return FALSE if the callback fails for any reason
                //
                rVal = ERROR_CANCELLED;
                goto exit;
            }
        } except (ExceptionPointers = GetExceptionInformation(),
                  EXCEPTION_EXECUTE_HANDLER) {
            //
            // we hit an exception calling the callback...return exception code
            //            
            DebugPrint3( LVL_VERBOSE, 
                         L"SIPF hit exception %x while calling callback routine %x at address %x\n",
                         ExceptionPointers->ExceptionRecord->ExceptionCode,
                         SfcNotificationCallback,
                         ExceptionPointers->ExceptionRecord->ExceptionAddress
                       );
            rVal = RtlNtStatusToDosError(ExceptionPointers->ExceptionRecord->ExceptionCode);
            goto exit;
        }
    }

exit:
    MemFree(Path.Buffer);

    if(cs != NULL)
    {
        midl_user_free( cs );    
    }

#ifndef _WIN64
    MemFree(szTranslatedFiles);
#endif

    SetLastError(rVal);
    return rVal == ERROR_SUCCESS;
}

BOOL
WINAPI
SfcGetNextProtectedFile(
    IN HANDLE RpcHandle,
    IN PPROTECTED_FILE_DATA ProtFileData
    )
/*++

Routine Description:

    Routine to retrieve the next protected file in the list.
    
Arguments:
    
    RpcHandle    - RPC binding handle to the SFC server
    ProtFileData - pointer to a PROTECTED_FILE_DATA structure to be filled
                   in by function.
    
Return Value:

    TRUE for success, FALSE for failure. If there are no more files, the last
    error code will be set to ERROR_NO_MORE_FILES.    
    
--*/
{
    DWORD rVal;
    LPWSTR FileName = NULL;
    DWORD FileNameSize = 0;
    BOOL bReturn = FALSE;
    DWORD FileNumber;

    //
    // validate parameters
    //
    if (ProtFileData == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    try {
        FileNumber = ProtFileData->FileNumber;        
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }
    
    //
    // If this is not an internal client, then RpcHandle must be NULL.
    //
    EnsureGoodConnectionHandleBool( RpcHandle );

    //
    // call the server API
    //
    rVal = SfcCli_GetNextProtectedFile(
        RpcHandle,
        FileNumber,
        (LPBYTE*)&FileName,
        &FileNameSize
        );
    if (rVal != ERROR_SUCCESS) {
        SetLastError(rVal);
        goto exit;        
    }

    bReturn = TRUE;

    //
    // copy into the caller supplied buffer
    //
    try {
        (void) StringCchCopy(ProtFileData->FileName, UnicodeChars(ProtFileData->FileName), FileName);
        ProtFileData->FileNumber += 1;        
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(RtlNtStatusToDosError(GetExceptionCode()));
        bReturn = FALSE;
    }

    midl_user_free( FileName );

exit:    
    return(bReturn);
}


BOOL
WINAPI
SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    )
/*++

Routine Description:

    Routine to determine if the specified file is protected.
    
Arguments:
    
    RpcHandle    - RPC binding handle to the SFC server
    ProtFileName - NULL terminated unicode string indicating fully qualified
                   filename to query
    
Return Value:

    TRUE if file is protected, FALSE if it isn't.  last error code contains a
    Win32 error code on failure.
    
--*/
{
    DWORD rVal;
    DWORD dwAttributes, dwSize;
    WCHAR Buffer[MAX_PATH];

    //
    // parameter validation
    //
    if (ProtFileName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // if this is not an internal client, then RpcHandle must be NULL.
    //
    EnsureGoodConnectionHandleBool( RpcHandle );

    //
    // check whether this file is sxs-wfp first, which could be done on client-side only
    //

    // 
    // check whether it begins with "%SystemRoot%\\WinSxS\\"
    //
    dwSize = ExpandEnvironmentStrings( L"%SystemRoot%\\WinSxS\\", Buffer, UnicodeChars(Buffer));
    if(0 == dwSize)
    {        
        DebugPrint1( LVL_MINIMAL, L"SFC : ExpandEnvironmentStrings failed with lastError = 0x%x", GetLastError());        
        return FALSE;
    }

    if(dwSize > UnicodeChars(Buffer)) {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    --dwSize;

    try {
        if ((wcslen(ProtFileName) > dwSize) &&
            (_wcsnicmp(Buffer, ProtFileName, dwSize) == 0))  // if they're equal, this could be a protected file
        {
            dwAttributes = GetFileAttributesW(ProtFileName);        
            if (dwAttributes == 0xFFFFFFFF)
                return FALSE;

            if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            return TRUE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // call server to determine if file is protected
    //
    rVal = SfcCli_IsFileProtected( RpcHandle, (PWSTR)ProtFileName );
    if (rVal != ERROR_SUCCESS) {
        SetLastError(rVal);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\btree.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    btree.c

Abstract:

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

Author:

    Tom McGuire (tommcg)   1-Jan-1998
    Wesley Witt (wesw)    18-Dec-1998

Revision History:

    Tom McGuire (tommcg)  13-Apr-2000  fixed hash collision search bug

--*/

#include "sfcp.h"
#pragma hdrstop

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const NAME_NODE NameRbEmptyNode = { RBNIL, RBNIL };
const DWORD_NODE EmptyNode = { NODE_NIL, NODE_NIL };


VOID
BtreeInit(
    IN OUT PNAME_TREE Tree
    )
{
    Tree->Root = RBNIL;
}


PNAME_NODE
BtreeFind(
    IN PNAME_TREE Tree,
    IN LPCWSTR Name,
    IN DWORD NameLength
    )
{
    PNAME_NODE Node;
    ULONG      Hash;

    HASH_DYN_CONVERT_KEY( Name, (NameLength/sizeof(WCHAR)), &Hash );

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node = Node->Right;
            }
        else {  // hashes equal, compare lengths

            if ( NameLength < Node->NameLength ) {
                Node = Node->Left;
                }
            else if ( NameLength > Node->NameLength ) {
                Node = Node->Right;
                }
            else {  // hashes and lengths equal, compare strings

                int Compare = memcmp( Name, Node->Name, NameLength );

                if ( Compare == 0 ) {
                    return Node;
                    }
                else if ( Compare < 0 ) {
                    Node = Node->Left;
                    }
                else {
                    Node = Node->Right;
                    }
                }
            }
        }

    return NULL;
}


PNAME_NODE
BtreeInsert(
    IN OUT PNAME_TREE Tree,
    IN LPCWSTR Name,
    IN DWORD NameLength
    )
{
    PNAME_NODE * Stack[ MAX_DEPTH ];
    PNAME_NODE **StackPointer = Stack;
    PNAME_NODE * Link;
    PNAME_NODE   Node;
    PNAME_NODE   Sibling;
    PNAME_NODE   Parent;
    PNAME_NODE   Child;
    PNAME_NODE   NewNode;
    ULONG        Hash;

    HASH_DYN_CONVERT_KEY( Name, (NameLength/sizeof(WCHAR)), &Hash );

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //
    //  Implementation Note:  The compiler is smart enough to collapse each
    //  of the three following "go left" and "go right" clauses into single
    //  "go left" and "go right" instruction sequences, so the code remains
    //  verbose for clarity.
    //

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {  // hashes equal, compare lengths

            if ( NameLength < Node->NameLength ) {
                *StackPointer++ = &Node->Left;
                Node = Node->Left;
                }
            else if ( NameLength > Node->NameLength ) {
                *StackPointer++ = &Node->Right;
                Node = Node->Right;
                }
            else {  // lengths equal, compare strings

                int Compare = memcmp( Name, Node->Name, NameLength );

                if ( Compare == 0 ) {
                    return Node;
                    }
                else if ( Compare < 0 ) {
                    *StackPointer++ = &Node->Left;
                    Node = Node->Left;
                    }
                else {
                    *StackPointer++ = &Node->Right;
                    Node = Node->Right;
                    }
                }
            }
        }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //

    NewNode = MemAlloc( sizeof(NAME_NODE)+NameLength );

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = RBNIL;
    NewNode->Right = RBNIL;
    NewNode->Hash  = Hash;
    NewNode->NameLengthAndColorBit = NameLength | 0x80000000;   // MARK_RED
    memcpy( NewNode->Name, Name, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
}




VOID
TreeInit(
    OUT PDWORD_TREE Tree
    )
{
    Tree->Root = NODE_NIL;
}


DWORD_CONTEXT
TreeFind(
    IN PDWORD_TREE Tree,
    IN ULONG Key
    )
{
    PDWORD_NODE Node;

    ASSERT(Tree != NULL);
    ASSERT(Key < (1 << 31));

    Node = Tree->Root;

    while ( Node != NODE_NIL ) {

        if ( Key < Node->Key ) {
            Node = Node->Left;
        }
        else if ( Key > Node->Key ) {
            Node = Node->Right;
        }
        else {
            return (DWORD_CONTEXT) Node->Context;
        }
    }

    return NULL;
}


DWORD_CONTEXT
TreeInsert(
    IN OUT PDWORD_TREE Tree,
    IN ULONG Key,
    IN DWORD_CONTEXT Context,
    IN ULONG ContextSize
    )
{
    PDWORD_NODE * Stack[ MAX_DEPTH ];
    PDWORD_NODE **StackPointer = Stack;
    PDWORD_NODE * Link;
    PDWORD_NODE   Node;
    PDWORD_NODE   Sibling;
    PDWORD_NODE   Parent;
    PDWORD_NODE   Child;
    PDWORD_NODE   NewNode;

    ASSERT(Tree != NULL && Context != NULL && ContextSize != 0);
    ASSERT(Key < (1 << 31));

    *StackPointer++ = &Tree->Root;
    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //
    //  Implementation Note:  The compiler is smart enough to collapse each
    //  of the three following "go left" and "go right" clauses into single
    //  "go left" and "go right" instruction sequences, so the code remains
    //  verbose for clarity.
    //

    while ( Node != NODE_NIL ) {

        if ( Key < Node->Key ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
        }
        else if ( Key > Node->Key ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
        }
        else {
            return (DWORD_CONTEXT) Node->Context;
        }
    }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //
    
    NewNode = MemAlloc( sizeof(DWORD_NODE) + ContextSize);

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = NODE_NIL;
    NewNode->Right = NODE_NIL;
    NewNode->Key  = Key;
    MARK_RED(NewNode);
    memcpy( NewNode->Context, Context, ContextSize );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = NODE_NIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return (DWORD_CONTEXT) NewNode->Context;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return (DWORD_CONTEXT) NewNode->Context;
}


VOID
TreeDestroy(
    IN OUT PDWORD_TREE Tree
    )
//
// We walk the tree left first, then right, until we find a leaf. We delete the leaf and continue 
// our walking to the right of the parent since we must've been to the parent's left before
//
{
    PDWORD_NODE * Stack[ MAX_DEPTH ];
    PDWORD_NODE **StackPointer;
    PDWORD_NODE Node;

    if(NODE_NIL == Tree->Root)
        return;

    StackPointer = Stack;
    *StackPointer = &Tree->Root;

lTryLeft:
    Node = **StackPointer;

    if(Node->Left != NODE_NIL)
    {
        *++StackPointer = &Node->Left;
        goto lTryLeft;
    }

lTryRight:
    if(Node->Right != NODE_NIL)
    {
        *++StackPointer = &Node->Right;
        goto lTryLeft;
    }

    MemFree(Node);
    **StackPointer = NODE_NIL;

    if(StackPointer > Stack)    // this is true if the current node is not the root
    {
        Node = **--StackPointer;
        goto lTryRight;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\btree.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    btree.h

Abstract:

    Prototypes and node structure definition for red-black binary trees.
    See btree.c for details and implementation.

Author:

    Tom McGuire (tommcg)  1-Jan-1998
    Wesley Witt (wesw)    18-Dec-1998

Revision History:

--*/

#ifndef _BTREE_H_
#define _BTREE_H_

#pragma warning( disable: 4200 )    // zero-sized array in struct/union

typedef struct _NAME_NODE NAME_NODE, *PNAME_NODE;
typedef struct _NAME_TREE NAME_TREE, *PNAME_TREE;

struct _NAME_NODE {
    PNAME_NODE Left;
    PNAME_NODE Right;
    ULONG      Hash;
    union {
      ULONG    NameLengthAndColorBit;
      struct {
        ULONG  NameLength:31;
        ULONG  Red:1;
        };
      };
    PVOID Context;
    CHAR  Name[ 0 ];
    };

struct _NAME_TREE {
    PNAME_NODE Root;
    };


#define RBNIL ((PNAME_NODE)&NameRbEmptyNode)

extern const NAME_NODE NameRbEmptyNode;


typedef struct _DWORD_NODE DWORD_NODE, *PDWORD_NODE;
typedef struct _DWORD_TREE DWORD_TREE, *PDWORD_TREE;
typedef LPCVOID DWORD_CONTEXT;

struct _DWORD_NODE {
    PDWORD_NODE Left;
    PDWORD_NODE Right;
    struct {
        ULONG Key:31;
        ULONG Red:1;
    };
    INT_PTR Context[0]; // everything that goes into Context is guaranteed to be aligned on a machine-word boundary
    };

struct _DWORD_TREE {
    PDWORD_NODE Root;
    };


#define NODE_NIL ((PDWORD_NODE) &EmptyNode)

extern const DWORD_NODE EmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  1 million, so the max depth is 40 (2*Lg(2^20)).  Note that no runtime
//  checks are made to ensure we don't exceed this number.
//

#define MAX_DEPTH 40


//
//  The following prototypes are the red-black tree interface.
//

VOID
BtreeInit(
    IN OUT PNAME_TREE Tree
    );

PNAME_NODE
BtreeInsert(
    IN OUT PNAME_TREE Tree,
    IN LPCWSTR Name,
    IN DWORD NameLength // in bytes, NOT characters
    );

PNAME_NODE
BtreeFind(
    IN PNAME_TREE Tree,
    IN LPCWSTR Name,
    IN DWORD NameLength // in bytes, NOT characters
    );



VOID
TreeInit(
    OUT PDWORD_TREE Tree
    );

DWORD_CONTEXT
TreeFind(
    IN PDWORD_TREE Tree,
    IN ULONG Key
    );

DWORD_CONTEXT
TreeInsert(
    IN OUT PDWORD_TREE Tree,
    IN ULONG Key,
    IN DWORD_CONTEXT Context,
    IN ULONG ContextSize
    );

VOID
TreeDestroy(
    IN OUT PDWORD_TREE Tree
    );

#endif // _BTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\server\termsrv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    termsrv.c

Abstract:

    Terminal Server routines for supporting multiple sessions.

Author:

Revision History:

--*/

#include "smsrvp.h"
#include <ntexapi.h>
#include <winerror.h>
#include "stdio.h"

HANDLE SmpSessionsObjectDirectory;

extern PSECURITY_DESCRIPTOR SmpLiberalSecurityDescriptor;

NTSTATUS
SmpSetProcessMuSessionId (
    IN HANDLE Process,
    IN ULONG MuSessionId
    )

/*++

Routine Description:

    This function sets the multiuser session ID for a process.

Arguments:

    Process - Supplies the handle of the process to set the ID for.

    MuSessionId - Supplies the ID to give to the supplied process.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    ProcessInfo.SessionId = MuSessionId;

    Status = NtSetInformationProcess (Process,
                                      ProcessSessionInformation,
                                      &ProcessInfo,
                                      sizeof( ProcessInfo ) );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(( "SMSS: SetProcessMuSessionId, Process=%x, Status=%x\n",
                  Process, Status ));
    }

    return Status;
}

NTSTATUS
SmpTerminateProcessAndWait (
    IN HANDLE Process,
    IN ULONG Seconds
    )

/*++

Routine Description:

    This function terminates the process and waits for it to die.

Arguments:

    Process - Supplies the handle of the process to terminate.

    Seconds - Supplies the number of seconds to wait for the process to die.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    ULONG mSecs;
    LARGE_INTEGER Timeout;

    //
    // Try to terminate the process.
    //

    Status = NtTerminateProcess( Process, STATUS_SUCCESS );

    if ( !NT_SUCCESS( Status ) && Status != STATUS_PROCESS_IS_TERMINATING ) {
        KdPrint(( "SMSS: Terminate=0x%x\n", Status ));
        return Status;
    }

    //
    // Wait for the process to die.
    //

    mSecs = Seconds * 1000;
    Timeout = RtlEnlargedIntegerMultiply( mSecs, -10000 );

    Status = NtWaitForSingleObject( Process, FALSE, &Timeout );

    return Status;
}

NTSTATUS
SmpGetProcessMuSessionId (
    IN HANDLE Process,
    OUT PULONG MuSessionId
    )

/*++

Routine Description:

    This function gets the multiuser session ID for a process.

Arguments:

    Process - Supplies the handle of the process to get the ID for.

    MuSessionId - Supplies the location to place the ID in.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    Status = NtQueryInformationProcess (Process,
                                        ProcessSessionInformation,
                                        &ProcessInfo,
                                        sizeof( ProcessInfo ),
                                        NULL );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(( "SMSS: GetProcessMuSessionId, Process=%x, Status=%x\n",
                  Process, Status ));
        *MuSessionId = 0;
    }
    else {
        *MuSessionId = ProcessInfo.SessionId;
    }

    return Status;
}

NTSTATUS
SmpTerminateCSR(
    IN ULONG MuSessionId
)

/*++

Routine Description:

    This function terminates all known subsystems for this MuSessionId.
    Also closes all LPC ports and all process handles.

Arguments:

    MuSessionId - Supplies the session ID to terminate subsystems for.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY Next;
    PLIST_ENTRY Tmp;
    PSMPKNOWNSUBSYS KnownSubSys;
    CLIENT_ID ClientId;
    HANDLE Process;

    RtlEnterCriticalSection( &SmpKnownSubSysLock );

    //
    // Force all subsystems of this session to exit.
    //

    Next = SmpKnownSubSysHead.Flink;
    while ( Next != &SmpKnownSubSysHead ) {

        KnownSubSys = CONTAINING_RECORD(Next,SMPKNOWNSUBSYS,Links);
        Next = Next->Flink;

        if ( KnownSubSys->MuSessionId != MuSessionId ) {
            continue;
        }

        ClientId = KnownSubSys->InitialClientId;
        Process = KnownSubSys->Process;

        // 
        // Reference the Subsystem so it does not go away while we using it.
        // 

        SmpReferenceKnownSubSys(KnownSubSys);

        // 
        // Set deleting so that this subsys will go away when refcount reaches
        // zero.
        // 

        KnownSubSys->Deleting = TRUE;

        //
        // Unlock the SubSystemList as we don't want to leave it locked
        // around a wait.
        //

        RtlLeaveCriticalSection( &SmpKnownSubSysLock );

        Status = SmpTerminateProcessAndWait( Process, 10 );

        if ( Status != STATUS_SUCCESS ) {
            KdPrint(( "SMSS: Subsystem type %d failed to terminate\n",
                          KnownSubSys->ImageType ));
        }
 
        RtlEnterCriticalSection( &SmpKnownSubSysLock );

        //
        // Must look for entry again.
        // BUGBUG: why re-look ?  ICASRV shouldn't allow it to be deleted, but..
        //

        Tmp = SmpKnownSubSysHead.Flink;

        while ( Tmp != &SmpKnownSubSysHead ) {

            KnownSubSys = CONTAINING_RECORD(Tmp,SMPKNOWNSUBSYS,Links);

            if ( KnownSubSys->InitialClientId.UniqueProcess == ClientId.UniqueProcess ) {
                //
                // Remove the KnownSubSys block from the list.
                //

                RemoveEntryList( &KnownSubSys->Links );

                //
                // Dereference the subsystem. If this is the last reference,
                // the subsystem will be deleted.
                //
            
                SmpDeferenceKnownSubSys(KnownSubSys);

                break;
            }
            Tmp = Tmp->Flink;
        }

        //
        // Since we have waited, we must restart from the top of the list.
        //

        Next = SmpKnownSubSysHead.Flink;

    }

    //
    // Unlock SubSystemList.
    //

    RtlLeaveCriticalSection( &SmpKnownSubSysLock );

    return Status;
}

NTSTATUS
SmpStartCsr(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )

/*++

Routine Description:

    This function creates a CSRSS system for a MuSessionId,
    returning the initial program and the windows subsystem.
    The console only returns the initial program
    and windows subsystem since it is started at boot.

Arguments:

    TBD.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS St;
    NTSTATUS Status;
    PSMSTARTCSR args;
    ULONG MuSessionId;
    UNICODE_STRING InitialCommand;
    UNICODE_STRING DefaultInitialCommand;
    ULONG_PTR InitialCommandProcessId;
    ULONG_PTR WindowsSubSysProcessId;
    HANDLE InitialCommandProcess;
    extern ULONG SmpInitialCommandProcessId;
    extern ULONG SmpWindowsSubSysProcessId;
    PVOID State;
    LOGICAL TerminateCSR;

    TerminateCSR = FALSE;

    args = &SmApiMsg->u.StartCsr;
    MuSessionId = args->MuSessionId;

    InitialCommand.Length = (USHORT)args->InitialCommandLength;
    InitialCommand.MaximumLength = (USHORT)args->InitialCommandLength;
    InitialCommand.Buffer = args->InitialCommand;

    //
    // Things are different for the console.
    // SM starts him up and passes his ID back here.
    //

    if ( !MuSessionId ) {
        args->WindowsSubSysProcessId = SmpWindowsSubSysProcessId;
        args->InitialCommandProcessId = SmpInitialCommandProcessId;
        return STATUS_SUCCESS;
    }

    //
    // Load subsystems for this session.
    //

    WindowsSubSysProcessId = 0;

    Status = SmpLoadSubSystemsForMuSession (&MuSessionId,
                                            &WindowsSubSysProcessId,
                                            &DefaultInitialCommand );

    if ( Status != STATUS_SUCCESS ) {

        DbgPrint( "SMSS: SmpStartCsr, SmpLoadSubSystemsForMuSession Failed. Status=%x\n",
                   Status );

        goto nostart;
    }

    //
    // Start the initial command for this session.
    //

    if ( InitialCommand.Length == 0 ) {

        Status = SmpExecuteInitialCommand( MuSessionId,
                                           &DefaultInitialCommand,
                                           &InitialCommandProcess,
                                           &InitialCommandProcessId );
    }
    else {
        Status = SmpExecuteInitialCommand( MuSessionId,
                                           &InitialCommand,
                                           &InitialCommandProcess,
                                           &InitialCommandProcessId );
    }

    if ( !NT_SUCCESS( Status ) ) {

        TerminateCSR = TRUE;
        DbgPrint( "SMSS: SmpStartCsr, SmpExecuteInitialCommand Failed. Status=%x\n",
                   Status );

        goto nostart;

    }

    NtClose( InitialCommandProcess );  // This handle isn't needed

    args->InitialCommandProcessId = InitialCommandProcessId;
    args->WindowsSubSysProcessId = WindowsSubSysProcessId;
    args->MuSessionId = MuSessionId;

nostart:

    if ((AttachedSessionId != (-1)) && NT_SUCCESS(SmpAcquirePrivilege( SE_LOAD_DRIVER_PRIVILEGE, &State ))) {

        //
        // If we are attached to a session space, leave it
        // so we can create a new one.
        //

        St = NtSetSystemInformation (SystemSessionDetach,
                                     (PVOID)&AttachedSessionId,
                                     sizeof(MuSessionId));

        if (NT_SUCCESS(St)) {
            AttachedSessionId = (-1);
        } else {

            //
            // This has to succeed otherwise we will bugcheck while trying to
            // create another session.
            //

#if DBG
            DbgPrint( "SMSS: SmpStartCsr, Couldn't Detach from Session Space. Status=%x\n",
                       St);

            DbgBreakPoint ();
#endif
        }

        SmpReleasePrivilege( State );
    }

    if ( TerminateCSR == TRUE ) {

        St = SmpTerminateCSR( MuSessionId );

#if DBG
        if (!NT_SUCCESS(St)) {
            DbgPrint( "SMSS: SmpStartCsr, Couldn't Terminate CSR. Status=%x\n", St);
            DbgBreakPoint();
        }
#endif

    }

    return Status;

}

NTSTATUS
SmpStopCsr(
    IN PSMAPIMSG SmApiMsg,
    IN PSMP_CLIENT_CONTEXT CallingClient,
    IN HANDLE CallPort
    )

/*++

Routine Description:

    This function terminates all known subsystems for this MuSessionId.
    Also closes all LPC ports and all process handles.

Arguments:

    TBD.

Return Value:

    NTSTATUS.

--*/

{
    PSMSTOPCSR args;
    ULONG MuSessionId;

    args = &SmApiMsg->u.StopCsr;
    MuSessionId = args->MuSessionId;

    return SmpTerminateCSR( MuSessionId );
}

BOOLEAN
SmpCheckDuplicateMuSessionId(
    IN ULONG MuSessionId
    )

/*++

Routine Description:

    This function looks for this MuSessionId in the known subsystems.

Arguments:

    MuSessionId - Supplies the session ID to look for.

Return Value:

    TRUE if found, FALSE if not.

--*/

{
    PLIST_ENTRY Next;
    PSMPKNOWNSUBSYS KnownSubSys;

    RtlEnterCriticalSection( &SmpKnownSubSysLock );

    Next = SmpKnownSubSysHead.Flink;
    while ( Next != &SmpKnownSubSysHead ) {

        KnownSubSys = CONTAINING_RECORD(Next,SMPKNOWNSUBSYS,Links);

        if ( KnownSubSys->MuSessionId == MuSessionId ) {
            RtlLeaveCriticalSection( &SmpKnownSubSysLock );
            return TRUE;
        }
        Next = Next->Flink;
    }

    RtlLeaveCriticalSection( &SmpKnownSubSysLock );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\apisrv.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    apisrv.c

Abstract:

    Windows File Protection server side APIs.  Note that these server side APIs
    all run in the context of the winlogon process, so special care must be
    taken to validate all parameters.

Author:

    Wesley Witt (wesw) 27-May-1999

Revision History:

    Andrew Ritz (andrewr) 5-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop


DWORD
WINAPI
SfcSrv_FileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
/*++

Routine Description:

    Routine to exempt a given file from the specified file change.  This
    routine is used by certain clients to allow files to be deleted from
    the system, etc.  Server side counterpart to SfcFileException API.


Arguments:

    RpcHandle          - RPC binding handle to the SFC server
    FileName           - NULL terminated unicode string specifying full
                         filename of the file to be exempted
    ExpectedChangeType - SFC_ACTION_* mask listing the file changes to exempt

Return Value:

    Win32 error code indicating outcome.

--*/
{
    #define BUFSZ (MAX_PATH*2)
    PNAME_NODE Node;
    PSFC_REGISTRY_VALUE RegVal;
    WCHAR Buffer[BUFSZ];
    DWORD sz;
    DWORD retval;

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    retval = SfcRpcPriviledgeCheck( RpcHandle );
    if (retval != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // expand any environment variables...this also serves to probe the client
    // buffer
    //
    if (FileName == NULL) {
        retval = ERROR_INVALID_PARAMETER;
    } else {
        sz = ExpandEnvironmentStrings( FileName, Buffer, UnicodeChars(Buffer) );
        if (sz == 0) {
            retval = GetLastError();
        } else if(sz > UnicodeChars(Buffer)) {
            retval = ERROR_BUFFER_OVERFLOW;
        }
    }

    if (retval != ERROR_SUCCESS) {
        return(retval);
    }

    //
    // our internal structures all assume the strings are in lower case.  we
    // must convert our search string to lowercase as well.
    //
    MyLowerString( Buffer, wcslen(Buffer) );

    DebugPrint2( LVL_MINIMAL, L"S_FE: [%ws], [%d]", Buffer, ExpectedChangeType );

    //
    // search for the file in our list.
    //
    Node = SfcFindProtectedFile( Buffer, UnicodeLen(Buffer) );
    if (Node == NULL) {
        retval = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // get pointer to file registry value for file
    //
    RegVal = (PSFC_REGISTRY_VALUE)Node->Context;

    RtlEnterCriticalSection( &ErrorCs );
    //
    // If the exemption flags are not valid anymore, reset them all
    //
    if(!SfcAreExemptionFlagsValid(TRUE)) {
        ZeroMemory(IgnoreNextChange, SfcProtectedDllCount * sizeof(ULONG));
    }
    //
    // OR the new flags into the current ones
    //
    SfcSetExemptionFlags(RegVal, ExpectedChangeType);
    RtlLeaveCriticalSection( &ErrorCs );

exit:
    return(retval);
}


DWORD
WINAPI
SfcSrv_InitiateScan(
    IN HANDLE hBinding,
    IN DWORD ScanWhen
    )

/*++

Routine Description:

    Routine to start some sort scan on the system.

Arguments:

    RpcHandle - RPC binding handle to the SFC server
    ScanWhen  - flag indicating when to scan.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    HANDLE hThread;
    PSCAN_PARAMS ScanParams;
    DWORD retval = ERROR_SUCCESS;

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    retval = SfcRpcPriviledgeCheck( hBinding );
    if (retval != ERROR_SUCCESS) {
        goto exit;
    }

    switch( ScanWhen ) {
        case SFC_SCAN_NORMAL:
        case SFC_SCAN_ALWAYS:
        case SFC_SCAN_ONCE:
            retval = SfcWriteRegDword( REGKEY_WINLOGON, REGVAL_SFCSCAN, ScanWhen );
            break;
        case SFC_SCAN_IMMEDIATE:
            //
            // a user must be logged on for this API to be called since it can bring up
            // UI (if the user need to insert media to restore files, etc.)  we could
            // succeed this and let the SfcScanProtectedDlls thread wait for a user to
            // log on if we wanted to.
            //
            if (!UserLoggedOn) {
                DebugPrint( LVL_MINIMAL, L"SfcSrv_InitiateScan: User not logged on" );
                retval =  ERROR_NOT_LOGGED_ON;
                goto exit;
            }

            ScanParams = MemAlloc( sizeof(SCAN_PARAMS) );
            if (!ScanParams) {
                retval = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            //
            // set the progress window to null so we force ourselves to show UI
            //
            ScanParams->ProgressWindow = NULL;
            ScanParams->AllowUI = !SFCNoPopUps;
            ScanParams->FreeMemory = TRUE;

            //
            // start off another thread to do the scan.
            //
            hThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)SfcScanProtectedDlls,
                ScanParams,
                0,
                NULL
                );
            if (hThread) {
                CloseHandle( hThread );
            } else {
                MemFree(ScanParams);
                retval =  GetLastError();
            }
            break;

        default:
            retval = ERROR_INVALID_PARAMETER;
            break;
    }

exit:
    return(retval);
}


DWORD
WINAPI
SfcSrv_InstallProtectedFiles(
    IN HANDLE hBinding,
    IN const LPBYTE FileNamesBuffer,
    IN DWORD FileNamesSize,
    OUT LPBYTE *InstallStatusBuffer,
    OUT LPDWORD InstallStatusBufferSize,
    OUT LPDWORD InstallStatusCount,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName
    )
/*++

Routine Description:

    Routine to install one or more protected system files onto the system at
    the protected location.  A client can use this API to request that WFP
    install the specified operating system files as appropriate (instead of the
    client redistributing the operating system files!)

    The routine works by building up a file queue of the files specified by the
    caller, then it commits the queue.

Arguments:

    RpcHandle        - RPC binding handle to the SFC server
    FileNamesBuffer  - a list of NULL seperated unicode strings, terminated by
                       two NULL characters.
    FileNamesSize    - DWORD indicating the size of the string buffer above.
    InstallStatusBuffer - receives an array of FILEINSTALL_STATUS structures
    InstallStatusBufferSize - receives the size of InstallStatusBuffer
    InstallStatusCount - receives the number of files processed
    AllowUI    - a BOOL indicating whether UI is allowed or not.  If this value
                 is TRUE, then any prompts for UI cause the API call to fail.
    ClassName  - NULL terminated unicode string indicating the window classname
                 for the parent window
    WindowName - NULL terminated unicode string indicating the window name for
                 the parent window for any UI that may be displayed

Return Value:

    Win32 error code indicating outcome.

--*/
{
    WCHAR buf[MAX_PATH*2];
    HSPFILEQ hFileQ = INVALID_HANDLE_VALUE;
    PVOID MsgHandlerContext = NULL;
    DWORD rVal = ERROR_SUCCESS;
    NTSTATUS Status;
    DWORD ScanResult;
    FILE_COPY_INFO fci;
    PSFC_REGISTRY_VALUE RegVal;
    PWSTR fname;
    PNAME_NODE Node;
    ULONG cnt = 0,tmpcnt;
    ULONG sz = 0;
    PFILEINSTALL_STATUS cs = NULL;
    BOOL b;
    PWSTR s;
    PSOURCE_INFO si = NULL;
    PWSTR FileNamesScratchBuffer = NULL, FileNamesScratchBufferStart;
    PWSTR ClientBufferCopy = NULL;
    HCATADMIN hCatAdmin = NULL;

    UNREFERENCED_PARAMETER( hBinding );
    UNREFERENCED_PARAMETER( FileNamesSize );

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    rVal = SfcRpcPriviledgeCheck( hBinding );

    if (rVal != ERROR_SUCCESS) {
        return rVal;
    }

    if(NULL == FileNamesBuffer || 0 == FileNamesSize || NULL == InstallStatusBuffer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(*InstallStatusBuffer != NULL || *InstallStatusBufferSize != 0)
    {
        return ERROR_INVALID_DATA;
    }

    ZeroMemory( &fci, sizeof(FILE_COPY_INFO) );

    if (ClassName && *ClassName && WindowName && *WindowName) {
        fci.hWnd = FindWindow( ClassName, WindowName );
    }

    fci.AllowUI = AllowUI;

    //
    // create the file queue
    //

    hFileQ = SetupOpenFileQueue();
    if (hFileQ == INVALID_HANDLE_VALUE) {
        rVal = GetLastError();
        DebugPrint1( LVL_VERBOSE, L"SetupOpenFileQueue failed, ec=%d", rVal );
        goto exit;
    }

    //
    // find out how much space we'll need for the FILEINSTALL_STATUS array
    //

    try {
        ClientBufferCopy = MemAlloc( FileNamesSize );
        if (ClientBufferCopy) {
            RtlCopyMemory( ClientBufferCopy, FileNamesBuffer, FileNamesSize );

            fname = ClientBufferCopy;

            while (*fname) {
                DWORD dwSize = ExpandEnvironmentStrings( fname, buf, UnicodeChars(buf) );

                if(0 == dwSize) {
                    rVal = GetLastError();
                    break;
                }

                if(dwSize > UnicodeChars(buf)) {
                    rVal = ERROR_BUFFER_OVERFLOW;
                    break;
                }

                DebugPrint1(LVL_VERBOSE, L"S_IPF [%ws]", buf);
                //
                // size = old size
                //       + 8 (unicode null + slop)
                //       + size of current string
                //       + size of FILEINSTALL_STATUS for this entry
                //
                sz = sz + 8 + UnicodeLen(buf) + sizeof(FILEINSTALL_STATUS);
                cnt += 1;
                fname += (wcslen(fname) + 1);
            }
        } else {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rVal = RtlNtStatusToDosError(GetExceptionCode());
        DebugPrint1(LVL_VERBOSE, L"S_IPF: exception occured while parsing client file buffer, ec=0x%08x", rVal);
    }

    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // extra unicode NULL to size for termination is included in slop above
    //

    //
    // allocate and zero out the memory for the array
    //
    cs = (PFILEINSTALL_STATUS) midl_user_allocate( sz );
    if (cs == NULL) {
        rVal = ERROR_OUTOFMEMORY;
        goto exit;
    }
    ZeroMemory( cs, sz );

    *InstallStatusBuffer = (LPBYTE) cs;
    *InstallStatusBufferSize = sz;
    *InstallStatusCount = cnt;

    //
    // also create a scratch buffer for our files for later
    //
    FileNamesScratchBufferStart
        = FileNamesScratchBuffer
        = (PWSTR) MemAlloc(cnt * MAX_PATH * 2 * sizeof(WCHAR));

    if (!FileNamesScratchBuffer) {
        rVal = GetLastError();
        DebugPrint1( LVL_VERBOSE,
                     L"S_IPF: MemAlloc (%d) failed",
                     FileNamesSize );
        goto exit;
    }

    //
    // create an array of sourceinfo pointers (and an array of source_info
    // structures) so that the commital callback routine can find out about
    // the status of each file
    //
    fci.CopyStatus = cs;
    fci.FileCount = cnt;
    fci.si = (PSOURCE_INFO *)MemAlloc( cnt * sizeof(PSOURCE_INFO) );
    if (!fci.si) {
        DebugPrint1( LVL_VERBOSE,
                     L"S_IPF: MemAlloc (%d) failed",
                     cnt* sizeof(PSOURCE_INFO) );
        rVal = ERROR_OUTOFMEMORY;
        goto exit;
    }

    si = MemAlloc( cnt * sizeof(SOURCE_INFO) );
    if (!si) {
        DebugPrint1( LVL_VERBOSE,
                     L"S_IPF: MemAlloc (%d) failed",
                     cnt* sizeof(SOURCE_INFO) );
        rVal = ERROR_OUTOFMEMORY;
        goto exit;
    }

    fname = ClientBufferCopy;

    //
    // now build up the FILEINSTALL_STATUS array
    //

    //
    // First set a string pointer to the end of the FILEINSTALL_STATUS
    // array.  We will later copy strings after the array of structures.
    //
    s = (PWSTR)((LPBYTE)cs + (cnt * sizeof(FILEINSTALL_STATUS)));
    tmpcnt = 0;
    //
    // Second, for each member in the caller supplied list,
    //  - copy the filename to the end of the array
    //  - save off the pointer to the filename in the proper FILEINSTALL_STATUS
    //    member
    //  - point to the next file in the list
    //

    while (*fname) {
        DWORD StringLength;
        StringLength = ExpandEnvironmentStrings( fname, buf, UnicodeChars(buf) );

        if(0 == StringLength) {
            rVal = GetLastError();
            goto exit;
        }

        //
        // We validated the length once so we don't do that again here
        //
        StringLength = wcslen(buf);
        MyLowerString(buf, StringLength);

        wcsncpy(&FileNamesScratchBuffer[MAX_PATH*2*tmpcnt],buf,MAX_PATH);

        cs->FileName = s;

        wcscpy( s, &FileNamesScratchBuffer[MAX_PATH*2*tmpcnt] );
        s += StringLength + 1;
        cs += 1;
        tmpcnt += 1;
        fname += (wcslen(fname) + 1);

        ASSERT(tmpcnt <= cnt);
    }


    //
    // we're finally ready to queue files
    //  - determine where the file comes from
    //  - add the file to the queue using the appropriate filename if the file
    //    is renamed
    //
    cs = fci.CopyStatus;
    FileNamesScratchBuffer = FileNamesScratchBufferStart;

	//
	//initialize crypto
	//
	Status = LoadCrypto();

	if(!NT_SUCCESS(Status))
	{
		rVal = RtlNtStatusToDosError(Status);
		goto exit;
	}

    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
		rVal = GetLastError();
        DebugPrint1( LVL_MINIMAL, L"CCAAC() failed, ec = 0x%08x", rVal);
        goto exit;
    }

    //
    // Flush the Cache once before we start any Crypto operations
    //

    SfcFlushCryptoCache();

    //
    // Refresh exception packages info
    //
    SfcRefreshExceptionInfo();

    tmpcnt=0;
    while (tmpcnt < cnt) {
        Node = SfcFindProtectedFile( (PWSTR)&FileNamesScratchBuffer[MAX_PATH*2*tmpcnt], UnicodeLen(&FileNamesScratchBuffer[MAX_PATH*2*tmpcnt]) );
        if (Node) {
            HANDLE FileHandle;
            BOOL QueuedFromCache;
            IMAGE_VALIDATION_DATA SignatureData;
            UNICODE_STRING tmpPath;
            WCHAR InfFileName[MAX_PATH];
            BOOL ExcepPackFile;

            RegVal = (PSFC_REGISTRY_VALUE)Node->Context;
            ASSERT(RegVal != NULL);

            //
            // get the inf name here
            //
            ExcepPackFile = SfcGetInfName(RegVal, InfFileName);

            //
            // Setup the SOURCE_INFO structure so we can record where each file in
            // the list is coming from (ie., golden media, driver cabinet,
            // service pack, etc.)
            //
            fci.si[tmpcnt] = &si[tmpcnt];
            if (!SfcGetSourceInformation( RegVal->SourceFileName.Length ? RegVal->SourceFileName.Buffer : RegVal->FileName.Buffer, InfFileName, ExcepPackFile, &si[tmpcnt] )) {
                rVal = GetLastError();
                DebugPrint2(LVL_VERBOSE, L"S_IPF failed SfcGetSourceInformation() on %ws, ec = %x",
                            RegVal->SourceFileName.Length ? RegVal->SourceFileName.Buffer : RegVal->FileName.Buffer,
                            rVal
                           );
                goto exit;
            }

            //
            // If the file is in the dllcache and it's valid, then queue up the
            // file to be copied from the dllcache instead of the installation
            // source.
            //
            // First we check the signature of the file in the dllcache.  Then
            // we try to queue up the file from the cache if the signature is
            // valid.  If anything goes wrong, we just queue from the regular
            // install media
            //
            QueuedFromCache = FALSE;

            RtlInitUnicodeString( &tmpPath, FileNameOnMedia( RegVal ) );

            if (!SfcGetValidationData(
                        &tmpPath,
                        &SfcProtectedDllPath,
                        SfcProtectedDllFileDirectory,
                        hCatAdmin,
                        &SignatureData)) {
                DebugPrint1( LVL_MINIMAL,
                             L"SfcGetValidationData() failed, ec = 0x%08x",
                             GetLastError() );
            } else if (SignatureData.SignatureValid) {
                //
                // The file is valid, so queue it up.
                //
                // We have to munge some of the SOURCE_INFO members to make
                // this function do what we want.  Remember these members
                // in case the queuing fails.  Then we can at least try to
                // queue the files for installation from media.
                //
                WCHAR SourcePathOld;

                SourcePathOld = si[tmpcnt].SourcePath[0];
                si[tmpcnt].SourcePath[0] = L'\0';

                b = SfcAddFileToQueue(
                            hFileQ,
                            RegVal->FileName.Buffer,
                            RegVal->FileName.Buffer,
                            RegVal->DirName.Buffer,
                            FileNameOnMedia( RegVal ),
                            SfcProtectedDllPath.Buffer,
                            InfFileName,
                            ExcepPackFile,
                            &si[tmpcnt]
                            );
                if (!b) {
                    //
                    // put the source path back
                    //
                    si[tmpcnt].SourcePath[0] = SourcePathOld;

                    //
                    // print out an error but continue.
                    //
                    rVal = GetLastError();
                    DebugPrint2(
                        LVL_VERBOSE,
                        L"S_IPF failed SfcAddFileToQueue(DLLCACHE) on %ws, ec = %x",
                        RegVal->FileName.Buffer,
                        rVal  );
                } else {
                    //
                    // successfully queued from cache.  remember this and continue
                    //
                    QueuedFromCache = TRUE;
                }
            }
            //
            // add the file to the queue if we haven't already
            //

            if (!QueuedFromCache) {

                b = SfcAddFileToQueue(
                    hFileQ,
                    RegVal->FileName.Buffer,
                    RegVal->FileName.Buffer,
                    RegVal->DirName.Buffer,
                    FileNameOnMedia( RegVal ),
                    NULL,
                    InfFileName,
                    ExcepPackFile,
                    &si[tmpcnt]
                    );
                if (!b) {
                    rVal = GetLastError();
                    DebugPrint2(
                        LVL_VERBOSE,
                        L"S_IPF failed SfcAddFileToQueue() on %ws, ec = %x",
                        RegVal->FileName.Buffer,
                        rVal  );
                    goto exit;
                }

            }

            //
            // see if the file is already present so we can save off the file
            // version.  If we copy in a new file, we will update the file
            // version at that time.  But if the file is already present and
            // signed, we will not copy the file and we must save off the file
            // version in that case.
            //
            Status = SfcOpenFile( &RegVal->FileName, RegVal->DirHandle, SHARE_ALL, &FileHandle);
            if (NT_SUCCESS(Status)) {
                SfcGetFileVersion( FileHandle, &cs->Version, NULL, NULL);

                NtClose( FileHandle );
            }

        } else {
            //
            // File is not in protected list.  We'll just mark the file as not
            // found and continue committing the rest of the files
            //
            DebugPrint1(LVL_VERBOSE,
                        L"S_IPF failed to find %ws in protected file list",
                        &FileNamesScratchBuffer[MAX_PATH*2*tmpcnt] );
            cs->Win32Error = ERROR_FILE_NOT_FOUND;
        }

        cs += 1;

        tmpcnt+=1;
    }

    cs = fci.CopyStatus;
    fci.Flags |= FCI_FLAG_INSTALL_PROTECTED;

    //
    // setup the default queue callback with the popups disabled
    //

    MsgHandlerContext = SetupInitDefaultQueueCallbackEx( NULL, INVALID_HANDLE_VALUE, 0, 0, 0 );
    if (MsgHandlerContext == NULL) {
        rVal = GetLastError();
        DebugPrint1( LVL_VERBOSE, L"SetupInitDefaultQueueCallbackEx failed, ec=%d", rVal );
        goto exit;
    }

    fci.MsgHandlerContext = MsgHandlerContext;

    //
    // see if the files in the queue are already present and valid.  If they
    // are, then we don't have to copy anything
    //
    b = SetupScanFileQueue(
                    hFileQ,
                    SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                    fci.hWnd,
                    NULL,
                    NULL,
                    &ScanResult);

    //
    // if SetupScanFileQueue succeeds, ScanResult = 1 and we don't have to copy
    // anything at all.  If it failed (it shouldn't), then we just commit the
    // queue anyway.
    //
    if (!b) {
        ScanResult = 0;
    }

    if (ScanResult == 1) {

        b = TRUE;

    } else {
        //
        // commit the file queue
        //

        b = SetupCommitFileQueue(
            NULL,
            hFileQ,
            SfcQueueCallback,
            &fci
            );

        if (!b) {
            DebugPrint1( LVL_VERBOSE, L"SetupCommitFileQueue failed, ec=%d", GetLastError() );
            rVal = GetLastError();
            goto exit;
        }
    }

    //
    // now that the queue is committed, we need to turn the filename pointers
    // from actual filename pointers into offsets to the filename so that RPC
    // can send the data back to the clients
    //
    for (sz=0; sz<cnt; sz++) {
        cs[sz].FileName = (PWSTR)((DWORD_PTR)cs[sz].FileName - (DWORD_PTR)fci.CopyStatus);
    }

exit:

    //
    // cleanup and exit
    //

    if (hCatAdmin) {
        CryptCATAdminReleaseContext(hCatAdmin,0);
    }

    if (MsgHandlerContext) {
        SetupTermDefaultQueueCallback( MsgHandlerContext );
    }
    if (hFileQ != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue( hFileQ );
    }

    if (FileNamesScratchBuffer) {
        MemFree(FileNamesScratchBuffer);
    }

    if (si) {
        MemFree( si );
    }

    if (fci.si) {
        MemFree( fci.si );
    }

    if (ClientBufferCopy) {
        MemFree( ClientBufferCopy );
    }

    if (rVal != ERROR_SUCCESS) {
        if(*InstallStatusBuffer != NULL) {
            midl_user_free(*InstallStatusBuffer);
        }

        *InstallStatusBuffer = NULL;
        *InstallStatusBufferSize = 0;
        *InstallStatusCount = 0;
    }
    return rVal;
}


DWORD
WINAPI
SfcSrv_GetNextProtectedFile(
    IN HANDLE RpcHandle,
    IN DWORD FileNumber,
    IN LPBYTE *FileName,
    IN LPDWORD FileNameSize
    )
/*++

Routine Description:

    Routine to retrieve the next protected file in the list.

Arguments:

    RpcHandle    - RPC binding handle to the SFC server
    FileNumer    - 1-based number of file to be retrieved
    FileName     - receives file name string
    FileNameSize - size of file name string

Return Value:

    win32 error code indicating success.

--*/
{
    LPWSTR szName;
    LPBYTE pBuffer;
    DWORD dwSize;
    UNREFERENCED_PARAMETER( RpcHandle );

    if(NULL == FileName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(*FileName != NULL || *FileNameSize != 0)
    {
        return ERROR_INVALID_DATA;
    }

    //
    // The filenumber is zero based, and we return "no more files" to
    // signify that they've enumerated all of the files
    //
    if (FileNumber >= SfcProtectedDllCount) {
        return ERROR_NO_MORE_FILES;
    }

    //
    // get the proper file from the list, allocate a buffer, and copy the
    // filename into the buffer
    //
    szName = SfcProtectedDllsList[FileNumber].FullPathName.Buffer;
    dwSize = UnicodeLen(szName) + sizeof(WCHAR);
    pBuffer = (LPBYTE) midl_user_allocate( dwSize );

    if(NULL == pBuffer)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlCopyMemory( pBuffer, szName, dwSize);
    *FileName = pBuffer;
    *FileNameSize = dwSize;
    return ERROR_SUCCESS;
}


DWORD
WINAPI
SfcSrv_IsFileProtected(
    IN HANDLE RpcHandle,
    IN PCWSTR ProtFileName
    )
/*++

Routine Description:

    Routine to determine if the specified file is protected.

Arguments:

    RpcHandle    - RPC binding handle to the SFC server
    ProtFileName - NULL terminated unicode string indicating fully qualified
                   filename to query

Return Value:

    Win32 error code indicating outcome.

--*/
{
    WCHAR buf[MAX_PATH];
	DWORD dwSize;
    UNREFERENCED_PARAMETER( RpcHandle );

    if (!ProtFileName)
        return ERROR_INVALID_PARAMETER;

    //
    // our internal structures all assume the strings are in lower case.  we
    // must convert our search string to lowercase as well.
    //
    if (!*ProtFileName)
        return ERROR_INVALID_DATA;

    dwSize = ExpandEnvironmentStrings( ProtFileName, buf, UnicodeChars(buf));

    if(0 == dwSize)
    {
        DWORD retval = GetLastError();
        DebugPrint1( LVL_MINIMAL, L"ExpandEnvironmentStrings failed, ec = 0x%x", retval);
        return retval;
    }

    if(dwSize > UnicodeChars(buf))
    {
        //
        // expandenvironmentstrings must have encountered a buffer that was
        // too large
        //
        DebugPrint(LVL_MINIMAL, L"ExpandEnvironmentStrings failed with STATUS_BUFFER_TOO_SMALL");
        return ERROR_INSUFFICIENT_BUFFER;
    }

    MyLowerString( buf, wcslen(buf) );

    if (!SfcFindProtectedFile( buf, UnicodeLen(buf) ))
        return ERROR_FILE_NOT_FOUND;

    return ERROR_SUCCESS;
}


DWORD
WINAPI
SfcSrv_PurgeCache(
    IN HANDLE hBinding
    )

/*++

Routine Description:

    Routine to purge the contents of the dllcache.

Arguments:

    RpcHandle - RPC binding handle to the SFC server

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD retval = ERROR_SUCCESS, DeleteError = ERROR_SUCCESS;
    WCHAR CacheDir[MAX_PATH];
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    PWSTR p;

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    retval = SfcRpcPriviledgeCheck( hBinding );
    if (retval != ERROR_SUCCESS) {
        goto exit;
    }

    ASSERT(SfcProtectedDllPath.Buffer != NULL);

    wcscpy( CacheDir, SfcProtectedDllPath.Buffer);
    pSetupConcatenatePaths( CacheDir, L"*", MAX_PATH, NULL );

    //
    // save pointer to directory
    //
    p = wcsrchr( CacheDir, L'\\' );
    if (!p) {
        ASSERT(FALSE);
        retval = ERROR_INVALID_DATA;
        goto exit;
    }

    p += 1;

    hFind = FindFirstFile( CacheDir, &FindFileData );
    if (hFind == INVALID_HANDLE_VALUE) {
        retval = GetLastError();
        goto exit;
    }

    do {
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            wcscpy( p, FindFileData.cFileName );
            SetFileAttributes( CacheDir, FILE_ATTRIBUTE_NORMAL );
            if (!DeleteFile( CacheDir )) {
                DeleteError = GetLastError();
            }
        }
    } while(FindNextFile( hFind, &FindFileData ));

    FindClose( hFind );

    retval = DeleteError;

exit:
    return(retval);
}


DWORD
WINAPI
SfcSrv_SetDisable(
    IN HANDLE hBinding,
    IN DWORD NewValue
    )

/*++

Routine Description:

    Routine to set the disable flag in the registry.

Arguments:

    RpcHandle - RPC binding handle to the SFC server
    NewValue - value of SFCDisable key in registry.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD retval = ERROR_SUCCESS;

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    retval = SfcRpcPriviledgeCheck( hBinding );
    if (retval != ERROR_SUCCESS) {
        goto exit;
    }


    switch( NewValue ) {
        case SFC_DISABLE_SETUP:
        case SFC_DISABLE_QUIET:
            retval = ERROR_INVALID_PARAMETER;
            break;
        case SFC_DISABLE_ONCE:
        case SFC_DISABLE_NOPOPUPS:
        case SFC_DISABLE_ASK:
        case SFC_DISABLE_NORMAL:

            retval = SfcWriteRegDword( REGKEY_WINLOGON, REGVAL_SFCDISABLE, NewValue );

            //
            // Issue: it would be nice if we made this "realtime", and shutdown
            // WFP if the caller requested.
            //

            // InterlockedExchange( &SFCDisable, NewValue );
            break;

    }


exit:
    return(retval);
}

DWORD
WINAPI
SfcSrv_SetCacheSize(
    IN HANDLE hBinding,
    IN DWORD NewValue
    )

/*++

Routine Description:

    Routine to set the dllcache quota size.

Arguments:

    RpcHandle - RPC binding handle to the SFC server
    NewValue -  value of SFCQuota key in registry.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD retval = ERROR_SUCCESS;

    ULONGLONG tmp;

    //
    // do an access check to make sure the caller is allowed to perform this
    // action.
    //
    retval = SfcRpcPriviledgeCheck( hBinding );
    if (retval != ERROR_SUCCESS) {
        goto exit;
    }

    if( NewValue == SFC_QUOTA_ALL_FILES ) {
        tmp = (ULONGLONG)-1;
    } else {
        tmp = NewValue * (1024*1024);
    }


    SFCQuota = tmp;
    retval = SfcWriteRegDword( REGKEY_WINLOGON, REGVAL_SFCQUOTA, NewValue );

exit:
    return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\crypto.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    Implementation of crypto access.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 7-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

typedef BOOL
(WINAPI *PCRYPTCATADMINRESOLVECATALOGPATH)(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
SfcRestoreSingleCatalog(
    IN PCWSTR CatalogName,
    IN PCWSTR CatalogFullPath
    );


//
// pointers to the crypto functions we call
//
PCRYPTCATADMINRESOLVECATALOGPATH  pCryptCATAdminResolveCatalogPath;

//
// global system catalog guid we pass into WinVerifyTrust
//
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;

//
// Specifies if crypto API is initialized
//
BOOL g_bCryptoInitialized = FALSE;
NTSTATUS g_CryptoStatus = STATUS_SUCCESS;

//
// critical section to protect crypto initialization and exception packages file tree
//

RTL_CRITICAL_SECTION g_GeneralCS;

BOOL
MyCryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwSize = ExpandEnvironmentStrings(
        L"%systemroot%\\system32\\catroot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\\",
        psCatInfo->wszCatalogFile,
        MAX_PATH);

    if(0 == dwSize || dwSize > MAX_PATH) {
        psCatInfo->wszCatalogFile[0] = 0;
    }

    wcscat(psCatInfo->wszCatalogFile,pwszCatalogFile);

    return TRUE;
}



BOOL
SfcValidateSingleCatalog(
    IN PCWSTR CatalogNameFullPath
    )
/*++

Routine Description:

    Routine to determine if the specified system catalog has a valid signature.

Arguments:

    CatalogNameFullPath   - null terminated string indicating full path to
                            catalog file to be validated

Return Value:

    Win32 error code indicating outcome.

--*/
{
    ULONG SigErr = ERROR_SUCCESS;
    WINTRUST_DATA WintrustData;
    WINTRUST_FILE_INFO WintrustFileInfo;
    DRIVER_VER_INFO OsAttrVersionInfo;
    OSVERSIONINFO OsVersionInfo;

    ASSERT(CatalogNameFullPath != NULL);

    //
    // build up the structure to pass into winverifytrust
    //
    ZeroMemory( &WintrustData, sizeof(WINTRUST_DATA) );
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.dwStateAction = WTD_STATEACTION_IGNORE;
    WintrustData.dwProvFlags =  WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                                WTD_CACHE_ONLY_URL_RETRIEVAL;
    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WintrustData.pFile = &WintrustFileInfo;

    ZeroMemory( &WintrustFileInfo, sizeof(WINTRUST_FILE_INFO) );
    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    WintrustFileInfo.pcwszFilePath = CatalogNameFullPath;

    //
    //  Initialize the DRIVER_VER_INFO structure to validate
    //  against 5.0 and 5.1 OSATTR
    //

    ZeroMemory( &OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    ZeroMemory(&OsAttrVersionInfo, sizeof(DRIVER_VER_INFO));
    OsAttrVersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);
    OsAttrVersionInfo.dwPlatform = VER_PLATFORM_WIN32_NT;
    OsAttrVersionInfo.sOSVersionLow.dwMajor = 5;
    OsAttrVersionInfo.sOSVersionLow.dwMinor = 0;

    if (GetVersionEx(&OsVersionInfo)) {

        OsAttrVersionInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
        OsAttrVersionInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;

        //Set this only if all went well
        WintrustData.pPolicyCallbackData = (LPVOID)(&OsAttrVersionInfo);

    }else{
        DebugPrint1( LVL_MINIMAL, L"Could not get OS Version while validating single catalog - GetVersionEx failed (%d)", GetLastError() );
    }

    //
    // call winverfifytrust to check signature
    //
    SigErr = (DWORD)WinVerifyTrust(
        NULL,
        &DriverVerifyGuid,
        &WintrustData
        );
    if(SigErr != ERROR_SUCCESS) {
        DebugPrint2(
            LVL_MINIMAL,
            L"WinVerifyTrust of catalog %s failed, ec=0x%08x",
            CatalogNameFullPath,
            SigErr );
        SetLastError(SigErr);
        return FALSE;
    }

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (OsAttrVersionInfo.pcSignerCertContext != NULL) {

        CertFreeCertificateContext(OsAttrVersionInfo.pcSignerCertContext);
        OsAttrVersionInfo.pcSignerCertContext = NULL;
    }


    return TRUE;
}


BOOL
SfcRestoreSingleCatalog(
    IN PCWSTR CatalogName,
    IN PCWSTR CatalogFullPath
    )
/*++

Routine Description:

    Routine to restore the specified catalog.  The catalog must be reinstalled
    by calling the CryptCATAdminAddCatalog API (pSetupInstallCatalog is a wrapper
    for this API).

    Note that this function may block if a user is not currently logged on.

Arguments:

    CatalogName  - name of catalog to be restored.  This is just the filename
                   part of the catalog, not the complete path.

    CatalogFullPath - name of catalog file to be restored.  This is the full
                  path to the file so we can validate it when it is restored.

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL b = FALSE;
    NTSTATUS Status;
    WCHAR Buffer[MAX_PATH];
    DWORD d;
    PWSTR p;
    UNICODE_STRING FileString;

    //
    // check if the catalog file is in the dllcache, and if so, try to restore
    // it
    //
    if (SfcProtectedDllFileDirectory) {
        MYASSERT(SfcProtectedDllPath.Buffer != NULL);

        wcscpy(Buffer,SfcProtectedDllPath.Buffer);
        pSetupConcatenatePaths(Buffer, CatalogName, MAX_PATH, NULL);

        if (!SfcValidateSingleCatalog( Buffer )) {
            //
            // the catalog in the dll cache is invalid.  Get rid of it.
            //
            DebugPrint1(
                LVL_MINIMAL,
                L"catalog %s in dllcache is invalid, deleting it.",
                Buffer);
            RtlInitUnicodeString(&FileString,CatalogName);
            SfcDeleteFile(
                SfcProtectedDllFileDirectory,
                &FileString );
        } else {
            //
            // the catalog in the dll cache is valid.  Let's isntall it.
            //
            d = pSetupInstallCatalog(Buffer,CatalogName,NULL);
            if (d == NO_ERROR) {
                DebugPrint1(
                    LVL_MINIMAL,
                    L"catalog %s was successfully installed.",
                    CatalogName);

                return(SfcValidateSingleCatalog(CatalogFullPath));
            } else {
                DebugPrint2(
                    LVL_MINIMAL,
                    L"catalog %s failed to install, ec = 0x%08x",
                    Buffer,
                    d);

                //
                // we could try to restore from media at this point, but if we
                // failed to restore from the dllcache even though that copy is
                // valid, I don't see how restoring from media will be any
                // more successful.
                //
                return(FALSE);

            }
        }
    }

    //
    // either the catalog file was invalid in the dllcache (and has since been
    // deleted), or the dllcache isn't initialized to anything valid.
    //

    // We have to wait for someone to logon so that we can restore the catalog
    // from installation media
    // -- note that we just restore from media if we're in GUI
    //   Setup.
    //
    if (SFCDisable != SFC_DISABLE_SETUP) {
        Status = NtWaitForSingleObject(hEventLogon,TRUE,NULL);
        if (!NT_SUCCESS(Status)) {
            DebugPrint1(
                LVL_MINIMAL,
                L"Failed waiting for the logon event, ec=0x%08x",
                Status);
        }
    }

    if (!SfcProtectedDllFileDirectory) {
        DWORD dwSize = ExpandEnvironmentStrings(L"%systemroot%\\system32", Buffer, UnicodeChars(Buffer));

        if(0 == dwSize || dwSize > UnicodeChars(Buffer)) {
            Buffer[0] = L'\\';
        }

    } else {
        wcscpy(Buffer,SfcProtectedDllPath.Buffer);
    }

    p = Buffer;


    b = SfcRestoreFileFromInstallMedia(
                        NULL,
                        CatalogName,
                        CatalogName,
                        p,
                        NULL,
                        NULL,
                        FALSE, // ###
                        FALSE, // target is NOT cache (it really could be, but
                               // pretend it isn't for the sake of this call)
                        (SFCDisable == SFC_DISABLE_SETUP) ? FALSE : TRUE,
                        NULL );

    if (b) {
        pSetupConcatenatePaths(Buffer, CatalogName, MAX_PATH, NULL);

        d = pSetupInstallCatalog(Buffer,CatalogName,NULL);

        b = (d == NO_ERROR);

        //
        // if we installed the catalog to somewhere besides the dllcache, then
        // we need to cleanup the temporary file that we installed.
        //
        if (!SfcProtectedDllFileDirectory) {
            HANDLE hDir;
            p = wcsrchr(Buffer,L'\\');
            if (p != NULL) {
                if(p == Buffer) {
                    ++p;
                }

                *p = L'\0';
            }
            hDir = SfcOpenDir( TRUE, TRUE, Buffer );
            RtlInitUnicodeString(&FileString,CatalogName);
            SfcDeleteFile( hDir , &FileString );
            CloseHandle( hDir );
        }

        if (d == NO_ERROR) {
            DebugPrint1(
                LVL_MINIMAL,
                L"catalog %s was successfully installed.",
                CatalogName);

            return(SfcValidateSingleCatalog(CatalogFullPath));
        } else {
            DebugPrint2(
                LVL_MINIMAL,
                L"catalog %s failed to install, ec = 0x%08x",
                Buffer,
                d);
        }
    }

    return(b);
}

BOOL SfcRestoreASingleFile(
    IN HCATADMIN hCatAdmin,
    IN PUNICODE_STRING FileName,
    IN HANDLE DirHandle,
    IN PWSTR FilePathPartOnly
    )
/*++

Routine Description:

    Routine to restore the specified file.  We first check for the file in the
    dllcache, and if the copy in the dll cache is valid, we use it, otherwise
    we restore from media.

    Note that this function may block if a user is not currently logged on.

Arguments:

    hCatAdmin    - catalog context for restoring the file
    FileName     - unicode string to file to be restored
    DirHandle    - directory handle of file to be restored
    FilePathPartOnly - string indicating the path to the file to be restored.

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL b = FALSE;
    NTSTATUS Status;
    WCHAR Buffer[MAX_PATH];
    HANDLE FileHandle;

    //
    // check if the file is in the dllcache and signed, and if so, try to restore
    // it
    //
    if (SfcProtectedDllFileDirectory) {
        MYASSERT(SfcProtectedDllPath.Buffer != NULL);

        wcscpy(Buffer,SfcProtectedDllPath.Buffer);
        pSetupConcatenatePaths(Buffer, FileName->Buffer, MAX_PATH, NULL);

        Status = SfcOpenFile(
                       FileName,
                       SfcProtectedDllFileDirectory,
                       SHARE_ALL,
                       &FileHandle );

        if (NT_SUCCESS(Status)) {
            if (!SfcValidateFileSignature(
                            hCatAdmin,
                            FileHandle,
                            FileName->Buffer,
                            Buffer)) {
                //
                // the file in the dll cache is invalid.  Get rid of it.
                //
                DebugPrint1(
                    LVL_MINIMAL,
                    L"file %s in dllcache is invalid, deleting it.",
                    Buffer);
                SfcDeleteFile(
                    SfcProtectedDllFileDirectory,
                    FileName );

                CloseHandle(FileHandle);
                FileHandle = NULL;
            } else {
                //
                // the file in the dll cache is valid.  copy it into place.
                //
                Status = SfcCopyFile( SfcProtectedDllFileDirectory,
                                      SfcProtectedDllPath.Buffer,
                                      DirHandle,
                                      FilePathPartOnly,
                                      FileName,
                                      NULL);

                if (NT_SUCCESS(Status)) {
                    DebugPrint1(
                        LVL_MINIMAL,
                        L"file %wZ was successfully installed, checking it's signature",
                        FileName);

                    CloseHandle(FileHandle);
                    FileHandle = NULL;

                    Status = SfcOpenFile(
                                    FileName,
                                    DirHandle,
                                    SHARE_ALL,
                                    &FileHandle);

                    wcscpy(Buffer,FilePathPartOnly);
                    pSetupConcatenatePaths(Buffer, FileName->Buffer, MAX_PATH, NULL);

                    if (NT_SUCCESS(Status)
                        && SfcValidateFileSignature(
                                            hCatAdmin,
                                            FileHandle,
                                            FileName->Buffer,
                                            Buffer)) {
                        DebugPrint1(
                            LVL_MINIMAL,
                            L"file %wZ was successfully installed and validated",
                            FileName);

                        CloseHandle(FileHandle);
                        return(TRUE);

                    } else {
                        DebugPrint1(
                            LVL_MINIMAL,
                            L"file %s failed to validate",
                            Buffer);
                        if (FileHandle) {
                            CloseHandle(FileHandle);
                            FileHandle = NULL;
                        }

                        //
                        // we could try to restore from media at this point, but if we
                        // failed to restore from the dllcache even though that copy is
                        // valid, I don't see how restoring from media will be any
                        // more successful.
                        //
                        return(FALSE);
                    }
                }
            }
        }
    }

    //
    // either the file file was invalid in the dllcache (and has since been
    // deleted), or the dllcache isn't initialized to anything valid.
    //

    // We have to wait for someone to logon so that we can restore the file
    // from installation media
    // -- note that we just restore from media if we're in GUI
    //   Setup.
    //
    if (SFCDisable != SFC_DISABLE_SETUP) {
        MYASSERT( hEventLogon != NULL );
        Status = NtWaitForSingleObject(hEventLogon,TRUE,NULL);
        if (!NT_SUCCESS(Status)) {
            DebugPrint1(
                LVL_MINIMAL,
                L"Failed waiting for the logon event, ec=0x%08x",
                Status);
        }
    }

    b = SfcRestoreFileFromInstallMedia(
                        NULL,
                        FileName->Buffer,
                        FileName->Buffer,
                        FilePathPartOnly,
                        NULL,
                        NULL,
                        FALSE, // ###
                        FALSE, // target is NOT cache
                        (SFCDisable == SFC_DISABLE_SETUP) ? FALSE : TRUE,
                        NULL );

    if (b) {
        Status = SfcOpenFile(
                FileName,
                DirHandle,
                SHARE_ALL,
                &FileHandle);

        wcscpy(Buffer,FilePathPartOnly);
        pSetupConcatenatePaths(Buffer, FileName->Buffer, MAX_PATH, NULL);

        if (NT_SUCCESS(Status)) {
            b = SfcValidateFileSignature(
                                hCatAdmin,
                                FileHandle,
                                FileName->Buffer,
                                Buffer);
            CloseHandle(FileHandle);

            DebugPrint2(
                LVL_MINIMAL,
                L"file %wZ was%s successfully installed and validated",
                FileName,
                b ? L" " : L" not");

        } else {
            b = FALSE;
        }


    } else {
        DebugPrint2(
            LVL_MINIMAL,
            L"file %s failed to install, ec = 0x%08x",
            Buffer,
            GetLastError());
    }

    return(b);
}



BOOL
SfcValidateCatalogs(
    VOID
    )
/*++

Routine Description:

    Validates that all system catalogs have a valid signature.  If
    a system catalog is not signed, then WFP will try to restore the files.

    Note that simply copying the file into place is NOT sufficient.  Instead,
    we must re-register the catalog with the crypto subsystem.

    This function runs very early on during WFP initialization, and may rely on
    the following:

    1) crypto subsystem being initialized so we can check file signatures.

    2) syssetup.inf being present on the system and signed.  Syssetup.inf
       contains the list of system catalogs.  If syssetup.inf isn't signed,
       we'll have to restore it, and this may require network access or
       prompting a user, when one finally logs on.


Arguments:

    NONE.

Return Value:

    TRUE if all critical system catalogs were validated as OK , FALSE on failure.
    If some "non-critical" catalogs fail to validate and restore, we still
    return TRUE.  We will log an error about the non-critical catalogs failing
    to install, however.

--*/
{
    NTSTATUS Status;
    PWSTR pInfPathOnly, pInfFullPath;
    BOOL RetVal = FALSE, CriticalCatalogFailedToValidateOrRestore = FALSE;
    HCATADMIN hCatAdmin = NULL;
    HANDLE InfDirHandle,InfFileHandle;
    UNICODE_STRING FileString;
    CATALOG_INFO CatInfo;
    PCWSTR CriticalCatalogList[] = {
                            L"nt5inf.cat",
                            L"nt5.cat" };

    #define CriticalCatalogCount  (sizeof(CriticalCatalogList)/sizeof(PCWSTR))
    BOOL CriticalCatalogVector[CriticalCatalogCount] = {FALSE};
    DWORD i,Count;
    HINF hInf;




    pInfPathOnly = MemAlloc(sizeof(WCHAR)*MAX_PATH);
    if (!pInfPathOnly) {
        goto e0;
    }

    pInfFullPath = MemAlloc(sizeof(WCHAR)*MAX_PATH);
    if (!pInfFullPath) {
        goto e1;
    }

    Count = ExpandEnvironmentStrings(L"%systemroot%\\inf", pInfPathOnly, MAX_PATH);

    if(0 == Count) {
        goto e2;
    }

    if(Count > MAX_PATH) {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        goto e2;
    }

    wcscpy(pInfFullPath, pInfPathOnly);
    pSetupConcatenatePaths(pInfFullPath, L"syssetup.inf", MAX_PATH, NULL);

    InfDirHandle = SfcOpenDir( TRUE, TRUE, pInfPathOnly );
    if (!InfDirHandle) {
        DebugPrint1( LVL_MINIMAL, L"failed to open inf directory, ec=%d", GetLastError() );
        goto e2;
    }

    RtlInitUnicodeString(&FileString,L"syssetup.inf");

    Status = SfcOpenFile( &FileString, InfDirHandle, SHARE_ALL, &InfFileHandle );
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            DebugPrint( LVL_MINIMAL, L"syssetup.inf is missing.  Trying to restore it" );
            goto restore_inf;
        }

        DebugPrint1( LVL_MINIMAL, L"failed to open syssetup.inf, ec=0x%08x", Status );
        goto e2;
    }

    //
    // aquire an HCATADMIN so we can check the signature of syssetup.inf.
    //
    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        DebugPrint1( LVL_MINIMAL, L"CCAAC() failed, ec=%x", GetLastError() );
        return(FALSE);
    }

    //
    // Flush the Cache once before we start any Crypto operations
    //

    SfcFlushCryptoCache();




    if (!SfcValidateFileSignature(
                        hCatAdmin,
                        InfFileHandle,
                        L"syssetup.inf",
                        pInfFullPath )) {
        CloseHandle(InfFileHandle);
        DebugPrint1( LVL_MINIMAL, L"syssetup.inf isn't signed, attempting to restore. ec=%x", GetLastError() );
        goto restore_inf;
    }

    CloseHandle(InfFileHandle);

    goto full_catalog_validation;

restore_inf:

    if (!SfcRestoreASingleFile(
                    hCatAdmin,
                    &FileString,
                    InfDirHandle,
                    pInfPathOnly
                    )) {
        DebugPrint1( LVL_MINIMAL, L"couldn't restore syssetup.inf, ec=%d", GetLastError() );
        goto minimal_catalog_validation;

    }

full_catalog_validation:

    //
    // 2. validate syssetup.inf against that catalog.  If syssetup.inf is
    // unsigned, then default to checking if nt5inf.cat is signed.  If it
    // is signed, then restore syssetup.inf and start over, but bail out if
    // we've been here before.
    //
    hInf = SetupOpenInfFile(pInfFullPath, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE) {
        DebugPrint1(
            LVL_MINIMAL,
            L"couldn't open syssetup.inf, doing minimal catalog validation, ec=%d",
            GetLastError() );
        goto minimal_catalog_validation;
    }


    Count = SetupGetLineCount( hInf, L"ProductCatalogsToInstall");
    if (Count == 0) {
        DebugPrint(
              LVL_MINIMAL,
              L"failed to retreive catalogs via syssetup.inf, validate using critical catalog list");
        goto minimal_catalog_validation;
    }
    for (i = 0; i < Count; i++) {
        INFCONTEXT InfContext;
        WCHAR CatalogName[MAX_PATH];
        BOOL SuccessfullyValidatedOrRestoredACatalog = FALSE;
        if(SetupGetLineByIndex(
                        hInf,
                        L"ProductCatalogsToInstall",
                        i,
                        &InfContext) &&
           (SetupGetStringField(
                        &InfContext,
                        1,
                        CatalogName,
                        sizeof(CatalogName)/sizeof(WCHAR),
                        NULL))) {
            CatInfo.cbStruct = sizeof(CATALOG_INFO);
            pCryptCATAdminResolveCatalogPath(
                                    hCatAdmin,
                                    CatalogName,
                                    &CatInfo,
                                    0 );


            if (!SfcValidateSingleCatalog( CatInfo.wszCatalogFile )) {
                if (!SfcRestoreSingleCatalog(
                                        CatalogName,
                                        CatInfo.wszCatalogFile )) {
                    DWORD j;
                    DebugPrint2(
                        LVL_MINIMAL,
                        L"couldn't restore catalog %s, ec=%d",
                        CatInfo.wszCatalogFile,
                        GetLastError() );
                    for (j = 0; j < CriticalCatalogCount; j++) {
                        if (0 == _wcsicmp(CatalogName,CriticalCatalogList[j])) {
                            CriticalCatalogFailedToValidateOrRestore = TRUE;
                            break;
                        }
                    }
                } else {
                    SuccessfullyValidatedOrRestoredACatalog = TRUE;
                }
            } else {
                SuccessfullyValidatedOrRestoredACatalog = TRUE;
            }

            if (SuccessfullyValidatedOrRestoredACatalog) {
                DWORD j;
                for (j = 0; j < CriticalCatalogCount; j++) {
                    if (0 == _wcsicmp(CatalogName,CriticalCatalogList[j])) {
                        CriticalCatalogVector[j] = TRUE;
                        break;
                    }
                }
            } else {
                DWORD LastError = GetLastError();
                //
                // log an error
                //
                DebugPrint2(
                    LVL_MINIMAL,
                    L"couldn't restore or validate catalog %s, ec=%d",
                    CatInfo.wszCatalogFile,
                    LastError );

                SfcReportEvent(
                    MSG_CATALOG_RESTORE_FAILURE,
                    CatInfo.wszCatalogFile,
                    NULL,
                    LastError);

            }

        } else {
            DebugPrint(
                LVL_MINIMAL,
                L"failed to retreive catalogs via syssetup.inf, validate using critical catalog list");
            goto minimal_catalog_validation;
        }
    }

    if (CriticalCatalogFailedToValidateOrRestore) {
        RetVal = FALSE;
        goto e3;
    } else {
        CriticalCatalogFailedToValidateOrRestore = FALSE;
        for (i = 0; i< CriticalCatalogCount; i++) {
            if (!CriticalCatalogVector[i]) {
                CriticalCatalogFailedToValidateOrRestore = TRUE;
            }
        }

        RetVal = !CriticalCatalogFailedToValidateOrRestore;
        goto e3;
    }

    MYASSERT(FALSE && "Should never get here");

    //
    // 3. validate all remaining catalogs in [ProductCatalogsToInstall] section.
    // Keep an internal list of critical catalogs, and if any of these fail to
    // be signed (and restored), then we should fail this function, and thus
    // fail to initialize WFP.  Otherwise, we'll treat the other catalogs being
    // invalid as a non-fatal error.


minimal_catalog_validation:

    CriticalCatalogFailedToValidateOrRestore = FALSE;

    for (i = 0; i < CriticalCatalogCount; i++) {
        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        pCryptCATAdminResolveCatalogPath(
                                hCatAdmin,
                                (PWSTR) CriticalCatalogList[i],
                                &CatInfo,
                                0 );


        if (!SfcValidateSingleCatalog( CatInfo.wszCatalogFile )) {
            if (!SfcRestoreSingleCatalog(
                                CriticalCatalogList[i],
                                CatInfo.wszCatalogFile )) {
                DebugPrint2(
                    LVL_MINIMAL,
                    L"couldn't restore critical catalog %s, ec=%d",
                    CatInfo.wszCatalogFile,
                    GetLastError() );
                CriticalCatalogFailedToValidateOrRestore = TRUE;
            }
        }

    }

    RetVal = !CriticalCatalogFailedToValidateOrRestore;

e3:
    CryptCATAdminReleaseContext( hCatAdmin, 0 );
e2:
    MemFree(pInfFullPath);
e1:
    MemFree(pInfPathOnly);
e0:
    return(RetVal);
}


NTSTATUS
LoadCrypto(
    VOID
    )

/*++

Routine Description:

    Loads all of the required DLLs that are necessary for
    doing driver signing and cataloge verification.

    This dynamic calling mechanism is necessary because this
    code is actually NOT used by session manager at this time.
    It is build here and is used conditionaly at runtime.  This
    code is linked into SMSS and WINLOGON, but only used by
    WINLOGON right now.  When the crypto functions are available
    as NT functions then the dynamic code here can be removed.

Arguments:

    None.

Return Value:

    NT status code.

--*/

{
    HMODULE hModuleWinTrust;
    RtlEnterCriticalSection(&g_GeneralCS);

    if(g_bCryptoInitialized)
    {
        RtlLeaveCriticalSection(&g_GeneralCS);
        return g_CryptoStatus;  // exit here to avoid cleanup
    }

    g_bCryptoInitialized = TRUE;    // set this anyway so no other thread will enter again
    hModuleWinTrust = GetModuleHandleW(L"wintrust.dll");
    ASSERT(hModuleWinTrust != NULL);
    pCryptCATAdminResolveCatalogPath = SfcGetProcAddress( hModuleWinTrust, "CryptCATAdminResolveCatalogPath" );

    if (pCryptCATAdminResolveCatalogPath == NULL) {
        pCryptCATAdminResolveCatalogPath = MyCryptCATAdminResolveCatalogPath;
    }

    if (!SfcValidateCatalogs()) {
        DebugPrint1( LVL_MINIMAL, L"LoadCrypto: failed SfcValidateCatalogs, ec=%d", GetLastError() );
        g_CryptoStatus = STATUS_NO_SUCH_FILE;
    }

    RtlLeaveCriticalSection(&g_GeneralCS);

    if (!(NT_SUCCESS(g_CryptoStatus))) {
        DebugPrint1( LVL_MINIMAL, L"LoadCrypto failed, ec=0x%08x", g_CryptoStatus );

        //
        // Terminate WFP
        //
        SfcTerminateWatcherThread();
    }

    return g_CryptoStatus;
}

void
SfcFlushCryptoCache(
    void
    )
/*++

Routine Description:

    Flushes the crypto catalog cache. Crypto by default maintains a per process based
    cache that it uses for fast signature verification. The bad part is that the cache
    is not updated if somebody updates (remove/add) a catalog file outside of this process.
    This can be a problem with install/uninstall/install of service packs etc. To workaround this
    we will need to flush the cache before we do any set of verifications. We want to do this at
    the beginning of such a set of operations as we don't want to affect performance by tearing
    down the cache before every file verification as we do today.



Arguments:

    None.

Return Value:

    None.

--*/

{

    WINTRUST_DATA WintrustData;
    ULONG SigErr = ERROR_SUCCESS;

    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE_FLUSH;
    WintrustData.dwProvFlags =  WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                                WTD_CACHE_ONLY_URL_RETRIEVAL;


    //Call WinVerifyTrust to flush the cache

    SigErr = (DWORD)WinVerifyTrust(
                    NULL,
                    &DriverVerifyGuid,
                    &WintrustData
                    );

    if(SigErr != ERROR_SUCCESS)
        DebugPrint1( LVL_MINIMAL, L"SFCC failed : WinVerifyTrust(1) failed, ec=0x%08x", SigErr );

    return;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\dirscan.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dirscan.c

Abstract:

    Implementation of directory scanner.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 7-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop


NTSTATUS
SfcDoScan(
    IN PSCAN_PARAMS ScanParams
    )

/*++

Routine Description:

    Scan the set of protected DLLs and compare them with the cached versions.
    If any are different, copy the correct one back.

Arguments:

    ScanParams - pointer to SCAN_PARAMS structure indicating scanning behavior
                 (such as whether to display UI or not)

Return Value:

    NTSTATUS code of any fatal error.

--*/

{
    NTSTATUS StatusPopulate, StatusSxsScan, rStatus;

    StatusPopulate = SfcPopulateCache( ScanParams->ProgressWindow, TRUE, ScanParams->AllowUI, NULL ) ? 
        STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    StatusSxsScan = SfcDoForcedSxsScan( ScanParams->ProgressWindow, TRUE, ScanParams->AllowUI );

    // Figure out which of these two failed.  We really do need to do both, rather than
    // just returning after a check of the SfcPopulateCache call.
    if ( !NT_SUCCESS( StatusPopulate ) ) {
        rStatus = StatusPopulate;
        DebugPrint1( LVL_MINIMAL, L"Failed scanning SFC: 0x%08x\n", rStatus );
    } else if ( !NT_SUCCESS( StatusSxsScan ) ) {
        rStatus = StatusSxsScan;
        DebugPrint1( LVL_MINIMAL, L"Failed scanning SxS: 0x%08x\n", rStatus );
    } else {
        rStatus = STATUS_SUCCESS;
    }

    return rStatus;
}


INT_PTR
CALLBACK
ProgressDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER( lParam );

    if (uMsg == WM_INITDIALOG) {
        if (hEventScanCancel == NULL) {
            EnableWindow( GetDlgItem(hwndDlg,IDCANCEL), FALSE );
        }
        CenterDialog( hwndDlg );
        ShowWindow( hwndDlg, SW_SHOWNORMAL );
        UpdateWindow( hwndDlg );
        SetForegroundWindow( hwndDlg );
        return TRUE;
    }
    if (uMsg == WM_COMMAND && LOWORD(wParam) == IDCANCEL) {
        SetEvent( hEventScanCancel );
        EndDialog( hwndDlg, 0 );
    }
    return FALSE;
}


NTSTATUS
SfcScanProtectedDlls(
    PSCAN_PARAMS ScanParams
    )
/*++

Routine Description:

    Thread routine to scan for protected dlls on the system.  The routine
    creates a dialog so the user can tell what's going on (if requested) and
    then calls into the main scanning routine.

Arguments:

    ScanParams - pointer to SCAN_PARAMS structure indicating scanning behavior
                 (such as whether to display UI or not)

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HWND hDlg = NULL;
#if 0
    HDESK hDesk = NULL;
#endif
    HANDLE hThread;

    ASSERT( ScanParams != NULL );

    //
    // make sure we only kick off one of these at a time
    //
    if (ScanInProgress) {
        if (ScanParams->FreeMemory) {
            MemFree( ScanParams );
        }
        return(ERROR_IO_PENDING);
    }


    //
    // if the system is configured to show UI progress and we don't
    // have a progress window, then we need to create a new thread
    // to do the scan as well as a progress dialog.
    //
    if (SfcQueryRegDwordWithAlternate(REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCSHOWPROGRESS, 1) &&
        ScanParams->ProgressWindow == NULL &&
        0 == m_gulAfterRestore) {
        //
        // if the user isn't logged in, we need to wait for them to do so
        // before thinking about creating a dialog
        //
        if (!UserLoggedOn) {
            Status = NtWaitForSingleObject(hEventLogon,TRUE,NULL);
            if (!NT_SUCCESS(Status)) {
                DebugPrint1(LVL_MINIMAL, L"Failed waiting for the logon event, ec=0x%08x",Status);
            }
        }

        //
        // we need access to the user's desktop now that they're logged in
        //
#if 0
        hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );
        if ( hDesk ) {
            SetThreadDesktop( hDesk );
            CloseDesktop( hDesk );
        } else {
            DebugPrint1(LVL_MINIMAL, L"OpenInputDesktop failed, ec=0x%08x",GetLastError());
        }
#else
        SetThreadDesktop( hUserDesktop );
#endif

        //
        // create an event so the user can cancel the scan
        //
        // (note that we should only have one scan going on at any given
        // time or our cancel object can get out of sync)
        //
        ASSERT( hEventScanCancel == NULL );
        ASSERT( hEventScanCancelComplete == NULL);
        hEventScanCancel = CreateEvent( NULL, FALSE, FALSE, NULL );
        hEventScanCancelComplete = CreateEvent( NULL, FALSE, FALSE, NULL );

        //
        // create the dialog the user will see UI in
        //
        hDlg = CreateDialog(
            SfcInstanceHandle,
            MAKEINTRESOURCE(IDD_PROGRESS),
            NULL,
            ProgressDialogProc
            );
        if (hDlg) {
            //
            // scale the progress dialog (we assume that it takes the same
            // amount of time to scan each file in the system)
            //
            ScanParams->ProgressWindow = GetDlgItem( hDlg, IDC_PROGRESS );
            SendMessage( ScanParams->ProgressWindow, PBM_SETRANGE, 0, MAKELPARAM(0,SfcProtectedDllCount) );
            SendMessage( ScanParams->ProgressWindow, PBM_SETPOS, 0, 0 );
            SendMessage( ScanParams->ProgressWindow, PBM_SETSTEP, 1, 0 );

            //
            // create a thread to do the work so we can pump messages in this
            // thread that already has access to the desktop
            //
            hThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)SfcDoScan,
                ScanParams,
                0,
                NULL
                );
            if (hThread) {
                MSG msg;
                while(1) {
                    //
                    // pump messages until the "worker" thread goes away or the
                    // dialog ends
                    //
                    if (WAIT_OBJECT_0+1 == MsgWaitForMultipleObjects( 1, &hThread, FALSE, INFINITE, QS_ALLEVENTS )) {
                        while (PeekMessage( &msg, NULL, 0, 0, PM_REMOVE )) {
                            if (!IsDialogMessage( hDlg, &msg )) {
                                TranslateMessage (&msg);
                                DispatchMessage (&msg);
                            }
                        }
                    } else {
                        break;
                    }
                }
                CloseHandle( hThread );
                EndDialog( hDlg, 0 );
            } else {
                //
                // CreateThread failed... kill the dialog and try to do it
                // synchronously
                //
                EndDialog( hDlg, 0 );
                SfcDoScan( ScanParams );
            }
        } else {
            //
            // CreateDialog failed... just try to do it synchronously
            //
            SfcDoScan( ScanParams );
        }

        //
        // cleanup
        //
        if (hEventScanCancel) {
            CloseHandle( hEventScanCancel );
            hEventScanCancel = NULL;
        }

        if (hEventScanCancelComplete) {
            CloseHandle( hEventScanCancelComplete );
            hEventScanCancelComplete = NULL;
        }
    } else {
        //
        // no UI to be shown, just do this synchronously
        //
        SfcDoScan( ScanParams );
    }

    if (ScanParams->FreeMemory) {
        MemFree( ScanParams );
    }
    return Status;
}


NTSTATUS
SfcDoForcedSxsScan(
    IN HWND hwDialogProgress,
    IN BOOL bValidate,
    IN BOOL bAllowUI
)
{
    NTSTATUS Status;

    Status = SfcLoadSxsProtection();
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ASSERT( SxsScanForcedFunc != NULL );

    if ( !SxsScanForcedFunc( hwDialogProgress, bValidate, bAllowUI ) ) {
        return STATUS_SUCCESS;
    } else
        return STATUS_NO_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\dirwatch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dirwatch.c

Abstract:

    Implementation of directory watcher and file list manipulation.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 6-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

#include <ntrpcp.h>
#include "sfcapi.h"
#include "sxsapi.h"

//
// List of directories being watched.  The assumption is that we are
// protecting many files in few directories, so a linked list of directories
// is fine, while something a bit more heavy duty is necessary to traverse the
// number of files we are watching
//
LIST_ENTRY SfcWatchDirectoryList;

//
// count of directories being watched
//
ULONG WatchDirectoryListCount;

//
// b-tree of filenames for quick sorting
//
NAME_TREE FileTree;

//
// handle to the thread that watches directories for changes
//
HANDLE WatcherThread;

//
// Instance of the WinSxS that we are providing protection for.
//
HMODULE SxsDllInstance = NULL;

//
// This function gets called back when a change is noticed in the SXS
// protected functions.
//
PSXS_PROTECT_NOTIFICATION SxsNotification = NULL;

//
// This function is called once to let SXS offer a list of protected
// directories.
//
PSXS_PROTECT_RETRIEVELISTS SxsGatherLists  = NULL;

//
// Notification functions from sfcp.h
//
PSXS_PROTECT_LOGIN_EVENT SxsLogonEvent = NULL;
PSXS_PROTECT_LOGIN_EVENT SxsLogoffEvent = NULL;

PSXS_PROTECT_SCAN_ONCE SxsScanForcedFunc = NULL;

VOID
SfcShutdownSxsProtection(
    void
)
{
    SxsNotification = NULL;
    SxsGatherLists = NULL;
    SxsLogonEvent = NULL;
    SxsLogoffEvent = NULL;
    SxsScanForcedFunc = NULL;

    if ( NULL != SxsDllInstance )
    {
        FreeLibrary( SxsDllInstance );
        SxsDllInstance = NULL;
    }
}

BOOL
SfcLoadSxsProtection(
    void
)
/*++

Routine Description:

    Loads and initializes the SxS protection system into the overall list of
    directory entries to watch.

Arguments:

    None.

Return Value:

    NTSTATUS indicating whether or not the entire SxS watching system was
    initialized or not.  Failure of this function is not necesarily a complete
    failure of the SFC functionality, but it should be logged somewhere.

--*/
{
    SIZE_T                  cProtectList = 0;
    SIZE_T                  iIndex;
    SIZE_T                  cbDirectory;
    DWORD                   dwLastError = 0;
    HANDLE                  hDirectory;
    PSXS_PROTECT_DIRECTORY  pProtectList = NULL;
    PSFC_REGISTRY_VALUE     pDirectory;
    PSXS_PROTECT_DIRECTORY  pSxsItem;
    BOOL                    bOk = FALSE;
    const static            WCHAR cwszFailMessage[] = L"Failed to load SxS.DLL: %ls";

    // If someone else has already loaded us, we don't really need to go and
    // load sxs again.
    if ( SxsDllInstance != NULL ) {
        DebugPrint1( LVL_MINIMAL, L"SFC:%s - SxS.DLL is already loaded.", __FUNCTION__ );
        bOk = TRUE;
        goto Exit;
    }

    ASSERT( NULL == SxsDllInstance );
    ASSERT( NULL == SxsNotification );
    ASSERT( NULL == SxsGatherLists );

    if ( NULL == ( SxsDllInstance = LoadLibraryW( L"sxs.dll" ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"LoadLibrary" );
        goto Exit;
    }

    if ( NULL == ( SxsNotification = (PSXS_PROTECT_NOTIFICATION)GetProcAddress( SxsDllInstance, PFN_NAME_PROTECTION_NOTIFY_CHANGE_W ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"GetProcAddress(SxsNotification)" );
        goto Exit;
    }

    if ( NULL == ( SxsGatherLists = (PSXS_PROTECT_RETRIEVELISTS)GetProcAddress( SxsDllInstance, PFN_NAME_PROTECTION_GATHER_LISTS_W ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"GetProcAddress(SxsGatherLists)" );
        goto Exit;
    }

    if ( NULL == ( SxsLogonEvent = (PSXS_PROTECT_LOGIN_EVENT)GetProcAddress( SxsDllInstance, PFN_NAME_PROTECTION_NOTIFY_LOGON ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"GetProcAddress(SxsLogonEvent)" );
        goto Exit;
    }

    if ( NULL == ( SxsLogoffEvent = (PSXS_PROTECT_LOGIN_EVENT)GetProcAddress( SxsDllInstance, PFN_NAME_PROTECTION_NOTIFY_LOGOFF ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"GetProcAddress(SxsLogoffEvent)" );
        goto Exit;
    }

    if ( NULL == ( SxsScanForcedFunc = (PSXS_PROTECT_SCAN_ONCE)GetProcAddress( SxsDllInstance, PFN_NAME_PROTECTION_SCAN_ONCE ) ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"GetProcAddress(SxsScanForcedFunc)" );
        goto Exit;
    }

    //
    // Ensure that all is OK - something bad happened if this is true.
    //
    ASSERT( ( NULL != SxsDllInstance ) && ( NULL != SxsNotification ) && ( NULL != SxsGatherLists ) );

    if ( !SxsGatherLists( &pProtectList, &cProtectList ) ) {
        DebugPrint1( LVL_MINIMAL, cwszFailMessage, L"SxsGatherLists" );
        goto Exit;
    }

    //
    // Loop across all the entries in the returned list of items, adding them to our
    // protection list as we go.
    //
    for ( iIndex = 0; iIndex < cProtectList; iIndex++ ) {

        //
        // Create a new holder for the list entry
        //
        pSxsItem = &pProtectList[iIndex];

        cbDirectory = sizeof( SFC_REGISTRY_VALUE ) + MAX_PATH;
        pDirectory = (PSFC_REGISTRY_VALUE)MemAlloc( cbDirectory );
        if ( NULL == pDirectory ) {
            DebugPrint( LVL_MINIMAL, L"SfcLoadSxsProtection: Out of memory allocating new watch bucket" );
            goto Exit;
        }

        //
        // Set up string
        //
        ZeroMemory( pDirectory, cbDirectory );
        pDirectory->DirName.Length = (USHORT)wcslen( pSxsItem->pwszDirectory );
        pDirectory->DirName.MaximumLength = MAX_PATH;
        pDirectory->DirName.Buffer = (PWSTR)((PUCHAR)pDirectory + sizeof(SFC_REGISTRY_VALUE));

        //
        // Move the all-important SxS cookies to the watch list.
        //
        pDirectory->pvWinSxsCookie = pSxsItem->pvCookie;
        pDirectory->dwWinSxsFlags = pSxsItem->ulRecursiveFlag;

        //
        // Copy string
        //
        RtlCopyMemory( pDirectory->DirName.Buffer, pSxsItem->pwszDirectory, pDirectory->DirName.Length );

        //
        // If we're at a point where the protected directory exists, then
        // we should create the handle to it and go forth.  Otherwise, we
        // might want to not do this at all.. but that would be odd that
        // the directory is toast at this point.
        //
        MakeDirectory( pSxsItem->pwszDirectory );

        hDirectory = SfcOpenDir( TRUE, FALSE, pSxsItem->pwszDirectory );
        if ( NULL != hDirectory ) {

            InsertTailList( &SfcWatchDirectoryList, &pDirectory->Entry );
            pDirectory->DirHandle = hDirectory;

            WatchDirectoryListCount += 1;

        } else {
            DebugPrint1( LVL_MINIMAL, L"SfcLoadSxsProtection: Failed adding item %ls to the watch list.", pSxsItem->pwszDirectory );
            MemFree( pDirectory );
        }
    }

    bOk = TRUE;

Exit:
    if ( !bOk )
    {
        if ( !SfcReportEvent( MSG_SXS_INITIALIZATION_FAILED, NULL, NULL, GetLastError() ) )
        {
            DebugPrint( LVL_MINIMAL, L"It's not our day - reporting that sxs initialization failed." );
        }
        SfcShutdownSxsProtection();
    }

    return bOk;
}



PVOID
SfcFindProtectedFile(
    IN PCWSTR FileName,
    IN ULONG FileNameLength
    )
/*++

Routine Description:

    Routine to find a given file in our protected list.

Arguments:

    FileName - name of file to look for.  Note that this shoud be a fully
               qualified file path that has already been lowercased by the
               caller for performance reasons
    FileNameLength - length of the file buffer in bytes

Return Value:

    a pointer to the files NAME_NODE if it is in the list, else NULL if the
    file is not in the list.

--*/
{
    ASSERT((FileName != NULL) && (FileNameLength > 0));

    return ((PVOID)BtreeFind( &FileTree, (PWSTR)FileName, FileNameLength ));
}


BOOL
SfcBuildDirectoryWatchList(
    void
    )
/*++

Routine Description:

    Routine that builds up the list of directories to watch

Arguments:

    None.

Return Value:

    TRUE for success, FALSE if the list failed to be built for any reason.

--*/
{
    NTSTATUS Status;
    PSFC_REGISTRY_VALUE p;
    PSFC_REGISTRY_VALUE RegVal;
    ULONG i;
    ULONG Size;
    HANDLE DirHandle;
    HANDLE hFile;
    PLIST_ENTRY Entry;
    BOOLEAN Found;
    PNAME_NODE Node;


    //
    // initialize our lists
    //
    InitializeListHead( &SfcWatchDirectoryList );
    BtreeInit( &FileTree );
    SfcExceptionInfoInit();

    for (i=0; i<SfcProtectedDllCount; i++) {
        RegVal = &SfcProtectedDllsList[i];

        //
        // add the file to the btree if it's not already there
        //
        if (!SfcFindProtectedFile( RegVal->FullPathName.Buffer, RegVal->FullPathName.Length )) {
            Node = BtreeInsert( &FileTree, RegVal->FullPathName.Buffer, RegVal->FullPathName.Length );
            if (Node) {
                Node->Context = RegVal;
            } else {
                DebugPrint2( LVL_MINIMAL, L"failed to insert file %ws into btree, ec = %x", RegVal->FullPathName.Buffer, GetLastError() );
            }
        } else {
            DebugPrint1( LVL_VERBOSE, L"file %ws is protected more than once", RegVal->FullPathName.Buffer );
        }

        //
        // add the directory to the list of directories to watch
        // but do not add a duplicate.  we must search the existing list
        // for duplicates first.
        //

        Entry = SfcWatchDirectoryList.Flink;
        Found = FALSE;
        while (Entry != &SfcWatchDirectoryList) {
            p = CONTAINING_RECORD( Entry, SFC_REGISTRY_VALUE, Entry );
            Entry = Entry->Flink;
            if (_wcsicmp( p->DirName.Buffer, RegVal->DirName.Buffer ) == 0) {
                Found = TRUE;
                break;
            }
        }

        if (Found) {
            ASSERT( p->DirHandle != NULL );
            RegVal->DirHandle = p->DirHandle;

        } else {

            //
            // go ahead and add it to the list
            //
            Size = sizeof(SFC_REGISTRY_VALUE) + RegVal->DirName.MaximumLength;
            p = (PSFC_REGISTRY_VALUE) MemAlloc( Size );
            if (p == NULL) {
                DebugPrint1( LVL_VERBOSE, L"failed to allocate %x bytes for new directory", Size );
                return(FALSE);
            }

            ZeroMemory(p, Size);

            p->DirName.Length = RegVal->DirName.Length;
            p->DirName.MaximumLength = RegVal->DirName.MaximumLength;
            //
            // point string buffer at end of registry value structure
            //
            p->DirName.Buffer = (PWSTR)((PUCHAR)p + sizeof(SFC_REGISTRY_VALUE));

            //
            // copy the directory name into the buffer
            //
            RtlCopyMemory( p->DirName.Buffer, RegVal->DirName.Buffer, RegVal->DirName.Length );

            //
            // Make sure the directory exists before we start protecting it.
            //
            //
            // NTRAID#97842-2000/03/29-andrewr
            // This isn't such a great solution since it creates
            // directories that the user might not want on the system
            //
            MakeDirectory( p->DirName.Buffer );

            DirHandle = SfcOpenDir( TRUE, FALSE, p->DirName.Buffer );
            if (DirHandle) {

                InsertTailList( &SfcWatchDirectoryList, &p->Entry );

                RegVal->DirHandle = DirHandle;
                p->DirHandle = DirHandle;

                WatchDirectoryListCount += 1;

                DebugPrint1( LVL_MINIMAL, L"Adding watch directory %ws", RegVal->DirName.Buffer );
            } else {
                DebugPrint1( LVL_MINIMAL, L"failed to add watch directory %ws", RegVal->DirName.Buffer );
                MemFree( p );
            }
        }

        //
        // special case: ntoskrnl and hal, which are both renamed from multiple
        // sources; we're not sure what source file name should be.  To work
        // around this, we look in the version resource in these files for the
        // original install name, which gives us what we're looking for
        //
        if (_wcsicmp( RegVal->FileName.Buffer, L"ntoskrnl.exe" ) == 0 ||
            _wcsicmp( RegVal->FileName.Buffer, L"ntkrnlpa.exe" ) == 0 ||
            _wcsicmp( RegVal->FileName.Buffer, L"hal.dll" ) == 0)
        {
            Status = SfcOpenFile( &RegVal->FileName, RegVal->DirHandle, SHARE_ALL, &hFile );
            if (NT_SUCCESS(Status) ) {
                SfcGetFileVersion( hFile, NULL, NULL, RegVal->OriginalFileName );
                NtClose( hFile );
            }
        }
    }

    //
    // Ask WinSxs for anything that they want to watch.
    //
    if ( SfcLoadSxsProtection() ) {
        DebugPrint( LVL_MINIMAL, L"Loaded SXS protection lists entirely." );
    } else {
        DebugPrint( LVL_MINIMAL, L"Failed to load SXS protection! Assemblies will not be safe." );
    }


    return(TRUE);
}


BOOL
SfcStartDirWatch(
    IN PDIRECTORY_WATCH_DATA dwd
    )
/*++

Routine Description:

    Routine that starts up the directory watch for the specified directory.  We
    take our open directory handle to each of the directories and ask for
    pending change notifications.

Arguments:

    dwd - pointer to the DIRECTORY_WATCH_DATA for the specified directory

Return Value:

    TRUE for success, FALSE if the pending notification failed to be setup.

--*/
{
    NTSTATUS Status;
    BOOLEAN bWatchTree;

    ASSERT(dwd != NULL);
    ASSERT(dwd->DirHandle != NULL);
    ASSERT(dwd->DirEvent != NULL);

    //
    // If the watch directory is an SxS watched directory, then see if they want to
    // watch the directory recursively or not.
    //
    if ( ( dwd->WatchDirectory ) && ( NULL != dwd->WatchDirectory->pvWinSxsCookie ) ) {
        bWatchTree = ( ( dwd->WatchDirectory->dwWinSxsFlags & SXS_PROTECT_RECURSIVE ) == SXS_PROTECT_RECURSIVE );
    } else {
        bWatchTree = FALSE;
    }


    Status = NtNotifyChangeDirectoryFile(
        dwd->DirHandle,                       //  Directory handle
        dwd->DirEvent,                        //  Event
        NULL,                                 //  ApcRoutine
        NULL,                                 //  ApcContext
        &dwd->Iosb,                           //  IoStatusBlock
        dwd->WatchBuffer,                     //  Buffer
        WATCH_BUFFER_SIZE,                    //  Buffer Size
        FILE_NOTIFY_FLAGS,                    //  Flags
        bWatchTree                            //  WatchTree
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_MINIMAL, L"Could not start watch on %ws - %x", dwd->WatchDirectory->DirName.Buffer, Status );
        return(FALSE);
    }

    return(TRUE);
}


BOOL
SfcCreateWatchDataEntry(
    IN PSFC_REGISTRY_VALUE WatchDirectory,
    OUT PDIRECTORY_WATCH_DATA dwd
    )
/*++

Routine Description:

    Routine takes our internal structure for directories and builds up a
    structure for asking for change notifications.  We then start waiting
    for notifications.

Arguments:

    WatchDirectory - pointer to SFC_REGISTRY_VALUE describing directory we want
                     to begin watching
    dwd            - pointer to DIRECTORY_WATCH_DATA for the specified data

Return Value:

    TRUE for success, FALSE if the structure failed to be setup.

--*/
{
    NTSTATUS Status;

    ASSERT((WatchDirectory != NULL) && (dwd != NULL));
    ASSERT(WatchDirectory->DirHandle != NULL);

    //
    // the watch directory and directory handle are already created
    //
    dwd->WatchDirectory = WatchDirectory;
    dwd->DirHandle = WatchDirectory->DirHandle;

    //
    // we have to create the watch buffer
    //
    dwd->WatchBuffer = MemAlloc( WATCH_BUFFER_SIZE );
    if (dwd->WatchBuffer == NULL) {
        DebugPrint1( LVL_MINIMAL, L"SfcCreateWatchDataEntry: MemAlloc(%x) failed", WATCH_BUFFER_SIZE );
        goto err_exit;
    }
    RtlZeroMemory( dwd->WatchBuffer, WATCH_BUFFER_SIZE );

    //
    // we have to create an event that is signalled when something changes in
    // the directory
    //
    Status = NtCreateEvent(
        &dwd->DirEvent,
        EVENT_ALL_ACCESS,
        NULL,
        NotificationEvent,
        FALSE
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_MINIMAL, L"Unable to create dir event, ec=0x%08x", Status );
        goto err_exit;
    }

    //
    // now that the DIRECTORY_WATCH_DATA is built up, start watching for
    // changes
    //
    if (!SfcStartDirWatch(dwd)) {
        goto err_exit;
    }

    DebugPrint2( LVL_MINIMAL, L"Watching [%ws] with handle %x", WatchDirectory->DirName.Buffer, dwd->DirEvent );


    return(TRUE);

err_exit:

    if (dwd->WatchBuffer) {
        MemFree( dwd->WatchBuffer );
        dwd->WatchBuffer = NULL;
    }
    if (dwd->DirEvent) {
        NtClose(dwd->DirEvent);
        dwd->DirEvent = NULL;
    }

    return(FALSE);
}

NTSTATUS
SfcWatchProtectedDirectoriesWorkerThread(
    IN PWATCH_THREAD_PARAMS WatchParams
    )
/*++

Routine Description:

    Worker thread for SfcWatchProtectedDirectoriesThread.  This routine
    watches the supplied handles for notification, then enqueues a verification
    request to the verification thread if necessary.

    Note that the code in between the wait being satisfied and watching
    for changes again must be as quick as possible.  The time this code takes
    to run is a window here where we are NOT watching for changes in that
    directory.

Arguments:

    WatchParams  - pointer to a WATCH_THREAD_PARAMS structure which supplies
                   the list of handles to be watched, etc.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
#if DBG
    #define EVENT_OFFSET 2
#else
    #define EVENT_OFFSET 1
#endif

    //
    // if the list of notfications changes in sfcp.h, this list must also change!
    //
    DWORD am[] = { 0, SFC_ACTION_ADDED, SFC_ACTION_REMOVED, SFC_ACTION_MODIFIED, SFC_ACTION_RENAMED_OLD_NAME, SFC_ACTION_RENAMED_NEW_NAME };

    PLARGE_INTEGER pTimeout = NULL;
    BOOL IgnoreChanges = FALSE;
    PFILE_NOTIFY_INFORMATION fni = NULL;
    PDIRECTORY_WATCH_DATA dwd = WatchParams->DirectoryWatchList;
    PSFC_REGISTRY_VALUE RegVal;
    PNAME_NODE Node;
    PWSTR FullPathName = NULL;
    ULONG Len,tmp;


    DebugPrint( LVL_MINIMAL, L"Entering SfcWatchProtectedDirectoriesWorkerThread" );

    DebugPrint2( LVL_VERBOSE, L"watching %d events at %x ", WatchParams->HandleCount, WatchParams->HandleList );

    //
    // allocate a big scratch buffer for our notifications to get copied into
    //
    FullPathName = MemAlloc( (MAX_PATH * 2)*sizeof(WCHAR) );
    if (FullPathName == NULL) {
        DebugPrint( LVL_MINIMAL, L"Unable to allocate full path buffer" );
        goto exit;
    }

    RtlZeroMemory(FullPathName, (MAX_PATH * 2)*sizeof(WCHAR) );

    while (TRUE) {
        NTSTATUS WaitStatus;

        //
        //  Wait for a change
        //

        WaitStatus = NtWaitForMultipleObjects(
            WatchParams->HandleCount,    //  Count
            WatchParams->HandleList,     //  Handles
            WaitAny,                     //  WaitType
            TRUE,                        //  Alertable
            pTimeout                     //  Timeout
            );

        if (!NT_SUCCESS( WaitStatus )) {
            DebugPrint1( LVL_MINIMAL, L"WaitForMultipleObjects failed returning %x", WaitStatus );
            break;
        }

        if (WaitStatus == 0) {
            //
            // WatchTermEvent was signalled, exit loop
            //
            goto exit;
        }

        if (WaitStatus == STATUS_TIMEOUT) {
            //
            // we timed out
            //

            ASSERT(FALSE && "we should never get here since we never specified a timeout");

            IgnoreChanges = FALSE;
            pTimeout = NULL;
            continue;
        }

#if DBG
        if (WaitStatus == 1) {
            DebugBreak();
            continue;
        }
#endif

        if ((ULONG)WaitStatus >= WatchParams->HandleCount) {
            DebugPrint1( LVL_MINIMAL, L"Unknown success code for WaitForMultipleObjects",WaitStatus );
            goto exit;
        }

        // DebugPrint( LVL_MINIMAL, L"Wake up!!!" );

        //
        // one of the directories hit a notification, so we cycle
        // through the list of files that have changed in that directory
        //
        if (!IgnoreChanges) {

            //
            // check the io buffer for the list of files that changed
            //

            //
            // note that we have to offset the waitstatus by the EVENT_OFFSET
            // to get the correct offset into the DIRECTORY_WATCH_DATA array
            //

            ASSERT((INT)(WaitStatus-EVENT_OFFSET) >=0);

            fni = (PFILE_NOTIFY_INFORMATION) dwd[WaitStatus-EVENT_OFFSET].WatchBuffer;
            while (TRUE) {
                ULONG c;
                RtlZeroMemory(FullPathName, (MAX_PATH * 2)*sizeof(WCHAR) );

                //
                // We can short-circuit a large amount of this by checking to see
                // if the change is from a SxS-protected directory and notifying
                // them immediately.
                //
                if ( NULL != dwd[WaitStatus-EVENT_OFFSET].WatchDirectory->pvWinSxsCookie ) {
                    ASSERT( SxsNotification != NULL );
                    if ( SxsNotification ) {
                        SxsNotification(
                            dwd[WaitStatus-EVENT_OFFSET].WatchDirectory->pvWinSxsCookie,
                            fni->FileName,
                            fni->FileNameLength / sizeof( fni->FileName[0] ),
                            fni->Action
                        );
                        DebugPrint( LVL_MINIMAL, L"Notified SxS about a change in their directory" );
                    }
                    goto LoopAgain;
                }


                wcscpy( FullPathName, dwd[WaitStatus-EVENT_OFFSET].WatchDirectory->DirName.Buffer );

                ASSERT(fni->FileName != NULL);

                //
                // FILE_NOTIFY_INFORMATION->FileName is not always a null
                // terminated string, so we copy the string using memmove.
                // the buffer already zero'ed out so the string will now be
                // NULL terminated
                //
                c = wcslen(FullPathName);
                if (FullPathName[c-1] != L'\\') {
                    FullPathName[c] = L'\\';
                    FullPathName[c+1] = L'\0';
                    c++;
                }
                RtlMoveMemory( &FullPathName[c], fni->FileName, fni->FileNameLength);

           //     DebugPrint3( LVL_VERBOSE, L"received a notification in directory %ws (%x) for %ws",
                             //dwd[WaitStatus-EVENT_OFFSET].WatchDirectory->DirName.Buffer,
                             //WatchParams->DirectoryWatchList[WaitStatus-EVENT_OFFSET].DirEvent,
                             //FullPathName);


                Len = wcslen(FullPathName);
                MyLowerString( FullPathName, Len );

          //      DebugPrint1( LVL_VERBOSE, L"Is %ws a protected file?", FullPathName );

                //
                // see if we found a protected file
                //
                Node = SfcFindProtectedFile( FullPathName, Len*sizeof(WCHAR) );
                if (Node) {
                    RegVal = (PSFC_REGISTRY_VALUE)Node->Context;
                    ASSERT(RegVal != NULL);
#if DBG
                    {
                        PWSTR ActionString[] = { NULL, L"Added(1)", L"Removed(2)", L"Modified(3)", L"Rename-Old(4)", L"Rename-New(5)" };

                        DebugPrint2( LVL_MINIMAL,
                                    L"[%ws] file changed (%ws)",
                                    FullPathName,
                                    ActionString[fni->Action] );
                    }
#endif
                    //
                    // check if we're supposed to ignore this change
                    // notification because someone exempted it
                    //
                    RtlEnterCriticalSection( &ErrorCs );
                    tmp = SfcGetExemptionFlags(RegVal);
                    RtlLeaveCriticalSection( &ErrorCs );

                    if((tmp & am[fni->Action]) != 0 && SfcAreExemptionFlagsValid(FALSE)) {
                        DebugPrint2( LVL_MINIMAL,
                                     L"[%ws] f i (0x%x)",
                                     FullPathName,
                                     tmp );
                    } else {
                        //
                        // a protected file has changed so we queue up a
                        // request to see if the file is still valid
                        //
                        SfcQueueValidationRequest( (PSFC_REGISTRY_VALUE)Node->Context, fni->Action );
                    }
                }

LoopAgain:
                //
                // point to the next file in the directory that has changed
                //
                if (fni->NextEntryOffset == 0) {
                    break;
                }
                fni = (PFILE_NOTIFY_INFORMATION) ((ULONG_PTR)fni + fni->NextEntryOffset);
            }
        }

        //
        // Restart the notify for this directory now that we've cleared out
        // all of the changes.
        //

        if (!SfcStartDirWatch(&dwd[WaitStatus-EVENT_OFFSET])) {
            goto exit;
        }
    }
exit:
    if (FullPathName) {
        MemFree( FullPathName );
    }

    return(STATUS_SUCCESS);

}



NTSTATUS
SfcWatchProtectedDirectoriesThread(
    IN PVOID NotUsed
    )
/*++

Routine Description:

    Thread routine that performs watch/update loop.  This routine opens
    up directory watch handles for each directory we're watching.

    Depending on the amount of directories (handles) we're watching, we require
    one or more worker threads that do the actual directory watching.

Arguments:

    Unreferenced Parameter.

Return Value:

    NTSTATUS code of any fatal error.

--*/
{
#if DBG
    #define EVENT_OFFSET 2
#else
    #define EVENT_OFFSET 1
#endif

    PLIST_ENTRY Entry;
    ULONG i,j;

    PDIRECTORY_WATCH_DATA dwd = NULL;
    PSFC_REGISTRY_VALUE WatchDirectory = NULL;
    PHANDLE *HandlesArray;
    ULONG TotalHandleCount,CurrentHandleCount;
    ULONG TotalHandleThreads,CurrentHandleList;
    ULONG TotalHandleCountWithEvents;
    ULONG WatchCount = 0;
    PLARGE_INTEGER pTimeout = NULL;
    PWATCH_THREAD_PARAMS WorkerThreadParams;
    PHANDLE ThreadHandles;

    NTSTATUS WaitStatus,Status;

    UNREFERENCED_PARAMETER( NotUsed );

    //
    // now start protecting each of the directories in the system
    //
    DebugPrint1( LVL_MINIMAL, L"%d watch directories", WatchDirectoryListCount );

    //
    //  allocate array of DIRECTORY_WATCH_DATA structures
    //
    i = sizeof(DIRECTORY_WATCH_DATA) * (WatchDirectoryListCount);
    dwd = MemAlloc( i );
    if (dwd == NULL) {
        DebugPrint1( LVL_MINIMAL, L"Unable to allocate directory watch table (%x bytes", i );
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY );
        return(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(dwd,i);

    //
    // we can have more than MAXIMUM_WAIT_OBJECTS directory handles to watch
    // so we create an array of handle arrays, each of which contain at most
    // MAXIMUM_WAIT_OBJECTS handles to be watched
    //
    TotalHandleCount = WatchDirectoryListCount;
    CurrentHandleCount = 0;
    TotalHandleCountWithEvents = 0;
    TotalHandleThreads = 0;

    //
    // find out how many lists of handle's we'll need
    //

    while (CurrentHandleCount < TotalHandleCount) {
        if (CurrentHandleCount + (MAXIMUM_WAIT_OBJECTS - EVENT_OFFSET) < TotalHandleCount) {
            CurrentHandleCount += (MAXIMUM_WAIT_OBJECTS-EVENT_OFFSET);
            DebugPrint2( LVL_VERBOSE, L"incremented currenthandlecount (%d) by %d ", CurrentHandleCount, (MAXIMUM_WAIT_OBJECTS-EVENT_OFFSET) );
        } else {
            CurrentHandleCount += (TotalHandleCount-CurrentHandleCount);
            DebugPrint1( LVL_VERBOSE, L"incremented currenthandlecount (%d) ", CurrentHandleCount );
        }
        TotalHandleThreads += 1;
    }

    DebugPrint1( LVL_MINIMAL, L"we need %d worker threads", TotalHandleThreads );

    //
    // allocates space for each handle list pointer
    //
    HandlesArray = MemAlloc( sizeof(HANDLE *) * TotalHandleThreads );
    if (!HandlesArray) {
        MemFree(dwd);
        DebugPrint( LVL_MINIMAL, L"Unable to allocate HandlesArray" );
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY );
        return(STATUS_NO_MEMORY);
    }

    WorkerThreadParams = MemAlloc( sizeof(WATCH_THREAD_PARAMS) * TotalHandleThreads );
    if (!WorkerThreadParams) {
        MemFree(dwd);
        MemFree(HandlesArray);
        DebugPrint( LVL_MINIMAL, L"Unable to allocate WorkerThreadParams" );
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY );
        return(STATUS_NO_MEMORY);
    }

    ThreadHandles = MemAlloc( sizeof(HANDLE) * TotalHandleThreads );
    if (!ThreadHandles) {
        DebugPrint( LVL_MINIMAL, L"Unable to allocate ThreadHandles" );
        MemFree(dwd);
        MemFree(WorkerThreadParams);
        MemFree(HandlesArray);
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY );
        return(STATUS_NO_MEMORY);
    }

    //
    // now create a handle list at each element
    //
    CurrentHandleCount = 0;
    TotalHandleThreads = 0;
    while (CurrentHandleCount < TotalHandleCount) {

        if (CurrentHandleCount + (MAXIMUM_WAIT_OBJECTS - EVENT_OFFSET) < TotalHandleCount) {
            DebugPrint1( LVL_VERBOSE, L"current thread will have %d handles ", (MAXIMUM_WAIT_OBJECTS) );
            i = sizeof(HANDLE) * MAXIMUM_WAIT_OBJECTS;
        } else {
            DebugPrint1( LVL_VERBOSE, L"current thread will have %d handles", EVENT_OFFSET + (TotalHandleCount-CurrentHandleCount) );
            i = sizeof(HANDLE) * (EVENT_OFFSET + (TotalHandleCount-CurrentHandleCount));
            ASSERT((i/sizeof(HANDLE)) <= MAXIMUM_WAIT_OBJECTS);
        }

        HandlesArray[TotalHandleThreads] = MemAlloc( i );
        CurrentHandleCount += (i/sizeof(HANDLE))-EVENT_OFFSET;

        DebugPrint2( LVL_VERBOSE, L"CurrentHandlecount (%d) was incremented by %d ", CurrentHandleCount, (i/sizeof(HANDLE))-EVENT_OFFSET );

        //
        // if we failed the allocation, bail out
        //
        if (!HandlesArray[TotalHandleThreads]) {
            j = 0;
            while (j < TotalHandleThreads) {
                MemFree( HandlesArray[j] );
                j++;
            }
            MemFree(dwd);
            MemFree(ThreadHandles);
            MemFree(WorkerThreadParams);
            MemFree(HandlesArray);
            SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY );
            return(STATUS_NO_MEMORY);
        }

        //
        // each list of handles has these two events at the start of their list
        //
        HandlesArray[TotalHandleThreads][0] = WatchTermEvent;
#if DBG
        HandlesArray[TotalHandleThreads][1] = SfcDebugBreakEvent;
#endif

        //
        // save off the current handle list for the worker thread along with
        // the number of handles that the worker thread will be watching
        //
        WorkerThreadParams[TotalHandleThreads].HandleList = HandlesArray[TotalHandleThreads];
        WorkerThreadParams[TotalHandleThreads].HandleCount = (i / sizeof(HANDLE));

        //
        // save off the directory watch list structure for the worker thread,
        // remembering that each thread can have at most
        // (MAXIMUM_WAIT_OBJECTS-EVENT_OFFSET) directory watch elements
        //
        WorkerThreadParams[TotalHandleThreads].DirectoryWatchList = &dwd[(TotalHandleThreads*(MAXIMUM_WAIT_OBJECTS-EVENT_OFFSET))];

        //
        // save off the total number of events we're watching
        //
        TotalHandleCountWithEvents += WorkerThreadParams[TotalHandleThreads].HandleCount;

        TotalHandleThreads += 1;
    }

    //
    //  Open the protected directories and start a watch on each, inserting
    //  the handle into the proper handle list
    //

    CurrentHandleCount = 0;
    CurrentHandleList  = 0;
    WatchCount = 0;
    Entry = SfcWatchDirectoryList.Flink;
    while (Entry != &SfcWatchDirectoryList) {
        WatchDirectory = CONTAINING_RECORD( Entry, SFC_REGISTRY_VALUE, Entry );

        if (SfcCreateWatchDataEntry(WatchDirectory,&dwd[WatchCount])) {
            //
            // save off a pointer to the directory we're watching into the
            // handles array, remembering that the start of each
            // handles list contains EVENT_OFFSET events that we don't want
            // to overwrite
            //
            HandlesArray[CurrentHandleList][CurrentHandleCount+EVENT_OFFSET] = dwd[WatchCount].DirEvent;
            WatchCount += 1;
            CurrentHandleCount += 1;
            if (CurrentHandleCount + EVENT_OFFSET > MAXIMUM_WAIT_OBJECTS - 1) {
                CurrentHandleList += 1;
                CurrentHandleCount = 0;
            }
        }
        Entry = Entry->Flink;
    }

    DebugPrint1( LVL_MINIMAL, L"%d directories being watched", WatchCount );

    if (WatchCount != WatchDirectoryListCount) {
        DebugPrint2( LVL_MINIMAL,
                    L"The number of directories to be watched (%d) does not match the actual number of directories being watched (%d)",
                    WatchDirectoryListCount,
                    WatchCount );
    }

    //
    // we're ready to start watching directories, so now initialize the rpc
    // server
    //
    Status = SfcRpcStartServer();

    if (! NT_SUCCESS(Status)) {
        DebugPrint1( LVL_MINIMAL,
                    L"Start Rpc Server failed, ec = 0x%08x\n",
                    Status
                    );
        goto exit;
    }

    //
    // create a worker thread to monitor each of the handle lists
    //
    for (CurrentHandleList = 0,CurrentHandleCount = 0; CurrentHandleList < TotalHandleThreads; CurrentHandleList++) {

        ThreadHandles[CurrentHandleList] = CreateThread(
                                                NULL,
                                                0,
                                                SfcWatchProtectedDirectoriesWorkerThread,
                                                &WorkerThreadParams[CurrentHandleList],
                                                0,
                                                NULL
                                                );
        if (!ThreadHandles[CurrentHandleList]) {
            DebugPrint1( LVL_MINIMAL,
                         L"Failed to create SfcWatchProtectedDirectoriesWorkerThread, ec = %x",
                         GetLastError() );
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
    }


    //
    // wait for the worker threads to all exit
    //


    WaitStatus = NtWaitForMultipleObjects(
        TotalHandleThreads,    //  Count
        ThreadHandles,         //  Handles
        WaitAll,               //  WaitType
        TRUE,                  //  Alertable
        pTimeout               //  Timeout
        );

    if (!NT_SUCCESS(WaitStatus)) {
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, ERROR_INVALID_PARAMETER );
        DebugPrint1( LVL_MINIMAL, L"WaitForMultipleObjects failed returning %x", WaitStatus );
        goto exit;
    }

    DebugPrint( LVL_MINIMAL, L"all worker threads have signalled their exit" );

    Status = STATUS_SUCCESS;

exit:
    //
    //  cleanup and return
    //

    if (HandlesArray) {
        j=0;
        while (j < TotalHandleThreads) {
            MemFree( HandlesArray[j] );
            NtClose(ThreadHandles[j]);
            j++;
        }
        MemFree( HandlesArray );

        MemFree(WorkerThreadParams);
    }

    if (dwd) {
        for (i=0; i<WatchDirectoryListCount; i++) {

            NtClose( dwd[i].DirHandle );
            NtClose( dwd[i].DirEvent );
            MemFree( dwd[i].WatchBuffer );

        }
        MemFree( dwd );

        //
        // now clean out any references to these directory handles in the
        // protected dll list
        //
        for (i=0;i<SfcProtectedDllCount;i++) {
            PSFC_REGISTRY_VALUE RegVal;

            RegVal = &SfcProtectedDllsList[i];
            RegVal->DirHandle = NULL;
        }

    }


    if (SfcProtectedDllFileDirectory) {
        NtClose( SfcProtectedDllFileDirectory );
    }


    DebugPrint( LVL_MINIMAL, L"SfcWatchProtectedDirectoriesThread terminating" );

    return(Status);
}


NTSTATUS
SfcStartProtectedDirectoryWatch(
    void
    )

/*++

Routine Description:

    Create asynchronous directory notifications on SYSTEM32 and SYSTEM32\DRIVERS
    to look for notifications.  Create a thread that waits on changes from either.

Arguments:

    None.

Return Value:

    NTSTATUS code indicating outcome.

--*/

{
    //
    //  Create watcher thread
    //

    WatcherThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)SfcWatchProtectedDirectoriesThread,
        0,
        0,
        NULL
        );
    if (WatcherThread == NULL) {
        DebugPrint1( LVL_MINIMAL, L"Unable to create watcher thread, ec=%d", GetLastError() );
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\init.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Implementation of System File Checker initialization code.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 6-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop


//
// globals
//

//
//  List of files that are to be protected
//
PSFC_REGISTRY_VALUE SfcProtectedDllsList;

//
// total number of protected files
//
ULONG SfcProtectedDllCount;

//
// This is a handle to the directory where the dll cache resides.  The dll
// cache is a store of valid versions of files that allows a quick restore
// of files that change. The dll cache can be on the local machine or it
// can be remote.
//
HANDLE SfcProtectedDllFileDirectory;

//
// This is a value indicating how much space to dedicate to the dllcache
// this is expressed in bytes, but we store in MB in the registry and convert
// to bytes at runtime
//
ULONGLONG SFCQuota;

//
// value that controls SFC's disable behavior
//
ULONG SFCDisable;

//
// value that controls how often SFC should perform scans
//
ULONG SFCScan;

//
// policy value that controls whether UI should show up on the system.
// Note that this is different than the SFCNoPopUps global in that the
// SFCNoPopUps policy is a union between the user being logged on and
// the existing policy (ie., SFCNoPopUpsPolicy can be FALSE, but if a
// user is not logged on, then SFCNoPopUps will be TRUE.)
//
ULONG SFCNoPopUpsPolicy;


//
// value that controls whether UI should show up on the system
//
ULONG SFCNoPopUps;


//
// values that controls the amount of debug output
//
WORD SFCDebugDump;
WORD SFCDebugLog;

//
// path to the log file
//
WCHAR g_szLogFile[MAX_PATH];

#ifdef SFCLOGFILE
//
// value that controls if we create a logfile of changes on the system.
//
ULONG SFCChangeLog;
#endif

//
// value that controls how long we wait after a change notification before
// attempting a reinstall of the files
//
ULONG SFCStall;

//
// value that indicates if we booted in safe mode or not.  WFP doesn't run
// in safe mode
//
ULONG SFCSafeBootMode;

//
// turn off WFP for Amd64 bit targets for awhile.
// we do this by reversing the polarity of the SFCDisable key.
//
#if  defined(_AMD64_)

#define TURN_OFF_WFP

#endif

#if DBG || defined(TURN_OFF_WFP)
//
// debug value that indicates if we're running in winlogon mode or test mode
//
ULONG RunningAsTest;
#endif

//
// event that is signalled when the desktop (WinSta0_DesktopSwitch) changes.
//
HANDLE hEventDeskTop;

//
// event that is signalled when the user logs on
//
HANDLE hEventLogon;

//
// event that is signalled when the user logs off
//
HANDLE hEventLogoff;

//
// event that is signalled when we should stop watching for file changes
//
HANDLE WatchTermEvent;

//
// event that is signalled when we should terminate the queue validation
// thread
//
HANDLE ValidateTermEvent;

//
// A named event that is signalled to force us to call DebugBreak().
// this is convenient for breaking into certain threads.
//
#if DBG
HANDLE SfcDebugBreakEvent;
#endif

//
// full path to the golden os install source
//
WCHAR OsSourcePath[MAX_PATH*2];

//
// full path to the service pack install source
//
WCHAR ServicePackSourcePath[MAX_PATH*2];

//
// full path to the base driver cabinet cache (note that this will NOT have
// i386 appended to it)
//
WCHAR DriverCacheSourcePath[MAX_PATH*2];

//
// path to system inf files (%systemroot%\inf)
//
WCHAR InfDirectory[MAX_PATH];

//
// set to TRUE if SFC prompted the user for credentials
//
BOOL SFCLoggedOn;

//
// path to the network share that we established network connection to
//
WCHAR SFCNetworkLoginLocation[MAX_PATH];


//
//  Path to the protected DLL directory
//
UNICODE_STRING SfcProtectedDllPath;

//
// global module handle
//
HMODULE SfcInstanceHandle;

//
// Not zero if Sfc was completely initialized
//
LONG g_lIsSfcInitialized = 0;


//
// keeps track of windows that SFC creates in the system.
//
LIST_ENTRY SfcWindowList;
RTL_CRITICAL_SECTION    WindowCriticalSection;

//
// the queue validation thread id
//
DWORD g_dwValidationThreadID = 0;

//
// Non zero if first boot after a system restore
//
ULONG m_gulAfterRestore = 0;

//
// prototypes
//

BOOL
pSfcCloseAllWindows(
    VOID
    );


DWORD
SfcDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
/*++

Routine Description:

    main dll entrypoint.

Arguments:

    standard dllmain arguments.

Return Value:

    WIN32 error code indicating whether dll load may occur.

--*/
{
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // record the module handle for later
        //
        SfcInstanceHandle = hInstance;
        //
        // we dont' care about thread creation notifications
        //
        DisableThreadLibraryCalls( hInstance );

        ClientApiInit();
    } 
	else if (Reason == DLL_PROCESS_DETACH) {
        //
        // we have some state that should be cleaned up if we were loaded in
        // the client side of a dll
        //
        ClientApiCleanup();

    }
    return TRUE;
}


VOID
SfcTerminateWatcherThread(
    VOID
    )
/*++

Routine Description:

    Routine cleans up sfc state and terminates all SFC threads so the system
    can be cleanly shutdown.  The routine waits for all SFC threads to
    terminate before returning to winlogon.

Arguments:

    none.

Return Value:

    none.

--*/
{
	LONG lInit;
    DWORD Error;

    if (SFCSafeBootMode) {
        DebugPrint( LVL_MINIMAL, L"We're in safe boot mode, so there are no threads to shutdown");
        return;
    }

    //
    // SFC_DISABLE_ONCE meaning says that we should turn off SFC for this boot,
    // but revert to normal SFC policy after this boot.
    //
    if (SFCDisable == SFC_DISABLE_ONCE) {
        SfcWriteRegDword( REGKEY_WINLOGON, REGVAL_SFCDISABLE, SFC_DISABLE_NORMAL );
    }

    //
    // if SFC wasn't successfully initialized, then we don't need to clean up
    // any worker threads
    //
	lInit = InterlockedExchange(&g_lIsSfcInitialized, 0);

    if ( 0 == lInit ) {
        return;
    }

    DebugPrint( LVL_MINIMAL, L"Shutting down all SFC threads...");

    //
    // The first thing to do is get rid of any UI that may be up on the system
    //
    pSfcCloseAllWindows();

    //
    // signal the other threads to cleanup and go away...
    //
    ASSERT(WatchTermEvent && ValidateTermEvent);

    //
    // clean up the scanning thread if it's running
    //
    if (hEventScanCancel) {
        ASSERT( hEventScanCancelComplete != NULL );

        SetEvent(hEventScanCancel);

        WaitForSingleObject(hEventScanCancelComplete,SFC_THREAD_SHUTDOWN_TIMEOUT);
    }

	//
	// wait for the validation thread only if not called by itself
	//
	if(hErrorThread != NULL)
	{
		if(GetCurrentThreadId() != g_dwValidationThreadID)
		{
			SetEvent(ValidateTermEvent);
			WaitForSingleObject( hErrorThread, SFC_THREAD_SHUTDOWN_TIMEOUT );
		}

		CloseHandle(hErrorThread);
	}

    SetEvent(WatchTermEvent);


    //
    // wait for them to end
    //

    if (WatcherThread) {
        WaitForSingleObject( WatcherThread, SFC_THREAD_SHUTDOWN_TIMEOUT );
        CloseHandle(WatcherThread);
    }


    CloseHandle(ValidateTermEvent);
    CloseHandle(WatchTermEvent);

    if (hEventIdle) {
        HANDLE h = hEventIdle;
        hEventIdle = NULL;
        CloseHandle(h);
    }

#if DBG
    if (SfcDebugBreakEvent) {
        CloseHandle( SfcDebugBreakEvent );
    }
#endif

    if (hEventDeskTop) {
        CloseHandle( hEventDeskTop );
    }

    if (hEventSrc) {
        DeregisterEventSource( hEventSrc );
    }

    SfcpSetSpecialEnvironmentVariables();

    //
    // Make a copy of the pending file rename key, if any
    //
    Error = SfcCopyRegValue(REGKEY_SESSIONMANAGER, REGVAL_PENDINGFILERENAMES, REGKEY_WINLOGON_WIN32, REGVAL_WFPPENDINGUPDATES);

    if(Error != ERROR_SUCCESS && Error != ERROR_FILE_NOT_FOUND) {
        DebugPrint1(LVL_MINIMAL, L"Could not copy the pending renames regkey (error %d)", Error);
    }

    DebugPrint( LVL_MINIMAL, L"All threads terminated, SFC exiting...");
}

#if DBG
ULONG
GetTimestampForImage(
    ULONG_PTR Module
    )
/*++

Routine Description:

    Routine for retrieving the timestamp of the specified image.

Arguments:

    Module - module handle.

Return Value:

    timestamp if available, otherwise zero.

--*/
{
    PIMAGE_DOS_HEADER DosHdr;
    ULONG dwTimeStamp;

    ASSERT( Module != 0 );

    try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}

void
PrintStartupBanner(
    void
    )
/*++

Routine Description:

    Routine for outputting a debug banner to the debugger.

Arguments:

    none.

Return Value:

    none.

--*/
{
    static WCHAR mnames[] = { L"JanFebMarAprMayJunJulAugSepOctNovDec" };
    LARGE_INTEGER MyTime;
    TIME_FIELDS TimeFields;
    ULONG TimeStamp;
    WCHAR buf[128];
    PWSTR TimeBuf;


    TimeStamp = GetTimestampForImage( (ULONG_PTR)SfcInstanceHandle );

    wcscpy( buf, L"System File Protection DLL, built on " );
    TimeBuf = &buf[wcslen(buf)];

    RtlSecondsSince1970ToTime( TimeStamp, &MyTime );
    RtlSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    wcsncpy( TimeBuf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    swprintf(
        &TimeBuf[3],
        L" %02d, %04d @ %02d:%02d:%02d",
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second
        );

    DebugPrint( LVL_MINIMAL, L"****************************************************************************************" );
    DebugPrint1( LVL_MINIMAL, L"%ws", buf );
    DebugPrint( LVL_MINIMAL, L"****************************************************************************************" );
}
#endif


ULONG
SfcInitProt(
    IN ULONG  OverrideRegistry,
    IN ULONG  RegDisable,        OPTIONAL
    IN ULONG  RegScan,           OPTIONAL
    IN ULONG  RegQuota,          OPTIONAL
    IN HWND   ProgressWindow,    OPTIONAL
    IN PCWSTR SourcePath,        OPTIONAL
    IN PCWSTR IgnoreFiles        OPTIONAL
    )
/*++

Routine Description:

    Initializes the protected DLL verification code.  Should be called before
    other entrypoints since it initializes many global variables that are
    needed by the WFP system

Arguments:

    OverrideRegistry - if set to TRUE, use the passed in data instead of
                       registry state.  Set by GUI-mode setup since all of the
                       registry isn't consistent yet.
    RegDisable       - if OverrideRegistry is set, this value supercedes the
                       SfcDisable registry value.
    RegScan          - if OverrideRegistry is set, this value supercedes the
                       SfcScan registry value.
    RegQuota         - if OverrideRegistry is set, this value supercedes the
                       SfcQuota registry value.
    ProgressWindow   - specifies the progress window to send updates to.  GUI
                       mode setup specifies this since it already has a
                       progress dialog on the screen.
    SourcePath       - specifies the proper OS source path to be used during
                       gui-mode setup if specified

Return Value:

    NT status code indicating outcome.

--*/

{
    static BOOL Initialized = FALSE;
    WCHAR buf[MAX_PATH];
    PWSTR s;
    NTSTATUS Status;
    ULONG Response = 0;
    ULONG Tmp;
    ULONG Size;
    HKEY hKey = NULL;
	ULONG SFCDebug;
    PSFC_GET_FILES pfGetFiles;

#if 0
    OSVERSIONINFOEX osv;
#endif
    SCAN_PARAMS ScanParams;


    //
    // make sure we only initialize ourselves once per process
    //
    if (Initialized) {
        return STATUS_SUCCESS;
    }

    Initialized = TRUE;
    SFCNoPopUps = 1;

#if 0
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx( (LPOSVERSIONINFO)&osv );
#endif

    SfcpSetSpecialEnvironmentVariables();

    //
    // we will need this privelege later on
    //
    EnablePrivilege( SE_SECURITY_NAME, TRUE );

    InitializeListHead( &SfcErrorQueue );
    InitializeListHead( &SfcWindowList );
    RtlInitializeCriticalSection( &ErrorCs );
    RtlInitializeCriticalSection( &SilentRestoreQueue.CriticalSection );
    RtlInitializeCriticalSection( &UIRestoreQueue.CriticalSection );
    RtlInitializeCriticalSection( &WindowCriticalSection );
    RtlInitializeCriticalSection( &g_GeneralCS );

    SilentRestoreQueue.FileQueue = INVALID_HANDLE_VALUE;
    UIRestoreQueue.FileQueue     = INVALID_HANDLE_VALUE;


    //
    // retreive all of our registry settings
    //
    if (OverrideRegistry) {
        SFCDisable = RegDisable;
        SFCScan = RegScan;
        Tmp = RegQuota;
    }
	else
	{
		SFCDisable = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCDISABLE, 0 );
	    SFCScan = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCSCAN, 0 );
		Tmp = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCQUOTA, 0 );
	}

    //
    // sfcquota is expressed in MB... convert to bytes
    //
    if (Tmp == SFC_QUOTA_ALL_FILES) {
        SFCQuota = (ULONGLONG)-1;
    } else {
        SFCQuota = Tmp * (1024*1024);
    }

    SFCDebug = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCDEBUG, 0 );
	SFCDebugDump = LOWORD(SFCDebug);
	SFCDebugLog = HIWORD(SFCDebug);

    SfcQueryRegPath(REGKEY_WINLOGON, REGVAL_SFCLOGFILE, REGVAL_SFCLOGFILE_DEFAULT, g_szLogFile, UnicodeChars(g_szLogFile));

#ifdef SFCLOGFILE
    SFCChangeLog = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCCHANGELOG, 0 );
#endif
    SFCStall = SfcQueryRegDwordWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCSTALL, 0 );
    SFCSafeBootMode = SfcQueryRegDword( REGKEY_SAFEBOOT, REGVAL_OPTIONVALUE, 0 );
    m_gulAfterRestore = SfcQueryRegDword( REGKEY_WINLOGON, REGVAL_SFCRESTORED, 0 );

    //
    // We also do this in SfcTerminateWatcherThread
    //
    if (SFCScan == SFC_SCAN_ONCE) {
        SfcWriteRegDword( REGKEY_WINLOGON, REGVAL_SFCSCAN, SFC_SCAN_NORMAL );
    }

    //
    // handle the source path variable for file copies
    //

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_SETUP, 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS) {
        Size = sizeof(buf);
        if (RegQueryValueEx( hKey, REGVAL_SOURCEPATH, NULL, NULL, (LPBYTE)buf, &Size ) == ERROR_SUCCESS) {
            Size = ExpandEnvironmentStrings( buf, OsSourcePath, UnicodeChars(OsSourcePath) );

            if(0 == Size || Size > UnicodeChars(OsSourcePath)) {
                OsSourcePath[0] = 0;
            }

        } else {
            DebugPrint( LVL_VERBOSE, L"Init: RegQueryValueEx failed" );
        }

        Size = sizeof(buf);
        if (RegQueryValueEx( hKey, REGVAL_SERVICEPACKSOURCEPATH, NULL, NULL, (LPBYTE)buf, &Size ) == ERROR_SUCCESS) {
            Size = ExpandEnvironmentStrings( buf, ServicePackSourcePath, UnicodeChars(ServicePackSourcePath) );

            if(0 == Size || Size > UnicodeChars(ServicePackSourcePath)) {
                ServicePackSourcePath[0] = 0;
            }
        } else {
            DebugPrint( LVL_VERBOSE, L"Init: RegQueryValueEx(1) failed" );
        }

        //
        // save off the source path if the caller passed it in.  this is only
        // passed in by GUI-setup, so we set the ServicePackSourcePath as well
        // as the os source path to the same value.
        //
        if (SourcePath) {
            wcsncpy( 
                OsSourcePath, 
                SourcePath,
                UnicodeChars(OsSourcePath) );

            OsSourcePath[UnicodeChars(OsSourcePath) - 1] = 0;

            wcsncpy( 
                ServicePackSourcePath,
                SourcePath,
                UnicodeChars(ServicePackSourcePath) );            

            ServicePackSourcePath[UnicodeChars(ServicePackSourcePath) - 1] = 0;
        }

        Size = sizeof(buf);
        if (RegQueryValueEx( hKey, REGVAL_DRIVERCACHEPATH, NULL, NULL, (LPBYTE)buf, &Size ) == ERROR_SUCCESS) {
            Size = ExpandEnvironmentStrings( buf, DriverCacheSourcePath, UnicodeChars(DriverCacheSourcePath) );

            if(0 == Size || Size > UnicodeChars(DriverCacheSourcePath)) {
                DriverCacheSourcePath[0] = 0;
            }
        } else {
            DebugPrint( LVL_VERBOSE, L"Init: RegQueryValueEx(2) failed" );
        }

        RegCloseKey( hKey );
    } else {
        DebugPrint( LVL_VERBOSE, L"Init: RegOpenKey failed" );
    }

    Size = ExpandEnvironmentStrings( L"%systemroot%\\inf\\", InfDirectory, UnicodeChars(InfDirectory) );

    if(0 == Size || Size > UnicodeChars(InfDirectory)) {
        InfDirectory[0] = 0;
    }

    if (!OsSourcePath[0]) {
        //
        // if we don't have an OS source path, default to the cdrom drive
        //
        // if the cdrom isn't present, just initialize to A:\, which is better
        // than an unitialized variable.
        //
        if (!SfcGetCdRomDrivePath( OsSourcePath )) {
            wcscpy( OsSourcePath, L"A:\\" );
        }
    }

    DebugPrint1( LVL_MINIMAL, L"OsSourcePath          = [%ws]", OsSourcePath );
    DebugPrint1( LVL_MINIMAL, L"ServicePackSourcePath = [%ws]", ServicePackSourcePath );
    DebugPrint1( LVL_MINIMAL, L"DriverCacheSourcePath = [%ws]", DriverCacheSourcePath );

#if DBG
    PrintStartupBanner();
#endif

    //
    // if we're in safe mode, we don't protect files
    //
    if (SFCSafeBootMode) {
        return STATUS_SUCCESS;
    }

    //
    // default the stall value if one wasn't in the registry
    //
    if (!SFCStall) {
        SFCStall = SFC_QUEUE_STALL;
    }

    //
    // create the required events
    //

    hEventDeskTop = OpenEvent( SYNCHRONIZE, FALSE, L"WinSta0_DesktopSwitch" );
    Status = NtCreateEvent( &hEventLogon, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
    if (!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_MINIMAL, L"Unable to create logon event, ec=0x%08x", Status );
        goto f0;        
    }
    Status = NtCreateEvent( &hEventLogoff, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE );
    if (!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_MINIMAL, L"Unable to create logoff event, ec=0x%08x", Status );
        goto f1;        
    }

    hEventIdle = CreateEvent( NULL, TRUE, TRUE, SFC_IDLE_TRIGGER );

    if (!hEventIdle) {    
        DebugPrint1( LVL_MINIMAL, L"Unable to create idle event, ec=0x%08x", GetLastError() );
        Status = STATUS_UNSUCCESSFUL;
        goto f2;
    }

#if DBG
    {
	    SECURITY_ATTRIBUTES sa;
		DWORD dwError;

        //
        // create the security descriptor
        //
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        dwError = CreateSd(&sa.lpSecurityDescriptor);

		if(dwError != ERROR_SUCCESS)
		{
            DebugPrint1( LVL_MINIMAL, L"CreateSd failed, ec=%d", dwError );
            Status = STATUS_NO_MEMORY;
            goto f3;
        }

        SfcDebugBreakEvent = CreateEvent( &sa, FALSE, FALSE, L"SfcDebugBreakEvent" );
		MemFree(sa.lpSecurityDescriptor);
        if (SfcDebugBreakEvent == NULL) {
            DebugPrint1( LVL_MINIMAL, L"Unable to create debug break event, ec=%d", GetLastError() );
            Status = STATUS_NO_MEMORY;
            goto f3;
        }
        GetModuleFileName( NULL, buf, UnicodeChars(buf) );
        s = wcsrchr( buf, L'\\' );
        if (s && _wcsicmp( s+1, L"sfctest.exe" ) == 0) {
            SetEvent( hEventLogon );
            RunningAsTest = TRUE;
            UserLoggedOn = TRUE;
            SFCNoPopUps = 0;
            wcscpy( LoggedOnUserName, L"sfctest.exe" );
        }
    }
#endif

#ifdef TURN_OFF_WFP

    if (!RunningAsTest) {

        if (SFCDisable == SFC_DISABLE_QUIET) {
            //
            // if it's disabled let's make it enabled
            //
            SFCDisable = SFC_DISABLE_NORMAL;
        } else if (SFCDisable != SFC_DISABLE_SETUP) {
            //
            // if we're not setup mode, then disable WFP.
            //
            SFCDisable = SFC_DISABLE_QUIET;
        }

    }
#else 
    if (SFCDisable == SFC_DISABLE_QUIET) {
        SFCDisable = SFC_DISABLE_ASK;
    }
#endif

    //
    // now determine how to initialize WFP
    //
    switch (SFCDisable) {
        case SFC_DISABLE_SETUP:
#if 0
            //
            // if we're on some sort of server variant, then we never want
            // popups so we set "no popups" and on workstation we want the
            // normally spec'ed behavior.
            //
            SfcWriteRegDword(
                REGKEY_WINLOGON,
                L"SFCDisable",
                osv.wProductType == VER_NT_SERVER ? SFC_DISABLE_NOPOPUPS : SFC_DISABLE_NORMAL
                );
#else
            //
            // that's no longer necessary.  we always set SFCDisable to normal
            // mode regardless of server or workstation
            //
            SfcWriteRegDword(
                REGKEY_WINLOGON,
                L"SFCDisable",
                SFC_DISABLE_NORMAL
                );
#endif
            GetModuleFileName( NULL, buf, UnicodeChars(buf) );
            s = wcsrchr( buf, L'\\' );

            //
            // if this is setup or the test harness, then set behavior to
            // "no popups", otherwise set WFP to normal behavior and log
            // in the eventlog that WFP is disabled
            //
            if ((s && _wcsicmp( s+1, L"setup.exe" ) == 0) ||
                (s && _wcsicmp( s+1, L"sfctest.exe" ) == 0))
            {
                SFCNoPopUps = 1;
                SFCNoPopUpsPolicy = 1;
            } else {
                SFCDisable = SFC_DISABLE_NORMAL;                
            }
            break;

        case SFC_DISABLE_ONCE:
            //
            // if we're on some sort of server variant, then we never want
            // popups so we set "no popups" and on workstation we want the
            // normally spec'ed behavior.
            //
            if (!OverrideRegistry) {
#if 0
                SfcWriteRegDword(
                    REGKEY_WINLOGON,
                    L"SFCDisable",
                    osv.wProductType == VER_NT_SERVER ? SFC_DISABLE_NOPOPUPS : SFC_DISABLE_NORMAL
                    );
#else
                //
                // above code is no longer necessary.  we always set SFCDisable
                // to normal mode regardless of server or workstation
                //
                SfcWriteRegDword(
                    REGKEY_WINLOGON,
                    L"SFCDisable",
                    SFC_DISABLE_NORMAL
                    );
#endif
            }

            //
            // The only way to disable WFP with this behavior is to have a
            // kernel debugger present and installed.  The idea here is that
            // testers and developers should have a kernel debugger attached
            // so we allow them to get their work done without putting a big
            // hole in WFP
            //
            if (KernelDebuggerEnabled) {
                SfcReportEvent( MSG_DISABLE, NULL, NULL, 0 );
                if (hEventIdle) {
                    CloseHandle(hEventIdle);                
                    hEventIdle = NULL;
                }
                return STATUS_SUCCESS;
            }
            break;

        case SFC_DISABLE_NOPOPUPS:
            //
            // no popups just turns off popups but default behavior is the same
            // as usual.
            //
            SFCNoPopUps = 1;
            SFCNoPopUpsPolicy = 1;
            break;

        case SFC_DISABLE_QUIET:
            //
            // quiet disable turns off all of WFP
            //
            SfcReportEvent( MSG_DISABLE, NULL, NULL, 0 );
            if (hEventIdle) {
                CloseHandle(hEventIdle);                
                hEventIdle = NULL;
            }
            return STATUS_SUCCESS;

        case SFC_DISABLE_ASK:
            //
            // put up a popup and ask if the user wants to override
            //
            // again, you must have a kernel debugger attached to override this
            // behavior
            //
            if (KernelDebuggerEnabled) {
#if 0
                if (!SfcWaitForValidDesktop()) {
                    DebugPrint1(LVL_MINIMAL, L"Failed waiting for the logon event, ec=0x%08x",Status);
                } else {
                    if (UserLoggedOn) {
                        HDESK hDeskOld;
                        ASSERT( hUserDesktop != NULL );

                        hDeskOld = GetThreadDesktop(GetCurrentThreadId());
                        SetThreadDesktop( hUserDesktop );
                        Response = MyMessageBox( NULL, IDS_PROTDLL_DISABLED, MB_YESNO );
                        SetThreadDesktop( hDeskOld );
                        if (Response == IDNO) {
                            SfcReportEvent( MSG_DISABLE, NULL, NULL, 0 );
                            return STATUS_SUCCESS;
                        }
                    } else {
                        DebugPrint(LVL_MINIMAL,
                                   L"valid user is not logged on, ignoring S_D_A flag");
                    }
                }
#else
                SfcReportEvent( MSG_DISABLE, NULL, NULL, 0 );
                if (hEventIdle) {
                    CloseHandle(hEventIdle);                
                    hEventIdle = NULL;
                }
                return STATUS_SUCCESS;
#endif
            }
            break;

        case SFC_DISABLE_NORMAL:
            break;

        default:
            DebugPrint1(LVL_MINIMAL, L"SFCDisable is unknown value %d, defaulting to S_D_N",SFCDisable);
#if 0
            SfcWriteRegDword(
                REGKEY_WINLOGON,
                REGVAL_SFCDISABLE,
                osv.wProductType == VER_NT_SERVER ? SFC_DISABLE_NOPOPUPS : SFC_DISABLE_NORMAL
                );
#else
            //
            // above code is no longer necessary.  we always set SFCDisable
            // to normal mode regardless of server or workstation
            //
            SfcWriteRegDword(
                REGKEY_WINLOGON,
                REGVAL_SFCDISABLE,
                SFC_DISABLE_NORMAL
                );
#endif
            SFCDisable = SFC_DISABLE_NORMAL;
            break;
    }

    //
    // create our termination events...note that WatchTermEvent must be a
    // notification event because there will be more than one thread worker
    // thread waiting on that event
    //
    WatchTermEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if (!WatchTermEvent) {
        Status = STATUS_UNSUCCESSFUL;
        DebugPrint1( LVL_MINIMAL, L"Unable to create WatchTermEvent event, ec=0x%08x", GetLastError() );
        goto f3;
    }
    ValidateTermEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!ValidateTermEvent) {
        Status = STATUS_UNSUCCESSFUL;
        DebugPrint1( LVL_MINIMAL, L"Unable to create ValidateTermEvent event, ec=0x%08x", GetLastError() );
        goto f4;
    }


    ASSERT(WatchTermEvent && ValidateTermEvent);

    //
    // get our crypto libraries loaded and ready to go
    //
    //Status = LoadCrypto();
    //if (!NT_SUCCESS( Status )) {
    //    goto f5;        
    //}

	// at this point, sfcfiles.dll must be present on the system; load it
    pfGetFiles = SfcLoadSfcFiles(TRUE);

	if(NULL == pfGetFiles)
	{
        DebugPrint( LVL_MINIMAL, L"Could not load sfc.dll" );
		Status = STATUS_CORRUPT_SYSTEM_FILE;
		goto f5;
	}

    //
    // build up the list of files to protect
    //
    Status = SfcInitializeDllLists(pfGetFiles);
    if (!NT_SUCCESS( Status )) {
        DebugPrint1( LVL_MINIMAL, L"SfcInitializeDllLists failed, ec=0x%08x", Status );
        goto f6;        
    }

    //
    // Now we can safely unload sfcfiles.dll since we've copied over the information
    //
    SfcLoadSfcFiles(FALSE);

    //
    // build up the directory watch list.
    //
    // We must do this before we can start watching the directories.
    //
    // This is also necessary in the GUI-mode setup case as well, where we
    // need to do a scan of the protected files; building the directory
    // list also initializes some per-file data that is necessary to complete
    // a scan
    //
    //
    if (!SfcBuildDirectoryWatchList()) {
        DWORD LastError = GetLastError();
        Status = STATUS_NO_MEMORY;
        DebugPrint1(LVL_MINIMAL, L"SfcBuildDirectoryWatchList failed, ec = %x",LastError);
        goto f6;
    }

    //
    // during setup, we populate the dll cache with files
    //
    if (SFCDisable == SFC_DISABLE_SETUP) {
        if (SfcPopulateCache(ProgressWindow, TRUE, FALSE, IgnoreFiles)) {
            Status = STATUS_SUCCESS;
            goto f7;
        } else {
            Status = STATUS_UNSUCCESSFUL;
            goto f7;
        }
    }



    if (SFCScan || m_gulAfterRestore != 0) {
        //
        // the progress window should be NULL or we won't show
        // any UI and the scan will be syncronous.
        //
        ASSERT(ProgressWindow == NULL);
        ScanParams.ProgressWindow = ProgressWindow;
        ScanParams.AllowUI = (0 == m_gulAfterRestore);
        ScanParams.FreeMemory = FALSE;
        Status = SfcScanProtectedDlls( &ScanParams );
        //
        // don't bother to bail out if the scan fails, as it's not a fatal
        // condition.
        //

		// reset the value since it will be checked in subsequent calls to SfcScanProtectedDlls
		// also reset the registry value
		if(m_gulAfterRestore != 0)
			SfcWriteRegDword(REGKEY_WINLOGON, REGVAL_SFCRESTORED, m_gulAfterRestore = 0);
    }

    //
    // finally start protecting dlls
    
    Status = SfcStartProtectedDirectoryWatch();
    g_lIsSfcInitialized = 1;

    //
    // Copy all protected renames to dllcache, if any. Ignore the error as this is not fatal.
    //
    ProcessDelayRenames();

    goto f0;

f7:
    // SfcBuildDirectoryWatchList cleanup here

f6:
    // SfcInitializeDllLists cleanup here
    if (SfcProtectedDllsList) {
        MemFree(SfcProtectedDllsList);
        SfcProtectedDllsList = NULL;
    }

    if(IgnoreNextChange != NULL) {
        MemFree(IgnoreNextChange);
        IgnoreNextChange = NULL;
    }

f5:
    ASSERT(ValidateTermEvent != NULL);
    CloseHandle( ValidateTermEvent );
    ValidateTermEvent = NULL;
f4:
    ASSERT(WatchTermEvent != NULL);
    CloseHandle( WatchTermEvent );
    WatchTermEvent = NULL;
f3:
#if DBG
    if (SfcDebugBreakEvent) {
        CloseHandle( SfcDebugBreakEvent );
        SfcDebugBreakEvent = NULL;
    }
#endif
    ASSERT(hEventIdle != NULL);
    CloseHandle( hEventIdle );
    hEventIdle = NULL;
f2:
    ASSERT(hEventLogoff != NULL);
    CloseHandle( hEventLogoff );
    hEventLogoff = NULL;
f1:
    ASSERT(hEventDeskTop != NULL);
    CloseHandle( hEventDeskTop );
    hEventDeskTop = NULL;
f0:
    if (Status != STATUS_SUCCESS) {
        SfcReportEvent( MSG_INITIALIZATION_FAILED, 0, NULL, Status );
    }
    return(Status);
}

BOOL
SfcpSetSpecialEnvironmentVariables(
    VOID
    )
/*++

Routine Description:

    This function sets some environment variables that are not part of the
    default environment.  (These environment variables are normally set by
    winlogon.)  The environment variables need to be set for us to resolve
    all the environment variables in our protected files list.

    Note that this routine simply mirrors variables from one location in
    the registry into a location that the session manager can access at
    it's initialization time.

--*/
{
    PWSTR string;
    DWORD count;
    BOOL retval;
    PCWSTR RegistryValues[] = {
                  L"ProgramFilesDir"
                , L"CommonFilesDir"
#ifdef WX86
                , L"ProgramFilesDir(x86)"
                , L"CommonFilesDir(x86)"
#endif
};

    #define EnvVarCount  (sizeof(RegistryValues)/sizeof(PCWSTR))

    retval = TRUE;

    for (count = 0; count< EnvVarCount; count++) {
        string = SfcQueryRegString( REGKEY_WINDOWS, RegistryValues[count] );

        if (string) {
            if (SfcWriteRegString(
                        REGKEY_SESSIONMANAGERSFC, 
                        RegistryValues[count],
                        string) != ERROR_SUCCESS) {
                retval = FALSE;
            }

            MemFree( string );
        } else {
            retval = FALSE;
        }

    }

    return(retval);

}


BOOL
pSfcCloseAllWindows(
    VOID
    )
/*++

Routine Description:

    This function cycles through a global list of window structures, sending a
    message to each of the windows to shutdown.

Arguments: None.

Return Value: TRUE indicates that all windows were successfully closed.  If any
    window cannot be closes, the return value is FALSE.

--*/
{
    PLIST_ENTRY Current;
    PSFC_WINDOW_DATA WindowData;
    BOOL RetVal = TRUE;

    RtlEnterCriticalSection( &WindowCriticalSection );

    Current = SfcWindowList.Flink;
    while (Current != &SfcWindowList) {
        LRESULT lResult;
        DWORD_PTR dwResult;

        WindowData = CONTAINING_RECORD( Current, SFC_WINDOW_DATA, Entry );

        ASSERT( WindowData != NULL);
        ASSERT( IsWindow(WindowData->hWnd) );

        Current = Current->Flink;

        //
        // If we don't use a timeout while sending a message this could deadlock (e.g. when the window
        // being sent the message is processing another message and calls pSfcRemoveWindowDataEntry before
        // returning control)
        //

        lResult = SendMessageTimeout(WindowData->hWnd, WM_WFPENDDIALOG, 0, 0, SMTO_NORMAL, 5000, &dwResult);
        if (0 == lResult) {
            RetVal = FALSE;
            DebugPrint2(
                LVL_MINIMAL,
                L"WM_WFPENDDIALOG failed [thread id 0x%08x], ec = %x",
                WindowData->ThreadId,
                GetLastError() );
        }

        RemoveEntryList( &WindowData->Entry );
        MemFree( WindowData );

    }

    RtlLeaveCriticalSection( &WindowCriticalSection );

    return(RetVal);

}

PSFC_WINDOW_DATA
pSfcCreateWindowDataEntry(
    HWND hWnd
    )
/*++

Routine Description:

    This function creates a new SFC_WINDOW_DATA structure and inserts it into a
    list of structures.  This is so that we can post a "cleanup" message to all
    of our windows on shutdown, etc.

Arguments: hWnd - the window handle of the window we want to insert into the
                  list.

Return Value: NULL indicates failure, else we return a pointer to the newly
    created SFC_WINDOW_DATA structure


--*/
{
    PSFC_WINDOW_DATA WindowData;

    ASSERT(IsWindow(hWnd));

    WindowData = MemAlloc( sizeof(SFC_WINDOW_DATA) );
    if (!WindowData) {
        DebugPrint1(
                LVL_MINIMAL,
                L"Couldn't allocate memory for SFC_WINDOW_DATA for %x",
                hWnd );
        return(NULL);
    }

    WindowData->hWnd = hWnd;
    WindowData->ThreadId = GetCurrentThreadId();

    RtlEnterCriticalSection( &WindowCriticalSection );
    InsertTailList( &SfcWindowList, &WindowData->Entry );
    RtlLeaveCriticalSection( &WindowCriticalSection );

    return(WindowData);

}


BOOL
pSfcRemoveWindowDataEntry(
    PSFC_WINDOW_DATA WindowData
    )
/*++

Routine Description:

    This function removes an SFC_WINDOW_DATA structure from our global list of
    these structures and frees the memory associated with this structure.

    This list is necessary so that we can post a "cleanup" message to all of
    our windows on shutdown, etc.

    This function is called by the actual window proc right before it goes away.

Arguments: WindowData - pointer to the SFC_WINDOW_DATA structure to be removed.

Return Value: TRUE indicates that the structure was removed successfully.  FALSE
              indicates that the structure was not in the global list and was

--*/
{
    PLIST_ENTRY CurrentEntry;
    PSFC_WINDOW_DATA WindowDataEntry;
    BOOL RetVal = FALSE;

    ASSERT(WindowData != NULL);

    RtlEnterCriticalSection( &WindowCriticalSection );

    CurrentEntry = SfcWindowList.Flink;
    while (CurrentEntry != &SfcWindowList) {

        WindowDataEntry = CONTAINING_RECORD( CurrentEntry, SFC_WINDOW_DATA, Entry );
        if (WindowDataEntry == WindowData) {
            RemoveEntryList( &WindowData->Entry );
            MemFree( WindowData );
            RetVal = TRUE;
            break;
        }

        CurrentEntry = CurrentEntry->Flink;

    }

    RtlLeaveCriticalSection( &WindowCriticalSection );

    return(RetVal);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\resource.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource header file.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

--*/

#define IDC_STATIC                              -1
#define IDC_PROGRESS                            101
#define IDC_NET_NAME                            102
#define IDC_MEDIA_NAME                          103
#define IDC_PROMPT_TEXT                         104

#define IDC_RETRY                               150
#define IDC_INFO                                151

#define IDI_CDROM                               201
#define IDI_NETWORK                             202

#define IDS_TITLE                               301
#define IDS_ERROR_TITLE                         302
#define IDS_PROTDLL_DISABLED                    303
#define IDS_FILE_CHANGE                         304
#define IDS_CANCEL_CONFIRM                      305
#define IDS_WRONG_CD                            306
#define IDS_MORE_INFORMATION_CD                 307
#define IDS_MORE_INFORMATION_NET                308
#define IDS_WRONG_NETCD                         309
#define IDS_RESTORE_TEXT                        310
#define IDS_CACHE_TEXT                          311
#define IDS_INSTALL_PROTECTED_TEXT              312
#define IDS_CANCEL_CONFIRM_INSTALL              313
#define IDS_CANCEL_CONFIRM_CACHE                314


#define IDS_UNKNOWN                             320

#define IDD_PROGRESS                            401
#define IDD_SFC_CD_PROMPT                       402
#define IDD_SFC_NETWORK_PROMPT                  403
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\registry.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Implementation of registry code.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 7-Jul-1999 : added comments
--*/

#include "sfcp.h"
#pragma hdrstop


//
// this is a list of all of the files that we protect on the system.  note that
// there is no such thing as a tier 1 file anymore, only tier 2 files.
//        
PPROTECT_FILE_ENTRY Tier2Files;

//
// this is the total number of files we're protecting
//
ULONG CountTier2Files;

//
// used to signal the watcher that the next change
// type is expected to the this type and if so the
// change should be ignored
//
ULONG* IgnoreNextChange = NULL;
ULARGE_INTEGER LastExemptionTime;


NTSTATUS
InitializeUnicodeString(
    IN PWSTR StrVal,
    IN ULONG StrLen, OPTIONAL
    OUT PUNICODE_STRING String
    )
/*++

Routine Description:

    Initialize a unicode_string given a unicode string pointer.  this function
    handles NULL strings and initializes the unicode string buffer to NULL in 
    this case

Arguments:

    StrVal      - pointer to null terminated unicode string
    StrLen      - length in characters of unicode string.  if not specified,
                  we use the length of the string.
    String      - pointer to a UNICODE_STRING structure that is filled in by
                  this function.
Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    
    ASSERT(String != NULL);
    
    if (StrVal == NULL) {
        String->Length = 0;
        String->MaximumLength = 0;
        String->Buffer = NULL;
        return STATUS_SUCCESS;
    }

    //
    // if the length was specified by the user, use that, otherwise use the 
    // string length
    //
    String->Length = StrLen ? (USHORT)StrLen : (USHORT)UnicodeLen(StrVal);
    //
    // just say that the length is twice what we calculated as the current 
    // length.
    //
    String->MaximumLength = String->Length + (sizeof(WCHAR)*2);
    String->Buffer = (PWSTR) MemAlloc( String->MaximumLength );
    if (String->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    RtlMoveMemory( String->Buffer, StrVal, String->Length );

    return STATUS_SUCCESS;
}


ULONG
SfcQueryRegDword(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr,
    ULONG DefaultValue
    )
/*++

Routine Description:

    retrieve a DWORD from the registry.  if the value is not present or cannot
    be retrieved, we use a default value.  calls registry api's using NT apis
    instead of win32 apis.
    
    
Arguments:

    KeyNameStr    - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to retreive.
    DefaultValue  - if we have problems retreiving the registry key or it is 
                    not set, use this default value.
Return Value:

    registry DWORD value or default value if registry cannot be retreived.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;

    //
    // Open the registry key.
    //

    ASSERT((KeyNameStr != NULL) && (ValueNameStr != NULL));

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", KeyNameStr, Status );
        return DefaultValue;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    //
    // cleanup
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't query value key (%ws): 0x%x", ValueNameStr, Status );
        return DefaultValue;
    }

    ASSERT(KeyValueInfo->Type == REG_DWORD && KeyValueInfo->DataLength == sizeof(DWORD));

    if(KeyValueInfo->Type != REG_DWORD || KeyValueInfo->DataLength != sizeof(DWORD)) {
        return DefaultValue;
    }

    //
    // return value
    //
    return *((PULONG)&KeyValueInfo->Data);
}


ULONG
SfcQueryRegDwordWithAlternate(
    IN PCWSTR FirstKey,
    IN PCWSTR SecondKey,
    IN PCWSTR ValueNameStr,
    IN ULONG DefaultValue
    )
/*++

Routine Description:

    retrieve a DWORD from the registry.  if the value is not present in the
    first key location, we look in the second key location.  If the key cannot
    be retrieved, we use a default value.  calls registry api's using NT apis
    instead of win32 apis.       

Arguments:

    FirstKey      - contains first registry keyname to look for value under.
    SecondKey     - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to retreive.
    DefaultValue  - if we have problems retreiving the registry key or it is 
                    not set, use this default value.
Return Value:

    registry DWORD value or default value if registry cannot be retreived.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    BOOL FirstTime;
    PCWSTR p;

    
    //
    // Open the registry key.
    //
    FirstTime = TRUE;
    ASSERT((FirstKey != NULL) && (ValueNameStr != NULL) && (SecondKey != NULL));

TryAgain:
    p = FirstTime ? FirstKey : SecondKey;
    
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, p );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status) && !FirstTime) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", p, Status );
        return DefaultValue;
    }

    if (!NT_SUCCESS(Status)) {
        ASSERT( FirstTime == TRUE );
        FirstTime = FALSE;
        goto TryAgain;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    //
    // cleanup
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status) && !FirstTime) {
        DebugPrint2( LVL_VERBOSE, L"can't query value key (%ws): 0x%x", ValueNameStr, Status );
        return DefaultValue;
    }

    if (!NT_SUCCESS(Status)) {
        ASSERT( FirstTime == TRUE );
        FirstTime = FALSE;
        goto TryAgain;
    }

    ASSERT(KeyValueInfo->Type == REG_DWORD && KeyValueInfo->DataLength == sizeof(DWORD));

    if(KeyValueInfo->Type != REG_DWORD || KeyValueInfo->DataLength != sizeof(DWORD)) {
        return DefaultValue;
    }

    //
    // return value
    //
    return *((PULONG)&KeyValueInfo->Data);
}


PWSTR
SfcQueryRegString(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr
    )
/*++

Routine Description:

    retrieve a string from the registry.  if the value is not present or cannot
    be retrieved, we return NULL.  calls registry api's using NT apis
    instead of win32 apis.    

Arguments:

    KeyNameStr    - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to retreive.
    
Return Value:

    unicode string pointer or NULL if registry cannot be retreived.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    PWSTR s;

    ASSERT((KeyNameStr != NULL) && (ValueNameStr != NULL));

    //
    // Open the registry key.
    //

    RtlZeroMemory( (PVOID)ValueBuffer, VALUE_BUFFER_SIZE );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", KeyNameStr, Status );
        return NULL;
    }
    
    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    //
    // cleanup
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't query value key (%ws): 0x%x", ValueNameStr, Status );
        return 0;
    }

    if (KeyValueInfo->Type == REG_MULTI_SZ) {
        DebugPrint1( LVL_VERBOSE, 
                     L"Warning: value key %ws is REG_MULTI_SZ, we will only return first string in list", 
                     ValueNameStr );
    } else {
        ASSERT(KeyValueInfo->Type == REG_SZ || KeyValueInfo->Type == REG_EXPAND_SZ);

        if(KeyValueInfo->Type != REG_SZ && KeyValueInfo->Type != REG_EXPAND_SZ) {
            return NULL;
        }
    }

    //
    // string length + 16 for slop
    //
    s = (PWSTR) MemAlloc( KeyValueInfo->DataLength + 16 );
    if (s == NULL) {
        return NULL;
    }

    CopyMemory( s, KeyValueInfo->Data, KeyValueInfo->DataLength );

    return s;
}

ULONG
SfcQueryRegPath(
    IN PCWSTR KeyNameStr,
    IN PCWSTR ValueNameStr,
	IN PCWSTR DefaultValue OPTIONAL,
	OUT PWSTR Buffer OPTIONAL,
	IN ULONG BufferSize OPTIONAL
    )
/*++

Routine Description:

    retrieves a path from the registry.  if the value is not present or cannot be retrieved, 
	it returns the passed-in default string. The function writes up to BufferSize - 1 characters and appends
	a null. calls registry api's using NT apis instead of win32 apis.    

Arguments:

    KeyNameStr    - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to retreive.
	DefaultValue  - the value returned in case of an error
	Buffer        - the buffer that receives the string
	BufferSize    - the size of Buffer in chars
    
Return Value:

    the length of the value data in chars, including the null

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) ValueBuffer;
    ULONG ValueLength;
	ULONG RequiredSize = 1;	// for null
    PCWSTR retval = NULL;

	ASSERT(KeyNameStr != NULL && ValueNameStr != NULL);
	ASSERT(0 == BufferSize || Buffer != NULL);

	if(BufferSize != 0)
		Buffer[0] = 0;

	//
	// Open the registry key.
	//
	RtlInitUnicodeString( &KeyName, KeyNameStr );

	InitializeObjectAttributes(
		&ObjectAttributes,
		&KeyName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
		);

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);

	if(NT_SUCCESS(Status)) 
	{
		//
		// Query the key value.
		//
		RtlInitUnicodeString( &ValueName, ValueNameStr );

		Status = NtQueryValueKey(
			Key,
			&ValueName,
			KeyValuePartialInformation,
			(PVOID) KeyValueInfo,
			VALUE_BUFFER_SIZE,
			&ValueLength
			);

		NtClose(Key);

		if(NT_SUCCESS(Status)) 
		{
			ASSERT(KeyValueInfo->Type == REG_SZ || KeyValueInfo->Type == REG_EXPAND_SZ);

            if(KeyValueInfo->Type == REG_SZ || KeyValueInfo->Type == REG_EXPAND_SZ) {
                retval = (PCWSTR) KeyValueInfo->Data;
            }
		}
	}

	if(NULL == retval || 0 == retval[0])
		retval = DefaultValue;

	if(retval != NULL)
	{
		RequiredSize = ExpandEnvironmentStrings(retval, Buffer, BufferSize);

		if(BufferSize != 0 && BufferSize < RequiredSize)
			Buffer[BufferSize - 1] = 0;
	}

	return RequiredSize;
}

PWSTR
SfcQueryRegStringWithAlternate(
    IN PCWSTR FirstKey,
    IN PCWSTR SecondKey,
    IN PCWSTR ValueNameStr
    )
/*++

Routine Description:

    retrieve a string from the registry.  if the value is not present or cannot
    be retrieved, we try the second key, then we return NULL.  
    
    This calls registry api's using NT apis instead of win32 apis.
    

Arguments:

    FirstKey      - contains registry keyname to look for value under.
    SecondKey     - 2nd key to look for value under
    ValueNameStr  - contains registry value to retreive.
    
Return Value:

    unicode string pointer or NULL if registry cannot be retreived.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    PWSTR s;
    BOOL FirstTime;
    PCWSTR p;

    ASSERT((FirstKey != NULL) && (ValueNameStr != NULL) && (SecondKey != NULL));
    FirstTime = TRUE;

TryAgain:
    p = FirstTime ? FirstKey : SecondKey;


    //
    // Open the registry key.
    //

    RtlZeroMemory( (PVOID)ValueBuffer, VALUE_BUFFER_SIZE );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, p );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status) && !FirstTime) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", p, Status );
        return NULL;
    }

    if (!NT_SUCCESS(Status)) {
        ASSERT( FirstTime == TRUE );
        FirstTime = FALSE;
        goto TryAgain;
    }
    
    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    //
    // cleanup
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status) && !FirstTime) {
        DebugPrint2( LVL_VERBOSE, L"can't query value key (%ws): 0x%x", ValueNameStr, Status );
        return 0;
    }

    if (!NT_SUCCESS(Status)) {
        ASSERT( FirstTime == TRUE );
        FirstTime = FALSE;
        goto TryAgain;
    }

    if (KeyValueInfo->Type == REG_MULTI_SZ) {
        DebugPrint1( LVL_VERBOSE, 
                     L"Warning: value key %ws is REG_MULTI_SZ, we will only return first string in list", 
                     ValueNameStr );
    } else {
        ASSERT(KeyValueInfo->Type == REG_SZ || KeyValueInfo->Type == REG_EXPAND_SZ);

        if(KeyValueInfo->Type != REG_SZ && KeyValueInfo->Type != REG_EXPAND_SZ) {
            return NULL;
        }
    }

    //
    // string length + 16 for slop
    //
    s = (PWSTR) MemAlloc( KeyValueInfo->DataLength + 16 );
    if (s == NULL) {
        return NULL;
    }

    CopyMemory( s, KeyValueInfo->Data, KeyValueInfo->DataLength );

    return s;
}


ULONG
SfcWriteRegDword(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr,
    ULONG Value
    )
/*++

Routine Description:

    set a REG_DWORD value in the registry.  Calls registry api's using NT apis
    instead of win32 apis.    

Arguments:

    KeyNameStr    - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to set.
    Value         - actual value to be set
    
Return Value:

    win32 error code indicating outcome.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;

    ASSERT((KeyNameStr != NULL) && (ValueNameStr != NULL));

    //
    // Open the registry key.
    //

    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_SET_VALUE, &ObjectAttributes);
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // key doesn't exist, let's try to create one
        //
        Status = NtCreateKey( &Key, 
                          KEY_SET_VALUE, 
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          NULL
                          );

    }
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", KeyNameStr, Status );
        return(RtlNtStatusToDosError(Status));
    }

    //
    // set the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );


    Status = NtSetValueKey(
        Key,
        &ValueName,
        0,
        REG_DWORD,
        &Value,
        sizeof(ULONG)
        );

    //
    // cleanup and leave
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't set value key (%ws): 0x%x", ValueNameStr, Status );
        
    }

    return(RtlNtStatusToDosError(Status));
}


DWORD
SfcWriteRegString(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr,
    PCWSTR Value
    )
/*++

Routine Description:

    set a REG_SZ value in the registry.  Calls registry api's using NT apis
    instead of win32 apis.
    

Arguments:

    KeyNameStr    - contains registry keyname to look for value under.
    ValueNameStr  - contains registry value to set.
    Value         - actual value to be set
    
Return Value:

    Win32 error code indicating outcome.        

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;

    ASSERT((KeyNameStr != NULL) && (ValueNameStr != NULL));

    //
    // Open the registry key.
    //

    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_SET_VALUE, &ObjectAttributes);
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // key doesn't exist, let's try to create one
        //
        Status = NtCreateKey( &Key, 
                          KEY_SET_VALUE, 
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          NULL
                          );

    }
    
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't open %ws key: 0x%x", KeyNameStr, Status );
        return(RtlNtStatusToDosError(Status));
    }

    //
    // set the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );

    Status = NtSetValueKey(
        Key,
        &ValueName,
        0,
        REG_SZ,
        (PWSTR)Value,
        UnicodeLen(Value)
        );

    //
    // cleanup
    //
    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"can't set value key (%ws): 0x%x", ValueNameStr, Status );
        return(RtlNtStatusToDosError(Status)) ;
    }

    return ERROR_SUCCESS;
}


#if 0
DWORD
WsInAWorkgroup(
    VOID
    )
/*++

Routine Description:

    This function determines whether we are a member of a domain, or of
    a workgroup.  First it checks to make sure we're running on a Windows NT
    system (otherwise we're obviously in a domain) and if so, queries LSA
    to get the Primary domain SID, if this is NULL, we're in a workgroup.

    If we fail for some random unexpected reason, we'll pretend we're in a
    domain (it's more restrictive).

Arguments:
    None

Return Value:

    TRUE   - We're in a workgroup
    FALSE  - We're in a domain

--*/
{
    NT_PRODUCT_TYPE ProductType;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE Handle;
    NTSTATUS Status;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo = NULL;
    DWORD Result = FALSE;


    Status = RtlGetNtProductType( &ProductType );

    if (!NT_SUCCESS( Status )) {
        DebugPrint( LVL_MINIMAL, L"Could not get Product type" );
        return FALSE;
    }

    if (ProductType == NtProductLanManNt) {
        return FALSE;
    }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );

    Status = LsaOpenPolicy( NULL, &ObjectAttributes, POLICY_VIEW_LOCAL_INFORMATION, &Handle );
    if (!NT_SUCCESS(Status)) {
        DebugPrint( LVL_MINIMAL, L"Could not open LSA Policy Database" );
        return FALSE;
    }

    Status = LsaQueryInformationPolicy( Handle, PolicyPrimaryDomainInformation, (LPVOID)&PolicyPrimaryDomainInfo );
    if (NT_SUCCESS(Status)) {
        if (PolicyPrimaryDomainInfo->Sid == NULL) {
           Result = TRUE;
        } else {
           Result = FALSE;
        }
    }

    if (PolicyPrimaryDomainInfo) {
        LsaFreeMemory( (PVOID)PolicyPrimaryDomainInfo );
    }

    LsaClose( Handle );

    return Result;
}


BOOL
WaitForMUP(
    DWORD dwMaxWait
    )
/*++

Routine Description:

    Waits for MUP to initialize by looking for the event that is signalled
    when MUP is ready
    
    
Arguments:
    dwMaxWait   - amount of time we'll wait for MUP to initialize

Return Value:

    TRUE   - MUP is initialized
    FALSE  - could not confirm MUP is initialized

--*/

{
    HANDLE hEvent;
    BOOL bResult;
    INT i = 0;


    if (WsInAWorkgroup()) {
        return TRUE;
    }

    DebugPrint(LVL_MINIMAL, L"waiting for mup...");
    //
    // Try to open the event
    //

    do {
        hEvent = OpenEvent(
            SYNCHRONIZE,
            FALSE,
            L"wkssvc:  MUP finished initializing event"
            );
        if (hEvent) {
            DebugPrint(LVL_MINIMAL, L"opened the mup event");
            break;
        }

        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            break;
        }

        DebugPrint(LVL_MINIMAL, L"mup event does not yet exist, waiting...");
        Sleep(2000);

        i++;

    } while (i < 30);


    if (!hEvent) {
        DebugPrint1(LVL_MINIMAL, L"Failed to open MUP event, ec=%d\n", GetLastError());
        return FALSE;
    }


    //
    // Wait for the event to be signalled
    //

    bResult = (WaitForSingleObject (hEvent, dwMaxWait) == WAIT_OBJECT_0);


    //
    // Clean up
    //

    CloseHandle (hEvent);

    return bResult;
}

#endif


NTSTATUS
ExpandPathString(
    IN PWSTR PathString,
    IN ULONG PathStringLength,
    OUT PUNICODE_STRING FileName, OPTIONAL
    OUT PUNICODE_STRING PathName,
    OUT PUNICODE_STRING FullPathName OPTIONAL
    )
/*++

Routine Description:

    Routine takes a source string containing environment variables, expand this
    into the full path.  Then it either copies this into a path, file, and full
    path, as requested.
    
Arguments:
    
    PathString       - source path string
    PathStringLength - source path string length
    FileName         - receives filename part of the path if specified.  If not
                       specified, we only want the path part
    PathName         - receives the path part of the expanded source.  If 
                       FileName is not specified, we fill in pathname with the
                       entire expanded path
    FullPathName     - if FileName is specified, then this is filled in with
                       the complete path.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING NewPath;
    UNICODE_STRING SrcPath;
    PWSTR FilePart;

    
    ASSERT((PathString != NULL));
    ASSERT((FileName == NULL) 
            ? (PathName != NULL) 
            : ((FullPathName != NULL) && (PathName != NULL)));
    
    //
    // turn the pathstring and length into a UNICODE_STRING
    //
    SrcPath.Length = (USHORT)PathStringLength;
    SrcPath.MaximumLength = SrcPath.Length;
    SrcPath.Buffer = PathString;

    //
    // create a new scratch UNICODE_STRING
    //
    NewPath.Length = 0;
    NewPath.MaximumLength = (MAX_PATH*2) * sizeof(WCHAR);
    NewPath.Buffer = (PWSTR) MemAlloc( NewPath.MaximumLength );
    if (NewPath.Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // expand source environment string into scratch string
    //
    Status = RtlExpandEnvironmentStrings_U(
        NULL,
        &SrcPath,
        &NewPath,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_MINIMAL, L"ExpandEnvironmentStrings failed for [%ws], ec=%08x", PathString, Status );
        goto exit;
    }

    //
    // convert scratch string to lowercase
    //
    MyLowerString( NewPath.Buffer, NewPath.Length/sizeof(WCHAR) );

    //
    // if filename isn't specified, then just copy the string into the pathname
    // and exit
    //
    if (FileName == NULL) {
        
        PathName->Length = NewPath.Length;
        PathName->MaximumLength = NewPath.MaximumLength;
        PathName->Buffer = NewPath.Buffer;
        return(STATUS_SUCCESS);

    }  else {    

        //
        // copy the full string into the fullpathname
        // 
        Status = InitializeUnicodeString( NewPath.Buffer, NewPath.Length, FullPathName );
        if (!NT_SUCCESS(Status)) {
            DebugPrint2( LVL_MINIMAL, L"InitializeUnicodeString failed for [%ws], ec=%08x", NewPath.Buffer, Status );
            goto exit;
        }
    
        //
        // separate the path part from the file part
        //
        FilePart = wcsrchr( NewPath.Buffer, L'\\' );
        if (FilePart == NULL) {
            Status = STATUS_NO_MEMORY;
            goto exit;
        }
    
        *FilePart = 0;
        FilePart += 1;
    
        Status = InitializeUnicodeString( NewPath.Buffer, 0, PathName );
        if (!NT_SUCCESS(Status)) {
            DebugPrint2( LVL_MINIMAL, L"InitializeUnicodeString failed for [%ws], ec=%08x", NewPath.Buffer, Status );            
            goto exit;
        }
        Status = InitializeUnicodeString( FilePart, 0, FileName );

        if (!NT_SUCCESS(Status)) {
            DebugPrint2( LVL_MINIMAL, L"InitializeUnicodeString failed for [%ws], ec=%08x", FilePart, Status );            
        }
        
    }


    FilePart -= 1;
    *FilePart = L'\\';
exit:
    MemFree( NewPath.Buffer );

    return Status;
}


BOOL
SfcDisableDllCache(
    BOOL LogMessage
    )
/*++

Routine Description:

    Routine disables the dllcache functionality.
    
    Specifically, we set the dll cache directory to the default and sets the 
    cache size to zero.  So we will never add files in the cache.
    
    We also log an error message if requested.
        
Arguments:
    
    LogMessage - if TRUE, we log a message indicating the cache is disabled

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    PWSTR CacheDefault = DLLCACHE_DIR_DEFAULT;
    NTSTATUS Status;
    
    Status = ExpandPathString(
                    CacheDefault,
                    UnicodeLen(CacheDefault),
                    NULL,
                    &SfcProtectedDllPath,
                    NULL
                    );
    if (NT_SUCCESS(Status)) {
        DebugPrint1(LVL_MINIMAL, 
                    L"default cache dir name=[%ws]",
                    SfcProtectedDllPath.Buffer);
        
        SfcProtectedDllFileDirectory = SfcOpenDir(
                                              TRUE, 
                                              TRUE, 
                                              SfcProtectedDllPath.Buffer );
        if (SfcProtectedDllFileDirectory == NULL) {
            DebugPrint(LVL_MINIMAL, 
                       L"could not open the cache dir, need to create");
            SfcProtectedDllFileDirectory = SfcCreateDir( 
                                                SfcProtectedDllPath.Buffer, 
                                                TRUE );
            if (SfcProtectedDllFileDirectory == NULL) {
                DebugPrint( LVL_MINIMAL, L"Cannot create ProtectedDllPath" );
            }
        }
    } else {
        //
        // not enough memory...we're toast
        //
        DebugPrint( LVL_MINIMAL, L"Cannot open ProtectedDllPath" );
        return(FALSE);
    }

    //
    // set the quota to zero
    //
    SFCQuota = 0;

    if (LogMessage) {
       SfcReportEvent( MSG_DLLCACHE_INVALID, NULL, NULL, 0 );
    }

    return(TRUE);
}



NTSTATUS
SfcInitializeDllList(
    IN PPROTECT_FILE_ENTRY Files,
    IN ULONG NumFiles,
    OUT PULONG Count
    )
/*++

Routine Description:

    Routine takes an empty array of SFC_REGISTRY_VALUE structures stored in the
    global SfcProtectedDllsList global and assigns the data from an array of
    PROTECT_FILE_ENTRY structures into these structures.
        
Arguments:
    
    Files    - pointer to first element in array of PROTECT_FILE_ENTRY 
               structures
    NumFiles - number of elements in array of structures
    Count    - receives number of files we correctly setup

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status,FinalStatus, LoopStatus;
    ULONG Index;
    PSFC_REGISTRY_VALUE RegVal;

    ASSERT(    (Files != NULL) 
            && (SfcProtectedDllsList != NULL)
            && (Count != NULL) );

    LoopStatus = FinalStatus = STATUS_SUCCESS;
    
    for (Index=0; Index<NumFiles; Index++) {
        
        RegVal = &SfcProtectedDllsList[*Count];

        //
        // set the directory name, filename and full path members
        //
        Status = ExpandPathString(
            Files[Index].FileName,
            UnicodeLen(Files[Index].FileName),
            &RegVal->FileName,
            &RegVal->DirName,
            &RegVal->FullPathName
            );
        if (!NT_SUCCESS(Status)) {
            //
            // if we have a problem initializing one of the array elements
            // keep going
            //
            DebugPrint1( LVL_MINIMAL, 
                         L"ExpandPathString failed, ec=%08x", 
                         Status );
            FinalStatus = Status;
            continue;
        }

        //
        // set the layout inf name and the source file names if they are present
        //
        Status = InitializeUnicodeString( Files[Index].InfName, 
                                          0, 
                                          &RegVal->InfName );
        if (!NT_SUCCESS(Status)) {
            DebugPrint1( LVL_MINIMAL, 
                         L"InitializeUnicodeString failed, ec=%08x", 
                         Status );
            LoopStatus = FinalStatus = Status;
        }
        Status = InitializeUnicodeString( Files[Index].SourceFileName,
                                          0,
                                          &RegVal->SourceFileName );
        if (!NT_SUCCESS(Status)) {
            DebugPrint1( LVL_MINIMAL,
                         L"InitializeUnicodeString failed, ec=%08x",
                         Status );
            LoopStatus = FinalStatus = Status;
        }

        if (NT_SUCCESS(Status)) {
            *Count += 1;
        }

        //
        // WinSxs work (jonwis) This is NULL in all cases, unless this entry is
        // added by WinSxs (see dirwatch.c)
        //
        RegVal->pvWinSxsCookie = NULL;
        
        LoopStatus = STATUS_SUCCESS;
    }

    Status = FinalStatus;
    if (NT_SUCCESS(Status)) {
        ASSERT(*Count == NumFiles);
    }
    
    return(Status);
}


NTSTATUS
SfcInitializeDllLists(
    PSFC_GET_FILES pfGetFiles
    )
/*++

Routine Description:

    Initialize the list of files we're going to protect.
    
Arguments:
    
    None.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    PWSTR s;
    BOOL FreeMem = TRUE;


    //
    // make sure we only call this guy once
    //
    if (SfcProtectedDllCount) {
        return STATUS_SUCCESS;
    }

    DebugPrint(LVL_MINIMAL, L"entering SfcInitializeDllLists()");

    //
    // get the dllcache directory and store it into to SfcProtectedDllPath
    // global
    //
    s = SfcQueryRegStringWithAlternate( REGKEY_POLICY, REGKEY_WINLOGON, REGVAL_SFCDLLCACHEDIR );
    if (s == NULL) {
        s = DLLCACHE_DIR_DEFAULT;
        FreeMem = FALSE;
    }
        
    Status = ExpandPathString(
        s,
        UnicodeLen(s),
        NULL,
        &SfcProtectedDllPath,
        NULL
        );
    if (NT_SUCCESS(Status)) {
        WCHAR DontCare[MAX_PATH];
        DWORD DriveType;
        
        DebugPrint1(LVL_MINIMAL, 
                    L"cache dir name=[%ws]",
                    SfcProtectedDllPath.Buffer);

        DriveType = SfcGetPathType( 
                        SfcProtectedDllPath.Buffer, 
                        DontCare, 
                        UnicodeChars(DontCare));
        if (DriveType != PATH_LOCAL) {
            DebugPrint2(LVL_MINIMAL,
                        L"cache dir %ws does not appear to be a local path (type %d), we are disabling cache functionality",
                        SfcProtectedDllPath.Buffer,
                        DriveType);
            SfcDisableDllCache( SFCDisable != SFC_DISABLE_SETUP );
            goto init;
        }


        //
        // get a handle to the dll cache directory
        //
        SfcProtectedDllFileDirectory = SfcOpenDir(
                                              TRUE, 
                                              TRUE, 
                                              SfcProtectedDllPath.Buffer );
        if (SfcProtectedDllFileDirectory == NULL) {
            DebugPrint(LVL_MINIMAL, 
                       L"could not open the cache dir, need to create");
            SfcProtectedDllFileDirectory = SfcCreateDir( 
                                                SfcProtectedDllPath.Buffer, 
                                                TRUE );
            if (SfcProtectedDllFileDirectory == NULL) {
                DebugPrint( LVL_MINIMAL, L"Cannot open ProtectedDllPath" );
                SfcDisableDllCache( SFCDisable != SFC_DISABLE_SETUP );
            } else {
                //
                // force a scan if we just created the dll cache
                //
                SFCScan = SFC_SCAN_ALWAYS;
            }
        }
    } else {
        //
        // dll cache path in registry must be bogus...use default path and
        // set the quota to zero so the cache is effectively disabled.
        //
        SfcDisableDllCache( SFCDisable != SFC_DISABLE_SETUP );
    }    

init:    

    if (FreeMem) {
        MemFree( s );
    }

    DebugPrint1(LVL_MINIMAL, 
                L"cache dir name=[%ws]",
                SfcProtectedDllPath.Buffer);
    ASSERT( SfcProtectedDllFileDirectory != NULL );

    //
    // now that we have the dll cache initialized, now retrieve the list of 
    // files that we will protect.  The list of files currently resides in
    // sfcfiles.dll.
    //
	ASSERT(pfGetFiles != NULL);
    Status = pfGetFiles( &Tier2Files, &CountTier2Files );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Take the file list (we only have the tier2 list) and build an array of
    // SFC_REGISTRY_VALUE structures and store into the SfcProtectedDllsList
    // global
    //

    SfcProtectedDllsList = (PSFC_REGISTRY_VALUE) MemAlloc( sizeof(SFC_REGISTRY_VALUE)*CountTier2Files );
    if (SfcProtectedDllsList == NULL) {
        return(STATUS_NO_MEMORY);
    }

    ASSERT(SfcProtectedDllCount == 0);

    //
    // now associate the data in our tier2 list with each of these structures
    // in the array
    //
    Status = SfcInitializeDllList( Tier2Files, CountTier2Files, &SfcProtectedDllCount );

    if (CountTier2Files != SfcProtectedDllCount) {
        DebugPrint2( LVL_MINIMAL, 
                     L"incorrect number of files in list: required count: %d actual count %d",
                     CountTier2Files, 
                     SfcProtectedDllCount );
        ASSERT(!NT_SUCCESS(Status));
    } else {
        IgnoreNextChange = (ULONG*) MemAlloc(SfcProtectedDllCount * sizeof(ULONG));

        if(NULL == IgnoreNextChange) {
            Status = STATUS_NO_MEMORY;
        }
    }
    
    DebugPrint(LVL_MINIMAL, L"leaving SfcInitializeDllLists()");
    return(Status);
}

DWORD
SfcCopyRegValue(
    IN LPCWSTR SourceKeyName,
    IN LPCWSTR SourceValueName,
    IN LPCWSTR DestinationKeyName,
    IN LPCWSTR DestinationValueName
    )
/*++

Routine Description:

    Copies a registry value from one key to another.
    
Arguments:
    
    SourceKeyName           -path to the source key name
    SourceValueName         -path to the source value name
    DestinationKeyName      -path to the destination key name
    DestinationValueName    -path to the destination value name

Return Value:

    Win32 error code.

--*/
{
    LONG Error = ERROR_SUCCESS;
    HKEY SourceKey = NULL;
    HKEY DestKey = NULL;
    LPBYTE DataPtr = NULL;
    DWORD ValueType;
    DWORD ValueSize;

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SourceKeyName, 0, KEY_QUERY_VALUE, &SourceKey);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    ValueSize = 0;
    Error = RegQueryValueExW(SourceKey, SourceValueName, NULL, &ValueType, NULL, &ValueSize);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    DataPtr = (LPBYTE) MemAlloc(ValueSize);

    if(NULL == DataPtr) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    Error = RegQueryValueExW(SourceKey, SourceValueName, NULL, &ValueType, DataPtr, &ValueSize);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE, DestinationKeyName, 0, KEY_SET_VALUE, &DestKey);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    Error = RegSetValueExW(DestKey, DestinationValueName, 0, ValueType, DataPtr, ValueSize);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

exit:
    if(SourceKey != NULL) {
        RegCloseKey(SourceKey);
    }

    if(DestKey != NULL) {
        RegCloseKey(DestKey);
    }

    MemFree(DataPtr);
    return (DWORD) Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\eventlog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    Implementation of event logging.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 7-Jul-1999
    
--*/

#include "sfcp.h"
#pragma hdrstop


typedef BOOL (WINAPI *PPSETUPLOGSFCERROR)(PCWSTR,DWORD);

//
// global handle to eventlog
//
HANDLE hEventSrc;

//
// pointer to gui-setup eventlog function
//
PPSETUPLOGSFCERROR pSetuplogSfcError;

BOOL
pSfcGetSetuplogSfcError(
    VOID
    )
/*++

Routine Description:

    Routine retreives a function pointer to the error logging entrypoint in
    syssetup.dll

Arguments:

    None.

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    HMODULE hMod;

    if (NULL == pSetuplogSfcError) {
        hMod = GetModuleHandle( L"syssetup.dll" );

        if (hMod) {
            pSetuplogSfcError = (PPSETUPLOGSFCERROR)SfcGetProcAddress( hMod, "pSetuplogSfcError" );
        } else {
            DebugPrint1(LVL_MINIMAL, L"GetModuleHandle on syssetup.dll failed, ec=0x%08x",GetLastError());
        }
    }

    return pSetuplogSfcError != NULL;
}

BOOL
SfcReportEvent(
    IN ULONG EventId,
    IN PCWSTR FileName,
    IN PCOMPLETE_VALIDATION_DATA ImageValData,
    IN DWORD LastError OPTIONAL
    )
/*++

Routine Description:

    Routine logs an event into the eventlog.  Also contains a hack for logging
    data into the GUI-setup error log as well.  we typically log unsigned files
    or the user tht cancelled the replacement of the signed files.

Arguments:

    EventId      - id of the eventlog error
    FileName     - null terminated unicode string indicating the file that was
                   unsigned, etc.
    ImageValData - pointer to file data for unsigned file
    LastError    - contains an optional last error code for logging

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    PFILE_VERSION_INFO FileVer;
    WCHAR SysVer[64];
    WCHAR BadVer[64];
    PCWSTR s[3];
    WORD Count = 0;
    WCHAR LastErrorText[MAX_PATH];
    PVOID ErrText = NULL;
    WORD wEventType;

    //
    // if we're in gui-mode setup, we take a special path to log into 
    // gui-setup's logfile instead of the eventlog
    //
    if (SFCDisable == SFC_DISABLE_SETUP) {
        if(!pSfcGetSetuplogSfcError()) {
            return FALSE;
        }

        switch (EventId){
        
            case MSG_DLL_CHANGE: //fall through
            case MSG_SCAN_FOUND_BAD_FILE:
                pSetuplogSfcError( FileName,0 );
                break;

            case MSG_COPY_CANCEL_NOUI:
            case MSG_RESTORE_FAILURE:
                pSetuplogSfcError( FileName, 1 );
                break;

            case MSG_CACHE_COPY_ERROR:
                pSetuplogSfcError( FileName, 2 );
                break;

            default:
                DebugPrint1(
                    LVL_MINIMAL, 
                    L"unexpected EventId 0x%08x in GUI Setup, ",
                    EventId);

                return FALSE;
                //ASSERT( FALSE && L"Unexpected EventId in SfcReportEvent");
        }

        return(TRUE);
    }

    //
    // we're outside of GUI-setup so we really want to log to the eventlog
    //

    if (EventId == 0) {
        ASSERT( FALSE && L"Unexpected EventId in SfcReportEvent");
        return(FALSE);
    }

    //
    // if we don't have a handle to the eventlog, create one.
    //
    if (hEventSrc == NULL) {
        hEventSrc = RegisterEventSource( NULL, L"Windows File Protection" );
        if (hEventSrc == NULL) {
            DebugPrint1(LVL_MINIMAL, L"RegisterEventSource failed, ec=0x%08x",GetLastError());
            return(FALSE);
        }
    }

    ASSERT(hEventSrc != NULL);
    

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        LastError,
        0,
        (PWSTR) &ErrText,
        0,
        NULL 
    );

    if (ErrText) {
        wsprintf(LastErrorText,L"0x%08x [%ws]",LastError,ErrText);
        LocalFree( ErrText );
    } else {
        wsprintf(LastErrorText,L"0x%08x",LastError);
    }
    

    //
    // pick out the appropriate message to log
    // the default event type is "information"
    //
    wEventType = EVENTLOG_INFORMATION_TYPE;

    switch (EventId) {
        case MSG_DLL_CHANGE:
            ASSERT(FileName != NULL);
            s[0] = FileName;

            //
            // we prefer a message that is most informative message with 
            // version information for both dlls to the least informative
            // message with no version information
            // 
            //
            if (ImageValData->New.DllVersion && ImageValData->Original.DllVersion)   {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->New.DllVersion;
                swprintf( SysVer, L"%d.%d.%d.%d", FileVer->VersionHigh, FileVer->VersionLow, FileVer->BuildNumber, FileVer->Revision );
                FileVer = (PFILE_VERSION_INFO)&ImageValData->Original.DllVersion;
                swprintf( BadVer, L"%d.%d.%d.%d", FileVer->VersionHigh, FileVer->VersionLow, FileVer->BuildNumber, FileVer->Revision );
                s[1] = BadVer;
                s[2] = SysVer;
                Count = 3;
                EventId = MSG_DLL_CHANGE2;
            } else if (ImageValData->New.DllVersion) {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->New.DllVersion;
                swprintf( SysVer, L"%d.%d.%d.%d", FileVer->VersionHigh, FileVer->VersionLow, FileVer->BuildNumber, FileVer->Revision );
                s[1] = SysVer;
                Count = 2;
                EventId = MSG_DLL_CHANGE3;
            } else if (ImageValData->Original.DllVersion) {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->Original.DllVersion;
                swprintf( BadVer, L"%d.%d.%d.%d", FileVer->VersionHigh, FileVer->VersionLow, FileVer->BuildNumber, FileVer->Revision );
                s[1] = BadVer;
                Count = 2;
                EventId = MSG_DLL_CHANGE;
            } else {
                //
                // we have to protect some things without version information, 
                // so we just log an error that doesn't mention version
                // information.  If we stop protecting files like this, this
                // should be an assert in prerelease versions of the code
                //
                Count = 1;
                EventId = MSG_DLL_CHANGE_NOVERSION;
                DebugPrint1( LVL_MINIMAL, L"TskTsk...the protected OS file %ws does not have any version information", FileName);                
            }
            break;

        case MSG_SCAN_FOUND_BAD_FILE:
            ASSERT(FileName != NULL);
            s[0] = FileName;

            //
            // if we found a bad file, we only want the version of the restored file
            //
            if (ImageValData->New.DllVersion) {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->New.DllVersion;
                swprintf( SysVer, L"%d.%d.%d.%d", FileVer->VersionHigh, FileVer->VersionLow, FileVer->BuildNumber, FileVer->Revision );
                s[1] = SysVer;
                Count = 2;
            } else {
                DebugPrint1( LVL_MINIMAL, L"TskTsk...the protected OS file %ws does not have any version information", FileName);
                EventId = MSG_SCAN_FOUND_BAD_FILE_NOVERSION;
                Count = 1;
                break;                
            }
            break;

        case MSG_RESTORE_FAILURE:
            Count = 3;
            s[0] = FileName;
            s[1] = BadVer;
            s[2] = (PCWSTR)LastErrorText;

            if (ImageValData->Original.DllVersion)   {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->Original.DllVersion;
                swprintf( BadVer, 
                          L"%d.%d.%d.%d", 
                          FileVer->VersionHigh,
                          FileVer->VersionLow, 
                          FileVer->BuildNumber,
                          FileVer->Revision );
            } else {
                LoadString( SfcInstanceHandle,IDS_UNKNOWN,BadVer,UnicodeChars(BadVer));
            }


            break;
        
        case MSG_CACHE_COPY_ERROR:
            Count = 2;
            s[0] = FileName;
            s[1] = (PCWSTR)LastErrorText;
            break;

        case MSG_COPY_CANCEL_NOUI:
            //fall through
        case MSG_COPY_CANCEL:
            Count = 3;
            s[0] = FileName;
            s[1] = LoggedOnUserName;
            s[2] = BadVer;

            if (ImageValData->Original.DllVersion)   {
                FileVer = (PFILE_VERSION_INFO)&ImageValData->Original.DllVersion;
                swprintf( BadVer, 
                          L"%d.%d.%d.%d", 
                          FileVer->VersionHigh,
                          FileVer->VersionLow, 
                          FileVer->BuildNumber,
                          FileVer->Revision );
            } else {
                LoadString( SfcInstanceHandle,IDS_UNKNOWN,BadVer,UnicodeChars(BadVer));
            }
            

            break;

        case MSG_DLL_NOVALIDATION_TERMINATION:
            wEventType = EVENTLOG_WARNING_TYPE;
            s[0] = FileName;
            Count = 1;
            break;

        case MSG_RESTORE_FAILURE_MAX_RETRIES:
            s[0] = FileName;
            Count = 1;
            break;

        case MSG_SCAN_STARTED:
            Count = 0;
            break;

        case MSG_SCAN_COMPLETED:
            Count = 0;
            break;

        case MSG_SCAN_CANCELLED:
            s[0] = LoggedOnUserName;
            Count = 1;
            break;

        case MSG_DISABLE:
            Count = 0;
            break;

        case MSG_DLLCACHE_INVALID:
            Count = 0;
            break;

        case MSG_SXS_INITIALIZATION_FAILED:
            Count = 1;
            s[0] = LastErrorText;
            break;


        case MSG_INITIALIZATION_FAILED:
            Count = 1;
            s[0] = LastErrorText;
            break;

        case MSG_CATALOG_RESTORE_FAILURE:
            Count = 2;
            s[0] = FileName;
            s[1] = LastErrorText;
            break;
        default:
            ASSERT( FALSE && L"Unknown EventId in SfcReportEvent");
            return FALSE;
    }

    return ReportEvent(
        hEventSrc,
        wEventType,
        0,
        EventId,
        NULL,
        Count,
        0,
        s,
        NULL
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\fileio.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    Implementation of file i/o.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 8-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//#include <initguid.h>
//#include <devguid.h>

#define SECURITY_FLAGS (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)


NTSTATUS
SfcOpenFile(
    IN PUNICODE_STRING FileName,
    IN HANDLE DirHandle,
    IN ULONG SharingFlags,
    OUT PHANDLE FileHandle
    )
/*++

Routine Description:

    Routine opens a handle to the specified file. Wrapper for NtOpenFile...

Arguments:

    FileName     - supplies the name of the file to open
    DirHandle    - handle to the directory that the file is located
    SharingFlags - specifies the sharing flags to be used when opening the file.
    FileHandle   - receives the file handle

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(FileHandle != NULL);
    ASSERT((FileName != NULL) && (FileName->Buffer != NULL));
    ASSERT(DirHandle != INVALID_HANDLE_VALUE);


    *FileHandle = NULL;

    InitializeObjectAttributes(
        &ObjectAttributes,
        FileName,
        OBJ_CASE_INSENSITIVE,
        DirHandle,
        NULL
        );

    Status = NtOpenFile(
        FileHandle,
        FILE_READ_ATTRIBUTES | SYNCHRONIZE | FILE_EXECUTE | FILE_READ_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        SharingFlags,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Could not open file (%wZ), ec=%lx", FileName, Status );
        return Status;
    }

    return STATUS_SUCCESS;
}


HANDLE
SfcCreateDir(
    IN PCWSTR DirName,
    IN BOOL UseCompression
    )
/*++

Routine Description:

    Routine creates a directory if it doesn't already exist.

Arguments:

    DirName        - supplies the dos-style directory name to be created
    UseCompression - if TRUE, try to set compression on this directory

Return Value:

    a valid directory handle for success, otherwise NULL.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    USHORT CompressionState = COMPRESSION_FORMAT_DEFAULT;

    //
    // convert the pathname to something the NT Api can use
    //
    if (!RtlDosPathNameToNtPathName_U( DirName, &FileName, NULL, NULL )) {
        DebugPrint1( LVL_VERBOSE, L"Unable to to convert %ws to an NT path", DirName );
        return NULL;
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // create the directory
    //
    Status = NtCreateFile(
        &FileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_CREATE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
        NULL,
        0
        );

    if(!NT_SUCCESS(Status) ) {
        DebugPrint2( LVL_VERBOSE, L"Unable to create dir (%wZ) - Status == %lx", &FileName, Status );
        FileHandle = NULL;
    }

    if (FileHandle && UseCompression) {
        //
        // try to set compression on the specified directory
        //

        NTSTATUS s;

        s = NtFsControlFile(
                    FileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_SET_COMPRESSION,
                    &CompressionState,
                    sizeof(CompressionState),
                    NULL,
                    0
                    );
        //
        // just check the status so we can log it-- this can fail if our FS
        // doesn't support compression, etc.
        //
        if (!NT_SUCCESS(s)) {
            DebugPrint2( LVL_VERBOSE, L"Unable to set compression on directory (%wZ) - Status = %lx", &FileName, Status );
        }
    }

    MemFree( FileName.Buffer );

    return(FileHandle);
}


HANDLE
SfcOpenDir(
    BOOL IsDosName,
    BOOL IsSynchronous,
    PCWSTR DirName
    )
/*++

Routine Description:

    Routine opens a directory handle to an existant directory.

Arguments:

    IsDosName     - if TRUE, the directory name needs to be converted to an NT
                    path
    IsSynchronous - if TRUE,
    DirName       - null terminated unicode string specifying directory to open

Return Value:

    a valid directory handle for success, otherwise NULL.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(DirName != NULL);

    //
    // convert the pathname to something the NT Api can use if requested
    //
    if (IsDosName) {
        if (!RtlDosPathNameToNtPathName_U( DirName, &FileName, NULL, NULL )) {
            DebugPrint1( LVL_VERBOSE,
                         L"Unable to to convert %ws to an NT path",
                         DirName );
            return NULL;
        }
    } else {
        RtlInitUnicodeString( &FileName, DirName );
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // open the directory
    //
    Status = NtOpenFile(
        &FileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE | READ_CONTROL | WRITE_DAC,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | (IsSynchronous ? FILE_SYNCHRONOUS_IO_NONALERT : 0)
        );

    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Unable to open a handle to the (%wZ) directory - Status == %lx", &FileName, Status );
        FileHandle = NULL;
    }

    if (IsDosName) {
        MemFree( FileName.Buffer );
    }

    return FileHandle;
}


NTSTATUS
SfcMapEntireFile(
    IN HANDLE hFile,
    OUT PHANDLE Section,
    OUT PVOID *ViewBase,
    OUT PSIZE_T ViewSize
    )
/*++

Routine Description:

    Routine memory maps a view of an already opened file.  It is assumed that
    the file was opened with the proper permissions.

Arguments:

    hFile    - file handle to the file to map
    Section  - recieves a handle to the mapped section object
    ViewBase - receives a pointer to the base address
    ViewSize - receives the size of the mapped filed

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;

    ASSERT( hFile != NULL );
    ASSERT( Section != NULL && ViewBase != NULL && ViewSize != NULL );

    *ViewSize = 0;

    SectionOffset.QuadPart = 0;

    //
    // create the section object
    //
    Status = NtCreateSection(
        Section,
        SECTION_ALL_ACCESS,
        NULL,
        NULL,
        PAGE_EXECUTE_WRITECOPY,
        SEC_COMMIT,
        hFile
        );

    if(!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_VERBOSE, L"Status %lx from ZwCreateSection", Status );
        return(Status);
    }

    *ViewBase = NULL;
    //
    // map the section
    //
    Status = NtMapViewOfSection(
        *Section,
        NtCurrentProcess(),
        ViewBase,
        0,
        0,
        &SectionOffset,
        ViewSize,
        ViewShare,
        0,
        PAGE_EXECUTE_WRITECOPY
        );

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        DebugPrint1( LVL_VERBOSE, L"SfcMapEntireFile: Status %lx from ZwMapViewOfSection", Status );

        s = NtClose(*Section);

        if(!NT_SUCCESS(s)) {
            DebugPrint1( LVL_VERBOSE, L"SfcMapEntireFile: Warning: status %lx from ZwClose on section handle", s );
        }

        return(Status);
    }

    return(STATUS_SUCCESS);
}


BOOL
SfcUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    )
/*++

Routine Description:

    Routine unmaps a memory mapped view of a file.

Arguments:

    Section  - handle to the mapped section object
    ViewBase - pointer to the base mapping address

Return Value:

    TRUE if we successfully cleaned up.

--*/
{
    NTSTATUS Status;
    BOOL  rc = TRUE;

    ASSERT( (Section != NULL) && (ViewBase != NULL) );

    Status = NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    if(!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_VERBOSE, L"Warning: status %lx from ZwUnmapViewOfSection", Status );
        rc = FALSE;
    }

    Status = NtClose(Section);
    if(!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_VERBOSE, L"Warning: status %lx from ZwClose on section handle", Status );
        rc = FALSE;
    }

    return(rc);
}


NTSTATUS
SfcDeleteFile(
    HANDLE DirHandle,
    PUNICODE_STRING FileName
    )
/*++

Routine Description:

    Routine deletes a file in the specified directory

Arguments:

    DirHandle - handle to the directory the file is present in
    FileName  - supplies filename of file to be deleted

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    FILE_DISPOSITION_INFORMATION Disposition;

    ASSERT(   (DirHandle != NULL)
           && (FileName != NULL)
           && (FileName->Buffer != NULL) );

    InitializeObjectAttributes(
        &ObjectAttributes,
        FileName,
        OBJ_CASE_INSENSITIVE,
        DirHandle,
        NULL
        );

    //
    // open a handle to the file
    //
    Status = NtOpenFile(
        &FileHandle,
        DELETE | FILE_READ_ATTRIBUTES,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Could not open file (%wZ), ec=%lx", FileName, Status );
        return Status;
    }

    //
    // undef DeleteFile so that DeleteFileW doesn't get in the way
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
        FileHandle,
        &IoStatusBlock,
        &Disposition,
        sizeof(Disposition),
        FileDispositionInformation
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Could not delete file (%wZ), ec=%lx", FileName, Status );
    }

    NtClose(FileHandle);
    return Status;
}


NTSTATUS
SfcRenameFile(
    HANDLE DirHandle,
    PUNICODE_STRING OldFileName,  // this file must exist
    PUNICODE_STRING NewFileName   // this file may exists, but it doesn't matter
    )
/*++

Routine Description:

    Routine renames a file in the specified directory

Arguments:

    DirHandle    - handle to the directory the file is present in
    OldFileName  - supplies filename of the source file to be renamed.
    NewFileName  - supplies filename of the destination filename

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    PFILE_RENAME_INFORMATION NewName;

    ASSERT( (DirHandle != NULL)
            && (OldFileName != NULL) && (OldFileName->Buffer != NULL)
            && (NewFileName != NULL) && (NewFileName->Buffer != NULL) );

	//
	// first of all, try to reset unwanted attributes on the new file
	// this could fail because the new file may not be there at all
	//
	InitializeObjectAttributes(
		&ObjectAttributes,
		NewFileName,
		OBJ_CASE_INSENSITIVE,
		DirHandle,
		NULL
		);

	Status = NtOpenFile(
		&FileHandle,
		FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
		&ObjectAttributes,
		&IoStatusBlock,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
		);

	if(NT_SUCCESS(Status))
	{
		FILE_BASIC_INFORMATION BasicInfo;
		RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));
		BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

		NtSetInformationFile(
			FileHandle,
			&IoStatusBlock,
			&BasicInfo,
			sizeof(BasicInfo),
			FileBasicInformation
			);

		NtClose(FileHandle);
	}

    InitializeObjectAttributes(
        &ObjectAttributes,
        OldFileName,
        OBJ_CASE_INSENSITIVE,
        DirHandle,
        NULL
        );

    //
    // open a handle to the file
    //
    Status = NtOpenFile(
        &FileHandle,
        FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Could not open file for rename (%wZ), ec=%lx", OldFileName, Status );
        return Status;
    }

    //
    // allocate and setup the rename structure
    //
    NewName = MemAlloc( NewFileName->Length+sizeof(*NewName));
    if (NewName != NULL) {

        NewName->ReplaceIfExists = TRUE;
        NewName->RootDirectory = DirHandle;
        NewName->FileNameLength = NewFileName->Length;

        RtlMoveMemory( NewName->FileName, NewFileName->Buffer, NewFileName->Length );

        //
        // do the rename
        //
        Status = NtSetInformationFile(
            FileHandle,
            &IoStatusBlock,
            NewName,
            NewFileName->Length+sizeof(*NewName),
            FileRenameInformation
            );

        if (!NT_SUCCESS(Status)) {
            DebugPrint3( LVL_VERBOSE, L"Could not rename file, ec=%lx, dll=(%wZ)(%wZ)", Status, OldFileName, NewFileName );
        }

        //
        // flush changes to disk so this is committed (at least on NTFS)
        //
        NtFlushBuffersFile( FileHandle, &IoStatusBlock );

        MemFree( NewName );
    } else {
        Status = STATUS_NO_MEMORY;
    }

    NtClose(FileHandle);
    return Status;
}


NTSTATUS
SfcMoveFileDelayed(
    IN PCWSTR OldFileNameDos,
    IN PCWSTR NewFileNameDos,
    IN BOOL AllowProtectedRename
    )

/*++

Routine Description:

    Appends the given delayed move file operation to the registry
    value that contains the list of move file operations to be
    performed on the next boot.

Arguments:

    OldFileName - Supplies the old file name

    NewFileName - Supplies the new file name

    AllowProtectedRename - if TRUE, allow the session manager to do the rename
                           of this file upon reboot even if it's a protected
                           file

Return Value:

    NTSTATUS code indicating outcome

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    HANDLE KeyHandle = NULL;
    PWSTR ValueData, s;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = NULL;
    ULONG ValueLength = 1024;
    ULONG ReturnedLength;
    NTSTATUS Status;
    NTSTATUS rVal = STATUS_SUCCESS;
    UNICODE_STRING OldFileName = {0};
    UNICODE_STRING NewFileName = {0};


    //
    // convert the file names
    //

    if (!RtlDosPathNameToNtPathName_U( OldFileNameDos, &OldFileName, NULL, NULL )) {
        DebugPrint1( LVL_VERBOSE, L"Unable to to convert %ws to an NT path", OldFileNameDos );
        rVal = STATUS_NO_MEMORY;
        goto exit;
    }
    if (NewFileNameDos) {
        if (!RtlDosPathNameToNtPathName_U( NewFileNameDos, &NewFileName, NULL, NULL )) {
            DebugPrint1( LVL_VERBOSE, L"Unable to to convert %ws to an NT path", NewFileNameDos );
            rVal = STATUS_NO_MEMORY;
            goto exit;
        }
    } else {
        RtlInitUnicodeString( &NewFileName, NULL );
    }

    //
    // open the registry
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );
    RtlInitUnicodeString( &ValueName, L"PendingFileRenameOperations" );
    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        (OBJ_OPENIF | OBJ_CASE_INSENSITIVE),
        NULL,
        NULL
        );

    Status = NtCreateKey(
        &KeyHandle,
        GENERIC_READ | GENERIC_WRITE,
        &Obja,
        0,
        NULL,
        0,
        NULL
        );
    if ( Status == STATUS_ACCESS_DENIED ) {
        Status = NtCreateKey(
            &KeyHandle,
            GENERIC_READ | GENERIC_WRITE,
            &Obja,
            0,
            NULL,
            REG_OPTION_BACKUP_RESTORE,
            NULL
            );
    }

    if (!NT_SUCCESS( Status )) {
        rVal = Status;
        goto exit;
    }

    //
    // retrieve the pending file rename registry key, allocating space until
    // we have enough to retrieve the data as well as our new strings
    //
    while (TRUE) {
        //
        // allocate space for old name + NULL + new name + NULL + 2 possible '@' chars
        //
        ValueInfo = MemAlloc(ValueLength + OldFileName.Length + NewFileName.Length + 4 * sizeof(WCHAR));
        if (ValueInfo == NULL) {
            NtClose(KeyHandle);
            rVal = STATUS_NO_MEMORY;
            goto exit;
        }

        //
        // File rename operations are stored in the registry in a
        // single MULTI_SZ value. This allows the renames to be
        // performed in the same order that they were originally
        // requested. Each rename operation consists of a pair of
        // NULL-terminated strings.
        //

        Status = NtQueryValueKey(KeyHandle,
            &ValueName,
            KeyValuePartialInformation,
            ValueInfo,
            ValueLength,
            &ReturnedLength
            );

        if (NT_SUCCESS(Status)) {
            break;
        }

        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        if (Status == STATUS_BUFFER_OVERFLOW) {
            ValueLength = ReturnedLength;
            MemFree( ValueInfo );
            ValueInfo = NULL;
        } else {
            //
            //  we failed for some other reason...bail out
            //
            break;
        }
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData = (PWSTR)ValueInfo;
    } else if (NT_SUCCESS(Status)) {
        ASSERT( ValueInfo->Type == REG_MULTI_SZ );
        //
        // A value already exists, append our two strings to the
        // MULTI_SZ.
        //
        // (note that the reg data is terminated with two NULLs, so
        // we subtract 1 from our pointer to account for that)
        //
        ValueData = (PWSTR)(&ValueInfo->Data);
        s = (PWSTR)((PCHAR)ValueData + ValueInfo->DataLength) - 1;
    } else {

        ASSERT(MemFree != NULL);

        rVal = Status;
        goto exit;
    }

    ASSERT( s != NULL );

    //
    // session manager recognizes this screwy syntax whereby if you set an "@"
    // in front of the source filename, it always allows the rename to occur.
    //
    // the pair of values are NULL separated and terminates in two NULL
    // characters
    //
    //
    if (AllowProtectedRename) {
        wcscpy( s, L"@" );
        s += 1;
    }
    CopyMemory(s, OldFileName.Buffer, OldFileName.Length);
    s += (OldFileName.Length/sizeof(WCHAR));
    *s++ = L'\0';

    if (AllowProtectedRename && NewFileName.Length) {
        wcscpy( s, L"@" );
        s += 1;
    }
    CopyMemory(s, NewFileName.Buffer, NewFileName.Length);
    s += (NewFileName.Length/sizeof(WCHAR));
    *s++ = L'\0';
    *s++ = L'\0';

    //
    // set the registry key
    //
    Status = NtSetValueKey(
        KeyHandle,
        &ValueName,
        0,
        REG_MULTI_SZ,
        ValueData,
        (ULONG)((s-ValueData)*sizeof(WCHAR))
        );
    rVal = Status;

exit:
    if (OldFileName.Length) {
        RtlFreeUnicodeString(&OldFileName);
    }
    if (NewFileName.Length) {
        RtlFreeUnicodeString(&NewFileName);
    }
    if (KeyHandle) {
        NtClose(KeyHandle);
    }
    if (ValueInfo) {
        MemFree( ValueInfo );
    }
    return rVal;
}


#if 0
DWORD
RetrieveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    Retreive security information from a file and place it into a buffer.

Arguments:

    FileName - supplies name of file whose security information is desired.

    SecurityDescriptor - If the function is successful, receives pointer
        to buffer containing security information for the file. The pointer
        may be NULL, indicating that there is no security information
        associated with the file or that the underlying filesystem does not
        support file security.

Return Value:

    Win32 error code indicating outcome. If ERROR_SUCCESS check the value returned
    in SecurityDescriptor.

    The caller can free the buffer with MemFree() when done with it.

--*/

{
    BOOL b;
    DWORD d;
    DWORD BytesRequired;
    PSECURITY_DESCRIPTOR p;



    BytesRequired = 1024;

    while (TRUE) {

        //
        // Allocate a buffer of the required size.
        //
        p = MemAlloc(BytesRequired);
        if(!p) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Get the security.
        //
        b = GetFileSecurity(
                FileName,
                SECURITY_FLAGS,
                p,
                BytesRequired,
                &BytesRequired
                );

        //
        // Return with sucess
        //
        if(b) {
            *SecurityDescriptor = p;
            return(ERROR_SUCCESS);
        }

        //
        // Return an error code, unless we just need a bigger buffer
        //
        MemFree(p);
        d = GetLastError();
        if(d != ERROR_INSUFFICIENT_BUFFER) {
            return (d);
        }

        //
        // There's a bug in GetFileSecurity that can cause it to ask for a
        // REALLY big buffer.  In that case, we return an error.
        //
        if (BytesRequired > 0xF0000000) {
            return (ERROR_INVALID_DATA);
        }

        //
        // Otherwise, we'll try again with a bigger buffer
        //
    }
}
#endif


NTSTATUS
SfcCopyFile(
    IN HANDLE SrcDirHandle,
    IN PCWSTR SrcDirName,
    IN HANDLE DstDirHandle,
    IN PCWSTR DstDirName,
    IN const PUNICODE_STRING FileName,
    IN const PUNICODE_STRING SourceFileNameIn OPTIONAL
    )

/*++

Routine Description:

    Copy a file from the source to the destination.  Since we are running
    in SMSS, we cannot use CopyFile.

Arguments:

    SrcDirHandle - handle to source directory where file exists

    DstDirHandle - handle to destination directory where file will be placed

    FileName - UNICODE_STRING of relative name of file to be copied

Return Value:

    NTSTATUS code of any fatal error.

--*/


{
    NTSTATUS Status,DeleteStatus;
    HANDLE SrcFileHandle;
    HANDLE DstFileHandle;
    HANDLE SectionHandle;
    PVOID ImageBase;
    ULONG remainingLength;
    ULONG writeLength;
    PUCHAR base;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER FileOffset;
    WCHAR TmpNameBuffer[MAX_PATH];
    WCHAR Tmp2NameBuffer[MAX_PATH];
    UNICODE_STRING TmpName;
    UNICODE_STRING Tmp2Name;
    OBJECT_ATTRIBUTES ObjectAttributes;
    FILE_STANDARD_INFORMATION StandardInfo;
    FILE_BASIC_INFORMATION BasicInfo;
    SIZE_T ViewSize;
    PUNICODE_STRING SourceFileName;


    SourceFileName = (SourceFileNameIn) ? SourceFileNameIn : FileName;

    ASSERT(SourceFileName != NULL);

    //
    // open & map the source file
    //

    Status = SfcOpenFile( SourceFileName, SrcDirHandle, SHARE_ALL, &SrcFileHandle );
    if(!NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = SfcMapEntireFile( SrcFileHandle, &SectionHandle, &ImageBase, &ViewSize );
    if(!NT_SUCCESS(Status) ) {
        NtClose( SrcFileHandle );
        return Status;
    }

    Status = NtQueryInformationFile(
        SrcFileHandle,
        &IoStatusBlock,
        &StandardInfo,
        sizeof(StandardInfo),
        FileStandardInformation
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_VERBOSE, L"QueryInfoFile status %lx", Status );
        SfcUnmapFile( SectionHandle, ImageBase );
        NtClose( SrcFileHandle );
        return Status;
    }

    Status = NtQueryInformationFile(
        SrcFileHandle,
        &IoStatusBlock,
        &BasicInfo,
        sizeof(BasicInfo),
        FileBasicInformation
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint1( LVL_VERBOSE, L"QueryInfoFile status %lx", Status );
        SfcUnmapFile( SectionHandle, ImageBase );
        NtClose( SrcFileHandle );
        return Status;
    }

    //
    // create the temp file name
    //

    TmpName.MaximumLength = sizeof(TmpNameBuffer);
    TmpName.Buffer = TmpNameBuffer;
    RtlZeroMemory( TmpName.Buffer, TmpName.MaximumLength );
    RtlCopyMemory( TmpName.Buffer, FileName->Buffer, FileName->Length );
    wcscat( TmpName.Buffer, L".new" );
    TmpName.Length = UnicodeLen(TmpName.Buffer);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TmpName,
        OBJ_CASE_INSENSITIVE,
        DstDirHandle,
        NULL
        );

    BasicInfo.FileAttributes &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN);
    Status = NtCreateFile(
        &DstFileHandle,
        (ACCESS_MASK)(DELETE | SYNCHRONIZE | GENERIC_WRITE | FILE_WRITE_ATTRIBUTES),
        &ObjectAttributes,
        &IoStatusBlock,
        &StandardInfo.EndOfFile,
        BasicInfo.FileAttributes ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY | FILE_OPEN_FOR_BACKUP_INTENT,
        NULL,
        0
        );
    if(!NT_SUCCESS(Status) ) {
        DebugPrint2( LVL_VERBOSE, L"Unable to create temp file (%wZ) - Status == %lx", &TmpName, Status );
        SfcUnmapFile( SectionHandle, ImageBase );
        NtClose( SrcFileHandle );
        return Status;
    }

    //
    // copy the bits
    //
    // guard the write with a try/except because if there is an i/o error,
    // memory management will raise an in-page exception.
    //

    FileOffset.QuadPart = 0;
    base = ImageBase;
    remainingLength = StandardInfo.EndOfFile.LowPart;

    try {
        while (remainingLength != 0) {
            writeLength = 60 * 1024;
            if (writeLength > remainingLength) {
                writeLength = remainingLength;
            }
            Status = NtWriteFile(
                DstFileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                base,
                writeLength,
                &FileOffset,
                NULL
                );
            base += writeLength;
            FileOffset.LowPart += writeLength;
            remainingLength -= writeLength;
            if (!NT_SUCCESS(Status)) {
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = STATUS_IN_PAGE_ERROR;
    }

    if (NT_SUCCESS(Status)) {
        Status = NtSetInformationFile(
            DstFileHandle,
            &IoStatusBlock,
            &BasicInfo,
            sizeof(BasicInfo),
            FileBasicInformation
            );
        if (!NT_SUCCESS(Status)) {
            DebugPrint2( LVL_VERBOSE, L"Could not set file information for (%wZ), ec=%lx", &TmpName, Status );
        }
    }

#if 0
    if (NT_SUCCESS(Status) && SrcDirName) {
        PSECURITY_DESCRIPTOR SecurityDescriptor;

        wcscpy( Tmp2NameBuffer, SrcDirName );
        pSetupConcatenatePaths( Tmp2NameBuffer, FileName->Buffer, UnicodeChars(Tmp2NameBuffer), NULL );
        if (RetrieveFileSecurity( Tmp2NameBuffer, &SecurityDescriptor ) == ERROR_SUCCESS) {
            SetFileSecurity(
                TmpName.Buffer,
                SECURITY_FLAGS,
                SecurityDescriptor
                );
            MemFree( SecurityDescriptor );
        }
    }
#endif

    SfcUnmapFile( SectionHandle, ImageBase );


    NtClose( SrcFileHandle );
    NtClose( DstFileHandle );

    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_VERBOSE, L"Could not copy file, ec=%lx, dll=%wZ", Status, &TmpName );
        NtDeleteFile( &ObjectAttributes );
        return Status;
    }

    //
    // attempt to rename the new (.new) file to the
    // destination file name.  in most cases this will
    // work, but it will fail when the destination file
    // is in use.
    //

    Status = SfcRenameFile( DstDirHandle, &TmpName, FileName );
    if (NT_SUCCESS(Status) ) {
        return Status;
    } else {
        DebugPrint2( LVL_VERBOSE, L"Could not rename file, ec=%lx, dll=%wZ", Status, &TmpName );
    }

    //
    // the rename failed so it must be in use
    //

    Tmp2Name.MaximumLength = sizeof(Tmp2NameBuffer);
    Tmp2Name.Buffer = Tmp2NameBuffer;
    RtlZeroMemory( Tmp2Name.Buffer, Tmp2Name.MaximumLength );
    RtlCopyMemory( Tmp2Name.Buffer, FileName->Buffer, FileName->Length );
    wcscat( Tmp2Name.Buffer, L".tmp" );
    Tmp2Name.Length = UnicodeLen(Tmp2Name.Buffer);

    Status = SfcRenameFile( DstDirHandle, FileName, &Tmp2Name );
    if(!NT_SUCCESS(Status) ) {
        DebugPrint2( LVL_VERBOSE, L"Could not rename file, ec=%lx, dll=%wZ", Status, &Tmp2Name );
        NtDeleteFile( &ObjectAttributes );
        return Status;
    }

    Status = SfcRenameFile( DstDirHandle, &TmpName, FileName );
    if(!NT_SUCCESS(Status) ) {
        DebugPrint2( LVL_VERBOSE, L"Could not rename file, ec=%lx, dll=%wZ", Status, &Tmp2Name );
        Status = SfcRenameFile( DstDirHandle, &Tmp2Name, FileName );
        if(!NT_SUCCESS(Status) ) {
            DebugPrint2( LVL_VERBOSE, L"Could not rename file, ec=%lx, dll=%wZ", Status, &Tmp2Name );
            NtDeleteFile( &ObjectAttributes );
            return Status;
        }
        NtDeleteFile( &ObjectAttributes );
        return Status;
    }

    DeleteStatus = SfcDeleteFile( DstDirHandle, &Tmp2Name );
    if (!NT_SUCCESS(DeleteStatus) && DstDirName) {
        wcscpy( TmpNameBuffer, L"@" );
        wcscat( TmpNameBuffer, DstDirName );
        wcscat( TmpNameBuffer, L"\\" );
        wcscat( TmpNameBuffer, Tmp2NameBuffer );
        Status = SfcMoveFileDelayed( TmpNameBuffer, NULL, TRUE );
        return Status;
    }

    return Status;
}


BOOL
SfcGetCdRomDrivePath(
    IN PWSTR CdRomPath
    )
/*++

Routine Description:

    Finds the first CDROM on your machine.  Cycles through the drive letters
    until it finds a drive that's a CDROM.

Arguments:

    CdRomPath - buffer to receive CDROM path.  Assumes that this buffer is at
                least 8 characters big

Return Value:

    TRUE if we found a CD-ROM

Note that this routine always returns back the first CD-ROM

--*/
{
    int i;
    WCHAR Path[8];

    ASSERT( CdRomPath != NULL );

    CdRomPath[0] = 0;
    for (i=0; i<26; i++) {
        swprintf( Path, L"%c:\\", L'a'+i );
        if (GetDriveType( Path ) == DRIVE_CDROM) {
            wcsncpy( CdRomPath, Path, UnicodeChars(Path) );
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
SfcIsFileOnMedia(
    IN PCWSTR FileName
    )
/*++

Routine Description:

    checks if the specified file exists.  Used to verify that a file present
    on our media or if it's also compressed on our media.

Arguments:

    FileName - specifies the filename to look for

Return Value:

    TRUE if the file is present.

--*/
{
    PWSTR CompressedName;
    DWORD dwTemp1, dwTemp2;
    UINT uiTemp1;

    //
    // this does exactly what we want...look for file.??? and file.??_
    //
    if (SetupGetFileCompressionInfo(
                            FileName,
                            &CompressedName,
                            &dwTemp1,
                            &dwTemp2,
                            &uiTemp1 ) == ERROR_SUCCESS) {
        LocalFree(CompressedName);
        return TRUE;
    }
    return FALSE;
}


DWORD
SfcGetPathType(
    IN PCWSTR Path,
    OUT PWSTR NewPath,
    IN DWORD NewPathSize
    )
/*++

Routine Description:

    Determines the type of drive specified.  If the drive is a drive letter and
    it's a remote drive, we will retrieve the UNC pathname of that drive.

Arguments:

    Path    - contains the path to check.
    NewPath - if a remote path (DRIVE_REMOTE), this receives the UNC pathname
              of that drive.  otherwise, this will receive the original path
              on success.
    NewPathSize - size in characters of NewPath buffer.

Return Value:

    returns a PATH_ constant similar to a DRIVE_ constant

--*/
{
    WCHAR buf[MAX_PATH*2];
    DWORD DriveType;
    WCHAR MyPath[4];

    ASSERT(Path != NULL && Path[0] != 0);

    if (Path[0] == L'\\' && Path[1] == L'\\') {
        if (wcslen(Path)+1 > NewPathSize) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(PATH_INVALID);
        }
        wcsncpy(NewPath,Path,NewPathSize);
        return PATH_UNC;
    }

    //
    // Get the path right.
    //
    MyPath[0] = Path[0];
    MyPath[1] = L':';
    MyPath[2] = L'\\';
    MyPath[3] = L'\0';


    DriveType = GetDriveType( MyPath );
    switch (DriveType) {
        case DRIVE_REMOTE:
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
            if(SfcGetConnectionName(Path, buf, UnicodeChars(buf), NULL, 0, FALSE, NULL)) {
                if (wcslen(buf) + 1 > NewPathSize) {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return(PATH_INVALID);
                }
                wcsncpy(NewPath, buf, NewPathSize );
                return PATH_NETWORK;
            } else {
                DebugPrint1( LVL_VERBOSE, L"SfcGetConnectionName [%ws] failed", Path );
                if (wcslen(Path)+1 > NewPathSize) {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return(PATH_INVALID);
                }
                wcsncpy( NewPath, Path, NewPathSize );
                return PATH_LOCAL;
            }
            ASSERT(FALSE && "Should never get here");
            break;

        case DRIVE_CDROM:
            if (wcslen(Path)+1 > NewPathSize) {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return(PATH_INVALID);
            }
            wcsncpy( NewPath, Path, NewPathSize );
            return PATH_CDROM;

        default:
            break;
    }

    if (wcslen(Path)+1 > NewPathSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(PATH_INVALID);
    }
    wcsncpy( NewPath, Path, NewPathSize );
    return PATH_LOCAL;
}


BOOL
SfcGetConnectionName(
    IN  PCWSTR Path,
    OUT PWSTR ConnectionName,
    IN  DWORD ConnectionBufferSize,
    OUT PWSTR RemainingPath OPTIONAL,
    IN  DWORD RemainingPathSize OPTIONAL,
    IN BOOL KeepImpersonating,
    OUT PBOOL Impersonating OPTIONAL
    )
/*++

Routine Description:

    Given a path, get the name of the UNC connection path which corresponds to
    this path.  Assumes that the path is a remote path.

Arguments:

    Path           - contains the path to parse
    ConnectionName - receives the UNC share that corresponds to the given path
    ConnectionBufferSize - size of ConnectionName buffer in characters

Return Value:

    TRUE indicates success, in which case ConnectionName will contain the UNC
    path

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR buf[MAX_PATH*2];
    PWSTR szConnection = NULL;
    PWSTR szRemaining = NULL;
    DWORD Size;

    if(ConnectionName != NULL && ConnectionBufferSize != 0) {
        ConnectionName[0] = 0;
    }

    if(RemainingPath != NULL && RemainingPathSize != 0) {
        RemainingPath[0] = 0;
    }

    if(Impersonating != NULL) {
        *Impersonating = FALSE;
    }

    if(NULL == Path || 0 == Path[0] || NULL == ConnectionName || 0 == ConnectionBufferSize || (KeepImpersonating && NULL == Impersonating)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // if we have a UNC path just use it
    //
    if (Path[0] == L'\\' && Path[1] == L'\\') {

        //
        // a UNC path always looks lke \\server\share\otherstuff, so it's
        // easy to parse it
        //
        lstrcpyn( buf, Path, UnicodeChars(buf) );
        //
        // find first '\' after '\\'
        //
        szRemaining = wcschr( &buf[2], L'\\' );
        
        if(szRemaining != NULL) {
            //
            // find next '\'  and NULL it out
            //
            szRemaining = wcschr(szRemaining + 1, L'\\');

            if(szRemaining != NULL) {
                *szRemaining++ = 0;
            }
        } else {
            DebugPrint1( LVL_VERBOSE, L"screwy UNC path [%ws] ", buf );
            ASSERT(FALSE);
        }

        szConnection = buf;
    } else {
        //
        // bummer, have to translate the driver letter into a full path name
        //
        REMOTE_NAME_INFO *rni = (REMOTE_NAME_INFO*)buf;
        Size = sizeof(buf);
        dwError = WNetGetUniversalName(Path, REMOTE_NAME_INFO_LEVEL, (LPVOID) rni, &Size);

        if((ERROR_BAD_DEVICE == dwError || ERROR_CONNECTION_UNAVAIL == dwError || 
            ERROR_NO_NET_OR_BAD_PATH == dwError || ERROR_NOT_CONNECTED == dwError) && 
            hUserToken != NULL && ImpersonateLoggedOnUser(hUserToken)) {
            //
            // This might make sense only in the logged-on user context
            //
            Size = sizeof(buf);
            dwError = WNetGetUniversalName(Path, REMOTE_NAME_INFO_LEVEL, (LPVOID) rni, &Size);

            if(KeepImpersonating && ERROR_SUCCESS == dwError) {
                *Impersonating = TRUE;
            } else {
                RevertToSelf();
            }
        }

        if(ERROR_SUCCESS == dwError) {
            szConnection = rni->lpConnectionName;
            szRemaining = rni->lpRemainingPath;
        }
    }

    if(dwError != ERROR_SUCCESS) {
        SetLastError(dwError);
        return FALSE;
    }

    ASSERT(szConnection != NULL);
    Size = wcslen(szConnection) + 1;

    if(Size > ConnectionBufferSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    RtlCopyMemory(ConnectionName, szConnection, Size * sizeof(WCHAR));

    if(RemainingPath != NULL && RemainingPathSize != 0 && szRemaining != NULL && szRemaining[0] != 0) {
        lstrcpyn(RemainingPath, szRemaining, RemainingPathSize);
    }

    return TRUE;
}


PCWSTR
IsFileInDriverCache(
    IN PCWSTR TargetFilename
    )
/*++

Routine Description:

    Routine determines if a file is in the local driver cache.  It does this by
    reading the inf file "drvindex.inf", which lists all of the files that
    reside in the driver cache.

    This code is lifted from setupapi's implementation.

Arguments:

    TargetFileName - contains the filename of the file to query.


Return Value:

    If the file is in the driver cache, the function returns the name of
    the cabfile which the file resides in, otherwise the function returns NULL.

--*/
{
    HINF CabInf;
    INFCONTEXT Context;
    INFCONTEXT SectionContext;
    WCHAR InfName[MAX_PATH];
    WCHAR SectionName[128];
    WCHAR CabName[128];
    UINT Field;
    UINT FieldCount;
    BOOL b;
    PCWSTR CacheName = NULL;

    ASSERT(TargetFilename != NULL);

    //
    // open up the driver index file which will tell us what we need to know.
    //
    wcscpy( InfName, InfDirectory );
    pSetupConcatenatePaths( InfName, L"drvindex.inf", UnicodeChars(InfName), NULL );

    CabInf = SetupOpenInfFile( InfName, NULL, INF_STYLE_WIN4, NULL );
    if (CabInf == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //
    // get the cabfiles line, which contains a list of section names we must
    // search for the file in.
    //
    if (!SetupFindFirstLine( CabInf, L"Version", L"CabFiles", &SectionContext )) {
        SetupCloseInfFile( CabInf );
        return NULL;
    }

    do  {
        //
        // each field in the CabFilesLine corresponds to a section name
        //
        FieldCount = SetupGetFieldCount( &SectionContext );
        for(Field=1; Field<=FieldCount; Field++) {
            b = SetupGetStringField( &SectionContext, Field, SectionName, UnicodeChars(SectionName), NULL );
            //
            // look for the file in this section
            //
            if (b && SetupFindFirstLine( CabInf, SectionName, TargetFilename, &Context )) {
                //
                // if we found the file in this section it must be in the
                // driver cache.  Now look in the "Cabs" section for a line
                // that corresponds to the section name, which contains the
                // actual cabfile name
                //
                if (SetupFindFirstLine( CabInf, L"Cabs", SectionName, &Context )) {
                    //
                    // now get that name, allocate and copy into a buffer and
                    // return
                    //
                    b = SetupGetStringField( &Context, 1, CabName, UnicodeChars(CabName), NULL );
                    if (b) {
                        CacheName = MemAlloc(  UnicodeLen(CabName) + 8 );
                        if (CacheName) {
                            wcscpy( (PWSTR)CacheName, CabName );
                            SetupCloseInfFile( CabInf );
                            return CacheName;
                        }
                    }
                }
            }
        }

    } while (SetupFindNextMatchLine( &SectionContext, L"CabFiles", &SectionContext ));

    SetupCloseInfFile( CabInf );
    return NULL;
}

DWORD
SfcQueueLookForFile(
    IN const PSOURCE_MEDIA sm,
    IN const PSOURCE_INFO si,
    IN PCWSTR fname,
    OUT PWSTR NewPath
    )
/*++

Routine Description:

    Routine looks for the specified file.  If the file isn't
    at the specified location, we start looking around for the file.

    We look on the cdrom and the network location if present.  If we
    don't find it there, then we strip off the platform extension as
    a hack workaround for broken release servers that don't match what
    layout.inf says about the source layout information

Arguments:

    sm      - pointer to SOURCE_MEDIA structure which desribes the media the
              file should be on
    si      - pointer to a SOURCE_INFO structure which describes the media the
              file should be on
    fname   - the full pathname to the file we're looking for
    NewPath - if we find the file somewhere else besides the actual media
              path, this is filled in with the correct path

Return Value:

    returns a FILEOP_* setupapi code

--*/
{
    DWORD PathType;
    WCHAR buf[MAX_PATH];
    WCHAR cdrom[16];
    PWSTR s;
    BOOL  CDRomIsPresent;

    ASSERT(fname != NULL);
    ASSERT((sm != NULL) && (si != NULL));

    //
    // first look to see if the file is on the specified media
    //
    if (SfcIsFileOnMedia( fname )) {
        return FILEOP_DOIT;
    }

    //
    // get the (first) cdrom drive path
    //
    CDRomIsPresent = SfcGetCdRomDrivePath( cdrom );

    //
    // get the path type for the specified source path
    //
    PathType = SfcGetPathType( (PWSTR)sm->SourcePath, buf,UnicodeChars(buf) );

    //
    // ok the file is not on the specified media, but it
    // could be located in a cab file.  the tag file *MAY*
    // contain the cab file name so check to see if the tag file
    // name is a cab file and then look to see if the cab is
    // present.
    //
    if (sm->Tagfile) {
        s = wcsrchr( sm->Tagfile, L'.' );
        if (s && _wcsicmp( s, L".cab" ) == 0) {
            BuildPathForFile(
                    sm->SourcePath,
                    NULL,
                    sm->Tagfile,
                    SFC_INCLUDE_SUBDIRECTORY,
                    SFC_INCLUDE_ARCHSUBDIR,
                    buf,
                    UnicodeChars(buf) );

            if (SfcIsFileOnMedia( buf )) {
                return FILEOP_DOIT;
            }
            if (PathType == PATH_NETWORK || PathType == PATH_UNC) {
                //
                // try removing the platform dir from the path
                // as a helper for the internal msft build servers
                //
                wcscpy( buf, sm->SourcePath );
                s = wcsrchr( buf, L'\\' );
                if (s && _wcsicmp(s,PLATFORM_DIR)==0) {
                    *s = 0;
                    pSetupConcatenatePaths( buf, sm->Tagfile, UnicodeChars(buf), NULL );
                    if (SfcIsFileOnMedia( buf )) {
                        wcscpy( NewPath, sm->SourcePath );
                        s = wcsrchr( NewPath, L'\\' );
                        *s = 0;
                        return FILEOP_NEWPATH;
                    }
                }

                //
                // the cab file is not on the specified network
                // source path so now look on the cdrom
                //
                if (CDRomIsPresent) {

                    BuildPathForFile(
                            cdrom,
                            si->SourcePath,
                            sm->Tagfile,
                            SFC_INCLUDE_SUBDIRECTORY,
                            SFC_INCLUDE_ARCHSUBDIR,
                            buf,
                            UnicodeChars(buf) );

                    if (SfcIsFileOnMedia( buf )) {
                        wcscpy( NewPath, buf );
                        pSetupConcatenatePaths( NewPath, si->SourcePath, MAX_PATH , NULL );
                        return FILEOP_NEWPATH;
                    }
                }
            }
        }
    }

    //
    // the file is not located in a cab file and it is not
    // present on the specified meda.  if the media
    // is a network share then look on the cd for the file.
    //
    if (PathType == PATH_NETWORK || PathType == PATH_UNC) {
        //
        // try removing the platform dir from the path
        // as a helper for the internal msft build servers
        //
        wcscpy( buf, sm->SourcePath );
        s = wcsrchr( buf, L'\\' );
        if (s && _wcsicmp(s,PLATFORM_DIR)==0) {
            *s = 0;
            pSetupConcatenatePaths( buf, sm->SourceFile, UnicodeChars(buf), NULL );
            if (SfcIsFileOnMedia( buf )) {
                wcscpy( NewPath, sm->SourcePath );
                s = wcsrchr( NewPath, L'\\' );
                *s = 0;
                return FILEOP_NEWPATH;
            }
        }
    }

    //
    // now try the cdrom
    //
    if (CDRomIsPresent) {

        BuildPathForFile(
                cdrom,
                si->SourcePath,
                sm->SourceFile,
                SFC_INCLUDE_SUBDIRECTORY,
                SFC_INCLUDE_ARCHSUBDIR,
                buf,
                UnicodeChars(buf) );

        if (SfcIsFileOnMedia( buf )) {
            wcscpy( NewPath, cdrom );
            pSetupConcatenatePaths( NewPath, si->SourcePath, MAX_PATH, NULL );
            return FILEOP_NEWPATH;
        }
    }

    return FILEOP_ABORT;
}

HINF
SfcOpenInf(
    IN PCWSTR InfName OPTIONAL,
    IN BOOL ExcepPackInf
    )
/*++

Routine Description:

    Routine opens the specified INF file.  We also appendload any INFs to this
    INF so we have all of the necessary layout information.

Arguments:

    InfName - Specifies the inf to open.  If no inf is specified, we just use
              the os layout file "layout.inf"

Return Value:

    a valid inf handle on success, else INVALID_HANDLE_VALUE

--*/
{
    HINF hInf = INVALID_HANDLE_VALUE;
    WCHAR SourcePath[MAX_PATH];
    PCWSTR InfPath = InfName;

    if (InfName && *InfName) {
        //
        // if this is an exception inf, InfName is a full path so leave it unchanged
        //
        if(!ExcepPackInf)
        {
            InfPath = SourcePath;
            wcscpy( SourcePath, InfDirectory );
            pSetupConcatenatePaths( SourcePath, InfName, UnicodeChars(SourcePath), NULL );
            if (GetFileAttributes( SourcePath ) == (DWORD)-1) {
                DWORD dwSize = ExpandEnvironmentStrings( L"%systemroot%\\system32", SourcePath, UnicodeChars(SourcePath) );

                if(0 == dwSize) {
                    return INVALID_HANDLE_VALUE;
                }

                if(dwSize > UnicodeChars(SourcePath)) {
                    SetLastError(ERROR_BUFFER_OVERFLOW);
                    return INVALID_HANDLE_VALUE;
                }

                pSetupConcatenatePaths( SourcePath, InfName, UnicodeChars(SourcePath), NULL );
                if (GetFileAttributes( SourcePath ) == (DWORD)-1) {
                    DebugPrint1( LVL_VERBOSE, L"Required inf missing [%ws]", SourcePath );
                    return INVALID_HANDLE_VALUE;
                }
            }
        }

        hInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
        if (hInf == INVALID_HANDLE_VALUE) {
            DebugPrint2( LVL_VERBOSE, L"SetupOpenInf failed [%ws], ec=%d", InfPath, GetLastError() );
            return INVALID_HANDLE_VALUE;
        }

        //
        // append-load layout.inf or whatever other layout file the inf wants
        // to load.  if this fails it's no big deal, the inf might not have a
        // layout file for instance.
        //
        if (!SetupOpenAppendInfFile( NULL, hInf, NULL)) {
            DebugPrint2( LVL_VERBOSE, L"SetupOpenAppendInfFile failed [%ws], ec=%d", InfPath, GetLastError() );
        }
    } else {
        wcscpy( SourcePath, InfDirectory );
        pSetupConcatenatePaths( SourcePath, L"layout.inf", UnicodeChars(SourcePath), NULL );
        hInf = SetupOpenInfFile( SourcePath, NULL, INF_STYLE_WIN4, NULL );
        if (hInf == INVALID_HANDLE_VALUE) {
            DebugPrint2( LVL_VERBOSE, L"SetupOpenInf failed [%ws], ec=%d", SourcePath, GetLastError() );
            return INVALID_HANDLE_VALUE;
        }
    }

    //
    // Note: major hack-o-rama.  Some infs use "34000" and "34001" custom
    // directory ids for the relative source path on x86, so that it
    // resolves to nec98 or i386 at runtime.  we emulate the same thing
    // here.  If some inf tries to copy to custom dirid 34000 or 34001 then
    // we're busted.  It would be a better solution to record these layout infs
    // and their custom dirid mappings so we only set this for the infs we care
    // about and so that we handle any other infs that come up with some other
    // wacky convention without having to rebuild this module.
    //

    SetupSetDirectoryIdEx( hInf, 34000, PLATFORM_DIR, SETDIRID_NOT_FULL_PATH, 0, 0 );
    SetupSetDirectoryIdEx( hInf, 34001, PLATFORM_DIR, SETDIRID_NOT_FULL_PATH, 0, 0 );

    return hInf;
}

BOOL
SfcGetSourceInformation(
    IN PCWSTR SourceFileName,
    IN PCWSTR InfName,  OPTIONAL
    IN BOOL ExcepPackFile,
    OUT PSOURCE_INFO si
    )
/*++

Routine Description:

    Routine retrieves information about a source file and stuffs it into the
    supplied SOURCE_INFO structure.

    Routine opens up a handle to the source's layout file and retreives layout
    information from this inf.

Arguments:

    SourceFileName - specifies the file to retreive source information for.
                     Note that if this file is renamed, we have the source
                     filename, not the destination filename.
    InfName        - specifies the layout file for the SourceFileName. If NULL,
                     assume that the layout file is layout.inf.
    si             - pointer to SOURCE_INFO structure that gets filled in with
                     information about the specified file.

Return Value:

    if TRUE, we successfully retrieved the source information about this file

--*/
{
    BOOL b = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    PCWSTR DriverCabName = NULL;
    WCHAR SetupAPIFlags[32];

    ASSERT((si != NULL) && (SourceFileName != NULL));

    //
    // if an exception file, the inf name must not be empty as we need it for the source path
    //
    ASSERT(!ExcepPackFile || (InfName != NULL && *InfName != 0));

    wcsncpy(si->SourceFileName, SourceFileName, MAX_PATH);

    //
    // open the necessary inf file
    //
    hInf = SfcOpenInf( InfName, ExcepPackFile );
    if (hInf == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    //
    // get the source file location
    //

    b = SetupGetSourceFileLocation(
        hInf,
        NULL,
        SourceFileName,
        &si->SourceId,
        NULL,
        0,
        NULL
        );

    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupGetSourceFileLocation failed, ec=%d", GetLastError() );
        goto exit;
    }

    //
    // get the following source file information:
    //     1)  path
    //     2)  tag file name
    //     3)  flags
    //     4)  description (for display to the user if necessary)
    //

    b = SetupGetSourceInfo(
        hInf,
        si->SourceId,
        SRCINFO_PATH,
        si->SourcePath,
        UnicodeChars(si->SourcePath),
        NULL
        );
    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupGetSourceInfo failed, ec=%d", GetLastError() );
        goto exit;
    }

    b = SetupGetSourceInfo(
        hInf,
        si->SourceId,
        SRCINFO_TAGFILE,
        si->TagFile,
        UnicodeChars(si->TagFile),
        NULL
        );
    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupGetSourceInfo failed, ec=%d", GetLastError() );
        goto exit;
    }

    b = SetupGetSourceInfo(
        hInf,
        si->SourceId,
        SRCINFO_DESCRIPTION,
        si->Description,
        UnicodeChars(si->Description),
        NULL
        );
    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupGetSourceInfo failed, ec=%d", GetLastError() );
        goto exit;
    }

    b = SetupGetSourceInfo(
        hInf,
        si->SourceId,
        SRCINFO_FLAGS,
        SetupAPIFlags,
        UnicodeChars(SetupAPIFlags),
        NULL
        );
    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupGetSourceInfo failed, ec=%d", GetLastError() );
        goto exit;
    }

    si->SetupAPIFlags = wcstoul(SetupAPIFlags, NULL, 0);

    //
    // set the source root path
    //
    if(!ExcepPackFile)
    {
        DriverCabName = IsFileInDriverCache( SourceFileName );
    }

    if (DriverCabName) {
        si->Flags |= SI_FLAG_USEDRIVER_CACHE;
        wcscpy( si->DriverCabName, DriverCabName );

        //
        // build up the full path to the driver cabinet file
        //
        BuildPathForFile(
                DriverCacheSourcePath,
                PLATFORM_DIR,
                DriverCabName,
                SFC_INCLUDE_SUBDIRECTORY,
                SFC_INCLUDE_ARCHSUBDIR,
                si->SourceRootPath,
                UnicodeChars(si->SourceRootPath) );

        //
        // If the cabinet isn't present, we must use the os source path for the
        // cabinet file.  We first try the service pack source path and look
        // for the cabfile there.  If it's there, we use that path, else we
        // use the OS Source Path.
        //
        if (GetFileAttributes( si->SourceRootPath ) == (DWORD)-1) {
            SfcGetSourcePath(TRUE,si->SourceRootPath);
            pSetupConcatenatePaths(
                si->SourceRootPath,
                DriverCabName,
                UnicodeChars(si->SourceRootPath),
                NULL );
            if (GetFileAttributes( si->SourceRootPath ) == (DWORD)-1) {
                SfcGetSourcePath(FALSE,si->SourceRootPath);
            } else {
                SfcGetSourcePath(TRUE,si->SourceRootPath);
            }
        } else {
            wcsncpy(
                si->SourceRootPath,
                DriverCacheSourcePath,
                UnicodeChars(si->SourceRootPath) );
        }

        MemFree( (PWSTR)DriverCabName );
        DriverCabName = NULL;
    } else if(ExcepPackFile) {
        PCWSTR sz;

        sz = wcsrchr(InfName, L'\\');
        ASSERT(sz != NULL);
        RtlCopyMemory(si->SourceRootPath, InfName, (PBYTE) sz - (PBYTE) InfName);
        si->SourceRootPath[sz - InfName] = 0;
    } else {
        SfcGetSourcePath((si->SetupAPIFlags & 1) != 0, si->SourceRootPath);
    }

    b = TRUE;

exit:
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile( hInf );
    }
    return b;
}

#define SFC_BAD_CREDENTIALS(rc)                                                                             \
    ((rc) == ERROR_ACCESS_DENIED || (rc) == ERROR_LOGON_FAILURE || (rc) == ERROR_NO_SUCH_USER ||            \
    (rc) == ERROR_BAD_USERNAME || (rc) == ERROR_INVALID_PASSWORD || (rc) == ERROR_NO_SUCH_LOGON_SESSION ||  \
    (rc) == ERROR_DOWNGRADE_DETECTED)

DWORD
IsDirAccessible(
    IN PCWSTR Path
    )
{
    DWORD dwRet = ERROR_SUCCESS;

    HANDLE hDir = CreateFile(
        Path,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL
        );

    if(hDir != INVALID_HANDLE_VALUE) {
        CloseHandle(hDir);
    } else {
        dwRet = GetLastError();
    }

    return dwRet;
}

DWORD
EstablishConnection(
    IN HWND   hWndParent,
    IN PCWSTR RemoteName,
    IN BOOL   AllowUI
    )
/*++

Routine Description:

    Routine establishes a connection to the specifed remote name given some
    wierd horkin path

Arguments:

    hWndParent - specifies parent hwnd that can be used if AllowUI is true.
    RemoteName - specifies a UNC path to connect to.
    AllowUI    - specifies if we allow the CONNECT_INTERACTIVE flag
                 when connecting to a network share

Return Value:

    win32 error code indicating outcome.

--*/
{
    WCHAR buf[MAX_PATH], RestofPath[MAX_PATH];
    NETRESOURCE  nr;
    DWORD rc;
    BOOL Impersonating = FALSE;

    ASSERT(RemoteName != NULL && RemoteName[0] != 0);

    //
    // create a string that is basically just "\\server\share"
    // even if the passed in string contains a unc path to a file
    // or a directory.
    //



    if (!SfcGetConnectionName(RemoteName, buf, UnicodeChars(buf), RestofPath, UnicodeChars(RestofPath), TRUE, &Impersonating)) {
        DWORD lasterror = GetLastError();
        DebugPrint1( LVL_VERBOSE, L"SfcGetConnectionName failed, ec=%d", lasterror );
        return(lasterror);
    }

    pSetupConcatenatePaths( buf, RestofPath, UnicodeChars(buf), NULL );

    //
    // try to establish a connection to the server
    //

    nr.dwScope = 0;
    nr.dwType = RESOURCETYPE_DISK;
    nr.dwDisplayType = 0;
    nr.dwUsage = 0;
    nr.lpLocalName = NULL;
    nr.lpRemoteName = buf;
    nr.lpComment = NULL;
    nr.lpProvider = NULL;

    //
    // try to establish a connection to the server
    //
    rc = WNetAddConnection2( &nr, NULL, NULL, CONNECT_TEMPORARY );

    //
    // The directory could not be accessible even if the connection succeeded
    //
    if(ERROR_SUCCESS == rc) {
        rc = IsDirAccessible(buf);
    }

    //
    // Try again in the context of the currently logged-on user
    //
    if(!Impersonating && SFC_BAD_CREDENTIALS(rc) && hUserToken != NULL && ImpersonateLoggedOnUser(hUserToken)) {
        Impersonating = TRUE;
        rc = WNetAddConnection2( &nr, NULL, NULL, CONNECT_TEMPORARY );

        if(ERROR_SUCCESS == rc) {
            rc = IsDirAccessible(buf);
        }
    }

    //
    // If this failed, there's no need to impersonate anymore; we always prompt for credentials in the system context.
    // If it succeeded, we must keep on impersonating until the end of the queue (when we receive SPFILENOTIFY_ENDQUEUE).
    //
    if(Impersonating && rc != ERROR_SUCCESS) {
        RevertToSelf();
    }

    //
    // if it failed, let's try to bring up UI to allow the connection
    //
    if(SFC_BAD_CREDENTIALS(rc) && AllowUI) {
        HWND hwndDlgParent = hWndParent;
        DWORD RetryCount = 2;

        SetThreadDesktop( hUserDesktop );

        if(NULL == hWndParent)
        {
            //
            // create a parent for the authentication dialog
            // in case of an error, hwndDlgParent will stay NULL; there's nothing much we can do about it
            //

            if(ERROR_SUCCESS == CreateDialogParent(&hwndDlgParent))
            {
                ASSERT(hwndDlgParent != NULL);
                //SetForegroundWindow(hwndDlgParent);
            }
        }

        do {
            rc = WNetAddConnection3(
                            hwndDlgParent,
                            &nr,
                            NULL,
                            NULL,
                            CONNECT_TEMPORARY | CONNECT_PROMPT | CONNECT_INTERACTIVE );

            if(ERROR_SUCCESS == rc) {
                rc = IsDirAccessible(buf);
            }

            RetryCount -= 1;
        } while (    (rc != ERROR_SUCCESS)
                  && (rc != ERROR_CANCELLED)
                  && (RetryCount > 0) );

        if(NULL == hWndParent && hwndDlgParent != NULL)
        {
            //
            // we created the parent, so we destroy it
            //

            DestroyWindow(hwndDlgParent);
        }

        if (rc == ERROR_SUCCESS) {
            SFCLoggedOn = TRUE;
            wcsncpy(SFCNetworkLoginLocation,buf,MAX_PATH);
        }
    }
    if ((SFCLoggedOn == FALSE) && (rc == ERROR_SUCCESS)) {
        WNetCancelConnection2( buf, CONNECT_UPDATE_PROFILE, FALSE );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\exceppk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exceppk.c

Abstract:

    Implementation of exception packages processing functions.

Author:

    Marian Trandafir (mariant) 27-Nov-2000

Revision History:

--*/

#include "sfcp.h"
#pragma hdrstop

#include <excppkg.h>


//
// Exception packages processing
//
typedef struct _SFC_EXCEPTION_INFO
{
    LIST_ENTRY ListEntry;
    GUID guid;
    WCHAR InfName[0];
}
SFC_EXCEPTION_INFO, *PSFC_EXCEPTION_INFO;

typedef struct _SFC_EXCEPTION_QUEUE_CONTEXT
{
    ULONG ProtectedFilesCount;
    ULONG InsertedFilesCount;
    PSFC_EXCEPTION_INFO ExcepInfo;
}
SFC_EXCEPTION_QUEUE_CONTEXT, *PSFC_EXCEPTION_QUEUE_CONTEXT;

DWORD_TREE ExceptionTree;       // the exception pack files tree
LIST_ENTRY ExceptionInfList;    // list of SFC_EXCEPTION_INFO structures

DWORD ExcepPackCount = 0;       // the size of the ExcepPackGuids array
LPGUID ExcepPackGuids = NULL;   // the array of package GUIDS

//
// this is the exception package directory (\-terminated)
//
static const WCHAR ExceptionPackDir[] = L"%windir%\\RegisteredPackages\\";


VOID 
SfcDestroyList(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Empties a linked list

Arguments:

    LiastHead:  pointer to the list header

Return Value:

    none

--*/
{
    PLIST_ENTRY Entry;

    for(Entry = ListHead->Flink; Entry != ListHead; )
    {
        PLIST_ENTRY Flink = Entry->Flink;
        MemFree(Entry);
        Entry = Flink;
    }

    InitializeListHead(ListHead);
}

VOID 
SfcExceptionInfoInit(
    VOID
    )
/*++

Routine Description:

    Initializes the exception info list and tree

Arguments:

    none

Return Value:

    none

--*/
{
    TreeInit(&ExceptionTree);
    InitializeListHead(&ExceptionInfList);
}

VOID
SfcExceptionInfoDestroy(
    VOID
    )
/*++

Routine Description:

    Empties the exception info list and tree.
Arguments:

    none

Return Value:

    none

--*/
{
    TreeDestroy(&ExceptionTree);
    SfcDestroyList(&ExceptionInfList);
}

BOOL
ExceptionPackageSetChanged(
    VOID
    )
/*++

Routine Description:

    Checks if the installed exception package set has changed. The routine uses the exception package API 
    to get the current list of installed exceppack's GUIDs and compares the list with the old one. If the
    lists are different, it replaces the old list with the new one.

Arguments:

    none

Return Value:

    TRUE if the list has changed.

--*/
{
    LPGUID NewList = NULL;
    DWORD NewCount;
    DWORD Error = ERROR_SUCCESS;
    BOOL bRet;

    if(!SetupQueryRegisteredOsComponentsOrder(&NewCount, NULL))
    {
        Error = GetLastError();
        goto lExit;
    }

    if(NewCount != 0)
    {
        NewList = (LPGUID) MemAlloc(NewCount * sizeof(GUID));

        if(NULL == NewList)
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto lExit;
        }

        if(!SetupQueryRegisteredOsComponentsOrder(&NewCount, NewList))
        {
            Error = GetLastError();
            goto lExit;
        }
    }

    if(ExcepPackCount == NewCount &&
        (0 == NewCount || 0 == memcmp(ExcepPackGuids, NewList, NewCount * sizeof(GUID))))
    {
        bRet = FALSE;
        goto lExit;
    }

    MemFree(ExcepPackGuids);
    ExcepPackCount = NewCount;
    ExcepPackGuids = NewList;
    NewList = NULL;
    bRet = TRUE;

lExit:
    MemFree(NewList);

    //
    // if errors occured, delete the old list and try to rebuild the exception info anyway
    //
    if(Error != ERROR_SUCCESS)
    {
        DebugPrint1(LVL_MINIMAL, L"Error 0x%08lX occured while reading exception packages info.", Error);
        MemFree(ExcepPackGuids);
        ExcepPackGuids = NULL;
        ExcepPackCount = 0;
        bRet = TRUE;
    }

    return bRet;
}

BOOL
SfcLookupAndInsertExceptionFile(
    IN LPCWSTR FilePath,
    IN PSFC_EXCEPTION_QUEUE_CONTEXT Context
    )
/*++

Routine Description:

    Lookup if an exceppack file is protected and, if so, inserts it in the exception search binary tree.
    The search key of this tree is the index of the SFC_REGISTRY_VALUE describing the protected file in the 
    SfcProtectedDllsList array. The context stored in the tree is a pointer to an SFC_EXCEPTION_INFO structure
    allocated on the heap and inserted in the ExceptionInfList list.

Arguments:

    FilePath:   full path to the exception file to be inserted
    Context:    pointer to the SFC_EXCEPTION_QUEUE_CONTEXT structure that is passed as a setup queue context

Return Value:

    TRUE if the file is protected and was inserted in the tree

--*/
{
    PNAME_NODE pNode;
    UINT_PTR uiIndex;
    DWORD dwSize;
    WCHAR buffer[MAX_PATH];

    ASSERT(FilePath != NULL);
    dwSize = wcslen(FilePath);
    ASSERT(dwSize != 0 && dwSize < MAX_PATH);

    if(dwSize >= MAX_PATH)
    {
        dwSize = MAX_PATH - 1;
    }

    RtlCopyMemory(buffer, FilePath, (dwSize + 1) * sizeof(WCHAR));
    buffer[MAX_PATH - 1] = 0;
    MyLowerString(buffer, dwSize);
    pNode = SfcFindProtectedFile(buffer, dwSize * sizeof(WCHAR));
    DebugPrint2(LVL_VERBOSE, L"Target file [%s] is %sprotected.", buffer, pNode != NULL ? L"" : L"not ");

    if(NULL == pNode)
    {
        return FALSE;
    }

    ++(Context->ProtectedFilesCount);
    uiIndex = (PSFC_REGISTRY_VALUE) pNode->Context - SfcProtectedDllsList;
    ASSERT(uiIndex < SfcProtectedDllCount);
    
    if(NULL == TreeInsert(&ExceptionTree, (ULONG) uiIndex, &Context->ExcepInfo, sizeof(PVOID)))
    {
        DebugPrint1(LVL_MINIMAL, L"Could not insert file [%s] if the exception tree.", buffer);
        return FALSE;
    }

    ++(Context->InsertedFilesCount);

    return TRUE;
}

UINT
SfcExceptionQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
/*++

Routine Description:

    This is the setup queue calback for an exceppack inf. The queue is used to enumerate all 
    exception files that are installed by the exceppack.

Arguments:

    Context:        pointer to an SFC_EXCEPTION_QUEUE_CONTEXT structure
    Notification:   notification code
    Param1:         first notification parameter
    Param2:         second notification parameter

Return Value:

    Operation code. For installed files, this is always FILEOP_SKIP since we only want to enumerate them

--*/
{
    ASSERT(Context != NULL);
    ASSERT(SPFILENOTIFY_QUEUESCAN == Notification);
    ASSERT(Param1 != 0);

    if(SPFILENOTIFY_QUEUESCAN == Notification && Param1 != 0)
    {
        SfcLookupAndInsertExceptionFile((LPCWSTR) Param1, (PSFC_EXCEPTION_QUEUE_CONTEXT) Context);
    }
    //
    // always continue with the next file
    //
    return 0;
}

DWORD
SfcBuildExcepPackInfo(
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Allocates the exceppack info structure, enumerates and inserts all exceppack protected files and,
    if any, inserts exceppack info in the list.

Arguments:

    ComponentData, ExceptionData:   describe the exceppack as passed to the exceppack enumerator callback.

Return Value:

    THe Win32 error code.

--*/
{
    HINF hinf = INVALID_HANDLE_VALUE;
    HSPFILEQ hfq = INVALID_HANDLE_VALUE;
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwUnused;
    PSFC_EXCEPTION_INFO pExcepInfo = NULL;
    SFC_EXCEPTION_QUEUE_CONTEXT Context;
    DWORD Size;
    LPCWSTR InfName;

    InfName = wcsrchr(ExceptionData->ExceptionInfName, L'\\');
    ASSERT(InfName != NULL);

    if(NULL == InfName)
    {
        dwError = ERROR_INVALID_DATA;
        goto lExit;
    }

    ++InfName;
    Size = wcslen(InfName) + 1;
    ASSERT(Size > 1 && Size < MAX_PATH);
    Size *= sizeof(WCHAR);
    pExcepInfo = (PSFC_EXCEPTION_INFO) MemAlloc(sizeof(SFC_EXCEPTION_INFO) + Size);

    if(NULL == pExcepInfo)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto lExit;
    }

    pExcepInfo->guid = ComponentData->ComponentGuid;
    RtlCopyMemory(pExcepInfo->InfName, InfName, Size);

    hinf = SetupOpenInfFileW(ExceptionData->ExceptionInfName, NULL, INF_STYLE_WIN4, NULL);

    if(INVALID_HANDLE_VALUE == hinf)
    {
        dwError = GetLastError();
        DebugPrint2(LVL_MINIMAL, L"SetupOpenInfFile returned 0x%08lX for [%s]", dwError, ExceptionData->ExceptionInfName);
        goto lExit;
    }

    hfq = SetupOpenFileQueue();

    if(INVALID_HANDLE_VALUE == hfq)
    {
        dwError = GetLastError();
        DebugPrint1(LVL_MINIMAL, L"SetupOpenFileQueue returned 0x%08lX.", dwError);
        goto lExit;
    }

    Context.ProtectedFilesCount = Context.InsertedFilesCount = 0;
    Context.ExcepInfo = pExcepInfo;

    if(!SetupInstallFilesFromInfSectionW(
        hinf,
        NULL,
        hfq,
        L"DefaultInstall",
        NULL,
        0
        ))
    {
        dwError = GetLastError();
        DebugPrint1(LVL_MINIMAL, L"SetupInstallFilesFromInfSectionW returned 0x%08lX.", dwError);
        goto lExit;
    }

    SetupScanFileQueue(
        hfq,
        SPQ_SCAN_USE_CALLBACK,
        NULL,
        SfcExceptionQueueCallback,
        &Context,
        &dwUnused
        );

    DebugPrint3(
        LVL_VERBOSE, 
        L"Exception package [%s] has %d protected files, of which %d were inserted in the tree.",
        ComponentData->FriendlyName, 
        Context.ProtectedFilesCount,
        Context.InsertedFilesCount
        );
    //
    // add the exception info in the list if there was at least one file inserted in the tree
    //
    if(Context.InsertedFilesCount != 0)
    {
        InsertTailList(&ExceptionInfList, (PLIST_ENTRY) pExcepInfo);
        pExcepInfo = NULL;
    }

lExit:
    MemFree(pExcepInfo);

    if(hfq != INVALID_HANDLE_VALUE)
    {
        SetupCloseFileQueue(hfq);
    }

    if(hinf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hinf);
    }

    return dwError;
}

BOOL CALLBACK SfcExceptionCallback(
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++

Routine Description:

    This is the excceppack enumerator callback. It passes on the excceppack info to SfcBuildExcepPackInfo.

Arguments:

    ComponentData, ExceptionData:   describe the exceppack
    Context:                        callback context, not used

Return Value:

    TRUE to continue the enumeration.

--*/
{
    ASSERT(ComponentData->SizeOfStruct == sizeof(*ComponentData));

    DebugPrint1(LVL_VERBOSE, L"Building exception info for package [%s]", ComponentData->FriendlyName);
    SfcBuildExcepPackInfo(ComponentData, ExceptionData);

    //
    // continue to scan the remaining packages, regardless of any errors
    //
    return TRUE;
}

VOID
SfcRefreshExceptionInfo(
    VOID
    )
/*++

Routine Description:

    Verifies if the installed exception pack set has changed and rebuilds exceppack info if necessary.
    This is called from different threads so the code protected by a critical section

Arguments:

    none

Return Value:

    none

--*/
{
    RtlEnterCriticalSection(&g_GeneralCS);

    if(ExceptionPackageSetChanged())
    {
        //
        // rebuild the entire exception info
        //
        SfcExceptionInfoDestroy();
        
        if(!SetupEnumerateRegisteredOsComponents(SfcExceptionCallback, 0))
        {
            DebugPrint1(LVL_MINIMAL, L"SetupEnumerateRegisteredOsComponents returned 0x%08lX.", GetLastError());
        }
    }

    RtlLeaveCriticalSection(&g_GeneralCS);
}

BOOL
SfcGetInfName(
    IN PSFC_REGISTRY_VALUE RegVal,
    OUT LPWSTR InfName
    )
/*++

Routine Description:

    Gets the path to the inf file that contains layout info for the protected file described by the RegVal argument.
    If the file is part of an installed excceppack, than the path to excceppack inf file is returned. Otherwise,
    the function returns the inf path specified in the RegVal argument.

Arguments:

    RegVal:     pointer to an SFC_REGISTRY_VALUE struct that describes the protected file
    InfName:    pointer to a buffer of MAX_PATH characters that receives the inf path

Return Value:

    TRUE if the file is part of an installed exceppack

--*/
{
    PSFC_EXCEPTION_INFO* ppExcepInfo;
    UINT_PTR uiIndex;
    BOOL bException;

    uiIndex = RegVal - SfcProtectedDllsList;
    ASSERT(uiIndex < (UINT_PTR) SfcProtectedDllCount);

    RtlEnterCriticalSection(&g_GeneralCS);

    ppExcepInfo = (PSFC_EXCEPTION_INFO*) TreeFind(&ExceptionTree, (ULONG) uiIndex);
    bException = (ppExcepInfo != NULL);

    if(bException)
    {
        PSFC_EXCEPTION_INFO pExcepInfo;
        UINT Size;

        pExcepInfo = *ppExcepInfo;
        ASSERT(pExcepInfo != NULL);

        Size = ExpandEnvironmentStringsW(ExceptionPackDir, InfName, MAX_PATH);
        InfName[MAX_PATH - 1] = 0;
        ASSERT(Size != 0 && Size < MAX_PATH);
        --Size;
        Size += (DWORD) StringFromGUID2(&pExcepInfo->guid, InfName + Size, MAX_PATH - Size);
        ASSERT(Size < MAX_PATH);
        InfName[Size - 1] = L'\\';
        wcsncpy(InfName + Size, pExcepInfo->InfName, MAX_PATH - Size);
        InfName[MAX_PATH - 1] = 0;
    }
    else if(NULL == RegVal->InfName.Buffer)
    {
        *InfName = 0;
    }
    else
    {
        wcsncpy(InfName, RegVal->InfName.Buffer, MAX_PATH - 1);
        InfName[MAX_PATH - 1] = 0;
    }

    RtlLeaveCriticalSection(&g_GeneralCS);

    return bException;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\restore.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Implementation of file restoration code.

Author:

    Andrew Ritz (andrewr) 30-Jul-1999

Revision History:

    Andrew Ritz (andrewr) 30-Jul-1999 : moved code from fileio.c and validate.c

--*/

#include "sfcp.h"
#pragma hdrstop

#include <dbt.h>
#include <initguid.h>
#include <devguid.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// DEVICE_CHANGE is a private stucture used to indicate how to check for a file
// (either from a device change notification or from the user clicking "retry"
// on the prompt dialog.
//
typedef struct _DEVICE_CHANGE {
    DWORD Mask;
    DWORD Flags;
} DEVICE_CHANGE, *PDEVICE_CHANGE;


DWORD
pSfcRestoreFromMediaWorkerThread(
                                IN PRESTORE_QUEUE RestoreQueue
                                );

DWORD
SfcGetCabTagFile(
    IN PSOURCE_INFO psi,
    OUT PWSTR* ppFile
    );

PVOID
pSfcRegisterForDevChange(
                        HWND hDlg
                        )
/*++

Routine Description:

    Routine registers for PNP device notification messages so we know when the
    user has inserted the CD-ROM.

Arguments:

    hDlg - dialog to post device change notification to.

Return Value:

    A device change handle for success, otherwise NULL.  If this function
    succeeds, the hDlg will receive WM_DEVICECHANGE notification messages

--*/
{
    PVOID hNotifyDevNode;
    DEV_BROADCAST_DEVICEINTERFACE FilterData;

    ASSERT(IsWindow(hDlg));

    //
    // register for cdrom change notifications
    //
    FilterData.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    FilterData.dbcc_classguid  = GUID_DEVCLASS_CDROM;

    hNotifyDevNode = RegisterDeviceNotification( hDlg, &FilterData, DEVICE_NOTIFY_WINDOW_HANDLE );
    if (hNotifyDevNode == NULL) {
        DebugPrint1( LVL_VERBOSE, L"RegisterDeviceNotification failed, ec=%d", GetLastError() );
    }

    return hNotifyDevNode;
}

INT_PTR
CALLBACK
pSfcPromptForMediaDialogProc(
                            HWND hwndDlg,
                            UINT uMsg,
                            WPARAM wParam,
                            LPARAM lParam
                            )
/*++

Routine Description:

    Routine is the dialog procedure for prompting the user to put in media.

    We use the same dialog procedure for IDD_SFC_NETWORK_PROMPT and
    IDD_SFC_CD_PROMPT.

    We register for a device notification so we know when the user puts the
    media into the drive.  So we don't even need an "OK" button in this dialog,
    just a cancel dialog in case the user cannot find the media, etc.

Arguments:

    standard dialog proc arguments

Return Value:

    standard dialog proc return code

--*/
{
#define WM_TRYAGAIN  (WM_APP + 1)
    DEV_BROADCAST_VOLUME *dbv;
    static UINT QueryCancelAutoPlay = 0;
    static PVOID hNotifyDevNode = NULL;
    static PPROMPT_INFO pi;
    WCHAR buf1[128];
    WCHAR buf2[128];
    WCHAR conn[128];
    PWSTR s;
    PDEVICE_CHANGE DeviceChangeStruct;
    DWORD Mask, Flags, i;
    DWORD rcid;
    static CancelId;
    WCHAR Path[16];
    WCHAR SourcePath[MAX_PATH];
    static PSFC_WINDOW_DATA WindowData;
    static bInModalLoop = FALSE;

    switch (uMsg) {
        case WM_INITDIALOG:
            pi = (PPROMPT_INFO) lParam;
            ASSERT(NULL != pi);

            //
            // register for cdrom notification.
            //
            hNotifyDevNode = pSfcRegisterForDevChange( hwndDlg );

            //
            // try to turn off the autorun junk that the shell creates
            //
            QueryCancelAutoPlay = RegisterWindowMessage( L"QueryCancelAutoPlay" );

            //
            // center the dialog and try to put it in the user's face
            //
            CenterDialog( hwndDlg );
            SetForegroundWindow( hwndDlg );



            GetDlgItemText( hwndDlg, IDC_MEDIA_NAME, buf1, UnicodeChars(buf1) );
            swprintf( buf2, buf1, pi->si->Description );
            SetDlgItemText( hwndDlg, IDC_MEDIA_NAME, buf2 );

            //
            // if we're a network connection, put in the actual source path.
            //
            if (pi->NetPrompt) {

                ASSERT( pi->SourcePath != NULL );

                GetDlgItemText( hwndDlg, IDC_NET_NAME, buf1, UnicodeChars(buf1) );

                if(!SfcGetConnectionName( pi->SourcePath, conn, UnicodeChars(conn), NULL, 0, FALSE, NULL )) {
                    conn[0] = 0;
                }

                (void) StringCchPrintf( buf2, UnicodeChars(buf2), buf1, conn );
                SetDlgItemText( hwndDlg, IDC_NET_NAME, buf2 );
            } else {
                NOTHING;
                //HideWindow( GetDlgItem( hwndDlg, IDC_RETRY ) );
                //HideWindow( GetDlgItem( hwndDlg, IDC_INFO  ) );
                //SetFocus( GetDlgItem( hwndDlg, IDCANCEL ) );
            }

            //
            // set the appropriate text based on what sort of prompt we are for
            //
            if (pi->Flags & PI_FLAG_COPY_TO_CACHE) {
                rcid = IDS_CACHE_TEXT;
                CancelId = IDS_CANCEL_CONFIRM_CACHE;
            } else if (pi->Flags & PI_FLAG_INSTALL_PROTECTED) {
                rcid = IDS_INSTALL_PROTECTED_TEXT;
                CancelId = IDS_CANCEL_CONFIRM_INSTALL;
            } else {
                ASSERT(pi->Flags & PI_FLAG_RESTORE_FILE);
                rcid = IDS_RESTORE_TEXT;
                CancelId = IDS_CANCEL_CONFIRM;
            }

            LoadString(SfcInstanceHandle,rcid,SourcePath,UnicodeChars(SourcePath));
            SetDlgItemText( hwndDlg, IDC_PROMPT_TEXT, SourcePath );


            //
            // remember our window handle so we can close it if we have to.
            //
            WindowData = pSfcCreateWindowDataEntry( hwndDlg );

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_RETRY:
                    PostMessage(hwndDlg, WM_TRYAGAIN, 0, (LPARAM)NULL);
                    break;
                case IDC_INFO:
                    bInModalLoop = TRUE;

                    MyMessageBox(
                                NULL,
                                pi->NetPrompt ? IDS_MORE_INFORMATION_NET : IDS_MORE_INFORMATION_CD,
                                MB_ICONINFORMATION | MB_SERVICE_NOTIFICATION);

                    bInModalLoop = FALSE;
                    break;
                case IDCANCEL:

                    //
                    // the user clicked cancel.  Ask them if they really mean it and exit
                    //
                    ASSERT(CancelId != 0);
                    bInModalLoop = TRUE;

                    if (MyMessageBox(
                                    hwndDlg,
                                    CancelId,
                                    MB_APPLMODAL | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING ) == IDYES) {
                        UnregisterDeviceNotification( hNotifyDevNode );
                        pSfcRemoveWindowDataEntry( WindowData );
                        EndDialog( hwndDlg, 0 );
                    }

                    bInModalLoop = FALSE;
                    break;
                default:
                    NOTHING;
            }
            break;
        case WM_WFPENDDIALOG:
            DebugPrint(
                      LVL_VERBOSE,
                      L"Received WM_WFPENDDIALOG message, terminating dialog" );


            SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, ERROR_SUCCESS );

            //
            // returning 2 indicates that we are being force-terminated so we
            // don't need to bother removing our SFC_WINDOW_DATA member
            //
            EndDialog( hwndDlg, 2 );


            break;
        case WM_TRYAGAIN:
            DeviceChangeStruct = (PDEVICE_CHANGE) lParam;
            if (DeviceChangeStruct) {
                Mask = DeviceChangeStruct->Mask;
                Flags = DeviceChangeStruct->Flags;
                MemFree(DeviceChangeStruct);
                DeviceChangeStruct = NULL;
            } else {
                Flags = DBTF_MEDIA;
                Mask = (DWORD)-1;
            }

            if (pi->NetPrompt) {
                EstablishConnection( hwndDlg, pi->SourcePath, !SFCNoPopUps );
                if (TAGFILE(pi->si)) {
                    s = wcsrchr( TAGFILE(pi->si), L'.' );
                    if (s && _wcsicmp( s, L".cab" ) == 0) {
                        //
                        // yep, the tagfile is a cabfile
                        // look for that file on disk
                        // and if it is, use it.
                        //

                        BuildPathForFile(
                                pi->SourcePath,
                                pi->si->SourcePath,
                                TAGFILE(pi->si),
                                SFC_INCLUDE_SUBDIRECTORY,
                                SFC_INCLUDE_ARCHSUBDIR,
                                SourcePath,
                                UnicodeChars(SourcePath) );

                        if (SfcIsFileOnMedia( SourcePath )) {
                            s = wcsrchr( SourcePath, L'\\' );
                            *s = L'\0';
                            wcscpy( pi->NewPath, SourcePath );
                            UnregisterDeviceNotification( hNotifyDevNode );
                            pSfcRemoveWindowDataEntry( WindowData );
                            EndDialog( hwndDlg, 1 );
                            return FALSE;
                        }

                        //
                        // try without the subdir
                        //

                        BuildPathForFile(
                                pi->SourcePath,
                                pi->si->SourcePath,
                                TAGFILE(pi->si),
                                SFC_INCLUDE_SUBDIRECTORY,
                                (!SFC_INCLUDE_ARCHSUBDIR),
                                SourcePath,
                                UnicodeChars(SourcePath) );

                        if (SfcIsFileOnMedia( SourcePath )) {
                            s = wcsrchr( SourcePath, L'\\' );
                            *s = L'\0';
                            wcscpy( pi->NewPath, SourcePath );
                            UnregisterDeviceNotification( hNotifyDevNode );
                            pSfcRemoveWindowDataEntry( WindowData );
                            EndDialog( hwndDlg, 1 );
                            return FALSE;
                        } else {
                            DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: cab file is missing from cd, [%ws]", SourcePath );
                        }
                    } else {
                        DebugPrint1( LVL_VERBOSE,
                                     L"pSfcPromptForMediaDialogProc: the tag file [%ws] is not a cab file",
                                     TAGFILE(pi->si) );
                    }
                }

                //
                // no cab file.  look for the actual
                // file on the media
                //

                BuildPathForFile(
                                pi->SourcePath,
                                pi->si->SourcePath,
                                pi->SourceFileName,
                                SFC_INCLUDE_SUBDIRECTORY,
                                SFC_INCLUDE_ARCHSUBDIR,
                                SourcePath,
                                UnicodeChars(SourcePath) );

                if (SfcIsFileOnMedia( SourcePath )) {
                    s = wcsrchr( SourcePath, L'\\' );
                    *s = L'\0';
                    wcscpy( pi->NewPath, SourcePath );
                    UnregisterDeviceNotification( hNotifyDevNode );
                    pSfcRemoveWindowDataEntry( WindowData );
                    EndDialog( hwndDlg, 1 );
                    return FALSE;
                }

                //
                // try again without the subdir
                //

                BuildPathForFile(
                                pi->SourcePath,
                                pi->si->SourcePath,
                                pi->SourceFileName,
                                SFC_INCLUDE_SUBDIRECTORY,
                                (!SFC_INCLUDE_ARCHSUBDIR),
                                SourcePath,
                                UnicodeChars(SourcePath) );

                if (SfcIsFileOnMedia( SourcePath )) {
                    s = wcsrchr( SourcePath, L'\\' );
                    *s = L'\0';
                    wcscpy( pi->NewPath, SourcePath );
                    UnregisterDeviceNotification( hNotifyDevNode );
                    pSfcRemoveWindowDataEntry( WindowData );
                    EndDialog( hwndDlg, 1 );
                    return FALSE;
                }
            }


            Path[0] = L'?';
            Path[1] = L':';
            Path[2] = L'\\';
            Path[3] = 0;
            Path[4] = 0;

            //
            // cycle through all drive letters A-Z looking for the file
            //
            for (i=0; i<26; i++) {
                if (Mask&1) {
                    Path[0] = (WCHAR)(L'A' + i);
                    Path[3] = 0;
                    //
                    // is media present in the CD-ROM?
                    //
                    if (Flags == DBTF_MEDIA) {
                        if (GetDriveType( Path ) == DRIVE_CDROM) {
                            //
                            // look for the tag file so we're sure that the cd that
                            // was inserted is the correct one
                            //
                            DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: found cdrom drive on [%ws]", Path );
                            if (TAGFILE(pi->si)) {
                                wcscpy( SourcePath, Path );
                                s = wcsrchr( TAGFILE(pi->si), L'.' );
                                if (s && _wcsicmp( s, L".cab" ) == 0) {
                                    PWSTR szTagfile;
                                    //
                                    // get the cab's tagfile
                                    //
                                    if (SfcGetCabTagFile(pi->si, &szTagfile) == ERROR_SUCCESS) {
                                        pSetupConcatenatePaths( SourcePath, szTagfile, UnicodeChars(SourcePath), NULL );
                                        MemFree(szTagfile);
                                    } else {
                                        DebugPrint1(LVL_VERBOSE, L"SfcGetCabTagFile failed with error %d", GetLastError());
                                    }

                                }else{
                                    pSetupConcatenatePaths( SourcePath, TAGFILE(pi->si),UnicodeChars(SourcePath), NULL );

                                }
                                if (GetFileAttributes( SourcePath ) != (DWORD)-1) {
                                    //
                                    // the user has the correct cd inserted
                                    // so now look to see if the file is on
                                    //  the cd
                                    //


                                    //
                                    // first we have to look for the tagfile
                                    // for the actual file because the tag-
                                    // file may actually be a cabfile that
                                    // the file is embedded in
                                    //
                                    if (TAGFILE(pi->si)) {
                                        s = wcsrchr( TAGFILE(pi->si), L'.' );
                                        if (s && _wcsicmp( s, L".cab" ) == 0) {
                                            //
                                            // yep, the tagfile is a cabfile
                                            // look for that file on disk
                                            // and if it is, use it.
                                            //
                                            BuildPathForFile(
                                                    Path,
                                                    pi->si->SourcePath,
                                                    TAGFILE(pi->si),
                                                    SFC_INCLUDE_SUBDIRECTORY,
                                                    SFC_INCLUDE_ARCHSUBDIR,
                                                    SourcePath,
                                                    UnicodeChars(SourcePath) );

                                            if (SfcIsFileOnMedia( SourcePath )) {
                                                s = wcsrchr( SourcePath, L'\\' );
                                                *s = L'\0';
                                                wcscpy( pi->NewPath, SourcePath );
                                                UnregisterDeviceNotification( hNotifyDevNode );
                                                pSfcRemoveWindowDataEntry( WindowData );
                                                EndDialog( hwndDlg, 1 );
                                                return FALSE;
                                            } else {
                                                DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: cab file is missing from cd, [%ws]", SourcePath );
                                            }
                                        } else {
                                            DebugPrint1( LVL_VERBOSE,
                                                         L"pSfcPromptForMediaDialogProc: the tag file [%ws] is not a cab file",
                                                         TAGFILE(pi->si) );
                                        }
                                    }

                                    //
                                    // no cab file.  look for the actual
                                    // file on the media
                                    //
                                    BuildPathForFile(
                                            Path,
                                            pi->si->SourcePath,
                                            pi->SourceFileName,
                                            SFC_INCLUDE_SUBDIRECTORY,
                                            SFC_INCLUDE_ARCHSUBDIR,
                                            SourcePath,
                                            UnicodeChars(SourcePath) );

                                    if (SfcIsFileOnMedia( SourcePath )) {
                                        s = wcsrchr( SourcePath, L'\\' );
                                        *s = L'\0';
                                        wcscpy( pi->NewPath, SourcePath );
                                        UnregisterDeviceNotification( hNotifyDevNode );
                                        pSfcRemoveWindowDataEntry( WindowData );
                                        EndDialog( hwndDlg, 1 );
                                        return FALSE;
                                    } else {
                                        DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: source file is missing [%ws]", SourcePath );
                                    }
                                } else {
                                    DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: media tag file [%ws] is missing, wrong CD", SourcePath );
                                }
                            } else {
                                DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: could not get source information for layout.inf, ec=%d", GetLastError() );
                            }
                        }
                    } else if (Flags == DBTF_NET) {
                        //
                        // network share has changed... get the UNC
                        // pathname and check for the file
                        //
                        if (SfcGetConnectionName( Path, SourcePath, UnicodeChars(SourcePath), NULL, 0, FALSE, NULL)) {


                            //
                            // first we have to look for the tagfile
                            // for the actual file because the tag-
                            // file may actually be a cabfile that
                            // the file is embedded in
                            //
                            if (TAGFILE(pi->si)) {
                                s = wcsrchr( TAGFILE(pi->si), L'.' );
                                if (s && _wcsicmp( s, L".cab" ) == 0) {
                                    //
                                    // yep, the tagfile is a cabfile
                                    // look for that file on disk
                                    // and if it is, use it.
                                    //
                                    BuildPathForFile(
                                            Path,
                                            pi->si->SourcePath,
                                            TAGFILE(pi->si),
                                            SFC_INCLUDE_SUBDIRECTORY,
                                            SFC_INCLUDE_ARCHSUBDIR,
                                            SourcePath,
                                            UnicodeChars(SourcePath) );

                                    if (SfcIsFileOnMedia( SourcePath )) {
                                        s = wcsrchr( SourcePath, L'\\' );
                                        *s = L'\0';
                                        wcscpy( pi->NewPath, SourcePath );
                                        UnregisterDeviceNotification( hNotifyDevNode );
                                        pSfcRemoveWindowDataEntry( WindowData );
                                        EndDialog( hwndDlg, 1 );
                                        return FALSE;
                                    } else {
                                        DebugPrint1( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: cab file is missing from cd, [%ws]", SourcePath );
                                    }
                                } else {
                                    DebugPrint1( LVL_VERBOSE,
                                                 L"pSfcPromptForMediaDialogProc: the tag file [%ws] is not a cab file",
                                                 TAGFILE(pi->si) );
                                }
                            }

                            BuildPathForFile(
                                SourcePath,
                                pi->si->SourcePath,
                                pi->SourceFileName,
                                SFC_INCLUDE_SUBDIRECTORY,
                                SFC_INCLUDE_ARCHSUBDIR,
                                SourcePath,
                                UnicodeChars(SourcePath) );

                            if (SfcIsFileOnMedia( SourcePath )) {
                                s = wcsrchr( SourcePath, L'\\' );
                                *s = L'\0';
                                wcscpy( pi->NewPath, SourcePath );
                                UnregisterDeviceNotification( hNotifyDevNode );
                                pSfcRemoveWindowDataEntry( WindowData );
                                EndDialog( hwndDlg, 1 );
                            }
                        }
                    }
                }
                Mask = Mask >> 1;
            }

            //
            // ok user made a mistake
            // he put in a cd but it is either the wrong cd
            // or it is damaged/corrupted.
            //
            bInModalLoop = TRUE;

            MyMessageBox(
                        hwndDlg,
                        pi->NetPrompt
                        ? IDS_WRONG_NETCD
                        : IDS_WRONG_CD,
                        MB_OK,
                        pi->si->Description );

            bInModalLoop = FALSE;

            //
            // Received a volume change notification but we didn't find what
            // we're looking for.
            //
            DebugPrint( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: didn't find file" );

            break;
        case WM_DEVICECHANGE:
            //
            // Don't process this while in a modal loop (i.e. displaying a message box) 
            //
            if(bInModalLoop) {
                break;
            }

            if (wParam == DBT_DEVICEARRIVAL) {
                dbv = (DEV_BROADCAST_VOLUME*)lParam;
                if (dbv->dbcv_devicetype == DBT_DEVTYP_VOLUME) {
                    //
                    // only care about volume type change notifications
                    //

                    DebugPrint( LVL_VERBOSE, L"pSfcPromptForMediaDialogProc: received a volume change notification" );

                    DeviceChangeStruct = MemAlloc( sizeof( DEVICE_CHANGE ) );
                    if (DeviceChangeStruct) {
                        DeviceChangeStruct->Mask =  dbv->dbcv_unitmask;
                        DeviceChangeStruct->Flags = dbv->dbcv_flags;
                        if (!PostMessage(hwndDlg, WM_TRYAGAIN, 0, (LPARAM)DeviceChangeStruct)) {
                            DebugPrint1( LVL_MINIMAL ,
                                         L"pSfcPromptForMediaDialogProc: PostMessage failed, ec = 0x%0xd",
                                         GetLastError() );
                            MemFree(DeviceChangeStruct);
                        }
                    } else {
                        PostMessage(hwndDlg, WM_TRYAGAIN, 0, (LPARAM)NULL);
                    }
                }
            }
            break;
        default:
            if (uMsg ==  QueryCancelAutoPlay) {
                //
                // disable autorun because it confuses the user
                //
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 1 );
                return 1;
            }
    } // end switch

    return FALSE;

}

UINT
SfcQueueCallback(
                IN PFILE_COPY_INFO fci,
                IN UINT Notification,
                IN UINT_PTR Param1,
                IN UINT_PTR Param2
                )
/*++

Routine Description:

    Routine is a setupapi queue callback routine.  We override some of the
    setupapi functions because we want to provide our own UI (or rather
    disallow the setupapi UI).

Arguments:

    fci          - our context structure which setupapi passes to us for each
                   callback
    Notification - SPFILENOTIFY_* code
    Param1       - depends on notification
    Param2       - depends on notification

Return Value:

    depends on notification.

--*/
{
    PSOURCE_MEDIA sm = (PSOURCE_MEDIA)Param1;
    WCHAR fname[MAX_PATH*2];
    WCHAR buf[MAX_PATH];
    DWORD rVal;
    INT_PTR rv;
    DWORD RcId;
    PFILEPATHS fp;
    PFILEINSTALL_STATUS cs;
    NTSTATUS Status;
    HANDLE FileHandle;
    PNAME_NODE Node;
    PSFC_REGISTRY_VALUE RegVal;
    DWORD FileSizeHigh;
    DWORD FileSizeLow;
    DWORD PathType;
    PROMPT_INFO pi;
    PSOURCE_INFO SourceInfo;
    PVALIDATION_REQUEST_DATA vrd;
    HCATADMIN hCatAdmin;


    switch (Notification) {
        case SPFILENOTIFY_ENDQUEUE:
            //
            // We might have impersonated the logged-on user in EstablishConnection during SPFILENOTIFY_NEEDMEDIA
            //
            RevertToSelf();
            break;

        //
        // we had a copy error, record this and move onto the next file.
        //
        case SPFILENOTIFY_COPYERROR:
            fp = (PFILEPATHS)Param1;
            DebugPrint2(
                       LVL_MINIMAL,
                       L"Failed to copy file %ws, ec = 0x%08x...",
                       fp->Target,
                       fp->Win32Error );
            //
            // fall through
            //
        case SPFILENOTIFY_ENDCOPY:
            //
            // end copy means the file copy just completed
            //

            fp = (PFILEPATHS)Param1;

            DebugPrint3( LVL_VERBOSE,
                         L"SfcQueueCallback: copy file %ws --> %ws, ec = 0x%08x",
                         fp->Source,
                         fp->Target,
                         fp->Win32Error );

            //
            // if the copy succeeded, clear any read-only or hidden attributes
            // that may have been set by copying off of a cd, etc.
            //
            if (fp->Win32Error == ERROR_SUCCESS) {
                SetFileAttributes( fp->Target,
                                   GetFileAttributes(fp->Target) & (~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN)) );
            }

            //
            // in the case that we're copying files due to an InstallProtectedFiles
            // call, cs will be initialized, and we can loop throught the list of
            // files, updating a status structure for each of these files
            //
            cs = fci->CopyStatus;
            while (cs && cs->FileName) {
                //
                // cycle through the list of files we want to be copied
                // and if the file was copied successfully, then get the
                // filesize so we can post it to the caller's dialog
                //
                // also remember the version for returning to the caller
                //
                if ( (_wcsicmp(cs->FileName,fp->Target) == 0)
                     && cs->Win32Error == ERROR_SUCCESS) {
                    cs->Win32Error = fp->Win32Error;
                    if (cs->Win32Error == ERROR_SUCCESS) {
                        Node = SfcFindProtectedFile( cs->FileName, UnicodeLen(cs->FileName) );
                        if (Node) {
                            RegVal = (PSFC_REGISTRY_VALUE)Node->Context;
                            Status = SfcOpenFile( &RegVal->FileName, RegVal->DirHandle, SHARE_ALL, &FileHandle );
                            if (NT_SUCCESS(Status)) {
                                if (fci->hWnd) {
                                    FileSizeLow = GetFileSize( FileHandle, &FileSizeHigh );
                                    PostMessage( fci->hWnd, WM_SFC_NOTIFY, (WPARAM)FileSizeLow, (LPARAM)FileSizeHigh );
                                }
                                SfcGetFileVersion( FileHandle, &cs->Version, NULL, fname );
                                NtClose( FileHandle );
                            }
                        }
                    } else {
                        DebugPrint2( LVL_MINIMAL, L"Failed to copy file %ws, ec = 0x%08x", fp->Target, fp->Win32Error );
                    }
                    break;
                }
                cs += 1;
            }

            if (fci->si) {
                vrd = pSfcGetValidationRequestFromFilePaths( fci->si, fci->FileCount, fp );
                if (vrd && vrd->Win32Error == ERROR_SUCCESS) {
                    vrd->Win32Error = fp->Win32Error;
                    if (fp->Win32Error == ERROR_SUCCESS) {
                        vrd->CopyCompleted = TRUE;

                        if (!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
                            DebugPrint1( LVL_MINIMAL, L"CCAAC() failed, ec=%d", GetLastError() );
                            goto next;
                        }

                        //
                        // make sure the file is now valid
                        //
                        if (!SfcGetValidationData( &vrd->RegVal->FileName,
                                                   &vrd->RegVal->FullPathName,
                                                   vrd->RegVal->DirHandle,
                                                   hCatAdmin,
                                                   &vrd->ImageValData.New )) {
                            DebugPrint1( LVL_MINIMAL, L"SfcGetValidationData() failed, ec=%d", GetLastError() );
                            goto next;
                        }

                        if (vrd->ImageValData.New.SignatureValid == FALSE) {
                            vrd->ImageValData.New.DllVersion = 0;
                        } else {
                            //
                            // Cause a validation request.  This should get us
                            // to sync the file in the cache.
                            //
                            SfcQueueValidationRequest(vrd->RegVal, SFC_ACTION_MODIFIED );
                        }

                        CryptCATAdminReleaseContext(hCatAdmin,0);

                        vrd->ImageValData.EventLog = MSG_DLL_CHANGE;
                    } else {
                        vrd->ImageValData.EventLog = MSG_RESTORE_FAILURE;
                    }
                }
            }

            return (Notification == SPFILENOTIFY_COPYERROR)
            ? FILEOP_SKIP
            : FILEOP_DOIT;
            break;

            //
            // This means that we're copying something from a new piece of media.
            // Before we mess around with putting up a prompt for the file, let's just
            // check for the file at the specified location and if it's there, we
            // assume that the media is already present and we should just use it.
            //
        case SPFILENOTIFY_NEEDMEDIA:

            DebugPrint3( LVL_MINIMAL, L"SfcQueueCallback: %ws - %ws, %ws", sm->SourcePath,  sm->SourceFile, sm->Tagfile );
            wcscpy( fname, sm->SourcePath );
            pSetupConcatenatePaths( fname, sm->SourceFile, UnicodeChars(fname), NULL );

            SourceInfo = pSfcGetSourceInfoFromSourceName( fci->si, fci->FileCount, sm );
            ASSERT(ShuttingDown ? SourceInfo != NULL : TRUE);

            //
            // if we're in the process of shutting down, then abort the queue.
            //
            if (ShuttingDown) {
                return(FILEOP_ABORT);
            }

            //
            // if we didn't find the SOURCE_INFO for this file, we can't go on
            // since we need that information to know where the proper location
            // to retrieve the file is.  we do make one last-ditch effort to
            // see if the file is just where we said it would be earlier, however.
            if (!SourceInfo) {
                if (SfcIsFileOnMedia( fname )) {
                    return FILEOP_DOIT;
                }

                SetLastError(ERROR_CANCELLED);
                return (FILEOP_ABORT);
            }

            //
            // if this is a network share we try to establish a connection
            // to the server before looking for the file.  this may bring up
            // UI
            //

            PathType = SfcGetPathType( (PWSTR)sm->SourcePath, buf,UnicodeChars(buf) );
            if (PathType == PATH_NETWORK || PathType == PATH_UNC) {
                EstablishConnection( NULL, sm->SourcePath, (fci->AllowUI && !SFCNoPopUps) );
            }

            rVal = SfcQueueLookForFile( sm, SourceInfo, fname, (PWSTR)Param2 );
            if (SFCNoPopUps) {
                if (rVal == FILEOP_ABORT) {
                    //
                    // media is necessary to copy the files but the user has
                    // configured wfp to not put up any ui.  we make this look
                    // like a cancel
                    //
                    SetLastError(ERROR_CANCELLED);
                }

                return (rVal);
            }

            if (rVal != FILEOP_ABORT) {
                //
                // we have found the file so start copying
                //
                return (rVal);
            }

            //
            // if we're not supposed to put up any dialogs, just abort copying
            // this media and goto the next media.
            //
            // Note: it would be good to skip instead of aborting, since
            // there might some set of files which we can restore from another
            // media.  In order to do this we really need to be able to know
            // what files are on this media and set an error code for these
            // files so that we know they weren't copied.
            //
            if (!fci->AllowUI) {
                return (FILEOP_ABORT);
            }

            //
            // otherwise let's just record that we're putting up media
            // and then do just that.
            //
            fci->UIShown = TRUE;
            //
            // Note: make sure not to use this source media structure after the
            // media has changed
            //
            switch (PathType) {
                case PATH_LOCAL:
                    RcId = IDD_SFC_CD_PROMPT;
                    break;

                case PATH_NETWORK:
                case PATH_UNC:
                    RcId = IDD_SFC_NETWORK_PROMPT;
                    break;

                case PATH_CDROM:
                    RcId = IDD_SFC_CD_PROMPT;
                    break;

                default:
                    RcId = 0;
                    ASSERT( FALSE && "Unexpected PathType" );
                    break;
            }

            ASSERT((sm->SourceFile) && (sm->SourcePath) && (RcId != 0) );
            pi.si = SourceInfo;
            pi.SourceFileName = (PWSTR)sm->SourceFile;
            pi.NewPath = buf;
            pi.SourcePath = (PWSTR)sm->SourcePath;
            pi.NetPrompt = (RcId == IDD_SFC_NETWORK_PROMPT);
            pi.Flags = fci->Flags;
            rv = MyDialogBoxParam(
                                 RcId,
                                 pSfcPromptForMediaDialogProc,
                                 (LPARAM)&pi
                                 );
            if (rv == 1) {
                //
                // we're done.  if we got a new path, pass that back to
                // setup API else just copy the file from the current
                // location
                //
                if (_wcsicmp( pi.NewPath, sm->SourcePath )) {
                    wcscpy( (PWSTR)Param2, pi.NewPath );
                    return ( FILEOP_NEWPATH );
                }
                return FILEOP_DOIT;
            } else if (rv == 2) {
                //
                // we were forcefully aborted by receiving WM_WFPENDDIALOG
                //
                return FILEOP_ABORT;
            } else {
                ASSERT(rv == 0);

                SetLastError(ERROR_CANCELLED);
                return FILEOP_ABORT;
            }

            ASSERT(FALSE && "should not get here");

            break;

        default:
            NOTHING;
    }

    next:
    //
    // just to the default for the rest of the callbacks
    //
    return SetupDefaultQueueCallback( fci->MsgHandlerContext, Notification, Param1, Param2 );
}


BOOL
SfcAddFileToQueue(
                 IN const HSPFILEQ hFileQ,
                 IN PCWSTR FileName,
                 IN PCWSTR TargetFileName,
                 IN PCWSTR TargetDirectory,
                 IN PCWSTR SourceFileName, OPTIONAL
                 IN PCWSTR SourceRootPath, OPTIONAL
                 IN PCWSTR InfName,
                 IN BOOL ExcepPackFile,
                 IN OUT PSOURCE_INFO SourceInfo OPTIONAL
                 )
/*++

Routine Description:

    Routine adds the specified file to a file queue for copying.

Arguments:

    hFileQ          - contains a file queue handle that we are inserting this
                      copy node into
    FileName        - specifies the filename to be copied
    TargetFileName  - target filename
    TargetDirectory - target destination directory
    SourceFileName  - source filename if it's different than the target
                      filename. if this is NULL, we assume the source filename
                      is the same as the target
    SourceRootPath  - the root path where we can find this file
    InfName         - the layout inf name
    SourceInfo      - SOURCE_INFO structure which gets set with additional
                      information about the file (like relative source
                      path, etc.)  If this is supplied, it is assumed that
                      the structure was already initialized with a call to
                      SfcGetSourceInformation

Return Value:

    TRUE if the file was successfully added to the file queue.

--*/
{
    BOOL b = FALSE;
    SOURCE_INFO sibuf;
    SP_FILE_COPY_PARAMS fcp;

    RtlZeroMemory(&fcp, sizeof(fcp));
    fcp.cbSize = sizeof(fcp);
    fcp.LayoutInf = INVALID_HANDLE_VALUE;

    //
    // get the source information
    //
    if (SourceInfo == NULL) {
        SourceInfo = &sibuf;
        ZeroMemory( SourceInfo, sizeof(SOURCE_INFO) );
        if (!SfcGetSourceInformation( SourceFileName == NULL ? FileName : SourceFileName, InfName, ExcepPackFile, SourceInfo )) {
            goto exit;
        }
    }

    ASSERT(SourceInfo != NULL);

    //
    // Open layout.inf
    //
    fcp.LayoutInf = SfcOpenInf(NULL, FALSE);

    if(INVALID_HANDLE_VALUE == fcp.LayoutInf) {
        goto exit;
    }

    fcp.QueueHandle = hFileQ;
    fcp.SourceRootPath = SourceRootPath ? SourceRootPath : SourceInfo->SourceRootPath;
    fcp.SourcePath = SourceInfo->SourcePath;
    fcp.SourceFilename = SourceFileName == NULL ? FileName : SourceFileName;
    fcp.SourceDescription = SourceInfo->Description;
    fcp.SourceTagfile = TAGFILE(SourceInfo);
    fcp.TargetDirectory = TargetDirectory;
    fcp.TargetFilename = TargetFileName;
    fcp.CopyStyle = SP_COPY_REPLACE_BOOT_FILE | PSP_COPY_USE_SPCACHE;

    //
    // add the file to the file queue
    //
    b = SetupQueueCopyIndirect(&fcp);

    if (!b) {
        DebugPrint1( LVL_VERBOSE, L"SetupQueueCopy failed, ec=%d", GetLastError() );
        goto exit;
    }

    exit:

    //
    // cleanup and exit
    //
    if(fcp.LayoutInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(fcp.LayoutInf);
    }

    return b;
}

BOOL
SfcRestoreFileFromInstallMedia(
                              IN PVALIDATION_REQUEST_DATA vrd,
                              IN PCWSTR FileName,
                              IN PCWSTR TargetFileName,
                              IN PCWSTR TargetDirectory,
                              IN PCWSTR SourceFileName,
                              IN PCWSTR InfName,
                              IN BOOL ExcepPackFile,
                              IN BOOL TargetIsCache,
                              IN BOOL AllowUI,
                              OUT PDWORD UIShown
                              )
/*++

Routine Description:

    Routine restores the file specified from media.  This routine only
    handles one file at a time, and it is only used when populating the
    DLLCache.

Arguments:

    vrd
    FileName
    TargetFileName
    TargetDirectory
    SourceFileName
    InfName
    AllowUI
    UIShown

Return Value:

    If TRUE, the file was successfully restored from media.

--*/
{
    HSPFILEQ hFileQ = INVALID_HANDLE_VALUE;
    PVOID MsgHandlerContext = NULL;
    BOOL b = FALSE;
    DWORD LastError = ERROR_SUCCESS;

    struct _info
    {
        FILE_COPY_INFO fci;
        SOURCE_INFO si;

    }* pinfo = NULL;

    PSOURCE_INFO psi;



    ASSERT(FileName != NULL);

    //
    // allocate SOURCE_INFO and FILE_COPY_INFO in the heap to minimize stack use
    // note that the memory is zeroed by MemAlloc
    //

    pinfo = (struct _info*) MemAlloc(sizeof(*pinfo));

    if(NULL == pinfo)
    {
        LastError = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrint( LVL_MINIMAL, L"Not enough memory in function SfcRestoreFileFromInstallMedia" );
        goto exit;
    }

    //
    // get the source information for the first file
    //

    if (!SfcGetSourceInformation( SourceFileName == NULL ? FileName : SourceFileName, InfName, ExcepPackFile, &pinfo->si )) {
        goto exit;
    }

    //
    // create a file queue
    //

    hFileQ = SetupOpenFileQueue();
    if (hFileQ == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        DebugPrint1( LVL_MINIMAL, L"SetupOpenFileQueue failed, ec=%d", LastError );
        b = FALSE;
        goto exit;
    }

    //
    // add the file(s) to the queue
    //
    // at this time we know where to copy the files from and the media is
    // present and available, but more files may have been queued up while
    // we performed this effort and possibly spent a long time prompting
    // the user for media.  because of this we need to examine the queue and
    // queue up all file copies so the user only gets one prompt.
    //
    // Old note:
    //     there may be a problem with this because we could have a situation
    //     where there are multiple file copies from different media.  this
    //     could happen in the case of a service pack or a winpack.
    //
    // New note: (andrewr) setupapi is smart enough to copy one media's worth of files
    // before copying the other media's files, so the prior concern isn't valid
    //

    b = SfcAddFileToQueue(
                         hFileQ,
                         FileName,
                         TargetFileName,
                         TargetDirectory,
                         SourceFileName,
                         NULL,
                         InfName,
                         ExcepPackFile,
                         &pinfo->si
                         );
    if (!b) {
        goto exit;
    }

    //
    // setup the default queue callback with the popups disabled
    //

    MsgHandlerContext = SetupInitDefaultQueueCallbackEx( NULL, INVALID_HANDLE_VALUE, 0, 0, 0 );
    if (MsgHandlerContext == NULL) {
        LastError = GetLastError();
        DebugPrint1( LVL_MINIMAL, L"SetupInitDefaultQueueCallbackEx failed, ec=%d", LastError );
        goto exit;
    }

    //
    // Note: There can be more than one SOURCE_INFO for the entire queue, so
    // this code is not strictly correct.  But this is really only a problem
    // in the case that we have to prompt the user for media.  This will
    // really work itself out in the NEED_MEDIA callback when we are actually
    // trying to copy the file.
    //
    pinfo->fci.MsgHandlerContext = MsgHandlerContext;
    pinfo->fci.si = &psi;
    pinfo->fci.FileCount = 1;
    psi = &pinfo->si;

    pinfo->si.ValidationRequestData = vrd;
    pinfo->fci.AllowUI = AllowUI;

    pinfo->fci.Flags |= TargetIsCache
                 ? FCI_FLAG_COPY_TO_CACHE
                 : FCI_FLAG_RESTORE_FILE;

    //
    // force the file queue to require all files be signed
    //

    pSetupSetQueueFlags( hFileQ, pSetupGetQueueFlags( hFileQ ) | FQF_QUEUE_FORCE_BLOCK_POLICY );

    //
    // commit the file queue
    //

    b = SetupCommitFileQueue(
                            NULL,
                            hFileQ,
                            SfcQueueCallback,
                            &pinfo->fci
                            );
    if (!b) {
        LastError = GetLastError();
        DebugPrint1( LVL_MINIMAL, L"SetupCommitFileQueue failed, ec=0x%08x", LastError );
    }

    if (UIShown) {
        *UIShown = pinfo->fci.UIShown;
    }

    exit:

    //
    // cleanup and exit
    //

    if (MsgHandlerContext) {
        SetupTermDefaultQueueCallback( MsgHandlerContext );
    }
    if (hFileQ != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue( hFileQ );
    }

    if(pinfo != NULL)
    {
        MemFree(pinfo);
    }

    SetLastError( LastError );
    return b;
}

BOOL
SfcRestoreFromCache(
                   IN PVALIDATION_REQUEST_DATA vrd,
                   IN HCATADMIN hCatAdmin
                   )
/*++

Routine Description:

    Routine takes a validated file and attempts to restore it from the cache.

    The routine also does some extra book-keeping tasks, like syncing up the
    copy of the dllcache file with that on disk

Arguments:

    vrd - pointer to VALIDATION_REQUEST_DATA structure describing the file to
          be restored.
    hCatAdmin - crypto context handle to be used in checking file

Return Value:

    always TRUE (indicates we successfully validated the DLL as good or bad)

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSFC_REGISTRY_VALUE RegVal = vrd->RegVal;
    PCOMPLETE_VALIDATION_DATA ImageValData = &vrd->ImageValData;
    UNICODE_STRING ActualFileName;
    PWSTR FileName;

    //
    // if the original file isn't present, then we should try to restore it
    // from cache
    //
    if (!ImageValData->Original.SignatureValid) {

        //
        // bad signature
        //

        DebugPrint1( LVL_MINIMAL,
                     L"%wZ signature is BAD, try to restore file from cache",
                     &RegVal->FileName );

        //
        // we always try to restore from cache first, even if there isn't a
        // file in the cache
        //

        ImageValData->RestoreFromCache = TRUE;
        ImageValData->NotifyUser = TRUE;
        if (!vrd->SyncOnly) {
            ImageValData->EventLog = MSG_DLL_CHANGE;
        }
    } else {

        //
        // good signature, let's do some book-keeping here to sync up the
        // file in the dllcache with that on disk
        //


        if (ImageValData->Original.FilePresent == TRUE && ImageValData->Cache.FilePresent == FALSE) {
            //
            // the file is missing from the cache but the original file has
            // a valid signature...
            // so we put the original file into the cache
            //

            //
            // Note that this doesn't really consider the SFCQuota policy, but
            // it's only one file, so we assume that we won't blow the cache
            // quota.
            //
            DebugPrint1( LVL_MINIMAL, L"Cache file doesn't exist; restoring from real - %wZ", &RegVal->FileName );
            ImageValData->RestoreFromReal = TRUE;
            ImageValData->NotifyUser = FALSE;
            ImageValData->EventLog = 0;
            vrd->SyncOnly = TRUE;
        } else {
            //
            // it looks like both files are present and are valid,
            // but we want to resynch the cach copy because someone
            // may have replaced the real file with a new, valid signed
            // file and now the cached copy doesn't match.
            //
            DebugPrint1( LVL_MINIMAL, L"Real file and cache are both present and valid, replace cache with newer - %wZ", &RegVal->FileName );
            ImageValData->RestoreFromReal = TRUE;
            ImageValData->NotifyUser = FALSE;
            ImageValData->EventLog = 0;
            vrd->SyncOnly = TRUE;
        }
    }

    if (ImageValData->RestoreFromCache || ImageValData->RestoreFromReal) {
        if (ImageValData->RestoreFromReal) {
            //
            // put the real file back in the cache
            //

            FileName = FileNameOnMedia( RegVal );
            RtlInitUnicodeString( &ActualFileName, FileName );

            ASSERT(FileName != NULL);
            ASSERT(RegVal->DirHandle != NULL);
            ASSERT(SfcProtectedDllFileDirectory != NULL);

            Status = SfcCopyFile(
                                RegVal->DirHandle,
                                RegVal->DirName.Buffer,
                                SfcProtectedDllFileDirectory,
                                NULL,
                                &ActualFileName,
                                &RegVal->FileName
                                );
            if (NT_SUCCESS(Status)) {
                SfcGetValidationData( &RegVal->FileName,
                                      &RegVal->FullPathName,
                                      RegVal->DirHandle,
                                      hCatAdmin,
                                      &ImageValData->New );

                if (ImageValData->New.SignatureValid == FALSE) {
                    ImageValData->New.DllVersion = 0;
                }

                if ((SFCDisable != SFC_DISABLE_SETUP) && (vrd->SyncOnly == FALSE)) {
                    SfcReportEvent( ImageValData->EventLog, RegVal->FullPathName.Buffer, ImageValData, 0 );
                }
                vrd->CopyCompleted = TRUE;

            } else {
                SfcReportEvent( MSG_CACHE_COPY_ERROR, RegVal->FullPathName.Buffer, ImageValData, GetLastError() );
            }
        } else { // restorefromcache == TRUE

            //
            // we need to put the cache copy back
            // but only if the cache version is valid
            //
            if (ImageValData->Cache.FilePresent && ImageValData->Cache.SignatureValid) {

                FileName = FileNameOnMedia( RegVal );
                RtlInitUnicodeString( &ActualFileName, FileName );

                ASSERT(FileName != NULL);
                ASSERT(SfcProtectedDllFileDirectory != NULL);
                ASSERT(RegVal->DirHandle != NULL);

                Status = SfcCopyFile(
                                    SfcProtectedDllFileDirectory,
                                    SfcProtectedDllPath.Buffer,
                                    RegVal->DirHandle,
                                    RegVal->DirName.Buffer,
                                    &RegVal->FileName,
                                    &ActualFileName
                                    );

                if (NT_SUCCESS(Status)) {
                    vrd->CopyCompleted = TRUE;
                    ImageValData->NotifyUser = TRUE;

                    if (!vrd->SyncOnly) {
                        ImageValData->EventLog = MSG_DLL_CHANGE;
                    }

                    SfcGetValidationData(
                                        &RegVal->FileName,
                                        &RegVal->FullPathName,
                                        RegVal->DirHandle,
                                        hCatAdmin,
                                        &ImageValData->New );

                    if (ImageValData->New.SignatureValid == FALSE) {
                        ImageValData->New.DllVersion = 0;
                    }

                    if (vrd->SyncOnly == FALSE) {
                        SfcReportEvent(
                            ImageValData->EventLog,
                            RegVal->FullPathName.Buffer,
                            ImageValData,
                            0 );
                    }


                } else {
                    //
                    // we failed to copy the file from the cache so we have
                    // to restore from media
                    //
                    ImageValData->RestoreFromMedia = TRUE;
                    ImageValData->NotifyUser = TRUE;
                    if (!vrd->SyncOnly) {
                        ImageValData->EventLog = MSG_DLL_CHANGE;
                    }
                }
            } else {
                //
                // need to restore from cache but the cache copy is missing
                // or invalid.  Clear the crud out of the cache
                //
                FileName = FileNameOnMedia( RegVal );
                RtlInitUnicodeString( &ActualFileName, FileName );


                DebugPrint2( LVL_MINIMAL,
                             L"Cannot restore file from the cache because the "
                             L"cache file [%wZ] is invalid - %wZ ",
                             &ActualFileName,
                             &RegVal->FileName );
                ImageValData->BadCacheEntry = TRUE;
                ImageValData->NotifyUser = TRUE;
                if (!vrd->SyncOnly) {
                    ImageValData->EventLog = MSG_DLL_CHANGE;
                }
                ImageValData->RestoreFromMedia = TRUE;
                SfcDeleteFile(
                             SfcProtectedDllFileDirectory,
                             &ActualFileName );
                SfcReportEvent(
                              ImageValData->EventLog,
                              RegVal->FullPathName.Buffer,
                              ImageValData,
                              0 );
            }
        }
        if (!NT_SUCCESS(Status)) {
            DebugPrint1( LVL_MINIMAL,
                         L"Failed to restore a file from the cache - %wZ",
                         &RegVal->FileName );
        }
    }

    return TRUE;
}


BOOL
SfcSyncCache(
            IN PVALIDATION_REQUEST_DATA vrd,
            IN HCATADMIN hCatAdmin
            )
/*++

Routine Description:

    Routine takes a validated file and attempts to sync a copy of the file in
    the cache.

Arguments:

    vrd - pointer to VALIDATION_REQUEST_DATA structure describing the file to
          be synced.
    hCatAdmin - crypto context handle to be used in checking file

Return Value:

    TRUE indicates we successfully sunc a copy in the dllcache

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSFC_REGISTRY_VALUE RegVal = vrd->RegVal;
    PCOMPLETE_VALIDATION_DATA ImageValData = &vrd->ImageValData;
    UNICODE_STRING ActualFileName;
    PWSTR FileName;


    //
    // caller should ensure that the signature is valid before proceeding
    //
    ASSERT(ImageValData->Original.SignatureValid == TRUE);

    //
    // if there is a copy in the dllcache already, let's assume that there is
    // enough space to sync the new copy of the file.  Otherwise we have to
    // ensure that there is reasonable space before proceeding.
    //
    //
    if (vrd->ImageValData.Cache.FilePresent == TRUE) {
        ImageValData->RestoreFromReal = TRUE;
        ImageValData->NotifyUser = FALSE;
        ImageValData->EventLog = 0;
        vrd->SyncOnly = TRUE;
    } else {

        ULONGLONG RequiredFreeSpace;
        ULARGE_INTEGER FreeBytesAvailableToCaller;
        ULARGE_INTEGER TotalNumberOfBytes;
        ULARGE_INTEGER TotalNumberOfFreeBytes;

        //
        // The file is not in the cache.
        //
        RequiredFreeSpace = (GetPageFileSize() + SFC_REQUIRED_FREE_SPACE)* ONE_MEG;

        //
        // see
        // a) how much space we have left
        // b) compare against our free space buffer
        // c) how much space the cache is using
        // d) compare against our cache quota
        //
        // if these all succeed, then we're allowed to copy the file into
        // the cache
        //
        if (GetDiskFreeSpaceEx(
                        SfcProtectedDllPath.Buffer,
                        &FreeBytesAvailableToCaller,
                        &TotalNumberOfBytes,
                        &TotalNumberOfFreeBytes)
            && TotalNumberOfFreeBytes.QuadPart > RequiredFreeSpace) {
            if (TotalNumberOfBytes.QuadPart <= SFCQuota) {
                ImageValData->RestoreFromReal = TRUE;
                ImageValData->NotifyUser = FALSE;
                ImageValData->EventLog = 0;
                vrd->SyncOnly = TRUE;
            }else {
                DebugPrint1( LVL_MINIMAL,
                             L"quota is exceeded (%I64d), can't copy new files",
                             TotalNumberOfBytes);
                Status = STATUS_QUOTA_EXCEEDED;
            }
        } else {
            DebugPrint1( LVL_MINIMAL,
                         L"Not enough free space on disk (%I64d), can't copy new files",
                         TotalNumberOfBytes.QuadPart);
            Status = STATUS_QUOTA_EXCEEDED;
        }
    }

    //
    // if we were told to copy the file above, then do it.
    //
    if (ImageValData->RestoreFromReal) {
        //
        // put the real file back in the cache
        //

        FileName = FileNameOnMedia( RegVal );
        RtlInitUnicodeString( &ActualFileName, FileName );

        ASSERT(FileName != NULL);
        ASSERT(RegVal->DirHandle != NULL);
        ASSERT(SfcProtectedDllFileDirectory != NULL);

        Status = SfcCopyFile(
                            RegVal->DirHandle,
                            RegVal->DirName.Buffer,
                            SfcProtectedDllFileDirectory,
                            SfcProtectedDllPath.Buffer,
                            &ActualFileName,
                            &RegVal->FileName
                            );
        if (NT_SUCCESS(Status)) {
            WCHAR FullPathToFile[MAX_PATH];
            UNICODE_STRING FullPathToCacheFile;

            wcscpy(FullPathToFile,SfcProtectedDllPath.Buffer);
            pSetupConcatenatePaths(
                FullPathToFile,
                ActualFileName.Buffer,
                UnicodeChars(FullPathToFile), NULL );
            RtlInitUnicodeString( &FullPathToCacheFile, FullPathToFile );

            SfcGetValidationData( &ActualFileName,
                                  &FullPathToCacheFile,
                                  SfcProtectedDllFileDirectory,
                                  hCatAdmin,
                                  &ImageValData->New );

            //
            // since we started with a valid file, we had better end up with
            // a valid file installed
            //
            if(ImageValData->New.SignatureValid == TRUE) {

                vrd->CopyCompleted = TRUE;

            } else {
                ImageValData->New.DllVersion = 0;
                SfcReportEvent( MSG_CACHE_COPY_ERROR, RegVal->FullPathName.Buffer, ImageValData, GetLastError() );
                Status = STATUS_UNSUCCESSFUL;
            }
        } else {
            SfcReportEvent( MSG_CACHE_COPY_ERROR, RegVal->FullPathName.Buffer, ImageValData, GetLastError() );
        }
    }

    return (NT_SUCCESS(Status));

}



PSOURCE_INFO
pSfcGetSourceInfoFromSourceName(
                               const PSOURCE_INFO *SourceInfoList,
                               DWORD         SourceInfoCount,
                               const PSOURCE_MEDIA SourceMediaInfo
                               )
{
    DWORD i;
    PSOURCE_INFO SourceInfo;

    ASSERT( SourceInfoList != NULL );
    ASSERT( SourceInfoCount > 0 );
    ASSERT( SourceMediaInfo != NULL );

    if (ShuttingDown) {
        return NULL;
    }

    i = 0;
    while (i < SourceInfoCount) {

        SourceInfo = SourceInfoList[i];

        ASSERT(SourceInfo != NULL);

        if (_wcsicmp(
                    SourceInfo->SourceFileName,
                    SourceMediaInfo->SourceFile) == 0) {
            return (SourceInfo);
        }

        i += 1;

    }

    return (NULL);

}

PVALIDATION_REQUEST_DATA
pSfcGetValidationRequestFromFilePaths(
                                     const PSOURCE_INFO *SourceInfoList,
                                     DWORD         SourceInfoCount,
                                     const PFILEPATHS FilePaths
                                     )
{
    DWORD i;
    PSOURCE_INFO SourceInfo;
    PCWSTR p;

    ASSERT( SourceInfoList != NULL );
    ASSERT( SourceInfoCount > 0 );
    ASSERT( FilePaths != NULL );

    if (ShuttingDown) {
        return NULL;
    }

    i = 0;
    while (i < SourceInfoCount) {

        SourceInfo = SourceInfoList[i];

        ASSERT(SourceInfo != NULL);

        if (SourceInfo->ValidationRequestData) {
            p = SourceInfo->ValidationRequestData->RegVal->FullPathName.Buffer;

            if (_wcsicmp(
                        p,
                        FilePaths->Target) == 0) {
                return (SourceInfo->ValidationRequestData);
            }
        }

        i += 1;

    }

    return (NULL);

}


BOOL
SfcQueueAddFileToRestoreQueue(
                             IN BOOL RequiresUI,
                             IN PSFC_REGISTRY_VALUE RegVal,
                             IN PCWSTR InfFileName,
                             IN BOOL ExcepPackFile,
                             IN OUT PSOURCE_INFO SourceInfo,
                             IN PCWSTR ActualFileNameOnMedia
                             )
/*++

Routine Description:

    This routine tries to add a file to the appropriate global file queue.

    If the queue is being commited, then this routine fails.

    If the file queue does not yet exist, the queue is created.

Arguments:

    RequiresUI            - if TRUE, the file will require UI in order to be
                            installed
    RegVal                - pointer to SFC_REGISTRY_VALUE that describes file
                            to be restored
    SourceInfo            - pointer to SOURCE_INFO structure describing where
                            the source file is to be restored from
    ActualFileNameOnMedia - the real filename of the file on the source media

Return Value:

    TRUE if the file was added to the queue, else FALSE.

--*/
{
    PRESTORE_QUEUE RestoreQueue;
    BOOL RetVal = FALSE;
    PVOID Ptr;

    ASSERT( SourceInfo != NULL );
    ASSERT( SourceInfo->SourceFileName[0] != (TCHAR)'\0' );

    //
    // point to the proper global queue
    //
    RestoreQueue = RequiresUI
                   ? &UIRestoreQueue
                   : &SilentRestoreQueue;

    //
    // must protect all of this in a critical section
    //
    RtlEnterCriticalSection( &RestoreQueue->CriticalSection );

    //
    // if the queue is in progress, we can't do anything
    //
    if (!RestoreQueue->RestoreInProgress) {
        //
        // create the queue if it doesn't already exist
        //
        if (RestoreQueue->FileQueue == INVALID_HANDLE_VALUE) {
            RestoreQueue->FileQueue = SetupOpenFileQueue();
            if (RestoreQueue->FileQueue == INVALID_HANDLE_VALUE) {
                DebugPrint1(
                           LVL_MINIMAL,
                           L"SetupOpenFileQueue() failed, ec=%d",
                           GetLastError() );
                goto exit;
            }

            //
            // also preallocate nothing to make re-allocating easy
            //
            ASSERT(RestoreQueue->FileCopyInfo.si == NULL);
            RestoreQueue->FileCopyInfo.si = MemAlloc( 0 );

        }

        ASSERT(RestoreQueue->FileQueue != INVALID_HANDLE_VALUE);

        //
        // now make more room in our array of PSOURCE_INFO pointers
        // for the new entry in our queue and assign that entry.
        //
        Ptr = MemReAlloc(
                        ((RestoreQueue->QueueCount + 1) * sizeof(PSOURCE_INFO)),
                        RestoreQueue->FileCopyInfo.si );

        if (Ptr) {
            RestoreQueue->FileCopyInfo.si = (PSOURCE_INFO *)Ptr;
            RestoreQueue->FileCopyInfo.si[RestoreQueue->QueueCount] = SourceInfo;
        } else {
            MemFree( (PVOID) RestoreQueue->FileCopyInfo.si );
            goto exit;
        }

        //
        // add the file to the queue
        //
        RetVal = SfcAddFileToQueue(
                                  RestoreQueue->FileQueue,
                                  RegVal->FileName.Buffer,
                                  RegVal->FileName.Buffer,
                                  RegVal->DirName.Buffer,
                                  ActualFileNameOnMedia,
                                  NULL,
                                  InfFileName,
                                  ExcepPackFile,
                                  SourceInfo
                                  );

        if (!RetVal) {
            DebugPrint2(
                       LVL_MINIMAL,
                       L"SfcAddFileToQueue failed [%ws], ec = %d",
                       RegVal->FileName.Buffer,
                       GetLastError() );
        } else {
            RestoreQueue->QueueCount += 1;
            //
            // remember something about adding this entry so that
            // when we commit the file we how to treat it
            //
            SourceInfo->Flags |= SI_FLAG_USERESTORE_QUEUE
                                 | (RequiresUI ? 0 : SI_FLAG_SILENT_QUEUE) ;

            DebugPrint2(
                       LVL_MINIMAL,
                       L"Added file [%ws] to %ws queue for restoration",
                       RegVal->FileName.Buffer,
                       RequiresUI ? L"UIRestoreQueue" : L"SilentRestoreQueue" );


        }
    }

    exit:

    RtlLeaveCriticalSection( &RestoreQueue->CriticalSection );

    return RetVal;

}

BOOL
SfcQueueResetQueue(
                  IN BOOL RequiresUI
                  )
/*++

Routine Description:

    This routine is called after we've successfully committed the file queue.

    The routine removes all of the associated validation requests from our
    queue, logging entries for each of these requests.  It also cleans up the
    global file queue to be processed again.

    If the queue has not been commited, then this routine fails.

Arguments:

    RequiresUI            - if TRUE, the file will require UI in order to be
                            installed

Return Value:

    TRUE if the routine succeeded, else FALSE.

--*/
{
    PRESTORE_QUEUE RestoreQueue;
    BOOL RetVal = FALSE;
    DWORD Count;
    PLIST_ENTRY Current;
    PVALIDATION_REQUEST_DATA vrd;
    DWORD Mask;
    BOOL DoReset = FALSE;
    DWORD Msg, ErrorCode;

    //
    // point to the proper global queue
    //
    RestoreQueue = RequiresUI
                   ? &UIRestoreQueue
                   : &SilentRestoreQueue;



    Mask = (VRD_FLAG_REQUEST_PROCESSED | VRD_FLAG_REQUEST_QUEUED)
           | (RequiresUI ? VRD_FLAG_REQUIRE_UI : 0);

    //
    // must protect all of this in a critical section
    //
    RtlEnterCriticalSection( &RestoreQueue->CriticalSection );

    if ((RestoreQueue->RestoreInProgress == TRUE) &&
        (RestoreQueue->RestoreComplete == TRUE)) {
        DoReset = TRUE;
    }

    if (DoReset) {

        RtlEnterCriticalSection( &ErrorCs );

        Current = SfcErrorQueue.Flink;
        Count = 0;

        //
        // cycle through our queue, logging and removing requests as we go.
        //
        while (Current != &SfcErrorQueue) {
            vrd = CONTAINING_RECORD( Current, VALIDATION_REQUEST_DATA, Entry );

            Current = vrd->Entry.Flink;

            //
            // check if we have a valid entry
            //

            if (vrd->Flags == Mask) {
                Count += 1;

#if 0
                //
                // if the file was copied successfully, then we'd better make
                // sure that the signature of the file is valid
                //
                // if the file failed to be copied, then we'd better have a
                // reason why it failed to be copied
                //
                ASSERT(vrd->CopyCompleted
                       ? (vrd->ImageValData.New.SignatureValid == TRUE)
                       && (vrd->ImageValData.EventLog == MSG_DLL_CHANGE)
                       : (RestoreQueue->LastErrorCode == ERROR_SUCCESS)
                       ? ((vrd->ImageValData.EventLog == MSG_RESTORE_FAILURE)
                          && (vrd->Win32Error != ERROR_SUCCESS))
                       : TRUE );
#endif

                if (vrd->CopyCompleted && vrd->ImageValData.New.SignatureValid == FALSE) {
                    vrd->ImageValData.New.DllVersion = 0;
                }

                DebugPrint2(
                           LVL_MINIMAL,
                           L"File [%ws] %ws restored successfully.",
                           vrd->RegVal->FullPathName.Buffer,
                           vrd->CopyCompleted ? L"was" : L"was NOT"
                           );

                //
                // log an event
                //
                // first determine if we need to tweak the error code if the
                // user cancelled, then log the event
                //
                ErrorCode = vrd->Win32Error;
                Msg = vrd->ImageValData.EventLog;

                if (RestoreQueue->LastErrorCode != ERROR_SUCCESS) {
                    if (RestoreQueue->LastErrorCode == ERROR_CANCELLED) {
                        if ((vrd->Win32Error == ERROR_SUCCESS)
                            && (vrd->CopyCompleted == FALSE) ) {
                            ErrorCode = ERROR_CANCELLED;
                            Msg = SFCNoPopUps ? MSG_COPY_CANCEL_NOUI : MSG_COPY_CANCEL;
                        }
                    } else {
                        if ((vrd->Win32Error == ERROR_SUCCESS)
                            && (vrd->CopyCompleted == FALSE) ) {
                            ErrorCode = RestoreQueue->LastErrorCode;
                            Msg = MSG_RESTORE_FAILURE;
                        } else if (Msg == 0) {
                            Msg = MSG_RESTORE_FAILURE;
                        }
                    }
                }

                ASSERT(Msg != 0);
                if (Msg == 0) {
                    Msg = MSG_RESTORE_FAILURE;
                }

                //
                // log the event
                //
                SfcReportEvent(
                              Msg,
                              vrd->RegVal->FileName.Buffer,
                              &vrd->ImageValData,
                              ErrorCode );

                //
                // remove the entry
                //

                RemoveEntryList( &vrd->Entry );
                ErrorQueueCount -= 1;
                MemFree( vrd );

            }

        }

        RtlLeaveCriticalSection( &ErrorCs );

        ASSERT( Count == RestoreQueue->QueueCount );

        CloseHandle( RestoreQueue->WorkerThreadHandle );
        RestoreQueue->WorkerThreadHandle = NULL;
        RestoreQueue->RestoreComplete = FALSE;
        RestoreQueue->QueueCount = 0;
        SetupCloseFileQueue( RestoreQueue->FileQueue );
        RestoreQueue->FileQueue = INVALID_HANDLE_VALUE;
        RestoreQueue->RestoreInProgress = FALSE;
        RestoreQueue->RestoreStatus = FALSE;
        RestoreQueue->LastErrorCode = ERROR_SUCCESS;
        SetupTermDefaultQueueCallback( RestoreQueue->FileCopyInfo.MsgHandlerContext );
        MemFree((PVOID)RestoreQueue->FileCopyInfo.si);
        ZeroMemory( &RestoreQueue->FileCopyInfo, sizeof(FILE_COPY_INFO) );

    }

    RtlLeaveCriticalSection( &RestoreQueue->CriticalSection );

    return ( RetVal );

}


BOOL
SfcQueueCommitRestoreQueue(
                          IN BOOL RequiresUI
                          )
/*++

Routine Description:

    This routine tries to add a file to the appropriate global file queue.

    If the queue is being commited, then this routine fails.

    If the file queue does not yet exist, the queue is created.

Arguments:

    RequiresUI            - if TRUE, the file will require UI in order to be
                            installed
    RegVal                - pointer to SFC_REGISTRY_VALUE that describes file
                            to be restored
    SourceInfo            - pointer to SOURCE_INFO structure describing where
                            the source file is to be restored from
    ActualFileNameOnMedia - the real filename of the file on the source media

Return Value:

    TRUE if the file was added to the queue, else FALSE.

--*/
{
    PRESTORE_QUEUE RestoreQueue;
    BOOL RetVal = FALSE;
    BOOL DoCommit = FALSE;

    //
    // point to the proper global queue
    //
    RestoreQueue = RequiresUI
                   ? &UIRestoreQueue
                   : &SilentRestoreQueue;

    //
    // we must protect our restore queue access in a critical section
    //
    RtlEnterCriticalSection( &RestoreQueue->CriticalSection );

    //
    // see if we should commit the queue
    //
    if (    (RestoreQueue->RestoreInProgress == FALSE)
            && (RestoreQueue->RestoreComplete == FALSE)
            && (RestoreQueue->QueueCount > 0)) {
        ASSERT(RestoreQueue->FileQueue != INVALID_HANDLE_VALUE );
        RestoreQueue->RestoreInProgress = TRUE;
        DoCommit = TRUE;
    }

    if (DoCommit) {
        DebugPrint1( LVL_MINIMAL,
                     L"Creating pSfcRestoreFromMediaWorkerThread for %ws queue",
                     RequiresUI ? L"UIRestoreQueue" : L"SilentRestoreQueue" );

        RestoreQueue->WorkerThreadHandle = CreateThread(
                                                       NULL,
                                                       0,
                                                       (LPTHREAD_START_ROUTINE)pSfcRestoreFromMediaWorkerThread,
                                                       RestoreQueue,
                                                       0,
                                                       NULL
                                                       );

        if (!RestoreQueue->WorkerThreadHandle) {
            DebugPrint1( LVL_MINIMAL,
                         L"Couldn't create pSfcRestoreFromMediaWorkerThread, ec = 0x%08x",
                         GetLastError() );
            RestoreQueue->RestoreInProgress = FALSE;
        }
    }

    RtlLeaveCriticalSection( &RestoreQueue->CriticalSection );

    return ( RetVal );

}


DWORD
pSfcRestoreFromMediaWorkerThread(
                                IN PRESTORE_QUEUE RestoreQueue
                                )
/*++

Routine Description:

    Routine takes a media queue that is ready for committal and commits
    that queue to disk.

    We require another thread to do the actual queue commital for 2
    reasons:

    a) we want to keep servicing change requests as they come in (for example,
    if we have to prompt for UI for some requests and not for others, we can
    commit the requests which do not require UI while we wait for media to
    become present to commit the files which require UI

    b) it makes terminating our valiation thread much easier if we know that we
    will never have popups on the screen as a result of that thread.  We can
    simply signal an event for that thread to go away, which can then signal
    these worker threads to go away.

Arguments:

    RestoreQueue - pointer to a RESTORE_QUEUE structure which describes the
                   queue to be committed.

Return Value:

    N/A.

--*/
{
    BOOL RetVal;
    PVOID MsgHandlerContext = NULL;
    BOOL RequiresUI;

    RequiresUI = (RestoreQueue == &UIRestoreQueue);

    ASSERT(RestoreQueue != NULL);

#if 1
    if (RequiresUI) {
        SetThreadDesktop( hUserDesktop );
    }
#endif

    DebugPrint1( LVL_MINIMAL,
                 L"entering pSfcRestoreFromMediaWorkerThread for %ws queue",
                 RequiresUI ? L"UIRestoreQueue" : L"SilentRestoreQueue" );

    //
    // setup the default queue callback with the popups disabled
    //
    MsgHandlerContext = SetupInitDefaultQueueCallbackEx( NULL, INVALID_HANDLE_VALUE, 0, 0, 0 );
    if (MsgHandlerContext == NULL) {
        DebugPrint1( LVL_VERBOSE, L"SetupInitDefaultQueueCallbackEx failed, ec=%d", GetLastError() );
        RetVal = FALSE;
        goto exit;
    }

    //
    // build up a structure which we use in committing the queue.
    //

    RtlEnterCriticalSection( &RestoreQueue->CriticalSection );
    RestoreQueue->FileCopyInfo.MsgHandlerContext = MsgHandlerContext;
    ASSERT( RestoreQueue->FileCopyInfo.si != NULL);
    RestoreQueue->FileCopyInfo.FileCount = RestoreQueue->QueueCount;
    RestoreQueue->FileCopyInfo.AllowUI = RequiresUI;

    //
    // remember that this is a restoration queue.
    // When we commit the queue we will use this fact to mark each file in
    // our queue as processed so that we can log it and remember the
    // file signature, etc.
    //
    RestoreQueue->FileCopyInfo.Flags |= FCI_FLAG_RESTORE_FILE;
    RestoreQueue->FileCopyInfo.Flags |= FCI_FLAG_USERESTORE_QUEUE
                                        | (RequiresUI ? 0 : FCI_FLAG_SILENT_QUEUE) ;

    //
    // force the file queue to require all files be signed
    //

    pSetupSetQueueFlags( RestoreQueue->FileQueue, pSetupGetQueueFlags( RestoreQueue->FileQueue ) | FQF_QUEUE_FORCE_BLOCK_POLICY );

    RtlLeaveCriticalSection( &RestoreQueue->CriticalSection );

    //
    // commit the file queue
    //

    RetVal = SetupCommitFileQueue(
                                 NULL,
                                 RestoreQueue->FileQueue,
                                 SfcQueueCallback,
                                 &RestoreQueue->FileCopyInfo
                                 );
    if (!RetVal) {
        DebugPrint1( LVL_VERBOSE, L"SetupCommitFileQueue failed, ec=0x%08x", GetLastError() );
    }

    //
    // if we succeeded commiting the queue, mark the queue
    //
    RtlEnterCriticalSection( &RestoreQueue->CriticalSection );

    ASSERT(RestoreQueue->RestoreInProgress == TRUE);
    RestoreQueue->RestoreStatus = RetVal;
    RestoreQueue->LastErrorCode = RetVal ? ERROR_SUCCESS : GetLastError();
    RestoreQueue->RestoreComplete = TRUE;

    RtlLeaveCriticalSection( &RestoreQueue->CriticalSection );

    //
    // set an event to wake up the validation thread so it can clean things up
    //
    SetEvent( ErrorQueueEvent );

    exit:

    DebugPrint2( LVL_MINIMAL,
                 L"Leaving pSfcRestoreFromMediaWorkerThread for %ws queue, retval = %d",
                 RequiresUI ? L"UIRestoreQueue" : L"SilentRestoreQueue",
                 RetVal
               );

    return (RetVal);

}

DWORD
SfcGetCabTagFile(
    IN PSOURCE_INFO psi,
    OUT PWSTR* ppFile
    )
/*++

Routine Description:

	This function gets the tagfile of a cabfile. It is called when the tagfile for a protected file is a cabfile.
    Allocates the output buffer.

Arguments:

	psi - the protected file source info
	ppFile - receives the tagfile

Return value:

	Win32 error code

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL bExcepFile = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT uiInfo = SRCINFO_TAGFILE;

    ASSERT(psi != NULL && ppFile != NULL);
    ASSERT(psi->ValidationRequestData != NULL && psi->ValidationRequestData->RegVal != NULL);

    *ppFile = (PWSTR) MemAlloc(MAX_PATH * sizeof(WCHAR));

    if(NULL == *ppFile) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // if there is a second tagfile, then we have to use the file's inf instead of layout.inf
    //
    if((psi->SetupAPIFlags & SRC_FLAGS_CABFILE) != 0) {
        uiInfo = SRCINFO_TAGFILE2;

        if(psi->ValidationRequestData != NULL && psi->ValidationRequestData->RegVal != NULL) {
            bExcepFile = SfcGetInfName(psi->ValidationRequestData->RegVal, *ppFile);
        }
    }

    hInf = SfcOpenInf(*ppFile, bExcepFile);

    if(INVALID_HANDLE_VALUE == hInf) {
        dwError = GetLastError();
        goto exit;
    }

    if(!SetupGetSourceInfo(hInf, psi->SourceId, uiInfo, *ppFile, MAX_PATH, NULL)) {
        dwError = GetLastError();
        goto exit;
    }

exit:
    if(dwError != ERROR_SUCCESS)
    {
        MemFree(*ppFile);
        *ppFile = NULL;
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\security.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    security.c

Abstract:

    Implementation of security code.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

--*/

#include "sfcp.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\sfcp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sfcp.h

Abstract:

    Implementation of protected DLLs.

    This works by caching a set of dlls in a system directory
    and then synchronizing the cache with the target file locations.
    The process is driven by a list of protected dlls which is retrieved from a
    dll at runtime.  Each entry contains a full path to the target
    file.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:
    Andrew Ritz (andrewr) 2-Jul-1999 : added comments

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsm.h>
#include <ntlsa.h>
#include <ntrpcp.h>
#include <stdlib.h>

#include <stdio.h>
#include <string.h>

#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>

#include <elfkrnl.h>
#include <newexe.h>

#include <wincrypt.h>
#include <mscat.h>
#include <softpub.h>
#include <wintrust.h>

#include <sfcapip.h>
#include <sfcapi.h>

#include "sxsapi.h"
#include "resource.h"
#include "btree.h"
#include "msg.h"

#include "sfcfiles.h"


#pragma warning(3:4101)         // Unreferenced local variable

//
// public definitions
//
#define SFC_SHOW_REGISTRY_DATA 1
#define SFC_PROT_VERBOSE_DEBUG 1

#define FILE_NOTIFY_FLAGS (FILE_NOTIFY_CHANGE_NAME | \
                           FILE_NOTIFY_CHANGE_SIZE | \
                           FILE_NOTIFY_CHANGE_LAST_WRITE | \
                           FILE_NOTIFY_CHANGE_CREATION | \
                           FILE_NOTIFY_CHANGE_STREAM_SIZE | \
                           FILE_NOTIFY_CHANGE_STREAM_WRITE)

#if DBG

#define MYASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else

#define MYASSERT( exp )

#endif // DBG

 //
 // this is a free space buffer of 150 MB
 //
 #define SFC_REQUIRED_FREE_SPACE (600)
 #define ONE_MEG (1024*1024)


#define WATCH_BUFFER_SIZE 4096
#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))

#define SHARE_ALL         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)

//
// macros
//
#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)
#define MinToNano(_min)             SecToNano((_min)*60)

#define UnicodeChars(_var)          (sizeof(_var)/sizeof(WCHAR))
#define UnicodeLen(_var)            (wcslen(_var)*sizeof(WCHAR))
#define ARRAY_LENGTH(arr)           (sizeof(arr) / sizeof((arr)[0]))    // count of elements in an array

#define LODWORD(l)                  ((ULONG)((DWORD_PTR)(l) & 0xffffffff))
#define HIDWORD(l)                  ((ULONG)((DWORD_PTR)(l) >> 32))

#define MIN(_first,_second)         ((_first < _second) ? _first : _second)

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)

#define FileNameOnMedia(_RegVal) ( _RegVal->OriginalFileName[0]                    \
                                    ? _RegVal->OriginalFileName                    \
                                    : _RegVal->SourceFileName.Buffer               \
                                      ? _RegVal->SourceFileName.Buffer             \
                                      : _RegVal->FileName.Buffer )

#define SpecialFileNameOnMedia(_RegVal) ( _RegVal->SourceFileName.Buffer           \
                                           ? _RegVal->SourceFileName.Buffer        \
                                           : _RegVal->FileName.Buffer )


#define TAGFILE(_si) ((_si->Flags & SI_FLAG_USEDRIVER_CACHE) ? _si->DriverCabName : _si->TagFile)



#if defined(_AMD64_)
#define PLATFORM_DIR L"\\amd64"
#define PLATFORM_NAME L"amd64"
#elif defined(_X86_)
#define PLATFORM_NAME (IsNEC_98 ? L"nec98" : L"i386")
#define PLATFORM_DIR (IsNEC_98 ? L"\\nec98" : L"\\i386")
#elif defined(_IA64_)
#define PLATFORM_DIR L"\\ia64"
#define PLATFORM_NAME L"ia64"
#endif

#define SFC_INCLUDE_SUBDIRECTORY    TRUE
#define SFC_INCLUDE_ARCHSUBDIR      TRUE



#define SFC_DISABLE_QUIET           0xffffff9d  // -99
#define SFC_VRD_SIGNATURE           0x69696969  // signature value
#define SFC_QUEUE_STALL             5           // in seconds
#define SFC_QUEUE_WAIT              5           // in seconds

#define PATH_INVALID                0
#define PATH_LOCAL                  1
#define PATH_UNC                    2
#define PATH_NETWORK                3
#define PATH_CDROM                  4

#define KernelDebuggerEnabled       ((USER_SHARED_DATA->KdDebuggerEnabled&3)==3)

#define WM_WFPENDDIALOG             WM_APP+69

void
dprintf(
    IN ULONG Level,
    IN PCWSTR FileName,
    IN ULONG LineNumber,
    IN PCWSTR FormatStr,
    IN ...
    );

#define LVL_VERBOSE     10
#define LVL_MEDIUM      5
#define LVL_MINIMAL     1
#define LVL_SILENT      0

//
// must keep the call to dprintf in all builds
//

#define DebugPrint(_lvl_,_fmt_)                                             dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_)
#define DebugPrint1(_lvl_,_fmt_,_arg1_)                                     dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_)
#define DebugPrint2(_lvl_,_fmt_,_arg1_,_arg2_)                              dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_)
#define DebugPrint3(_lvl_,_fmt_,_arg1_,_arg2_,_arg3_)                       dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3_)
#define DebugPrint4(_lvl_,_fmt_,_arg1_,_arg2_,_arg3,_arg4_)                 dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3, _arg4_)
#define DebugPrint5(_lvl_,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5_)         dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5_)
#define DebugPrint6(_lvl_,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6_)  dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6_)
#define DebugPrint7(_lvl_,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6, _arg7_)  dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6, _arg7_)
#define DebugPrint8(_lvl_,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6, _arg7_, _arg8_)  dprintf(_lvl_,TEXT(__FILE__),__LINE__,_fmt_,_arg1_,_arg2_,_arg3, _arg4, _arg5, _arg6, _arg7_, _arg8_)

//
// this hash function was taken from the ntfs driver
//

#define FILENAME_STRING_CONVERT_CONSTANT   314159269    // default value for "scrambling constant"
#define FILENAME_STRING_PRIME              1000000007   // prime number, also used for scrambling

#define HASH_DYN_CONVERT_KEY(_pustr,_len,_phash) \
    { \
        PCWSTR _p = _pustr; \
        PCWSTR _ep = _p + _len; \
        ULONG _chHolder =0; \
        while( _p < _ep ) { \
            _chHolder = 37 * _chHolder + (unsigned int) (*_p++); \
        } \
        *(_phash) = abs(FILENAME_STRING_CONVERT_CONSTANT * _chHolder) % FILENAME_STRING_PRIME; \
    }

#define PARENT_WND_CLASS                L"SFC Parent Window Class"
#define SFC_RPC_ENDPOINT                L"SfcApi"

#define REGKEY_WINLOGON                 L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define REGKEY_WINLOGON_WIN32           L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define REGKEY_SAFEBOOT                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Safeboot\\Option"
#define REGKEY_POLICY                   L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows NT\\Windows File Protection"
#define REGKEY_POLICY_SETUP             L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows NT\\Setup"
#define REGKEY_SETUP_FULL               L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define REGKEY_SETUP                    L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define REGKEY_WINDOWS                  L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion"
#define REGKEY_SESSIONMANAGERSFC        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\SFC"
#define REGKEY_SESSIONMANAGER           L"System\\CurrentControlSet\\Control\\Session Manager"

#define REGVAL_SFCDEBUG                 L"SfcDebug"
#define REGVAL_SFCDISABLE               L"SfcDisable"
#define REGVAL_SFCSCAN                  L"SfcScan"
#define REGVAL_SFCQUOTA                 L"SfcQuota"
#define REGVAL_SFCSHOWPROGRESS          L"SfcShowProgress"
#ifdef SFCLOGFILE
#define REGVAL_SFCCHANGELOG             L"SfcChangeLog"
#endif
#define REGVAL_SFCSTALL                 L"SfcStall"
#define REGVAL_SFCDLLCACHEDIR           L"SfcDllCacheDir"
#define REGVAL_OPTIONVALUE              L"OptionValue"
#define REGVAL_SOURCEPATH               L"SourcePath"
#define REGVAL_SERVICEPACKSOURCEPATH    L"ServicePackSourcePath"
#define REGVAL_DRIVERCACHEPATH          L"DriverCachePath"
#define REGVAL_PENDINGFILERENAMES       L"PendingFileRenameOperations"
#define REGVAL_WFPPENDINGUPDATES        L"SfcPendingUpdates"

// this is used by the system restore
#define REGVAL_SFCRESTORED              L"SFCRestored"

// the path to the log file
#define REGVAL_SFCLOGFILE                L"SFCLogFile"
#define REGVAL_SFCLOGFILE_DEFAULT        L"%systemroot%\\SFCLog.txt"

#define DLLCACHE_DIR_DEFAULT            L"%SystemRoot%\\system32\\DllCache"

typedef struct _SOURCE_INFO {
    WCHAR               SourceFileName[MAX_PATH];
    WCHAR               SourceRootPath[MAX_PATH];
    WCHAR               SourcePath[MAX_PATH];
    WCHAR               TagFile[MAX_PATH];
    WCHAR               Description[MAX_PATH];
    ULONG               SetupAPIFlags;
    UINT                SourceId;
    DWORD               Flags;
    WCHAR               DriverCabName[MAX_PATH];
    struct _VALIDATION_REQUEST_DATA *ValidationRequestData;
} SOURCE_INFO, *PSOURCE_INFO;

//
// define valid flags for SOURCE_INFO.Flags
//
#define SI_FLAG_USEDRIVER_CACHE     0x00000001
#define SI_FLAG_USERESTORE_QUEUE    0x00000002
#define SI_FLAG_SILENT_QUEUE        0x00000004

typedef struct _FILE_COPY_INFO {
    PVOID               MsgHandlerContext;
    BOOL                UIShown;
    BOOL                AllowUI;
    WCHAR               NewPath[MAX_PATH*2];
    PFILEINSTALL_STATUS CopyStatus;
    HANDLE              hWnd;
    BOOL                CdRomOnly;
    DWORD               Flags;
    DWORD               FileCount;
    PSOURCE_INFO        *si;
} FILE_COPY_INFO, *PFILE_COPY_INFO;

//
// define valid flags for FILE_COPY_INFO.Flags
//
#define FCI_FLAG_USERESTORE_QUEUE    0x00000001
#define FCI_FLAG_SILENT_QUEUE        0x00000002
#define FCI_FLAG_COPY_TO_CACHE       0x00000004
#define FCI_FLAG_INSTALL_PROTECTED   0x00000008
#define FCI_FLAG_RESTORE_FILE        0x00000010

//
// This is the timeout when waitiing all WFP threads to shutdown (1 minute)
//
#define SFC_THREAD_SHUTDOWN_TIMEOUT     60000

typedef struct _PROMPT_INFO {
    PWSTR               NewPath;
    PCWSTR              SourceFileName;
    PCWSTR              SourcePath;
    PSOURCE_INFO        si;
    BOOL                NetPrompt;
    DWORD               Flags;
} PROMPT_INFO, *PPROMPT_INFO;
//
// define valid flags for PROMPT_INFO.Flags
//
#define PI_FLAG_USERESTORE_QUEUE    0x00000001
#define PI_FLAG_SILENT_QUEUE        0x00000002
#define PI_FLAG_COPY_TO_CACHE       0x00000004
#define PI_FLAG_INSTALL_PROTECTED   0x00000008
#define PI_FLAG_RESTORE_FILE        0x00000010



typedef struct _SCAN_PARAMS {
    HWND ProgressWindow;
    BOOL AllowUI;
    BOOL FreeMemory;
} SCAN_PARAMS, *PSCAN_PARAMS;


typedef struct _RESTORE_QUEUE {
    RTL_CRITICAL_SECTION    CriticalSection;
    HSPFILEQ                FileQueue;
    ULONG                   QueueCount;
    BOOL                    RestoreInProgress;
    BOOL                    RestoreComplete;
    BOOL                    RestoreStatus;
    DWORD                   LastErrorCode;
    HANDLE                  WorkerThreadHandle;
    FILE_COPY_INFO          FileCopyInfo;
} RESTORE_QUEUE, * PRESTORE_QUEUE;


//
// descibes a file's version information for display in the eventlog, etc.
//
typedef struct _FILE_VERSION_INFO {
    WORD Revision;
    WORD BuildNumber;
    WORD VersionLow;
    WORD VersionHigh;
} FILE_VERSION_INFO, *PFILE_VERSION_INFO;

//
// describes a given file on disk
//
typedef struct _IMAGE_VALIDATION_DATA {
    ULONGLONG                   DllVersion;
    ULONG                       DllCheckSum;
    BOOL                        SignatureValid;
    BOOL                        FilePresent;  // is file present on disk?
    WCHAR                       FileName[32];
} IMAGE_VALIDATION_DATA, *PIMAGE_VALIDATION_DATA;

//
// describes a file on disk, in dllcache, etc.
//
typedef struct _COMPLETE_VALIDATION_DATA {
    IMAGE_VALIDATION_DATA       Original;
    IMAGE_VALIDATION_DATA       Cache;
    IMAGE_VALIDATION_DATA       New;
    BOOL                        RestoreFromReal;
    BOOL                        RestoreFromCache;
    BOOL                        RestoreFromMedia;
    BOOL                        NotifyUser;
    BOOL                        BadCacheEntry;
    ULONG                       EventLog;
} COMPLETE_VALIDATION_DATA, *PCOMPLETE_VALIDATION_DATA;

//
// describes a given file in the system
//
typedef struct _SFC_REGISTRY_VALUE {
    LIST_ENTRY                  Entry;
    UNICODE_STRING              FileName;
    UNICODE_STRING              DirName;
    UNICODE_STRING              FullPathName;
    UNICODE_STRING              InfName;
    UNICODE_STRING              SourceFileName;
    WCHAR                       OriginalFileName[128];
    HANDLE                      DirHandle;

    //
    // This is dropped in here from WinSxs (jonwis) - tally up some
    // useful information about the directories they want to watch.
    // This should be NULL otherwise.
    //
    PVOID                       pvWinSxsCookie;

    //
    // Other flags used by the SFC/SXS interaction, specifically
    // whether or not the directory should be watched recursively
    // or not.
    //
    DWORD                       dwWinSxsFlags;

} SFC_REGISTRY_VALUE, *PSFC_REGISTRY_VALUE;

//
// describes a given directory that we're watching for changes in
//
typedef struct _DIRECTORY_WATCH_DATA {
    HANDLE                      DirHandle;
    HANDLE                      DirEvent;
    IO_STATUS_BLOCK             Iosb;
    PUCHAR                      WatchBuffer;
    PSFC_REGISTRY_VALUE         WatchDirectory;
} DIRECTORY_WATCH_DATA, *PDIRECTORY_WATCH_DATA;

//
// describes a file that needs to be replaced
//
typedef struct _VALIDATION_REQUEST_DATA {
    LIST_ENTRY                  Entry;
    ULONG                       Signature;
    COMPLETE_VALIDATION_DATA    ImageValData;
    PSFC_REGISTRY_VALUE         RegVal;

    //
    // records the source information for this
    // file
    //
    SOURCE_INFO                 SourceInfo;

    ULONG                       ChangeType;
    //
    // indicates that the file has been validated
    // and the good file copied back
    //
    BOOL                        CopyCompleted;

    //
    // indicates win32 error code if an error occurs while
    // restoring the file
    //
    DWORD                       Win32Error;

    //
    // this flag prevents the validator from logging
    // file changes when we have to put a file into the cache
    //
    BOOL                        SyncOnly;
    //
    // in case of errors we need to track the
    // count so we don't loop on one file forever
    //
    DWORD                       RetryCount;

    //
    // flags for validation request item
    //
    DWORD                       Flags;

    //
    // this value contains a tick count and is
    // used to pause the queue for a specific file.
    // this is necessary so that rename/copy operations
    // can work properly.
    //
    ULONG                       NextValidTime;


} VALIDATION_REQUEST_DATA, *PVALIDATION_REQUEST_DATA;

//
// define valid flags for VALIDATION_REQUEST_DATA.Flags
//
#define VRD_FLAG_REQUEST_PROCESSED        0x00000001
#define VRD_FLAG_REQUIRE_UI               0x00000002
#define VRD_FLAG_REQUEST_QUEUED           0x00000004


typedef struct _WATCH_THREAD_PARAMS {
    PHANDLE                 HandleList;
    DWORD                   HandleCount;
    PDIRECTORY_WATCH_DATA   DirectoryWatchList;
} WATCH_THREAD_PARAMS, *PWATCH_THREAD_PARAMS;

//
// Describes a system dialog that may be brought up.  We need a structure to keep
// track of the windows so that we can tear them down on logoff or system
// shutdown
//
typedef struct _SFC_WINDOW_DATA {
    LIST_ENTRY              Entry;
    HWND                    hWnd;
    DWORD                   ThreadId;
    //HANDLE                  hEvent;
} SFC_WINDOW_DATA, *PSFC_WINDOW_DATA;

//
// externs
//
extern PSFC_REGISTRY_VALUE SfcProtectedDllsList;
extern ULONG SfcProtectedDllCount;
extern HMODULE SfcInstanceHandle;
extern LIST_ENTRY SfcErrorQueue;
extern HANDLE ErrorQueuePort;
extern HANDLE hErrorThread;
extern HANDLE ErrorQueueEvent;
extern ULONG ErrorQueueCount;
extern HANDLE SfcProtectedDllFileDirectory;
extern RTL_CRITICAL_SECTION ErrorCs;
extern ULONG SFCDisable;
extern ULONG SFCScan;
extern ULONGLONG SFCQuota;
extern ULONG SFCNoPopUps;
extern ULONG SFCNoPopUpsPolicy;
extern WORD SFCDebugDump;
extern WORD SFCDebugLog;
extern WCHAR g_szLogFile[MAX_PATH];
#ifdef SFCLOGFILE
extern ULONG SFCChangeLog;
#endif
extern ULONG SFCStall;
extern ULONG SFCSafeBootMode;
extern HANDLE hEventDeskTop;
extern HANDLE hEventLogon;
extern HANDLE hEventLogoff;
extern UNICODE_STRING SfcProtectedDllPath;
extern LIST_ENTRY SfcWatchDirectoryList;
extern GUID DriverVerifyGuid;
extern HANDLE WatchTermEvent;
extern HANDLE ValidateTermEvent;
extern HANDLE WatcherThread;
#if DBG
extern HANDLE SfcDebugBreakEvent;
extern ULONG RunningAsTest;
#endif
extern WCHAR LoggedOnUserName[MAX_PATH];
extern BOOL UserLoggedOn;
extern HANDLE hEventScanCancel;
extern HANDLE hEventScanCancelComplete;
extern WCHAR OsSourcePath[MAX_PATH*2];
extern WCHAR ServicePackSourcePath[MAX_PATH*2];
extern WCHAR DriverCacheSourcePath[MAX_PATH*2];
extern WCHAR InfDirectory[MAX_PATH];
extern BOOL ScanInProgress;
extern HANDLE hEventSrc;
extern BOOL g_bCryptoInitialized;
extern RTL_CRITICAL_SECTION g_GeneralCS;
extern DWORD g_dwValidationThreadID;
extern DWORD m_gulAfterRestore;
extern ULONG* IgnoreNextChange;
extern ULARGE_INTEGER LastExemptionTime;

//
// This event is signalled when WFP is idle and no longer processing any
// validation requests.  An external process can synchronize on this process
// so that it knows WFP is idle before shutting down the system
//
extern HANDLE hEventIdle;

//
// set to TRUE if SFC prompted the user for credentials
//
extern BOOL SFCLoggedOn;

//
// path to the network share that we established network connection to
//
extern WCHAR SFCNetworkLoginLocation[MAX_PATH];


extern RESTORE_QUEUE  SilentRestoreQueue;
extern RESTORE_QUEUE  UIRestoreQueue;

//
// keeps track of windows that SFC creates in the system.
//
extern LIST_ENTRY SfcWindowList;

//
// handles to user's desktop and token
//
extern HDESK hUserDesktop;
extern HANDLE hUserToken;

//
// indicates if WFP can receive anymore validation requests or not.
//
extern BOOL ShuttingDown;


//
// HINSTANCE of a (possibly) loaded Sxs.dll for notification purposes
//
extern HMODULE SxsDllInstance;

//
// This function gets called back when a change is noticed in the SXS
// protected functions.
//
extern PSXS_PROTECT_NOTIFICATION SxsNotification;

//
// This function is called once to let SXS offer a list of protected
// directories.
//
extern PSXS_PROTECT_RETRIEVELISTS SxsGatherLists;

//
// Notification functions for logon/logoff events to let SXS do whatever
// they need to.
//
extern PSXS_PROTECT_LOGIN_EVENT SxsLogonEvent;
extern PSXS_PROTECT_LOGIN_EVENT SxsLogoffEvent;

//
// Single-shot scanner function to let SxS do its own scanning routine.
//
extern PSXS_PROTECT_SCAN_ONCE SxsScanForcedFunc;

//
// prototypes
//

BOOL
WINAPI
CryptCATAdminAcquireContext(
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    );

BOOL
WINAPI
CryptCATAdminReleaseContext(
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    );

BOOL
WINAPI
CryptCATAdminCalcHashFromFileHandle(
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    );

HCATINFO
WINAPI
CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    );

LONG
WINAPI
WinVerifyTrust(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    );

BOOL
WINAPI
CryptCATCatalogInfoFromContext(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
WINAPI
CryptCATAdminReleaseCatalogContext(
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    );


//
// Imports from sfcfiles.dll (loaded dynamically)
//

typedef NTSTATUS (*PSFC_GET_FILES)(
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    );


PVOID
SfcGetProcAddress(
    HMODULE hModule,
    LPSTR ProcName
    );

HMODULE
SfcLoadLibrary(
    IN PCWSTR LibFileName
    );

NTSTATUS
SfcOpenFile(
    IN PUNICODE_STRING FileName,
    IN HANDLE DirHandle,
    IN ULONG SharingFlags,
    OUT PHANDLE FileHandle
    );

HANDLE
SfcCreateDir(
    IN PCWSTR DirName,
    IN BOOL UseCompression
    );

HANDLE
SfcOpenDir(
    BOOL IsDosName,
    BOOL IsSynchronous,
    PCWSTR DirName
    );

BOOL
SfcValidateDLL(
    IN PVALIDATION_REQUEST_DATA vrd,
    IN HCATADMIN hCatAdmin
    );


BOOL
SfcValidateFileSignature(
    IN HCATADMIN hCatAdmin,
    IN HANDLE RealFileHandle,
    IN PCWSTR BaseFileName,
    IN PCWSTR CompleteFileName
    );

#if DBG
VOID
PrintHandleCount(
    PCWSTR str
    );
#endif

NTSTATUS
SfcCopyFile(
    IN HANDLE SrcDirHandle,
    IN PCWSTR SrcDirName,
    IN HANDLE DstDirHandle,
    IN PCWSTR DstDirName,
    IN const PUNICODE_STRING FileName,
    IN const PUNICODE_STRING SourceFileName OPTIONAL
    );

NTSTATUS
SfcMoveFileDelayed(
    IN PCWSTR OldFileNameDos,
    IN PCWSTR NewFileNameDos,
    IN BOOL AllowProtectedRename
    );

BOOL
SfcReportEvent(
    IN ULONG EventId,
    IN PCWSTR FileName,
    IN PCOMPLETE_VALIDATION_DATA ImageValData,
    IN DWORD LastError OPTIONAL
    );

//ULONGLONG
//SfcGetFileVersion(
//  IN HANDLE FileHandle,
//  OUT PULONG CheckSum,
//  OUT PWSTR FileName
//  );

BOOL
SfcGetFileVersion(
    IN HANDLE FileHandle,
    OUT PULONGLONG Version,
    OUT PULONG Checksum,
    OUT PWSTR FileName
    );

NTSTATUS
SfcMapEntireFile(
    IN HANDLE hFile,
    OUT PHANDLE Section,
    OUT PVOID *ViewBase,
    OUT PSIZE_T ViewSize
    );

BOOL
SfcUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    );

NTSTATUS
LoadCrypto(
    VOID
    );

NTSTATUS
SfcScanProtectedDlls(
    PSCAN_PARAMS ScanParams
    );

NTSTATUS
SfcStartProtectedDirectoryWatch(
    void
    );

BOOL
SfcBuildDirectoryWatchList(
    void
    );

NTSTATUS
SfcDeleteFile(
    HANDLE DirHandle,
    PUNICODE_STRING FileName
    );

BOOL
SfcRestoreFileFromInstallMedia(
    IN PVALIDATION_REQUEST_DATA vrd,
    IN PCWSTR FileName,
    IN PCWSTR TargetFileName,
    IN PCWSTR TargetDirectory,
    IN PCWSTR SourceFileName,
    IN PCWSTR InfName,
    IN BOOL ExcepPackFile,
    IN BOOL TargetIsCache,
    IN BOOL AllowUI,
    OUT PDWORD UIShown
    );

DWORD
MyMessageBox(
    HWND hwndParent,
    DWORD ResId,
    DWORD MsgBoxType,
    ...
    );

ULONG
SfcQueryRegDword(
    IN PCWSTR KeyNameStr,
    IN PCWSTR ValueNameStr,
    IN ULONG DefaultValue
    );

ULONG
SfcQueryRegDwordWithAlternate(
    IN PCWSTR FirstKey,
    IN PCWSTR SecondKey,
    IN PCWSTR ValueNameStr,
    IN ULONG DefaultValue
    );


PVOID
MemAlloc(
    SIZE_T AllocSize
    );

PVOID
MemReAlloc(
    SIZE_T AllocSize,
    PVOID  OrigPtr
    );


VOID
MemFree(
    PVOID MemPtr
    );

ULONG
SfcWriteRegDword(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr,
    ULONG Value
    );

ULONG
SfcWriteRegString(
    PCWSTR KeyNameStr,
    PCWSTR ValueNameStr,
    PCWSTR Value
    );

BOOL
EnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    );

PVOID
SfcFindProtectedFile(
    IN PCWSTR FileName,
    IN ULONG FileNameLength  // in characters
    );

PWSTR
SfcQueryRegString(
    IN PCWSTR KeyNameStr,
    IN PCWSTR ValueNameStr
    );

ULONG
SfcQueryRegPath(
    IN PCWSTR KeyNameStr,
    IN PCWSTR ValueNameStr,
    IN PCWSTR DefaultValue OPTIONAL,
    OUT PWSTR Buffer,
    IN ULONG BufferSize
    );

PWSTR
SfcQueryRegStringWithAlternate(
    IN PCWSTR FirstKey,
    IN PCWSTR SecondKey,
    IN PCWSTR ValueNameStr
    );


NTSTATUS
SfcQueueValidationRequest(
    IN PSFC_REGISTRY_VALUE RegVal,
    IN ULONG ChangeType
    );

void
MyLowerString(
    IN PWSTR String,
    IN ULONG StringLength  // in characters
    );

#ifdef SFCLOGFILE
void
SfcLogFileWrite(
    IN DWORD StrId,
    IN ...
    );
#endif

BOOL
SfcPopulateCache(
    IN HWND ProgressWindow,
    IN BOOL Validate,
    IN BOOL AllowUI,
    IN PCWSTR IgnoreFiles OPTIONAL
    );

NTSTATUS
SfcDoForcedSxsScan(
    IN HWND ProgressWindow,
    IN BOOL Validate,
    IN BOOL AllowUI
    );

BOOL
SfcLoadSxsProtection(
    void
    );


BOOL
SfcAddFileToQueue(
    IN const HSPFILEQ hFileQ,
    IN PCWSTR FileName,
    IN PCWSTR TargetFileName,
    IN PCWSTR TargetDirectory,
    IN PCWSTR SourceFileName, OPTIONAL
    IN PCWSTR SourceRootPath, OPTIONAL
    IN PCWSTR InfName,
    IN BOOL ExcepPackFile,
    IN OUT PSOURCE_INFO SourceInfo OPTIONAL
    );

UINT
SfcQueueCallback(
    IN PFILE_COPY_INFO fci,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

NTSTATUS
SfcInitializeDllLists(
    PSFC_GET_FILES pfGetFiles
    );

void
RemoveDuplicatesFromQueue(
    IN PSFC_REGISTRY_VALUE RegVal
    );

int
MyDialogBoxParam(
    IN DWORD RcId,
    IN DLGPROC lpDialogFunc,    // pointer to dialog box procedure
    IN LPARAM dwInitParam       // initialization value
    );

BOOL
SfcGetValidationData(
    IN PUNICODE_STRING FileName,
    IN PUNICODE_STRING FullPathName,
    IN HANDLE DirHandle,
    IN HCATADMIN hCatAdmin,
    OUT PIMAGE_VALIDATION_DATA ImageValData
    );

void
CenterDialog(
    HWND hwnd
    );

BOOL
MakeDirectory(
    PCWSTR Dir
    );

void
ClientApiInit(
    void
    );

void
ClientApiCleanup(
    void
    );

BOOL
SfcGetSourceInformation(
    IN PCWSTR SourceFileName,
    IN PCWSTR InfName,
    IN BOOL ExcepPackFile,
    OUT PSOURCE_INFO si
    );

BOOL
SfcGetCdRomDrivePath(
    IN PWSTR CdRomPath
    );

BOOL
SfcpSetSpecialEnvironmentVariables(
    VOID
    );

DWORD
SfcGetPathType(
    IN PCWSTR Path,
    OUT PWSTR NewPath,
    IN DWORD NewPathSize
    );

#if 0
DWORD
SfcIsTargetAvailable(
    IN PCWSTR InfName,
    IN PCWSTR SourceFileName,
    IN BOOL   TargetIsCache,
    OUT PWSTR NewSourcePath,
    IN OUT PSOURCE_INFO si
    );
#endif

BOOL
SfcRestoreFromCache(
    IN PVALIDATION_REQUEST_DATA vrd,
    IN HCATADMIN hCatAdmin
    );

BOOL
SfcSyncCache(
    IN PVALIDATION_REQUEST_DATA vrd,
    IN HCATADMIN hCatAdmin
    );


PVALIDATION_REQUEST_DATA
IsFileInQueue(
    IN PSFC_REGISTRY_VALUE RegVal
    );

DWORD
SfcQueueLookForFile(
    IN const PSOURCE_MEDIA sm,
    IN const PSOURCE_INFO si,
    IN PCWSTR fname,
    OUT PWSTR NewPath
    );

BOOL
SfcQueueAddFileToRestoreQueue(
    IN BOOL RequiresUI,
    IN PSFC_REGISTRY_VALUE RegVal,
    IN PCWSTR InfFileName,
    IN BOOL ExcepPackFile,
    IN PSOURCE_INFO SourceInfo,
    IN PCWSTR ActualFileNameOnMedia
    );

BOOL
SfcQueueCommitRestoreQueue(
    IN BOOL RequiresUI
    );

BOOL
SfcQueueResetQueue(
    IN BOOL RequiresUI
    );

PSOURCE_INFO
pSfcGetSourceInfoFromSourceName(
    const PSOURCE_INFO *SourceInfoList,
    DWORD         SourceInfoCount,
    const PSOURCE_MEDIA SourceMediaInfo
    );

PVALIDATION_REQUEST_DATA
pSfcGetValidationRequestFromFilePaths(
    const PSOURCE_INFO *SourceInfoList,
    DWORD               SourceInfoCount,
    const PFILEPATHS FilePaths
    );

BOOL
SfcGetConnectionName(
    IN  PCWSTR Path,
    OUT PWSTR ConnectionName,
    IN  DWORD ConnectionBufferSize,
    OUT PWSTR RemainingPath OPTIONAL,
    IN  DWORD RemainingPathSize OPTIONAL,
    IN BOOL KeepImpersonating,
    OUT PBOOL Impersonating OPTIONAL
    );

DWORD
GetPageFileSize(
    VOID
    );

BOOL
SfcIsFileOnMedia(
    IN PCWSTR FileName
    );

PCWSTR
IsFileInDriverCache(
    IN PCWSTR TargetFilename
    );

INT_PTR
CALLBACK
pSfcPromptForMediaDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );


PSFC_WINDOW_DATA
pSfcCreateWindowDataEntry(
    HWND hWnd
    );

BOOL
pSfcRemoveWindowDataEntry(
    PSFC_WINDOW_DATA WindowData
    );

DWORD
EstablishConnection(
    IN HWND   hWndParent,
    IN PCWSTR PathName,
    IN BOOL   AllowUI
    );

BOOL
BuildPathForFile(
    IN PCWSTR SourceRootPath,
    IN PCWSTR SubDirectoryPath, OPTIONAL
    IN PCWSTR FileName,
    IN BOOL   IncludeSubDirectory,
    IN BOOL   IncludeArchitectureSpecificSubDirectory,
    OUT PWSTR  PathBuffer,
    IN DWORD  PathBufferSize
    );

BOOL
SfcWaitForValidDesktop(
    VOID
    );

PWSTR
SfcGetSourcePath(
    IN BOOL bServicePackSourcePath,
    IN OUT PWSTR Path
    );

DWORD
SfcRpcPriviledgeCheck(
    IN HANDLE RpcHandle
    );

void
SfcFlushCryptoCache(
    void
    );

PSFC_GET_FILES
SfcLoadSfcFiles(
	BOOL bLoad
	);

DWORD 
CreateSd(
	PSECURITY_DESCRIPTOR* ppsd
	);

VOID 
SfcExceptionInfoInit(
    VOID
    );

VOID
SfcRefreshExceptionInfo(
    VOID
    );

BOOL
SfcGetInfName(
    IN PSFC_REGISTRY_VALUE RegVal,
    OUT LPWSTR InfName
    );

DWORD
CreateDialogParent(
    OUT HWND* phwnd
    );

NTSTATUS
SfcAllocUnicodeStringFromPath(
    IN PCWSTR szPath,
    OUT PUNICODE_STRING pString
    );

#ifndef _WIN64

VOID
SfcInitPathTranslator(
    VOID
    );

VOID
SfcCleanupPathTranslator(
    IN BOOL FinalCleanup
    );

NTSTATUS
SfcRedirectPath(
    IN PCWSTR szPath,
    OUT PUNICODE_STRING pPath
    );

#endif  // _WIN64

DWORD
SfcCreateSid(
    IN WELL_KNOWN_SID_TYPE type,
    OUT PSID* ppSid
    );

DWORD
SfcGetSidName(
    IN PSID pSid,
    OUT PWSTR* ppszName
    );

NTSTATUS
SfcRpcStartServer(
    VOID
    );

HINF
SfcOpenInf(
    IN PCWSTR InfName OPTIONAL,
    IN BOOL ExcepPackInf
    );

FORCEINLINE
ULONG
SfcGetExemptionFlags(
    IN PSFC_REGISTRY_VALUE RegVal
    )
{
    UINT_PTR Index;

    ASSERT(RegVal != NULL);
    Index = RegVal - SfcProtectedDllsList;
    ASSERT(Index < SfcProtectedDllCount);

    return Index < SfcProtectedDllCount ? IgnoreNextChange[Index] : 0;
}

FORCEINLINE
VOID
SfcSetExemptionFlags(
    IN PSFC_REGISTRY_VALUE RegVal,
    IN ULONG Flags
    )
{
    UINT_PTR Index;

    ASSERT(RegVal != NULL);
    Index = RegVal - SfcProtectedDllsList;
    ASSERT(Index < SfcProtectedDllCount);

    if(Index < SfcProtectedDllCount) {
        IgnoreNextChange[Index] |= Flags;
    }
}

FORCEINLINE
ULARGE_INTEGER
SfcGetSystemTime(
    VOID
    )
{
    FILETIME filetime;
    ULARGE_INTEGER time;

    GetSystemTimeAsFileTime(&filetime);
    time.LowPart = filetime.dwLowDateTime;
    time.HighPart = filetime.dwHighDateTime;
    
    return time;
}

FORCEINLINE
BOOL
SfcAreExemptionFlagsValid(
    BOOL ResetValidityTimer
    )
{
    //
    // one minute in 100-nanosecond units
    //
    const ULARGE_INTEGER ExemptionFlagsTimeout = { 10000000 * 60 };

    ULARGE_INTEGER time = SfcGetSystemTime();
    BOOL Valid = (time.QuadPart - LastExemptionTime.QuadPart < ExemptionFlagsTimeout.QuadPart);

    if(ResetValidityTimer) {
        LastExemptionTime.QuadPart = time.QuadPart;
    }

    return Valid;
}

DWORD
SfcCopyRegValue(
    IN LPCWSTR SourceKeyName,
    IN LPCWSTR SourceValueName,
    IN LPCWSTR DestinationKeyName,
    IN LPCWSTR DestinationValueName
    );

DWORD
ProcessDelayRenames(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\validate.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    validate.c

Abstract:

    Implementation of file validation.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 7-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

#include <winwlx.h>

//
// handle to validation thread
//
HANDLE hErrorThread;

//
// list of files that need to be checked in the validation request queue
//
LIST_ENTRY SfcErrorQueue;

//
// count of files in queue
//
ULONG ErrorQueueCount;

//
// event that's signalled when a new event is placed into the queue
//
HANDLE ErrorQueueEvent;

//
// critical section used to synchronize insertion and deletion from the file
// restore list
//
RTL_CRITICAL_SECTION ErrorCs;

//
// this records how much space in our dllcache has been consumed.  CacheUsed
// should never be larger than the quota.
//
ULONGLONG CacheUsed;

//
// records the currently logged on user's name (for logging)
//
WCHAR LoggedOnUserName[MAX_PATH];

//
// set to TRUE if a user is logged onto the system
//
BOOL UserLoggedOn;

//
// set to TRUE if we're in the middle of a scan
//
BOOL ScanInProgress;

//
// event that is signalled to cancel the scanning of the system
//
HANDLE hEventScanCancel;

//
// event that is signalled when the cancel has been completed
//
HANDLE hEventScanCancelComplete;


//
// used to handle files that need to come from media which do not
// require UI to restore
//
RESTORE_QUEUE SilentRestoreQueue;

//
// used to handle files that need to come from media which require UI to
// restore
//
RESTORE_QUEUE UIRestoreQueue;

//
// handles to user's desktop and token
//
HDESK hUserDesktop;
HANDLE hUserToken;

//
// indicates if WFP can receive anymore validation requests or not.
//
BOOL ShuttingDown = FALSE;

//
// This event is signalled when WFP is idle and no longer processing any
// validation requests.  An external process can synchronize on this process
// so that it knows WFP is idle before shutting down the system
//
HANDLE hEventIdle;


//
// prototypes
//
BOOL
pSfcHandleAllOrphannedRequests(
    VOID
    );


BOOL
SfcValidateFileSignature(
    IN HCATADMIN hCatAdmin,
    IN HANDLE RealFileHandle,
    IN PCWSTR BaseFileName,
    IN PCWSTR CompleteFileName
    )
/*++

Routine Description:

    Checks if the signature for a given file is valid using WinVerifyTrust

Arguments:

    hCatAdmin      - admin context handle for checking file signature
    RealFileHandle - file handle to the file to be verified
    BaseFileName   - filename without the path of the file to be verified
    CompleteFileName - fully qualified filename with path

Return Value:

    TRUE if the file has a valid signature.

--*/
{
    BOOL rVal = FALSE;
    DWORD HashSize;
    LPBYTE Hash = NULL;
    ULONG SigErr = ERROR_SUCCESS;
    WINTRUST_DATA WintrustData;
    WINTRUST_CATALOG_INFO WintrustCatalogInfo;
    WINTRUST_FILE_INFO WintrustFileInfo;
    WCHAR UnicodeKey[MAX_PATH];
    HCATINFO PrevCat;
    HCATINFO hCatInfo;
    CATALOG_INFO CatInfo;
    DRIVER_VER_INFO OsAttrVersionInfo;
    OSVERSIONINFO OsVersionInfo;


    //
    // initialize some of the structure that we will pass into winverifytrust.
    // we don't know if we're checking against a catalog or directly against a
    // file at this point
    //
    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WintrustData.pCatalog = &WintrustCatalogInfo;
    WintrustData.dwProvFlags =  WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                                WTD_CACHE_ONLY_URL_RETRIEVAL;
    Hash = NULL;

    //
    //  Initialize the DRIVER_VER_INFO structure to validate
    //  against 5.0 and 5.1 OSATTR
    //

    ZeroMemory( &OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    ZeroMemory(&OsAttrVersionInfo, sizeof(DRIVER_VER_INFO));
    OsAttrVersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);
    OsAttrVersionInfo.dwPlatform = VER_PLATFORM_WIN32_NT;
    OsAttrVersionInfo.sOSVersionLow.dwMajor = 5;
    OsAttrVersionInfo.sOSVersionLow.dwMinor = 0;

    if (GetVersionEx(&OsVersionInfo)) {

        OsAttrVersionInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
        OsAttrVersionInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;

        //Set this only if all went well
        WintrustData.pPolicyCallbackData = (LPVOID)(&OsAttrVersionInfo);

    }else{
        DebugPrint1( LVL_MINIMAL, L"Could not get OS Version while validating file - GetVersionEx failed (%d)", GetLastError() );
    }

    //
    // we first calculate a hash for our file.  start with a reasonable
    // hash size and grow larger as needed
    //
    HashSize = 100;
    do {
        Hash = MemAlloc( HashSize );
        if(!Hash) {
            DebugPrint( LVL_MINIMAL, L"Not enough memory to verify file signature" );
            SigErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if(CryptCATAdminCalcHashFromFileHandle(RealFileHandle,
                                                &HashSize,
                                                Hash,
                                                0)) {
            SigErr = ERROR_SUCCESS;
        } else {
            SigErr = GetLastError();
            ASSERT(SigErr != ERROR_SUCCESS);
            //
            // If this API did mess up and not set last error, go ahead
            // and set something.
            //
            if(SigErr == ERROR_SUCCESS) {
                SigErr = ERROR_INVALID_DATA;
            }
            MemFree( Hash );
            Hash = NULL;  // reset this so we won't try to free it later
            if(SigErr != ERROR_INSUFFICIENT_BUFFER) {
                //
                // The API failed for some reason other than
                // buffer-too-small.  We gotta bail.
                //
                DebugPrint1( LVL_MINIMAL,
                            L"CCACHFFH() failed, ec=0x%08x",
                            SigErr );
                break;
            }
        }
    } while (SigErr != ERROR_SUCCESS);

    if (SigErr != ERROR_SUCCESS) {
        //
        // if we failed at this point there are a few reasons:
        //
        //
        // 1) a bug in this code
        // 2) we are in a low memory situation
        // 3) the file's hash cannot be calculated on purpose (in the case
        //    of a catalog file, a hash cannot be calculated because a catalog
        //    cannot sign another catalog.  In this case, we check to see if
        //    the file is "self-signed".
        hCatInfo = NULL;
        goto selfsign;
    }

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    WintrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    ZeroMemory(&WintrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WintrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WintrustCatalogInfo.pbCalculatedFileHash = Hash;
    WintrustCatalogInfo.cbCalculatedFileHash = HashSize;

    //
    // WinVerifyTrust is case-sensitive, so ensure that the key
    // being used is all lower-case!
    //
    // Copy the key to a writable Unicode character buffer so we
    // can lower-case it.
    //
    wcsncpy(UnicodeKey, BaseFileName, UnicodeChars(UnicodeKey));

    // in theory, we don't know what the size of BaseFileName is...
    UnicodeKey[UnicodeChars(UnicodeKey) - 1] = '\0';

    MyLowerString(UnicodeKey, wcslen(UnicodeKey));
    WintrustCatalogInfo.pcwszMemberTag = UnicodeKey;

    //
    // Search through installed catalogs looking for those that
    // contain data for a file with the hash we just calculated.
    //
    PrevCat = NULL;
    hCatInfo = CryptCATAdminEnumCatalogFromHash(
        hCatAdmin,
        Hash,
        HashSize,
        0,
        &PrevCat
        );
    if (hCatInfo == NULL) {
        SigErr = GetLastError();
        DebugPrint2( LVL_MINIMAL,
                     L"CCAECFH() failed for (%ws), ec=%d",
                     UnicodeKey,
                     SigErr );
    }

    while(hCatInfo) {

        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {

            //
            // Attempt to validate against each catalog we
            // enumerate.  Note that the catalog file info we
            // get back gives us a fully qualified path.
            //


            // NOTE:  Because we're using cached
            // catalog information (i.e., the
            // WTD_STATEACTION_AUTO_CACHE flag), we
            // don't need to explicitly validate the
            // catalog itself first.
            //
            WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            SigErr = (DWORD)WinVerifyTrust(
                NULL,
                &DriverVerifyGuid,
                &WintrustData
                );

            //
            // If the result of the above validations is
            // success, then we're done.
            //
            if(SigErr == ERROR_SUCCESS) {
                //
                // note: this API has odd semantics.
                // in the success case, we must release the catalog info handle
                // in the failure case, we implicitly free PrevCat
                // if we explicitly free the catalog, we will double free the
                // handle!!!
                //
                CryptCATAdminReleaseCatalogContext(hCatAdmin,hCatInfo,0);
                break;
            } else {
                DebugPrint1( LVL_MINIMAL, L"WinVerifyTrust(1) failed, ec=0x%08x", SigErr );
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (OsAttrVersionInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(OsAttrVersionInfo.pcSignerCertContext);
                OsAttrVersionInfo.pcSignerCertContext = NULL;
            }
        }

        PrevCat = hCatInfo;
        hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, Hash, HashSize, 0, &PrevCat);
    }

selfsign:

    if (hCatInfo == NULL) {
        //
        // We exhausted all the applicable catalogs without
        // finding the one we needed.
        //
        SigErr = GetLastError();
        ASSERT(SigErr != ERROR_SUCCESS);
        //
        // Make sure we have a valid error code.
        //
        if(SigErr == ERROR_SUCCESS) {
            SigErr = ERROR_INVALID_DATA;
        }

        //
        // The file failed to validate using the specified
        // catalog.  See if the file validates without a
        // catalog (i.e., the file contains its own
        // signature).
        //

        WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
        WintrustData.pFile = &WintrustFileInfo;
        ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
        WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
        WintrustFileInfo.pcwszFilePath = CompleteFileName;
        WintrustFileInfo.hFile = RealFileHandle;

        SigErr = (DWORD)WinVerifyTrust(
            NULL,
            &DriverVerifyGuid,
            &WintrustData
            );
        if(SigErr != ERROR_SUCCESS) {
            DebugPrint2( LVL_MINIMAL, L"WinVerifyTrust(2) failed [%ws], ec=0x%08x", WintrustData.pFile->pcwszFilePath,SigErr );
            //
            // in this case the file is not in any of our catalogs
            // and it does not contain it's own signature
            //
        }

        //
        // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
        // that was allocated in our call to WinVerifyTrust.
        //
        if (OsAttrVersionInfo.pcSignerCertContext != NULL) {

            CertFreeCertificateContext(OsAttrVersionInfo.pcSignerCertContext);
            OsAttrVersionInfo.pcSignerCertContext = NULL;
        }
    }

    if(SigErr == ERROR_SUCCESS) {
        rVal = TRUE;
    }

    if (Hash) {
        MemFree( Hash );
    }
    return rVal;
}


DWORD
GetPageFileSize(
    VOID
    )
/*++

Routine Description:

    This function will only be needed if we're being called from Setup.
    The problem is that Setup has decided how much of a pagefile will
    be needed on the next reboot, but doesn't actually generate a pagefile,
    therefore, the disk space appears to be free.

    This function will go look in the registry, and determine the
    size of the pagefile (that isn't really on disk).

    Note that we only care about the pagefile if it's going to be
    on the partition where the file cache is installed.

Arguments:

    NONE.

Return Value:

    If successful, returns the size of the pagefile.  Otherwise, we're
    going to return 0.

--*/
{
#if 0
    DWORD SetupMode = 0;
#endif
    PWSTR PageFileString = 0;
    PWSTR SizeString;
#if 0
    WCHAR WindowsDirectory[MAX_PATH];
#endif
    DWORD PageFileSize = 0;


    //
    // Determine if we're in Setup mode.
    //
#if 0
    SetupMode = SfcQueryRegDword(
        L"\\Registry\\Machine\\System\\Setup",
        L"SystemSetupInProgress",
        0
        );
    if( SetupMode == 0 ) {
        return( 0 );
    }
#else
    if (SFCDisable != SFC_DISABLE_SETUP) {
        return( 0 );
    }
#endif

    //
    // Go get the pagefile string out of the registry.
    //
    // Note that the pagefile string is really a REG_MULTI_SZ,
    // but we're only going to pay attention to the first string
    // returned.
    //
    //
    PageFileString = SfcQueryRegString(
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
        L"PagingFiles"
        );
    if( PageFileString == NULL ) {
        return( 0 );
    }

    //
    // Is the pagefile even on the cache drive?
    //
    // Note that the user can have multiple pagefiles.  We're going to
    // look at the first one.  Any other pagefiles, and the user is on his own.
    //
#if 0
    GetWindowsDirectory( WindowsDirectory, MAX_PATH );
    if( WindowsDirectory[0] != PageFileString[0] ) {
#else
    if( towlower(SfcProtectedDllPath.Buffer[0]) != towlower(PageFileString[0]) ) {
#endif
        MemFree( PageFileString );
        return( 0 );
    }

    //
    // How big is the pagefile?
    //
    SizeString = wcsrchr( PageFileString, L' ' );

    if (SizeString != NULL) {
        PageFileSize = wcstoul( SizeString + 1, NULL, 10 );
    } else {
        PageFileSize = 0;
    }

    //
    // Default.
    //
    MemFree( PageFileString );
    return PageFileSize;
}


BOOL
SfcPopulateCache(
    IN HWND ProgressWindow,
    IN BOOL Validate,
    IN BOOL AllowUI,
    IN PCWSTR IgnoreFiles OPTIONAL
    )
/*++

Routine Description:

    This routine is used to populate the dll cache directory.

    We add files in order of their insertion in our list (so note that we have
    to put files we *really want in the cache* at the head of the list.)  We
    continue to add files until we run out of space compared to our quota.

Arguments:

    ProgressWindow  - handle to progress control that is stepped as we add
                      each file to the cache
    Validate        - if TRUE, we should make sure that each file we're adding
                      is valid before moving the file into the cache
    AllowUI         - if FALSE, do not emit any UI

Return Value:

    If successful, returns TRUE.

--*/
{

    ULONG i;
    PSFC_REGISTRY_VALUE RegVal;
    VALIDATION_REQUEST_DATA vrd;
    NTSTATUS Status;
    HANDLE hFile;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    ULONGLONG FileSize;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;
    HANDLE DirHandle;
    WCHAR Drive[8];
    HCATADMIN hCatAdmin = NULL;
    ULONGLONG RequiredFreeSpace;
    BOOL Cancelled = FALSE;
    DWORD LastErrorInvalidFile = ERROR_SUCCESS;
    DWORD LastErrorCache = ERROR_SUCCESS;
    UNICODE_STRING tmpString;
    PCWSTR FileNameOnMedia;
    BOOL DoCopy;
    WCHAR InfFileName[MAX_PATH];
    BOOL ExcepPackFile;

    //
    // if we're in the middle of scanning, we shouldn't touch the cache since
    // the two functions will step on each other.
    //
    if (ScanInProgress) {
        return TRUE;
    }

    DebugPrint( LVL_MINIMAL, L"SfcPopulateCache entry..." );

    //
    // start the scan and log the message, but don't log anything if we're
    // inside gui-mode setup
    //
    ScanInProgress = TRUE;

    if (SFCDisable != SFC_DISABLE_SETUP) {
        SfcReportEvent( MSG_SCAN_STARTED, NULL, NULL, 0 );
    }

    //
    // How big does our freespace buffer need to be?
    //
    RequiredFreeSpace = (GetPageFileSize() + SFC_REQUIRED_FREE_SPACE)* ONE_MEG;
    DebugPrint2( LVL_MINIMAL, L"RequiredFreeSpace = %d, SFCQuota = %I64d", RequiredFreeSpace, SFCQuota );

    //
    // try to initialize crypto here as this could be the first use of it (from SfcInitProt or SfcInitiateScan)
    //
    Status = LoadCrypto();

    if(!NT_SUCCESS(Status))
        return FALSE;

    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        DebugPrint1( LVL_MINIMAL, L"CCAAC() failed, ec=%d", GetLastError() );
        return FALSE;
    }

    //
    // Flush the Cache once before we start any Crypto operations
    //

    SfcFlushCryptoCache();

    //
    // Refresh exception packages info
    //
    SfcRefreshExceptionInfo();

    CacheUsed = 0;
    Drive[2] = L'\\';
    Drive[3] = 0;

    //
    // iterate through the list of files we're protecting
    //
    // 1. make sure the entry is ok
    // 2. if we're supposed to, check the signature of the file and restore if
    //    necessary.
    // 3. if there is space available, copy the file into the cache from:
    //    a) if the file is present on disk, use it
    //    b) if the file isn't present from appropriate media
    // 4. add the size of the file to the total cache size and make sure the
    //    file we put in the cache is properly signed
    for (i=0; i<SfcProtectedDllCount; i++) {
        RegVal = &SfcProtectedDllsList[i];

        DebugPrint2( LVL_VERBOSE, L"Processing protected file [%ws] [%ws]", RegVal->FullPathName.Buffer, RegVal->SourceFileName.Buffer );
        //
        // We step the guage once per file
        //
        if (ProgressWindow != NULL) {
            PostMessage( ProgressWindow, PBM_STEPIT, 0, 0 );
        }

        if (RegVal->DirName.Buffer[0] == 0 || RegVal->DirName.Buffer[0] == L'\\') {
            ASSERT(FALSE);
            continue;
        }

        if (NULL == RegVal->DirHandle) {
            DebugPrint1(LVL_MINIMAL, L"The dir handle for [%ws] is NULL; skipping the file", RegVal->DirName.Buffer);
            continue;
        }

        //
        // check if the user clicked cancel, and if so, exit
        //
        if (hEventScanCancel) {
            if (WaitForSingleObject( hEventScanCancel, 0 ) == WAIT_OBJECT_0) {
                Cancelled = TRUE;
                break;
            }
        }
#if DBG
        //
        // don't protect the SFC files in the debug build
        //
        if (_wcsnicmp( RegVal->FileName.Buffer, L"sfc", 3 ) == 0) {
            continue;
        }
#endif

        //
        // get the inf name here
        //
        ExcepPackFile = SfcGetInfName(RegVal, InfFileName);

        if (Validate) {
            //
            // also make sure the file is valid... if we're putting a file
            // in the cache, then don't log anything (SyncOnly = TRUE)
            //
            RtlZeroMemory( &vrd, sizeof(vrd) );
            vrd.RegVal = RegVal;
            vrd.SyncOnly = TRUE;
            vrd.ImageValData.EventLog = MSG_SCAN_FOUND_BAD_FILE;
            //
            // set the validation data
            //
            SfcGetValidationData( &RegVal->FileName,
                                  &RegVal->FullPathName,
                                  RegVal->DirHandle,
                                  hCatAdmin,
                                  &vrd.ImageValData.New);

            //
            // check the signature
            //
            SfcValidateDLL( &vrd, hCatAdmin );

            //
            // If the source file is present and is unsigned, we must restore
            // it.  If the source file is not present, then we just ignore it
            //
            if (!vrd.ImageValData.Original.SignatureValid &&
                vrd.ImageValData.Original.FilePresent) {

                //
                // this might be an unsigned F6 driver that should be left alone when running in GUI setup
                //
                if(SFC_DISABLE_SETUP == SFCDisable && IgnoreFiles != NULL)
                {
                    PCWSTR szFile = IgnoreFiles;
                    USHORT usLen;

                    for(;;)
                    {
                        usLen = (USHORT) wcslen(szFile);

                        if(0 == usLen || (usLen * sizeof(WCHAR) == RegVal->FullPathName.Length &&
                            0 == _wcsnicmp(szFile, RegVal->FullPathName.Buffer, usLen)))
                        {
                            break;
                        }

                        szFile += usLen + 1;
                    }

                    if(usLen != 0)
                    {
                        continue;
                    }
                }

                //
                // see if we can restore from cache
                //
                if (!vrd.ImageValData.RestoreFromMedia) {
                    SfcRestoreFromCache( &vrd, hCatAdmin );
                }


                if (vrd.ImageValData.RestoreFromMedia) {
                    //
                    // the file is still bad so we need to restore from the
                    // media
                    //
                    if (!SfcRestoreFileFromInstallMedia(
                                            &vrd,
                                            RegVal->FileName.Buffer,
                                            RegVal->FileName.Buffer,
                                            RegVal->DirName.Buffer,
                                            RegVal->SourceFileName.Buffer,
                                            InfFileName,
                                            ExcepPackFile,
                                            FALSE, // target is NOT cache
                                            AllowUI,
                                            NULL )) {
                        LastErrorInvalidFile = GetLastError();

                        SfcReportEvent(
                                ((LastErrorInvalidFile != ERROR_CANCELLED)
                                  ? MSG_RESTORE_FAILURE
                                  : (SFCNoPopUps == TRUE)
                                     ? MSG_COPY_CANCEL_NOUI
                                     : MSG_COPY_CANCEL ),
                                RegVal->FullPathName.Buffer,
                                &vrd.ImageValData,
                                LastErrorInvalidFile);

                        DebugPrint1(
                            LVL_MINIMAL,
                            L"Failed to restore file from install media [%ws]",
                            RegVal->FileName.Buffer );
                    } else {
                        DebugPrint1(
                            LVL_VERBOSE,
                            L"The file was successfully restored from install media [%ws]",
                            RegVal->FileName.Buffer );


                        SfcReportEvent(
                                MSG_SCAN_FOUND_BAD_FILE,
                                RegVal->FullPathName.Buffer,
                                &vrd.ImageValData,
                                ERROR_SUCCESS );
                    }
                } else {
                    ASSERT(vrd.ImageValData.New.SignatureValid == TRUE);
                }
            }
        }

        //
        // see how much space we have left
        //
        Drive[0] = SfcProtectedDllPath.Buffer[0];
        Drive[1] = SfcProtectedDllPath.Buffer[1];
        if (!GetDiskFreeSpaceEx( Drive, &FreeBytesAvailableToCaller, &TotalNumberOfBytes, &TotalNumberOfFreeBytes ) ||
            TotalNumberOfFreeBytes.QuadPart <= RequiredFreeSpace)
        {
            DebugPrint( LVL_MINIMAL, L"Not enough free space" );
            //
            // if we're validating, we want to keep going through the list even
            // though we're out of space
            //
            if (Validate) {
                continue;
            } else {
                break;
            }
        }
        if (CacheUsed >= SFCQuota) {
            DebugPrint( LVL_MINIMAL, L"Cache is full" );
            //
            // if we're validating, we want to keep going through the list even
            // though we're out of space
            //
            if (Validate) {
                continue;
            } else {
                break;
            }
        }

        ASSERT(RegVal->DirHandle != NULL);

        DirHandle = RegVal->DirHandle;

        if (!DirHandle) {
            DebugPrint1( LVL_MINIMAL, L"invalid dirhandle for dir [%ws]", RegVal->DirName.Buffer );
            continue;
        }
        //
        // Either copy the file or restore from media...
        //
        // Let's make an optimization here that says that if the file is in
        // the driver cache, we don't have to spend any time putting the
        // file in the dllcache since we will probably be able to get at
        // the file later on.  This will also save disk space during the
        // initial scan
        //
        DoCopy = TRUE;
        if (SFCDisable == SFC_DISABLE_SETUP) {
            PCWSTR TempCabName;


            TempCabName = IsFileInDriverCache( SpecialFileNameOnMedia( RegVal ));
            if (TempCabName) {
                MemFree((PVOID)TempCabName);
                DoCopy = FALSE;
            }

        }

        if (DoCopy) {
            PCWSTR OnDiskFileName;

            OnDiskFileName = FileNameOnMedia( RegVal );
            FileNameOnMedia = SpecialFileNameOnMedia( RegVal );
            Status = STATUS_UNSUCCESSFUL;

            //
            // see if the file is cached.  the filename in the cache will
            // have the same name as the filename on the media.  Note that
            // we don't use the "FileNameOnMedia" routine to get
            // this information because of special case files like the NT
            // kernel and HALs.  In these special case files, we should
            // only copy the current file on disk to the cache if it
            // corresponds to the source filename.
            //
            if (_wcsicmp( OnDiskFileName, FileNameOnMedia) == 0) {
                Status = SfcOpenFile( &RegVal->FileName, DirHandle, SHARE_ALL, &hFile );
            }

            if (NT_SUCCESS(Status) ) {
                NtClose( hFile );
                RtlInitUnicodeString( &tmpString, FileNameOnMedia );
                Status = SfcCopyFile(
                    DirHandle,
                    RegVal->DirName.Buffer,
                    SfcProtectedDllFileDirectory,
                    SfcProtectedDllPath.Buffer,
                    &tmpString,
                    &RegVal->FileName
                    );
                if (!NT_SUCCESS(Status)) {
                    DebugPrint3( LVL_MINIMAL, L"Could not copy file [0x%08x] [%ws] [%ws]", Status, RegVal->FileName.Buffer, RegVal->DirName.Buffer );
                }
            } else {
                if (!SfcRestoreFileFromInstallMedia(
                    &vrd,
                    RegVal->FileName.Buffer,
                    SpecialFileNameOnMedia(RegVal),
                    SfcProtectedDllPath.Buffer,
                    RegVal->SourceFileName.Buffer,
                    InfFileName,
                    ExcepPackFile,
                    TRUE, // target is cache
                    AllowUI,
                    NULL ))

                {
                    LastErrorCache = GetLastError();
                    SfcReportEvent( MSG_CACHE_COPY_ERROR, RegVal->FullPathName.Buffer, &vrd.ImageValData, LastErrorCache);
                    DebugPrint1( LVL_MINIMAL, L"Failed to restore file from install media [%ws]", RegVal->FileName.Buffer );
                }
            }

            //
            // get the size of the file we just added to the cache and add it to
            // the total cache size.  while we have the handle open, it's a good
            // time to verify that the file we copied into the cache is indeed
            // valid
            //

            ASSERT(SfcProtectedDllFileDirectory != NULL );

            FileNameOnMedia = SpecialFileNameOnMedia(RegVal);
            RtlInitUnicodeString( &tmpString, FileNameOnMedia );

            Status = SfcOpenFile( &tmpString, SfcProtectedDllFileDirectory, SHARE_ALL, &hFile );
            if (NT_SUCCESS(Status) ) {
                WCHAR FullPathToCachedFile[MAX_PATH];

                wcsncpy(FullPathToCachedFile, SfcProtectedDllPath.Buffer, UnicodeChars(FullPathToCachedFile));
                pSetupConcatenatePaths( FullPathToCachedFile, FileNameOnMedia, UnicodeChars(FullPathToCachedFile), NULL);

                Status = NtQueryInformationFile(
                    hFile,
                    &IoStatusBlock,
                    &StandardInfo,
                    sizeof(StandardInfo),
                    FileStandardInformation
                    );
                if (NT_SUCCESS(Status) ) {
                    FileSize = StandardInfo.EndOfFile.QuadPart;
                    DebugPrint2( LVL_MINIMAL, L"file size =  [0x%08x] [%ws]", FileSize, RegVal->FileName.Buffer );
                } else {
                    DebugPrint2( LVL_MINIMAL, L"Could not query file information [0x%08x] [%ws]", Status, RegVal->FileName.Buffer );
                    FileSize = 0;
                }
                if (!SfcValidateFileSignature(
                                    hCatAdmin,
                                    hFile,
                                    FileNameOnMedia,
                                    FullPathToCachedFile )) {
                    //
                    // delete the unsigned file from the cache
                    //
                    DebugPrint1( LVL_MINIMAL, L"Cache file has a bad signature [%ws]", RegVal->FileName.Buffer );
                    SfcDeleteFile( SfcProtectedDllFileDirectory, &tmpString );
                    FileSize = 0;
                }
                NtClose( hFile );
            } else {
                DebugPrint2( LVL_MINIMAL, L"Could not open file [0x%08x] [%ws]", Status, RegVal->FileName.Buffer );
                FileSize = 0;
            }
            DebugPrint4( LVL_MINIMAL,
                         L"cache size [0x%08x], filesize [0x%08x], new size [0x%08x] (%d)",
                         CacheUsed, FileSize, CacheUsed+FileSize, (CacheUsed+FileSize)/(1024*1024)
                          );
            CacheUsed += FileSize;
        }
    }

    if (hCatAdmin) {
        CryptCATAdminReleaseContext(hCatAdmin,0);
    }

    //
    // log an event saying it succeeded or was cancelled, but only if we're not
    // inside gui-setup.
    //
    if (SFCDisable == SFC_DISABLE_SETUP) {
        //
        // the user can never cancel inside gui-setup
        //
        ASSERT(Cancelled == FALSE);
    } else {
        SfcReportEvent( Cancelled ? MSG_SCAN_CANCELLED : MSG_SCAN_COMPLETED, NULL, NULL, 0 );
    }

    ScanInProgress = FALSE;

    if (hEventScanCancelComplete) {
        SetEvent(hEventScanCancelComplete);
    }

    DebugPrint( LVL_MINIMAL, L"SfcPopulateCache exit..." );

    return TRUE;
}


PVALIDATION_REQUEST_DATA
IsFileInQueue(
    IN PSFC_REGISTRY_VALUE RegVal
    )
/*++

Routine Description:

    This routine checks if the specified file is in the validation request
    queue.

    Note that this routine does no locking of the queue.  The caller is
    responsible for locking.

Arguments:

    RegVal - pointer to structure for file we're concerned with

Return Value:

    If the file is already in the queue, returns a pointer to the validation
    request corresponding to this item, else NULL.

--*/
{
    PVALIDATION_REQUEST_DATA vrd;
    PLIST_ENTRY Next;

    //
    // walk through our linked list of validation requests looking for a match
    //
    Next = SfcErrorQueue.Flink;
    while (Next != &SfcErrorQueue) {
        vrd = CONTAINING_RECORD( Next, VALIDATION_REQUEST_DATA, Entry );
        Next = vrd->Entry.Flink;
        if (RegVal == vrd->RegVal) {
            return vrd;
        }
    }
    return NULL;
}


void
RemoveDuplicatesFromQueue(
    IN PSFC_REGISTRY_VALUE RegVal
    )

/*++

Routine Description:

    This routine checks for the specified file is in the validation request
    queue and removes any duplicate entries from the queue.

    Note that this routine does locking of the queue.  The caller is
    not responsible for locking.

Arguments:

    RegVal - pointer to structure for file we're concerned with

Return Value:

    none.

--*/
{
    PVALIDATION_REQUEST_DATA vrd;
    PLIST_ENTRY Next;

    //
    // we need to lock down the validation queue since we are modifying the
    // list
    //
    RtlEnterCriticalSection( &ErrorCs );
    Next = SfcErrorQueue.Flink;
    //
    // walk through our linked list of validation requests looking for a match
    // and remove any duplicates
    while (Next != &SfcErrorQueue) {
        vrd = CONTAINING_RECORD( Next, VALIDATION_REQUEST_DATA, Entry );
        Next = vrd->Entry.Flink;
        if (RegVal == vrd->RegVal) {
            RemoveEntryList( &vrd->Entry );
            ErrorQueueCount -= 1;
            MemFree( vrd );
        }
    }

    RtlLeaveCriticalSection( &ErrorCs );
}


BOOL
IsUserValid(
    IN HANDLE Token,
    IN DWORD Rid
    )
/*++

Routine Description:

    This routine checks that the security token has access for the specified
    RID (relative sub-authority) for the NT-authority SID

Arguments:

    Token  - security token
    Rid    - well known relative sub-authority to check for presence in

Return Value:

    none.

--*/
{
    BOOL b = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID Group;

    b = AllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            Rid,
            0, 0, 0, 0, 0, 0,
            &Group
            );

    if(b) {

        //
        // See if the user has the administrator group.
        //
        if (ImpersonateLoggedOnUser( Token )) {

            if (!CheckTokenMembership( NULL,  Group, &b)) {
                b = FALSE;
            }

            RevertToSelf();

        } else {
            b = FALSE;
        }


        FreeSid(Group);
    }


    //
    // Clean up and return.
    //

    return b;
}


VOID
SfcWLEventLogon(
    IN PWLX_NOTIFICATION_INFO pInfo
    )
/*++

Routine Description:

    This routine is called by winlogon each time a user logs onto the system.

    If a valid user is logged on, then we signal an event.

Arguments:

    pInfo - pointer to WLX_NOTIFICATION_INFO structure filled in by winlogon

Return Value:

    none.

--*/
{


    if (SfcWaitForValidDesktop()) {
        if (IsUserValid(pInfo->hToken,DOMAIN_ALIAS_RID_ADMINS)) {
            DebugPrint1(LVL_MINIMAL, L"user logged on = %ws",pInfo->UserName);
            UserLoggedOn = TRUE;
            hUserDesktop = pInfo->hDesktop;
            hUserToken = pInfo->hToken;

            //
            // record the user's name for later on
            //
            wcscpy( LoggedOnUserName, pInfo->UserName );

            //
            // now that a user is logged on, SFCNoPopups can transition to
            // whatever value we grabbed on initialization (ie., we can now
            // allow popups to occur since a user is logged on)
            //
            SFCNoPopUps = SFCNoPopUpsPolicy;

            SetEvent( hEventLogon );

            if ( SxsLogonEvent ) {
                SxsLogonEvent();
            }

        } else {
            DebugPrint1(
                LVL_MINIMAL,
                L"received a logon event, but user is not a member of domain administrators = %ws",
                pInfo->UserName);
            ;
        }
    }
}


VOID
SfcWLEventLogoff(
    PWLX_NOTIFICATION_INFO pInfo
    )
/*++

Routine Description:

    This routine is called by winlogon each time a user logs off of the system.

    We simply signal an event when this occurs.  Note that the UserLoggedOff
    global is set by a thread that will detect this event.

Arguments:

    pInfo - pointer to WLX_NOTIFICATION_INFO structure filled in by winlogon

Return Value:

    none.

--*/

{
    BOOL ReallyLogoff;

    DebugPrint1(LVL_MINIMAL, L"user logged off = %ws",pInfo->UserName);

    ReallyLogoff = FALSE;

    //
    // See if the correct user logged off.
    //
    if (UserLoggedOn) {
        if (_wcsicmp( LoggedOnUserName, pInfo->UserName )==0) {
            ReallyLogoff = TRUE;
        }
    }

    if (ReallyLogoff) {
        //
        // reset the logon event since the validation thread may not be around to do this
        //
        ResetEvent(hEventLogon);

        //
        // just fire the event if we had a valid user logged on
        //
        if (hEventLogoff) {
            SetEvent( hEventLogoff );
            if ( SxsLogoffEvent ) {
                SxsLogoffEvent();
            }
        }


        ASSERT((SFCSafeBootMode == 0)
                ? (UserLoggedOn == TRUE)
                : TRUE );

        UserLoggedOn = FALSE;
        hUserDesktop = NULL;
        hUserToken = NULL;
        LoggedOnUserName[0] = L'\0';


        //
        // now that the user is logged off, SFCNoPopups transitions to
        // 1, meaning that we cannot allow any popups to occur until a
        // user logs on again.
        //
        SFCNoPopUps = 1;

        //
        // we need to get rid of the persistant connection we asked the user to
        // make earlier on
        //
        if (SFCLoggedOn == TRUE) {
            WNetCancelConnection2( SFCNetworkLoginLocation, CONNECT_UPDATE_PROFILE, FALSE );
            SFCLoggedOn = FALSE;
        }
   }

}


NTSTATUS
SfcQueueValidationThread(
    IN PVOID lpv
    )
/*++

Routine Description:

    Thread routine that performs the file validations.

    The validation thread can only run when a user is logged on.

    The validation thread waits for an event which signals that there are
    pending files to validate.  It then cycles through this list of files,
    validating each file that has not been validated.

    If the file is valid, it is removed from the queue.
    If the file is invalid, we first try to restore the file from cache.
    If we cannot restore from cache, we try to determine if we'd require UI
    to restore this file.  We then have one of two global files we add the file
    to (one which requires UI, one which does not).  After we've gone through
    the entire list of files, we will attempt to commit these queues if the
    queue committal is not already in progress.  (Care must be taken not to
    add a file to a file queue that is already being committed.)

    We then put the thread back to sleep waiting for a new event to wake up the
    thread and start all over again.  If we still have pending items to be
    restored, we will put the thread back to sleep with a non-INFINITE timeout.

Arguments:

    Unreferenced Parameter.

Return Value:

    NTSTATUS code of any fatal error.

--*/
{
    NTSTATUS Status;
    HANDLE Handles[3];
    PVALIDATION_REQUEST_DATA vrd;
    HCATADMIN hCatAdmin = NULL;
    LARGE_INTEGER Timeout;
    PLARGE_INTEGER pTimeout = NULL;
    HANDLE FileHandle;
#if 0
    HDESK hDesk = NULL;
#endif
    PSFC_REGISTRY_VALUE RegVal;
    DWORD Ticks;
    BOOL WaitAgain;
    ULONG tmpErrorQueueCount;
    PWSTR ActualFileNameOnMedia;
    PLIST_ENTRY CurrentEntry;
    BOOL RemoveEntry;
    ULONG FilesNeedToBeCommited;
    WCHAR InfFileName[MAX_PATH];
    BOOL ExcepPackFile;
    const DWORD cdwCatalogMinRetryTimeout = 30;                                 // 30 seconds
    const DWORD cdwCatalogMaxRetryTimeout = 128 * cdwCatalogMinRetryTimeout;    // 64 minutes
    DWORD dwCatalogRetryTimeout = cdwCatalogMinRetryTimeout;

    UNREFERENCED_PARAMETER(lpv);

    ASSERT((ValidateTermEvent != NULL)
           && (ErrorQueueEvent != NULL)
           && (hEventLogoff != NULL)
           && (hEventLogon != NULL)
           );

    //
    // if this thread has started, we'll need crypto; set the thread's ID before attempting to load it
    //
    g_dwValidationThreadID = GetCurrentThreadId();
    Status = LoadCrypto();

    if(!NT_SUCCESS(Status))
        goto exit;

#if 0
    //
    // this thread must run on the user's desktop
    //
    hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );
    if ( hDesk ) {
        SetThreadDesktop( hDesk );
        CloseDesktop( hDesk );
    }
#endif

    //
    // event tells us to stop validating (ie., machine is shutting down)
    //
    Handles[0] = ValidateTermEvent;

    //
    // tells us that new events were added to the validation queue
    //
    Handles[1] = ErrorQueueEvent;

    //
    // event tells us to start validating again since someone is logged on
    //
    Handles[2] = hEventLogon;

    while (TRUE) {
        //
        // set our idle trigger to "signalled" if there are no events to be
        // validated
        //
        if (hEventIdle && ErrorQueueCount == 0) {
            SetEvent( hEventIdle );
        }

        //
        //  Wait for a change
        //
        Status = NtWaitForMultipleObjects(
            sizeof(Handles)/sizeof(HANDLE),
            Handles,
            WaitAny,
            TRUE,
            pTimeout
            );

        if (!NT_SUCCESS(Status)) {
            DebugPrint1( LVL_MINIMAL, L"WaitForMultipleObjects failed returning %x", Status );
            goto exit;
        }

        DebugPrint1( LVL_VERBOSE,
                     L"SfcQueueValidationThread: WaitForMultipleObjects returned %x",
                     Status );

        if (Status == 0) {
            //
            // the termination event fired so we must exit
            //
            goto exit;
        }

        //
        // Make sure we acknowlege that the user logged on so this event
        // doesn't remain signalled forever
        //
        if ( (Status == 2) || (Status == 1) ) {
            if (WaitForSingleObject(hEventLogon,0) == WAIT_OBJECT_0) {

                //
                // the logon event fired
                //
                ASSERT(UserLoggedOn == TRUE);
                ResetEvent( hEventLogon );

                if (Status == 2) {
                    if (IsListEmpty(&SfcErrorQueue)) {
                        DebugPrint(
                            LVL_MINIMAL,
                            L"logon event but queue is empty...");
                        pTimeout = NULL;
                    } else {
                        DebugPrint(
                            LVL_MINIMAL,
                            L"logon event occurred with requests in the queue. see if we can satisfy any of the requests");
                        pTimeout = &Timeout;
                        goto validate_start;
                    }
                    continue;
                }
            } else {
                ASSERT(Status == 1);
            }
        }

        if (Status == STATUS_TIMEOUT) {
            //
            // a timeout is necessary only when there are entries in the list
            // that are servicable
            //
            if (IsListEmpty(&SfcErrorQueue)) {
                DebugPrint(LVL_MINIMAL, L"Timeout in SfcQueueValidationThread but queue is empty");
                pTimeout = NULL;

            } else {
                DebugPrint(LVL_MINIMAL, L"Timeout in SfcQueueValidationThread with requests in the queue. check it out");
                pTimeout = &Timeout;

                goto validate_start;
            }

            continue;
        }

        if (Status > sizeof(Handles)/sizeof(HANDLE)) {
            DebugPrint1( LVL_MINIMAL, L"Unknown success code %d for WaitForMultipleObjects", Status );
            continue;
        }

        ASSERT(Status == 1);

validate_start:
        DebugPrint( LVL_MINIMAL, L"Processing queued file validations..." );
        //
        // process any file validations
        //

        //
        // Reset our "idle trigger so that it is unsignalled while we validate
        // the files
        //
        if (hEventIdle) {
            ResetEvent( hEventIdle );
        }

        NtResetEvent( ErrorQueueEvent, NULL );

        ASSERT(hCatAdmin == NULL);

        if (!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
            DebugPrint1( LVL_MINIMAL, L"CCAAC() failed, ec=%d", GetLastError() );
            hCatAdmin = NULL;
            //
            // try again to get a context; each time, double the timeout until we reach the max
            //
            Timeout.QuadPart = (1000 * dwCatalogRetryTimeout) * (-10000);
            pTimeout = &Timeout;

            if(dwCatalogRetryTimeout < cdwCatalogMaxRetryTimeout)
            {
                dwCatalogRetryTimeout *= 2;
            }

            continue;
        }
        //
        // reset the catalog wait timeout
        //
        dwCatalogRetryTimeout = cdwCatalogMinRetryTimeout;

        //
        // Flush the Cache once before we start any Crypto operations
        //

        SfcFlushCryptoCache();

        //
        // Refresh exception packages info
        //
        SfcRefreshExceptionInfo();

        Timeout.QuadPart = (1000*SFC_QUEUE_WAIT) * (-10000);
        WaitAgain = FALSE;

        //
        // cycle through the list of queued files, processing one at a time
        // until we get back to the start again
        //
        RtlEnterCriticalSection( &ErrorCs );
        CurrentEntry = SfcErrorQueue.Flink;
        RtlLeaveCriticalSection( &ErrorCs );

        while (CurrentEntry != &SfcErrorQueue) {

            RemoveEntry = FALSE;

            DebugPrint1( LVL_VERBOSE,
                     L"CurrentEntry= %p",
                     CurrentEntry );

            ASSERT(ErrorQueueCount > 0 );

            //
            // get the current entry from the list and point to the next entry
            //
            RtlEnterCriticalSection( &ErrorCs );
            vrd = CONTAINING_RECORD( CurrentEntry, VALIDATION_REQUEST_DATA, Entry );
            RegVal = vrd->RegVal;
            ASSERT(RegVal != NULL);

            CurrentEntry = CurrentEntry->Flink;


            RtlLeaveCriticalSection( &ErrorCs );

            DebugPrint2( LVL_VERBOSE,
                         L"Processing validation request for [%wZ], flags = 0x%08x ",
                         &vrd->RegVal->FullPathName,
                         vrd->Flags );


            //
            // attempt to validate the file if we haven't already done so
            //

            if ((vrd->Flags & VRD_FLAG_REQUEST_PROCESSED) == 0) {
                //
                // skip this file if the queue has not paused long enough
                //
                Ticks = GetTickCount();

                ASSERT(vrd->NextValidTime != 0);

                if (vrd->NextValidTime && Ticks < vrd->NextValidTime) {
                    Timeout.QuadPart = (__int64)(vrd->NextValidTime - Ticks) * -10000;
                    WaitAgain = TRUE;
                    RemoveEntry = FALSE;

                    DebugPrint1( LVL_VERBOSE,
                             L"Have not waited long enough on validation request for [%wZ]",
                             &vrd->RegVal->FullPathName );

                    goto continue_entry;
                }


                //
                // see if we can open the file, otherwise wait a bit until we have
                // a chance to validate the file.
                //
                Status = SfcOpenFile( &vrd->RegVal->FileName, vrd->RegVal->DirHandle, FILE_SHARE_READ, &FileHandle );
                if (NT_SUCCESS(Status) ) {
                    DebugPrint1( LVL_VERBOSE, L"file opened successfully [%wZ] ", &vrd->RegVal->FileName );
                    NtClose( FileHandle );
                } else {
                    if (Status == STATUS_SHARING_VIOLATION) {
                        DebugPrint1( LVL_VERBOSE, L"file sharing violation [%wZ] ", &vrd->RegVal->FileName );
                        vrd->RetryCount += 1;
                        RemoveEntry = FALSE;
                        WaitAgain = TRUE;
                        goto continue_entry;
                    }
                }

                //
                // now validate the file
                //

                SfcValidateDLL( vrd, hCatAdmin );
                vrd->Flags |= VRD_FLAG_REQUEST_PROCESSED;

            }

            ASSERT((vrd->Flags & VRD_FLAG_REQUEST_PROCESSED)==VRD_FLAG_REQUEST_PROCESSED);

            //
            // if the file is valid, we're ready to go onto the next file
            //
            if (vrd->ImageValData.Original.SignatureValid) {
                //
                // before we continue, let's see if we can synchronize the copy
                // of the file in the dll cache
                //
                if (!SfcSyncCache( vrd, hCatAdmin )) {
                    DebugPrint1( LVL_VERBOSE,
                                 L"failed to synchronize [%wZ] in dllcache",
                                 &vrd->RegVal->FileName );
                }
                RemoveEntry = TRUE;
                goto continue_next;
            }

            ASSERT(vrd->ImageValData.Original.SignatureValid == FALSE);

            //
            // see if we can restore from cache.  If this succeeds, we're
            // ready to go onto the next file
            //
            if (vrd->ImageValData.Cache.SignatureValid) {
                SfcRestoreFromCache( vrd, hCatAdmin );
                if (vrd->CopyCompleted) {
                    DebugPrint1( LVL_VERBOSE,
                                 L"File [%wZ] was restored from cache",
                                 &vrd->RegVal->FileName );
                    RemoveEntry = TRUE;
                    goto continue_next;
                }
            }

            if ((vrd->Flags & VRD_FLAG_REQUEST_QUEUED) == 0) {
                //
                // check if the file is available.  If it is, then we can restore
                // it without any UI coming up
                //
                ActualFileNameOnMedia = FileNameOnMedia( RegVal );

                //
                // get the inf name here
                //
                ExcepPackFile = SfcGetInfName(RegVal, InfFileName);

                //
                // get the source information which let's us know where to look
                // for the file
                //
                wcscpy(vrd->SourceInfo.SourceFileName,ActualFileNameOnMedia);
                if (!SfcGetSourceInformation(ActualFileNameOnMedia,InfFileName,ExcepPackFile,&vrd->SourceInfo)) {
                    //
                    // if this fails, just assume that we need UI
                    //
                    vrd->Flags |= VRD_FLAG_REQUIRE_UI;
                } else {
                    WCHAR DontCare[MAX_PATH];
                    WCHAR FilePath[MAX_PATH];
                    WCHAR SourcePath[MAX_PATH];
                    SOURCE_MEDIA SourceMedia;
                    DWORD Result;

                    RtlZeroMemory( &SourceMedia, sizeof( SourceMedia ));

                    //
                    // build up a temporary SOURCE_MEDIA structure as well
                    // as the full path to the file we're looking for
                    //
                    wcscpy( SourcePath, vrd->SourceInfo.SourceRootPath );
                    pSetupConcatenatePaths(
                                SourcePath,
                                vrd->SourceInfo.SourcePath,
                                UnicodeChars(SourcePath),
                                NULL);
                    //
                    // note the wierd syntax here because TAGFILE is a macro
                    // that accepts a PSOURCE_INFO pointer.
                    //
                    SourceMedia.Tagfile     = TAGFILE(((PSOURCE_INFO)&vrd->SourceInfo));
                    SourceMedia.Description = vrd->SourceInfo.Description;
                    SourceMedia.SourcePath  = SourcePath;
                    SourceMedia.SourceFile  = ActualFileNameOnMedia;

                    wcscpy( FilePath, vrd->SourceInfo.SourceRootPath );

                    BuildPathForFile(
                                vrd->SourceInfo.SourceRootPath,
                                vrd->SourceInfo.SourcePath,
                                ActualFileNameOnMedia,
                                SFC_INCLUDE_SUBDIRECTORY,
                                SFC_INCLUDE_ARCHSUBDIR,
                                FilePath,
                                UnicodeChars(FilePath) );

                    Result = SfcQueueLookForFile(
                                &SourceMedia,
                                &vrd->SourceInfo,
                                FilePath,
                                DontCare);

                    if (Result == FILEOP_ABORT) {
                        vrd->Flags |= VRD_FLAG_REQUIRE_UI;
                    }
                }

                vrd->SourceInfo.ValidationRequestData = vrd;


                //
                // now add the file to the proper file queue
                //

                if (SfcQueueAddFileToRestoreQueue(
                                vrd->Flags & VRD_FLAG_REQUIRE_UI,
                                RegVal,
                                InfFileName,
                                ExcepPackFile,
                                &vrd->SourceInfo,
                                ActualFileNameOnMedia)) {
                    vrd->Flags |= VRD_FLAG_REQUEST_QUEUED;
                } else {
                    //
                    // we failed for some reason. put the request back in
                    // the queue to see if we can add it later on
                    //
                    WaitAgain = TRUE;
                    goto continue_entry;
                }
            }

continue_entry:
            if (vrd->RetryCount < 10) {
                NOTHING;
            } else {
                DebugPrint1( LVL_MINIMAL, L"Could not restore file [%ws], retries exceeded", RegVal->FileName.Buffer);
                RemoveEntry = TRUE;
                SfcReportEvent(
                    MSG_RESTORE_FAILURE_MAX_RETRIES,
                    RegVal->FileName.Buffer,
                    NULL,
                    0 );
            }

continue_next:

            if (RemoveEntry) {
                //
                // remove the entry if we're done with it.  otherwise we leave
                // it in the list just in case we get more notifications about
                // this file
                //
                RtlEnterCriticalSection( &ErrorCs );

                RemoveEntryList( &vrd->Entry );
                ErrorQueueCount -= 1;

                RtlLeaveCriticalSection( &ErrorCs );

                MemFree( vrd );
            }

        } // end of while(CurrentEntry != &SfcErrorQueue)

        //
        // we've cycled through the validation queue.  now if we've queued any
        // files for restoration, we can do that now.
        //

        //
        // no UI filequeue
        //
        SfcQueueCommitRestoreQueue( FALSE );
        SfcQueueResetQueue( FALSE );

        if (UserLoggedOn) {
            //
            // UI filequeue
            //
            SfcQueueCommitRestoreQueue( TRUE );
            SfcQueueResetQueue( TRUE );

        } else {
            RtlEnterCriticalSection( &UIRestoreQueue.CriticalSection );
            RtlEnterCriticalSection( &ErrorCs );
            tmpErrorQueueCount = ErrorQueueCount;
            RtlLeaveCriticalSection( &ErrorCs );
            FilesNeedToBeCommited = UIRestoreQueue.QueueCount;
            RtlLeaveCriticalSection( &UIRestoreQueue.CriticalSection );
        }

        //
        // getting ready to wait again, cleanup our admin context
        //
        if (hCatAdmin) {
            CryptCATAdminReleaseContext(hCatAdmin,0);
            hCatAdmin = NULL;
        }

        //
        // a timeout is necessary only when there are
        // entries in the list that can be acted on
        //
        // if all of our files need UI but the user is not logged on, then
        // we should just sleep until the user logs on again.
        //
        if (IsListEmpty(&SfcErrorQueue) ||
             (UserLoggedOn == FALSE
              && tmpErrorQueueCount == FilesNeedToBeCommited) ||
             (WaitAgain == FALSE) ) {
            pTimeout = NULL;
        } else {
            pTimeout = &Timeout;
        }
    }

exit:

    //
    // we're terminating our validation thread.  remember this so we don't
    // start a new thread up.
    //
    ShuttingDown = TRUE;

    //
    // Log an event for each validation request we couldn't finish servicing.
    // This will at least let the user know that they should run a scan on
    // their system.
    //
    pSfcHandleAllOrphannedRequests();

    DebugPrint( LVL_MINIMAL, L"SfcQueueValidationThread terminating" );
    return 0;
}

NTSTATUS
SfcQueueValidationRequest(
    IN PSFC_REGISTRY_VALUE RegVal,
    IN ULONG ChangeType
    )
/*++

Routine Description:

    Routine adds a new validation request to the validation queue.

    It is called by the watcher thread to add the new validation request.

    This routine must be as fast as possible because we want to start watching
    the directory for other changes as soon as possible.

Arguments:

    RegVal     - pointer to the SFC_REGISTRY_VALUE for the file that should be
                 validated.
    ChangeType - type of change that occurred to the file.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PVALIDATION_REQUEST_DATA vrd = NULL;
    PVALIDATION_REQUEST_DATA vrdexisting = NULL;

    ASSERT(RegVal != NULL);

    //
    // if we're in GUI-Setup, don't queue any validation requests
    //
    if (SFCDisable == SFC_DISABLE_SETUP) {
        return STATUS_SUCCESS;
    }

    //
    // allocate a vrd & initialize it
    //
    vrd = MemAlloc( sizeof(VALIDATION_REQUEST_DATA) );
    if (vrd == NULL) {
        DebugPrint( LVL_MINIMAL,
                    L"SfcQueueValidationRequest failed to allocate memory for validation request" );
        return STATUS_NO_MEMORY;
    }

    vrd->NextValidTime = GetTickCount() + (1000*SFCStall);
    vrd->RegVal = RegVal;
    vrd->ChangeType = ChangeType;
    vrd->Signature = SFC_VRD_SIGNATURE;

    //
    // insert it in the list if it isn't already in the list.  Note that we
    // take the hit of looking through this list right now for this file
    // because it's much simpler and faster later on if we don't have any
    // duplicates in our list
    //
    //
    // note that we do allow a duplicate entry in the list if the file has
    // already been queued for restoration (if someone changes a file after
    // we restore it but before we remove it from the queue, we don't want
    // there to be a window where we don't care if the file changes).  We
    // ignore this window in the case of restoring from cache because that
    // is a much quicker codepath.
    //
    // Note that the reasoning above is incorrect, in that the window of time
    // in the cache restore case, though much quicker than the restore from
    // media case, can be significant.  So this logic is changed to say that
    // we remove duplicate entries in the case that we haven't yet verified
    // the file's signature.  Once we verify the signature of the file and get
    // a change notification, we need another request to re-verify the file.
    //
    //
    RtlEnterCriticalSection( &ErrorCs );

    //
    // Put a try-except here since we don't want to hang on to the critical section
    // if some exception is raised (Windows bug 690573)
    //
    __try {
        vrdexisting = IsFileInQueue( RegVal);
        if (!vrdexisting || (vrdexisting->Flags & VRD_FLAG_REQUEST_PROCESSED) ) {

            DebugPrint1( LVL_VERBOSE,
                        L"Inserting [%ws] into error queue for validation",
                        RegVal->FullPathName.Buffer );

            InsertTailList( &SfcErrorQueue, &vrd->Entry );
            ErrorQueueCount += 1;

            //
            // do this to avoid free later on
            //
            vrdexisting = NULL;

        } else {
            vrd->NextValidTime = GetTickCount() + (1000*SFCStall);

            DebugPrint1( LVL_VERBOSE,
                        L"Not inserting [%ws] into error queue for validation. (The file is already present in the error validation queue.)",
                        RegVal->FullPathName.Buffer );

        }

        //
        // create the list processor thread, if necessary
        //
        if (hErrorThread == NULL) {
            Status = NtCreateEvent(
                &ErrorQueueEvent,
                EVENT_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE
                );
            if (NT_SUCCESS(Status)) {
                //
                //  Create error queue thread
                //
                hErrorThread = CreateThread(
                    NULL,
                    0,
                    SfcQueueValidationThread,
                    0,
                    0,
                    NULL
                    );
                if (hErrorThread == NULL) {
                    DebugPrint1( LVL_MINIMAL, L"Unable to create error queue thread, ec=%d", GetLastError() );
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                DebugPrint1( LVL_MINIMAL, L"Unable to create error queue event, ec=0x%08x", Status );
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugPrint1(LVL_MINIMAL, L"Exception occurred in SfcQueueValidationRequest, ec=0x%08x", Status);
    }

    RtlLeaveCriticalSection( &ErrorCs );

    //
    // signal an event to the validation thread to wakeup and process the
    // request
    //
    if (NT_SUCCESS(Status)) {

        ASSERT(hErrorThread != NULL);
        NtSetEvent(ErrorQueueEvent,NULL);
    }

    //
    // if we already inserted an event into the list, we don't need this
    // entry anymore, so free it
    //
    if (vrdexisting) {
        MemFree( vrd );
    }

    return Status;
}


BOOL
SfcGetValidationData(
    IN PUNICODE_STRING FileName,
    IN PUNICODE_STRING FullPathName,
    IN HANDLE DirHandle,
    IN HCATADMIN hCatAdmin,
    OUT PIMAGE_VALIDATION_DATA ImageValData
    )
/*++

Routine Description:

    Routine takes a filename in a given directory and fills in an
    IMAGE_VALIDATION_DATA structure based on it's checks

Arguments:

    FileName  - unicode_string containing file to be checked
    FullPathName - unicode_string containing fully qualified path name of file
    DirHandle - handle to directory the file is located in
    hCatAdmin - crypto context handle to be used in checking file
    ImageValData - pointer to IMAGE_VALIDATION_DATA structure

Return Value:

    TRUE indicates the file data was successfully retreived.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;

    ASSERT((FileName != NULL) && (FileName->Buffer != NULL));
    ASSERT((FullPathName != NULL) && (FullPathName->Buffer != NULL));
    ASSERT(   (DirHandle != NULL)
           && (hCatAdmin != NULL)
           && (ImageValData != NULL) );

    RtlZeroMemory( ImageValData, sizeof(IMAGE_VALIDATION_DATA) );

    //
    // open the file
    //

    Status = SfcOpenFile( FileName, DirHandle, SHARE_ALL, &FileHandle );
    if (NT_SUCCESS(Status)) {

        ASSERT(FileHandle != INVALID_HANDLE_VALUE);
        ImageValData->FilePresent = TRUE;
        SfcGetFileVersion(FileHandle,
                            &ImageValData->DllVersion,
                            &ImageValData->DllCheckSum,
                            ImageValData->FileName );
    } else {
        //
        // we don't to anything on failure since this is an expected state
        // if the file was just removed.  The member variables's below are
        // automatically set at the entrypoint to the function so they are
        // not necessary but are present and commented out for the sake of
        // clarity
        //
        NOTHING;
        //ImageValData->SignatureValid = FALSE;
        //ImageValData->FilePresent = FALSE;
    }

    //
    // verify the file signature
    //

    if (hCatAdmin && FileHandle != NULL) {
        ImageValData->SignatureValid = SfcValidateFileSignature(
                                                    hCatAdmin,
                                                    FileHandle,
                                                    FileName->Buffer,
                                                    FullPathName->Buffer);
    } else {
        ImageValData->SignatureValid = FALSE;
    }

    //
    // close the file
    //

    if (FileHandle != INVALID_HANDLE_VALUE) {
        NtClose( FileHandle );
    }

    return TRUE;
}


BOOL
SfcValidateDLL(
    IN PVALIDATION_REQUEST_DATA vrd,
    IN HCATADMIN hCatAdmin
    )
/*++

Routine Description:

    Routine takes a validation request and processes it.

    It does this by checking if the file is present, and if so, it checks the
    signature of the file.

    This routine does not replace any files, it merely checks the signature of
    the file and of the copy of the file in the cache, if present.

Arguments:

    vrd - pointer to VALIDATION_REQUEST_DATA structure describing the file to
          be checked.
    hCatAdmin - crypto context handle to be used in checking file

Return Value:

    always TRUE (indicates we successfully validated the DLL as good or bad)

--*/
{
    PSFC_REGISTRY_VALUE RegVal = vrd->RegVal;
    PCOMPLETE_VALIDATION_DATA ImageValData = &vrd->ImageValData;
    UNICODE_STRING ActualFileName;
    PCWSTR FileName;

    //
    // get the version information for both files (the cached version and the
    // current version)
    //

    SfcGetValidationData( &RegVal->FileName,
                          &RegVal->FullPathName,
                          RegVal->DirHandle,
                          hCatAdmin,
                          &ImageValData->Original);

    {
        UNICODE_STRING FullPath;
        WCHAR Buffer[MAX_PATH];

        RtlZeroMemory( &ImageValData->Cache, sizeof(IMAGE_VALIDATION_DATA) );

        FileName = FileNameOnMedia( RegVal );
        RtlInitUnicodeString( &ActualFileName, FileName );


        ASSERT(FileName != NULL);

        wcscpy(Buffer, SfcProtectedDllPath.Buffer);
        pSetupConcatenatePaths( Buffer, ActualFileName.Buffer, UnicodeChars(Buffer), NULL);
        RtlInitUnicodeString( &FullPath, Buffer );

        SfcGetValidationData( &ActualFileName,
                              &FullPath,
                              SfcProtectedDllFileDirectory,
                              hCatAdmin,
                              &ImageValData->Cache);

    }

    DebugPrint8( LVL_VERBOSE, L"Version Data (%wZ),(%ws) - %I64x, %I64x, %lx, %lx (%ws) >%ws<",
        &RegVal->FileName,
        ImageValData->Original.FileName,
        ImageValData->Original.DllVersion,
        ImageValData->Cache.DllVersion,
        ImageValData->Original.DllCheckSum,
        ImageValData->Cache.DllCheckSum,
        ImageValData->Original.FilePresent ? L"Present" : L"Missing",
        ImageValData->Original.SignatureValid ? L"good" : L"bad"
        );

    //
    // log the fact that the file was validated
    //
#ifdef SFCCHANGELOG
    if (SFCChangeLog) {
        SfcLogFileWrite( IDS_FILE_CHANGE, RegVal->FileName.Buffer );
    }
#endif

    return TRUE;
}

BOOL
pSfcHandleAllOrphannedRequests(
    VOID
    )
/*++

Routine Description:

    This function cycles through the list of validation requests, taking an
    action (for now, just logging an event) for each request, then removing
    the request

Arguments: None.

Return Value: TRUE indicates that all requests were successfully removed.  If
    any request could not be closed, the return value is FALSE.
--*/
{
    PLIST_ENTRY Current;
    PVALIDATION_REQUEST_DATA vrd;
    BOOL RetVal = TRUE;
    DWORD Total;

    RtlEnterCriticalSection( &ErrorCs );

    Total = ErrorQueueCount;

    Current = SfcErrorQueue.Flink;
    while (Current != &SfcErrorQueue) {

        vrd = CONTAINING_RECORD( Current, VALIDATION_REQUEST_DATA, Entry );

        ASSERT( vrd->Signature == SFC_VRD_SIGNATURE );
        ASSERT( vrd->RegVal != NULL );

        Current = Current->Flink;

        SfcReportEvent(
                MSG_DLL_NOVALIDATION_TERMINATION,
                vrd->RegVal->FullPathName.Buffer,
                NULL,
                0 );

        ErrorQueueCount -= 1;

        RemoveEntryList( &vrd->Entry );
        MemFree( vrd );

    }

    RtlLeaveCriticalSection( &ErrorCs );

    ASSERT( ErrorQueueCount == 0 );

    return(RetVal);
}


BOOL
SfcWaitForValidDesktop(
    VOID
    )
{
    HDESK hDesk = NULL;
    WCHAR DesktopName[128];
    DWORD BytesNeeded;
    DWORD i;

    BOOL RetVal = FALSE;

    #define MAX_DESKTOP_RETRY_COUNT 60


    if (hEventLogon) {
        //
        // open a handle to the desktop and check if the current desktop is the
        // default desktop.  If it isn't then wait for the desktop event to be
        // signalled before proceeding
        //
        // Note that this event is pulsed so we have a timeout loop in case the
        // event isn't signalled while we are waiting for it and the desktop
        // transitions from the winlogon desktop to the default desktop
        //

        i = 0;
try_again:
        ASSERT( hDesk == NULL );
        hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );
        if (GetUserObjectInformation( hDesk, UOI_NAME, DesktopName, sizeof(DesktopName), &BytesNeeded )) {
            if (wcscmp( DesktopName, L"Default" )) {
                if (WaitForSingleObject( hEventDeskTop, 1000 * 2 ) == WAIT_TIMEOUT) {
                    i += 1;
                    if (i < MAX_DESKTOP_RETRY_COUNT) {
                        if (hDesk) {
                            CloseDesktop( hDesk );
                            hDesk = NULL;
                        }
                        goto try_again;
                    }
                } else {
                    RetVal = TRUE;
                }
            } else {
                RetVal = TRUE;
            }
        }
        if (hDesk) {
            CloseDesktop( hDesk );
        }
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\util.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Implementation of general utility functions.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

    Andrew Ritz (andrewr) 6-Jul-1999 : added comments

--*/

#include "sfcp.h"
#pragma hdrstop

//
// use this define to force path redirections
//
//#define SFC_REDIRECTOR_TEST


#define CONST_UNICODE_STRING(sz)         { sizeof(sz) - 1, sizeof(sz), sz }

#ifndef _WIN64

typedef struct _SFC_EXPAND_TRANSLATION_ENTRY
{
    LPCWSTR Src;                        // full path to translate from (does not end in \\)
    LPCWSTR Dest;                       // full path to translate to
    ULONG ExceptionCount;               // count of elements in Exceptions
    const UNICODE_STRING* Exceptions;   // array of excepted paths, relative to Src (begins with \\ but does not end in \\)
}
SFC_EXPAND_TRANSLATION_ENTRY;

typedef struct _SFC_TRANSLATION_ENTRY
{
    UNICODE_STRING Src;
    UNICODE_STRING Dest;
}
SFC_TRANSLATION_ENTRY;

//
// exception lists; relative paths with no environment variables
//
static const UNICODE_STRING SfcSystem32Exceptions[] = 
{
    CONST_UNICODE_STRING(L"\\drivers\\etc"),
    CONST_UNICODE_STRING(L"\\spool"),
    CONST_UNICODE_STRING(L"\\catroot"),
    CONST_UNICODE_STRING(L"\\catroot2")
};

//
// translation table that is expanded into SfcTranslations
//
static const SFC_EXPAND_TRANSLATION_ENTRY SfcExpandTranslations[] =
{
    { L"%windir%\\system32", L"%windir%\\syswow64", ARRAY_LENGTH(SfcSystem32Exceptions), SfcSystem32Exceptions },
    { L"%windir%\\ime", L"%windir%\\ime (x86)", 0, NULL },
    { L"%windir%\\regedit.exe", L"%windir%\\syswow64\\regedit.exe", 0, NULL }
};

//
// translation table with expanded strings
//
static SFC_TRANSLATION_ENTRY* SfcTranslations = NULL;

//
// this guards the initialization of SfcTranslations
//
static RTL_CRITICAL_SECTION SfcTranslatorCs;
static BOOL SfcNeedTranslation = FALSE;
static BOOL SfcIsTranslatorInitialized = FALSE;

#endif  // _WIN64


PVOID
SfcGetProcAddress(
    HMODULE hModule,
    LPSTR ProcName
    )

/*++

Routine Description:

    Gets the address of the specified function.

Arguments:

    hModule     - Module handle returned from LdrLoadDll.
    ProcName    - Procedure name

Return Value:

    NULL if the function does not exist.
    Valid address is the function is found.

--*/

{
    NTSTATUS Status;
    PVOID ProcedureAddress;
    STRING ProcedureName;

    ASSERT((hModule != NULL) && (ProcName != NULL));


    RtlInitString(&ProcedureName,ProcName);

    Status = LdrGetProcedureAddress(
        hModule,
        &ProcedureName,
        0,
        &ProcedureAddress
        );
    if (!NT_SUCCESS(Status)) {
        DebugPrint2( LVL_MINIMAL, L"GetProcAddress failed for %S, ec=%lx", ProcName, Status );
        return NULL;
    }

    return ProcedureAddress;
}


HMODULE
SfcLoadLibrary(
    IN PCWSTR LibFileName
    )

/*++

Routine Description:

    Loads the specified DLL into session manager's
    address space and return the loaded DLL's address.

Arguments:

    LibFileName - Name of the desired DLL

Return Value:

    NULL if the DLL cannot be loaded.
    Valid address is the DLL is loaded.

--*/

{
    NTSTATUS Status;
    HMODULE hModule;
    UNICODE_STRING DllName_U;

    ASSERT(LibFileName);

    RtlInitUnicodeString( &DllName_U, LibFileName );

    Status = LdrLoadDll(
        NULL,
        NULL,
        &DllName_U,
        (PVOID *)&hModule
        );
    if (!NT_SUCCESS( Status )) {
        DebugPrint2( LVL_MINIMAL, L"LoadDll failed for %ws, ec=%lx", LibFileName, Status );
        return NULL;
    }

    return hModule;
}

PVOID
MemAlloc(
    SIZE_T AllocSize
    )
/*++

Routine Description:

    Allocates the specified number of bytes using the default process heap.


Arguments:

    AllocSize - size in bytes of memory to be allocated

Return Value:

    pointer to allocated memory or NULL for failure.

--*/
{
    return RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, AllocSize );
}


PVOID
MemReAlloc(
    SIZE_T AllocSize,
    PVOID OrigPtr
    )
/*++

Routine Description:

    ReAllocates the specified number of bytes using the default process heap.


Arguments:

    AllocSize - size in bytes of memory to be reallocated
    OrigPtr   - original heap memory pointer

Return Value:

    pointer to allocated memory or NULL for failure.

--*/
{
    PVOID ptr;

    ptr = RtlReAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, OrigPtr, AllocSize );
    if (!ptr) {
        DebugPrint1( LVL_MINIMAL, L"MemReAlloc [%d bytes] failed", AllocSize );
    }

    return(ptr);
}



VOID
MemFree(
    PVOID MemPtr
    )
/*++

Routine Description:

    Free's the memory at the specified location from the default process heap.

Arguments:

    MemPtr - pointer to memory to be freed.  If NULL, no action is taken.

Return Value:

    none.

--*/
{
    if (MemPtr) {
        RtlFreeHeap( RtlProcessHeap(), 0, MemPtr );
    }
}


void 
SfcWriteDebugLog(
        IN LPCSTR String, 
        IN ULONG Length OPTIONAL
        )
{
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Attrs;
        UNICODE_STRING FileName;
        IO_STATUS_BLOCK iosb;
        HANDLE hFile;

        ASSERT(String != NULL);

        if(RtlDosPathNameToNtPathName_U(g_szLogFile, &FileName, NULL, NULL))
        {
                InitializeObjectAttributes(&Attrs, &FileName, OBJ_CASE_INSENSITIVE, NULL, NULL);
                
                Status = NtCreateFile(
                        &hFile, 
                        FILE_APPEND_DATA | SYNCHRONIZE, 
                        &Attrs, 
                        &iosb, 
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ, 
                        FILE_OPEN_IF,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                        NULL,
                        0
                        );

                MemFree(FileName.Buffer);

                if(!NT_SUCCESS(Status))
                {
#if DBG
                        DbgPrint("Could not open the log file.\r\n");
#endif

                        return;
                }

                if(0 == Length)
                        Length = strlen(String);

                Status = NtWriteFile(hFile, NULL, NULL, NULL, &iosb, (PVOID) String, Length, NULL, NULL);
                NtClose(hFile);

#if DBG
                if(!NT_SUCCESS(Status))
                        DbgPrint("Could not write the log file.\r\n");
#endif
        }
}

#define CHECK_DEBUG_LEVEL(var, l)       ((var) != LVL_SILENT && (l) <= (var))

void
dprintf(
    IN ULONG Level,
    IN PCWSTR FileName,
    IN ULONG LineNumber,
    IN PCWSTR FormatStr,
    IN ...
    )
/*++

Routine Description:

    Main debugger output routine.  Callers should use the DebugPrintX macro,
    which is compiled out in the retail version of the product

Arguments:

    Level -  indicates a LVL_ severity level so the amount of output can be
             controlled.
    FileName - string indicating the filename the debug comes from
    LineNumber - indicates the line number of the debug output.
    FormatStr - indicates the data to be output

Return Value:

    none.

--*/
{
    static WCHAR buf[4096];
    static CHAR str[4096];
    va_list arg_ptr;
    ULONG Bytes;
    PWSTR p;
    SYSTEMTIME CurrTime;

#if DBG
    if(!CHECK_DEBUG_LEVEL(SFCDebugDump, Level) && !CHECK_DEBUG_LEVEL(SFCDebugLog, Level))
        return;
#else
    if(!CHECK_DEBUG_LEVEL(SFCDebugLog, Level))
        return;
#endif

    GetLocalTime( &CurrTime );

    try {
        p = buf + swprintf( buf, L"SFC: %02d:%02d:%02d.%03d ",
            CurrTime.wHour,
            CurrTime.wMinute,
            CurrTime.wSecond,
            CurrTime.wMilliseconds
            );

#if DBG
        if (FileName && LineNumber) {
                        PWSTR s;
            s = wcsrchr( FileName, L'\\' );
            if (s) {
                p += swprintf( p, L"%12s @ %4d ", s+1, LineNumber );
            }
        }
#else
                //
                // put only the line number in output
                //
                p += swprintf(p, L"@ %4d ", LineNumber);
#endif

        va_start( arg_ptr, FormatStr );
        p += _vsnwprintf( p, 2048, FormatStr, arg_ptr );
        va_end( arg_ptr );
        wcscpy( p, L"\r\n" );
                p += wcslen(p);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return;
    }

    Bytes = (ULONG)(p - buf);

    WideCharToMultiByte(
        CP_ACP,
        0,
        buf,
        Bytes + 1,      // include the null
        str,
        sizeof(str),
        NULL,
        NULL
        );

#if DBG
    if(CHECK_DEBUG_LEVEL(SFCDebugDump, Level))
                DbgPrint( str );

    if(CHECK_DEBUG_LEVEL(SFCDebugLog, Level))
                SfcWriteDebugLog(str, Bytes);
#else
        SfcWriteDebugLog(str, Bytes);
#endif
}


#if DBG
UCHAR HandleBuffer[1024*64];

VOID
PrintHandleCount(
    PCWSTR str
    )
/*++

Routine Description:

    Outputs the handle count for the current process to the debugger.  Use
    this call before and after a function to look for handle leaks (the input
    string can help you identify where you are checking the handle count.)

Arguments:

    str - null terminated unicode string that prefaces the debug spew

Return Value:

    none.  Debug routine only.

--*/
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    NTSTATUS Status;
    ULONG TotalOffset;

    //
    // get the system process information
    //
    Status = NtQuerySystemInformation(
        SystemProcessInformation,
        HandleBuffer,
        sizeof(HandleBuffer),
        NULL
        );
    if (NT_SUCCESS(Status)) {
        //
        // find our process and spew the handle count
        //
        TotalOffset = 0;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)HandleBuffer;
        while(1) {
            if ((DWORD_PTR)ProcessInfo->UniqueProcessId == (ULONG_PTR)NtCurrentTeb()->ClientId.UniqueProcess) {
                DebugPrint2( LVL_MINIMAL, L"%ws: handle count = %d", str, ProcessInfo->HandleCount );
                break;
            }
            if (ProcessInfo->NextEntryOffset == 0) {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&HandleBuffer[TotalOffset];
        }
    }
}

#endif


DWORD
MyMessageBox(
    HWND hwndParent, OPTIONAL
    DWORD ResId,
    DWORD MsgBoxType,
    ...
    )
/*++

Routine Description:

    Messagebox wrapper that retreives a string table resource id and creates a
    popup for the given message.

Arguments:

    hwndParent - handle to parent window
    ResId      - resource id of string to be loaded
    MsgBoxType - MB_* constant

Return Value:

    Win32 error code indicating outcome

--*/
{
    static WCHAR Title[128] = { L"\0" };
    WCHAR Tmp1[MAX_PATH*2];
    WCHAR Tmp2[MAX_PATH*2];
    PWSTR Text = NULL;
    PWSTR s;
    va_list arg_ptr;
    int Size;


    //
    // SFCNoPopUps is a policy setting that can be set
    //
    if (SFCNoPopUps) {
        return(0);
    }

    //
    // load the title string
    //
    if (!Title[0]) {
        Size = LoadString(
            SfcInstanceHandle,
            IDS_TITLE,
            Title,
            UnicodeChars(Title)
            );
        if (Size == 0) {
            return(0);
        }
    }

    //
    // load the message string
    //
    Size = LoadString(
        SfcInstanceHandle,
        ResId,
        Tmp1,
        UnicodeChars(Tmp1)
        );
    if (Size == 0) {
        return(0);
    }

    //
    // inplace substitution can occur here
    //
    s = wcschr( Tmp1, L'%' );
    if (s) {
        va_start( arg_ptr, MsgBoxType );
        _vsnwprintf( Tmp2, sizeof(Tmp2)/sizeof(WCHAR), Tmp1, arg_ptr );
        va_end( arg_ptr );
        Text = Tmp2;
    } else {
        Text = Tmp1;
    }

    //
    // actually call messagebox now
    //
    return MessageBox(
        hwndParent,
        Text,
        Title,
        (MsgBoxType | MB_TOPMOST) & ~MB_DEFAULT_DESKTOP_ONLY
        );
}


BOOL
EnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


void
MyLowerString(
    IN PWSTR String,
    IN ULONG StringLength  // in characters
    )
/*++

Routine Description:

    lowercase the specified string.

Arguments:

    String - supplies string to lowercase

    StringLength - length in chars of string to be lowercased

Return Value:

    none.

--*/
{
    ULONG i;

    ASSERT(String != NULL);

    for (i=0; i<StringLength; i++) {
        String[i] = towlower(String[i]);
    }
}

#ifdef SFCLOGFILE
void
SfcLogFileWrite(
    IN DWORD StrId,
    IN ...
    )
/*++

Routine Description:

    Output the string table resource id as specified to the sfc logfile.

    This logfile is used to record files that have been restored on the system.
    This way, an installer can know if packages are attempting to install
    system components.

    The logfile is a unicode text file of the format:

    <TIME> <FILENAME>

    We need to record the full path of the file plus the date for this to
    be more useful.

Arguments:

    StrId - supplies resource id to load.


Return Value:

    none.

--*/
{
    static WCHAR buf[4096];
    static HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR str[128];
    va_list arg_ptr;
    ULONG Bytes;
    PWSTR p;
    SYSTEMTIME CurrTime;

    GetSystemTime( &CurrTime );

    if (hFile == INVALID_HANDLE_VALUE) {
        ExpandEnvironmentStrings( L"%systemroot%\\sfclog.txt", buf, UnicodeChars(buf) );
        hFile = CreateFile(
            buf,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL
            );
        if (hFile != INVALID_HANDLE_VALUE) {
            //
            // If the file is empty, write out a unicode tag to the front of
            // the file.
            //
            if (GetFileSize( hFile, NULL ) == 0) {
                buf[0] = 0xff;
                buf[1] = 0xfe;
                WriteFile( hFile, buf, 2, &Bytes, NULL );
            }
        }
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    try {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d:%02d:%02d.%03d ",
            CurrTime.wHour,
            CurrTime.wMinute,
            CurrTime.wSecond,
            CurrTime.wMilliseconds
            );
        p += wcslen(p);
        LoadString( SfcInstanceHandle, StrId, str, UnicodeChars(str) );
        va_start( arg_ptr, StrId );
        _vsnwprintf( p, 2048, str, arg_ptr );
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        buf[0] = 0;
    }

    if (buf[0] == 0) {
        return;
    }

    //
    // set file pointer to end of file so we don't overwrite data
    //
    SetFilePointer(hFile,0,0,FILE_END);

    WriteFile( hFile, buf, UnicodeLen(buf), &Bytes, NULL );

    return;
}

#endif


int
MyDialogBoxParam(
    IN DWORD RcId,
    IN DLGPROC lpDialogFunc,    // pointer to dialog box procedure
    IN LPARAM dwInitParam       // initialization value
    )
/*++

Routine Description:

    creates a dialog box on the user's desktop.

Arguments:

    RcId - resource id of dialog to be created.
    lpDialogFunc - dialog proc for dialog
    dwInitParam - initial parameter that WM_INITDIALOG receives in dialogproc


Return Value:

    0 or -1 for failure, else the value from EndDialog.

--*/
{
#if 0
    HDESK hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );
    if ( hDesk ) {
        SetThreadDesktop( hDesk );
        CloseDesktop( hDesk );
    }
#else
    SetThreadDesktop( hUserDesktop );
#endif
    return (int) DialogBoxParam(
        SfcInstanceHandle,
        MAKEINTRESOURCE(RcId),
        NULL,
        lpDialogFunc,
        dwInitParam
        );
}


void
CenterDialog(
    HWND hwnd
    )
/*++

Routine Description:

    centers the specified window around the middle of the screen..

Arguments:

    HWND - handle to window.


Return Value:

    none.

--*/
{
    RECT  rcWindow;
    LONG  x,y,w,h;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN),
          sy = GetSystemMetrics(SM_CYSCREEN);

    ASSERT(IsWindow(hwnd));

    GetWindowRect(hwnd,&rcWindow);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = (sx - w)/2;
    y = (sy - h)/2;

    MoveWindow(hwnd,x,y,w,h,FALSE);
}

BOOL
MakeDirectory(
    PCWSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p, NewDir;
    BOOL retval;


    NewDir = p = MemAlloc( (wcslen(Dir) + 1) *sizeof(WCHAR) );
    if (p) {
        wcscpy(p, Dir);
    } else {
        return(FALSE);
    }


    if (*p != '\\') p += 2;
    while( *++p ) {
        while(*p && *p != TEXT('\\')) p++;
        if (!*p) {
            retval = CreateDirectory( NewDir, NULL );

            retval = retval
                      ? retval
                      : (GetLastError() == ERROR_ALREADY_EXISTS) ;

            MemFree(NewDir);


            return(retval);
        }
        *p = 0;
        retval = CreateDirectory( NewDir, NULL );
        if (!retval && GetLastError() != ERROR_ALREADY_EXISTS) {
            MemFree(NewDir);
            return(retval);
        }
        *p = TEXT('\\');
    }

    MemFree( NewDir );

    return(TRUE);
}


BOOL
BuildPathForFile(
    IN PCWSTR SourceRootPath,
    IN PCWSTR SubDirectoryPath, OPTIONAL
    IN PCWSTR FileName,
    IN BOOL   IncludeSubDirectory,
    IN BOOL   IncludeArchitectureSpecificSubDirectory,
    OUT PWSTR  PathBuffer,
    IN DWORD  PathBufferSize
    )
/*++

Routine Description:

    Builds the specified path into a buffer

Arguments:

    SourceRootPath          - Specifies the root path to look for.
    SubDirectoryPath        - Specifies an optional subdirectory under the root
                              path where the file is located
    FileName                - Specifies the filename to look for.
    IncludeSubDirectory     - If TRUE, specifies that the subdirectory
                              specification should be used.
    IncludeArchitectureSpecificSubDirectory - If TRUE, specifies that the
                              architecture specif subdir should be used.
                              If FALSE, specifies that the architecture
                              specific subdir should be filtered out.
                              If IncludeSubDirectory is FALSE, this parameter
                              is ignored
    PathBuffer              - Specifies a buffer to receive the path
    PathBufferSize          - Specifies the size of the buffer to receive the
                              path, in characters

Return Value:

    TRUE for success, FALSE on error

--*/
{
    WCHAR InternalBuffer[MAX_PATH];
    WCHAR InternalSubDirBuffer[MAX_PATH];
    PWSTR p;

    ASSERT( SourceRootPath != NULL );
    ASSERT( FileName != NULL );
    ASSERT( PathBuffer != NULL );

    wcscpy( InternalBuffer, SourceRootPath );

    if (IncludeSubDirectory) {
        if (SubDirectoryPath) {
            wcscpy( InternalSubDirBuffer, SubDirectoryPath );

            if (IncludeArchitectureSpecificSubDirectory) {
                p = InternalSubDirBuffer;
            } else {
                p = wcsstr( InternalSubDirBuffer, PLATFORM_NAME );
                if (p) {
                    p += wcslen(PLATFORM_NAME) + 1;
                    if (p > InternalSubDirBuffer + wcslen(InternalSubDirBuffer)) {
                        p = NULL;
                    }
                }
            }
        } else {
            p = NULL;
        }

        if (p) {
            pSetupConcatenatePaths( InternalBuffer, p, UnicodeChars(InternalBuffer), NULL );
        }

    }

    pSetupConcatenatePaths( InternalBuffer, FileName, UnicodeChars(InternalBuffer), NULL );

    if (wcslen(InternalBuffer) + 1 <= PathBufferSize) {
        wcscpy( PathBuffer, InternalBuffer );
        return(TRUE);
    }

    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return(FALSE);

}

PWSTR
SfcGetSourcePath(
    IN BOOL bServicePackSourcePath,
    IN OUT PWSTR Path
    )
/*++

Routine Description:

    Retreives the os source path or servicepack source path, taking into
    account group policy.

Arguments:

    bServicePackSourcePath  - if TRUE, indicates that the servicepack source
                              path should be retreived.
    Path                    - Specifies the buffer to receive the path.
                              Assume the buffer is at least
                              MAX_PATH*sizeof(WCHAR) large.
                              path where the file is located

Return Value:

    if successful, returns back a pointer to Path, else NULL

--*/
{
    PWSTR p;

    MYASSERT(Path != NULL);

    // If running under setup then we need to use the path 
    // to $WINNT$.~LS or whatever passed in by GUI-setup.
    if (SFCDisable == SFC_DISABLE_SETUP) {
        MYASSERT(ServicePackSourcePath != NULL && ServicePackSourcePath[0] != 0);
        MYASSERT(OsSourcePath != NULL && OsSourcePath[0] != 0);
        if(bServicePackSourcePath) {
            wcsncpy( Path, ServicePackSourcePath, MAX_PATH );
        } else {
            wcsncpy( Path, OsSourcePath, MAX_PATH );
        }
        return(Path);
    }
    p = SfcQueryRegStringWithAlternate(
                            REGKEY_POLICY_SETUP,
                            REGKEY_SETUP_FULL,
                            bServicePackSourcePath
                                ? REGVAL_SERVICEPACKSOURCEPATH
                                : REGVAL_SOURCEPATH );
    if(p) {
       wcsncpy( Path, p, MAX_PATH );
       MemFree( p );
    }

    return((p != NULL)
            ? Path
            : NULL );



}

DWORD
SfcCreateSid(
    IN WELL_KNOWN_SID_TYPE type,
    OUT PSID* ppSid
    )
/*++

Routine Description:

    Allocates and creates a well-known SID.

Arguments:

    type    - type of SID to create
    ppSid   - receives a pointer to the newly-created SID

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PSID pSid = NULL;
    DWORD dwSize = SECURITY_MAX_SID_SIZE;

    *ppSid = NULL;
    pSid = (PSID) MemAlloc(dwSize);

    if(NULL == pSid) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    if(!CreateWellKnownSid(type, NULL, pSid, &dwSize)) {
        dwError = GetLastError();
        goto exit;
    }

    *ppSid = pSid;
    pSid = NULL;

exit:
    MemFree(pSid);
    return dwError;
}

DWORD
SfcGetSidName(
    IN PSID pSid,
    OUT PWSTR* ppszName
    )
/*++

Routine Description:

    Gets the account name of a SID. The function allocates the buffer for the name.

Arguments:

    pSid        - pointer to the SID
    ppszName    - receives a pointer to the allocated buffer that holds the account name

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PWSTR szName = NULL;
    PWSTR szDomain = NULL;
    DWORD dwNameSize;
    DWORD dwDomainSize;
    SID_NAME_USE use;

    *ppszName = NULL;
    dwNameSize = dwDomainSize = 256;
    szName = (PWSTR) MemAlloc(dwNameSize);
    szDomain = (PWSTR) MemAlloc(dwDomainSize);

    if(NULL == szName || NULL == szDomain) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    if(!LookupAccountSid(NULL, pSid, szName, &dwNameSize, szDomain, &dwDomainSize, &use)) {
        dwError = GetLastError();
        goto exit;
    }

    *ppszName = szName;
    szName = NULL;

exit:
    MemFree(szName);
    MemFree(szDomain);
    return dwError;
}

DWORD 
SfcIsUserAdmin(
    IN HANDLE hToken OPTIONAL,
    OUT PBOOL Result
    )
/*++

Routine Description:

    Verifies if an impersonation token is a member of the local administrators group.

Arguments:

    hToken  - handle to the impersonation token; if NULL, the current thread's impersonation token (or the process token if
              the thread is not impersonating) is used

    Result  - receives a non-zero value if the token is a member of the administrators group, FALSE otherwise

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PSID pSid = NULL;
    *Result = FALSE;

    dwError = SfcCreateSid(WinBuiltinAdministratorsSid, &pSid);

    if(dwError != ERROR_SUCCESS) {
        goto exit;
    }

    if(!CheckTokenMembership(hToken, pSid, Result)) {
        dwError = GetLastError();
        goto exit;
    }

exit:
    MemFree(pSid);
    return dwError;
}

DWORD
SfcRpcPriviledgeCheck(
    IN HANDLE RpcHandle
    )
/*++

Routine Description:

    Check if the user has sufficient privilege to perform the requested action.

    Currently only administrators have privilege to do this.

Arguments:

    RpcHandle - Rpc binding handle used for impersonating the client.

Return Value:

    Win32 error code indicating outcome -- RPC_S_OK (ERROR_SUCCESS) indicates
    success.

--*/
{
    DWORD dwError;
    DWORD dwTemp;
    BOOL IsAdmin;

    //
    // impersonate the calling client
    //
    dwError = RpcImpersonateClient(RpcHandle);

    if (dwError != RPC_S_OK) {
        DebugPrint1( LVL_MINIMAL, L"RpcImpersonateClient failed, ec = %d",dwError );
        goto exit;
    }

    //
    // make sure the user has sufficient privilege
    //
    dwError = SfcIsUserAdmin(NULL, &IsAdmin);

    //
    // revert back to original context.  if this fails, we must return failure.
    //
    dwTemp = RpcRevertToSelf();

    if (dwTemp != RPC_S_OK) {
        dwError = dwTemp;
        DebugPrint1( LVL_MINIMAL, L"RpcRevertToSelf failed, ec = 0x%08x", dwError );
        goto exit;
    }

    if(ERROR_SUCCESS == dwError && !IsAdmin) {
        dwError = ERROR_ACCESS_DENIED;
    }

exit:
    return dwError;
}

PSFC_GET_FILES
SfcLoadSfcFiles(
    BOOL bLoad
    )
/*++

Routine Description:

    Loads or unloads sfcfiles.dll and gets the address of SfcGetFiles function

Arguments:

    bLoad:  TRUE to load sfcfiles.dll, false otherwise.

Return Value:

    If bLoad is TRUE and the function is successful, it returns the address of SfcGetFiles function, otherwise NULL

--*/
{
        static HMODULE h = NULL;
    PSFC_GET_FILES pfGetFiles = NULL;

    if(bLoad)
    {
        if(NULL == h)
        {
                h = SfcLoadLibrary(L"sfcfiles.dll");
        }

        if(h != NULL)
        {
            pfGetFiles = (PSFC_GET_FILES) GetProcAddress(h, "SfcGetFiles");
        }
    }

    if(NULL == pfGetFiles && h != NULL)
    {
        LdrUnloadDll(h);
        h = NULL;
    }

    return pfGetFiles;
}

#if DBG
DWORD GetProcessOwner(PTOKEN_OWNER* ppto)
{
        HANDLE hToken = NULL;
        DWORD dwSize = 100;
        DWORD dwError;

        ASSERT(ppto != NULL);
        *ppto = (PTOKEN_OWNER) MemAlloc(dwSize);

        if(NULL == *ppto)
        {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto lExit;
        }

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
        {
                dwError = GetLastError();
                goto lExit;
        }

        if(!GetTokenInformation(hToken, TokenOwner, *ppto, dwSize, &dwSize))
        {
                PTOKEN_OWNER p;
                dwError = GetLastError();

                if(dwError != ERROR_INSUFFICIENT_BUFFER)
                        goto lExit;

                p = (PTOKEN_OWNER) MemReAlloc(dwSize, *ppto);

                if(NULL == p)
                {
                        dwError = ERROR_NOT_ENOUGH_MEMORY;
                        goto lExit;
                }

                *ppto = p;
                
                if(!GetTokenInformation(hToken, TokenOwner, *ppto, dwSize, &dwSize))
                {
                        dwError = GetLastError();
                        goto lExit;
                }
        }

        dwError = ERROR_SUCCESS;

lExit:
        if(dwError != ERROR_SUCCESS && *ppto != NULL)
        {
                MemFree(*ppto);
                *ppto = NULL;
        }

        if(hToken != NULL)
                CloseHandle(hToken);

        return dwError;
}

DWORD CreateSd(PSECURITY_DESCRIPTOR* ppsd)
{
        enum
        {
                AuthenticatedUsers,
                MaxSids
        };

        PTOKEN_OWNER pto = NULL;
        PSID psids[MaxSids] = { NULL };
        const DWORD cdwAllowedAceLength = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD);
        SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
        PACL pacl;
        DWORD dwAclSize;
        DWORD dwError;
        DWORD i;

        ASSERT(ppsd != NULL);
        *ppsd = NULL;

        dwError = GetProcessOwner(&pto);

        if(dwError != ERROR_SUCCESS)
                goto lExit;

        if(!AllocateAndInitializeSid(
                &sidNtAuthority,
                1,
                SECURITY_AUTHENTICATED_USER_RID,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                psids + AuthenticatedUsers
                ))
        {
                dwError = GetLastError();
                goto lExit;
        }

        //
        // compute the size of ACL
        //
        dwAclSize = sizeof(ACL) + cdwAllowedAceLength + GetLengthSid(pto->Owner);
        
        for(i = 0; i < MaxSids; i++)
                dwAclSize += cdwAllowedAceLength + GetLengthSid(psids[i]);

        *ppsd = (PSECURITY_DESCRIPTOR) MemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize);

        if(NULL == *ppsd)
        {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto lExit;
        }

        pacl = (PACL) ((LPBYTE) (*ppsd) + SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(
                !InitializeAcl(pacl, dwAclSize, ACL_REVISION) ||
                !AddAccessAllowedAce(pacl, ACL_REVISION, EVENT_ALL_ACCESS, pto->Owner) ||
                !AddAccessAllowedAce(pacl, ACL_REVISION, EVENT_MODIFY_STATE, psids[AuthenticatedUsers]) ||
                !InitializeSecurityDescriptor(*ppsd, SECURITY_DESCRIPTOR_REVISION) ||
                !SetSecurityDescriptorDacl(*ppsd, TRUE, pacl, FALSE)
                )
        {
                dwError = GetLastError();
                goto lExit;
        }

        dwError = ERROR_SUCCESS;

lExit:
        if(dwError != ERROR_SUCCESS && *ppsd != NULL)
        {
                MemFree(*ppsd);
                *ppsd = NULL;
        }

        if(pto != NULL)
                MemFree(pto);

        for(i = 0; i < MaxSids; i++)
        {
                if(psids[i] != NULL)
                        FreeSid(psids[i]);
        }

        return dwError;
}
#endif


LRESULT CALLBACK DlgParentWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*++

Routine Description:

    This is the window proc of the parent window for network authentication dialog

Arguments:

    See Platform SDK docs

Return Value:

    See Platform SDK docs

--*/
{
    static PSFC_WINDOW_DATA pWndData = NULL;

    switch(uMsg)
    {
    case WM_CREATE:
        pWndData = pSfcCreateWindowDataEntry(hwnd);

        if(NULL == pWndData)
        {
            return -1;
        }

        break;

    case WM_WFPENDDIALOG:
        //
        // don't try to delete pWndData from the list when this message is sent because we'll deadlock;
        // the entry will be removed by the thread that sent it
        //

        pWndData = NULL;
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:
        if(pWndData != NULL)
        {
            //
            // delete pWndData from the list since this is not a consequence of receiving WM_WFPENDDIALOG
            //

            pSfcRemoveWindowDataEntry(pWndData);
        }

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

DWORD
CreateDialogParent(
    OUT HWND* phwnd
    )
/*++

Routine Description:

    Creates the parent window for network authentication dialog

Arguments:

    phwnd:  receives the handle of the newly-created window

Return Value:

    Win32 error code

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    WNDCLASSW wc;
    WCHAR szTitle[128];

    ASSERT(phwnd != NULL);

    RtlZeroMemory(&wc, sizeof(wc));
    wc.lpszClassName = PARENT_WND_CLASS;
    wc.hInstance = SfcInstanceHandle;
    wc.lpfnWndProc = DlgParentWndProc;

    //
    // if the class is already registered, there will be no problems;
    // if there's an error registering the class for the first time, it will show up in CreateWindow
    //
    RegisterClassW(&wc);

    if(0 == LoadString(SfcInstanceHandle, IDS_TITLE, szTitle, ARRAY_LENGTH(szTitle))) {
        szTitle[0] = 0;
    }

    *phwnd = CreateWindowW(
        wc.lpszClassName,
        szTitle,
        WS_POPUP | WS_VISIBLE,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        wc.hInstance,
        NULL
        );

    if(NULL == *phwnd)
    {
        dwError = GetLastError();
        DebugPrint1(LVL_VERBOSE, L"CreateDialogParent failed with the code %x", dwError);
        goto exit;
    }

    //
    // Make it topmost so it won't go unnoticed
    //
    SetWindowPos(*phwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

exit:
    return dwError;
}


NTSTATUS
SfcAllocUnicodeStringFromPath(
    IN PCWSTR szPath,
    OUT PUNICODE_STRING pString
    )
/*++

Routine Description:

	Expands the environment variables in the input path. Allocates the output buffer.

Arguments:

	szPath - a path that can contain environment variables
	pString - receives the expanded path

Return value:

	The error code.

--*/
{
    ULONG uLength;

    pString->Length = pString->MaximumLength = 0;
    pString->Buffer = NULL;

    uLength = ExpandEnvironmentStringsW(szPath, NULL, 0);

    if(0 == uLength || uLength > MAXSHORT)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pString->Buffer = (PWSTR) MemAlloc(uLength * sizeof(WCHAR));

    if(NULL == pString->Buffer)
    {
        return STATUS_NO_MEMORY;
    }

    if(0 == ExpandEnvironmentStringsW(szPath, pString->Buffer, uLength)) {
        return STATUS_INVALID_PARAMETER;
    }

    pString->MaximumLength = (USHORT) (uLength * sizeof(WCHAR));
    pString->Length = pString->MaximumLength - sizeof(WCHAR);

    return STATUS_SUCCESS;
}

#ifndef _WIN64

VOID
SfcCleanupPathTranslator(
    IN BOOL FinalCleanup
    )
/*++

Routine Description:

	Frees the memory used in the translation table and optionally the critical section used to access it.

Arguments:

	FinalCleanup - if TRUE, the critical section is also deleted

Return value:

	none

--*/
{
    if(SfcNeedTranslation)
    {
        if(SfcTranslations != NULL)
        {
            ULONG i;

            for(i = 0; i < ARRAY_LENGTH(SfcExpandTranslations); ++i)
            {
                MemFree(SfcTranslations[i].Src.Buffer);
                MemFree(SfcTranslations[i].Dest.Buffer);
            }

            MemFree(SfcTranslations);
            SfcTranslations = NULL;
        }

        if(FinalCleanup)
        {
            RtlDeleteCriticalSection(&SfcTranslatorCs);
        }
    }
}

VOID
SfcInitPathTranslator(
    VOID
    )
/*++

Routine Description:

	Initializes the path translator. Does not expand the table paths.

Arguments:

	none

Return value:

	none

--*/
{
#ifdef SFC_REDIRECTOR_TEST

    SfcNeedTranslation = TRUE;

#else

    SfcNeedTranslation = (GetSystemWow64DirectoryW(NULL, 0) != 0);

#endif

    if(SfcNeedTranslation) {
        RtlInitializeCriticalSection(&SfcTranslatorCs);
    }
}

NTSTATUS
SfcExpandPathTranslator(
    VOID
    )
/*++

Routine Description:

	Expands the translation table paths.

Arguments:

	none

Return value:

	The error code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(SfcNeedTranslation);
    RtlEnterCriticalSection(&SfcTranslatorCs);

    if(!SfcIsTranslatorInitialized)
    {
        ULONG ulCount = ARRAY_LENGTH(SfcExpandTranslations);
        ULONG i;

        ASSERT(NULL == SfcTranslations);

        SfcTranslations = (SFC_TRANSLATION_ENTRY*) MemAlloc(ulCount * sizeof(SFC_TRANSLATION_ENTRY));

        if(NULL == SfcTranslations)
        {
            Status = STATUS_NO_MEMORY;
            goto cleanup;
        }

        for(i = 0; i < ulCount; ++i)
        {
            Status = SfcAllocUnicodeStringFromPath(SfcExpandTranslations[i].Src, &SfcTranslations[i].Src);

            if(!NT_SUCCESS(Status))
            {
                goto cleanup;
            }

            Status = SfcAllocUnicodeStringFromPath(SfcExpandTranslations[i].Dest, &SfcTranslations[i].Dest);

            if(!NT_SUCCESS(Status))
            {
                goto cleanup;
            }
        }
        //
        // set this to TRUE only on success; in case of failure, the init will be tried later
        //
        SfcIsTranslatorInitialized = TRUE;

cleanup:
        if(!NT_SUCCESS(Status))
        {
            SfcCleanupPathTranslator(FALSE);
            DebugPrint(LVL_MINIMAL, L"Could not initialize the path translator");
        }
    }

    RtlLeaveCriticalSection(&SfcTranslatorCs);
    return Status;
}


NTSTATUS
SfcRedirectPath(
    IN PCWSTR szPath,
    OUT PUNICODE_STRING pPath
    )
/*++

Routine Description:

	Expands environment variables and translates a path from win32 to wow64. Allocates the output buffer.

Arguments:

	szPath - the path to expand/translate
	pPath - receives the processed (and possibly changed) path

Return value:

	The error code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Path = { 0 };
    ULONG i;

    ASSERT(szPath != NULL);
    ASSERT(pPath != NULL);

    RtlZeroMemory(pPath, sizeof(*pPath));
    //
    // first of all, expand environment strings
    //
    Status = SfcAllocUnicodeStringFromPath(szPath, &Path);

    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    if(!SfcNeedTranslation)
    {
        goto no_translation;
    }

    Status = SfcExpandPathTranslator();

    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    for(i = 0; i < ARRAY_LENGTH(SfcExpandTranslations); ++i)
    {
        PUNICODE_STRING pSrc = &SfcTranslations[i].Src;
        PUNICODE_STRING pDest = &SfcTranslations[i].Dest;

        if(Path.Length >= pSrc->Length && 0 == _wcsnicmp(Path.Buffer, pSrc->Buffer, pSrc->Length / sizeof(WCHAR)))
        {
            const UNICODE_STRING* pExcep = SfcExpandTranslations[i].Exceptions;
            //
            // test if this is an excluded path
            //
            for(i = SfcExpandTranslations[i].ExceptionCount; i--; ++pExcep)
            {
                if(Path.Length >= pSrc->Length + pExcep->Length && 
                    0 == _wcsnicmp((PWCHAR) ((PCHAR) Path.Buffer + pSrc->Length), pExcep->Buffer, pExcep->Length / sizeof(WCHAR)))
                {
                    goto no_translation;
                }
            }

            DebugPrint1(LVL_VERBOSE, L"Redirecting \"%s\"", Path.Buffer);
            //
            // compute the new length, including the terminator
            //
            pPath->MaximumLength = Path.Length - pSrc->Length + pDest->Length + sizeof(WCHAR);
            pPath->Buffer = (PWSTR) MemAlloc(pPath->MaximumLength);

            if(NULL == pPath->Buffer)
            {
                Status = STATUS_NO_MEMORY;
                goto exit;
            }

            RtlCopyMemory(pPath->Buffer, pDest->Buffer, pDest->Length);
            //
            // copy the reminder of the path (including terminator)
            //
            RtlCopyMemory((PCHAR) pPath->Buffer + pDest->Length, (PCHAR) Path.Buffer + pSrc->Length, Path.Length - pSrc->Length + sizeof(WCHAR));
            pPath->Length = pPath->MaximumLength - sizeof(WCHAR);

            DebugPrint1(LVL_VERBOSE, L"Path redirected to \"%s\"", pPath->Buffer);
            goto exit;
        }
    }

no_translation:
    DebugPrint1(LVL_VERBOSE, L"No translation required for \"%s\"", Path.Buffer);
    //
    // output the expanded string
    //
    *pPath = Path;
    Path.Buffer = NULL;

exit:
    MemFree(Path.Buffer);

    if(!NT_SUCCESS(Status))
    {
        MemFree(pPath->Buffer);
        RtlZeroMemory(pPath, sizeof(*pPath));
    }

    return Status;
}
#endif  // _WIN64

NTSTATUS
SfcRpcStartServer(
    VOID
    )
/*++

Routine Description:

    Initializes the RPC server and starts listening for calls.

Arguments:

    none

Return Value:

    NT status code.

--*/
{
    RPC_STATUS Status;

    //
    // Use LRPC protocol and WFP's endpoint
    //
    Status = RpcServerUseProtseqEp(L"ncalrpc", 0, SFC_RPC_ENDPOINT, NULL);

    if(Status != RPC_S_OK) {
        goto exit;
    }

    //
    // Register the RPC interface and start listening to calls
    //
    Status = RpcServerRegisterIfEx(
        SfcSrv_sfcapi_ServerIfHandle, 
        NULL, 
        NULL, 
        RPC_IF_AUTOLISTEN, 
        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
        NULL
        );

exit:
    return I_RpcMapWin32Status(Status);
}

DWORD
SfcNtPathToDosPath(
    IN LPCWSTR NtName,
    OUT LPWSTR* DosName
    )
/*++

Routine Description:

    Converts an NT file system path to a DOS path. Allocates the result using MemAlloc.

Arguments:

    NtName      -NT path to be converted
    DosName     -pointer that receives the converted DOS path (allocated)

Return Value:

    Win32 error code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_UNICODE_STRING_BUFFER Buffer;
    UNICODE_STRING String;

    ASSERT(DosName != NULL);
    *DosName = NULL;

    RtlInitUnicodeString(&String, NtName);
    ASSERT(String.Length != 0);

    if(String.Length != 0 && L'!' == String.Buffer[0]) {
        ++String.Buffer;
        String.Length -=2;
        String.MaximumLength -= 2;
    }

    RtlInitUnicodeStringBuffer(&Buffer, NULL, 0);
    Status = RtlAssignUnicodeStringBuffer(&Buffer, &String);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = RtlNtPathNameToDosPathName(0, &Buffer, NULL, NULL);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    *DosName = MemAlloc(Buffer.String.Length + sizeof(WCHAR));

    if(NULL == *DosName) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    RtlCopyMemory(*DosName, Buffer.String.Buffer, Buffer.String.Length);
    (*DosName)[Buffer.String.Length / sizeof(WCHAR)] = 0;

exit:
    RtlFreeUnicodeStringBuffer(&Buffer);

    return RtlNtStatusToDosError(Status);
}

DWORD
ProcessDelayRenames(
    VOID
    )
/*++

Routine Description:

    Checks to see if delay-renames were pending during last reboot and
    copies the affected files to dllcache

Arguments:

    none

Return Value:

    Win32 error code.

--*/
{
    LONG Error = ERROR_SUCCESS;
    HKEY RegKey = NULL;
    LPWSTR DataPtr = NULL;
    DWORD ValueType;
    DWORD ValueSize;
    UINT_PTR i;

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE, REGKEY_WINLOGON_WIN32, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &RegKey);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    ValueSize = 0;
    Error = RegQueryValueExW(RegKey, REGVAL_WFPPENDINGUPDATES, NULL, &ValueType, NULL, &ValueSize);

    if(Error != ERROR_SUCCESS) {
        if(ERROR_FILE_NOT_FOUND == Error) {
            //
            // No value means nothing to do here
            //
            Error = ERROR_SUCCESS;
        }

        goto exit;
    }

    if(ValueType != REG_MULTI_SZ) {
        Error = ERROR_INVALID_DATA;
        goto exit;
    }

    DataPtr = (LPWSTR) MemAlloc(ValueSize);

    if(NULL == DataPtr) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    Error = RegQueryValueExW(RegKey, REGVAL_WFPPENDINGUPDATES, NULL, &ValueType, (LPBYTE) DataPtr, &ValueSize);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    ValueSize /= sizeof(WCHAR);

    //
    // Look for target files
    //
    for(i = 0; ; ) {
        UINT_PTR Start = i;

        //
        // skip source path
        //
        for(; i < ValueSize && DataPtr[i] != 0; ++i);

        if(i >= ValueSize) {
            Error = ERROR_INVALID_DATA;
            goto exit;
        }

        if(i == Start) {
            //
            // empty source path; this must be the end of the list
            //
            break;
        }

        //
        // skip the terminator and store the target start
        //
        Start = (++i);

        //
        // search for the end of target
        //
        for(; i < ValueSize && DataPtr[i] != 0; ++i);

        if(i >= ValueSize) {
            Error = ERROR_INVALID_DATA;
            goto exit;
        }

        if(i != Start) {
            //
            // This is a delay-rename; process it
            //
            LPWSTR DosPath = NULL;
            Error = SfcNtPathToDosPath(DataPtr + Start, &DosPath);

            if(STATUS_SUCCESS == Error) {
                PNAME_NODE Node;
                DWORD Size = wcslen(DosPath);

                MyLowerString(DosPath, Size);
                Node = SfcFindProtectedFile(DosPath, Size * sizeof(WCHAR));
                MemFree(DosPath);

                if(Node != NULL) {
                    //
                    // This one's protected. Blindly copy the file to dllcahe; 
                    // if it's not signed, it will be like not being there at all.
                    // Also, we don't take into account the dllcache quota for simplicity.
                    //
                    NTSTATUS Status;
                    UNICODE_STRING FileNameOnMediaString;
                    PCWSTR FileNameOnMedia;
                    PSFC_REGISTRY_VALUE RegVal = (PSFC_REGISTRY_VALUE) Node->Context;

                    ASSERT(RegVal != NULL);
                    ASSERT(RegVal->DirHandle != NULL);
                    ASSERT(SfcProtectedDllFileDirectory != NULL);

                    FileNameOnMedia = FileNameOnMedia(RegVal);
                    ASSERT(FileNameOnMedia != NULL);
                    RtlInitUnicodeString(&FileNameOnMediaString, FileNameOnMedia);

                    Status = SfcCopyFile(
                        RegVal->DirHandle, 
                        RegVal->DirName.Buffer, 
                        SfcProtectedDllFileDirectory, 
                        SfcProtectedDllPath.Buffer, 
                        &FileNameOnMediaString, 
                        &RegVal->FileName
                        );

                    if(!NT_SUCCESS(Status)) {
                        DebugPrint2(LVL_MEDIUM, L"Renamed file [%wZ] could not be copied to dllcache, error &lX", &RegVal->FileName, Status);
                    }
                }
            }
        }

        //
        // Skip the null and move on
        //
        ++i;
    }

    //
    // Delete the key so we don't process it the next boot
    //
    RegDeleteValue(RegKey, REGVAL_WFPPENDINGUPDATES);

exit:
    if(RegKey != NULL) {
        RegCloseKey(RegKey);
    }

    MemFree(DataPtr);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\stub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Stubbed out Windows File Protection APIs.  These APIs are "Millenium" SFC 
    apis, which we simply stub out so that any clients programming to these
    APIs may work on both platforms

Author:

    Andrew Ritz (andrewr) 23-Sep-1999

Revision History:
    
    

--*/

#include "sfcp.h"
#pragma hdrstop

#include <srrestoreptapi.h>

DWORD
WINAPI
SfpInstallCatalog(
    IN LPCSTR pszCatName, 
    IN LPCSTR pszCatDependency,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
WINAPI
SfpDeleteCatalog(
    IN LPCSTR pszCatName,
    IN PVOID Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


BOOL
WINAPI
SfpVerifyFile(
    IN LPCSTR pszFileName,
    IN LPSTR  pszError,
    IN DWORD   dwErrSize
    )
{

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
    
}

#undef SRSetRestorePoint
#undef SRSetRestorePointA
#undef SRSetRestorePointW

typedef BOOL (WINAPI * PSETRESTOREPOINTA) (PRESTOREPOINTINFOA, PSTATEMGRSTATUS);
typedef BOOL (WINAPI * PSETRESTOREPOINTW) (PRESTOREPOINTINFOW, PSTATEMGRSTATUS);

BOOL
WINAPI
SRSetRestorePointA ( PRESTOREPOINTINFOA  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;
    
    if (hClient != NULL)
    {
        PSETRESTOREPOINTA pSetRestorePointA = (PSETRESTOREPOINTA )
                          GetProcAddress (hClient, "SRSetRestorePointA"); 

        if (pSetRestorePointA != NULL)
        {
            fReturn =  (* pSetRestorePointA) (pRestorePtSpec, pSMgrStatus); 
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

    return fReturn;
}

BOOL
WINAPI
SRSetRestorePointW ( PRESTOREPOINTINFOW  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;

    if (hClient != NULL)
    {
        PSETRESTOREPOINTW pSetRestorePointW = (PSETRESTOREPOINTW )
                          GetProcAddress (hClient, "SRSetRestorePointW");

        if (pSetRestorePointW != NULL)
        {
            fReturn =  (* pSetRestorePointW) (pRestorePtSpec, pSMgrStatus);
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;


    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\dll\version.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    version.h

Abstract:

    Implementation of file version checking.

Author:

    Wesley Witt (wesw) 18-Dec-1998    

Revision History:

    Andrew Ritz (andrewr) 6-Jul-1999

--*/

#include "sfcp.h"
#pragma hdrstop



//
// Resource type information block
//
typedef struct rsrc_typeinfo RSRC_TYPEINFO, *LPRESTYPEINFO;


//
// Resource name information block
//
typedef struct rsrc_nameinfo RSRC_NAMEINFO, *PRSRC_NAMEINFO;


#define RSORDID     0x8000      // if high bit of ID set then integer id
                                // otherwise ID is offset of string from
                                // the beginning of the resource table
                                // Ideally these are the same as the
                                // corresponding segment flags

typedef struct _RESOURCE_DATAW {
    USHORT TotalSize;
    USHORT DataSize;
    USHORT Type;
    WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
    VS_FIXEDFILEINFO FixedFileInfo;
} RESOURCE_DATAW, *PRESOURCE_DATAW;

typedef struct _RESOURCE_DATAA {
    USHORT TotalSize;
    USHORT DataSize;
    USHORT Type;
    CHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
    VS_FIXEDFILEINFO FixedFileInfo;
} RESOURCE_DATAA, *PRESOURCE_DATAA;




LPBYTE
FindResWithIndex(
   LPBYTE lpResTable,
   INT iResIndex,
   LPBYTE lpResType
   )
/*++

Routine Description:

    Routine searches for a resource in a resource table at the specified index.
    The routine works by walking the resource table until we hit the specified
    resource.

Arguments:

    lpResTable - pointer to the resource table
    iResIndex  - integer indicating the index of the resource to be retreived
    lpResType  - pointer to data indicating the type of resource we're 
                 manipulating

Return Value:

    a pointer to the specified resource or NULL on failure.

--*/
{
    LPRESTYPEINFO lpResTypeInfo;

    ASSERT((lpResTable != NULL) && (iResIndex >= 0));

    try {

        lpResTypeInfo = (LPRESTYPEINFO)(lpResTable + sizeof(WORD));

        while (lpResTypeInfo->rt_id) {
            if ((lpResTypeInfo->rt_id & RSORDID) &&
                (MAKEINTRESOURCE(lpResTypeInfo->rt_id & ~RSORDID) == (LPTSTR)lpResType)) {
                if (lpResTypeInfo->rt_nres > (WORD)iResIndex) {
                   return (LPBYTE)(lpResTypeInfo+1) + iResIndex * sizeof(RSRC_NAMEINFO);
                } else {
                    return NULL;
                }
            }
            //
            // point to the next resource
            //
            lpResTypeInfo = (LPRESTYPEINFO)((LPBYTE)(lpResTypeInfo+1) + lpResTypeInfo->rt_nres * sizeof(RSRC_NAMEINFO));
        }
        DebugPrint( LVL_VERBOSE, L"FindResWithIndex didn't find resource\n" );
        return(NULL);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint( LVL_VERBOSE, L"FindResWithIndex hit an exception\n" );
    }

    return (NULL);    
}


ULONGLONG
GetFileVersion16(
	PVOID ImageBase,
    PIMAGE_OS2_HEADER NewImageHeader
    )
/*++

Routine Description:

    Routine retreives the version for a downlevel image file.
    
Arguments:

    ImageBase		- base pointer to the image
	NewImageHeader	- pointer to the image's new header

Return Value:

    a number indicating the version of the image or 0 if the version is 
    unavailable

--*/
{
    PBYTE ResTable;
    PRSRC_NAMEINFO ResPtr;
    PRESOURCE_DATAA ResourceDataA;
    ULONG iShiftCount;
    ULONG Offset;
    ULONGLONG Version = 0;

    ASSERT(ImageBase != NULL && NewImageHeader != NULL && IMAGE_OS2_SIGNATURE == NewImageHeader->ne_magic);

    if (NewImageHeader->ne_rsrctab != NewImageHeader->ne_restab) {
        ResTable = (PBYTE) NewImageHeader + NewImageHeader->ne_rsrctab;
        ResPtr = (PRSRC_NAMEINFO) FindResWithIndex( ResTable, 0, (LPBYTE)RT_VERSION );
        if (ResPtr) {
            iShiftCount = *((WORD *)ResTable);
            Offset = MAKELONG(ResPtr->rn_offset << iShiftCount, (ResPtr->rn_offset) >> (16 - iShiftCount));
            ResourceDataA = (PRESOURCE_DATAA)((PBYTE)ImageBase + Offset);
            Version = ((ULONGLONG)ResourceDataA->FixedFileInfo.dwFileVersionMS << 32)
                     | (ULONGLONG)ResourceDataA->FixedFileInfo.dwFileVersionLS;
        }
    }

    return Version;
}


ULONGLONG
GetFileVersion32(
    IN PVOID ImageBase
    )
/*++

Routine Description:

    Routine retreives the version for a 32 bit image file.
    
Arguments:

    ImageBase  - base pointer to the image resource
    

Return Value:

    a number indicating the version of the image or 0 if the version is 
    unavailable

--*/
{
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;
    ULONGLONG Version = 0;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    PRESOURCE_DATAW ResourceDataW;

    ASSERT(ImageBase != NULL);
    
    //
    // Do this to prevent the Ldr routines from faulting.
    //
    ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);

    IdPath[0] = PtrToUlong(RT_VERSION);
    IdPath[1] = PtrToUlong(MAKEINTRESOURCE(VS_VERSION_INFO));
    IdPath[2] = 0;

    //
    // find the resource data entry
    //
    try {
        Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return 0;
    }

    //
    // now get the data out of the entry
    //
    try {
        Status = LdrAccessResource(ImageBase,DataEntry,&ResourceDataW,&ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return 0;
    }

    try {
        if((ResourceSize >= sizeof(*ResourceDataW)) && !_wcsicmp(ResourceDataW->Name,L"VS_VERSION_INFO")) {

            Version = ((ULONGLONG)ResourceDataW->FixedFileInfo.dwFileVersionMS << 32)
                     | (ULONGLONG)ResourceDataW->FixedFileInfo.dwFileVersionLS;

        } else {
            DebugPrint( LVL_MINIMAL, L"GetFileVersion32 warning: invalid version resource" );
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint( LVL_MINIMAL, L"GetFileVersion32 Exception encountered processing bogus version resource" );
    }

    return Version;
}


BOOL
SfcGetVersionFileName(
    IN PVOID ImageBase,
    IN PWSTR FileName
    )
/*++

Routine Description:

    Routine retreives the original filename for an image.   can be used to
    determine the actual source name of the hal that is installed on the 
    system, for example
    
Arguments:

    ImageBase  - base pointer to the image resource
    FileName   - pointer to unicode string buffer which receives the filename.
                 There is an assumption that the original file name can never
                 exceed 32 characters.

Return Value:

    TRUE indicates no problems retrieving version, FALSE indicates failure.    

--*/
{
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;
    ULONGLONG Version = 0;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    PRESOURCE_DATAW ResourceDataW;
    LPVOID lpInfo;
    LPVOID lpvData = NULL;
    DWORD *pdwTranslation;
    UINT uLen;
    UINT cch;
    DWORD dwDefLang = 0x409;
    WCHAR key[80];
    PWSTR s = NULL;

    ASSERT((ImageBase != NULL) && (FileName != NULL));

    //
    // Do this to prevent the Ldr routines from faulting.
    //
    ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);

    IdPath[0] = PtrToUlong(RT_VERSION);
    IdPath[1] = PtrToUlong(MAKEINTRESOURCE(VS_VERSION_INFO));
    IdPath[2] = 0;

    //
    // find the version resource
    //
    try {
        Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // access the version resource
    //
    try {
        Status = LdrAccessResource(ImageBase,DataEntry,&ResourceDataW,&ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    lpvData = ResourceDataW;

    //
    // get the default language
    //
    if (!VerQueryValue( lpvData, L"\\VarFileInfo\\Translation", &pdwTranslation, &uLen )) {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    //
    // get the original file name
    //
    swprintf( key, L"\\StringFileInfo\\%04x%04x\\OriginalFilename", LOWORD(*pdwTranslation), HIWORD(*pdwTranslation) );
    if (VerQueryValue( lpvData, key, &lpInfo, &cch )) {
        ASSERT(UnicodeChars(lpInfo) < 32);
        wcsncpy( FileName, lpInfo, 32 );
    } else {
        DebugPrint( LVL_MINIMAL, L"VerQueryValue for OriginalFileName failed." );
        return(FALSE);
    }

    return(TRUE);
}


BOOL
SfcGetFileVersion(
	IN HANDLE FileHandle,
	OUT PULONGLONG Version,
	OUT PULONG Checksum,
	OUT PWSTR FileName
	)
/*++

Routine Description:

    Routine retreives the file version for an image, the checksum and the original
    filename resource from the image.
    
Arguments:

    FileHandle - handle to the file to retrieve an image for
	Version	   - ULONGLONG that receives the file version (can be NULL)
    Checksum   - DWORD which receives the file checksum (can be NULL)
    FileName   - pointer to unicode string buffer which receives the original
                 filename. There is an assumption that the original file name
                 can never exceed 32 characters (can be NULL)

Return Value:

	TRUE if successful: Version receives the major version in the high DWORD and the minor version in the low DWORD.
--*/
{
	NTSTATUS Status;
	HANDLE SectionHandle;
    PVOID ImageBase;
    SIZE_T ViewSize;
	DWORD dwFileSize;

	ASSERT(FileHandle != INVALID_HANDLE_VALUE);
	ASSERT(Version != NULL || Checksum != NULL || FileName != NULL);
	
	if(Version != NULL)
		*Version = 0;

	if(Checksum != NULL)
		*Checksum = 0;
	
	if(FileName != NULL)
		*FileName = L'\0';

	dwFileSize = GetFileSize(FileHandle, NULL);

	if(-1 == dwFileSize)
		return FALSE;

    Status = SfcMapEntireFile(FileHandle, &SectionHandle, &ImageBase, &ViewSize);

    if(!NT_SUCCESS(Status))
		return FALSE;

    try {
        //
        //  There are three sorts of files that can be replaced:
        //
        //      32-bit images.  Extract the 32 bit version, checksum and filename
        //      16-bit images.  Extract the 16 bit version and checksum
        //      other.  The version is 1 and we compute the checksum
        //
		if(dwFileSize > sizeof(IMAGE_DOS_HEADER))
		{
			PIMAGE_DOS_HEADER DosHdr = (PIMAGE_DOS_HEADER) ImageBase;

			//
			// this code will break if we ever protect files > 2^32. not to mention
			// being very slow.
			//
			if (IMAGE_DOS_SIGNATURE == DosHdr->e_magic && DosHdr->e_lfanew > 0)
			{
				// assume 32bit
				PIMAGE_NT_HEADERS NtHdrs = (PIMAGE_NT_HEADERS) ((PBYTE)ImageBase + DosHdr->e_lfanew);

				if(dwFileSize > (DWORD) (DosHdr->e_lfanew + sizeof(PIMAGE_NT_HEADERS)) && 
					IMAGE_NT_SIGNATURE == NtHdrs->Signature) 
				{
					if(Version !=NULL)
						*Version = GetFileVersion32( ImageBase );

					if(Checksum != NULL)
						*Checksum = NtHdrs->OptionalHeader.CheckSum;

					if(FileName != NULL)
						SfcGetVersionFileName( ImageBase, FileName );

					goto lExit;
				}
				else
				{
					// assume 16bit
					PIMAGE_OS2_HEADER NeHdr = (PIMAGE_OS2_HEADER) NtHdrs;
					
					if(dwFileSize > (DWORD) (DosHdr->e_lfanew + sizeof(PIMAGE_OS2_HEADER)) && 
						IMAGE_OS2_SIGNATURE == NeHdr->ne_magic)
					{
						if(Version !=NULL)
							*Version = GetFileVersion16( ImageBase, NeHdr );

						if(Checksum != NULL)
							*Checksum = NeHdr->ne_crc;

						goto lExit;	// no filename
					}
				}
			}
		}
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint1( LVL_MINIMAL, L"Exception inside SfcGetFileVersion (0x%08X); bad image", GetExceptionCode() );
		// fall through bad image
    }

    //
    //  Not a 16/32bit image.  Compute a checksum.  In the interest
    //  of speed, we'll add up all the ULONGs in the file and
    //  ignore any fraction at the end
    //
    if(Version != NULL)
		*Version = 1;

	if(Checksum != NULL) {
		PULONG Data = (PULONG) ImageBase;
        *Checksum = 0;

        try {
		    while( dwFileSize >= sizeof( ULONG ) ) {
			    *Checksum += *Data++;
			    dwFileSize -= sizeof( ULONG );
		    }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            DebugPrint1( LVL_MINIMAL, L"Exception inside SfcGetFileVersion while calculating the checksum (0x%08X)", GetExceptionCode() );
            *Checksum = 0;
        }
	}

lExit:
    SfcUnmapFile(SectionHandle,ImageBase);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\exe\sfc.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sfc.c

Abstract:

    code file for system file checker utilty program

Revision History:

    Andrew Ritz (andrewr)  2-Jul-1999 : Added comments

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <sfcapip.h>
#include <sfcapi.h>
#include <locale.h>
#include "msg.h"

BOOL
IsUserAdmin(
    VOID
    );

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    );

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

#define DLLCACHE_DIR_DEFAULT L"%SystemRoot%\\system32\\DllCache"
#define SFC_REGISTRY_KEY     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SFC_DLLCACHE_VALUE   L"SFCDllCacheDir"
#define SFC_SCAN_VALUE       L"SFCScan"
#define SFC_DISABLE_VALUE    L"SFCDisable"
#define SFC_QUOTA_VALUE      L"SFCQuota"


typedef enum _SFCACTION {    
    ScanOnce,
    ScanNow,
    ScanBoot,
    RevertScan,
    PurgeCacheNow,
    SetCache
    } SFCACTION;

DWORD
SfcQueryRegDword(
    LPWSTR KeyName,
    LPWSTR ValueName
    )
/*++

Routine Description:

    Registry wrapper function.  Retreives the DWORD value at the specified key.
    Only handles values under HKLM.
    
Arguments:

    KeyName - Keyname that the specified value lives under.
    ValueName - ValueName we want to query.  

Return Value:

    The DWORD value at the specifed location or 0 on failure.
    If the call fails, GetLastError() returns something other than 
    ERROR_SUCESS.

--*/
{
    HKEY hKey;
    DWORD val;
    DWORD sz = sizeof(DWORD);
    long rslt;

    rslt = RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey );
    if  (rslt != ERROR_SUCCESS) {
        val = 0;
        goto e0;
    }

    rslt = RegQueryValueEx( hKey, ValueName, NULL, NULL, (LPBYTE)&val, &sz );
    if (rslt != ERROR_SUCCESS) {
        val = 0;
    }

    RegCloseKey( hKey );
e0:
    SetLastError( rslt );
    return(val);
}


PWSTR
SfcQueryRegString(
    LPWSTR KeyName,
    LPWSTR ValueName
    )
/*++

Routine Description:

    Registry wrapper function.  Retreives the string value at the specified key.
    Only handles values under HKLM.
    
Arguments:

    KeyName - Keyname that the specified value lives under.
    ValueName - ValueName we want to query.  

Return Value:

    The string value at the specifed location or NULL on failure.  If the 
    function fails, call GetLastError() to get the extended error code.

--*/
{
    HKEY hKey;
    DWORD size = 0;
    PWSTR val;
    long rslt;

    rslt = RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey );
    if (rslt != ERROR_SUCCESS) {
        val = NULL;
        goto e0;
    }

    rslt = RegQueryValueEx( hKey, ValueName, NULL, NULL, NULL, &size );
    if (rslt != ERROR_SUCCESS) {
        val = NULL;
        goto e1;
    }

    val = malloc( size+ sizeof(WCHAR) );
    if (val == NULL) {
        rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto e1;
    }

    rslt = RegQueryValueEx( hKey, ValueName, NULL, NULL, (LPBYTE)val, &size );
    if (rslt != ERROR_SUCCESS) {
        free( val );
        val = NULL;
    }

e1:
    RegCloseKey( hKey );
e0:
    SetLastError( rslt );
    return val;
}


DWORD
SfcWriteRegDword(
    LPWSTR KeyName,
    LPWSTR ValueName,
    ULONG Value
    )
/*++

Routine Description:

    Registry wrapper function.  Writes the DWORD value at the specified key.
    Only handles values under HKLM.
    
Arguments:

    KeyName - Keyname that the specified value lives under.
    ValueName - ValueName we want to query.  
    Value - value to be set

Return Value:

    WIN32 error code indicating outcome (ERROR_SUCCESS on success).

--*/
{
    HKEY hKey;
    DWORD retval;
    long rslt;


    rslt = RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey );
    if (rslt != ERROR_SUCCESS) {
        retval = rslt;
        goto e0;
    }

    rslt = RegSetValueEx( 
                    hKey,
                    ValueName, 
                    0,
                    REG_DWORD, 
                    (LPBYTE)&Value, 
                    sizeof(DWORD) );
     
    retval = rslt;

    RegCloseKey( hKey );
e0:
    SetLastError( rslt );
    return( retval );
}


DWORD
SfcWriteRegString(
    LPWSTR KeyName,
    LPWSTR ValueName,
    PWSTR Value
    )
/*++

Routine Description:

    Registry wrapper function.  Writes the string value at the specified key.
    Only handles values under HKLM.
    
Arguments:

    KeyName - Keyname that the specified value lives under.
    ValueName - ValueName we want to query.  
    Value - value to be set

Return Value:

    WIN32 error code indicating outcome (ERROR_SUCCESS on success).

--*/
{
    HKEY hKey;
    DWORD retval;
    long rslt;

    rslt = RegOpenKey( HKEY_LOCAL_MACHINE, KeyName, &hKey );
     
    if (rslt != ERROR_SUCCESS) {
        retval = rslt;
        goto e0;
    }

    rslt = RegSetValueEx( 
                    hKey, 
                    ValueName, 
                    0, 
                    REG_SZ, 
                    (LPBYTE)Value, 
                    (wcslen(Value)+1)*sizeof(WCHAR) );
    
    retval = rslt;

    RegCloseKey( hKey );
e0:
    SetLastError( rslt );
    return( retval );
}





 /***
 * My_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This My_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}



void
PrintMessage(
    DWORD MsgId,
    DWORD LastError,
    PCWSTR FileName,
    BOOL bStdOut
    )
/*++

Routine Description:

    Output the specified message id to specified output.
    
Arguments:

    MsgId - resource message id of message to be output
    LastError - error code
    FileName - filename to be logged, if specified
    bStdOut - TRUE indicates the message goes to stdout, else stderr
    
    
Return Value:

    None.

--*/
{
    WCHAR buf[2048];
    WCHAR LastErrorText[200];
    PVOID ErrText;

    PVOID Array[3];


    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        LastError,
        0,
        (PWSTR) &ErrText,
        0,
        NULL );

    if (ErrText) {
        wsprintf(LastErrorText,L"0x%08x [%ws]",LastError,ErrText);
        LocalFree( ErrText );
    } else {
        wsprintf(LastErrorText,L"0x%08x",LastError);
    }

    Array[0] = (PVOID)LastErrorText;
    Array[1] = (PVOID)FileName;
    Array[2] = NULL;

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MsgId,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        buf,
        sizeof(buf) / sizeof(WCHAR),
	    (va_list *)Array );

    My_fwprintf( 
            bStdOut 
             ? stdout 
             : stderr, 
            L"%ws", 
            buf );
}


void
Usage(
    void
    )
/*++

Routine Description:

    Display's usage for program to stdout.
    
Arguments:

   None.

Return Value:

    None.

--*/
{
    PrintMessage( MSG_USAGE, 0, NULL, FALSE );
}


BOOL 
DoAction(
    SFCACTION SfcAction,
    DWORD     CacheSize
    )
/*++

Routine Description:

    take the specified action based on input parameter
    
Arguments:

    SfcAction - enumerated type illustrating action
    CacheSize - only used for SetCache action, specifies cache size

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    HANDLE RpcHandle;
    DWORD errcode;
    BOOL retval;
        
    switch( SfcAction ) {
        case ScanOnce:
            //
            // connect to SFC RPC server and telling it to scan once.
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                errcode = SfcInitiateScan( RpcHandle, SFC_SCAN_ONCE );
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (errcode != ERROR_SUCCESS) {
                PrintMessage( MSG_SET_FAIL, errcode, NULL, FALSE );
                retval = FALSE;
            } else {
                //
                // requires a reboot
                //
                PrintMessage( MSG_REBOOT, 0, NULL, TRUE );
                retval = TRUE;
            }
            
            break;
        case ScanBoot:
            //
            // connect to SFC RPC server and telling it to scan every boot.                
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                errcode = SfcInitiateScan( RpcHandle, SFC_SCAN_ALWAYS );
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (errcode != ERROR_SUCCESS) {
                PrintMessage( MSG_SET_FAIL, errcode, NULL, FALSE );
                retval = FALSE;
            } else {
                //
                // requires a reboot
                //
                PrintMessage( MSG_REBOOT, 0, NULL, TRUE );
                retval = TRUE;
            }
            
            break;
        case ScanNow:
            //
            // scan immediately by connecting to SFC RPC server
            // and telling it to scan now.
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                //
                // scanwhen argument is ignored.
                //
                errcode = SfcInitiateScan( RpcHandle, SFC_SCAN_IMMEDIATE );
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (!retval) {
                PrintMessage(MSG_SCAN_FAIL, errcode, NULL, FALSE);
            }
            break;
        case RevertScan:
            //
            // connect to SFC RPC server and telling it to scan normally.                
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                errcode = SfcInitiateScan( RpcHandle, SFC_SCAN_NORMAL);
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (errcode != ERROR_SUCCESS) {
                PrintMessage( MSG_SET_FAIL, errcode, NULL, FALSE );
                retval = FALSE;
            } else {
                //
                // requires a reboot
                //
                PrintMessage( MSG_REBOOT, 0, NULL, TRUE );
                retval = TRUE;
            }
            
            break;
        case SetCache:            
            //
            // connect to SFC RPC server and tell it to set the cache size.
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                errcode = SfcCli_SetCacheSize( RpcHandle, CacheSize );
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (errcode != ERROR_SUCCESS) {
                PrintMessage( MSG_SET_FAIL, errcode, NULL, FALSE );
                retval = FALSE;
            } else {
                //
                // print success message
                //
                PrintMessage( MSG_SUCCESS, 0, NULL, TRUE );
                retval = TRUE;
            }

            break;
        case PurgeCacheNow:
            //
            // remove all files from the cache
            //
            //
            // connect to SFC RPC server and tell it to purge the cache
            //
            RpcHandle = SfcConnectToServer( NULL );
            if (RpcHandle) {
            
                errcode = SfcCli_PurgeCache( RpcHandle );
                retval = (errcode == ERROR_SUCCESS);
                SfcClose( RpcHandle );
            } else {
                retval = FALSE;
                errcode = GetLastError();
            }

            if (!retval) {
                PrintMessage(MSG_PURGE_FAIL, errcode, NULL, FALSE);
            } else {
                PrintMessage(MSG_SUCCESS, 0, NULL, FALSE);                
            }
            break;
        default:
            //
            // should never get here!
            //
            ASSERT(FALSE);
            retval = FALSE;
    }

    return(retval);
}

void SetLanguage()
{
    HMODULE h = GetModuleHandleW(L"kernel32.dll");

    if(h != NULL)
    {
        typedef LANGID (WINAPI * PSET_THREAD_UI_LANGUAGE)(WORD);
        PSET_THREAD_UI_LANGUAGE pf = (PSET_THREAD_UI_LANGUAGE) GetProcAddress(h, "SetThreadUILanguage");

        if(pf != NULL)
        {
            pf(0);
        }
    }

    setlocale(LC_ALL, ".OCP");
}

int 
__cdecl wmain(
    int argc,
    WCHAR *argv[]
    )
/*++

Routine Description:

    program entrypoint
    
Arguments:

    argc - number of arguments
    argv - pointer to argument array

Return Value:

   0 indicates success, 1 failure. 

--*/
{
    int i;
    DWORD val;
    PWSTR s;
    SFCACTION SfcAction;

    SetLanguage();

    //
    // only an administrator logged on to session 0 (console) is allowed to run this app
    //
    if (!IsUserAdmin() || !ProcessIdToSessionId(GetCurrentProcessId(), &val) || val != 0) {
        PrintMessage( MSG_ADMIN, 0, NULL, FALSE );    
        return 1;
    }
    
    //
    // parse args
    //
    if (argc == 1) {
        Usage();
        return 1;
    }

    val = 0;
    for (i=1; i<argc; i++) {
        s = argv[i];
        //
        // support '-' and '/' as synonyms
        //
        if (*s != L'-' && *s != L'/') {
            Usage();
            return 1;
        }
        s += 1;
        if (_wcsicmp( s, L"SCANONCE" ) == 0) {
            SfcAction = ScanOnce;         
        } else if (_wcsicmp( s, L"SCANBOOT" ) == 0) {
            SfcAction = ScanBoot;            
        } else if (_wcsicmp( s, L"SCANNOW" ) == 0) {
            SfcAction = ScanNow;            
        } else if (_wcsicmp( s, L"REVERT" ) == 0) {
            SfcAction = RevertScan;
        } else if (_wcsnicmp( s, L"CACHESIZE=", 10 ) == 0) {
            SfcAction = SetCache;
            val = wcstoul( s+10, NULL, 0 );            
        } else if (_wcsicmp( s, L"PURGECACHE" ) == 0) {
            SfcAction = PurgeCacheNow;            
        } else {
            Usage();
            return 1;
        }
                
    }

    //
    // do the specified action
    //
        
    if (DoAction(SfcAction,val)) {
        return 0;
    }

    return 1;
}


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &AdministratorsGroup
            );

    if(b) {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b)) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);

    }
    
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\postbuild\src\sfcfiles.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sfcfiles.c

Abstract:

    Routines to initialize and retrieve a list of files to be proected by the
    system.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:
    
    Andrew Ritz (andrewr) 2-Jul-199 -- added comments

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "sfcfiles.h"

//
// Put the protected lists in the read-only data segment
//
#pragma data_seg(".rdata")

#if defined(_AMD64_)

#include "amd64_dtc.h"
#include "amd64_ent.h"
#include "amd64_wks.h"

#elif defined(_IA64_)

#include "ia64_dtc.h"
#include "ia64_ent.h"
#include "ia64_wks.h"

#elif defined(_X86_)

#include "x86_dtc.h"
#include "x86_ent.h"
#include "x86_per.h"
#include "x86_srv.h"
#include "x86_wks.h"
#include "x86_bla.h"
#include "x86_sbs.h"

#else
#error "No Target Platform"
#endif

//
// switch back to the default data segment
//
#pragma data_seg()

//
// Globals
//


//
// module handle
//
HMODULE SfcInstanceHandle;

//
// pointer to tier2 files for this system
//
PPROTECT_FILE_ENTRY Tier2Files;

//
// number of files in the tier 2 list. there must always be at least one file
// in the list of protected files
//
ULONG CountTier2Files;



DWORD
SfcDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
/*++

Routine Description:

    Main Dll Entrypoint

Arguments:

    hInstance - handle to dll module
    Reason    - reason for calling function
    Context   - reserved

Return Value:

    always TRUE

--*/
{
    if (Reason == DLL_PROCESS_ATTACH) {
        SfcInstanceHandle = hInstance;

        //
        // we don't need thread attach/detach notifications
        //
        LdrDisableThreadCalloutsForDll( hInstance );
    }
    return TRUE;
}


NTSTATUS
SfcFilesInit(
    void
    )
/*++

Routine Description:

    Initialization routine.  This routine must be called before 
    SfcGetFiles() can do any work.  The initialization routine 
    determines what embedded file list we should use based on 
    product type and architecture.

Arguments:

    NONE.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    OSVERSIONINFOEXW ver;
    

    //
    // set the tier2 file pointer based on the product we're running on
    //
    
    //
    // retrieve product information
    //
    RtlZeroMemory( &ver, sizeof(ver) );
    ver.dwOSVersionInfoSize = sizeof(ver);
    Status = RtlGetVersion( (LPOSVERSIONINFOW)&ver );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (ver.wProductType == VER_NT_WORKSTATION) {
#if !defined(_AMD64_) && !defined(_IA64_)
        if (ver.wSuiteMask & VER_SUITE_PERSONAL)
        {
            Tier2Files = PerFiles;
            CountTier2Files = CountPerFiles;
        }
        else
#endif
        {
            Tier2Files = WksFiles;
            CountTier2Files = CountWksFiles;
        }
    } else {
        //
        // Datacenter MUST come before enterprise because the datacenter
        // suite also has the enterprise suite bit set
        //
        if (ver.wSuiteMask & VER_SUITE_DATACENTER) {
            Tier2Files = DtcFiles;
            CountTier2Files = CountDtcFiles;
        } else if (ver.wSuiteMask & VER_SUITE_ENTERPRISE) {
            Tier2Files = EntFiles;
            CountTier2Files = CountEntFiles;
        } 
#if !defined(_AMD64_) && !defined(_IA64_)
        else if (ver.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED) {
            Tier2Files = SbsFiles;
            CountTier2Files = CountSbsFiles;
        } else if (ver.wSuiteMask & VER_SUITE_BLADE) {
            Tier2Files = BlaFiles;
            CountTier2Files = CountBlaFiles;
        } else {
            Tier2Files = SrvFiles;
            CountTier2Files = CountSrvFiles;
        }
#endif
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SfcGetFiles(
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    )
/*++

Routine Description:

    Retreives pointers to the file list and file count.  Note that we refer to 
    a "tier2" list here but in actuality there is no tier 1 list.
    
Arguments:

    Files - pointer to a PPROTECT_FILE_ENTRY, which is filled in with a pointer
            to the actual protected files list.
    FileCount - pointer to a ULONG which is filled in with the file count.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;


    if (CountTier2Files == 0) {
        Status = SfcFilesInit();
        if (!NT_SUCCESS(Status)) {
            *Files = NULL;
            *FileCount = 0;
            return Status;
        }
    }

    ASSERT(Tier2Files != NULL);
    ASSERT(CountTier2Files != 0);

    *Files = Tier2Files;
    *FileCount = CountTier2Files;

    return STATUS_SUCCESS;
}

NTSTATUS
pSfcGetFilesList(
    IN DWORD ListMask,
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    )
/*++

Routine Description:

    Retreives pointers to the requested file list and file count.
    
    This is an internal testing routine that is used so that we can retrieve
    any file list on a given machine so testing does not have to install more
    than one build to get at multiple file lists
    
Arguments:

    ListMask - specifies a SFCFILESMASK_* constant
    Files - pointer to a PPROTECT_FILE_ENTRY, which is filled in with a pointer
            to the actual protected files list.
    FileCount - pointer to a ULONG which is filled in with the file count.

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS RetVal = STATUS_SUCCESS;

    if (!Files || !FileCount) {
        return(STATUS_INVALID_PARAMETER);
    }

    switch (ListMask) {
        case SFCFILESMASK_PROFESSIONAL:
            *Files = WksFiles;
            *FileCount = CountWksFiles;
            break;
#if !defined(_AMD64_) && !defined(_IA64_)
        case SFCFILESMASK_PERSONAL:
            *Files = PerFiles;
            *FileCount = CountPerFiles;
            break;
        case SFCFILESMASK_SERVER:
            *Files = SrvFiles;
            *FileCount = CountSrvFiles;
            break;
        case SFCFILESMASK_SBSERVER:
            *Files = SbsFiles;
            *FileCount = CountSbsFiles;
            break;
        case SFCFILESMASK_BLASERVER:
            *Files = BlaFiles;
            *FileCount = CountBlaFiles;
            break;
#endif
        case SFCFILESMASK_ADVSERVER:
            *Files = EntFiles;
            *FileCount = CountEntFiles;
            break;
        case SFCFILESMASK_DTCSERVER:
            *Files = DtcFiles;
            *FileCount = CountDtcFiles;
            break;
        default:
            RetVal = STATUS_INVALID_PARAMETER;
    }

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\rpc\cli\makefile.inc ===
$(O)\sfcapi_c.c : ..\idl\$(O)\sfcapi_c.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\rpc\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR  [string] LPSTR
#define LPTSTR [string] LPTSTR
#define LPWSTR [string] wchar_t *
#define PWSTR  [string] wchar_t *
#define PCWSTR [string] const wchar_t *
#define enum   [v1_enum] enum
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\publish\makefile.inc ===
#
# sfc.h, sfcapip.h, sfcapip.x, sfc.x
#


$(O)\sfc.x $(O)\sfcapip.x: sfc.w
    hsplit -e -o $(O)\sfc.x $(O)\sfcapip.x sfc.w

$(O)\sfc.h: $(O)\sfc.x
    wcshdr < $? > $@

$(O)\sfcapip.h: $(O)\sfcapip.x
    wcshdr < $? > $@

$(O)\sfcfiles.h : sfcfiles.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(SDK_INC_PATH)\sfc.h: $(O)\sfc.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\sfcapip.h: $(O)\sfcapip.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\sfcfiles.h : $(O)\sfcfiles.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\sfcexts\sfcext.c ===
#include "sfcp.h"
#include "sfcfiles.h"
#include <wchar.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD_PTR dwCurrentPc,                  \
        PWINDBG_EXTENSION_APIS lpExtensionApis, \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), ((DWORD *)d) ))

#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), ((DWORD *)d) ))

#define Ioctl                   (ExtensionApis.lpIoctlRoutine)




WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;



PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with MyFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = malloc(BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        free(UnicodeString);
        return(NULL);
    }

    return(UnicodeString);

}




void
dump_SFC_REGISTRY_VALUE(
    PSFC_REGISTRY_VALUE srv,
    DWORD_PTR           Addr
    )
{
    SIZE_T cb;
    WCHAR buf[512];

    dprintf( "SFC_REGISTRY_VALUE at %p\n", Addr );
    dprintf( "\tEntry.Flink        = 0x%08x\n", srv->Entry.Flink );
    dprintf( "\tEntry.Blink        = 0x%08x\n", srv->Entry.Blink );
    ReadMemory( srv->FileName.Buffer, buf, srv->FileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tFileName           = %ws\n",    buf );
    ReadMemory( srv->DirName.Buffer, buf, srv->DirName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tDirName            = %ws\n",    buf );
    ReadMemory( srv->FullPathName.Buffer, buf, srv->FullPathName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tFullPathName       = %ws\n",    buf );
    ReadMemory( srv->InfName.Buffer, buf, srv->FileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tInfName            = %ws\n",    srv->InfName );
    ReadMemory( srv->SourceFileName.Buffer, buf, srv->SourceFileName.Length+sizeof(WCHAR), &cb);
    dprintf( "\tSourceFileName     = %ws\n",    srv->SourceFileName );
    dprintf( "\tDirHandle          = 0x%08x\n", srv->DirHandle  );
    //dprintf( "\tFlags              = 0x%08x\n", srv->IgnoreNextChange  );
}

void
dump_IMAGE_VALIDATION_DATA(
    PIMAGE_VALIDATION_DATA ivd
    )
{
    dprintf( "DllVersion         = 0x%I64x\n", ivd->DllVersion );
    dprintf( "DllCheckSum        = 0x%08x\n", ivd->DllCheckSum );
    dprintf( "SignatureValid     = %s\n", ivd->SignatureValid ? "true" : "false"  );
    dprintf( "FilePresent        = %s\n", ivd->FilePresent ? "true" : "false"  );
}

void
dump_COMPLETE_VALIDATION_DATA(
    PCOMPLETE_VALIDATION_DATA cvd
    )
{
    dprintf( "*Original*           = 0x%08x\n", &cvd->Original );
    dump_IMAGE_VALIDATION_DATA( &cvd->Original );
    dprintf( "*Cache*              = 0x%08x\n", &cvd->Cache );
    dump_IMAGE_VALIDATION_DATA( &cvd->Cache );
    dprintf( "*New*              = 0x%08x\n", &cvd->New );
    dump_IMAGE_VALIDATION_DATA( &cvd->New );
    dprintf( "RestoreFromReal    = %s\n", cvd->RestoreFromReal ? "true" : "false"  );
    dprintf( "RestoreFromCache   = %s\n", cvd->RestoreFromCache ? "true" : "false"  );
    dprintf( "RestoreFromMedia   = %s\n", cvd->RestoreFromMedia ? "true" : "false"  );
    dprintf( "NotifyUser         = %s\n", cvd->NotifyUser ? "true" : "false"  );
    dprintf( "BadCacheEntry      = %s\n", cvd->BadCacheEntry ? "true" : "false"  );
}

void
dump_RESTORE_QUEUE(
    PRESTORE_QUEUE rq,
    DWORD_PTR  Addr
    )
{
    dprintf( "RESTORE_QUEUE at %p\n", Addr );
    dprintf( "FileQueue = %p\n", rq->FileQueue  );
    dprintf( "QueueCount = %d\n", rq->QueueCount  );
    dprintf( "RestoreInProgress   = %s\n", rq->RestoreInProgress ? "true" : "false"  );
    dprintf( "RestoreComplete   = %s\n", rq->RestoreComplete ? "true" : "false"  );
    dprintf( "RestoreStatus   = %s\n", rq->RestoreStatus ? "true" : "false"  );
    dprintf( "LastErrorCode   = %d (0x%08x)\n", rq->LastErrorCode, rq->LastErrorCode );
    dprintf( "WorkerThreadHandle = %d\n", rq->WorkerThreadHandle );

}

void
dump_VALIDATION_REQUEST_DATA(
    PVALIDATION_REQUEST_DATA vrd,
    DWORD_PTR           Addr
    )
{
    SIZE_T cb;
    SFC_REGISTRY_VALUE RegVal;


    dprintf( "**VALIDATION_REQUEST_DATA at address = 0x%p**\n", Addr );

#if DBG
    if (vrd->Signature != 0x69696969) {
        dprintf( "**** invalid queue entry, signature does not match\n" );
        return;
    }
#endif

    dprintf( "\tEntry.Flink        = 0x%08x\n", vrd->Entry.Flink );
    dprintf( "\tEntry.Blink        = 0x%08x\n", vrd->Entry.Blink );
    dprintf( "\tImageValData       = 0x%08x\n", &vrd->ImageValData );
    dump_COMPLETE_VALIDATION_DATA( &vrd->ImageValData );
    dprintf( "\tRegVal             = 0x%08x\n", vrd->RegVal );
    ReadMemory( vrd->RegVal, &RegVal, sizeof(SFC_REGISTRY_VALUE), &cb);
    dump_SFC_REGISTRY_VALUE( &RegVal, (DWORD_PTR)vrd->RegVal );
    dprintf( "\tChangeType         = %d\n",     vrd->ChangeType );
    dprintf( "\tCopyCompleted      = %s\n",     vrd->CopyCompleted ? "true" : "false"  );
    dprintf( "\tWin32Error         = %d (0x%08x)\n", vrd->Win32Error, vrd->Win32Error  );
    dprintf( "\tFlags              = 0x%08x\n", vrd->Flags );
    dprintf( "\tRetryCount         = 0x%08x\n", vrd->RetryCount );
    dprintf( "\tSyncOnly           = %s\n",     vrd->SyncOnly ? "true" : "false"  );
}

void
dump_PROTECT_FILE_ENTRY(
    PPROTECT_FILE_ENTRY Entry,
    DWORD_PTR           Addr
    )
{
    WCHAR  SourceFileBuffer[MAX_PATH];
    WCHAR  DestFileBuffer[MAX_PATH];
    WCHAR  InfNameBuffer[MAX_PATH];
    SIZE_T cb;

    if (Entry->SourceFileName) {
        ReadMemory( Entry->SourceFileName, SourceFileBuffer, sizeof(SourceFileBuffer), &cb);
    }else {
        SourceFileBuffer[0] = L'\0';
    }

    if (Entry->FileName) {
        ReadMemory( Entry->FileName, DestFileBuffer, sizeof(DestFileBuffer), &cb);
    }else {
        DestFileBuffer[0] = L'\0';
    }

    if (Entry->InfName) {
        ReadMemory( Entry->InfName, InfNameBuffer, sizeof(InfNameBuffer), &cb);
    }else {
        InfNameBuffer[0] = L'\0';
    }

    dprintf( " PROTECT_FILE_ENTRY at %p\n", Addr );
    dprintf( " \tSourceFileName = %S\n" , SourceFileBuffer[0] ? SourceFileBuffer : L"[Same as target name]" );
    dprintf( " \tFileName = %S\n" , DestFileBuffer  );
    dprintf( " \tInfName = %S\n" , InfNameBuffer[0] ? InfNameBuffer : L"[None, default to layout.inf]" );

}

BOOL
DoesProtFileEntryMatch(
    PPROTECT_FILE_ENTRY Entry,
    DWORD_PTR           Addr,
    PCWSTR              FileName
    )
{
    WCHAR  SourceFileBuffer[MAX_PATH];
    WCHAR  DestFileBuffer[MAX_PATH];
    WCHAR  InfNameBuffer[MAX_PATH];
    DWORD  count;
    PCWSTR p;
    SIZE_T cb;
    PCWSTR a[3] = { SourceFileBuffer, DestFileBuffer, InfNameBuffer } ;

    if (Entry->SourceFileName) {
        ReadMemory( Entry->SourceFileName, SourceFileBuffer, sizeof(SourceFileBuffer), &cb);
    }else {
        SourceFileBuffer[0] = L'\0';
    }

    if (Entry->FileName) {
        ReadMemory( Entry->FileName, DestFileBuffer, sizeof(DestFileBuffer), &cb);
    }else {
        DestFileBuffer[0] = L'\0';
    }

    if (Entry->InfName) {
        ReadMemory( Entry->InfName, InfNameBuffer, sizeof(InfNameBuffer), &cb);
    }else {
        InfNameBuffer[0] = L'\0';
    }

    for (count = 0; count < 3; count++) {

        p = wcsrchr( a[count], L'\\' );
        if (p) {
            p += 1;
            if (_wcsicmp(p, FileName)== 0) {
                return(TRUE);
            }
        }
    }

    return(FALSE);

}

BOOL
DoesRegEntryMatch(
    PSFC_REGISTRY_VALUE Entry,
    DWORD_PTR           Addr,
    PCWSTR              FileName
    )
{
    WCHAR  Buffer[MAX_PATH];
    DWORD  count;
    PCWSTR p;
    SIZE_T cb;
    PUNICODE_STRING a[5];

    a[0] = &Entry->FileName;
    a[1] = &Entry->DirName;
    a[2] = &Entry->FullPathName;
    a[3] = &Entry->InfName;
    a[4] = &Entry->SourceFileName;

    for (count = 0; count < 5; count++) {
        if (a[count]->Buffer) {
            ReadMemory( a[count]->Buffer, Buffer, sizeof(Buffer), &cb);
        }
        p = wcsrchr( Buffer, L'\\' );
        if (p) {
            p += 1;
        } else {
            p = Buffer;
        }
        if (_wcsicmp(p, FileName)== 0) {
            return(TRUE);
        }
    }

    return(FALSE);

}



DECLARE_API( help )
{
    INIT_API();

    dprintf( "WFP debugger extension commands:\n" );
    dprintf( "dumpq -  dump validation queue\n" );
    dprintf( "dumpsettings - dump global WFP settings\n" );
    dprintf( "isprotfile [filename] - search for a particular protected file in the list\n" );
    dprintf( "isprotfile [list address] [list count address] [filename] - search for a particular protected file in the list\n" );
    dprintf( "protfile - list all protected files in list\n" );
    dprintf( "protfile - [list address] [list count address] list all protected files in list\n" );
}


DECLARE_API( dumpq )
{
    DWORD_PTR addr;
    SIZE_T cb;
    LIST_ENTRY Next;
    VALIDATION_REQUEST_DATA vrd;



    INIT_API();

    addr = GetExpression( "SfcErrorQueue" );
    if (!addr) {
        dprintf("couldn't get address");
        return;
    }
    dprintf( "SfcErrorQueue address=0x%p\n", addr );

    ReadMemory( addr, &Next, sizeof(Next), &cb);

    if (Next.Flink == (PVOID)addr) {
        dprintf( "queue is empty\n" );
        return;
    }

    do {
        ReadMemory( Next.Flink, &vrd, sizeof(VALIDATION_REQUEST_DATA), &cb);
        dump_VALIDATION_REQUEST_DATA( &vrd, (DWORD_PTR)Next.Flink );
        Next.Flink = vrd.Entry.Flink;
        if (Next.Flink != (PVOID)addr) {
            dprintf( "\n******************************************\n\n" );
        }

        if (CheckControlC() ) {
            dprintf( "\nInterrupted\n\n" );
            break;
        }
    } while (Next.Flink != (PVOID)addr);
}

DECLARE_API( dumpsettings )
{
    DWORD_PTR addr;
    SIZE_T cb;
    DWORD val;


    INIT_API();


    addr = GetExpression( "SFCDisable" );

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &val, sizeof(DWORD), &cb);
    dprintf( "SFCDisable = %d\n", val );
}

DECLARE_API( dumpregval )
{
    DWORD_PTR addr;
    SIZE_T cb;
    SFC_REGISTRY_VALUE regval;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &regval, sizeof(SFC_REGISTRY_VALUE), &cb);
    dump_SFC_REGISTRY_VALUE( &regval, (DWORD_PTR)addr );

    return;

}


DECLARE_API( dumprq )
{
    DWORD_PTR addr;
    SIZE_T cb;
    RESTORE_QUEUE rq;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &rq, sizeof(RESTORE_QUEUE), &cb);
    dump_RESTORE_QUEUE( &rq, addr );

    return;

}


DECLARE_API( dumpvrd )
{
    DWORD_PTR addr;
    SIZE_T cb;
    VALIDATION_REQUEST_DATA vrd;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addr = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
        return;
    }

    if (!addr) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addr, &vrd, sizeof(VALIDATION_REQUEST_DATA), &cb);
    dump_VALIDATION_REQUEST_DATA( &vrd, addr );

    return;

}



DECLARE_API( protfile )
{
    DWORD_PTR addrNext, addrTotal;
    SIZE_T cb;
    PROTECT_FILE_ENTRY Next;
    ULONG Total;
    ULONG Current;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        addrNext = GetExpression( lpArgumentString );

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            addrTotal = GetExpression( lpArgumentString );
        } else {
            dprintf("bogus usage\n");
            return;
        }
    }

    else {
        addrNext = GetExpression( "sfc!Tier2Files" );
        addrTotal = GetExpression( "sfc!CountTier2Files" );
    }

    if (!addrTotal || !addrNext) {
       dprintf("couldn't get address");
       return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);

    dprintf( "Tier2Files: address=0x%p Total=%d\n", addrNext, Total );

    Current = 0;
    while (Current < Total) {

        dump_PROTECT_FILE_ENTRY( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );

        ReadMemory( addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)), &Next, sizeof(PROTECT_FILE_ENTRY), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }


}

DECLARE_API( isprotfile )
{
    DWORD_PTR addrNext, addrTotal;
    PCSTR FileName;
    SIZE_T cb;
    PROTECT_FILE_ENTRY Next;
    ULONG Total;
    ULONG Current;
    BOOL FoundMatch = FALSE;
    PCWSTR FileNameW;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        FileName = lpArgumentString;
        addrNext = GetExpression( lpArgumentString );

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            addrTotal = GetExpression( lpArgumentString );
        } else {
            addrNext = GetExpression( "sfc!Tier2Files" );
            addrTotal = GetExpression( "sfc!CountTier2Files" );
            goto doit;
        }

        while (*lpArgumentString && (*lpArgumentString != ' ') ) {
           lpArgumentString++;
        }
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString) {
            FileName = lpArgumentString;
        } else {
            dprintf("bogus usage\n");
            return;
        }

    } else {
        dprintf("bogus usage\n");
        return;
    }

doit:

    if (!addrTotal || !addrNext) {
        dprintf("couldn't get address");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    FileNameW = MultiByteToUnicode( FileName, CP_ACP );
    if (!FileNameW) {
        dprintf("Error: couldn't convert filename to unicode string\n");
        return;
    }

    Current = 0;
    while (Current < Total) {

        if (DoesProtFileEntryMatch( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)),FileNameW )) {
            dump_PROTECT_FILE_ENTRY( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );
            FoundMatch = TRUE;
        }

        ReadMemory( addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)), &Next, sizeof(PROTECT_FILE_ENTRY), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

    if (!FoundMatch) {
        dprintf( "Couldn't find %s in list\n", FileName );
    }

    free((PVOID)FileNameW);

}

DECLARE_API( regvals )
{
    DWORD_PTR addrNext, addrTotal;
    SIZE_T cb;
    SFC_REGISTRY_VALUE Next;
    ULONG Total;
    ULONG Current;



    INIT_API();

    addrNext = GetExpression( "sfc!SfcProtectedDllsList" );
    addrTotal = GetExpression( "sfc!SfcProtectedDllCount" );

    if (!addrNext || ! addrTotal) {
        dprintf("Error: couldn't resolve sfc!SfcProtectedDllsList and sfc!SfcProtectedDllCount\n");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    dprintf( "SfcProtectedDllsList: address=0x%p Total=%d\n", addrNext, Total );

    Current = 0;
    while (Current < Total) {

        dump_SFC_REGISTRY_VALUE( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );

        ReadMemory( addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)), &Next, sizeof(SFC_REGISTRY_VALUE), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

}


DECLARE_API( getregval )
{
    DWORD_PTR addrNext, addrTotal;
    PCSTR FileName;
    SIZE_T cb;
    SFC_REGISTRY_VALUE Next;
    ULONG Total;
    ULONG Current;
    BOOL FoundMatch = FALSE;
    PCWSTR FileNameW;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        FileName = lpArgumentString;
    } else {
        dprintf("bogus usage\n");
        return;
    }

    addrNext = GetExpression( "sfc!SfcProtectedDllsList" );
    addrTotal = GetExpression( "sfc!SfcProtectedDllCount" );

    if (!addrNext || ! addrTotal) {
        dprintf("Error: couldn't resolve sfc!SfcProtectedDllsList and sfc!SfcProtectedDllCount\n");
        return;
    }

    ReadMemory( addrNext, &Next, sizeof(PROTECT_FILE_ENTRY), &cb);
    ReadMemory( addrTotal, &Total, sizeof(ULONG), &cb);


    FileNameW = MultiByteToUnicode( FileName, CP_ACP );
    if (!FileNameW) {
        dprintf("Error: couldn't convert filename to unicode string\n");
        return;
    }

    Current = 0;
    while (Current < Total) {

        if (DoesRegEntryMatch( &Next, addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)),FileNameW )) {
            dump_SFC_REGISTRY_VALUE( &Next, addrNext+(Current*sizeof(PROTECT_FILE_ENTRY)) );
            FoundMatch = TRUE;
        }

        ReadMemory( addrNext+(Current*sizeof(SFC_REGISTRY_VALUE)), &Next, sizeof(SFC_REGISTRY_VALUE), &cb);

        Current += 1;

        if ( CheckControlC() ) {
           dprintf( "\nInterrupted\n\n" );
           break;
        }
    }

    if (!FoundMatch) {
        dprintf( "Couldn't find %s in list\n", FileName );
    }

    free((PVOID)FileNameW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\rpc\srv\makefile.inc ===
$(O)\sfcapi_s.c : ..\idl\$(O)\sfcapi_s.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\sfc_fwd\stub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Stubbed out Windows File Protection APIs.  These APIs are "Millenium" SFC 
    apis, which we simply stub out so that any clients programming to these
    APIs may work on both platforms

Author:

    Andrew Ritz (andrewr) 23-Sep-1999

Revision History:
    
    

--*/

#include <windows.h>
#include <srrestoreptapi.h>

DWORD
WINAPI
SfpInstallCatalog(
    IN LPCSTR pszCatName, 
    IN LPCSTR pszCatDependency,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
WINAPI
SfpDeleteCatalog(
    IN LPCSTR pszCatName,
    IN PVOID Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


BOOL
WINAPI
SfpVerifyFile(
    IN LPCSTR pszFileName,
    IN LPSTR  pszError,
    IN DWORD   dwErrSize
    )
{

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
    
}

#undef SRSetRestorePoint
#undef SRSetRestorePointA
#undef SRSetRestorePointW

typedef BOOL (WINAPI * PSETRESTOREPOINTA) (PRESTOREPOINTINFOA, PSTATEMGRSTATUS);
typedef BOOL (WINAPI * PSETRESTOREPOINTW) (PRESTOREPOINTINFOW, PSTATEMGRSTATUS);

BOOL
WINAPI
SRSetRestorePointA ( PRESTOREPOINTINFOA  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;
    
    if (hClient != NULL)
    {
        PSETRESTOREPOINTA pSetRestorePointA = (PSETRESTOREPOINTA )
                          GetProcAddress (hClient, "SRSetRestorePointA"); 

        if (pSetRestorePointA != NULL)
        {
            fReturn =  (* pSetRestorePointA) (pRestorePtSpec, pSMgrStatus); 
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

    return fReturn;
}

BOOL
WINAPI
SRSetRestorePointW ( PRESTOREPOINTINFOW  pRestorePtSpec,
                     PSTATEMGRSTATUS     pSMgrStatus )
{
    HMODULE hClient = LoadLibrary (L"SRCLIENT.DLL");
    BOOL fReturn = FALSE;

    if (hClient != NULL)
    {
        PSETRESTOREPOINTW pSetRestorePointW = (PSETRESTOREPOINTW )
                          GetProcAddress (hClient, "SRSetRestorePointW");

        if (pSetRestorePointW != NULL)
        {
            fReturn =  (* pSetRestorePointW) (pRestorePtSpec, pSMgrStatus);
        }
        else if (pSMgrStatus != NULL)
            pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;

        FreeLibrary (hClient);
    }
    else if (pSMgrStatus != NULL)
        pSMgrStatus->nStatus = ERROR_CALL_NOT_IMPLEMENTED;


    return fReturn;
}

#include <sfcapip.h>

ULONG
MySfcInitProt(
    IN ULONG  OverrideRegistry,
    IN ULONG  RegDisable,        OPTIONAL
    IN ULONG  RegScan,           OPTIONAL
    IN ULONG  RegQuota,          OPTIONAL
    IN HWND   ProgressWindow,    OPTIONAL
    IN PCWSTR SourcePath,        OPTIONAL
    IN PCWSTR IgnoreFiles        OPTIONAL
    )
{
    return SfcInitProt( OverrideRegistry, RegDisable, RegScan, RegQuota, ProgressWindow, SourcePath, IgnoreFiles);
}

VOID
MySfcTerminateWatcherThread(
    VOID
    )
{
    SfcTerminateWatcherThread();
}

HANDLE
WINAPI
MySfcConnectToServer(
    IN PCWSTR ServerName
    )
{
    return SfcConnectToServer(ServerName);
}

VOID
MySfcClose(
    IN HANDLE RpcHandle
    )
{
    SfcClose(RpcHandle);
}

DWORD
WINAPI
MySfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return SfcFileException(RpcHandle, FileName, ExpectedChangeType);
}

DWORD
WINAPI
MySfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    )
{
    return SfcInitiateScan(RpcHandle, ScanWhen);
}

BOOL
WINAPI
MySfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context OPTIONAL
    )
{
    return SfcInstallProtectedFiles(RpcHandle, FileNames, AllowUI, ClassName, WindowName, SfcNotificationCallback, Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\test\resource.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource header file.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:

--*/

#define IDC_STATIC                              -1
#define IDI_CDROM                               201
#define IDD_SFC_CD_PROMPT                       402
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\stress\test.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sfc.h>

PROTECTED_FILE_DATA pd;
DWORD CachedFiles;
DWORD NonCachedFiles;
DWORD TotalFiles;
WCHAR BackupDir[256];



void
ProcessProtectedFile(
    int FileNumber
    )
{
    int action;
    PWSTR s;
    WCHAR buf[512];


    //
    // get the file name
    //
    ZeroMemory( &pd, sizeof(pd) );
    pd.FileNumber = (DWORD)FileNumber;
    if (!SfcGetNextProtectedFile(NULL,&pd)) {
        return;
    }
    //
    // if the file doesn't exist then there is nothing do to
    //
    if (GetFileAttributes( pd.FileName ) == 0xffffffff) {
        return;
    }
    //
    // backup the file before we mess with it
    //
    wcscpy( buf, BackupDir );
    wcscat( buf, &pd.FileName[2] );
    s = wcsrchr( buf, L'\\' );
    *s = 0;
    CreateDirectory( buf, NULL );
    *s = L'\\';
    CopyFile( pd.FileName, buf, FALSE );
    //
    // now do something
    //
    action = rand() % 3;
    switch (action) {
        case 0:
            //
            // delete the file
            //
            DeleteFile( pd.FileName );
            break;
        case 1:
            //
            // rename the file
            //
            wcscpy( buf, pd.FileName );
            wcscat( buf, L".sfc" );
            MoveFileEx( pd.FileName, buf, MOVEFILE_REPLACE_EXISTING );
            break;
        case 2:
            //
            // move the file
            //
            wcscpy( buf, L"c:\\temp\\sfctemp" );
            wcscat( buf, &pd.FileName[2] );
            MoveFileEx( pd.FileName, buf, MOVEFILE_REPLACE_EXISTING );
            break;
        case 3:
            //
            // change the file attributes
            //
            SetFileAttributes( pd.FileName, GetFileAttributes( pd.FileName ) );
            break;
        default:
            //
            // should not get here....
            //
            return;
    }
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    LONG rc;
    HKEY hKey;
    PWSTR s;
    WCHAR buf[512];
    DWORD sz;
    WCHAR CacheDir[512];
    int rnum;
    DWORD FileCount = (DWORD)-1;
    HANDLE SfcDebugBreakEvent;


    if (argc == 2) {
        if (_wcsicmp( argv[1], L"break" ) == 0) {

            SfcDebugBreakEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, L"SfcDebugBreakEvent" );
            if (SfcDebugBreakEvent) {
                SetEvent( SfcDebugBreakEvent );
            } else {
                wprintf( L"could not open the break event, ec=%d\n", GetLastError() );
            }

            return 0;
        } else {
            FileCount = _wtoi( argv[1] );
        }
    }

    rc = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        L"software\\microsoft\\windows nt\\currentversion\\winlogon",
        &hKey
        );
    if (rc != ERROR_SUCCESS) {
        return 0;
    }

    sz = sizeof(buf);

    rc = RegQueryValueEx(
        hKey,
        L"SFCDllCacheDir",
        NULL,
        NULL,
        (LPBYTE)buf,
        &sz
        );
    if (rc != ERROR_SUCCESS) {
        wcscpy( buf, L"%systemroot%\\system32\\dllcache\\" );
    }

    RegCloseKey( hKey );

    if (buf[wcslen(buf)-1] != L'\\') {
        wcscat( buf, L"\\" );
    }

    rc = ExpandEnvironmentStrings( buf, CacheDir, sizeof(CacheDir)/sizeof(WCHAR) );
    if (!rc) {
        return 0;
    }

    wcscpy( BackupDir, L"c:\\temp\\sfcsave" );

    while (SfcGetNextProtectedFile(NULL,&pd)) {
        s = wcsrchr( pd.FileName, L'\\' );
        if (!s) {
            return 0;
        }
        s += 1;
        wcscpy( buf, CacheDir );
        wcscat( buf, s );
        if (GetFileAttributes( buf ) != 0xffffffff) {
            CachedFiles += 1;
        }
    }

    ZeroMemory( &pd, sizeof(pd) );
    pd.FileNumber = 0xffffffff;
    SfcGetNextProtectedFile(NULL,&pd);
    TotalFiles = pd.FileNumber;
    NonCachedFiles = TotalFiles - CachedFiles;

    wprintf( L"cached files     = %d\n", CachedFiles );
    wprintf( L"non-cached files = %d\n", NonCachedFiles );
    wprintf( L"total files      = %d\n", TotalFiles );

    srand( (unsigned int)GetTickCount() );

    while(1) {
        rnum = rand();
        if (rnum&1) {
            rnum = rand() % CachedFiles;
        } else {
            rnum = rand() % TotalFiles;
            if (rnum < (int)CachedFiles) {
                rnum = (rnum + CachedFiles) % TotalFiles;
            }
        }
        ProcessProtectedFile( rnum );
        if (FileCount != (DWORD)-1) {
            FileCount -= 1;
            if (FileCount == 0) {
                break;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\sfpcopy\sfp.c ===
#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>
#include <setupapi.h>
#include <spapip.h>
#include <sfcapip.h>


#define ALLOWRENAMES        TEXT("AllowProtectedRenames")

extern void RestartDialog(VOID *, VOID *, UINT);

void
PrintUsage(
    void
    )
{
    printf("allows copying a protected system file\n");
    printf("if the file is in use, you will have to reboot.\n");
    printf("Usage: sfpcopy -q [source] [destination]\n");
    printf(" q: silent mode: if the file is in use, force a reboot\n");
    return;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;

    rslt = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
        0,
        KEY_SET_VALUE,
        &hKey
        );

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = bSet ? 1 : 0;
        rslt = RegSetValueEx(
            hKey,
            TEXT("AllowProtectedRenames"),
            0,
            REG_DWORD,
            (LPBYTE)&Value,
            sizeof(DWORD)
            );

        RegCloseKey(hKey);
    }

    return(rslt == ERROR_SUCCESS);
}


int _cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )
{
    LPTSTR TargetName = NULL,SourceName=NULL;
    TCHAR TargetDir[MAX_PATH];
    TCHAR TempFile[MAX_PATH];
    LPTSTR p;

    BOOL SilentMode = FALSE;
    BOOL NeedReboot = FALSE;
    HANDLE hSfp;
    DWORD Result = NO_ERROR;

    //
    // parse args
    //
    while (--argc) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {
                case TEXT('q'):
                case TEXT('Q'):
                    SilentMode = TRUE;
                    goto Next;
                    break;
                default:
                    PrintUsage();
                    return -1;
            }

        }

        if (!SourceName) {
            SourceName = argv[0];
        } else if (!TargetName) {
            TargetName = argv[0];
        } else {
            PrintUsage();
            return -1;
        }
Next:
    ;
    }

    //
    // Validate files are really there
    //
    if (!SourceName || !TargetName) {
        PrintUsage();
        return -1;
    }

    if (!FileExists(SourceName,NULL)) {
        printf("Invalid Source File\n");
        PrintUsage();
        return -1;
    }

    if (!FileExists(TargetName,NULL)) {
        printf("Invalid Target File\n");
        PrintUsage();
        return -1;
    }

    //
    // unprotect the file
    //
    hSfp = SfcConnectToServer( NULL );
    if (hSfp) {
        if (SfcIsFileProtected(hSfp,TargetName)) {
            Result = SfcFileException(
                hSfp,
                (PWSTR) TargetName,
                (DWORD) -1
                );
            if (Result != NO_ERROR) {
                printf("Couldn't unprotect file, ec = %d\n", Result);
                goto exit;
            }
        } else {
            if (!SilentMode) {
                printf("target file is not protected\n");
            }
        }
        SfcClose(hSfp);
    }

    //
    // copy the file
    //
    _tcscpy(TargetDir,TargetName);
    p = _tcsrchr(TargetDir,TEXT('\\'));
    if (p) {
        *p = (TCHAR)NULL;
    }

    GetTempFileName(TargetDir,TEXT("sfp"),0,TempFile);

    _tprintf( TEXT("Copying %s --> %s\n"), SourceName, TargetName);
    Result = 1;
    if (CopyFile(SourceName,TempFile,FALSE)) {
        if (!MoveFileEx(TempFile,TargetName,MOVEFILE_REPLACE_EXISTING)) {
            if (MoveFileEx(
                    TempFile,
                    TargetName,
                    MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT)
                    )
            {
                NeedReboot = TRUE;
                Result = NO_ERROR;
            }
        } else {
            Result = NO_ERROR;
        }
    } else {
        Result = GetLastError();
    }

    if (Result != NO_ERROR) {
        Result = GetLastError();
        printf("Failed to copy file, ec = %d\n", Result);
    }

    //
    // Reboot if necessary
    //
    if (Result == NO_ERROR && NeedReboot) {

        pSetupProtectedRenamesFlag(TRUE);

        if (SilentMode) {
            HANDLE hToken;
            TOKEN_PRIVILEGES tkp;  // Get a token for this process.

            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken)) {
                printf("Can't force silent reboot\n");
                goto verbose;
            }

            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
            tkp.PrivilegeCount = 1;  // one privilege to set
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Get the shutdown privilege for this process.
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

            //
            // Shut down the system and force all applications to close.
            //
            if (! ExitWindowsEx(EWX_REBOOT|EWX_FORCE , 0) ) {
                printf("Can't force silent reboot\n");
                goto verbose;
            }


        } else {
verbose:
            RestartDialog(NULL,NULL,EWX_REBOOT);
        }
    }

exit:
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\stress\util.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define VALUE_BUFFER_SIZE 1024


PWSTR
SfcQueryRegString(
    LPWSTR KeyNameStr,
    LPWSTR ValueNameStr
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    PWSTR s;

    //
    // Open the registry key.
    //

    RtlZeroMemory( (PVOID)ValueBuffer, VALUE_BUFFER_SIZE );
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        return NULL;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    s = (PWSTR) malloc( KeyValueInfo->DataLength + 16 );
    if (s == NULL) {
        return NULL;
    }

    CopyMemory( s, KeyValueInfo->Data, KeyValueInfo->DataLength );

    return s;
}

ULONG
SfcQueryRegDword(
    LPWSTR KeyNameStr,
    LPWSTR ValueNameStr
    )
{

    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;
    WCHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;

    //
    // Open the registry key.
    //

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    RtlInitUnicodeString( &KeyName, KeyNameStr );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    //
    // Query the key value.
    //

    RtlInitUnicodeString( &ValueName, ValueNameStr );
    Status = NtQueryValueKey(
        Key,
        &ValueName,
        KeyValuePartialInformation,
        (PVOID)KeyValueInfo,
        VALUE_BUFFER_SIZE,
        &ValueLength
        );

    NtClose(Key);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    return *((PULONG)&KeyValueInfo->Data);
}


ULONG
ExpandPathString(
    IN PWSTR PathString,
    IN ULONG PathStringLength,
    OUT PUNICODE_STRING FileName,
    OUT PUNICODE_STRING PathName
    )
{
    NTSTATUS Status;
    UNICODE_STRING NewPath;
    UNICODE_STRING SrcPath;
    PWSTR FilePart;


    SrcPath.Length = (USHORT)PathStringLength;
    SrcPath.MaximumLength = SrcPath.Length;
    SrcPath.Buffer = PathString;

    NewPath.Length = 0;
    NewPath.MaximumLength = (MAX_PATH*2) * sizeof(WCHAR);
    NewPath.Buffer = (PWSTR) malloc( NewPath.MaximumLength );
    if (NewPath.Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlExpandEnvironmentStrings_U(
        NULL,
        &SrcPath,
        &NewPath,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    if (FileName == NULL) {
        PathName->Length = NewPath.Length;
        PathName->MaximumLength = NewPath.MaximumLength;
        PathName->Buffer = NewPath.Buffer;
        return STATUS_SUCCESS;
    }

    FilePart = wcsrchr( NewPath.Buffer, L'\\' );
    if (FilePart == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    *FilePart = 0;
    FilePart += 1;

    PathName->Length = wcslen(NewPath.Buffer) * sizeof(WCHAR);
    PathName->MaximumLength = PathName->Length + 4;
    PathName->Buffer = (PWSTR) malloc( PathName->MaximumLength );
    if (PathName->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }
    wcscpy( PathName->Buffer, NewPath.Buffer );

    FileName->Length = wcslen(FilePart) * sizeof(WCHAR);
    FileName->MaximumLength = FileName->Length + 4;
    FileName->Buffer = (PWSTR) malloc( FileName->MaximumLength );
    if (FileName->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        free( PathName->Buffer );
        goto exit;
    }
    wcscpy( FileName->Buffer, FilePart );

    Status = STATUS_SUCCESS;

exit:
    free( NewPath.Buffer );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\subsys\sm\sfc\test\test.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbt.h>
#include <initguid.h>
#include <devguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <sfcapip.h>
#include "resource.h"




BOOL
CALLBACK
SfcNotificationCallback(
    IN PFILEINSTALL_STATUS FileInstallStatus,
    IN DWORD_PTR Context
    )
{
    wprintf( L"file=[%s], version=[%I64x], ec=[%d]\n", FileInstallStatus->FileName, FileInstallStatus->Version, FileInstallStatus->Win32Error  );
    return TRUE;
}


PWSTR
addstr(
    PWSTR s1,
    PWSTR s2
    )
{
    wcscpy( s1, s2 );
    return s1 + wcslen(s1) + 1;
}


#define MemAlloc malloc
#define MemFree  free

BOOL
MakeDirectory(
    PCWSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p, NewDir;
    BOOL retval;
    

    NewDir = p = MemAlloc( (wcslen(Dir) + 1) *sizeof(WCHAR) );
    if (p) {
        wcscpy(p, Dir);
    } else {
        return(FALSE);
    }

    
    if (*p != '\\') p += 2;
    while( *++p ) {
        while(*p && *p != TEXT('\\')) p++;
        if (!*p) {
            retval = CreateDirectory( NewDir, NULL );
            MemFree(NewDir);
            return(retval);
        }
        *p = 0;
        retval = CreateDirectory( NewDir, NULL );
        if (!retval && GetLastError() != ERROR_ALREADY_EXISTS) {
            MemFree(NewDir);
            return(retval);
        }
        *p = TEXT('\\');
    }
    
    MemFree( NewDir );

    return(TRUE);
}


PVOID
RegisterForDevChange(
    HWND hDlg
    )
{
    PVOID hNotifyDevNode;
    DEV_BROADCAST_DEVICEINTERFACE FilterData;


    FilterData.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    FilterData.dbcc_classguid  = GUID_DEVCLASS_CDROM;

    hNotifyDevNode = RegisterDeviceNotification( hDlg, &FilterData, DEVICE_NOTIFY_WINDOW_HANDLE );
    if (hNotifyDevNode == NULL) {
    }

    return hNotifyDevNode;
}


INT_PTR
CALLBACK
PromptForMediaDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DEV_BROADCAST_VOLUME *dbv;
    static UINT QueryCancelAutoPlay = 0;
    static PVOID hNotifyDevNode = NULL;

    if (uMsg == WM_INITDIALOG) {
        hNotifyDevNode = RegisterForDevChange( hwndDlg );
        QueryCancelAutoPlay = RegisterWindowMessage( L"QueryCancelAutoPlay" );
    }
    if (uMsg == WM_COMMAND && LOWORD(wParam) == IDCANCEL) {
        UnregisterDeviceNotification( hNotifyDevNode );
        EndDialog( hwndDlg, 0 );
    }
    if (uMsg == QueryCancelAutoPlay) {
        SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 1 );
        return 1;
    }
    if (uMsg == WM_DEVICECHANGE) {
        if (wParam == DBT_DEVICEARRIVAL) {
            dbv = (DEV_BROADCAST_VOLUME*)lParam;
            if (dbv->dbcv_devicetype == DBT_DEVTYP_VOLUME) {
                //
                // look for the cd
                //
                DWORD mask,i;
                WCHAR Path[16];
                WCHAR SourcePath[MAX_PATH];
                Path[1] = L':';
                Path[2] = L'\\';
                Path[3] = 0;
                Path[4] = 0;
                for (i=0,mask=dbv->dbcv_unitmask; i<26; i++) {
                    if (mask&1) {
                        Path[0] = (WCHAR)(L'A' + i);
                        Path[3] = 0;
                        if (dbv->dbcv_flags == DBTF_MEDIA) {
                            if (GetDriveType( Path ) == DRIVE_CDROM) {
                                MessageBox( hwndDlg, L"CD was inserted, YEA BABY!", L"Windows File Protection", MB_OK );
                                UnregisterDeviceNotification( hNotifyDevNode );
                                EndDialog( hwndDlg, 1 );
                            }
                        }
                    }
                    mask = mask >> 1;
                }
            }
        }
    }
    return FALSE;
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HANDLE RpcHandle = NULL;
    PROTECTED_FILE_DATA FileData;
    PWSTR fnames;
    PWSTR s;
    BOOL b;
    PROTECTED_FILE_DATA ProtFileData;
    DWORD starttype;
    DWORD quota;
    WCHAR Path[MAX_PATH];

#if 0
    GetPrivateProfileString(L"test",
                            L"path",
                            L"c:\\winnt\\system32",
                            Path,
                            sizeof(Path),
                            L"test.ini");

    return MakeDirectory( Path );
#endif

    if (argc == 2 && _wcsicmp(argv[1],L"/i")==0) {
        RpcHandle = SfcConnectToServer( NULL );
        s = fnames = (PWSTR) LocalAlloc( LPTR, 8192 );
        s = addstr( s, L"%windir%\\system32\\admwprox.dll" );
        s = addstr( s, L"%windir%\\system32\\adsiis.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\certmap.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\certwiz.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\cnfgprts.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\coadmin.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\dt_ctrl.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\fscfg.dll" );
        s = addstr( s, L"%windir%\\system32\\ftpsapi2.dll" );
        s = addstr( s, L"%windir%\\system32\\iisext.dll" );
        s = addstr( s, L"%windir%\\system32\\iismap.dll" );
        s = addstr( s, L"%windir%\\system32\\iisreset.exe" );
        s = addstr( s, L"%windir%\\system32\\iisrstap.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\iisrstas.exe" );
        s = addstr( s, L"%windir%\\system32\\iisrtl.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\iisui.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\inetmgr.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\inetmgr.exe" );
        s = addstr( s, L"%windir%\\system32\\inetsloc.dll" );
        s = addstr( s, L"%windir%\\system32\\infoadmn.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\isatq.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\logui.ocx" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\nntpadm.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\nntpsnap.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\smtpadm.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\smtpsnap.dll" );
        s = addstr( s, L"%windir%\\system32\\staxmem.dll" );
        s = addstr( s, L"%windir%\\system32\\inetsrv\\w3scfg.dll" );
        s = addstr( s, L"%windir%\\system32\\wamregps.dll" );

        SfcInstallProtectedFiles( RpcHandle, fnames, TRUE, NULL, NULL, SfcNotificationCallback, 0 );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/t")==0) {
        RpcHandle = SfcConnectToServer( NULL );
        b = SfcIsFileProtected( RpcHandle, L"%systemroot%\\system32\\kernel32.dll" );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/x")==0) {
        //RpcHandle = SfcConnectToServer( NULL );
        ZeroMemory( &ProtFileData, sizeof(PROTECTED_FILE_DATA) );
        ProtFileData.FileNumber = 24;
        b = SfcGetNextProtectedFile( RpcHandle, &ProtFileData );
        if (b) {
            wprintf( L"%ws\n", ProtFileData.FileName );
        }
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/c")==0) {
        DialogBoxParam(
            GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_SFC_CD_PROMPT),
            NULL,
            PromptForMediaDialogProc,
            0
            );
        return 0;
    }

    if (argc == 2 && _wcsicmp(argv[1],L"/p")==0) {
        TCHAR DllPath[MAX_PATH];
        HMODULE DllMod;

        ExpandEnvironmentStrings(argv[2],DllPath,sizeof(DllPath)/sizeof(TCHAR));
        DllMod = LoadLibrary(DllPath);

        MoveFileEx(DllPath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);

        FreeLibrary(DllMod);
        
    }




    starttype = GetPrivateProfileInt(L"test",
                                        L"starttype",
                                        0,
                                        L"test.ini");

    quota = GetPrivateProfileInt(L"test",
                                 L"quota",
                                 0,
                                 L"test.ini");



    SfcInitProt( SFC_REGISTRY_OVERRIDE, 
                 starttype, 
                 SFC_SCAN_NORMAL,
                 quota,
                 NULL,
                 NULL,
                 NULL);

    while (TRUE) {
      if (WaitForSingleObject( NtCurrentProcess(), 1000 * 10 ) == WAIT_OBJECT_0) {
         break;
      }

      if (GetPrivateProfileInt(L"test",
                               L"shutdown",
                               0,
                               L"test.ini")) {
         break;
      }      

    }

    SfcTerminateWatcherThread();

    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    SfcInitiateScan( RpcHandle, 0 );
    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    SfcFileException( RpcHandle, argv[1], FILE_ACTION_REMOVED );
    return 0;

    RpcHandle = SfcConnectToServer( NULL );
    FileData.FileNumber = 0;

    while(SfcGetNextProtectedFile(RpcHandle,&FileData)) {
        if (GetFileAttributes(FileData.FileName) != 0xffffffff) {
            wprintf( L"File = %ws\n", FileData.FileName );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\blade\hash.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    This module compiles into a program hash.exe
    that is used to compute the import table hash.
    
    This program should be in the path for the perl 
    tool webblade.pl to work.
    
Author:

    Vishnu Patankar (VishnuP) 04-June-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

VOID
PrintHash(
    BYTE *Hash
    );

VOID PrintNibble(
    BYTE    OneByte
    );

VOID 
PrintError(
    DWORD rc
    );

#define WEB_BLADE_MAX_HASH_SIZE 16

VOID __cdecl
main(int argc, char *argv[])
{
    char * lpFileName;
    HANDLE hFile;
    SECURITY_ATTRIBUTES sa;
    BYTE    Hash[WEB_BLADE_MAX_HASH_SIZE];
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    // Get the name of the passed .exe
    //

    if (argc != 2) {
        printf("Usage: hash <filename>\n");
        exit(0);
    }

    lpFileName = argv[1];

    //
    // Map the image of the exe
    //

    sa.nLength = sizeof( SECURITY_ATTRIBUTES );
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = FALSE;

    hFile = CreateFile(
                lpFileName,
                GENERIC_READ,
                0,
                &sa,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (hFile == INVALID_HANDLE_VALUE) {
        PrintError(GetLastError());
	return;
    }

#define ITH_REVISION_1  1

    Status = RtlComputeImportTableHash( hFile, Hash, ITH_REVISION_1 );
    
    if (NT_SUCCESS(Status)) {
        wprintf(L"Hashing Succeeded:");
        PrintHash( Hash );
    }
    else {
        PrintError(RtlNtStatusToDosError(Status));
    }

    CloseHandle(hFile);

    return;
}

VOID
PrintHash(
    BYTE *Hash
    )
{

    DWORD dwIndex;

    if (Hash == NULL) {
        return;
    }
    
    for (dwIndex=0; dwIndex < WEB_BLADE_MAX_HASH_SIZE; dwIndex++ ) {
        PrintNibble( (Hash[dwIndex] & 0xF0) >> 4 );
        PrintNibble( Hash[dwIndex] & 0xF );
    }

    printf("\n");

}

VOID PrintNibble(
    BYTE    OneByte
    )
{
    DWORD   dwIndex;
        
        switch (OneByte) {
        case 0x0: 
            printf("0");
            break;
        case 0x1: 
            printf("1");
            break;
        case 0x2: 
            printf("2");
            break;
        case 0x3: 
            printf("3");
            break;
        case 0x4: 
            printf("4");
            break;
        case 0x5: 
            printf("5");
            break;
        case 0x6: 
            printf("6");
            break;
        case 0x7: 
            printf("7");
            break;
        case 0x8: 
            printf("8");
            break;
        case 0x9: 
            printf("9");
            break;
        case 0xa: 
            printf("A");
            break;
        case 0xb: 
            printf("B");
            break;
        case 0xc: 
            printf("C");
            break;
        case 0xd: 
            printf("D");
            break;
        case 0xe: 
            printf("E");
            break;
        case 0xf: 
            printf("F");
            break;
        default:
            break;
        
        }
    
}


VOID 
PrintError(
    DWORD rc
    )
{
    LPVOID     lpMsgBuf=NULL;

    wprintf(L"Hashing Failed:");

    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   rc,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   (LPTSTR)&lpMsgBuf,
                   0,
                   NULL
                 );

    if (lpMsgBuf) {
        wprintf(L"%s", lpMsgBuf);
        LocalFree(lpMsgBuf);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\bldrthnk\bldrthnk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bldrthnk.c

Abstract:

    This module implements a program which generates code to thunk from
    32-bit to 64-bit structures.

    This code is generated as an aid to the AMD64 boot loader, which
    must generate 64-bit structures from 32-bit structures.

Author:

    Forrest C. Foltz (forrestf) 15-May-2000


To use:

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "bldrthnk.h"

//
// Internal type definitions follow
// 

typedef struct _OBJ {
    PCHAR Image;
    LONG ImageSize;
    PDEFINITIONS Definitions;
} OBJ, *POBJ;

typedef struct _TYPE_REC  *PTYPE_REC;
typedef struct _FIELD_REC *PFIELD_REC;

typedef struct _TYPE_REC {
    PTYPE_REC Next;
    PCHAR Name;
    ULONG Size32;
    ULONG Size64;
    PFIELD_REC FieldList;
    BOOL SignExtend;
    BOOL Fabricated;
    BOOL Only64;
} TYPE_REC;

typedef struct _FIELD_REC {
    PFIELD_REC Next;
    PCHAR Name;
    PCHAR TypeName;
    PCHAR SizeFormula;
    ULONG TypeSize32;
    ULONG TypeSize64;
    ULONG Offset32;
    ULONG Offset64;
    ULONG Size32;
    ULONG Size64;
    PTYPE_REC TypeRec;
} FIELD_REC;

//
// Static TYPE_REC describing a 64-bit pointer type
//

TYPE_REC pointer64_typerec = {
    NULL,
    "POINTER64",
    4,
    8,
    NULL,
    TRUE,
    TRUE };

//
// Inline routine to generate a 32-bit pointer value from a ULONGLONG
// value found in an .obj file.
//

__inline
PVOID
CalcPtr(
    IN ULONGLONG Address
    )
{
    return (PVOID)((ULONG)Address);
}

//
// Forward declarations follow
// 

VOID
ApplyFixupsToImage(
    IN PCHAR ObjImage
    );

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *FormatString,
    ...
    );

VOID
FabricateMissingTypes(
    VOID
    );

PTYPE_REC
FindTypeRec(
    IN PCHAR Name
    );

PVOID
GetMem(
    IN ULONG Size
    );

VOID
NewGlobalType(
    IN PTYPE_REC TypeRec
    );

BOOL
ProcessStructure(
    IN ULONG StrucIndex
    );

void
ReadObj(
    IN PCHAR Path,
    OUT POBJ Obj
    );

int
Usage(
    void
    );

VOID
WriteCopyList(
    IN PTYPE_REC TypeRec
    );

VOID
WriteCopyListWorker(
    IN PTYPE_REC TypeRec,
    IN ULONG Offset32,
    IN ULONG Offset64,
    IN PCHAR ParentName
    );

VOID
WriteCopyRoutine(
    IN PTYPE_REC TypeRec
    );

VOID
WriteThunkSource(
    VOID
    );

//
// Global data follows.  
// 

OBJ Obj32;
OBJ Obj64;
PTYPE_REC TypeRecList = NULL;

int
__cdecl
main(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    This is the main entrypoint of bldrthnk.exe.  Two command-line arguments
    are expected: first the path to the 32-bit .obj module, the second to
    the path to the 64-bit .obj module.  The .objs are expected to be the
    result of compiling m4-generated structure definition code.

Arguments:

Return value:

    0 for success, non-zero otherwise.

--*/

{
    ULONG strucIndex;

    //
    // argv[1] is the name of the 32-bit obj, argv[2] is the name of the
    // 64-bit obj
    // 

    if (argc != 3) {
        return Usage();
    }

    //
    // Usage:
    //
    // bldrthnk <32-bit.obj> <64-bit.obj>
    //

    ReadObj( argv[1], &Obj32 );
    ReadObj( argv[2], &Obj64 );

    //
    // Process each STRUC_DEF structure
    //

    strucIndex = 0;
    while (ProcessStructure( strucIndex )) {
        strucIndex += 1;
    }

    FabricateMissingTypes();

    //
    // Write out the file
    //

    WriteThunkSource();

    return 0;
}

int
Usage(
    VOID
    )

/*++

Routine Description:

    Displays program usage.

Arguments:

Return value:

--*/

{
    fprintf(stderr, "Usage: bldrthnk.exe <32-bit obj> <64-bit obj>\n");
    return -1;
}

void
ReadObj(
    IN PCHAR Path,
    OUT POBJ Obj
    )

/*++

Routine Description:

    Allocates an appropriate buffer, and reads into it the supplied object
    image in its entirety.

Arguments:

    Path - Supplies the path of the object image to process.

    Obj - Supplies a pointer to an OBJ structure which upon return will
        updated with the appropriate data.

Return value:

    None.

--*/

{
    FILE *objFile;
    int result;
    long objImageSize;
    PCHAR objImage;
    PULONG sigPtr;
    PULONG srchEnd;
    PDEFINITIONS definitions;
    LONGLONG imageBias;

    //
    // Open the file
    //

    objFile = fopen( Path, "rb" );
    CheckCondition( objFile != NULL,
                    "Cannot open %s for reading.\n",
                    Path );

    //
    // Get the file size, allocate a buffer, read it in, and close.
    //

    result = fseek( objFile, 0, SEEK_END );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    objImageSize = ftell( objFile );
    CheckCondition( objImageSize != -1L,
                    "ftell() failed, error %d\n",
                    errno );

    CheckCondition( objImageSize > 0,
                    "%s appears to be corrupt\n",
                    Path );

    objImage = GetMem( objImageSize );

    result = fseek( objFile, 0, SEEK_SET );
    CheckCondition( result == 0,
                    "fseek() failed, error %d\n",
                    errno );

    result = fread( objImage, 1, objImageSize, objFile );
    CheckCondition( result == objImageSize,
                    "Error reading from %s\n",
                    Path );

    fclose( objFile );

    //
    // Find the start of the "definitions" array by looking for
    // SIG_1 followed by SIG_2
    //

    srchEnd = (PULONG)(objImage + objImageSize - 2 * sizeof(SIG_1));
    sigPtr = (PULONG)objImage;
    definitions = NULL;

    while (sigPtr < srchEnd) {

        if (sigPtr[0] == SIG_1 && sigPtr[1] == SIG_2) {
            definitions = (PDEFINITIONS)sigPtr;
            break;
        }

        sigPtr = (PULONG)((PCHAR)sigPtr + 1);
    }
    CheckCondition( definitions != NULL,
                    "Error: could not find signature in %s\n",
                    Path );

    //
    // Perform fixups on the image
    //

    ApplyFixupsToImage( objImage );

    //
    // Fill in the output structure and return
    // 

    Obj->Image = objImage;
    Obj->ImageSize = objImageSize;
    Obj->Definitions = definitions;
}

VOID
__cdecl
CheckCondition(
    int Condition,
    const char *FormatString,
    ...
    )

/*++

Routine Description:

    Asserts that Condition is non-zero.  If Condition is zero, FormatString
    is processed and displayed, and the program is terminated.

Arguments:

    Condition - Supplies the boolean value to evaluate.

    FormatString, ... - Supplies the format string and optional parameters
        to display in the event of a zero Condition.

Return value:

    None.

--*/

{
    va_list(arglist);

    va_start(arglist, FormatString);

    if( Condition == 0 ){

        //
        // A fatal error was encountered.  Bail.
        //

        vprintf( FormatString, arglist );
        perror( "genxx" );
        exit(-1);
    }
}

BOOL
ProcessStructure(
    IN ULONG StrucIndex
    )

/*++

Routine Description:

    Processes a single pair of structure definitions, 32-bit and 64-bit,
    respectively.

    Processing includes generating a TYPE_REC and associated FIELD_RECs for
    the definition pair.

Arguments:

    StrucIndex - Supplies the index into the array of STRUC_DEF structures
        found within each of the object images.

Return value:

    TRUE if the processing was successful, FALSE otherwise (e.g. a terminating
    record was located).

--*/

{
    PSTRUC_DEF Struc32, Struc64;
    PFIELD_DEF Field32, Field64;

    ULONG strLen;
    ULONG strLen2;
    ULONG strLen3;
    PTYPE_REC typeRec;
    PFIELD_REC fieldRec;
    PFIELD_REC insertNode;
    BOOL only64;

    ULONG index;

    Struc32 = CalcPtr( Obj32.Definitions->Structures[ StrucIndex ] );
    Struc64 = CalcPtr( Obj64.Definitions->Structures[ StrucIndex ] );

    if (Struc64 == NULL) {
        return FALSE;
    }

    if (Struc32 == NULL) {
        only64 = TRUE;
    } else {
        only64 = FALSE;
    }

    CheckCondition( Struc64 != NULL &&
                    ((only64 != FALSE) ||
                     strcmp( Struc32->Name, Struc64->Name ) == 0),
                    "Mismatched structure definitions found.\n" );

    //
    // Allocate and build a TYPE_REC for this STRUC_DEF
    //

    strLen = strlen( Struc64->Name ) + sizeof(char);
    typeRec = GetMem( sizeof(TYPE_REC) + strLen );
    typeRec->Name = (PCHAR)(typeRec + 1);
    typeRec->Only64 = only64;

    memcpy( typeRec->Name, Struc64->Name, strLen );

    if (only64 == FALSE) {
        typeRec->Size32 = Struc32->Size;
    }

    typeRec->Size64 = Struc64->Size;
    typeRec->FieldList = NULL;
    typeRec->SignExtend = FALSE;
    typeRec->Fabricated = FALSE;

    //
    // Create the FIELD_RECs hanging off of this type
    //

    index = 0;
    while (TRUE) {

        if (only64 == FALSE) {
            Field32 = CalcPtr( Struc32->Fields[index] );
        }

        Field64 = CalcPtr( Struc64->Fields[index] );

        if (Field64 == NULL) {
            break;
        }

        if (only64 == FALSE) {
            CheckCondition( strcmp( Field32->Name, Field64->Name ) == 0 &&
                            strcmp( Field32->TypeName, Field64->TypeName ) == 0,
                            "Mismatched structure definitions found.\n" );
        }

        strLen = strlen( Field64->Name ) + sizeof(CHAR);
        strLen2 = strlen( Field64->TypeName ) + sizeof(CHAR);
        strLen3 = strlen( Field64->SizeFormula );
        if (strLen3 > 0) {
            strLen3 += sizeof(CHAR);
        }

        fieldRec = GetMem( sizeof(FIELD_REC) + strLen + strLen2 + strLen3 );
        fieldRec->Name = (PCHAR)(fieldRec + 1);
        fieldRec->TypeName = fieldRec->Name + strLen;

        memcpy( fieldRec->Name, Field64->Name, strLen );
        memcpy( fieldRec->TypeName, Field64->TypeName, strLen2 );

        if (strLen3 > 0) {
            fieldRec->SizeFormula = fieldRec->TypeName + strLen2;
            memcpy( fieldRec->SizeFormula, Field64->SizeFormula, strLen3 );
        } else {
            fieldRec->SizeFormula = NULL;
        }

        if (only64 == FALSE) {
            fieldRec->Offset32 = Field32->Offset;
            fieldRec->Size32 = Field32->Size;
            fieldRec->TypeSize32 = Field32->TypeSize;
        }

        fieldRec->Offset64 = Field64->Offset;
        fieldRec->TypeSize64 = Field64->TypeSize;
        fieldRec->Size64 = Field64->Size;

        fieldRec->Next = NULL;
        fieldRec->TypeRec = NULL;

        //
        // Insert at the end of the list
        //

        insertNode = CONTAINING_RECORD( &typeRec->FieldList,
                                        FIELD_REC,
                                        Next );
        while (insertNode->Next != NULL) {
            insertNode = insertNode->Next;
        }
        insertNode->Next = fieldRec;

        index += 1;
    }

    //
    // Insert it into the global list
    //

    CheckCondition( FindTypeRec( typeRec->Name ) == NULL,
                    "Duplicate definition for structure %s\n",
                    typeRec->Name );

    NewGlobalType( typeRec );

    return TRUE;
}

PTYPE_REC
FindTypeRec(
    IN PCHAR Name
    )

/*++

Routine Description:

    Searches the global list of TYPE_REC structures for one with a name
    that matches the supplied name.

Arguments:

    Name - pointer to a null-terminated string representing the name of
        the sought type.

Return value:

    A pointer to the matching TYPE_REC, or NULL if a match was not found.

--*/

{
    PTYPE_REC typeRec;

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        if (strcmp( Name, typeRec->Name ) == 0) {
            return typeRec;
        }

        typeRec = typeRec->Next;
    }
    return NULL;
}

PVOID
GetMem(
    IN ULONG Size
    )

/*++

Routine Description:

    Memory allocator.  Works just like malloc() except that triggers a
    fatal error in the event of an out-of-memory condition.

Arguments:

    Size - number of bytes to allocate.

Return value:

    Returns a pointer to a block of memory of the specified size.

--*/

{
    PVOID mem;

    mem = malloc( Size );
    CheckCondition( mem != NULL,
                    "Out of memory.\n" );

    return mem;
}

VOID
FabricateMissingTypes(
    VOID
    )

/*++

Routine Description:

    Routine to generate TYPE_REC records for simple types referenced, but
    not defined, by a structure layout file.

Arguments:

    None.

Return value:

    None.

--*/

{
    PTYPE_REC typeRec;
    PTYPE_REC fieldTypeRec;
    PFIELD_REC fieldRec;
    PCHAR fieldTypeName;
    ULONG strLen;

    typeRec = TypeRecList;
    while (typeRec != NULL) {

        fieldRec = typeRec->FieldList;
        while (fieldRec != NULL) {

            fieldTypeRec = FindTypeRec( fieldRec->TypeName );
            if (fieldTypeRec == NULL) {

                if (typeRec->Only64 == FALSE) {
                    CheckCondition( (fieldRec->Size32 == fieldRec->Size64) ||
    
                                    ((fieldRec->Size32 == 1 ||
                                      fieldRec->Size32 == 2 ||
                                      fieldRec->Size32 == 4 ||
                                      fieldRec->Size32 == 8) &&
                                     (fieldRec->Size64 > fieldRec->Size32) &&
                                     (fieldRec->Size64 % fieldRec->Size32 == 0)),
    
                                    "Must specify type %s (%s)\n",
                                    fieldRec->TypeName,
                                    typeRec->Name );
                }

                //
                // No typerec exists for this type.  Assume it is a simple
                // type.
                //

                if ((typeRec->Only64 != FALSE &&
                     fieldRec->Size64 == sizeof(ULONGLONG) &&
                     *fieldRec->TypeName == 'P') ||

                    (fieldRec->Size32 == sizeof(PVOID) &&
                     fieldRec->Size64 == sizeof(ULONGLONG))) {

                    //
                    // Either a pointer or [U]LONG_PTR type.  Make
                    // it longlong.
                    //

                    fieldTypeRec = &pointer64_typerec;

                } else {

                    //
                    // Some other type.
                    // 

                    strLen = strlen( fieldRec->TypeName ) + sizeof(CHAR);
                    fieldTypeRec = GetMem( sizeof(TYPE_REC) + strLen );
                    fieldTypeRec->Name = (PCHAR)(fieldTypeRec + 1);
                    memcpy( fieldTypeRec->Name, fieldRec->TypeName, strLen );
                    fieldTypeRec->Size32 = fieldRec->Size32;
                    fieldTypeRec->Size64 = fieldRec->Size64;
                    fieldTypeRec->FieldList = NULL;
                    fieldTypeRec->SignExtend = TRUE;
                    fieldTypeRec->Fabricated = TRUE;

                    NewGlobalType( fieldTypeRec );
                }

            }
            fieldRec->TypeRec = fieldTypeRec;
            fieldRec = fieldRec->Next;
        }
        typeRec = typeRec->Next;
    }
}

VOID
WriteCopyRecord(
    IN ULONG Offset32,
    IN ULONG Offset64,
    IN PCHAR TypeName,
    IN ULONG Size32,
    IN ULONG Size64,
    IN BOOL SignExtend,
    IN PCHAR FieldName,
    IN BOOL Last
    )

/*++

Routine Description:

    Support routine to generate the text of a copy record.

Arguments:

    Offset32 - Offset of this field within a 32-bit structure layout

    Offset64 - Offset of this field within a 64-bit structure layout

    Size32 - Size of this field within a 32-bit structure layout

    Size64 - Size of this field within a 64-bit structure layout

    SignExtend - Indicates whether this type should be sign extended or not

    FieldName - Name of the field

    Last - Whether this is the last copy record in a zero-terminated list

Return value:

    None

--*/

{
    CHAR buf[ 255 ];

    buf[sizeof(buf) - 1] = 0;
    if (SignExtend) {
        _snprintf(buf, sizeof(buf) - 1, "IS_SIGNED_TYPE(%s)", TypeName);
    } else {
        _snprintf(buf, sizeof(buf) - 1, "FALSE");
    }

    printf("    { \t0x%x, \t0x%x, \t0x%x, \t0x%x, \t%5s }%s\n",
           Offset32,
           Offset64,
           Size32,
           Size64,
           buf,
           Last ? "" : "," );
}

VOID
WriteDefinition64(
    IN PTYPE_REC TypeRec
    )

/*++

Routine Description:

    Generates a structure definition that represents, to a 32-bit compiler,
    the layout of a 64-bit structure.

Arguments:

    TypeRec - Pointer to the TYPE_REC structure defining this type.

Return value:

    None.

--*/

{
    PFIELD_REC fieldRec;
    ULONG currentOffset;
    PTYPE_REC fieldTypeRec;
    ULONG padBytes;
    ULONG reservedCount;

    currentOffset = 0;
    reservedCount = 0;

    printf("typedef struct _%s_64 {\n", TypeRec->Name );

    fieldRec = TypeRec->FieldList;
    while (fieldRec != NULL) {

        fieldTypeRec = fieldRec->TypeRec;
        padBytes = fieldRec->Offset64 - currentOffset;
        if (padBytes > 0) {

            printf("    UCHAR Reserved%d[ 0x%x ];\n",
                   reservedCount,
                   padBytes );

            currentOffset += padBytes;
            reservedCount += 1;
        }

        printf("    %s%s %s",
            fieldTypeRec->Name,
            fieldTypeRec->Fabricated ? "" : "_64",
            fieldRec->Name );

        if (fieldRec->Size64 > fieldRec->TypeSize64) {

            CheckCondition( fieldRec->Size64 % fieldRec->TypeSize64 == 0,
                            "Internal error type %s.%s\n",
                            TypeRec->Name, fieldRec->Name );

            //
            // This field must be an array
            //

            printf("[%d]", fieldRec->Size64 / fieldRec->TypeSize64);
        }

        printf(";\n");

        currentOffset += fieldRec->Size64;

        fieldRec = fieldRec->Next;
    }

    padBytes = TypeRec->Size64 - currentOffset;
    if (padBytes > 0) {

        printf("    UCHAR Reserved%d[ 0x%x ];\n", reservedCount, padBytes );
        currentOffset += padBytes;
        reservedCount += 1;
    }

    printf("} %s_64, *P%s_64;\n\n", TypeRec->Name, TypeRec->Name );

    fieldRec = TypeRec->FieldList;
    while (fieldRec