

    LOGICAL - TRUE: There is space for cached references in the object,
              FALSE: No space was available.

--*/
{
    return FastRef.RefCnt != MAX_FAST_REFS;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefIsLastReference (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to determine if the fast reference
    structure contains only 1 cached reference.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    LOGICAL - TRUE: There is only one cached reference in the object,
              FALSE: The is more or less than one cached reference available.

--*/
{
    return FastRef.RefCnt == 1;
}


NTKERNELAPI
PVOID
FORCEINLINE
ExFastRefGetObject (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to obtain the object pointer from a fast
    reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    PVOID - The contained object or NULL if there isn't one.

--*/
{
    return (PVOID) (FastRef.Value & ~MAX_FAST_REFS);
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExFastRefObjectNull (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to test of the specified fastref value
    has a null pointer

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    BOOLEAN - TRUE if the object is NULL FALSE otherwise

--*/
{
    return (BOOLEAN) (FastRef.Value == 0);
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExFastRefEqualObjects (
    IN EX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine allows the caller to test of the specified fastref contains
    the specified object

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    BOOLEAN - TRUE if the object matches FALSE otherwise

--*/
{
    return (BOOLEAN)((FastRef.Value^(ULONG_PTR)Object) <= MAX_FAST_REFS);
}


NTKERNELAPI
ULONG
FORCEINLINE
ExFastRefGetUnusedReferences (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to obtain the number of cached refrences
    in the fast reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    ULONG - The number of cached references.

--*/
{
    return (ULONG) FastRef.RefCnt;
}


NTKERNELAPI
VOID
FORCEINLINE
ExFastRefInitialize (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object OPTIONAL
    )
/*++

Routine Description:

    This routine initializes fast reference structure.

Arguments:

    FastRef - Fast reference block to be used
    Object  - Object pointer to be assigned to the fast reference

Return Value:

    None.

--*/
{
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    if (Object == NULL) {
       FastRef->Object = NULL;
    } else {
       FastRef->Value = (ULONG_PTR) Object | MAX_FAST_REFS;
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExFastRefInitializeEx (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object OPTIONAL,
    IN ULONG AdditionalRefs
    )
/*++

Routine Description:

    This routine initializes fast reference structure with the specified additional references.

Arguments:

    FastRef       - Fast reference block to be used
    Object        - Object pointer to be assigned to the fast reference
    AditionalRefs - Number of additional refs to add to the object

Return Value:

    None

--*/
{
    ASSERT (AdditionalRefs <= MAX_FAST_REFS);
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    if (Object == NULL) {
       FastRef->Object = NULL;
    } else {
       FastRef->Value = (ULONG_PTR) Object + AdditionalRefs;
    }
}

NTKERNELAPI
ULONG
FORCEINLINE
ExFastRefGetAdditionalReferenceCount (
    VOID
    )
{
    return MAX_FAST_REFS;
}



NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastReference (
    IN PEX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine attempts to obtain a fast (cached) reference from a fast
    reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    EX_FAST_REF - The old or current contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;
        //
        // If the object pointer is null or if there are no cached references
        // left then bail. In the second case this reference will need to be
        // taken while holding the lock. Both cases are covered by the single
        // test of the lower bits since a null pointer can never have cached
        // refs.
        //
        if (OldRef.RefCnt != 0) {
            //
            // We know the bottom bits can't underflow into the pointer for a
            // request that works so just decrement
            //
            NewRef.Value = OldRef.Value - 1;
            NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                               NewRef.Object,
                                                               OldRef.Object);
            if (NewRef.Object != OldRef.Object) {
                //
                // The structured changed beneath us. Try the operation again
                //
                continue;
            }
        }
        break;
    }

    return OldRef;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefDereference (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine attempts to release a fast reference from a fast ref
    structure. This routine could be called for a reference obtained
    directly from the object but preumably the chances of the pointer
    matching would be unlikely. The algorithm will work correctly in this
    case.

Arguments:

    FastRef - Fast reference block to be used

    Object - The original object that the reference was taken on.

Return Value:

    LOGICAL - TRUE: The fast dereference worked ok, FALSE: the
              dereference didn't.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    ASSERT (Object != NULL);

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // If the reference cache is fully populated or the pointer has
        // changed to another object then just return the old value. The
        // caller can return the reference to the object instead.
        //
        if ((OldRef.Value^(ULONG_PTR)Object) >= MAX_FAST_REFS) {
            return FALSE;
        }
        //
        // We know the bottom bits can't overflow into the pointer so just
        // increment
        //
        NewRef.Value = OldRef.Value + 1;
        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Try the operation again
            //
            continue;
        }
        break;
    }
    return TRUE;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefAddAdditionalReferenceCounts (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object,
    IN ULONG RefsToAdd
    )
/*++

Routine Description:

    This routine attempts to update the cached references on structure to
    allow future callers to run lock free. Callers must have already biased
    the object by the RefsToAdd reference count. This operation can fail at
    which point the caller should removed the extra references added and
    continue.

Arguments:

    FastRef - Fast reference block to be used

    Object - The original object that has had its reference count biased.

    RefsToAdd - The number of references to add to the cache

Return Value:

    LOGICAL - TRUE: The references where cached ok, FALSE: The references
              could not be cached.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    ASSERT (RefsToAdd <= MAX_FAST_REFS);
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // If the count would push us above maximum cached references or
        // if the object pointer has changed the fail the request.
        //
        if (OldRef.RefCnt + RefsToAdd > MAX_FAST_REFS ||
            (ULONG_PTR) Object != (OldRef.Value & ~MAX_FAST_REFS)) {
            return FALSE;
        }
        //
        // We know the bottom bits can't overflow into the pointer so just
        // increment
        //
        NewRef.Value = OldRef.Value + RefsToAdd;
        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Use the return value from the
            // exchange and try it all again.
            //
            continue;
        }
        break;
    }
    return TRUE;
}

NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastRefSwapObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine attempts to replace the current object with a new object.
    This routine must be called while holding the lock that protects the
    pointer field if concurrency with the slow ref path is possible.
    Its also possible to obtain and drop the lock after this operation has
    completed to force all the slow referencers from the slow reference path.

Arguments:

    FastRef - Fast reference block to be used

    Object - The new object that is to be placed in the structure. This
             object must have already had its reference count biased by
             the caller to account for the reference cache.

Return Value:

    EX_FAST_REF - The old contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef;
    EX_FAST_REF NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    if (Object != NULL) {
        NewRef.Value = (ULONG_PTR) Object | MAX_FAST_REFS;
    } else {
        NewRef.Value = 0;
    }
    OldRef.Object = InterlockedExchangePointer (&FastRef->Object, NewRef.Object);
    return OldRef;
}

NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastRefCompareSwapObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object,
    IN PVOID OldObject
    )
/*++

Routine Description:

    This routine attempts to replace the current object with a new object if
    the current object matches the old object.
    This routine must be called while holding the lock that protects the
    pointer field if concurrency with the slow ref path is possible.
    Its also possible to obtain and drop the lock after this operation has
    completed to force all the slow referencers from the slow reference path.

Arguments:

    FastRef - Fast reference block to be used

    Object - The new object that is to be placed in the structure. This
             object must have already had its reference count biased by
             the caller to account for the reference cache.

    OldObject - The object that must match the current object for the
                swap to occure.

Return Value:

    EX_FAST_REF - The old contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef;
    EX_FAST_REF NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // Compare the current object to the old to see if a swap is possible.
        //
        if (!ExFastRefEqualObjects (OldRef, OldObject)) {
            return OldRef;
        }

        if (Object != NULL) {
            NewRef.Value = (ULONG_PTR) Object | MAX_FAST_REFS;
        } else {
            NewRef.Value = (ULONG_PTR) Object;
        }

        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Try it all again.
            //
            continue;
        }
        break;
    }
    return OldRef;
}

// begin_ntosp

#if !defined(NONTOSPINTERLOCK)

VOID
FORCEINLINE
ExInitializePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Initialize a push lock structure

Arguments:

    PushLock - Push lock to be initialized

Return Value:

    None

--*/
{
    PushLock->Value = 0;
}

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     );

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     );

NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     );

// end_ntosp

NTKERNELAPI
VOID
FORCEINLINE
ExAcquireReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively and immediately release it

Arguments:

    PushLock - Push lock to be acquired and released

Return Value:

    None

--*/
{
    PVOID Ptr;

    KeMemoryBarrier ();
    Ptr = PushLock->Ptr;
    KeMemoryBarrier ();

    if (Ptr != NULL) {
        ExfAcquirePushLockExclusive (PushLock);
        ExfReleasePushLock (PushLock);
    }
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExTryAcquireReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Try to acquire a push lock exclusively and immediately release it

Arguments:

    PushLock - Push lock to be acquired and released

Return Value:

    BOOLEAN - TRUE: The lock was acquired, FALSE: The lock was not acquired

--*/
{
    PVOID Ptr;

    KeMemoryBarrier ();
    Ptr = PushLock->Ptr;
    KeMemoryBarrier ();

    if (Ptr == NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

// begin_ntosp

VOID
FORCEINLINE
ExAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
                                           NULL) != NULL) {
        ExfAcquirePushLockExclusive (PushLock);
    }
}

BOOLEAN
FORCEINLINE
ExTryAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Try and acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Acquire was successfull, FALSE: Lock was already acquired

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
                                           NULL) == NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
FORCEINLINE
ExAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    OldValue.Value &= ~(EX_PUSH_LOCK_EXCLUSIVE | EX_PUSH_LOCK_WAITING);
    NewValue.Value = OldValue.Value + EX_PUSH_LOCK_SHARE_INC;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfAcquirePushLockShared (PushLock);
    }
}

VOID
FORCEINLINE
ExAcquirePushLockSharedAssumeNoOwner (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared making the assumption that its not currently owned.

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           (PVOID)EX_PUSH_LOCK_SHARE_INC,
                                           NULL) != NULL) {
        ExfAcquirePushLockShared (PushLock);
    }
}

BOOLEAN
FORCEINLINE
ExTryConvertPushLockSharedToExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Attempts to convert a shared acquire to exclusive. If other sharers or waiters are present
    the function fails.

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Conversion worked ok, FALSE: The conversion could not be achieved

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr, (PVOID) EX_PUSH_LOCK_EXCLUSIVE,
                                           (PVOID) EX_PUSH_LOCK_SHARE_INC) ==
                                               (PVOID)EX_PUSH_LOCK_SHARE_INC) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
FORCEINLINE
ExReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    OldValue.Value &= ~EX_PUSH_LOCK_WAITING;
    NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
                         ~EX_PUSH_LOCK_EXCLUSIVE;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfReleasePushLock (PushLock);
    }
}

VOID
FORCEINLINE
ExReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    ASSERT (PushLock->Value & (EX_PUSH_LOCK_WAITING|EX_PUSH_LOCK_EXCLUSIVE));

    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NULL,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE) != (PVOID)EX_PUSH_LOCK_EXCLUSIVE) {
        ExfReleasePushLock (PushLock);
    }
}

VOID
FORCEINLINE
ExReleasePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    ASSERT (OldValue.Waiting || !OldValue.Exclusive);
    OldValue.Value &= ~EX_PUSH_LOCK_WAITING;
    NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfReleasePushLock (PushLock);
    }
}

VOID
FORCEINLINE
ExReleasePushLockSharedAssumeSingleOwner (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired shared assuming that we are the only owner

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
#if DBG
    EX_PUSH_LOCK OldValue;

    OldValue = *PushLock;

    ASSERT (OldValue.Waiting || !OldValue.Exclusive);

#endif

    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NULL,
                                           (PVOID)EX_PUSH_LOCK_SHARE_INC) != (PVOID)EX_PUSH_LOCK_SHARE_INC) {
        ExfReleasePushLock (PushLock);
    }
}

//
// This is a block held on the local stack of the waiting threads.
//

typedef  struct _EX_PUSH_LOCK_WAIT_BLOCK *PEX_PUSH_LOCK_WAIT_BLOCK;

typedef struct _EX_PUSH_LOCK_WAIT_BLOCK {
    KEVENT WakeEvent;
    PEX_PUSH_LOCK_WAIT_BLOCK Next;
    PEX_PUSH_LOCK_WAIT_BLOCK Last;
    PEX_PUSH_LOCK_WAIT_BLOCK Previous;
    ULONG ShareCount;
    BOOLEAN Exclusive;
} EX_PUSH_LOCK_WAIT_BLOCK;

// end_ntosp

NTKERNELAPI
VOID
FASTCALL
ExBlockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     );

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     );

VOID
FORCEINLINE
ExUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
{
    KeMemoryBarrier ();
    if (WaitBlock != NULL || PushLock->Ptr != NULL) {
        ExfUnblockPushLock (PushLock, WaitBlock);
    }
}

// begin_ntosp

VOID
FORCEINLINE
ExWaitForUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
{
    UNREFERENCED_PARAMETER (PushLock);

    KeWaitForSingleObject (&WaitBlock->WakeEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}


NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     VOID
     );

NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     PEX_PUSH_LOCK_CACHE_AWARE PushLock
     );

NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     );

NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     );

PEX_PUSH_LOCK
FORCEINLINE
ExAcquireCacheAwarePushLockShared (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock shared.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK PushLock;
    //
    // Take a single one of the slots in shared mode.
    // Exclusive acquires must obtain all the slots exclusive.
    //
    PushLock = CacheAwarePushLock->Locks[KeGetCurrentProcessorNumber()%EX_PUSH_LOCK_FANNED_COUNT];
    ExAcquirePushLockSharedAssumeNoOwner (PushLock);
//    ExAcquirePushLockShared (PushLock);
    return PushLock;
}

VOID
FORCEINLINE
ExReleaseCacheAwarePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock shared.

Arguments:

    PushLock - Part of cache aware push lock returned by ExAcquireCacheAwarePushLockShared

Return Value:

    None

--*/
{
    ExReleasePushLockSharedAssumeSingleOwner (PushLock);
//    ExReleasePushLockShared (PushLock);
    return;
}

#endif // !defined(NONTOSPINTERLOCK)

// end_ntosp


//
// Define low overhead callbacks for thread create etc
//

// begin_wdm begin_ntddk

//
// Define a block to hold the actual routine registration.
//
typedef NTSTATUS (*PEX_CALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

// end_wdm end_ntddk

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF        RundownProtect;
    PEX_CALLBACK_FUNCTION Function;
    PVOID                 Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

//
// Define a structure the caller uses to hold the callbacks
//
typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

VOID
ExInitializeCallBack (
    IN OUT PEX_CALLBACK CallBack
    );

BOOLEAN
ExCompareExchangeCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK NewBlock,
    IN PEX_CALLBACK_ROUTINE_BLOCK OldBlock
    );

NTSTATUS
ExCallCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

PEX_CALLBACK_ROUTINE_BLOCK
ExAllocateCallBack (
    IN PEX_CALLBACK_FUNCTION Function,
    IN PVOID Context
    );

VOID
ExFreeCallBack (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

PEX_CALLBACK_ROUTINE_BLOCK
ExReferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack
    );

PEX_CALLBACK_FUNCTION
ExGetCallBackBlockRoutine (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

PVOID
ExGetCallBackBlockContext (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

VOID
ExDereferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

VOID
ExWaitForCallBacks (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

//
//  Hotpatch declarations
//

extern volatile LONG ExHotpSyncRenameSequence;

#endif /* _EX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\fastsys.inc ===
; /*
;
; Copyright (c) 1997 Microsoft Corporation
;
; Module Name:
;
;    fastsys.inc
;
; Abstract:
;
;    This module implements the header for Fast System Calls for Intel
;    x86 family processors.
;
; Author:
;
;    Bryan M. Willman (bryanwi) 09-Jan-1998
;
; Environment:
;
;    kernel mode.
;
; Revision History:
;
;   Peter Johnston (peterj) 07-May-1998
;       Add support for AMD implementation.
;
;--

if 0  ; Begin C only code   */

// CPUID Feature bit in EDX indicating that fast system calls are supported

#define KI_FAST_SYSCALL_SUPPORTED   0x0800

#define MSR_SYSENTER_CS             0x00000174
#define MSR_SYSENTER_ESP            0x00000175
#define MSR_SYSENTER_EIP            0x00000176

#define MSR_EXT_FEATURE_ENABLE      0xC0000080
#define MSR_SYSCALL_TARGET_ADDR     0xC0000081

//
// Define bits in the Extended Feature Enable Register (EFER) (MSR).
//

#define MSR_EFER_SCE                0x1

/*
endif
;
;  Begin Assembly definitions
;


iSYSENTER macro
    db 0fH,34H
endm ;; SYSENTER

iSYSEXIT macro
    db 0fH,35H
endm ;; SYSEXIT

iSYSCALL macro
    db 0fH,05H
endm ;; SYSCALL

iSYSRET macro
    db 0fH,07H
endm ;; SYSRET

; */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\halalpha.h ===
#if defined(_AXP64_)
#include "halpaxp64.h"
#else
#include "halpalpha.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\hal.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hal.h

Abstract:

    This header file defines the Hardware Architecture Layer (HAL) interfaces
    that are exported by a system vendor to the NT system.

Author:

    David N. Cutler (davec) 25-Apr-1991


Revision History:

--*/

// begin_nthal

#ifndef _HAL_
#define _HAL_

// begin_ntosp

//
// Define OEM bitmapped font check values.
//

#define OEM_FONT_VERSION 0x200
#define OEM_FONT_TYPE 0
#define OEM_FONT_ITALIC 0
#define OEM_FONT_UNDERLINE 0
#define OEM_FONT_STRIKEOUT 0
#define OEM_FONT_CHARACTER_SET 255
#define OEM_FONT_FAMILY (3 << 4)

//
// Define OEM bitmapped font file header structure.
//
// N.B. this is a packed structure.
//

#include "pshpack1.h"
typedef struct _OEM_FONT_FILE_HEADER {
    USHORT Version;
    ULONG FileSize;
    UCHAR Copyright[60];
    USHORT Type;
    USHORT Points;
    USHORT VerticleResolution;
    USHORT HorizontalResolution;
    USHORT Ascent;
    USHORT InternalLeading;
    USHORT ExternalLeading;
    UCHAR Italic;
    UCHAR Underline;
    UCHAR StrikeOut;
    USHORT Weight;
    UCHAR CharacterSet;
    USHORT PixelWidth;
    USHORT PixelHeight;
    UCHAR Family;
    USHORT AverageWidth;
    USHORT MaximumWidth;
    UCHAR FirstCharacter;
    UCHAR LastCharacter;
    UCHAR DefaultCharacter;
    UCHAR BreakCharacter;
    USHORT WidthInBytes;
    ULONG Device;
    ULONG Face;
    ULONG BitsPointer;
    ULONG BitsOffset;
    UCHAR Filler;
    struct {
        USHORT Width;
        USHORT Offset;
    } Map[1];
} OEM_FONT_FILE_HEADER, *POEM_FONT_FILE_HEADER;
#include "poppack.h"


// end_ntosp

// begin_ntddk begin_wdm begin_ntosp
//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG BusNumber; // unused for WDM
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1
#define DEVICE_DESCRIPTION_VERSION2 2

// end_ntddk end_wdm

//
// Boot record disk partition table entry structure format.
//

typedef struct _PARTITION_DESCRIPTOR {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    UCHAR StartingCylinderLsb;      // Not used
    UCHAR StartingCylinderMsb;      // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    UCHAR EndingCylinderLsb;        // Not used
    UCHAR EndingCylinderMsb;        // Not used
    UCHAR StartingSectorLsb0;       // Hidden sectors
    UCHAR StartingSectorLsb1;
    UCHAR StartingSectorMsb0;
    UCHAR StartingSectorMsb1;
    UCHAR PartitionLengthLsb0;      // Sectors in this partition
    UCHAR PartitionLengthLsb1;
    UCHAR PartitionLengthMsb0;
    UCHAR PartitionLengthMsb1;
} PARTITION_DESCRIPTOR, *PPARTITION_DESCRIPTOR;

//
// Number of partition table entries
//

#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Initial size of the Partition list structure.
//

#define PARTITION_BUFFER_SIZE          2048

//
// Partition active flag - i.e., boot indicator
//

#define PARTITION_ACTIVE_FLAG          0x80

// end_ntosp


// begin_ntddk
//
// The following function prototypes are for HAL routines with a prefix of Hal.
//
// General functions.
//

typedef
BOOLEAN
(*PHAL_RESET_DISPLAY_PARAMETERS) (
    IN ULONG Columns,
    IN ULONG Rows
    );

DECLSPEC_DEPRECATED_DDK
NTHALAPI
VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    );

// end_ntddk

NTHALAPI
VOID
HalDisplayString (
    PUCHAR String
    );

NTHALAPI
VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    );

NTHALAPI
VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    );

NTHALAPI
BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTHALAPI
VOID
HalProcessorIdle(
    VOID
    );

NTHALAPI
VOID
HalReportResourceUsage (
    VOID
    );

NTHALAPI
ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    );

// begin_ntosp
//
// Get and set environment variable values.
//

NTHALAPI
ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    );

NTHALAPI
ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    );

NTHALAPI
NTSTATUS
HalGetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );

NTSTATUS
HalSetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );

NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

// end_ntosp

//
// Cache and write buffer flush functions.
//
//

#if defined(_IA64_)                             // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp

NTHALAPI
VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    );

NTHALAPI
VOID
HalFlushDcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

// begin_ntosp
NTHALAPI
VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// begin_ntddk begin_ntifs begin_ntndis
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );

// end_ntosp end_ntddk end_ntifs end_ntndis
NTHALAPI
VOID
HalPurgeDcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

NTHALAPI
VOID
HalPurgeIcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

NTHALAPI
VOID
HalSweepDcache (
    VOID
    );

NTHALAPI
VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

NTHALAPI
VOID
HalSweepIcache (
    VOID
    );

NTHALAPI
VOID
HalSweepIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );


NTHALAPI
VOID
HalZeroPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN PFN_NUMBER PageFrame
    );

#endif                                          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
#if defined(_M_IX86) || defined(_M_AMD64)       // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
#define HalGetDmaAlignmentRequirement() 1L      // ntddk ntifs ntndis ntosp

NTHALAPI
VOID
HalHandleNMI (
    IN OUT PVOID NmiInformation
    );

#if defined(_AMD64_)

NTHALAPI
VOID
HalHandleMcheck (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

#endif

//
// The following are temporary.
//

#if defined(_M_AMD64)

NTHALAPI
KIRQL
HalSwapIrql (
    IN KIRQL Irql
    );

NTHALAPI
KIRQL
HalGetCurrentIrql (
    VOID
    );

#endif

#endif                                          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs wdm ntndis

#if defined(_M_IA64)

NTHALAPI
VOID
HalSweepCacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );


NTHALAPI
LONGLONG
HalCallPal (
    IN  ULONGLONG  FunctionIndex,
    IN  ULONGLONG  Arguement1,
    IN  ULONGLONG  Arguement2,
    IN  ULONGLONG  Arguement3,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    );

#endif

// begin_ntosp

NTHALAPI                                        // ntddk ntifs wdm ntndis
VOID                                            // ntddk ntifs wdm ntndis
KeFlushWriteBuffer (                            // ntddk ntifs wdm ntndis
    VOID                                        // ntddk ntifs wdm ntndis
    );                                          // ntddk ntifs wdm ntndis
                                                // ntddk ntifs wdm ntndis


#if defined(_ALPHA_)

NTHALAPI
PVOID
HalCreateQva(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN PVOID VirtualAddress
    );

NTHALAPI
PVOID
HalDereferenceQva(
    PVOID Qva,
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber
    );

#endif


#if !defined(_X86_)

NTHALAPI
BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    );

#endif
// end_ntosp

//
// Profiling functions.
//

NTHALAPI
VOID
HalCalibratePerformanceCounter (
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

NTHALAPI
ULONG_PTR
HalSetProfileInterval (
    IN ULONG_PTR Interval
    );


NTHALAPI
VOID
HalStartProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    );

NTHALAPI
VOID
HalStopProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    );

//
// Timer and interrupt functions.
//

// begin_ntosp
NTHALAPI
BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    );
// end_ntosp

NTHALAPI
BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    );

#if defined(_M_IX86) || defined(_M_AMD64)

NTHALAPI
VOID
FASTCALL
HalRequestSoftwareInterrupt (
    KIRQL RequestIrql
    );

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
   IN ULONG Vector,
   OUT PKINTERRUPT_ROUTINE **FlatDispatch,
   OUT PKINTERRUPT_ROUTINE *NoConnection
   );

#endif

// begin_ntosp
//
// Firmware interface functions.
//

NTHALAPI
VOID
HalReturnToFirmware (
    IN FIRMWARE_REENTRY Routine
    );

//
// System interrupts functions.
//

NTHALAPI
VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    );

NTHALAPI
BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    );

// begin_ntddk
//
// I/O driver configuration functions.
//
#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//

NTHALAPI
PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN OUT PULONG NumberOfMapRegisters
    );

#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoGetDmaAdapter
NTHALAPI
PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

// end_ntddk end_ntosp

#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );
#endif // NO_LEGACY_DRIVERS

// begin_ntddk begin_ntosp
//
// System beep functions.
//
#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK
NTHALAPI
BOOLEAN
HalMakeBeep(
    IN ULONG Frequency
    );
#endif // NO_LEGACY_DRIVERS

//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//

// end_ntddk end_ntosp

//
// Multi-Processorfunctions.
//

NTHALAPI
BOOLEAN
HalAllProcessorsStarted (
    VOID
    );

NTHALAPI
VOID
HalInitializeProcessor (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTHALAPI
BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    );

NTHALAPI
VOID
HalRequestIpi (
    IN KAFFINITY Mask
    );

//
// The following function prototypes are for HAL routines with a prefix of Kd.
//
// Kernel debugger port functions.
//

NTHALAPI
BOOLEAN
KdPortInitialize (
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    );

NTHALAPI
ULONG
KdPortGetByte (
    OUT PUCHAR Input
    );

NTHALAPI
ULONG
KdPortPollByte (
    OUT PUCHAR Input
    );

NTHALAPI
VOID
KdPortPutByte (
    IN UCHAR Output
    );

NTHALAPI
VOID
KdPortRestore (
    VOID
    );

NTHALAPI
VOID
KdPortSave (
    VOID
    );

//
// The following function prototypes are for HAL routines with a prefix of Ke.
//
// begin_ntddk begin_ntifs begin_wdm begin_ntosp
//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

// begin_ntndis
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

// end_ntddk end_ntifs end_wdm end_ntndis end_ntosp


//*****************************************************************************
//
//  HAL BUS EXTENDERS

//
// Bus handlers
//

// begin_ntddk

typedef
VOID
(*PDEVICE_CONTROL_COMPLETION)(
    IN struct _DEVICE_CONTROL_CONTEXT     *ControlContext
    );

typedef struct _DEVICE_CONTROL_CONTEXT {
    NTSTATUS                Status;
    PDEVICE_HANDLER_OBJECT  DeviceHandler;
    PDEVICE_OBJECT          DeviceObject;
    ULONG                   ControlCode;
    PVOID                   Buffer;
    PULONG                  BufferLength;
    PVOID                   Context;
} DEVICE_CONTROL_CONTEXT, *PDEVICE_CONTROL_CONTEXT;

// end_ntddk

typedef struct _HAL_DEVICE_CONTROL {
    //
    // Handler this DeviceControl is for
    //
    struct _BUS_HANDLER         *Handler;
    struct _BUS_HANDLER         *RootHandler;

    //
    // Bus specific storage for this Context
    //
    PVOID                       BusExtensionData;

    //
    // Reserved for HALs use
    //
    ULONG                       HalReserved[4];

    //
    // Reserved for BusExtneder use
    //
    ULONG                       BusExtenderReserved[4];

    //
    // DeviceControl Context and the CompletionRoutine
    //
    PDEVICE_CONTROL_COMPLETION  CompletionRoutine;
    DEVICE_CONTROL_CONTEXT      DeviceControl;

} HAL_DEVICE_CONTROL_CONTEXT, *PHAL_DEVICE_CONTROL_CONTEXT;


typedef
ULONG
(*PGETSETBUSDATA)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef
ULONG
(*PGETINTERRUPTVECTOR)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

typedef
BOOLEAN
(*PTRANSLATEBUSADDRESS)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef NTSTATUS
(*PADJUSTRESOURCELIST)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

typedef PDEVICE_HANDLER_OBJECT
(*PREFERENCE_DEVICE_HANDLER)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN ULONG                    SlotNumber
    );

//typedef VOID
//(*PDEREFERENCE_DEVICE_HANDLER)(
//    IN PDEVICE_HANDLER_OBJECT   DeviceHandler
//    );

typedef NTSTATUS
(*PASSIGNSLOTRESOURCES)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

typedef
NTSTATUS
(*PQUERY_BUS_SLOTS)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN ULONG                    BufferSize,
    OUT PULONG                  SlotNumbers,
    OUT PULONG                  ReturnedLength
    );

typedef ULONG
(*PGET_SET_DEVICE_INSTANCE_DATA)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );


typedef
NTSTATUS
(*PDEVICE_CONTROL)(
    IN PHAL_DEVICE_CONTROL_CONTEXT Context
    );


typedef
NTSTATUS
(*PHIBERNATEBRESUMEBUS)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler
    );

//
// Supported range structures
//

#define BUS_SUPPORTED_RANGE_VERSION 1

typedef struct _SUPPORTED_RANGE {
    struct _SUPPORTED_RANGE     *Next;
    ULONG                       SystemAddressSpace;
    LONGLONG                    SystemBase;
    LONGLONG                    Base;
    LONGLONG                    Limit;
} SUPPORTED_RANGE, *PSUPPORTED_RANGE;

typedef struct _SUPPORTED_RANGES {
    USHORT              Version;
    BOOLEAN             Sorted;
    UCHAR               Reserved;

    ULONG               NoIO;
    SUPPORTED_RANGE     IO;

    ULONG               NoMemory;
    SUPPORTED_RANGE     Memory;

    ULONG               NoPrefetchMemory;
    SUPPORTED_RANGE     PrefetchMemory;

    ULONG               NoDma;
    SUPPORTED_RANGE     Dma;
} SUPPORTED_RANGES, *PSUPPORTED_RANGES;

//
// Bus handler structure
//

#define BUS_HANDLER_VERSION 1

typedef struct _BUS_HANDLER {
    //
    // Version of structure
    //

    ULONG                           Version;

    //
    // This bus handler structure is for the following bus
    //

    INTERFACE_TYPE                  InterfaceType;
    BUS_DATA_TYPE                   ConfigurationType;
    ULONG                           BusNumber;

    //
    // Device object for this bus extender, or NULL if it is
    // a hal internal bus extender
    //

    PDEVICE_OBJECT                  DeviceObject;

    //
    // The parent handlers for this bus
    //

    struct _BUS_HANDLER             *ParentHandler;

    //
    // Bus specific strorage
    //

    PVOID                           BusData;

    //
    // Amount of bus specific storage needed for DeviceControl function calls
    //

    ULONG                           DeviceControlExtensionSize;

    //
    // Supported address ranges this bus allows
    //

    PSUPPORTED_RANGES               BusAddresses;

    //
    // For future use
    //

    ULONG                           Reserved[4];

    //
    // Handlers for this bus
    //

    PGETSETBUSDATA                  GetBusData;
    PGETSETBUSDATA                  SetBusData;
    PADJUSTRESOURCELIST             AdjustResourceList;
    PASSIGNSLOTRESOURCES            AssignSlotResources;
    PGETINTERRUPTVECTOR             GetInterruptVector;
    PTRANSLATEBUSADDRESS            TranslateBusAddress;

    PVOID                           Spare1;
    PVOID                           Spare2;
    PVOID                           Spare3;
    PVOID                           Spare4;
    PVOID                           Spare5;
    PVOID                           Spare6;
    PVOID                           Spare7;
    PVOID                           Spare8;

} BUS_HANDLER, *PBUS_HANDLER;

VOID
HalpInitBusHandler (
    VOID
    );

// begin_ntosp
typedef
NTSTATUS
(*PINSTALL_BUS_HANDLER)(
      IN PBUS_HANDLER   Bus
      );

typedef
NTSTATUS
(*pHalRegisterBusHandler)(
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           AssociatedConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandlers,
    OUT PBUS_HANDLER           *BusHandler
    );
// end_ntosp

NTSTATUS
HaliRegisterBusHandler (
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           AssociatedConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandlers,
    OUT PBUS_HANDLER           *BusHandler
    );

// begin_ntddk begin_ntosp
typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForBus) (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );
// end_ntddk end_ntosp

PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );

PBUS_HANDLER
FASTCALL
HaliHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );

typedef VOID
(FASTCALL *pHalRefernceBusHandler) (
    IN PBUS_HANDLER   BusHandler
    );

VOID
FASTCALL
HaliDerefernceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );

// begin_ntosp
typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForConfigSpace) (
    IN BUS_DATA_TYPE  ConfigSpace,
    IN ULONG          BusNumber
    );
// end_ntosp

PBUS_HANDLER
FASTCALL
HaliHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigSpace,
    IN ULONG          BusNumber
    );

// begin_ntddk begin_ntosp
typedef
VOID
(FASTCALL *pHalReferenceBusHandler) (
    IN PBUS_HANDLER   BusHandler
    );
// end_ntddk end_ntosp

VOID
FASTCALL
HaliReferenceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );

VOID
FASTCALL
HaliDereferenceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );


NTSTATUS
HaliQueryBusSlots (
    IN PBUS_HANDLER             BusHandler,
    IN ULONG                    BufferSize,
    OUT PULONG                  SlotNumbers,
    OUT PULONG                  ReturnedLength
    );

NTSTATUS
HaliAdjustResourceListRange (
    IN PSUPPORTED_RANGES                    SupportedRanges,
    IN PSUPPORTED_RANGE                     InterruptRanges,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    );

// begin_ntosp
typedef
VOID
(*pHalSetWakeEnable)(
    IN BOOLEAN          Enable
    );

typedef
VOID
(*pHalSetWakeAlarm)(
    IN ULONGLONG        WakeTime,
    IN PTIME_FIELDS     WakeTimeFields
    );

typedef
VOID
(*pHalLocateHiberRanges)(
    IN PVOID MemoryMap
    );


// begin_ntddk

//*****************************************************************************
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalInformationClassUnused1,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation,
    HalMapRegisterInformation,
    HalMcaLogInformation,               // Machine Check Abort Information
    HalFrameBufferCachingInformation,
    HalDisplayBiosInformation,
    HalProcessorFeatureInformation,
    HalNumaTopologyInterface,
    HalErrorInformation,                // General MCA, CMC, CPE Error Information.
    HalCmcLogInformation,               // Processor Corrected Machine Check Information
    HalCpeLogInformation,               // Corrected Platform Error Information
    HalQueryMcaInterface,
    HalQueryAMLIIllegalIOPortAddresses,
    HalQueryMaxHotPlugMemoryAddress,
    HalPartitionIpiInterface,
    HalPlatformInformation,
    HalQueryProfileSourceList
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval,
    HalProfileSourceInterruptHandler,
    HalMcaRegisterDriver,              // Registring Machine Check Abort driver
    HalKernelErrorHandler,
    HalCmcRegisterDriver,              // Registring Processor Corrected Machine Check driver
    HalCpeRegisterDriver,              // Registring Corrected Platform  Error driver
    HalMcaLog,
    HalCmcLog,
    HalCpeLog,
    HalGenerateCmcInterrupt             // Used to test CMC
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;


typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );

// end_ntddk
NTSTATUS
HaliQuerySystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );
NTSTATUS
HaliHandlePCIConfigSpaceAccess(
    IN      BOOLEAN Read,
    IN      ULONG   Addr,
    IN      ULONG   Size,
    IN OUT  PULONG  pData
    );
//begin_ntddk

typedef
NTSTATUS
(*pHalSetSystemInformation)(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

// end_ntddk
NTSTATUS
HaliSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );
// begin_ntddk

typedef
VOID
(FASTCALL *pHalExamineMBR)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

typedef
VOID
(FASTCALL *pHalIoAssignDriveLetters)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    IN PBUS_HANDLER         BusHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

typedef
NTSTATUS
(*pHalInitPnpDriver)(
    VOID
    );

// end_ntddk
NTSTATUS
HaliInitPnpDriver(
    VOID
    );
// begin_ntddk

typedef struct _PM_DISPATCH_TABLE {
    ULONG   Signature;
    ULONG   Version;
    PVOID   Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;

typedef
NTSTATUS
(*pHalInitPowerManagement)(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

// end_ntddk
NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );
// begin_ntddk

typedef
struct _DMA_ADAPTER *
(*pHalGetDmaAdapter)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

// end_ntddk
struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );
// begin_ntddk

typedef
NTSTATUS
(*pHalGetInterruptTranslator)(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

// end_ntddk
NTSTATUS
HaliGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );
// begin_ntddk

typedef
BOOLEAN
(*pHalTranslateBusAddress)(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
NTSTATUS
(*pHalAssignSlotResources) (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

typedef
VOID
(*pHalHaltSystem) (
    VOID
    );

typedef
BOOLEAN
(*pHalResetDisplay) (
    VOID
    );

// begin_ntndis
typedef struct _MAP_REGISTER_ENTRY {
    PVOID   MapRegister;
    BOOLEAN WriteToDevice;
} MAP_REGISTER_ENTRY, *PMAP_REGISTER_ENTRY;
// end_ntndis

// end_ntddk 
typedef
NTSTATUS
(*pHalAllocateMapRegisters)(
    IN struct _ADAPTER_OBJECT *DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegsiterArray
    );

NTSTATUS
HalAllocateMapRegisters(
    IN struct _ADAPTER_OBJECT *DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegsiterArray
    );
// begin_ntddk

typedef
UCHAR
(*pHalVectorToIDTEntry) (
    ULONG Vector
);

typedef
BOOLEAN
(*pHalFindBusAddressTranslation) (
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

typedef
NTSTATUS
(*pHalStartMirroring)(
    VOID
    );

typedef
NTSTATUS
(*pHalEndMirroring)(
    IN ULONG PassNumber
    );

typedef
NTSTATUS
(*pHalMirrorPhysicalMemory)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef
NTSTATUS
(*pHalMirrorVerify)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef struct {
    UCHAR     Type;  //CmResourceType
    BOOLEAN   Valid;
    UCHAR     Reserved[2];
    PUCHAR    TranslatedAddress;
    ULONG     Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS  Start;
    PHYSICAL_ADDRESS  MaxEnd;
    PVOID             VirtualAddress;
    ULONG             Length;
    BOOLEAN           Cached;
    BOOLEAN           Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef struct {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;
    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    BOOLEAN   Initialized;
    DEBUG_DEVICE_ADDRESS BaseAddress[6];
    DEBUG_MEMORY_REQUIREMENTS   Memory;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;

typedef
NTSTATUS
(*pKdSetupPciDeviceForDebugging)(
    IN     PVOID                     LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdReleasePciDeviceForDebugging)(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
PVOID
(*pKdGetAcpiTablePhase0)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN ULONG Signature
    );

typedef
VOID
(*pKdCheckPowerButton)(
    VOID
    );

typedef
VOID
(*pHalEndOfBoot)(
    VOID
    );

typedef
PVOID
(*pKdMapPhysicalMemory64)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

typedef
VOID
(*pKdUnmapVirtualAddress)(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );


typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    ULONG                           Spare1;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoAssignDriveLetters        HalIoAssignDriveLetters;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;

    pHalHandlerForBus               HalReferenceHandlerForBus;
    pHalReferenceBusHandler         HalReferenceBusHandler;
    pHalReferenceBusHandler         HalDereferenceBusHandler;

    pHalInitPnpDriver               HalInitPnpDriver;
    pHalInitPowerManagement         HalInitPowerManagement;

    pHalGetDmaAdapter               HalGetDmaAdapter;
    pHalGetInterruptTranslator      HalGetInterruptTranslator;

    pHalStartMirroring              HalStartMirroring;
    pHalEndMirroring                HalEndMirroring;
    pHalMirrorPhysicalMemory        HalMirrorPhysicalMemory;
    pHalEndOfBoot                   HalEndOfBoot;
    pHalMirrorVerify                HalMirrorVerify;

} HAL_DISPATCH, *PHAL_DISPATCH;

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        3

#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots

#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler

#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement

#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator

#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify

// end_ntddk

typedef struct {
    ULONG                               Version;

    pHalHandlerForBus                   HalHandlerForBus;
    pHalHandlerForConfigSpace           HalHandlerForConfigSpace;
    pHalLocateHiberRanges               HalLocateHiberRanges;

    pHalRegisterBusHandler              HalRegisterBusHandler;

    pHalSetWakeEnable                   HalSetWakeEnable;
    pHalSetWakeAlarm                    HalSetWakeAlarm;

    pHalTranslateBusAddress             HalPciTranslateBusAddress;
    pHalAssignSlotResources             HalPciAssignSlotResources;

    pHalHaltSystem                      HalHaltSystem;

    pHalFindBusAddressTranslation       HalFindBusAddressTranslation;

    pHalResetDisplay                    HalResetDisplay;

    pHalAllocateMapRegisters            HalAllocateMapRegisters;

    pKdSetupPciDeviceForDebugging       KdSetupPciDeviceForDebugging;
    pKdReleasePciDeviceForDebugging     KdReleasePciDeviceForDebugging;

    pKdGetAcpiTablePhase0               KdGetAcpiTablePhase0;
    pKdCheckPowerButton                 KdCheckPowerButton;

    pHalVectorToIDTEntry                HalVectorToIDTEntry;

    pKdMapPhysicalMemory64              KdMapPhysicalMemory64;
    pKdUnmapVirtualAddress              KdUnmapVirtualAddress;

} HAL_PRIVATE_DISPATCH, *PHAL_PRIVATE_DISPATCH;


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_PRIVATE_DISPATCH           HalPrivateDispatchTable;
#define HALPDISPATCH                    HalPrivateDispatchTable

#else

extern  HAL_PRIVATE_DISPATCH            HalPrivateDispatchTable;
#define HALPDISPATCH                    (&HalPrivateDispatchTable)

#endif

#define HAL_PRIVATE_DISPATCH_VERSION        2

#define HalRegisterBusHandler           HALPDISPATCH->HalRegisterBusHandler
#define HalHandlerForBus                HALPDISPATCH->HalHandlerForBus
#define HalHandlerForConfigSpace        HALPDISPATCH->HalHandlerForConfigSpace
#define HalLocateHiberRanges            HALPDISPATCH->HalLocateHiberRanges
#define HalSetWakeEnable                HALPDISPATCH->HalSetWakeEnable
#define HalSetWakeAlarm                 HALPDISPATCH->HalSetWakeAlarm
#define HalHaltSystem                   HALPDISPATCH->HalHaltSystem
#define HalResetDisplay                 HALPDISPATCH->HalResetDisplay
#define HalAllocateMapRegisters         HALPDISPATCH->HalAllocateMapRegisters
#define KdSetupPciDeviceForDebugging    HALPDISPATCH->KdSetupPciDeviceForDebugging
#define KdReleasePciDeviceForDebugging  HALPDISPATCH->KdReleasePciDeviceForDebugging
#define KdGetAcpiTablePhase0            HALPDISPATCH->KdGetAcpiTablePhase0
#define KdCheckPowerButton              HALPDISPATCH->KdCheckPowerButton
#define HalVectorToIDTEntry             HALPDISPATCH->HalVectorToIDTEntry
#define KdMapPhysicalMemory64           HALPDISPATCH->KdMapPhysicalMemory64
#define KdUnmapVirtualAddress           HALPDISPATCH->KdUnmapVirtualAddress

// begin_ntddk

//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    ULONG           Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
    KPROFILE_SOURCE Source;
    BOOLEAN         Supported;
    ULONG_PTR       Interval;
    ULONG_PTR       DefInterval;
    ULONG_PTR       MaxInterval;
    ULONG_PTR       MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

// for the information class "HalProfileSourceInterval"
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG_PTR Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

// for the information class "HalQueryProfileSourceList"
typedef struct _HAL_PROFILE_SOURCE_LIST {
    KPROFILE_SOURCE Source;
    PWSTR Description;
} HAL_PROFILE_SOURCE_LIST, *PHAL_PROFILE_SOURCE_LIST;

// for the information class "HalDispayBiosInformation"
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios,
    HalDisplayEmulatedBios,
    HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION {
    ULONG   TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO {
    ULONG   ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS {
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

// for the information class "HalProcessorFeatureInformation"
typedef struct _HAL_PROCESSOR_FEATURE {
    ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;

// for the information class "HalNumaTopologyInterface"

typedef ULONG HALNUMAPAGETONODE;

typedef
HALNUMAPAGETONODE
(*PHALNUMAPAGETONODE)(
    IN  ULONG_PTR   PhysicalPageNumber
    );

typedef
NTSTATUS
(*PHALNUMAQUERYPROCESSORNODE)(
    IN  ULONG       ProcessorNumber,
    OUT PUSHORT     Identifier,
    OUT PUCHAR      Node
    );

typedef struct _HAL_NUMA_TOPOLOGY_INTERFACE {
    ULONG                               NumberOfNodes;
    PHALNUMAQUERYPROCESSORNODE          QueryProcessorNode;
    PHALNUMAPAGETONODE                  PageToNode;
} HAL_NUMA_TOPOLOGY_INTERFACE;

typedef
NTSTATUS
(*PHALIOREADWRITEHANDLER)(
    IN      BOOLEAN fRead,
    IN      ULONG dwAddr,
    IN      ULONG dwSize,
    IN OUT  PULONG pdwData
    );

// for the information class "HalQueryIllegalIOPortAddresses"
typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST
{
    ULONG                   BadAddrBegin;
    ULONG                   BadAddrSize;
    ULONG                   OSVersionTrigger;
    PHALIOREADWRITEHANDLER  IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;

// end_ntosp

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// HalQueryMcaInterface
//

typedef
VOID
(*PHALMCAINTERFACELOCK)(
    VOID
    );

typedef
VOID
(*PHALMCAINTERFACEUNLOCK)(
    VOID
    );

typedef
NTSTATUS
(*PHALMCAINTERFACEREADREGISTER)(
    IN     UCHAR    BankNumber,
    IN OUT PVOID    Exception
    );

typedef struct _HAL_MCA_INTERFACE {
    PHALMCAINTERFACELOCK            Lock;
    PHALMCAINTERFACEUNLOCK          Unlock;
    PHALMCAINTERFACEREADREGISTER    ReadRegister;
} HAL_MCA_INTERFACE;

#if defined(_AMD64_)

struct _KTRAP_FRAME;
struct _KEXCEPTION_FRAME;

typedef
ERROR_SEVERITY
(*PDRIVER_EXCPTN_CALLBACK) (
    IN PVOID Context,
    IN struct _KTRAP_FRAME *TrapFrame,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN PMCA_EXCEPTION Exception
);

#endif

#if defined(_X86_) || defined(_IA64_)

typedef
#if defined(_IA64_)
ERROR_SEVERITY
#else
VOID
#endif
(*PDRIVER_EXCPTN_CALLBACK) (
    IN PVOID Context,
    IN PMCA_EXCEPTION BankLog
);

#endif

typedef PDRIVER_EXCPTN_CALLBACK  PDRIVER_MCA_EXCEPTION_CALLBACK;

//
// Structure to record the callbacks from driver
//

typedef struct _MCA_DRIVER_INFO {
    PDRIVER_MCA_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} MCA_DRIVER_INFO, *PMCA_DRIVER_INFO;

// end_ntddk

// For the information class HalKernelErrorHandler
typedef enum
{
	MceNotification,               // An MCE realated event occured
    McaAvailable,                  // An CPE is available for processing
    CmcAvailable,                  // An CMC is available for processing
    CpeAvailable,                  // An CPE is available for processing
    CmcSwitchToPolledMode,         // CMC Threshold exceeded - switching to polled mode
    CpeSwitchToPolledMode          // CPE Threshold exceeded - switching to polled mode
} KERNEL_MCE_DELIVERY_OPERATION, *PKERNEL_MCE_DELIVERY_OPERATION;

typedef BOOLEAN (*KERNEL_MCA_DELIVERY)( PVOID Reserved, KERNEL_MCE_DELIVERY_OPERATION Operation, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_CMC_DELIVERY)( PVOID Reserved, KERNEL_MCE_DELIVERY_OPERATION Operation, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_CPE_DELIVERY)( PVOID Reserved, KERNEL_MCE_DELIVERY_OPERATION Operation, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_MCE_DELIVERY)( PVOID Reserved, KERNEL_MCE_DELIVERY_OPERATION Operation, PVOID Argument2 );

#define KERNEL_ERROR_HANDLER_VERSION 0x2
typedef struct
{
    ULONG                Version;     // Version of this structure. Required to be 1rst field.
    ULONG                Padding;
    KERNEL_MCA_DELIVERY  KernelMcaDelivery;   // Kernel callback for MCA DPC Queueing.
    KERNEL_CMC_DELIVERY  KernelCmcDelivery;   // Kernel callback for CMC DPC Queueing.
    KERNEL_CPE_DELIVERY  KernelCpeDelivery;   // Kernel callback for CPE DPC Queueing.
    KERNEL_MCE_DELIVERY  KernelMceDelivery;   // Kernel callback for CME DPC Queueing.
                                              //    Includes the kernel notifications for FW
                                              //    interfaces errors.
} KERNEL_ERROR_HANDLER_INFO, *PKERNEL_ERROR_HANDLER_INFO;

// KERNEL_MCA_DELIVERY.McaType definition
#define KERNEL_MCA_UNKNOWN   0x0
#define KERNEL_MCA_PREVIOUS  0x1
#define KERNEL_MCA_CORRECTED 0x2

// KERNEL_MCE_DELIVERY.Reserved.EVENTTYPE definitions
#define KERNEL_MCE_EVENTTYPE_MCA   0x00
#define KERNEL_MCE_EVENTTYPE_INIT  0x01
#define KERNEL_MCE_EVENTTYPE_CMC   0x02
#define KERNEL_MCE_EVENTTYPE_CPE   0x03
#define KERNEL_MCE_EVENTTYPE_MASK  0xffff
#define KERNEL_MCE_EVENTTYPE( _Reserved ) ((USHORT)(ULONG_PTR)(_Reserved))

// KERNEL_MCE_DELIVERY.Reserved.OPERATION definitions
#define KERNEL_MCE_OPERATION_CLEAR_STATE_INFO   0x1
#define KERNEL_MCE_OPERATION_GET_STATE_INFO     0x2
#define KERNEL_MCE_OPERATION_MASK               0xffff
#define KERNEL_MCE_OPERATION_SHIFT              16

#define KERNEL_MCE_OPERATION( _Reserved )  \
   ((USHORT)((((ULONG_PTR)(_Reserved)) >> KERNEL_MCE_OPERATION_SHIFT) & KERNEL_MCE_OPERATION_MASK))

// for information class HalErrorInformation
#define HAL_ERROR_INFO_VERSION 0x2

// begin_ntddk

typedef struct _HAL_ERROR_INFO {
    ULONG     Version;                 // Version of this structure
    ULONG     Reserved;                //
    ULONG     McaMaxSize;              // Maximum size of a Machine Check Abort record
    ULONG     McaPreviousEventsCount;  // Flag indicating previous or early-boot MCA event logs.
    ULONG     McaCorrectedEventsCount; // Number of corrected MCA events since boot.      approx.
    ULONG     McaKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     McaDriverDpcQueueFails;  // Number of OEM MCA Driver Dpc queueing failures. approx.
    ULONG     McaReserved;
    ULONG     CmcMaxSize;              // Maximum size of a Corrected Machine  Check record
    ULONG     CmcPollingInterval;      // In units of seconds
    ULONG     CmcInterruptsCount;      // Number of CMC interrupts.                       approx.
    ULONG     CmcKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CmcDriverDpcQueueFails;  // Number of OEM CMC Driver Dpc queueing failures. approx.
    ULONG     CmcGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CmcClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CmcReserved;
    ULONGLONG CmcLogId;                // Last seen record identifier.
    ULONG     CpeMaxSize;              // Maximum size of a Corrected Platform Event record
    ULONG     CpePollingInterval;      // In units of seconds
    ULONG     CpeInterruptsCount;      // Number of CPE interrupts.                       approx.
    ULONG     CpeKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CpeDriverDpcQueueFails;  // Number of OEM CPE Driver Dpc queueing failures. approx.
    ULONG     CpeGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CpeClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CpeInterruptSources;     // Number of SAPIC Platform Interrupt Sources
    ULONGLONG CpeLogId;                // Last seen record identifier.
    ULONGLONG KernelReserved[4];
} HAL_ERROR_INFO, *PHAL_ERROR_INFO;


#define HAL_MCE_INTERRUPTS_BASED ((ULONG)-1)
#define HAL_MCE_DISABLED          ((ULONG)0)

//
// Known values for HAL_ERROR_INFO.CmcPollingInterval.
//

#define HAL_CMC_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CMC_DISABLED          HAL_MCE_DISABLED

//
// Known values for HAL_ERROR_INFO.CpePollingInterval.
//

#define HAL_CPE_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CPE_DISABLED          HAL_MCE_DISABLED

#define HAL_MCA_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_MCA_DISABLED          HAL_MCE_DISABLED


// end_ntddk

//
// Kernel/WMI Tokens for HAL MCE Log Interfaces
//

#define McaKernelToken KernelReserved[0]
#define CmcKernelToken KernelReserved[1]
#define CpeKernelToken KernelReserved[2]

// begin_ntddk

//
// Driver Callback type for the information class "HalCmcRegisterDriver"
//

typedef
VOID
(*PDRIVER_CMC_EXCEPTION_CALLBACK) (
    IN PVOID            Context,
    IN PCMC_EXCEPTION   CmcLog
);

//
// Driver Callback type for the information class "HalCpeRegisterDriver"
//

typedef
VOID
(*PDRIVER_CPE_EXCEPTION_CALLBACK) (
    IN PVOID            Context,
    IN PCPE_EXCEPTION   CmcLog
);

//
//
// Structure to record the callbacks from driver
//

typedef struct _CMC_DRIVER_INFO {
    PDRIVER_CMC_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CMC_DRIVER_INFO, *PCMC_DRIVER_INFO;

typedef struct _CPE_DRIVER_INFO {
    PDRIVER_CPE_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CPE_DRIVER_INFO, *PCPE_DRIVER_INFO;

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#if defined(_IA64_)

typedef
NTSTATUS
(*HALSENDCROSSPARTITIONIPI)(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    );

typedef
NTSTATUS
(*HALRESERVECROSSPARTITIONINTERRUPTVECTOR)(
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    );

typedef struct _HAL_CROSS_PARTITION_IPI_INTERFACE {
    HALSENDCROSSPARTITIONIPI HalSendCrossPartitionIpi;
    HALRESERVECROSSPARTITIONINTERRUPTVECTOR HalReserveCrossPartitionInterruptVector;
} HAL_CROSS_PARTITION_IPI_INTERFACE;

#endif

typedef struct _HAL_PLATFORM_INFORMATION {
    ULONG PlatformFlags;
} HAL_PLATFORM_INFORMATION, *PHAL_PLATFORM_INFORMATION;

//
// These platform flags are carried over from the IPPT table
// definition if appropriate.
//

#define HAL_PLATFORM_DISABLE_WRITE_COMBINING      0x01L
#define HAL_PLATFORM_DISABLE_PTCG                 0x04L
#define HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY       0x08L
#define HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO  0x10L
#define HAL_PLATFORM_ACPI_TABLES_CACHED           0x20L

// begin_wdm begin_ntndis begin_ntosp

typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

// end_ntndis

typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
     IN PDMA_ADAPTER DmaAdapter,
     IN OPTIONAL PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     OUT PULONG  ScatterGatherListSize,
     OUT OPTIONAL PULONG pNumberOfMapRegisters
     );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST)(
     IN PDMA_ADAPTER DmaAdapter,
     IN PDEVICE_OBJECT DeviceObject,
     IN PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     IN PDRIVER_LIST_CONTROL ExecutionRoutine,
     IN PVOID Context,
     IN BOOLEAN WriteToDevice,
     IN PVOID   ScatterGatherBuffer,
     IN ULONG   ScatterGatherLength
     );

typedef NTSTATUS
(*PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
    PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
    PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
} DMA_OPERATIONS;

// end_wdm


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_))

// begin_wdm

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
FORCEINLINE
PVOID
HalAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
FORCEINLINE
VOID
HalFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
FORCEINLINE
BOOLEAN
IoFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
FORCEINLINE
VOID
IoFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
FORCEINLINE
VOID
IoFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    IN PVOID MapRegisterBase,
    IN ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
FORCEINLINE
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

DECLSPEC_DEPRECATED_DDK                 // Use GetDmaAlignment
FORCEINLINE
ULONG
HalGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
FORCEINLINE
ULONG
HalReadDmaCounter(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

// end_wdm

#else

//
// DMA adapter object functions.
//
DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
NTHALAPI
VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
NTHALAPI
ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
NTHALAPI
VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
NTHALAPI
VOID
IoFreeMapRegisters(
   IN PADAPTER_OBJECT AdapterObject,
   IN PVOID MapRegisterBase,
   IN ULONG NumberOfMapRegisters
   );

DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );
#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)

DECLSPEC_DEPRECATED_DDK
NTSTATUS
HalGetScatterGatherList (               // Use GetScatterGatherList
    IN PADAPTER_OBJECT DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

DECLSPEC_DEPRECATED_DDK                 // Use PutScatterGatherList
VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

DECLSPEC_DEPRECATED_DDK                 // Use PutDmaAdapter
VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT DmaAdapter
    );

// end_ntddk end_ntosp

#endif // _HAL_

// end_nthal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

#if defined(_AMD64_) || defined(_X86_)

#define HEAP_PROTECTION PAGE_EXECUTE_READWRITE

#else

#define HEAP_PROTECTION PAGE_READWRITE

#endif

typedef struct _HEAP_ENTRY {

#if !defined(_WIN64)
    union {
        struct {

            //
            //  This field gives the size of the current block in allocation
            //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
            //  equals the size in bytes).
            //
            //  Except if this is part of a virtual alloc block then this
            //  value is the difference between the commit size in the virtual
            //  alloc entry and the what the user asked for.
            //

            USHORT Size;

            //
            // This field gives the size of the previous block in allocation
            // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
            // equals the size of the previous block in bytes).
            //

            USHORT PreviousSize;
        };

        volatile PVOID SubSegmentCode;
    };

#else
    
    USHORT Size;
    USHORT PreviousSize;

#endif

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    volatile UCHAR SegmentIndex;

#if defined(_WIN64)
    volatile PVOID SubSegmentCode;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {

    HEAP_ENTRY;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //

    LIST_ENTRY FreeList;

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//
// PAGE_CHECK_NO_SERIALIZE_ACCESS
//
//     Additional checks for multi-threaded access for no_serialize
//     heaps. This flag can trigger false positives in MPheap. It needs
//     to be used only on processes that do not use MPheap-like heaps.
//
// PAGE_HEAP_USE_READONLY
//
//     The page following (or preceding) the user allocation is marked
//     RO instead of NA. This is useful when testing RPC servers which
//     by design during unmarshalling might go off by a few bytes when 
//     probing parameters. This is so for performance reasons.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_NO_UMDH_SUPPORT           0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040 // obsolete
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000
#define PAGE_HEAP_USE_READONLY              0x8000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\halpnpp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    halpnpp.h

Abstract:

    Private interface from 'legacy' hal to 'PnP' class drivers that support
    new functionality

Author:

    Mike Gallop (mikeg) April, 1998

Revision History:

--*/


#define ISA_FTYPE_DMA_INTERFACE_VERSION 1
#define ISA_DMA_CHANNELS 8

typedef
NTSTATUS
(*PISA_CLAIM_FTYPE_CHANNEL)(
    IN PVOID Context,
    IN ULONG Channel,
    OUT PULONG ChannelInfo
    );

typedef
NTSTATUS
(*PISA_RELEASE_FTYPE_CHANNEL)(
    IN PVOID Context,
    IN ULONG Channel
    );

/*++


Routine Description:

    This returns information about children to be enumerated by a multifunction
    driver.

Arguments:

    Context - Context from the ISA_FTYPE_DMA_INTERFACE

    Channel - Channel to try and set to F-Type DMA

    ChannelInfo - Result of the set. Returns the mask of channels set to F-Type

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NO_MORE_ENTRIES indicates that the are no more children to enumerate

--*/

typedef struct _ISA_FTYPE_DMA_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    //
    //
    PISA_CLAIM_FTYPE_CHANNEL IsaSetFTypeChannel;
    PISA_RELEASE_FTYPE_CHANNEL IsaReleaseFTypeChannel;

} ISA_FTYPE_DMA_INTERFACE, *PISA_FTYPE_DMA_INTERFACE;



DEFINE_GUID(GUID_ISA_FDMA_INTERFACE,
            0xEFF58E88L, 0xCE6B, 0x11D1, 0x8B, 0xA8, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0);

DEFINE_GUID( GUID_FDMA_INTERFACE_PRIVATE,
            0x60526D5EL, 0xCF34, 0x11D1, 0x8B, 0xA8, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\hotpatch.h ===
/*

Copyright (c) 2001  Microsoft Corporation

File name:

    hotpatch.h
   
Author:
    
    Adrian Marinescu (adrmarin)  Nov 15 2001
    Tom McGuire (tommcg)
    
*/

#ifndef _HOTPATCH_H
#define _HOTPATCH_H

//
//  Patch file format structures
//

//
//  The HOTPATCH_HEADER can be found in the hotpatch binary by searching
//  the section headers for a section named ".hotp1  " and verifying that
//  the first four bytes in that section match the "HOT1" ('1TOH') header
//  signature.  The .hotp1 section will be marked readonly and discardable.
//
//
//  The HOTPATCH_HEADER can be found in the hotpatch binary by searching
//  the section headers for a section named ".hotp1  " and verifying that
//  the first four bytes in that section match the "HOT1" ('1TOH') header
//  signature.  The .hotp1 section will be marked readonly and discardable.
//


#define HOTP_SIGNATURE_DWORD        ((ULONG) '1TOH' )   // "HOT1"
#define HOTP_HEADER_VERSION_1_0     0x00010000          // 1.0
#define HOTP_SECTION_NAME           ".hotp1  "          //
#define HOTP_SECTION_NAME_QWORD     0x20203170746F682E  // ".hotp1  "


typedef struct _HOTPATCH_HEADER
{
    ULONG Signature;          // "HOT1" '1TOH'
    ULONG Version;            // 0x00010000   (1.0)

    ULONG FixupRgnCount;      // count of HOTPATCH_FIXUP_REGION entries at FixupArrayRva
    ULONG FixupRgnRva;        // RVA in this image of HOTPATCH_FIXUP_REGION entries
                              // (if FixupCount zero, FixupListRva also zero)

    ULONG ValidationCount;    // count of ValidationArray entries
    ULONG ValidationArrayRva; // RVA in this image of HOTPATCH_VALIDATION array
                              // (validation bytes valid after fixups applied)

    ULONG HookCount;          // count of HOTPATCH_HOOK entries at HookArrayRva
    ULONG HookArrayRva;       // RVA in this image of HOTPATCH_HOOK entries
                              // (if HookCount zero, HookArrayRva also zero)

    ULONGLONG OrigHotpBaseAddress;   // If hotpatch loaded at this address, and
    ULONGLONG OrigTargetBaseAddress; //   if target is loaded at this address, then
                                 //     fixups in hotpatch are not necessary

    ULONG TargetNameRva;      // RVA of target module name "kernel32.dll"
    ULONG ModuleIdMethod;     // one of HOTPATCH_MODULE_ID_METHOD

    union                     // content depends on HOTPATCH_MODULE_ID_METHOD
    {
        ULONGLONG Quad;
        GUID  Guid;

        struct
        {
            GUID  Guid;
            ULONG Age;
        }
        PdbSig;

        UCHAR Hash128[ 16 ];    // For MD5, etc.
        UCHAR Hash160[ 20 ];    // For SHA, etc.
    }
    TargetModuleIdValue;        // unique ID of target module

}
HOTPATCH_HEADER, *PHOTPATCH_HEADER;


typedef enum _HOTPATCH_MODULE_ID_METHOD
{
    HOTP_ID_None              = 0x00000000,   // No ID verification of target

    HOTP_ID_PeHeaderHash1     = 0x00000001,

    //
    //  MD5 hash of "normalized" IMAGE_NT_HEADERS32/64, ignoring certain
    //  fields that change due to resource localization, rebase, bind,
    //  sign, winalign, etc.
    //
    //      FileHeader.TimeDateStamp
    //      OptionalHeader.CheckSum
    //      OptionalHeader.ImageBase
    //      OptionalHeader.FileAlignment
    //      OptionalHeader.SizeOfCode
    //      OptionalHeader.SizeOfInitializedData
    //      OptionalHeader.SizeOfUninitializedData
    //      OptionalHeader.SizeOfImage
    //      OptionalHeader.SizeOfHeaders
    //      OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ]
    //      OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_SECURITY ]
    //      OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ]
    //      OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
    //

    HOTP_ID_PeHeaderHash2     = 0x00000002,   // 64-bit hash of normalized PE header

    HOTP_ID_PeChecksum        = 0x00000003,   // 32-bit checksum in the PE Optional header

    HOTP_ID_PeDebugSignature  = 0x00000010,   // pdb signature (GUID,Age)

}
HOTPATCH_MODULE_ID_METHOD;



typedef struct _HOTPATCH_FIXUP_REGION
{
    ULONG RvaHi:20;             // Hi 20 bits of RVA where fixups to be applied
    ULONG Count:12;             // Number of fixup entries for this region
    USHORT Fixup[2];             // Variable length HOTPATCH_FIXUP_ENTRY array
}
HOTPATCH_FIXUP_REGION, *PHOTPATCH_FIXUP_REGION;


typedef struct _HOTPATCH_FIXUP_ENTRY
{
    USHORT RvaOffset:12;          // Lo 12 bits of RVA where fixup to be applied
    USHORT FixupType:4;           // Type of fixup to perform at this location
}
HOTPATCH_FIXUP_ENTRY, *PHOTPATCH_FIXUP_ENTRY;


typedef enum _HOTPATCH_FIXUP_TYPE
{
    HOTP_Fixup_None   = 0x0,    // No fixup, ignore this entry (alignment, etc)
    HOTP_Fixup_VA32   = 0x1,    // 32-bit address in target image
    HOTP_Fixup_PC32   = 0x2,    // 32-bit x86 pc-rel address to target image
    HOTP_Fixup_VA64   = 0x3,    // 64-bit address in target image
}
HOTPATCH_FIXUP_TYPE;


typedef struct _HOTPATCH_VALIDATION
{
    ULONG SourceRva;       // RVA within patch image of validation raw bytes
    ULONG TargetRva;       // RVA within target image to validate against
    USHORT ByteCount;       // number of bytes to validate at this RVA pair
    USHORT OptionFlags;     // combination of HOTPATCH_VALIDATION_OPTIONS
}
HOTPATCH_VALIDATION, *PHOTPATCH_VALIDATION;


typedef enum _HOTPATCH_VALIDATION_OPTIONS
{
    HOTP_Valid_Hook_Target = 0x0001,    // specific to a HOTPATCH_HOOK entry
}
HOTPATCH_VALIDATION_OPTIONS;


typedef struct _HOTPATCH_HOOK
{
    USHORT HookType;         // one of HOTPATCH_HOOK_TYPE
    USHORT HookOptions;      // options specific to HookType
    ULONG  HookRva;          // RVA in target image -- where to insert hook
    ULONG  HotpRva;          // RVA in hotpatch image for redirected target of hook
    ULONG  ValidationRva;    // Optional RVA in hotpatch image of HOTPATCH_VALIDATION
}                            // specific to this hook location in target image.
HOTPATCH_HOOK, *PHOTPATCH_HOOK;


typedef enum _HOTPATCH_HOOK_TYPE
{
    HOTP_Hook_None     = 0x0000,  // No hook, ignore this entry (continuation values)
    HOTP_Hook_VA32     = 0x0001,  // 32-bit absolute address of hook target (little endian)
    HOTP_Hook_X86_JMP  = 0x0002,  // x86 E9 jmp with 32-bit pc-relative to hook target
                                  //   HookOptions low 4 bits contains original instruction length
                                  //   so implementation can pad E9 hook instruction with CC bytes
    HOTP_Hook_PCREL32  = 0x0003,  // 32-bit x86 pcrelative address of hook target, replacing
                                  //   the last four bytes of a call or conditional branch.
                                  //   HookOptions low 4 bits contains original instruction length
                                  //   so can determine where instruction begins.
    HOTP_Hook_X86_JMP2B = 0x0004, // x86 EB jmp with 8-bit displacement to an X86_JMP hook
                                  //   HookOptions low 4 bits contains original instruction length
                                  //   HotpRva contains the 8-bit displacement

    HOTP_Hook_VA64     = 0x0010,  // 64-bit absolute address of hook target (little endian)
    HOTP_Hook_IA64_BRL = 0x0011,  // IA64 brl with 64-bit target address
}
HOTPATCH_HOOK_TYPE;

//
//  Information existent in debug directory
//

typedef struct _HOTPATCH_DEBUG_SIGNATURE {

    USHORT HotpatchVersion;
    USHORT Signature;

} HOTPATCH_DEBUG_SIGNATURE, *PHOTPATCH_DEBUG_SIGNATURE;

typedef struct _HOTPATCH_DEBUG_DATA {

    ULONGLONG PEHashData;
    ULONGLONG ChecksumData;

} HOTPATCH_DEBUG_DATA, *PHOTPATCH_DEBUG_DATA;

//
//  RTL internal patch definitions
//

#ifdef NTOS_KERNEL_RUNTIME

    #define PATCH_LDR_DATA_TABLE_ENTRY     KLDR_DATA_TABLE_ENTRY   
    #define PPATCH_LDR_DATA_TABLE_ENTRY    PKLDR_DATA_TABLE_ENTRY   
#else //  ! NTOS_KERNEL_RUNTIME

    #define PATCH_LDR_DATA_TABLE_ENTRY     LDR_DATA_TABLE_ENTRY
    #define PPATCH_LDR_DATA_TABLE_ENTRY    PLDR_DATA_TABLE_ENTRY
#endif //  NTOS_KERNEL_RUNTIME


typedef struct _RTL_PATCH_HEADER {

    LIST_ENTRY  PatchList;

    PVOID       PatchImageBase;
    struct _RTL_PATCH_HEADER * NextPatch;
    
    ULONG       PatchFlags;
    LONG        PatchRefCount;
    
    PHOTPATCH_HEADER HotpatchHeader;
    
    UNICODE_STRING  TargetDllName;
    PVOID           TargetDllBase;

    PPATCH_LDR_DATA_TABLE_ENTRY TargetLdrDataTableEntry;
    PPATCH_LDR_DATA_TABLE_ENTRY PatchLdrDataTableEntry;

    PSYSTEM_HOTPATCH_CODE_INFORMATION CodeInfo;

} RTL_PATCH_HEADER, *PRTL_PATCH_HEADER;

NTSTATUS
RtlCreateHotPatch (
    OUT PRTL_PATCH_HEADER * RtlPatchData,
    IN PHOTPATCH_HEADER Patch,
    IN PPATCH_LDR_DATA_TABLE_ENTRY PatchLdrEntry,
    IN ULONG PatchFlags
    );

NTSTATUS
RtlInitializeHotPatch (
    IN PRTL_PATCH_HEADER RtlPatchData,
    IN ULONG_PTR PatchOffsetCorrection
    );

NTSTATUS
RtlReadHookInformation(
    IN PRTL_PATCH_HEADER RtlPatchData
    );

VOID
RtlFreeHotPatchData(
    IN PRTL_PATCH_HEADER RtlPatchData
    );

PHOTPATCH_HEADER
RtlGetHotpatchHeader(
    PVOID ImageBase
    );

PRTL_PATCH_HEADER
RtlFindRtlPatchHeader(
    IN PLIST_ENTRY PatchList,
    IN PPATCH_LDR_DATA_TABLE_ENTRY PatchLdrEntry
    );

BOOLEAN
RtlpIsSameImage (
    IN PRTL_PATCH_HEADER RtlPatchData,
    IN PPATCH_LDR_DATA_TABLE_ENTRY LdrDataEntry
    );

#endif  // _HOTPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ia64.h ===
/*++

Module Name:

    ia64.h

Abstract:

    This module contains the IA64 hardware specific header file.

Author:

    David N. Cutler (davec) 31-Mar-1990

Revision History:

    Bernard Lint 6-Jun-1995: IA64 version based on MIPS version.

--*/

#ifndef _IA64H_
#define _IA64H_

#if !(defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_)) && !defined(_BLDR_)

#define ExRaiseException RtlRaiseException
#define ExRaiseStatus RtlRaiseStatus

#endif

//
// Interruption history
//
// N.B. Currently the history records are saved in the 2nd half of the 8K
//      PCR page.  Therefore, we can only keep track of up to the latest
//      128 interruption records, each of 32 bytes in size.  Also, the PCR
//      structure cannot be greater than 4K.  In the future, the interruption
//      history records may become part of the KPCR structure.
//

typedef struct _IHISTORY_RECORD {
    ULONGLONG InterruptionType;
    ULONGLONG IIP;
    ULONGLONG IPSR;
    ULONGLONG Extra0;
} IHISTORY_RECORD;

#define MAX_NUMBER_OF_IHISTORY_RECORDS  128

//
// For PSR bit field definitions
//
#include "kxia64.h"


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"


#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __fci (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);
void __yield();
void __lfetch(int, void const *);
void __lfetchfault(int, void const *);

#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__fci)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)
#pragma intrinsic (__yield)
#pragma intrinsic (__lfetch)
#pragma intrinsic (__lfetchfault)
#endif // _M_IA64

#ifdef __cplusplus
}
#endif


// end_ntndis

//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

// end_wdm


//
// IA64 specific interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for values are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecture specific interfaces.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExIa64InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExIa64InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExIa64InterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExIa64InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

// begin_wdm

//
// IA64 Interrupt Definitions.
//
//
// Define length of interrupt object dispatch code in longwords.
//

#define DISPATCH_LENGTH 2*2                // Length of dispatch code template in 32-bit words

// Begin of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL            0      // Passive release level
#define LOW_LEVEL                0      // Lowest interrupt level
#define APC_LEVEL                1      // APC interrupt level
#define DISPATCH_LEVEL           2      // Dispatcher level
#define CMC_LEVEL                3      // Correctable machine check level
#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs
#define PC_LEVEL                12      // Performance Counter IRQL
#define IPI_LEVEL               14      // IPI IRQL
#define CLOCK_LEVEL             13      // Clock Timer IRQL
#define POWER_LEVEL             15      // Power failure level
#define PROFILE_LEVEL           15      // Profiling level
#define HIGH_LEVEL              15      // Highest interrupt level

// end_ntddk end_wdm end_ntosp


#if defined(NT_UP)

#define SYNCH_LEVEL             DISPATCH_LEVEL  // Synchronization level - UP

#else

#define SYNCH_LEVEL             (IPI_LEVEL-2) // Synchronization level - MP

#endif

//
// Define profile intervals.
//

#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 1000 * 10) // 10 milliseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 500) // 500 microseconds

// end_nthal
//
// The current IRQL is maintained in the TPR.mic field. The
// shift count is the number of bits to shift right to extract the
// IRQL from the TPR. See the GET/SET_IRQL macros.
//

#define TPR_MIC        4
#define TPR_IRQL_SHIFT TPR_MIC

// To go from vector number <-> IRQL we just do a shift
#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT

//
// Interrupt Vector Definitions
//

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT


//
// End of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 100

// begin_ntddk begin_wdm begin_nthal begin_ntosp

#if defined(_M_IA64) && !defined(RC_INVOKED)

#define InterlockedAdd _InterlockedAdd
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire _InterlockedIncrement_acq
#define InterlockedIncrementRelease _InterlockedIncrement_rel
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire _InterlockedDecrement_acq
#define InterlockedDecrementRelease _InterlockedDecrement_rel
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 _InterlockedExchange64_acq
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64_rel

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire _InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease _InterlockedCompareExchange_rel
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeRelease (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
FORCEINLINE
InterlockedAnd64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

LONGLONG
FORCEINLINE
InterlockedOr64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif


#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

LONGLONG
FORCEINLINE
InterlockedXor64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif


#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_IA64) && !defined(RC_INVOKED)

// end_wdm

__forceinline
LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

__forceinline
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

__forceinline
LONG
InterlockedXor (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i ^ Set,
                                       i);

    } while (i != j);

    return j;
}


// end_ntddk end_nthal end_ntosp

#define KiSynchIrql SYNCH_LEVEL         // enable portable code
#define KiProfileIrql PROFILE_LEVEL     // enable portable code


//
// Sanitize FPSR based on processor mode.
//
// If kernel mode, then
//      let caller specify all bits, except reserved
//
// If user mode, then
//      let the caller specify all bits, except reserved
//

__forceinline
ULONG64
SANITIZE_FSR(ULONG64 fsr, MODE mode)
{
    UNREFERENCED_PARAMETER(mode);

    fsr &= ~(MASK_IA64(FPSR_MBZ0,FPSR_MBZ0_V)| MASK_IA64(FPSR_TD0, 1));

    if (((fsr >> FPSR_PC0) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC0);
    }
    if (((fsr >> FPSR_PC1) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC1);
    }
    if (((fsr >> FPSR_PC2) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC2);
    }
    if (((fsr >> FPSR_PC3) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC3);
    }

    return fsr;
}

//
// Define SANITIZE_PSR for IA64
//
// If kernel mode, then
//      force clearing of BE, SP, CPL, MC, PK, DFL, reserved (MBZ)
//      force the setting of IC, DT, DFH, DI, LP, RT, IT
//      let caller specify UP, AC, I, BN, PP, SI, DB, TB, IS, ID, DA, DD, SS, RI, ED
//
// If user mode, then
//      force clearing of MC, PK, LP, DFH, reserved
//      force the setting of BN, IC, I, DT, RT, CPL, IT
//      let caller specify BE, UP, PP, AC, DFL, SP, SI, DI, DB, TB, IS, ID, DA, DD, SS, RI, ED
//

#define PSR_KERNEL_CLR  (MASK_IA64(PSR_MBZ4,1i64) | MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) | \
                         MASK_IA64(PSR_PK,1i64) | MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_DFL, 1i64) | \
                         MASK_IA64(PSR_SP,1i64) | MASK_IA64(PSR_MBZ2,PSR_MBZ2_V) | MASK_IA64(PSR_CPL,0x3i64) | \
                         MASK_IA64(PSR_MC,1i64) | MASK_IA64(PSR_MBZ3,PSR_MBZ3_V))
                         
#define PSR_KERNEL_SET  (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_DT,1i64) | \
                         MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_RT,1i64) | \
                         MASK_IA64(PSR_IT,1i64))

#define PSR_KERNEL_CPY  (MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_AC,1i64) | MASK_IA64(PSR_MFL,1i64) | \
                         MASK_IA64(PSR_MFH,1i64) | MASK_IA64(PSR_I,1i64) | MASK_IA64(PSR_DFH,1i64)  | \
                         MASK_IA64(PSR_PP,1i64) | MASK_IA64(PSR_SI,1i64) | MASK_IA64(PSR_DB,1i64) | \
                         MASK_IA64(PSR_LP,1i64) | MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | \
                         MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS,1i64) | \
                         MASK_IA64(PSR_ID,1i64) | MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | \
                         MASK_IA64(PSR_BN,1i64) | MASK_IA64(PSR_IA,1i64))

#define PSR_USER_CLR    (MASK_IA64(PSR_MBZ4,1i64) | MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) | MASK_IA64(PSR_PK,1i64) | \
                         MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_DFL,1i64) | MASK_IA64(PSR_SP,1i64) | \
                         MASK_IA64(PSR_SI,1i64) | MASK_IA64(PSR_MBZ2,PSR_MBZ2_V) | MASK_IA64(PSR_LP,1i64) | \
                         MASK_IA64(PSR_MBZ3,PSR_MBZ3_V) | MASK_IA64(PSR_MC,1i64) | MASK_IA64(PSR_DA,1i64) | \
                         MASK_IA64(PSR_IA,1i64))
                         

#define PSR_USER_SET    (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_I,1i64)  | \
                         MASK_IA64(PSR_DT,1i64) | MASK_IA64(PSR_PP,1i64) | \
                         MASK_IA64(PSR_RT,1i64) | MASK_IA64(PSR_CPL,0x3i64) | \
                         MASK_IA64(PSR_IT,1i64) | MASK_IA64(PSR_BN,1i64))

#define PSR_USER_CPY    (MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_UP,1i64) | \
                         MASK_IA64(PSR_AC,1i64) | MASK_IA64(PSR_MFL,1i64) | MASK_IA64(PSR_MFH,1i64) | \
                         MASK_IA64(PSR_DFH,1i64) | MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_DB,1i64) | \
                         MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) | \
                         MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS, 1i64) |  \
                         MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64))


#define PSR_DEBUG_SET   (MASK_IA64(PSR_DB,1i64) | MASK_IA64(PSR_SS,1i64) | MASK_IA64(PSR_TB,1i64) |  \
                         MASK_IA64(PSR_ID,1i64) | MASK_IA64(PSR_DD,1i64))

extern ULONGLONG UserPsrSetMask;

__forceinline
ULONG64
SANITIZE_PSR(ULONG64 psr, MODE mode){

    psr = (mode) == KernelMode ?
        (PSR_KERNEL_SET | ((psr) & (PSR_KERNEL_CPY | ~PSR_KERNEL_CLR))) :
        (UserPsrSetMask | ((psr) & (PSR_USER_CPY | ~PSR_USER_CLR)));

    if (((psr >> PSR_RI) & 3) == 3) {

        //
        // 3 is an invalid slot number; sanitize it to zero
        //

        psr &= ~(3i64 << PSR_RI);
    }

    return(psr);
}

//
// Define SANITIZE_IFS for IA64
//

__forceinline
ULONG64
SANITIZE_IFS(ULONG64 pfsarg, MODE mode){

    IA64_PFS pfs;
    ULONGLONG sof;

    UNREFERENCED_PARAMETER(mode);

    pfs.ull = pfsarg;

    //
    // There is no previous EC or previous privilege level in IFS
    //

    pfs.sb.pfs_pec = 0;
    pfs.sb.pfs_ppl = 0;
    pfs.sb.pfs_reserved1 = 0;
    pfs.sb.pfs_reserved2 = 0;

    //
    // Set the valid bit.
    //

    pfs.ull |= MASK_IA64(IFS_V,1i64);

    //
    // Verify the size of frame is not greater than allowed.
    //

    sof = pfs.sb.pfs_sof;
    if (sof > PFS_MAXIMUM_REGISTER_SIZE) {
        sof = PFS_MAXIMUM_REGISTER_SIZE;
        pfs.sb.pfs_sof = PFS_MAXIMUM_REGISTER_SIZE;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < pfs.sb.pfs_sol) {
        pfs.sb.pfs_sol = sof;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_sor = sof / 8;
    }

    //
    // Verify rename bases are less than the size of the rotaing regions.
    //

    if (pfs.sb.pfs_rrb_gr >= (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_rrb_gr = 0;
    }

    if (pfs.sb.pfs_rrb_fr >= PFS_MAXIMUM_REGISTER_SIZE) {
        pfs.sb.pfs_rrb_fr = 0;
    }

    if (pfs.sb.pfs_rrb_pr >= PFS_MAXIMUM_PREDICATE_SIZE) {
        pfs.sb.pfs_rrb_pr = 0;
    }

    return(pfs.ull);

}

__forceinline
ULONG64
SANITIZE_PFS(ULONG64 pfsarg, MODE mode){

    IA64_PFS pfs;
    ULONGLONG sof;

    pfs.ull = pfsarg;

    if (mode != KernelMode) {
        pfs.sb.pfs_ppl = IA64_USER_PL;
    }

    pfs.sb.pfs_reserved1 = 0;
    pfs.sb.pfs_reserved2 = 0;

    //
    // Verify the size of frame is not greater than allowed.
    //

    sof = pfs.sb.pfs_sof;
    if (sof > PFS_MAXIMUM_REGISTER_SIZE) {
        sof = PFS_MAXIMUM_REGISTER_SIZE;
        pfs.sb.pfs_sof = PFS_MAXIMUM_REGISTER_SIZE;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < pfs.sb.pfs_sol) {
        pfs.sb.pfs_sol = sof;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_sor = sof / 8;
    }

    //
    // Verify rename bases are less than the size of the rotaing regions.
    //

    if (pfs.sb.pfs_rrb_gr >= (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_rrb_gr = 0;
    }

    if (pfs.sb.pfs_rrb_fr >= PFS_MAXIMUM_REGISTER_SIZE) {
        pfs.sb.pfs_rrb_fr = 0;
    }

    if (pfs.sb.pfs_rrb_pr >= PFS_MAXIMUM_PREDICATE_SIZE) {
        pfs.sb.pfs_rrb_pr = 0;
    }

    return(pfs.ull);

}

//
// Function used to zero the software field of RSC that contains the size of
// RSE frame to be preloaded on kernel exit and sanitize the reserved fields.
// This function does not the the PL used by the RSE.
//

__forceinline
ULONG64
ZERO_PRELOAD_SIZE(ULONG64 RseRsc){
    RSC rseRsc;

    rseRsc.ull = RseRsc;

    rseRsc.sb.rsc_be = 0;
    rseRsc.sb.rsc_preload = 0;
    rseRsc.sb.rsc_res0 = 0;
    rseRsc.sb.rsc_res1 = 0;

    return(rseRsc.ull);
}


//
// Function used to sanitize the RSC.
// This function does not modify the preload size.
//

__forceinline
ULONG64
SANITIZE_RSC(ULONG64 RseRsc, MODE mode){
    RSC rseRsc;

    rseRsc.ull = RseRsc;

    if (mode != KernelMode) {
        rseRsc.sb.rsc_pl = IA64_USER_PL;
    }

    rseRsc.sb.rsc_be = 0;
    rseRsc.sb.rsc_res0 = 0;
    rseRsc.sb.rsc_res1 = 0;

    return(rseRsc.ull);
}

extern ULONGLONG KiIA64DCR;

#define SANITIZE_DCR(dcr, mode)  \
    ((mode) == KernelMode ? dcr : KiIA64DCR)

//
// Macro to sanitize debug registers
//

#define SANITIZE_DR(dr, mode)  \
    ((mode) == KernelMode ?  \
        (dr) :  \
        (dr & ~(0x7i64 << DR_PLM0)) /* disable pl 0-2 */  \
    )




#define SANITIZE_AR21_FCR(FCR,mode) \
    (((FCR)&0x0000FFBF00001F3Fi64)|0x40i64)

/*
bits 0-7 correspond to standard flags (zero, parity, etc) with certain bits set or cleared. Ok for user to modify.
bit 8 is the trap flag. I don't know if the ia32 debuggers use this or not, but no harm is done letting users set/clear this bit.
bit 9 is the interrupt enable flag. This value is ignored based on values in the cflg register. This value is always set for compatibility with x86 apps.
bits 10/11 are more standard flags, ok for the user to set/clear
bits 12-15 are OS related flags, must be zero (iopl, nt)
bit 16 is resume flag. Can be set/cleared by OS, should be passed back to user.
bit 17 is vm flag. Not used by wow, should be cleared.
bit 18 is ac flag. OK to be set by user.
bit 19/20 are virtual interrupt flags. Not used by wow so should be cleared
bit 21 is cpuid check, ok for user to set/clear
*/

#define SANITIZE_AR24_EFLAGS(EFLAGS,mode) \
    (((EFLAGS)&0x0000000000250FD7i64)|0x0202i64)

/*
bit 0 is protected mode and should always be 1
bits 1-3 are related to emulation of x87. Wow does not allow for emulation of x87 so must be zero.
bit 4 is ignored and always returns 1.
bit 5 is numeric exception and is ignored and treated as 1. No harm if set or cleared.
bit 6 enables use of TSS permission map. wow expects this bit to be zero.
bit 7 is IF enable. Wow does not allow modifying the eflags.if bit so should be zero
bit 8 is IF intercept. Wow depends on this behavior so should be set.
bit 9-15 is not used and must be 0
bit 16 is write protect and is ignored. No harm if set or cleared.
bit 17 is not used and must be 0
bit 18 is alignment check. No harm if set/cleared.
bits 19-28 are not used and must be 0
bit 29 is disable write-through and are ignored. No harm if set or cleared.
bit 30 is cache disable and is ignored. No harm if set or cleared.
bit 31 is paging enabled and is ignored. No harm if set or cleared.
bit 32 is VME bit. Wow depends on some behaviors of vme and should be set.
bit 33 is PVI bit. Wow does not use virtual interrupts. Should be cleared
bit 34 is rdtsc bit. No harm if set or cleared.
bits 35-39 are ia32 OS extensions and are ignored. No harm if set or cleared.
bit 40 is rdpmc. No harm if set or cleared.
bit 41 is FXSR enable. No harm if set or cleared.
bit 42 is simd exception extension. No harm if set or cleared.
*/

#define SANITIZE_AR27_CFLG(CFLG,mode) \
    ((CFLG)&(0x000007FDE0050131i64) | 0x100000111i64)

#define SANITIZE_AR28_FSR(FSR,mode) \
    ((FSR)&0x0000FFBF5555FFFFi64)

#define SANITIZE_AR29_FIR(FIR,mode) \
    ((FIR)&0x07FFFFFFFFFFFFFFi64)

#define SANITIZE_AR30_FDR(FDR,mode) \
    ((FDR)&0x0000FFFFFFFFFFFFi64)



// begin_nthal

//
// Define interrupt request physical address (maps to HAL virtual address)
//

#define INTERRUPT_REQUEST_PHYSICAL_ADDRESS  0xFFE00000

//
// Define Address of Processor Control Registers.
//


//
// Define Pointer to Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xFFFF0000))            // kernel address of first PCR
#define PCR ((KPCR * const)KIPCR)

//
// Define address for epc system calls
//

#define MM_EPC_VA (KADDRESS_BASE + 0xFFA00000)

//
// Define Base Address of PAL Mapping 
// 
//

#define HAL_PAL_VIRTUAL_ADDRESS (KADDRESS_BASE + 0xE0000000)


//
// Get address of current processor block.
//

#define KeGetCurrentPrcb() PCR->Prcb

// begin_ntddk begin_wdm begin_ntosp

#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

// end_wdm

//
// Get address of processor control region.
//

#define KeGetPcr() PCR

//
// Get address of current kernel thread object.
//

#if defined(_M_IA64)
#define KeGetCurrentThread() PCR->CurrentThread
#endif

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() ((ULONG)(PCR->Number))

//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() PCR->DcacheFillSize

// end_ntddk end_nthal end_ntosp

//
// Test if executing a DPC.
//


BOOLEAN
KeIsExecutingDpc (
    VOID
    );


//
// Save & Restore floating point state
//
// begin_ntddk begin_wdm begin_ntosp

#define KeSaveFloatingPointState(a)         STATUS_SUCCESS
#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS

// end_ntddk end_wdm end_ntosp

// begin_ntddk begin_nthal begin_ntndis begin_wdm begin_ntosp


//
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses generated by the compiler.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier (
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_ReadWriteBarrier)

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as generated by the compiler and 
//    as seen by other processors.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KE_MEMORY_BARRIER_REQUIRED

#define KeMemoryBarrier() {_ReadWriteBarrier();__mf ();_ReadWriteBarrier();}

//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp

//
// Define the page size and shift for large pages.
//

#define LARGE_PAGE_SIZE   0x1000000
#define LARGE_PAGE_SHIFT  24L

// begin_nthal
//
// IA64 hardware structures
//


//
// A Page Table Entry on an IA64 has the following definition.
//

#define _HARDWARE_PTE_WORKING_SET_BITS  11

typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Rsvd0 : 1;
    ULONG64 Cache : 3;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 Owner : 2;
    ULONG64 Execute : 1;
    ULONG64 Write : 1;
    ULONG64 Rsvd1 : PAGE_SHIFT - 12;
    ULONG64 CopyOnWrite : 1;
    ULONG64 PageFrameNumber : 50 - PAGE_SHIFT;
    ULONG64 Rsvd2 : 2;
    ULONG64 Exception : 1;
    ULONGLONG SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Fill TB entry
//
// Filling TB entry on demand by VHPT H/W seems faster than done by s/w.
// Determining I/D side of TLB, disabling/enabling PSR.i and ic bits,
// serialization, writing to IIP, IDA, IDTR and IITR seem just too much
// compared to VHPT searching it automatically.
//

#define KiVhptEntry(va)  ((PVOID)__thash((__int64)va))
#define KiVhptEntryTag(va)  ((ULONGLONG)__ttag((__int64)va))

#define KiFlushSingleTb(va)                            \
    __ptcl((__int64)va,PAGE_SHIFT << 2);  __isrlz()

#define KeFillEntryTb( Virtual)                        \
       KiFlushSingleTb(Virtual);

#define KiFlushFixedInstTbEx(Invalid, va, pssize)   \
    __ptri((__int64)va, (pssize) << 2); __isrlz()

#define KiFlushFixedInstTb(Invalid, va)   \
    KiFlushFixedInstTbEx(Invalid, va, PAGE_SHIFT)

#define KiFlushFixedDataTbEx(Invalid, va, pssize)   \
    __ptrd((__int64)va, (pssize) << 2); __dsrlz()

#define KiFlushFixedDataTb(Invalid, va)   \
    KiFlushFixedDataTbEx(Invalid, va, PAGE_SHIFT)


NTKERNELAPI
VOID
KeFillLargeEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize
    );

//
// Fill TB fixed entry
//

NTKERNELAPI
VOID
KeFillFixedEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize,
    IN ULONG Index
    );

NTKERNELAPI
VOID
KeFillFixedLargeEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize,
    IN ULONG Index
    );

#define INST_TB_BASE 0x80000000
#define DATA_TB_BASE 0

#define INST_TB_KERNEL_INDEX          (INST_TB_BASE|ITR_KERNEL_INDEX)
#define INST_TB_EPC_INDEX             (INST_TB_BASE|ITR_EPC_INDEX)
#define INST_TB_HAL_INDEX             (INST_TB_BASE|ITR_HAL_INDEX)
#define INST_TB_PAL_INDEX             (INST_TB_BASE|ITR_PAL_INDEX)

#define DATA_TB_DRIVER0_INDEX         (DATA_TB_BASE|DTR_DRIVER0_INDEX)
#define DATA_TB_DRIVER1_INDEX         (DATA_TB_BASE|DTR_DRIVER1_INDEX)
#define DATA_TB_KTBASE_INDEX          (DATA_TB_BASE|DTR_KTBASE_INDEX)
#define DATA_TB_UTBASE_INDEX          (DATA_TB_BASE|DTR_UTBASE_INDEX)
#define DATA_TB_STBASE_INDEX          (DATA_TB_BASE|DTR_STBASE_INDEX)
#define DATA_TB_IOPORT_INDEX          (DATA_TB_BASE|DTR_IO_PORT_INDEX)
#define DATA_TB_KTBASE_TMP_INDEX      (DATA_TB_BASE|DTR_KTBASE_INDEX_TMP)
#define DATA_TB_UTBASE_TMP_INDEX      (DATA_TB_BASE|DTR_UTBASE_INDEX_TMP)
#define DATA_TB_HAL_INDEX             (DATA_TB_BASE|DTR_HAL_INDEX)
#define DATA_TB_PAL_INDEX             (DATA_TB_BASE|DTR_PAL_INDEX)

//
// Fill Inst TB entry
//

NTKERNELAPI
VOID
KeFillInstEntryTb (
    IN HARDWARE_PTE Pte,
    IN PVOID Virtual
    );

NTKERNELAPI
VOID
KeFlushCurrentTb (
    VOID
    );


#define KiFlushProcessTb() \
    KeFlushEntireTb(FALSE, TRUE);

//
// Get a VHPT entry address
//

PVOID
KiVhptEntry64(
   IN ULONG VirtualPageNumber
   );

//
// Get a VHPT entry TAG value
//

ULONGLONG
KiVhptEntryTag64(
    IN ULONG VirtualPageNumber
    );

//
// Fill a VHPT entry
//

VOID
KiFillEntryVhpt(
   IN PHARDWARE_PTE PointerPte,
   IN PVOID Virtual
   );


//
// Flush the kernel portions of Tb
//


VOID
KeFlushKernelTb(
    IN BOOLEAN AllProcessors
    );

//
// Flush the user portions of Tb
//

VOID
KeFlushUserTb(
    IN BOOLEAN AllProcessors
    );



//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

NTKERNELAPI
VOID
KeChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    );

NTKERNELAPI
VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    );

#define KeSweepCurrentDcache()

NTKERNELAPI
VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    );

NTKERNELAPI
VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

NTKERNELAPI
VOID
KeSweepCurrentIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

NTKERNELAPI
VOID
KeSweepCurrentIcache();

NTKERNELAPI
VOID
KeSweepCacheRangeWithDrain (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    );

// begin_ntddk begin_ntndis begin_wdm begin_ntosp
//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// end_ntddk end_ntndis end_wdm end_ntosp

//
// Clock, profile, and interprocessor interrupt functions.
//

struct _KEXCEPTION_FRAME;
struct _KTRAP_FRAME;

NTKERNELAPI
VOID
KeIpiInterrupt (
    IN struct _KTRAP_FRAME *TrapFrame
    );

#define KeYieldProcessor __yield

NTKERNELAPI
VOID
KeProfileInterrupt (
    IN struct _KTRAP_FRAME *TrapFrame
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

NTKERNELAPI
VOID
KeUpdateRunTime (
    IN struct _KTRAP_FRAME *TrapFrame
    );

NTKERNELAPI
VOID
KeUpdateSystemTime (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN ULONG Increment
    );

//
// The following function prototypes are exported for use in MP HALs.
//

#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)

#else

NTKERNELAPI
VOID
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(NT_UP)

#define KiReleaseSpinLock(SpinLock)

#else

VOID
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#ifndef CAPKERN_SYNCH_POINTS
#define KiReleaseSpinLock _ReleaseSpinLock
#endif

#endif // !defined(NT_UP)

//
// Define cache error routine type and prototype.
//

typedef
VOID
(*PKCACHE_ERROR_ROUTINE) (
    VOID
    );

NTKERNELAPI
VOID
KeSetCacheErrorRoutine (
    IN PKCACHE_ERROR_ROUTINE Routine
    );

// begin_ntddk begin_wdm

//
// Kernel breakin breakpoint
//

VOID
KeBreakinBreakpoint (
    VOID
    );

// end_ntddk end_nthal end_wdm

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//

#if defined(NT_UP) && !defined(_NTDDK_) && !defined(_NTIFS_)
#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrql(DISPATCH_LEVEL, (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)
#else

// begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk end_ntosp

#endif

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IA64)

VOID
_disable (
    VOID
    );

VOID
_enable (
    VOID
    );

#pragma intrinsic(_disable)
#pragma intrinsic(_enable)

#endif

#if defined(NT_UP) && !DBG
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// Data and instruction bus error function prototypes.
//

BOOLEAN
KeBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame,
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

VOID
KiDataBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiInstructionBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

// end_wdm

#else

// end_ntddk end_nthal end_ntosp

//
// Define query tick count macro.
//

#define KiQueryTickCount(CurrentCount) \
    *(PULONGLONG)(CurrentCount) = KeTickCount.QuadPart;

//
// Define query interrupt time macro.
//

#define KiQueryInterruptTime(CurrentTime) {                                 \
    C_ASSERT((FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) & 7) == 0);    \
    ((PLARGE_INTEGER)(CurrentTime))->QuadPart = *(volatile LONG64 *)(&SharedUserData->InterruptTime); \
}

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp

//
// The following function prototypes must be in the module since they are
// machine dependent.
//

ULONG
KiEmulateBranch (
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiEmulateFloating (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

ULONGLONG
KiGetRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiSetRegisterValue (
    IN ULONG Register,
    IN ULONGLONG Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    );

FLOAT128
KiGetFloatRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiSetFloatRegisterValue (
    IN ULONG Register,
    IN FLOAT128 Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiAdvanceInstPointer(
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiRequestSoftwareInterrupt (
    KIRQL RequestIrql
    );

// begin_ntddk begin_nthal begin_ntndis begin_wdm begin_ntosp
//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

// end_ntddk end_ntndis end_wdm end_ntosp



//
// Higher FP volatile
//
//  This structure defines the higher FP volatile registers.
//

typedef struct _KHIGHER_FP_VOLATILE {
    // volatile higher floating registers f32 - f127
    FLOAT128 FltF32;
    FLOAT128 FltF33;
    FLOAT128 FltF34;
    FLOAT128 FltF35;
    FLOAT128 FltF36;
    FLOAT128 FltF37;
    FLOAT128 FltF38;
    FLOAT128 FltF39;
    FLOAT128 FltF40;
    FLOAT128 FltF41;
    FLOAT128 FltF42;
    FLOAT128 FltF43;
    FLOAT128 FltF44;
    FLOAT128 FltF45;
    FLOAT128 FltF46;
    FLOAT128 FltF47;
    FLOAT128 FltF48;
    FLOAT128 FltF49;
    FLOAT128 FltF50;
    FLOAT128 FltF51;
    FLOAT128 FltF52;
    FLOAT128 FltF53;
    FLOAT128 FltF54;
    FLOAT128 FltF55;
    FLOAT128 FltF56;
    FLOAT128 FltF57;
    FLOAT128 FltF58;
    FLOAT128 FltF59;
    FLOAT128 FltF60;
    FLOAT128 FltF61;
    FLOAT128 FltF62;
    FLOAT128 FltF63;
    FLOAT128 FltF64;
    FLOAT128 FltF65;
    FLOAT128 FltF66;
    FLOAT128 FltF67;
    FLOAT128 FltF68;
    FLOAT128 FltF69;
    FLOAT128 FltF70;
    FLOAT128 FltF71;
    FLOAT128 FltF72;
    FLOAT128 FltF73;
    FLOAT128 FltF74;
    FLOAT128 FltF75;
    FLOAT128 FltF76;
    FLOAT128 FltF77;
    FLOAT128 FltF78;
    FLOAT128 FltF79;
    FLOAT128 FltF80;
    FLOAT128 FltF81;
    FLOAT128 FltF82;
    FLOAT128 FltF83;
    FLOAT128 FltF84;
    FLOAT128 FltF85;
    FLOAT128 FltF86;
    FLOAT128 FltF87;
    FLOAT128 FltF88;
    FLOAT128 FltF89;
    FLOAT128 FltF90;
    FLOAT128 FltF91;
    FLOAT128 FltF92;
    FLOAT128 FltF93;
    FLOAT128 FltF94;
    FLOAT128 FltF95;
    FLOAT128 FltF96;
    FLOAT128 FltF97;
    FLOAT128 FltF98;
    FLOAT128 FltF99;
    FLOAT128 FltF100;
    FLOAT128 FltF101;
    FLOAT128 FltF102;
    FLOAT128 FltF103;
    FLOAT128 FltF104;
    FLOAT128 FltF105;
    FLOAT128 FltF106;
    FLOAT128 FltF107;
    FLOAT128 FltF108;
    FLOAT128 FltF109;
    FLOAT128 FltF110;
    FLOAT128 FltF111;
    FLOAT128 FltF112;
    FLOAT128 FltF113;
    FLOAT128 FltF114;
    FLOAT128 FltF115;
    FLOAT128 FltF116;
    FLOAT128 FltF117;
    FLOAT128 FltF118;
    FLOAT128 FltF119;
    FLOAT128 FltF120;
    FLOAT128 FltF121;
    FLOAT128 FltF122;
    FLOAT128 FltF123;
    FLOAT128 FltF124;
    FLOAT128 FltF125;
    FLOAT128 FltF126;
    FLOAT128 FltF127;

} KHIGHER_FP_VOLATILE, *PKHIGHER_FP_VOLATILE;

//
// Debug registers
//
// This structure defines the hardware debug registers.
// We allow space for 4 pairs of instruction and 4 pairs of data debug registers
// The hardware may actually have more.
//

typedef struct _KDEBUG_REGISTERS {

    ULONGLONG DbI0;
    ULONGLONG DbI1;
    ULONGLONG DbI2;
    ULONGLONG DbI3;
    ULONGLONG DbI4;
    ULONGLONG DbI5;
    ULONGLONG DbI6;
    ULONGLONG DbI7;

    ULONGLONG DbD0;
    ULONGLONG DbD1;
    ULONGLONG DbD2;
    ULONGLONG DbD3;
    ULONGLONG DbD4;
    ULONGLONG DbD5;
    ULONGLONG DbD6;
    ULONGLONG DbD7;

} KDEBUG_REGISTERS, *PKDEBUG_REGISTERS;

//
// misc. application registers (mapped to IA-32 registers)
//

typedef struct _KAPPLICATION_REGISTERS {
    ULONGLONG Ar21;
    ULONGLONG Ar24;
    ULONGLONG Unused;  // AR 25 is now treated as a volitile register.
    ULONGLONG Ar26;
    ULONGLONG Ar27;
    ULONGLONG Ar28;
    ULONGLONG Ar29;
    ULONGLONG Ar30;
} KAPPLICATION_REGISTERS, *PKAPPLICATION_REGISTERS;

//
// performance registers
//

typedef struct _KPERFORMANCE_REGISTERS {
    ULONGLONG Perfr0;
    ULONGLONG Perfr1;
    ULONGLONG Perfr2;
    ULONGLONG Perfr3;
    ULONGLONG Perfr4;
    ULONGLONG Perfr5;
    ULONGLONG Perfr6;
    ULONGLONG Perfr7;
} KPERFORMANCE_REGISTERS, *PKPERFORMANCE_REGISTERS;

//
// Thread State save area. Currently, beginning of Kernel Stack
//
// This structure defines the area for:
//
//      higher fp register save/restore
//      user debug register save/restore.
//
// The order of these area is significant.
//

typedef struct _KTHREAD_STATE_SAVEAREA {

    KAPPLICATION_REGISTERS AppRegisters;
    KPERFORMANCE_REGISTERS PerfRegisters;
    KHIGHER_FP_VOLATILE HigherFPVolatile;
    KDEBUG_REGISTERS DebugRegisters;

} KTHREAD_STATE_SAVEAREA, *PKTHREAD_STATE_SAVEAREA;

#define KTHREAD_STATE_SAVEAREA_LENGTH ((sizeof(KTHREAD_STATE_SAVEAREA) + 15) & ~((ULONG_PTR)15))

#define GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(StackBase)     \
    (PKHIGHER_FP_VOLATILE) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->HigherFPVolatile)

#define GET_DEBUG_REGISTER_SAVEAREA()                       \
    (PKDEBUG_REGISTERS) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)KeGetCurrentThread()->StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->DebugRegisters)

#define GET_APPLICATION_REGISTER_SAVEAREA(StackBase)     \
    (PKAPPLICATION_REGISTERS) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->AppRegisters)


//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all preserved registers. The volatile registers will already
//  have been saved in a trap frame. Also used as part of switch frame built
//  at thread switch.
//
//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,
//

typedef struct _KEXCEPTION_FRAME {


    // Preserved application registers
    ULONGLONG ApEC;       // epilogue count
    ULONGLONG ApLC;       // loop count
    ULONGLONG IntNats;    // Nats for S0-S3; i.e. ar.UNAT after spill

    // Preserved (saved) interger registers, s0-s3
    ULONGLONG IntS0;
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;

    // Preserved (saved) branch registers, bs0-bs4
    ULONGLONG BrS0;
    ULONGLONG BrS1;
    ULONGLONG BrS2;
    ULONGLONG BrS3;
    ULONGLONG BrS4;

    // Preserved (saved) floating point registers, f2 - f5, f16 - f31
    FLOAT128 FltS0;
    FLOAT128 FltS1;
    FLOAT128 FltS2;
    FLOAT128 FltS3;
    FLOAT128 FltS4;
    FLOAT128 FltS5;
    FLOAT128 FltS6;
    FLOAT128 FltS7;
    FLOAT128 FltS8;
    FLOAT128 FltS9;
    FLOAT128 FltS10;
    FLOAT128 FltS11;
    FLOAT128 FltS12;
    FLOAT128 FltS13;
    FLOAT128 FltS14;
    FLOAT128 FltS15;
    FLOAT128 FltS16;
    FLOAT128 FltS17;
    FLOAT128 FltS18;
    FLOAT128 FltS19;


} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;


//
// Switch frame
//
//  This frame is established when doing a thread switch in SwapContext. It
//  provides a place to save the preserved kernel state at the point of the
//  switch registers.
//  The volatile registers are scratch across the call to SwapContext.
//
//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,
//

typedef struct _KSWITCH_FRAME {

    ULONGLONG SwitchPredicates; // Predicates for Switch
    ULONGLONG SwitchRp;         // return pointer for Switch
    ULONGLONG SwitchPFS;        // PFS for Switch
    ULONGLONG SwitchFPSR;   // ProcessorFP status at thread switch
    ULONGLONG SwitchBsp;
    ULONGLONG SwitchRnat;
    // ULONGLONG Pad;

    KEXCEPTION_FRAME SwitchExceptionFrame;

} KSWITCH_FRAME, *PKSWITCH_FRAME;

// Trap frame
//  This frame is established when handling a trap. It provides a place to
//  save all volatile registers. The nonvolatile registers are saved in an
//  exception frame or through the normal C calling conventions for saved
//  registers.  Its size must be a multiple of 16 bytes.
//
//  N.B - the 16-byte alignment is required to maintain the stack alignment.
//

#define KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args


typedef struct _KTRAP_FRAME {

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //

    ULONGLONG Reserved[(KTRAP_FRAME_ARGUMENTS+16)/8];

    // Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel)
    FLOAT128 FltT0;
    FLOAT128 FltT1;
    FLOAT128 FltT2;
    FLOAT128 FltT3;
    FLOAT128 FltT4;
    FLOAT128 FltT5;
    FLOAT128 FltT6;
    FLOAT128 FltT7;
    FLOAT128 FltT8;
    FLOAT128 FltT9;

    // Temporary (volatile) interger registers
    ULONGLONG IntGp;    // global pointer (r1)
    ULONGLONG IntT0;
    ULONGLONG IntT1;
                        // The following 4 registers fill in space of preserved  (S0-S3) to align Nats
    ULONGLONG ApUNAT;   // ar.UNAT on kernel entry
    ULONGLONG ApCCV;    // ar.CCV
    ULONGLONG SegCSD;   // Second register for 16 byte values
    ULONGLONG Preds;    // Predicates

    ULONGLONG IntV0;    // return value (r8)
    ULONGLONG IntT2;
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;    // stack pointer (r12)
    ULONGLONG IntTeb;   // teb (r13)
    ULONGLONG IntT5;
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG IntNats;  // Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill

    ULONGLONG BrRp;     // Return pointer on kernel entry

    ULONGLONG BrT0;     // Temporary (volatile) branch registers (b6-b7)
    ULONGLONG BrT1;

    // Register stack info
    ULONGLONG RsRSC;    // RSC on kernel entry
    ULONGLONG RsBSP;    // BSP on kernel entry
    ULONGLONG RsBSPSTORE; // User BSP Store at point of switch to kernel backing store
    ULONGLONG RsRNAT;   // old RNAT at point of switch to kernel backing store
    ULONGLONG RsPFS;    // PFS on kernel entry

    // Trap Status Information
    ULONGLONG StIPSR;   // Interruption Processor Status Register
    ULONGLONG StIIP;    // Interruption IP
    ULONGLONG StIFS;    // Interruption Function State
    ULONGLONG StFPSR;   // FP status
    ULONGLONG StISR;    // Interruption Status Register
    ULONGLONG StIFA;    // Interruption Data Address
    ULONGLONG StIIPA;   // Last executed bundle address
    ULONGLONG StIIM;    // Interruption Immediate
    ULONGLONG StIHA;    // Interruption Hash Address

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONGLONG TrapFrame;// Previous Trap Frame

    //
    // Exception record
    //
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

    // End of frame marker (for debugging)
    ULONGLONG NewBSP;  // NewBSP  When a stack switch occur this is the value of the new BSP
    ULONGLONG EOFMarker;
} KTRAP_FRAME, *PKTRAP_FRAME;

#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 15) & (~15))
#define KTRAP_FRAME_ALIGN (16)
#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)
#define KTRAP_FRAME_EOF 0xe0f0e0f0e0f0e000i64

//
// Use the lowest 4 bits of EOFMarker field to encode the trap frame type
//

#define SYSCALL_FRAME      0
#define INTERRUPT_FRAME    1
#define EXCEPTION_FRAME    2
#define CONTEXT_FRAME      10
#define MODIFIED_FRAME     0x20

#define TRAP_FRAME_TYPE(tf)  (tf->EOFMarker & 0xf)

//
// Define the kernel mode and user mode callback frame structures.
//

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//
// N.B. The size of the following structure must be a multiple of 16 bytes
//      and it must be 16-byte aligned.
//

typedef struct _KCALLOUT_FRAME {


    ULONGLONG   BrRp;
    ULONGLONG   RsPFS;
    ULONGLONG   Preds;
    ULONGLONG   ApUNAT;
    ULONGLONG   ApLC;
    ULONGLONG   RsRNAT;
    ULONGLONG   IntNats;

    ULONGLONG   IntS0;
    ULONGLONG   IntS1;
    ULONGLONG   IntS2;
    ULONGLONG   IntS3;

    ULONGLONG   BrS0;
    ULONGLONG   BrS1;
    ULONGLONG   BrS2;
    ULONGLONG   BrS3;
    ULONGLONG   BrS4;

    FLOAT128    FltS0;          // 16-byte aligned boundary
    FLOAT128    FltS1;
    FLOAT128    FltS2;
    FLOAT128    FltS3;
    FLOAT128    FltS4;
    FLOAT128    FltS5;
    FLOAT128    FltS6;
    FLOAT128    FltS7;
    FLOAT128    FltS8;
    FLOAT128    FltS9;
    FLOAT128    FltS10;
    FLOAT128    FltS11;
    FLOAT128    FltS12;
    FLOAT128    FltS13;
    FLOAT128    FltS14;
    FLOAT128    FltS15;
    FLOAT128    FltS16;
    FLOAT128    FltS17;
    FLOAT128    FltS18;
    FLOAT128    FltS19;

    ULONGLONG   A0;             // saved argument registers a0-a2
    ULONGLONG   A1;
    ULONGLONG   CbStk;          // saved callback stack address
    ULONGLONG   InStack;        // saved initial stack address
    ULONGLONG   CbBStore;       // saved callback stack address
    ULONGLONG   InBStore;       // saved initial stack address
    ULONGLONG   TrFrame;        // saved callback trap frame address
    ULONGLONG   TrStIIP;        // saved continuation address


} KCALLOUT_FRAME, *PKCALLOUT_FRAME;


typedef struct _UCALLOUT_FRAME {
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    ULONGLONG IntSp;
    ULONGLONG RsPFS;
    ULONGLONG BrRp;
    ULONGLONG Pad;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;


// end_nthal

// begin_ntddk begin_wdm begin_ntosp
//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONG   Reserved;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp

#define STATUS_IA64_INVALID_STACK     STATUS_BAD_STACK

//
// iA32 control bits definition
//
//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// Define constants to access CFLG bits
//
#define CFLG_IO 0x00000040          // IO bit map checking on
#define CFLG_IF 0x00000080          // EFLAG.if to control external interrupt
#define CFLG_II 0x00000100          // enable EFLAG.if interception

//
// CR4 bits;  These only apply to Pentium
//
#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// begin_nthal
//
// Machine type definitions
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

//
// PAL Interface
//
// iA-64 defined PAL function IDs in decimal format as in the PAL spec
// All PAL calls done through HAL. HAL may block some calls
//

#define PAL_CACHE_FLUSH                                       1I64
#define PAL_CACHE_INFO                                        2I64
#define PAL_CACHE_INIT                                        3I64
#define PAL_CACHE_SUMMARY                                     4I64
#define PAL_PTCE_INFO                                         6I64
#define PAL_MEM_ATTRIB                                        5I64
#define PAL_VM_INFO                                           7I64
#define PAL_VM_SUMMARY                                        8I64
#define PAL_BUS_GET_FEATURES                                  9I64
#define PAL_BUS_SET_FEATURES                                 10I64
#define PAL_DEBUG_INFO                                       11I64
#define PAL_FIXED_ADDR                                       12I64
#define PAL_FREQ_BASE                                        13I64
#define PAL_FREQ_RATIOS                                      14I64
#define PAL_PERF_MON_INFO                                    15I64
#define PAL_PLATFORM_ADDR                                    16I64
#define PAL_PROC_GET_FEATURES                                17I64
#define PAL_PROC_SET_FEATURES                                18I64
#define PAL_RSE_INFO                                         19I64
#define PAL_VERSION                                          20I64
#define PAL_MC_CLEAR_LOG                                     21I64
#define PAL_MC_DRAIN                                         22I64
#define PAL_MC_EXPECTED                                      23I64
#define PAL_MC_DYNAMIC_STATE                                 24I64
#define PAL_MC_ERROR_INFO                                    25I64
#define PAL_MC_RESUME                                        26I64
#define PAL_MC_REGISTER_MEM                                  27I64
#define PAL_HALT                                             28I64
#define PAL_HALT_LIGHT                                       29I64
#define PAL_COPY_INFO                                        30I64
#define PAL_CACHE_LINE_INIT                                  31I64
#define PAL_PMI_ENTRYPOINT                                   32I64
#define PAL_ENTER_IA_32_ENV                                  33I64
#define PAL_VM_PAGE_SIZE                                     34I64
#define PAL_MEM_FOR_TEST                                     37I64
#define PAL_CACHE_PROT_INFO                                  38I64
#define PAL_REGISTER_INFO                                    39I64
#define PAL_SHUTDOWN                                         44I64
#define PAL_PREFETCH_VISIBILITY                              41I64

#define PAL_COPY_PAL                                        256I64
#define PAL_HALT_INFO                                       257I64
#define PAL_TEST_PROC                                       258I64
#define PAL_CACHE_READ                                      259I64
#define PAL_CACHE_WRITE                                     260I64
#define PAL_VM_TR_READ                                      261I64

//
// iA-64 defined PAL return values
//

#define PAL_STATUS_INVALID_CACHELINE                          1I64
#define PAL_STATUS_SUPPORT_NOT_NEEDED                         1I64
#define PAL_STATUS_SUCCESS                                    0
#define PAL_STATUS_NOT_IMPLEMENTED                           -1I64
#define PAL_STATUS_INVALID_ARGUMENT                          -2I64
#define PAL_STATUS_ERROR                                     -3I64
#define PAL_STATUS_UNABLE_TO_INIT_CACHE_LEVEL_AND_TYPE       -4I64
#define PAL_STATUS_NOT_FOUND_IN_CACHE                        -5I64
#define PAL_STATUS_NO_ERROR_INFO_AVAILABLE                   -6I64


// end_nthal


//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1
#define RPL_MASK     3

//
// SetProcessInformation Structure for ProcessSetIoHandlers info class
//

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;

//
// Used for cleaning up ia32 contexts
// This is taken from i386.h
//
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L


// begin_windbgkd begin_nthal

#ifdef _IA64_

//
// Stack Registers for IA64
//

typedef struct _STACK_REGISTERS {


    ULONGLONG IntR32;
    ULONGLONG IntR33;
    ULONGLONG IntR34;
    ULONGLONG IntR35;
    ULONGLONG IntR36;
    ULONGLONG IntR37;
    ULONGLONG IntR38;
    ULONGLONG IntR39;

    ULONGLONG IntR40;
    ULONGLONG IntR41;
    ULONGLONG IntR42;
    ULONGLONG IntR43;
    ULONGLONG IntR44;
    ULONGLONG IntR45;
    ULONGLONG IntR46;
    ULONGLONG IntR47;
    ULONGLONG IntR48;
    ULONGLONG IntR49;

    ULONGLONG IntR50;
    ULONGLONG IntR51;
    ULONGLONG IntR52;
    ULONGLONG IntR53;
    ULONGLONG IntR54;
    ULONGLONG IntR55;
    ULONGLONG IntR56;
    ULONGLONG IntR57;
    ULONGLONG IntR58;
    ULONGLONG IntR59;

    ULONGLONG IntR60;
    ULONGLONG IntR61;
    ULONGLONG IntR62;
    ULONGLONG IntR63;
    ULONGLONG IntR64;
    ULONGLONG IntR65;
    ULONGLONG IntR66;
    ULONGLONG IntR67;
    ULONGLONG IntR68;
    ULONGLONG IntR69;

    ULONGLONG IntR70;
    ULONGLONG IntR71;
    ULONGLONG IntR72;
    ULONGLONG IntR73;
    ULONGLONG IntR74;
    ULONGLONG IntR75;
    ULONGLONG IntR76;
    ULONGLONG IntR77;
    ULONGLONG IntR78;
    ULONGLONG IntR79;

    ULONGLONG IntR80;
    ULONGLONG IntR81;
    ULONGLONG IntR82;
    ULONGLONG IntR83;
    ULONGLONG IntR84;
    ULONGLONG IntR85;
    ULONGLONG IntR86;
    ULONGLONG IntR87;
    ULONGLONG IntR88;
    ULONGLONG IntR89;

    ULONGLONG IntR90;
    ULONGLONG IntR91;
    ULONGLONG IntR92;
    ULONGLONG IntR93;
    ULONGLONG IntR94;
    ULONGLONG IntR95;
    ULONGLONG IntR96;
    ULONGLONG IntR97;
    ULONGLONG IntR98;
    ULONGLONG IntR99;

    ULONGLONG IntR100;
    ULONGLONG IntR101;
    ULONGLONG IntR102;
    ULONGLONG IntR103;
    ULONGLONG IntR104;
    ULONGLONG IntR105;
    ULONGLONG IntR106;
    ULONGLONG IntR107;
    ULONGLONG IntR108;
    ULONGLONG IntR109;

    ULONGLONG IntR110;
    ULONGLONG IntR111;
    ULONGLONG IntR112;
    ULONGLONG IntR113;
    ULONGLONG IntR114;
    ULONGLONG IntR115;
    ULONGLONG IntR116;
    ULONGLONG IntR117;
    ULONGLONG IntR118;
    ULONGLONG IntR119;

    ULONGLONG IntR120;
    ULONGLONG IntR121;
    ULONGLONG IntR122;
    ULONGLONG IntR123;
    ULONGLONG IntR124;
    ULONGLONG IntR125;
    ULONGLONG IntR126;
    ULONGLONG IntR127;
                                 // Nat bits for stack registers
    ULONGLONG IntNats2;          // r32-r95 in bit positions 1 to 63
    ULONGLONG IntNats3;          // r96-r127 in bit position 1 to 31


} STACK_REGISTERS, *PSTACK_REGISTERS;



//
// Special Registers for IA64
//

typedef struct _KSPECIAL_REGISTERS {

    // Kernel debug breakpoint registers

    ULONGLONG KernelDbI0;         // Instruction debug registers
    ULONGLONG KernelDbI1;
    ULONGLONG KernelDbI2;
    ULONGLONG KernelDbI3;
    ULONGLONG KernelDbI4;
    ULONGLONG KernelDbI5;
    ULONGLONG KernelDbI6;
    ULONGLONG KernelDbI7;

    ULONGLONG KernelDbD0;         // Data debug registers
    ULONGLONG KernelDbD1;
    ULONGLONG KernelDbD2;
    ULONGLONG KernelDbD3;
    ULONGLONG KernelDbD4;
    ULONGLONG KernelDbD5;
    ULONGLONG KernelDbD6;
    ULONGLONG KernelDbD7;

    // Kernel performance monitor registers

    ULONGLONG KernelPfC0;         // Performance configuration registers
    ULONGLONG KernelPfC1;
    ULONGLONG KernelPfC2;
    ULONGLONG KernelPfC3;
    ULONGLONG KernelPfC4;
    ULONGLONG KernelPfC5;
    ULONGLONG KernelPfC6;
    ULONGLONG KernelPfC7;

    ULONGLONG KernelPfD0;         // Performance data registers
    ULONGLONG KernelPfD1;
    ULONGLONG KernelPfD2;
    ULONGLONG KernelPfD3;
    ULONGLONG KernelPfD4;
    ULONGLONG KernelPfD5;
    ULONGLONG KernelPfD6;
    ULONGLONG KernelPfD7;

    // kernel bank shadow (hidden) registers

    ULONGLONG IntH16;
    ULONGLONG IntH17;
    ULONGLONG IntH18;
    ULONGLONG IntH19;
    ULONGLONG IntH20;
    ULONGLONG IntH21;
    ULONGLONG IntH22;
    ULONGLONG IntH23;
    ULONGLONG IntH24;
    ULONGLONG IntH25;
    ULONGLONG IntH26;
    ULONGLONG IntH27;
    ULONGLONG IntH28;
    ULONGLONG IntH29;
    ULONGLONG IntH30;
    ULONGLONG IntH31;

    // Application Registers

    //       - CPUID Registers - AR
    ULONGLONG ApCPUID0; // Cpuid Register 0
    ULONGLONG ApCPUID1; // Cpuid Register 1
    ULONGLONG ApCPUID2; // Cpuid Register 2
    ULONGLONG ApCPUID3; // Cpuid Register 3
    ULONGLONG ApCPUID4; // Cpuid Register 4
    ULONGLONG ApCPUID5; // Cpuid Register 5
    ULONGLONG ApCPUID6; // Cpuid Register 6
    ULONGLONG ApCPUID7; // Cpuid Register 7

    //       - Kernel Registers - AR
    ULONGLONG ApKR0;    // Kernel Register 0 (User RO)
    ULONGLONG ApKR1;    // Kernel Register 1 (User RO)
    ULONGLONG ApKR2;    // Kernel Register 2 (User RO)
    ULONGLONG ApKR3;    // Kernel Register 3 (User RO)
    ULONGLONG ApKR4;    // Kernel Register 4
    ULONGLONG ApKR5;    // Kernel Register 5
    ULONGLONG ApKR6;    // Kernel Register 6
    ULONGLONG ApKR7;    // Kernel Register 7

    ULONGLONG ApITC;    // Interval Timer Counter

    // Global control registers

    ULONGLONG ApITM;    // Interval Timer Match register
    ULONGLONG ApIVA;    // Interrupt Vector Address
    ULONGLONG ApPTA;    // Page Table Address
    ULONGLONG ApGPTA;   // ia32 Page Table Address

    ULONGLONG StISR;    // Interrupt status
    ULONGLONG StIFA;    // Interruption Faulting Address
    ULONGLONG StITIR;   // Interruption TLB Insertion Register
    ULONGLONG StIIPA;   // Interruption Instruction Previous Address (RO)
    ULONGLONG StIIM;    // Interruption Immediate register (RO)
    ULONGLONG StIHA;    // Interruption Hash Address (RO)

    //       - External Interrupt control registers (SAPIC)
    ULONGLONG SaLID;    // Local SAPIC ID
    ULONGLONG SaIVR;    // Interrupt Vector Register (RO)
    ULONGLONG SaTPR;    // Task Priority Register
    ULONGLONG SaEOI;    // End Of Interrupt
    ULONGLONG SaIRR0;   // Interrupt Request Register 0 (RO)
    ULONGLONG SaIRR1;   // Interrupt Request Register 1 (RO)
    ULONGLONG SaIRR2;   // Interrupt Request Register 2 (RO)
    ULONGLONG SaIRR3;   // Interrupt Request Register 3 (RO)
    ULONGLONG SaITV;    // Interrupt Timer Vector
    ULONGLONG SaPMV;    // Performance Monitor Vector
    ULONGLONG SaCMCV;   // Corrected Machine Check Vector
    ULONGLONG SaLRR0;   // Local Interrupt Redirection Vector 0
    ULONGLONG SaLRR1;   // Local Interrupt Redirection Vector 1

    // System Registers
    //       - Region registers
    ULONGLONG Rr0;  // Region register 0
    ULONGLONG Rr1;  // Region register 1
    ULONGLONG Rr2;  // Region register 2
    ULONGLONG Rr3;  // Region register 3
    ULONGLONG Rr4;  // Region register 4
    ULONGLONG Rr5;  // Region register 5
    ULONGLONG Rr6;  // Region register 6
    ULONGLONG Rr7;  // Region register 7

    //      - Protection Key registers
    ULONGLONG Pkr0;     // Protection Key register 0
    ULONGLONG Pkr1;     // Protection Key register 1
    ULONGLONG Pkr2;     // Protection Key register 2
    ULONGLONG Pkr3;     // Protection Key register 3
    ULONGLONG Pkr4;     // Protection Key register 4
    ULONGLONG Pkr5;     // Protection Key register 5
    ULONGLONG Pkr6;     // Protection Key register 6
    ULONGLONG Pkr7;     // Protection Key register 7
    ULONGLONG Pkr8;     // Protection Key register 8
    ULONGLONG Pkr9;     // Protection Key register 9
    ULONGLONG Pkr10;    // Protection Key register 10
    ULONGLONG Pkr11;    // Protection Key register 11
    ULONGLONG Pkr12;    // Protection Key register 12
    ULONGLONG Pkr13;    // Protection Key register 13
    ULONGLONG Pkr14;    // Protection Key register 14
    ULONGLONG Pkr15;    // Protection Key register 15

    //      -  Translation Lookaside buffers
    ULONGLONG TrI0;     // Instruction Translation Register 0
    ULONGLONG TrI1;     // Instruction Translation Register 1
    ULONGLONG TrI2;     // Instruction Translation Register 2
    ULONGLONG TrI3;     // Instruction Translation Register 3
    ULONGLONG TrI4;     // Instruction Translation Register 4
    ULONGLONG TrI5;     // Instruction Translation Register 5
    ULONGLONG TrI6;     // Instruction Translation Register 6
    ULONGLONG TrI7;     // Instruction Translation Register 7

    ULONGLONG TrD0;     // Data Translation Register 0
    ULONGLONG TrD1;     // Data Translation Register 1
    ULONGLONG TrD2;     // Data Translation Register 2
    ULONGLONG TrD3;     // Data Translation Register 3
    ULONGLONG TrD4;     // Data Translation Register 4
    ULONGLONG TrD5;     // Data Translation Register 5
    ULONGLONG TrD6;     // Data Translation Register 6
    ULONGLONG TrD7;     // Data Translation Register 7

    //      -  Machine Specific Registers
    ULONGLONG SrMSR0;   // Machine Specific Register 0
    ULONGLONG SrMSR1;   // Machine Specific Register 1
    ULONGLONG SrMSR2;   // Machine Specific Register 2
    ULONGLONG SrMSR3;   // Machine Specific Register 3
    ULONGLONG SrMSR4;   // Machine Specific Register 4
    ULONGLONG SrMSR5;   // Machine Specific Register 5
    ULONGLONG SrMSR6;   // Machine Specific Register 6
    ULONGLONG SrMSR7;   // Machine Specific Register 7

} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;


//
// Processor State structure.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _IA64_

// end_windbgkd 

//
// DPC data structure definition.
//

typedef struct _KDPC_DATA {
    LIST_ENTRY DpcListHead;
    KSPIN_LOCK DpcLock;
    volatile ULONG DpcQueueDepth;
    ULONG DpcCount;
} KDPC_DATA, *PKDPC_DATA;

//
// Processor Control Block (PRCB)
//

#define PRCB_MINOR_VERSION 1
#define PRCB_MAJOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

struct _RESTART_BLOCK;

typedef struct _KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
//

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *RESTRICTED_POINTER NextThread;
    struct _KTHREAD *IdleThread;
    CCHAR Number;
    CCHAR WakeIdle;
    USHORT BuildType;
    KAFFINITY SetMember;
    struct _RESTART_BLOCK *RestartBlock;
    ULONG_PTR PcrPage;
    ULONG Spare0[4];

//
// Processor Idendification Registers.
//

    ULONG     ProcessorModel;
    ULONG     ProcessorRevision;
    ULONG     ProcessorFamily;
    ULONG     ProcessorArchRev;
    ULONGLONG ProcessorSerialNumber;
    ULONGLONG ProcessorFeatureBits;
    UCHAR     ProcessorVendorString[16];

//
// Space reserved for the system.
//

    ULONGLONG SystemReserved[8];

//
// Space reserved for the HAL.
//

    ULONGLONG HalReserved[16];

//
// End of the architecturally defined section of the PRCB.
// end_nthal
//

    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG InterruptCount;
    ULONG DispatchInterruptCount;
    ULONG DebugDpcTime;
    ULONG Spare1[4];
    ULONG PageColor;

//
// MP information.
//

    struct _KNODE *ParentNode;
    KAFFINITY MultiThreadProcessorSet;
    volatile ULONG IpiFrozen;
    struct _KPROCESSOR_STATE ProcessorState;

    PVOID Spare2[6];

//
//  Per-processor data for various hot code which resides in the
//  kernel image. Each processor is given it's own copy of the data
//  to lessen the cache impact of sharing the data between multiple
//  processors.
//

    PVOID SpareHotData[2];         // Used by PerfSetLogging

//
//  Cache manager performance counters.
// N.B. This is carefully aligned to be on a cache line boundary.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
// Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;

//
//  Reserved for future counters.
//

    ULONG ReservedCounter[8];

//
// I/O IRP float.
//

    LONG LookasideIrpFloat;


//
// Per processor lock queue entries.
//
// N.B. The following padding is such that the first lock entry falls in the
//      last 16 bytes of a cache line. This makes the dispatcher lock and
//      the other locks lie in separate cache lines.
//


    ULONGLONG Spare3[34];
    KSPIN_LOCK_QUEUE LockQueue[16];

    ULONGLONG Spare4[2];

//
// Nonpaged per processor lookaside lists.
// N.B. This is carefully aligned to be on a cache line boundary.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// MP interprocessor request packet barrier.
//
// N.B. This is carefully allocated in a different cache line from
//      the request packet.
//

    volatile KAFFINITY PacketBarrier;
    ULONGLONG  Spare5[31];
//
// MP interprocessor request packet and summary.
//
// N.B. This is carefully aligned to be on a cache line boundary.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;

// N.B. Place MHz here so we can keep alignment and size
// of this structure unchanged.
    ULONG MHz;
    ULONG Spare6;
    ULONGLONG Spare7[10];

//
// N.B. These two fields must be on a cache boundary and adjacent.
//

    volatile ULONG RequestSummary;
    volatile struct _KPRCB *SignalDone;

    ULONGLONG Spare8[14];

//
// DPC listhead, counts, and batching parameters.
// N.B. This is carefully aligned to be on a cache line boundary.
//

    KDPC_DATA DpcData[2];
    ULONG MaximumDpcQueueDepth;
    ULONG DpcRequestRate;
    ULONG MinimumDpcRate;
    ULONG DpcLastCount;
    ULONG DpcInterruptRequested;
    ULONG DpcThreadRequested;
    ULONG DpcRoutineActive;
    ULONG DpcThreadActive;
    union {
        ULONGLONG TimerHand;            // On x86 this is 32 bits and can end up being zero
        ULONGLONG TimerRequest;         // for a timer request so two field are need.
    };                                  // On IA64 we can make it the same.

    ULONG ThreadDpcEnable;
    ULONG QuantumEnd;
    LONG DpcSetEventRequest;
    ULONG AdjustDpcThreshold;
    LARGE_INTEGER StartCount;

//
// DPC thread and generic call DPC.
// N.B. This is carefully aligned to be on a cache line boundary.
//

    PVOID DpcThread;
    KEVENT DpcEvent;
    KDPC CallDpc;
    volatile BOOLEAN IdleSchedule;
    UCHAR Spare9[7];
    KSPIN_LOCK PrcbLock;
    SINGLE_LIST_ENTRY DeferredReadyListHead;
    ULONG64 Spare10[1];

//
// Per-processor ready summary and ready queues.
//
// N.B. This is carefully aligned to be on a cache line boundary.
//

    LIST_ENTRY WaitListHead;
    ULONG ReadySummary;
    ULONG SelectNextLast;
    LIST_ENTRY DispatcherReadyListHead[MAXIMUM_PRIORITY];
    ULONG64 Spare11[13];

//
// Debug & Processor Information
//

    BOOLEAN SkipTick;
    KIRQL   DebuggerSavedIRQL;

//
// Processor ID from HAL (ACPI ID/EID).
//

    USHORT ProcessorId;

//
// Processors power state
//
    PROCESSOR_POWER_STATE PowerState;

// begin_nthal 
} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// end_nthal

C_ASSERT(((FIELD_OFFSET(KPRCB, LockQueue) + sizeof(KSPIN_LOCK_QUEUE)) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PPLookasideList) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PPNPagedLookasideList) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PacketBarrier) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, CurrentPacket) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, RequestSummary) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, DpcData) & (128 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, DpcRoutineActive)) & (1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, DpcThread) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, WaitListHead) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, CcFastReadNoWait) & (128 - 1)) == 0);
C_ASSERT(sizeof(KPRCB) < PAGE_SIZE);

// begin_nthal 
//
// OS_MCA, OS_INIT HandOff State definitions
//
// Note: The following definitions *must* match the definions of the
//       corresponding SAL Revision Hand-Off structures.
//

typedef struct _SAL_HANDOFF_STATE   {
    ULONGLONG     PalProcEntryPoint;
    ULONGLONG     SalProcEntryPoint;
    ULONGLONG     SalGlobalPointer;
     LONGLONG     RendezVousResult;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     MinStateSavePtr;
} SAL_HANDOFF_STATE, *PSAL_HANDOFF_STATE;

typedef struct _OS_HANDOFF_STATE    {
    ULONGLONG     Result;
    ULONGLONG     SalGlobalPointer;
    ULONGLONG     MinStateSavePtr;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     NewContextFlag;
} OS_HANDOFF_STATE, *POS_HANDOFF_STATE;

//
// per processor OS_MCA and OS_INIT resource structure
//


#define SER_EVENT_STACK_FRAME_ENTRIES    8

typedef struct _SAL_EVENT_RESOURCES {

    SAL_HANDOFF_STATE   SalToOsHandOff;
    OS_HANDOFF_STATE    OsToSalHandOff;
    PVOID               StateDump;
    ULONGLONG           StateDumpPhysical;
    PVOID               BackStore;
    ULONGLONG           BackStoreLimit;
    PVOID               Stack;
    ULONGLONG           StackLimit;
    PULONGLONG          PTOM;
    ULONGLONG           StackFrame[SER_EVENT_STACK_FRAME_ENTRIES];
    PVOID               EventPool;
    ULONG               EventPoolSize;
} SAL_EVENT_RESOURCES, *PSAL_EVENT_RESOURCES;

//
// PAL Mini-save area, used by MCA and INIT
//

typedef struct _PAL_MINI_SAVE_AREA {
    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;

    ULONGLONG B0R16;        // Bank 0 registers 16-31
    ULONGLONG B0R17;        
    ULONGLONG B0R18;        
    ULONGLONG B0R19;        
    ULONGLONG B0R20;        
    ULONGLONG B0R21;        
    ULONGLONG B0R22;        
    ULONGLONG B0R23;        
    ULONGLONG B0R24;        
    ULONGLONG B0R25;        
    ULONGLONG B0R26;        
    ULONGLONG B0R27;        
    ULONGLONG B0R28;        
    ULONGLONG B0R29;        
    ULONGLONG B0R30;        
    ULONGLONG B0R31;        

    ULONGLONG IntT7;        // Bank 1 registers 16-31
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG Preds;        //  predicates, preserved
    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIFS;        //  Interruption Function State
    ULONGLONG XIP;          //  Event IP
    ULONGLONG XPSR;         //  Event Processor Status
    ULONGLONG XFS;          //  Event Function State
    
} PAL_MINI_SAVE_AREA, *PPAL_MINI_SAVE_AREA;

// begin_ntddk begin_ntosp

//
// Define Processor Control Region Structure.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//
    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification from PrId register.
//

    ULONG ProcessorId;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

    ULONG InterruptionCount;

//
// Space reserved for the system.
//

    ULONGLONG   SystemReserved[6];

//
// Space reserved for the HAL
//

    ULONGLONG   HalReserved[64];

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[64];
    UCHAR IrqlTable[64];

//
// External Interrupt vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Processor affinity mask.
//

    KAFFINITY SetMember;

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
//  Shadow copy of Prcb->CurrentThread for fast access
//

    struct _KTHREAD *CurrentThread;

//
// Processor number.
//

    CCHAR Number;                        // Processor Number

// end_ntddk end_ntosp

    CCHAR PollSlot;                      // Used by the clock routine track when we should break in.
    UCHAR KernelDebugActive;             // debug register active in kernel flag
    UCHAR CurrentIrql;                   // Current IRQL
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

//
// Address of per processor SAPIC EOI Table
//

    PVOID       EOITable;

//
// IA-64 Machine Check Events trackers
//

    UCHAR       InOsMca;
    UCHAR       InOsInit;
    UCHAR       InOsCmc;
    UCHAR       InOsCpe;
    ULONG       InOsULONG_Spare; // Spare ULONG
    PSAL_EVENT_RESOURCES OsMcaResourcePtr;
    PSAL_EVENT_RESOURCES OsInitResourcePtr;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

// end_nthal 

//
// OS Part
//

//
//  Address of the thread who currently owns the high fp register set
//

    struct _KTHREAD *HighFpOwner;

//  Per processor kernel (ntoskrnl.exe) global pointer
    ULONGLONG   KernelGP;
//  Per processor initial kernel stack for current thread
    ULONGLONG   InitialStack;
//  Per processor pointer to kernel BSP
    ULONGLONG   InitialBStore;
//  Per processor kernel stack limit
    ULONGLONG   StackLimit;
//  Per processor kernel backing store limit
    ULONGLONG   BStoreLimit;
//  Per processor panic kernel stack
    ULONGLONG   PanicStack;

//
//  Save area for kernel entry/exit
//
    ULONGLONG   SavedIIM;
    ULONGLONG   SavedIFA;
        
    KSPIN_LOCK  FpbLock;
    ULONGLONG   ForwardProgressBuffer[16];
    PVOID       Pcb;      // holds KPROCESS for MP region synchronization

//
//  Nt page table base addresses
//
    ULONGLONG   PteUbase;
    ULONGLONG   PteKbase;
    ULONGLONG   PteSbase;
    ULONGLONG   PdeUbase;
    ULONGLONG   PdeKbase;
    ULONGLONG   PdeSbase;
    ULONGLONG   PdeUtbase;
    ULONGLONG   PdeKtbase;
    ULONGLONG   PdeStbase;

//
//  The actual resources for the OS_INIT and OS_MCA handlers
//  are placed at the end of the PCR structure so that auto
//  can be used to get to get between the public and private
//  sections of the PCR in the traps and context routines.
//
    SAL_EVENT_RESOURCES OsMcaResource;
    SAL_EVENT_RESOURCES OsInitResource;

// begin_nthal begin_ntddk begin_ntosp

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

//
// Prototype for get current IRQL.
//

#if !(defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_)) && !defined(_BLDR_)

VOID
KiCheckForSoftwareInterrupt (
    KIRQL RequestIrql
    );

__forceinline
KIRQL
KeGetCurrentIrql()

/*++

Routine Description:

    This function return the current IRQL.

Arguments:

    None.

Return Value:

    The current IRQL is returned as the function value.

--*/

{
   return( KeGetPcr()->CurrentIrql);
}

__forceinline
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    )

/*++

Routine Description:

    This function lowers the IRQL to the specified value.

Arguments:

    NewIrql  - Supplies the new IRQL value.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() >= NewIrql);

    __setReg( CV_IA64_SaTPR, (NewIrql <<  TPR_IRQL_SHIFT));
    KeGetPcr()->CurrentIrql = NewIrql;

    //
    // If lowering below DISPATCH_LEVEL, check for pending
    // software interrupts that could run now.
    //
    
    if (NewIrql < DISPATCH_LEVEL && 
        NewIrql < KeGetPcr()->SoftwareInterruptPending ) {
        
        KiCheckForSoftwareInterrupt(NewIrql);
    }
}

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

__forceinline
KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    ) 

/*++

Routine Description:

    This function raises the current IRQL to the specified value and returns
    the previous IRQL.

Arguments:

    NewIrql (cl) - Supplies the new IRQL value.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= NewIrql);

    __setReg( CV_IA64_SaTPR, (NewIrql <<  TPR_IRQL_SHIFT));
    KeGetPcr()->CurrentIrql = NewIrql;

    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= DISPATCH_LEVEL);

    __setReg( CV_IA64_SaTPR, (DISPATCH_LEVEL <<  TPR_IRQL_SHIFT));
    KeGetPcr()->CurrentIrql = DISPATCH_LEVEL;

    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= SYNCH_LEVEL);

    __setReg( CV_IA64_SaTPR, (SYNCH_LEVEL <<  TPR_IRQL_SHIFT));
    KeGetPcr()->CurrentIrql = SYNCH_LEVEL;

    return OldIrql;
}

#else

// begin_ntddk begin_wdm begin_ntosp begin_nthal


NTKERNELAPI
KIRQL
KeGetCurrentIrql();

NTKERNELAPI
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

NTKERNELAPI
VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );

// end_wdm

NTKERNELAPI
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// end_ntddk end_ntosp end_nthal

#endif

#define KeGetContextSwitches(Prcb) (Prcb)->KeContextSwitches

// begin_nthal

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT PAGE_SHIFT

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT (PTI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI1_SHIFT (PDI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI_MASK ((1 << (PAGE_SHIFT - PTE_SHIFT)) - 1)

//
// Define the number of bits to shift to left to produce page table offset
// from page table index.
//

#define PTE_SHIFT 3

//
// Define the number of bits to shift to the right justify the Page Directory
// Table Entry field.
//

#define VHPT_PDE_BITS 40

//
// Define the RID for IO Port Space.
//

#define RR_IO_PORT 6


//
// The following definitions are required for the debugger data block.
//

// begin_ntddk begin_ntosp

//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG_PTR MmUserProbeAddress;


#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask

// end_ntddk end_wdm end_ntosp

#define MI_HIGHEST_USER_ADDRESS (PVOID) (ULONG_PTR)((UADDRESS_BASE + 0x6FC00000000 - 0x10000 - 1)) // highest user address
#define MI_USER_PROBE_ADDRESS ((ULONG_PTR)(UADDRESS_BASE + 0x6FC00000000UI64 - 0x10000)) // starting address of guard page
#define MI_SYSTEM_RANGE_START (PVOID) (UADDRESS_BASE + 0x6FC00000000) // start of system space


//
// Define the page table base and the page directory base for
// the TB miss routines and memory management.
//
//
// user/kernel page table base and top addresses
//

extern ULONG_PTR KiIA64VaSignedFill;
extern ULONG_PTR KiIA64PtaSign;

#define PTA_SIGN KiIA64PtaSign
#define VA_FILL KiIA64VaSignedFill

#define SADDRESS_BASE 0x2000000000000000UI64  // session base address

#define PTE_UBASE  PCR->PteUbase
#define PTE_KBASE  PCR->PteKbase
#define PTE_SBASE  PCR->PteSbase

#define PTE_UTOP (PTE_UBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (user)
#define PTE_KTOP (PTE_KBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (kernel)
#define PTE_STOP (PTE_SBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (session)

//
// Second level user and kernel PDR address
//

#define PDE_UBASE  PCR->PdeUbase
#define PDE_KBASE  PCR->PdeKbase
#define PDE_SBASE  PCR->PdeSbase

#define PDE_UTOP (PDE_UBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (user)
#define PDE_KTOP (PDE_KBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (kernel)
#define PDE_STOP (PDE_SBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (session)

//
// 8KB first level user and kernel PDR address
//

#define PDE_UTBASE PCR->PdeUtbase
#define PDE_KTBASE PCR->PdeKtbase
#define PDE_STBASE PCR->PdeStbase

#define PDE_USELFMAP (PDE_UTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (user)
#define PDE_KSELFMAP (PDE_KTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)
#define PDE_SSELFMAP (PDE_STBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)

#define PTE_BASE    PTE_UBASE
#define PDE_BASE    PDE_UBASE
#define PDE_TBASE   PDE_UTBASE
#define PDE_SELFMAP PDE_USELFMAP

#define KSEG0_BASE (KADDRESS_BASE + 0x80000000)           // base of kernel
#define KSEG2_BASE (KADDRESS_BASE + 0xA0000000)           // end of kernel

#define KSEG3_BASE 0x8000000000000000UI64
#define KSEG3_LIMIT 0x8000100000000000UI64

#define KSEG4_BASE 0xA000000000000000UI64
#define KSEG4_LIMIT 0xA000100000000000UI64

//
//++
//PVOID
//KSEG_ADDRESS (
//    IN ULONG PAGE
//    );
//
// Routine Description:
//
//    This macro returns a KSEG virtual address which maps the page.
//
// Arguments:
//
//    PAGE - Supplies the physical page frame number
//
// Return Value:
//
//    The address of the KSEG address
//
//--

#define KSEG_ADDRESS(PAGE) ((PVOID)(KSEG3_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))

#define KSEG4_ADDRESS(PAGE) ((PVOID)(KSEG4_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))


#define MAXIMUM_FWP_BUFFER_ENTRY 8

typedef struct _REGION_MAP_INFO {
    ULONG RegionId;
    ULONG PageSize;
    ULONGLONG SequenceNumber;
} REGION_MAP_INFO, *PREGION_MAP_INFO;

// begin_ntddk begin_wdm
//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))
// end_nthal end_ntddk end_wdm

#define SYSTEM_BASE (KADDRESS_BASE + 0xC3000000)          // start of system space (no typecast)

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)   \
    *((PULONGLONG)(dirbase)) = 0;                       \
    ((PHARDWARE_PTE)(dirbase))->PageFrameNumber = pfn;  \
    ((PHARDWARE_PTE)(dirbase))->Accessed = 1;           \
    ((PHARDWARE_PTE)(dirbase))->Dirty = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Cache = 0;              \
    ((PHARDWARE_PTE)(dirbase))->Write = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Valid = 1;


//
// IA64 function definitions
//

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//  This call is used on a not running thread to see if it's numeric
//  state has been saved in it's context information.  On IA64 the
//  numeric state is always saved.
//
//--
#define KiIsThreadNumericStateSaved(a) TRUE

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--
#define KiRundownThread(a)

//
// ia64 Feature bit definitions
//

#define KF_BRL              0x00000001   // processor supports long branch instruction.

//
// Define macro to test if x86 feature is present.
//
// N.B. All x86 features test TRUE on IA64 systems.
//

#define Isx86FeaturePresent(_f_) TRUE


// begin_nthal begin_ntddk begin_ntndis begin_wdm begin_ntosp
#endif // defined(_IA64_)
// end_nthal end_ntddk end_ntndis end_wdm end_ntosp

#endif // _IA64H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\hivedata.h ===
//depot/main/Base/ntos/inc/hivedata.h#9 - integrate change 19035 (text)
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hivedata.h

Abstract:

    This module contains data structures used by the
    direct memory loaded hive manager.

Author:

    Dragos C. Sambotin (dragoss) 13-Jan-99

Revision History:



--*/

#ifndef __HIVE_DATA__
#define __HIVE_DATA__

//
// ===== Arbitrary Limits Imposed For Sanity =====
//
#define HSANE_CELL_MAX      (1024*1024)     // 1 megabyte max size for
                                            // a single cell


//
// ===== Tuning =====

#define HBIN_THRESHOLD      (HBLOCK_SIZE-512)   // If less than threshold
                                                // bytes would be left in
                                                // bin, add another page

#define HLOG_GROW           HBLOCK_SIZE         // Minimum size to grow log
                                                // by.  Can set this up
                                                // if we think it thrashes.

#define HCELL_BIG_ROUND     (HBLOCK_SIZE*3)     //
                                                // If someone tries to
                                                // allocate a very large
                                                // cell, round it up to
                                                // HBLOCK_SIZE.  This is
                                                // the rather arbitrary
                                                // define for "very large"
                                                //
//
// Never shrink the log files smaller than this, this prevents people
// from taking up all the disk space and then being unable to do
// critical registry operations (like logging on to delete some files)
//
#define HLOG_MINSIZE(Hive)  \
    ((Hive)->Cluster * HSECTOR_SIZE * 2)

//
// ===== Basic Structures and Definitions =====
//
// These are same whether on disk or in memory.
//

//
// NOTE:    Volatile == storage goes away at reboot
//          Stable == Persistent == Not Volatile
//
typedef enum {
    Stable = 0,
    Volatile = 1
} HSTORAGE_TYPE;

#define HTYPE_COUNT 2

//
// --- HCELL_INDEX ---
//
//
// Handle to a cell -> effectively the "virtual" address of the cell,
// HvMapCell converts this to a "real" address, that is, a memory
// address.  Mapping scheme is very much like that standard two level
// page table.  No mappings stored in file, they are built up when
// the file is read in.  (The INDEX in HCELL_INDEX is historical)
//
//  Bit     31  30-21   20-12   11-0
//        +----------------------------+
//        | T | Table | Block | Offset |
//        +----------------------------+
//
//  T = Type(1)= 0 for stable ("normal") storage
//               1 for volatile storage
//
//      Table(10) = Index into directory of mapping tables, selects a table.
//                  Each mapping table is an array of HMAP_ENTRY structures.
//
//      Block(9) = Index into Table, selects an HMAP_ENTRY.  HMAP_ENTRY
//                 contains address of area in memory that this HCELL_INDEX
//                 maps to.  (Base of memory copy of Block)
//
//      Offset(12) = Offset within page, of the Cell header for the cell
//                   of interest.
//
typedef ULONG HCELL_INDEX;
typedef HCELL_INDEX *PHCELL_INDEX;

#ifdef DRAGOSS_PRIVATE_DEBUG
//#undef PAGE_SIZE
//#define PAGE_SIZE 0x2000
#endif //DRAGOSS_PRIVATE_DEBUG

#define HCELL_NIL   ((HCELL_INDEX)(-1))

#define HCELL_TYPE_MASK         0x80000000
#define HCELL_TYPE_SHIFT        31

#define HCELL_TABLE_MASK        0x7fe00000
#define HCELL_TABLE_SHIFT       21

#define HCELL_BLOCK_MASK        0x001ff000
#define HCELL_BLOCK_SHIFT       12

#define HCELL_OFFSET_MASK       0x00000fff

#define HBLOCK_SIZE             0x1000                      // LOGICAL block size
                                                            // This is the size of one of
                                                            // the registry's logical/virtual
                                                            // pages.  It has no particular
                                                            // relationship to page size
                                                            // of the machine.

#define HSECTOR_SIZE            0x200                       // LOGICAL sector size
#define HSECTOR_COUNT           8                           // LOGICAL sectors / LOGICAL Block

#define HSECTOR_PER_PAGE_COUNT  (PAGE_SIZE / HSECTOR_SIZE)  // LOGICAL sectors / Physical page

#define HTABLE_SLOTS        512         // 9 bits of address
#define HDIRECTORY_SLOTS    1024        // 10 bits of address

#define HvGetCellType(Cell) ((ULONG)((Cell & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT))

//
// --- HCELL --- an object within the hive  (A bin is filled with HCELLs)
//
// Any given item of user data must fit within a single HCELL.
// HCELLs cannot span Bins.
//
#define HCELL_PAD(Hive)         ((Hive->Version>=2) ? 8 : 16)
                                // All cells must be at least this large,
                                // All allocations on this boundary

#define HCELL_ALLOCATE_FILL 0xb2    // bz -> buzz buzz (yeah, it's a stretch)
                                    // must fill all newly allocated
                                    // cells for security reasons

#define HCELL_FREE_FILL     0xfc    // fc = HvFreeCell...

//
// Currently we support two cell formats, one with a Last backpointer (old version),
// and one without (new version)
//
// All cells in a hive must be of the same type.  Version 1 hives use the old version,
// Version 2 or greater use the new version.
//

#define USE_OLD_CELL(Hive) (Hive->Version==1)

typedef struct _HCELL {
    LONG    Size;
    union {
        struct {
            ULONG Last;
            union {
                ULONG UserData;
                HCELL_INDEX Next;   // offset of next element in freelist (not a FLink)
            } u;
        } OldCell;

        struct {
            union {
                ULONG UserData;
                HCELL_INDEX Next;    // offset of next element in freelist (not a FLink)
            } u;
        } NewCell;
    } u;
} HCELL, *PHCELL;


//
// --- HBIN ---  is a contiguous set of HBLOCKs, filled with HCELLs.
//
#define HBIN_SIGNATURE          0x6e696268      // "hbin"
#define HBIN_NIL                (-1)

#pragma pack(4)
typedef struct  _HBIN {
    ULONG       Signature;
    ULONG       FileOffset;     // Own file offset (used in checking)
    ULONG       Size;           // Size of bin in bytes, all inclusive
    ULONG       Reserved1[2];   // Old FreeSpace and FreeList (from 1.0)
    LARGE_INTEGER   TimeStamp;  // Old Link (from 1.0).  Usually trash, but
                                // first bin has valid value used for .log
                                // correspondence testing, only meaningful
                                // on disk.
    ULONG       Spare;          // this used to be MemAlloc. We don't use it anymore as we
                                // can't afford to touch the bin (it's not residing in paged-pool
                                // anymore, so touching it means modifying mnw pages).
                                // Spare is used for the ShiftFreeBins Stuff - in memory only!

    //
    // Cell data goes here
    //

} HBIN, *PHBIN;
#pragma pack()

//
// ===== On Disk Structures =====
//

//
// NOTE:    Hive storage is always allocated in units of 4K.  This size
//          must be used on all systems, regardless of page size, since
//          the file format needs to be transportable amoung systems.
//
// NOTE:    The integrity code depends on certain blocks (e.g., the
//          BASE block) being at least as large as the size of a physical
//          sector.  (Otherwise data that should be left alone will
//          be written because the FS has to block/deblock.)  This means
//          that the current code will not work with sectors > 4K.
//
// NOTE:    A hive on disk always contains at least two blocks of storage.
//          1 block for the base block, and 1 for the minimum 1 bin.
//
// NOTE:    Only modified parts of the hive get written to disk.
//          This is not just for efficiency, but also to avoid risk
//          of destruction of unlogged data.  Dirty bits keep track
//          of what has been modified, they reside in a simple
//          bit map attached to the hive.  One bit for each logical
//          sector of 512 bytes.
//
//          If the physical sector size of the machine is less than 512,
//          no matter, we'll always write in clumps of 512.  If the
//          physical sector size is greater than 512, we'll always clump
//          data together so that we log and write data
//          in chunks of that size.  Physical sector sizes > 4K will
//          not work correctly (logging will not work right, so system
//          crashes may lose data that would not otherwise be lost.)
//


//
// An on disk image of a hive looks like this:
//
//      +---------------------------------------+
//      | HBASE_BLOCK                           | 1 Hive Block == 4K
//      |                                       |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Bin - 1 to N 4K blocks                |
//      | Each contains a signature, size, and  |
//      | a boundary tag heap internal to       |
//      | itself.  Once allocated lives forever |
//      | and always at same file offset.       |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Bin ...                               |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//              ...
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Last allocated Bin, new bins are put  |
//      | immediately after this one.           |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//
//  Hive files must allocate on HBLOCK_SIZE boundaries because they
//  might be written on many different systems, and must therefore be
//  set up for the largest cluster size we will support.
//

//
//  The log file format is:
//
//          +-------------------------------+
//          | HBASE_BLOCK copy              |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | DirtyVector                   |
//          | (length computed from length  |
//          |  in the base block            |
//          | (with "DIRT" on front as a    |
//          |  signature)                   |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | Dirty Data                    |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | Dirty Data                    |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | ...                           |
//          +-------------------------------+
//
//  Recovery consists of reading the file in, computing which clusters
//  of data are present from the dirtyvector, and where they belong in
//  the hive address space.  Position in file is by sequential count.
//
//  Logs can allocate on cluster boundaries (physical sector size of
//  host machine) because they will never be written on any machine other
//  than the one that created them.
//
//  For log to be valid:
//
//      Signature, format, major.minor must match expected values.
//      Sequence1 and Sequence2 must match.
//      CheckSum must be correct.
//      Signture on DirtyVector must be correct
//
//  For log to be applicable:
//
//      Sequence in log must match sequence in hive.
//      TimeStamp in log must match TimeStamp in hive.
//      Hive must be in mid-update state, or have bogus header.
//

//
// --- HBASE_BLOCK --- on disk description of the hive
//

//
// NOTE:    HBASE_BLOCK must be >= the size of physical sector,
//          or integrity assumptions will be violated, and crash
//          recovery may not work.
//
#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"

#define HSYS_MAJOR              1               // Must match to read at all
#define HSYS_MINOR              3

#define HSYS_WHISTLER_BETA1     4               // Whistler Beta1 hives

#define HSYS_WHISTLER           5               // normal Whistler hives

#define HSYS_MINOR_SUPPORTED    HSYS_WHISTLER   // Must be <= to write, always
                                                // set up to writer's version.



#define HBASE_FORMAT_MEMORY 1               // Direct memory load case

#define HBASE_NAME_ALLOC    64              // 32 unicode chars

//
// Boot Type Loader <-> Kernel communication
//
#define HBOOT_NORMAL            0
#define HBOOT_REPAIR            1
#define HBOOT_BACKUP            2
#define HBOOT_SELFHEAL          4

#pragma pack(4)
typedef struct _HBASE_BLOCK {
    ULONG           Signature;
    ULONG           Sequence1;
    ULONG           Sequence2;
    LARGE_INTEGER   TimeStamp;
    ULONG           Major;
    ULONG           Minor;
    ULONG           Type;                   // HFILE_TYPE_[PRIMARY|LOG]
    ULONG           Format;
    HCELL_INDEX     RootCell;
    ULONG           Length;                 // Includes all but header
    ULONG           Cluster;                // for logs only
    UCHAR           FileName[HBASE_NAME_ALLOC];  // filename tail
    ULONG           Reserved1[99];
    ULONG           CheckSum;
    ULONG           Reserved2[128*7-2];       // subtract 2 for the volatile info
    ULONG           BootType;				// set by bootloader 
    ULONG           BootRecover;            // set to 1 by bootloader if it did hive recovery
                                            // nobody else is using this
} HBASE_BLOCK, *PHBASE_BLOCK;
#pragma pack()

#define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))
#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"

//
// ===== In Memory Structures =====
//

//
// In memory image of a Hive looks just like the on-disk image,
// EXCEPT that the HBIN structures can be spread throughout memory
// rather than packed together.
//
// To find an HCELL in memory, a mechanism that takes an HCELL_INDEX and
// derives a memory address from it is used.  That mechanism is very
// similar to a two level hardware paging table.
//
// A bit map is used to remember which parts of the hive are dirty.
//
// An HBLOCK can be in three different states
//  1. Present in memory.  BlockAddress and BinAddress are valid pointers.
//     This is the normal state of an HBLOCK.
//
//  2. Discardable.  The HBIN containing this HBLOCK is completely free, but
//     the bin is dirty and needs to be written to the hive file before it
//     can be free.  This is the state we will be in if somebody frees a
//     cell, causing the entire HBIN to become free.  HvpEnlistFreeCell will
//     transition all the HBLOCKs in the free HBIN to this state, but will
//     not free their memory.  After the dirty HBLOCKs are flushed to the
//     file, the memory will be freed.
//
//     Note that if we need to allocate more storage from an HBIN in this
//     state, HvAllocateCell will simply change its state back to State 1
//     and it will be usable.
//
//     An HBLOCK in this state has a valid BlockAddress and BinAddress, but
//     the HMAP_DISCARDABLE bit will be set.
//
//  3. Discarded.  The HBIN containing this HBLOCK is completely free, and
//     is not dirty (i.e. it is marked as free in the hive file as well).
//     There is no memory allocated to contain this HBIN.  After HvSyncHive
//     writes out an HBIN that is in State 2, it frees its pool and the
//     HBIN moves into this state.
//
//     In order to use this HBIN, memory must be allocated to back it, and
//     the HBIN and initial HCELL must be recreated.  (we could re-read it
//     from the hive file, but there's not much point in that since we know
//     that it is entirely free, so we might as well just recreate it and
//     save the disk i/o)
//
//     An HBLOCK in this state has a NULL BlockAddress in the map.
//     The BinAddress will contain the next HCELL in the free list, so
//     we can reconstruct this when we need it.
//     The HMAP_NEWALLOC bit will be set for the first HBLOCK in the HBIN.
//

//
// --- HMAP_ENTRY --- Holds memory location of HCELL
//
#define HMAP_FLAGS          (0xf)
#define HMAP_BASE           (~(HMAP_FLAGS))

#define HBIN_BASE(BinAddress)   (BinAddress & HMAP_BASE)
#define HBIN_FLAGS(BinAddress)  (BinAddress & HMAP_FLAGS)

#define HMAP_NEWALLOC       1               // the bin is the beginning of a new
                                            // allocation. When bin is in view this
                                            // doesn't really matter

#define HMAP_DISCARDABLE    2               // bin is discardable (i.e. is all free)
                                            // first time when we get the chance we'll
                                            // free it (if it is in paged pool)

#define HMAP_INVIEW         4               // bin is mapped in system cache

#define HMAP_INPAGEDPOOL    8               // bin is allocated from paged pool


#define BIN_MAP_ALLOCATION_TYPE(Me) (((Me)->BinAddress)&(HMAP_INPAGEDPOOL|HMAP_INVIEW))

#define ASSERT_BIN_INVIEW(Me)       ASSERT( ((Me)->BinAddress & HMAP_INVIEW) != 0 )
#define ASSERT_BIN_INPAGEDPOOL(Me)  ASSERT( ((Me)->BinAddress & HMAP_INPAGEDPOOL) != 0 )
#define ASSERT_BIN_INVALID(Me)      ASSERT( ((Me)->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 )
#define ASSERT_BIN_VALID(Me)        ASSERT( ((Me)->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) != 0 )

struct _CM_VIEW_OF_FILE; //forward
typedef struct _HMAP_ENTRY {
    ULONG_PTR    BlockAddress;       // Low 2 bits always 0.  High bits
                                    // are memory address of HBLOCK that
                                    // HCELL starts in, add Offset to this.
                                    // (An HCELL can span several HBLOCKs)
                                    //

    ULONG_PTR    BinAddress;         // Low bit set TRUE to mark beginning
                                    // of a new allocation.
                                    // High bits are memory address of
                                    // first HBLOCK in same bin.
                                    // (A given HCELL is always contained
                                    //  in a single bin.)

// Dragos: From here start the changes!!!
    struct _CM_VIEW_OF_FILE    *CmView;    // pointer to the view; NULL when bin is not mapped

    ULONG       MemAlloc;           // we needed to move this from the bin header to the map, in
                                    // order to prevent the bin from being touched

/*
We don't really need this. Left just as a comment


    ULONG       Flags;              // tells if a bin is mapped through
                                    // a view, is allocated from paged pool
                                    // or is unmapped/unallocated


    ULONG_PTR   MappedAddress;      // temporary address inside the mapped view.

*/

} HMAP_ENTRY, *PHMAP_ENTRY;


//
// --- HMAP_TABLE --- Array of MAP_ENTRYs that point to memory HBLOCKs
//
// Each HBLOCK worth of space in the Hive image has an entry in
// an HMAP_TABLE.
//
typedef struct _HMAP_TABLE {
    HMAP_ENTRY  Table[ HTABLE_SLOTS ];
} HMAP_TABLE, *PHMAP_TABLE;


//
// --- HMAP_DIRECTORY --- Array of pointers to HMAP_TABLEs
//
typedef struct _HMAP_DIRECTORY {
    PHMAP_TABLE Directory[  HDIRECTORY_SLOTS ];
} HMAP_DIRECTORY, *PHMAP_DIRECTORY;


//
// ===== Hive Routines typedefs =====
//
struct _HHIVE; // forward

typedef
PVOID
(*PALLOCATE_ROUTINE) (
    ULONG       Length,             // Size of new block wanted
    BOOLEAN     UseForIo,            // TRUE if yes, FALSE if no
    ULONG       Tag
    );

typedef
VOID
(*PFREE_ROUTINE) (
    PVOID       MemoryBlock,
    ULONG       GlobalQuotaSize
    );

typedef
BOOLEAN
(*PFILE_SET_SIZE_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG          FileType,
    ULONG          FileSize,
    ULONG          OldFileSize
    );

typedef struct {
    ULONG  FileOffset;
    PVOID  DataBuffer;
    ULONG  DataLength;
} CMP_OFFSET_ARRAY, * PCMP_OFFSET_ARRAY;

typedef
BOOLEAN
(*PFILE_WRITE_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG       FileType,
    PCMP_OFFSET_ARRAY offsetArray,
    ULONG offsetArrayCount,
    PULONG FileOffset
    );

typedef
BOOLEAN
(*PFILE_READ_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG       FileType,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

typedef
BOOLEAN
(*PFILE_FLUSH_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG           FileType,
    PLARGE_INTEGER  FileOffset,
    ULONG           Length
    );

typedef
struct _CELL_DATA *
(*PGET_CELL_ROUTINE)(
    struct _HHIVE   *Hive,
    HCELL_INDEX Cell
    );

typedef
VOID
(*PRELEASE_CELL_ROUTINE)(
    struct _HHIVE   *Hive,
    HCELL_INDEX Cell
    );

//
// --- HHIVE --- In memory descriptor for a hive.
//

//
// HHIVE contains pointers to service procedures, and pointers to
// map structure.
//
// NOTE:    Optimization - If the size of a hive is less than what can
//          be mapped with a single HMAP_TABLE (HTABLE_SLOTS * HBLOCK_SIZE,
//          or 2 megabytes) there is no real HMAP_DIRECTORY.  Instead,
//          a single DWORD in the HHIVE acts as the 0th entry of the
//          directory.
//
// NOTE:    Free Storage Management - When a hive is loaded, we build up
//          a display (vector) of lists of free cells.  The first part
//          of this vector contains lists that only hold one size cell.
//          The size of cell on the list is HCELL_PAD * (ListIndex+1)
//          There are 15 of these lists, so all free cells between 8 and
//          120 bytes are on these lists.
//
//          The second part of this vector contains lists that hold more
//          than one size cell.  Each size bucket is twice the previous
//          size.  There are 8 of these lists, so all free cells between 136 and
//          32768 bytes are on these lists.
//
//          The last list in this vector contains all cells too large to
//          fit in any previous list.
//
//          Example:    All free cells of size 1 HCELL_PAD (8 bytes)
//                      are on the list at offset 0 in FreeDisplay.
//
//                      All free cells of size 15 HCELL_PAD (120 bytes)
//                      are on the list at offset 0xe.
//
//                      All free cells of size 16-31 HCELL_PAD (128-248 bytes)
//                      are on the list at offset 0xf
//
//                      All free cells of size 32-63 HCELL_PAD (256-506 bytes)
//                      are on the list at offset 0x10.
//
//                      All free cells of size 2048 HCELL_PAD (16384 bytes)
//                      OR greater, are on the list at offset 0x17.
//
//          FreeSummary is a bit vector, with a bit set to true for each
//          entry in FreeDisplay that is not empty.
//

#define HHIVE_SIGNATURE 0xBEE0BEE0

#define HFILE_TYPE_PRIMARY      0   // Base hive file
#define HFILE_TYPE_LOG          1   // Log (security.log)
#define HFILE_TYPE_EXTERNAL     2   // Target of savekey, etc.
#define HFILE_TYPE_MAX          3

#define HHIVE_LINEAR_INDEX      16  // All computed linear indices < HHIVE_LINEAR_INDEX are valid
#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices < HHIVE_EXPONENTIAL_INDEX
                                    // and >= HHIVE_LINEAR_INDEX are valid.
#define HHIVE_FREE_DISPLAY_SIZE 24

#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!
#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index


#define FREE_HBIN_DISCARDABLE   1   // the BlockAddress in HBIN points to the real bin

typedef struct _FREE_HBIN {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    ULONG       FileOffset;
    ULONG       Flags;
} FREE_HBIN, *PFREE_HBIN;

typedef struct _FREE_DISPLAY {
    ULONG       RealVectorSize;
    RTL_BITMAP  Display;
} FREE_DISPLAY, *PFREE_DISPLAY;

typedef struct _HHIVE {
    ULONG                   Signature;

    PGET_CELL_ROUTINE       GetCellRoutine;
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;

    PALLOCATE_ROUTINE       Allocate;
    PFREE_ROUTINE           Free;

    PFILE_SET_SIZE_ROUTINE  FileSetSize;
    PFILE_WRITE_ROUTINE     FileWrite;
    PFILE_READ_ROUTINE      FileRead;
    PFILE_FLUSH_ROUTINE     FileFlush;

    struct _HBASE_BLOCK     *BaseBlock;

    RTL_BITMAP              DirtyVector;    // only for Stable bins
    ULONG                   DirtyCount;
    ULONG                   DirtyAlloc;     // allocated bytges for dirty vect
    
    ULONG                   BaseBlockAlloc;

    ULONG                   Cluster;        // Usually 1 512 byte sector.
                                            // Set up force writes to be
                                            // done in larger units on
                                            // machines with larger sectors.
                                            // Is number of logical 512 sectors.

    BOOLEAN                 Flat;               // TRUE if FLAT
    BOOLEAN                 ReadOnly;           // TRUE if READONLY

    BOOLEAN                 Log;

    ULONG                   HiveFlags;

    ULONG                   LogSize;

    ULONG                   RefreshCount;       // debugging aid


    ULONG                   StorageTypeCount;   // 1 > Number of largest valid
                                                // type. (1 for Stable only,
                                                // 2 for stable & volatile)

    ULONG                   Version;            // hive version, to allow supporting multiple
                                                // formats simultaneously.

    struct _DUAL {
        ULONG               Length;
#ifdef  HV_TRACK_FREE_SPACE
        ULONG				FreeStorage;		// how many free space.
#endif
        PHMAP_DIRECTORY     Map;
        PHMAP_TABLE         SmallDir;
        ULONG               Guard;				// Always == -1

        FREE_DISPLAY        FreeDisplay[HHIVE_FREE_DISPLAY_SIZE];   // bitmap of freecells of the corresponding size
                                                                    // for every HBLOCK_SIZE - bin in the hive, a bit
                                                                    // is set here if a free cell of the desired size
                                                                    // lies in this block

        ULONG               FreeSummary;
        LIST_ENTRY          FreeBins;           // list of freed HBINs (FREE_HBIN)

    }                       Storage[ HTYPE_COUNT ];

    //
    // Caller defined data goes here
    //

} HHIVE, *PHHIVE;


#endif // __HIVE_DATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\init.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Header file for the INIT subcomponent of NTOS

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#ifndef _INIT_
#define _INIT_

// begin_ntosp
#define INIT_SYSTEMROOT_LINKNAME "\\SystemRoot"
#define INIT_SYSTEMROOT_DLLPATH  "\\SystemRoot\\System32"
#define INIT_SYSTEMROOT_BINPATH  "\\SystemRoot\\System32"
// end_ntosp

#define INIT_WINPEMODE_NONE                 0x00000000
#define INIT_WINPEMODE_REGULAR              0x00000001
#define INIT_WINPEMODE_INRAM                0x80000000
#define INIT_WINPEMODE_READONLY_MEDIA       0x00000100
#define INIT_WINPEMODE_REMOVABLE_MEDIA      0x00000200  


extern UNICODE_STRING NtSystemRoot;
// begin_ntosp
extern ULONG NtBuildNumber;
// end_ntosp
extern const ULONG NtMajorVersion;
extern const ULONG NtMinorVersion;
extern ULONG CmNtCSDVersion;
extern UNICODE_STRING CmVersionString;
extern UNICODE_STRING CmCSDVersionString;

extern const CHAR NtBuildLab[];

extern NLSTABLEINFO InitTableInfo;
extern ULONG InitNlsTableSize;
extern PVOID InitNlsTableBase;
extern ULONG InitAnsiCodePageDataOffset;
extern ULONG InitOemCodePageDataOffset;
extern ULONG InitUnicodeCaseTableDataOffset;
extern PVOID InitNlsSectionPointer;
extern BOOLEAN InitSafeModeOptionPresent;
extern ULONG InitSafeBootMode;

extern BOOLEAN InitIsWinPEMode;
extern ULONG InitWinPEModeType;

#if defined(_M_IX86) || defined(_M_AMD64)

VOID
KiSystemStartup(
    IN PVOID LoaderBlock
    );

#else

VOID
KiSystemStartup( VOID );

#endif

VOID
Phase1Initialization(
    IN PVOID Context
    );

typedef
BOOLEAN
(*PTESTFCN)( VOID );

extern PTESTFCN TestFunction;
extern ULONG InitializationPhase;

#if DBG
extern BOOLEAN ForceNonPagedPool;
extern ULONG MmDebug;
#endif // DBG

#endif // _INIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\i386.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i386.h

Abstract:

    This module contains the i386 hardware specific header file.

Author:

    David N. Cutler (davec) 2-Aug-1989

Revision History:

    25-Jan-1990    shielint

                   Added definitions for 8259 ports and commands and
                   macros for 8259 irq# and system irql conversion.

--*/

#ifndef _i386_
#define _i386_

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp


//  NOTE -  KiPcr is only useful for PCR references where we know we
//          won't get context switched between the call to it and the
//          variable reference, OR, were we don't care, (ie TEB pointer)

//  NOTE - bryanwi 11 june 90 - we must not macro out things we export
//      Things like KeFlushIcache and KeFlushDcache cannot be macroed
//      out because external code (like drivers) will want to import
//      them by name.  Therefore, the defines below that turn them into
//      nothing are inappropriate.  But this isn't going to hurt us right
//      now.


//
// Length on interrupt object dispatch code in longwords.
// (shielint) Reserve 9*4 space for ABIOS stack mapping.  If NO
//            ABIOS support the size of DISPATCH_LENGTH should be 74.
//

// begin_nthal

#define NORMAL_DISPATCH_LENGTH 106                  // ntddk wdm
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm


//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// CR4 bits;  These only apply to Pentium
//
#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

// end_nthal

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// External references to the labels defined in int.asm
//

extern ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];
extern PULONG KiInterruptTemplateObject;
extern PULONG KiInterruptTemplateDispatch;
extern PULONG KiInterruptTemplate2ndDispatch;

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

// end_ntddk end_wdm end_ntosp

#if defined(NT_UP)

// synchronization level - UP system
#define SYNCH_LEVEL DISPATCH_LEVEL  

#else

// synchronization level - MP system
#define SYNCH_LEVEL (IPI_LEVEL-2)   // ntddk wdm ntosp

#endif

#define KiSynchIrql SYNCH_LEVEL     // enable portable code

//
// Machine type definitions
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

// end_nthal
//
//  The previous values are or'ed into KeI386MachineType.
//

extern ULONG KeI386MachineType;

// begin_nthal
//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1      // ntosp
#define RPL_MASK     3

//
// SEGMENT_MASK is used to throw away trash part of segment.  Part always
// pushes or pops 32 bits to/from stack, but if it's a segment value,
// high order 16 bits are trash.
//

#define SEGMENT_MASK    0xffff

//
// Startup count value for KeStallExecution.  This value is used
// until KiInitializeStallExecution can compute the real one.
// Pick a value long enough for very fast processors.
//

#define INITIAL_STALL_COUNT 100

// end_nthal

//
// begin_nthal
//
// Macro to extract the high word of a long offset
//

#define HIGHWORD(l) \
    ((USHORT)(((ULONG)(l)>>16) & 0xffff))

//
// Macro to extract the low word of a long offset
//

#define LOWWORD(l) \
    ((USHORT)((ULONG)l & 0x0000ffff))

//
// Macro to combine two USHORT offsets into a long offset
//

#if !defined(MAKEULONG)

#define MAKEULONG(x, y) \
    (((((ULONG)(x))<<16) & 0xffff0000) | \
    ((ULONG)(y) & 0xffff))

#endif

// end_nthal

//
// Request a software interrupt.
//

#define KiRequestSoftwareInterrupt(RequestIrql) \
    HalRequestSoftwareInterrupt( RequestIrql )

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L

// end_ntddk end_wdm end_nthal end_ntosp

//
// Fill TB entry.
//

#define KeFillEntryTb(Virtual)                  \
        KiFlushSingleTb (Virtual);

#if !defined(MIDL_PASS) && defined(_M_IX86) && !defined(_CROSS_PLATFORM_)

FORCEINLINE
VOID
KiFlushSingleTb (
    IN PVOID Virtual
    )
{
    __asm {
        mov eax, Virtual
        invlpg [eax]
    }
}

FORCEINLINE
VOID
KiFlushProcessTb (
    VOID
    )
{
    __asm {
        mov eax, cr3
        mov cr3, eax
    }
}

#endif

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeFlushCurrentTb (                                  // nthal
    VOID                                            // nthal
    );                                              // nthal
                                                    // nthal
//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

//  386 and 486 have transparent caches, so these are noops.

#define KeSweepDcache(AllProcessors)
#define KeSweepCurrentDcache()

#define KeSweepIcache(AllProcessors)
#define KeSweepCurrentIcache()

#define KeSweepIcacheRange(AllProcessors, BaseAddress, Length)

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

// end_ntddk end_wdm end_ntndis end_ntosp

#define KeYieldProcessor()    __asm { rep nop }

// end_nthal

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//
// KeRaiseIrql is one instruction longer than KeAcquireSpinLock on x86 UP.
// KeLowerIrql and KeReleaseSpinLock are the same.
//

#if defined(NT_UP) && !DBG && !defined(_NTDDK_) && !defined(_NTIFS_)

#if !defined(_NTDRIVER_)
#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#else
#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#endif
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)

#else

// begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk end_ntosp

#endif

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IX86) && !defined(USER_MODE_CODE)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)
#pragma intrinsic(_disable)
#pragma intrinsic(_enable)
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)
#endif

#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// The following function prototypes must be in this module so that the
// above macros can call them directly.
//
// begin_nthal

VOID
FASTCALL
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

VOID
FASTCALL
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

// end_nthal

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) { \
    volatile PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    while (TRUE) {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        _asm { rep nop }                                                    \
    }                                                                       \
}

// end_wdm

#else

// end_ntddk end_nthal end_ntosp

//
// Define query tick count macro.
//

#define KiQueryTickCount(CurrentCount) \
    while (TRUE) {                                                      \
        (CurrentCount)->HighPart = KeTickCount.High1Time;               \
        (CurrentCount)->LowPart = KeTickCount.LowPart;                  \
        if ((CurrentCount)->HighPart == KeTickCount.High2Time) break;   \
        _asm { rep nop }                                                \
    }

//
// Define query interrupt time macro.
//

#define KiQueryInterruptTime(CurrentTime) \
    while (TRUE) {                                                                      \
        (CurrentTime)->HighPart = SharedUserData->InterruptTime.High1Time;              \
        (CurrentTime)->LowPart = SharedUserData->InterruptTime.LowPart;                 \
        if ((CurrentTime)->HighPart == SharedUserData->InterruptTime.High2Time) break;  \
        _asm { rep nop }                                                                \
    }

// begin_ntddk begin_nthal begin_ntosp

VOID
NTAPI
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp


// begin_nthal begin_ntosp
//
// 386 hardware structures
//

//
// A Page Table Entry on an Intel 386/486 has the following definition.
//
// **** NOTE A PRIVATE COPY OF THIS EXISTS IN THE MM\I386 DIRECTORY! ****
// ****  ANY CHANGES NEED TO BE MADE TO BOTH HEADER FILES.           ****
//


typedef struct _HARDWARE_PTE_X86 {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE_X86, *PHARDWARE_PTE_X86;

typedef struct _HARDWARE_PTE_X86PAE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE_X86PAE, *PHARDWARE_PTE_X86PAE;

//
// Special check to work around mspdb limitation
//
#if defined (_NTSYM_HARDWARE_PTE_SYMBOL_)
#if !defined (_X86PAE_)
typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

#else
typedef struct _HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE, *PHARDWARE_PTE;
#endif

#else

#if !defined (_X86PAE_)
typedef HARDWARE_PTE_X86 HARDWARE_PTE;
typedef PHARDWARE_PTE_X86 PHARDWARE_PTE;
#else
typedef HARDWARE_PTE_X86PAE HARDWARE_PTE;
typedef PHARDWARE_PTE_X86PAE PHARDWARE_PTE;
#endif
#endif

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04


#define IDT_NMI_VECTOR       2
#define IDT_DFH_VECTOR       8
#define NMI_TSS_DESC_OFFSET  0x58
#define DF_TSS_DESC_OFFSET   0x50


//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;


//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IO_ACCESS_MAP_NONE 0

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;


typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   NotUsed1[4];

    ULONG   CR3;
    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;


    USHORT  Es;
    USHORT  Reserved2;

    USHORT  Cs;
    USHORT  Reserved3;

    USHORT  Ss;
    USHORT  Reserved4;

    USHORT  Ds;
    USHORT  Reserved5;

    USHORT  Fs;
    USHORT  Reserved6;

    USHORT  Gs;
    USHORT  Reserved7;

    USHORT  LDT;
    USHORT  Reserved8;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;


#define KiComputeIopmOffset(MapNumber)          \
    (MapNumber == IO_ACCESS_MAP_NONE) ?         \
        (USHORT)(sizeof(KTSS)) :                    \
        (USHORT)(FIELD_OFFSET(KTSS, IoMaps[MapNumber-1].IoMap))

// begin_windbgkd

//
// Special Registers for i386
//

#ifdef _X86_

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _X86_

// end_windbgkd

//
// DPC data structure definition.
//

typedef struct _KDPC_DATA {
    LIST_ENTRY DpcListHead;
    KSPIN_LOCK DpcLock;
    volatile ULONG DpcQueueDepth;
    ULONG DpcCount;
} KDPC_DATA, *PKDPC_DATA;

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    struct _KPROCESSOR_STATE ProcessorState;

    ULONG   KernelReserved[16];         // For use by the kernel
    ULONG   HalReserved[16];            // For use by Hal

//
// Per processor lock queue entries.
//
// N.B. The following padding is such that the first lock entry falls in the
//      last eight bytes of a cache line. This makes the dispatcher lock and
//      the context swap lock lie in separate cache lines.
//

    UCHAR PrcbPad0[28 + 64];
    KSPIN_LOCK_QUEUE LockQueue[16];
    UCHAR PrcbPad1[8];

// End of the architecturally defined section of the PRCB.
// end_nthal end_ntosp

//
// Micellaneous counters - 64-byte aligned.
//

    struct _KTHREAD *NpxThread;
    ULONG   InterruptCount;
    ULONG   KernelTime;
    ULONG   UserTime;
    ULONG   DpcTime;
    ULONG   DebugDpcTime;
    ULONG   InterruptTime;
    ULONG   AdjustDpcThreshold;
    ULONG   PageColor;
    BOOLEAN SkipTick;
    KIRQL   DebuggerSavedIRQL;
    UCHAR   Spare1[6];
    struct _KNODE *ParentNode;
    KAFFINITY MultiThreadProcessorSet;
    struct _KPRCB * MultiThreadSetMaster;
    ULONG   ThreadStartCount[2];

//
// Performance counters - 64-byte aligned.
//
// Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
//  Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG SpareCounter0;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;
    ULONG SpareCounter1;

//
// Nonpaged per processor lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// MP interprocessor request packet barrier - 64-byte aligned.
//

    volatile KAFFINITY PacketBarrier;
    volatile ULONG ReverseStall;
    PVOID IpiFrame;
    UCHAR PrcbPad2[52];

//
// MP interprocessor request packet and summary - 64-byte aligned.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;
    volatile ULONG IpiFrozen;
    UCHAR PrcbPad3[40];

//
// MP interprocessor request summary and packet address - 64-byte aligned.
//

    volatile ULONG RequestSummary;
    volatile struct _KPRCB *SignalDone;
    UCHAR PrcbPad4[56];

//
// DPC listhead, counts, and batching parameters - 64-byte aligned.
//

    KDPC_DATA DpcData[2];
    PVOID DpcStack;
    ULONG MaximumDpcQueueDepth;
    ULONG DpcRequestRate;
    ULONG MinimumDpcRate;
    volatile BOOLEAN DpcInterruptRequested;
    volatile BOOLEAN DpcThreadRequested;

//
// N.B. the following two fields must be on a word boundary.
//

    volatile BOOLEAN DpcRoutineActive;
    volatile BOOLEAN DpcThreadActive;
    KSPIN_LOCK PrcbLock;
    ULONG DpcLastCount;
    volatile ULONG TimerHand;
    volatile ULONG TimerRequest;
    PVOID DpcThread;
    KEVENT DpcEvent;
    BOOLEAN ThreadDpcEnable;
    volatile BOOLEAN QuantumEnd;
    UCHAR PrcbPad50;
    volatile BOOLEAN IdleSchedule;
    LONG DpcSetEventRequest;
    UCHAR PrcbPad5[22];

//
// Generic call DPC - 64-byte aligned.
//

    KDPC CallDpc;
    ULONG PrcbPad7[8];

//
// Per-processor ready summary and ready queues - 64-byte aligned.
//
// N.B. Ready summary is in the first cache line as the queue for priority
//      zero is never used.
//

    LIST_ENTRY WaitListHead;
    ULONG ReadySummary;
    ULONG SelectNextLast;
    LIST_ENTRY DispatcherReadyListHead[MAXIMUM_PRIORITY];
    SINGLE_LIST_ENTRY DeferredReadyListHead;
    ULONG PrcbPad72[11];

//
// Per processor chained interrupt list - 64-byte aligned.
//

    PVOID ChainedInterruptList;

//
// I/O IRP float.
//

    LONG LookasideIrpFloat;

//
// Spare fields.
//

    ULONG   SpareFields0[4];

//
// Processor information.
//

    UCHAR VendorString[13];
    UCHAR InitialApicId;
    UCHAR LogicalProcessorsPerPhysicalProcessor;
    ULONG MHz;
    ULONG FeatureBits;
    LARGE_INTEGER UpdateSignature;

//
// ISR timing data.
//

    volatile ULONGLONG IsrTime;

//
// Npx save area - 16-byte aligned.
//

    FX_SAVE_AREA NpxSaveArea;

//
// Processors power state
//

    PROCESSOR_POWER_STATE PowerState;

// begin_nthal begin_ntosp

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// end_nthal end_ntosp

//
// The offset of the PRCB in the PCR is 32 mod 64.
//
// The offset of the following structure must be 0 mod 64 except for the
// lock queue array which straddles two cache lines.
//

C_ASSERT(((FIELD_OFFSET(KPRCB, LockQueue) + sizeof(KSPIN_LOCK_QUEUE) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, NpxThread) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, CcFastReadNoWait) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPNPagedLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPPagedLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PacketBarrier) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, CurrentPacket) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, DpcData) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, DpcRoutineActive)) & (1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, CallDpc) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, WaitListHead) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, ChainedInterruptList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, NpxSaveArea) + 32) & (16 - 1)) == 0);

// begin_nthal begin_ntddk begin_ntosp

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// stack limit, subsystem TIB, fiber data, arbitrary user pointer, and the
// self address of then PCR itself (another field has been added for that
// purpose). Therefore, these fields are overlaid with other data to get
// better cache locality.
//

    union {
        NT_TIB  NtTib;
        struct {
            struct _EXCEPTION_REGISTRATION_RECORD *Used_ExceptionList;
            PVOID Used_StackBase;
            PVOID PerfGlobalGroupMask;
            PVOID TssCopy;
            ULONG ContextSwitches;
            KAFFINITY SetMemberCopy;
            PVOID Used_Self;
        };
    };

    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;                       // do not use 3 bytes after this as
                                        // HALs assume they are zero.
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    PVOID   KdVersionBlock;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   SpareUnused;
    UCHAR   Number;

// end_ntddk end_ntosp

    UCHAR   Spare0;
    UCHAR   SecondLevelCacheAssociativity;
    ULONG   VdmAlert;
    ULONG   KernelReserved[14];         // For use by the kernel
    ULONG   SecondLevelCacheSize;
    ULONG   HalReserved[16];            // For use by Hal

// End of the architecturally defined section of the PCR.
// end_nthal

    ULONG   InterruptMode;
    UCHAR   Spare1;
    ULONG   KernelReserved2[17];
    struct _KPRCB PrcbData;

// begin_nthal begin_ntddk begin_ntosp

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

C_ASSERT(FIELD_OFFSET(KPCR, NtTib.ExceptionList) == FIELD_OFFSET(KPCR, Used_ExceptionList));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.StackBase) == FIELD_OFFSET(KPCR, Used_StackBase));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.StackLimit) == FIELD_OFFSET(KPCR, PerfGlobalGroupMask));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.SubSystemTib) == FIELD_OFFSET(KPCR, TssCopy));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.FiberData) == FIELD_OFFSET(KPCR, ContextSwitches));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.ArbitraryUserPointer) == FIELD_OFFSET(KPCR, SetMemberCopy));
C_ASSERT(FIELD_OFFSET(KPCR, NtTib.Self) == FIELD_OFFSET(KPCR, Used_Self));
C_ASSERT((FIELD_OFFSET(KPCR, PrcbData) & (64 - 1)) == 32);

FORCEINLINE
ULONG
KeGetContextSwitches (
    PKPRCB Prcb
    )

{

    PKPCR Pcr;

    Pcr = CONTAINING_RECORD(Prcb, KPCR, PrcbData);
    return Pcr->ContextSwitches;
}

// begin_nthal begin_ntosp

//
// bits defined in Eflags
//

#define EFLAGS_CF_MASK        0x00000001L
#define EFLAGS_PF_MASK        0x00000004L
#define EFLAGS_AF_MASK        0x00000010L
#define EFLAGS_ZF_MASK        0x00000040L
#define EFLAGS_SF_MASK        0x00000080L
#define EFLAGS_TF             0x00000100L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_OF_MASK        0x00000800L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_NT             0x00004000L
#define EFLAGS_RF             0x00010000L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_ID_MASK        0x00200000L

#define EFLAGS_USER_SANITIZE  0x003f4dd7L

// end_nthal

//
// Sanitize segCS and eFlags based on a processor mode.
//
// If kernel mode,
//      force CPL == 0
//
// If user mode,
//      force CPL == 3
//

#define SANITIZE_SEG(segCS, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((segCS) & 0xfffc)) : \
        ((0x00000003L) | ((segCS) & 0xffff))))

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//


#define SANITIZE_FLAGS(eFlags, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((eFlags) & 0x003f0fd7)) : \
        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) & EFLAGS_USER_SANITIZE))))

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active

#define SANITIZE_DR6(Dr6, mode) ((Dr6 & DR6_LEGAL));

#define SANITIZE_DR7(Dr7, mode) ((Dr7 & DR7_LEGAL));

#define SANITIZE_DRADDR(DrReg, mode) (          \
    (mode) == KernelMode ?                      \
        (DrReg) :                               \
        (((PVOID)DrReg <= MM_HIGHEST_USER_ADDRESS) ?   \
            (DrReg) :                           \
            (0)                                 \
        )                                       \
    )

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//

extern ULONG KiMXCsrMask;

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMXCsrMask)

//
// Nonvolatile context pointers
//
// bryanwi 21 feb 90 - This is bogus.  The 386 doesn't have
//                     enough nonvolatile context to make this
//                     structure worthwhile.  Can't declare a
//                     field to be void, so declare a Junk structure
//                     instead.

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    ULONG   Junk;
} KNONVOLATILE_CONTEXT_POINTERS,  *PKNONVOLATILE_CONTEXT_POINTERS;

// begin_nthal
//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//

#define FRAME_EDITED        0xfff8

// end_nthal

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//

typedef struct _KCALLOUT_FRAME {
    ULONG   InStk;          // saved initial stack address
    ULONG   TrFr;           // saved callback trap frame
    ULONG   CbStk;          // saved callback stack address
    ULONG   Edi;            // saved nonvolatile registers
    ULONG   Esi;            //
    ULONG   Ebx;            //
    ULONG   Ebp;            //
    ULONG   Ret;            // saved return address
    ULONG   OutBf;          // address to store output buffer
    ULONG   OutLn;          // address to store output length
} KCALLOUT_FRAME;

typedef KCALLOUT_FRAME *PKCALLOUT_FRAME;


//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   ApcBypassDisable;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;


//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

// begin_ntddk begin_wdm
//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp

//
// i386 Profile values
//

#define DEFAULT_PROFILE_INTERVAL   39063

//
// The minimum acceptable profiling interval is set to 1221 which is the
// fast RTC clock rate we can get.  If this
// value is too small, the system will run very slowly.
//

#define MINIMUM_PROFILE_INTERVAL   1221


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp
//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis end_wdm
//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define the highest user address and user probe address.
//

// end_ntddk end_nthal end_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_ntddk begin_nthal begin_ntosp

extern PVOID *MmHighestUserAddress;
extern PVOID *MmSystemRangeStart;
extern ULONG *MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress
#define MM_SYSTEM_RANGE_START *MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress

// end_ntddk end_nthal end_ntosp

#else

extern PVOID MmHighestUserAddress;
extern PVOID MmSystemRangeStart;
extern ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

// begin_ntddk begin_nthal begin_ntosp
//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#if !defined (_X86PAE_)
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#else
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000
#endif

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_ntddk end_wdm

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define page directory and page base addresses.
//

#define PDE_BASE_X86    0xc0300000
#define PDE_BASE_X86PAE 0xc0600000

#define PTE_TOP_X86     0xC03FFFFF
#define PDE_TOP_X86     0xC0300FFF

#define PTE_TOP_X86PAE  0xC07FFFFF
#define PDE_TOP_X86PAE  0xC0603FFF


#if !defined (_X86PAE_)
#define PDE_BASE PDE_BASE_X86
#define PTE_TOP  PTE_TOP_X86
#define PDE_TOP  PDE_TOP_X86
#else
#define PDE_BASE PDE_BASE_X86PAE
#define PTE_TOP  PTE_TOP_X86PAE
#define PDE_TOP  PDE_TOP_X86PAE
#endif
#define PTE_BASE 0xc0000000

// end_nthal end_ntosp

//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE 0x80000000
#define ALTERNATE_BASE (0xe1000000 - 16 * 1024 * 1024)

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG)(dirbase)) = ((pfn) << PAGE_SHIFT)


// begin_nthal
//
// Location of primary PCR (used only for UP kernel & hal code)
//

// addressed from 0xffdf0000 - 0xffdfffff are reserved for the system
// (ie, not for use by the hal)

#define KI_BEGIN_KERNEL_RESERVED    0xffdf0000
#define KIP0PCRADDRESS              0xffdff000  // ntddk wdm ntosp

// begin_ntddk begin_ntosp

#define KI_USER_SHARED_DATA         0xffdf0000
#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock APIs into their architectural
// equivalents.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

// begin_wdm

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

// end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

// end_ntddk end_nthal end_ntosp

//
// UP/MP versions of interlocked intrinsics
//
// N.B. FASTCALL does NOT work with inline functions.
//

#if !defined(_WINBASE_) && !defined(NONTOSPINTERLOCK) // ntosp ntddk nthal
#if defined(_M_IX86)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

// begin_ntddk begin_nthal begin_ntosp
#if !defined(MIDL_PASS) // wdm
#if defined(NO_INTERLOCKED_INTRINSICS) || defined(_CROSS_PLATFORM_)
// begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

// end_wdm

#else       // NO_INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

// end_ntddk end_nthal end_ntosp

#if defined(NT_UP) && !defined (_NTDDK_) && !defined(_NTIFS_)

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedIncrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedIncrement)
#define InterlockedIncrement _InterlockedIncrement
#else
#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedDecrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedDecrement)
#define InterlockedDecrement _InterlockedDecrement
#else
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)
#endif

//FORCEINLINE
//LONG
//FASTCALL
//InterlockedIncrement(
//    IN PLONG Addend
//    )
//{
//    __asm {
//        mov     eax, 1
//        mov     ecx, Addend
//        xadd    [ecx], eax
//        inc     eax
//    }
//}

//FORCEINLINE
//LONG
//FASTCALL
//InterlockedDecrement(
//    IN PLONG Addend
//    )
//{
//    __asm {
//        mov     eax, -1
//        mov     ecx, Addend
//        xadd    [ecx], eax
//        dec     eax
//    }
//}

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#pragma intrinsic (_InterlockedExchange)
#define InterlockedExchange _InterlockedExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

#pragma intrinsic (_InterlockedExchangeAdd)
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
        xadd    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#pragma intrinsic (_InterlockedCompareExchange)
#define InterlockedCompareExchange (LONG)_InterlockedCompareExchange
#else

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
        cmpxchg [ecx], edx
    }
}

#endif

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

#else   // NT_UP

// begin_ntosp begin_ntddk begin_nthal

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#pragma intrinsic (_InterlockedExchange)
#define InterlockedExchange _InterlockedExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedIncrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedIncrement)
#define InterlockedIncrement _InterlockedIncrement
#else
#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedDecrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedDecrement)
#define InterlockedDecrement _InterlockedDecrement
#else
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

#pragma intrinsic (_InterlockedExchangeAdd)
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#else
// begin_wdm
FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
         mov     eax, Increment
         mov     ecx, Addend
    lock xadd    [ecx], eax
    }
}
// end_wdm
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#pragma intrinsic (_InterlockedCompareExchange)
#define InterlockedCompareExchange (LONG)_InterlockedCompareExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}
#endif

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

// end_ntosp end_ntddk end_nthal
#endif      // NT_UP
// begin_ntddk begin_nthal begin_ntosp
#endif      // INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_
// begin_wdm
#endif      // MIDL_PASS

#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

// end_ntosp end_ntddk end_nthal end_wdm
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif
#endif      // _M_IX86 && !CROSS_PLATFORM
// begin_ntddk begin_nthal begin_ntosp
#endif      // __WINBASE__ && !NONTOSPINTERLOCK
// end_ntosp end_ntddk end_nthal

// begin_nthal begin_ntddk

//
// Turn these instrinsics off until the compiler can handle them
//
#if (_MSC_FULL_VER > 13009037)

LONG
_InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedOr)

#define InterlockedOr _InterlockedOr

LONG
_InterlockedAnd (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedAnd)

#define InterlockedAnd _InterlockedAnd

LONG
_InterlockedXor (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedXor)

#define InterlockedXor _InterlockedXor

#else // compiler version

FORCEINLINE
LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

FORCEINLINE
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

#endif // compiler version

// end_nthal end_ntddk

//
// Structure for Ldt information in x86 processes
//
typedef struct _LDTINFORMATION {
    ULONG Size;
    ULONG AllocatedSize;
    PLDT_ENTRY Ldt;
} LDTINFORMATION, *PLDTINFORMATION;

//
// SetProcessInformation Structure for ProcessSetIoHandlers info class
//

// begin_ntosp

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;


//
//    Vdm Objects and Io handling structure
//

typedef struct _VDM_IO_HANDLER_FUNCTIONS {
    PDRIVER_IO_PORT_ULONG  UlongIo;
    PDRIVER_IO_PORT_ULONG_STRING UlongStringIo;
    PDRIVER_IO_PORT_USHORT UshortIo[2];
    PDRIVER_IO_PORT_USHORT_STRING UshortStringIo[2];
    PDRIVER_IO_PORT_UCHAR UcharIo[4];
    PDRIVER_IO_PORT_UCHAR_STRING UcharStringIo[4];
} VDM_IO_HANDLER_FUNCTIONS, *PVDM_IO_HANDLER_FUNCTIONS;

typedef struct _VDM_IO_HANDLER {
    struct _VDM_IO_HANDLER *Next;
    ULONG PortNumber;
    VDM_IO_HANDLER_FUNCTIONS IoFunctions[2];
} VDM_IO_HANDLER, *PVDM_IO_HANDLER;



// begin_nthal begin_ntddk begin_wdm


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

// end_wdm

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

// end_ntddk end_ntosp
#if NT_UP
    #define _PCR   ds:[KIP0PCRADDRESS]
#else
    #define _PCR   fs:[0]                   // ntddk ntosp
#endif


//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
#define KiPcr() KeGetPcr()
FORCEINLINE
PKPCR
NTAPI
KeGetPcr(VOID)
{
#if NT_UP
    return (PKPCR)KIP0PCRADDRESS;
#else

#if (_MSC_FULL_VER >= 13012035)
    return (PKPCR) (ULONG_PTR) __readfsdword (FIELD_OFFSET (KPCR, SelfPcr));
#else
    __asm {  mov eax, _PCR KPCR.SelfPcr  }
#endif

#endif
}

// begin_ntosp

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE
PKPRCB
NTAPI
KeGetCurrentPrcb (VOID)
{
#if (_MSC_FULL_VER >= 13012035)
    return (PKPRCB) (ULONG_PTR) __readfsdword (FIELD_OFFSET (KPCR, Prcb));
#else
    __asm {  mov eax, _PCR KPCR.Prcb     }
#endif
}

// begin_ntddk begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

// end_ntddk end_wdm

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || !defined(_APIC_TPR_)

// begin_ntddk begin_wdm

NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql();

// end_ntddk end_wdm

#endif

// begin_ntddk begin_wdm

// end_wdm
//
// Get the current processor number
//

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
#if (_MSC_FULL_VER >= 13012035)
    return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, Number));
#else
    __asm {  movzx eax, _PCR KPCR.Number  }
#endif
}

// end_nthal end_ntddk end_ntosp
//
// Get address of current kernel thread object.
//
// WARNING: This inline macro can not be used for device drivers or HALs
// they must call the kernel function KeGetCurrentThread.
// WARNING: This inline macro is always MP enabled because filesystems
// utilize it
//
//
FORCEINLINE
struct _KTHREAD *
NTAPI KeGetCurrentThread (VOID)
{
#if (_MSC_FULL_VER >= 13012035)
    return (struct _KTHREAD *) (ULONG_PTR) __readfsdword (FIELD_OFFSET (KPCR, PrcbData.CurrentThread));
#else
    __asm {  mov eax, fs:[0] KPCR.PrcbData.CurrentThread }
#endif
}

//
// If processor executing DPC?
// WARNING: This inline macro is always MP enabled because filesystems
// utilize it
//
FORCEINLINE
ULONG
NTAPI
KeIsExecutingDpc(VOID)
{
#if (_MSC_FULL_VER >= 13012035)
    return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, PrcbData.DpcRoutineActive));
#else
    __asm {  movzx eax, word ptr fs:[0] KPCR.PrcbData.DpcRoutineActive }
#endif
}

// begin_nthal begin_ntddk begin_ntosp

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif

// begin_wdm
#endif // !defined(MIDL_PASS) && defined(_M_IX86)

// end_nthal end_ntddk end_wdm end_ntosp

// begin_ntddk begin_nthal begin_ntndis begin_wdm begin_ntosp

//++
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    These functions order memory accesses as seen by other processors.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier(
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic (_ReadWriteBarrier)


FORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp

//
// For the UP kernel don't generate the locked reference
//
#if defined (NT_UP)
#define KeMemoryBarrier() _ReadWriteBarrier()
#endif

// begin_nthal
//
// Macro to set address of a trap/interrupt handler to IDT
//
#define KiSetHandlerAddressToIDT(Vector, HandlerAddress) {\
    UCHAR IDTEntry = HalVectorToIDTEntry(Vector); \
    ULONG Ha = (ULONG)HandlerAddress; \
    KeGetPcr()->IDT[IDTEntry].ExtendedOffset = HIGHWORD(Ha); \
    KeGetPcr()->IDT[IDTEntry].Offset = LOWWORD(Ha); \
}

//
// Macro to return address of a trap/interrupt handler in IDT
//
#define KiReturnHandlerAddressFromIDT(Vector) \
   MAKEULONG(KiPcr()->IDT[HalVectorToIDTEntry(Vector)].ExtendedOffset, KiPcr()->IDT[HalVectorToIDTEntry(Vector)].Offset)

// end_nthal

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//--
#define KiIsThreadNumericStateSaved(a) \
    (a->NpxState != NPX_STATE_LOADED)

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#if defined(NT_UP)

//
// On UP x86 systems, FP state is lazy saved and loaded.  If this
// thread owns the current FP context, clear the ownership field
// so we will not try to save to this thread after it has been
// terminated.
//

#define KiRundownThread(a)                          \
    if (KeGetCurrentPrcb()->NpxThread == (a))   {   \
        KeGetCurrentPrcb()->NpxThread = NULL;       \
        __asm { fninit }                            \
    }

#else

#define KiRundownThread(a)

#endif

//
// functions specific to 386 structure
//

VOID
NTAPI
KiSetIRR (
    IN ULONG SWInterruptMask
    );

//
// Procedures to support frame manipulation
//

ULONG
NTAPI
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    );

ULONG
NTAPI
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    );

//
// Define prototypes for i386 specific clock and profile interrupt routines.
//

VOID
NTAPI
KiUpdateRunTime (
    VOID
    );

VOID
NTAPI
KiUpdateSystemTime (
    VOID
    );

// begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm
// begin_nthal

NTKERNELAPI
VOID
NTAPI
KeProfileInterruptWithSource (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

// end_ntosp

VOID
NTAPI
KeProfileInterrupt (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KeUpdateRuntime (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KeUpdateSystemTime (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

// begin_ntddk begin_wdm begin_ntndis begin_ntosp

#endif // defined(_X86_)

// end_nthal end_ntddk end_wdm end_ntndis end_ntosp

// begin_nthal begin_ntddk

// Use the following for kernel mode runtime checks of X86 system architecture

#ifdef _X86_

#ifdef IsNEC_98
#undef IsNEC_98
#endif

#ifdef IsNotNEC_98
#undef IsNotNEC_98
#endif

#ifdef SetNEC_98
#undef SetNEC_98
#endif

#ifdef SetNotNEC_98
#undef SetNotNEC_98
#endif

#define IsNEC_98     (SharedUserData->AlternativeArchitecture == NEC98x86)
#define IsNotNEC_98  (SharedUserData->AlternativeArchitecture != NEC98x86)
#define SetNEC_98    SharedUserData->AlternativeArchitecture = NEC98x86
#define SetNotNEC_98 SharedUserData->AlternativeArchitecture = StandardDesign

#endif

// end_nthal end_ntddk

//
// i386 arch. specific kernel functions.
//

// begin_ntosp
#ifdef _X86_
VOID
NTAPI
Ke386SetLdtProcess (
    struct _KPROCESS  *Process,
    PLDT_ENTRY  Ldt,
    ULONG       Limit
    );

VOID
NTAPI
Ke386SetDescriptorProcess (
    struct _KPROCESS  *Process,
    ULONG       Offset,
    LDT_ENTRY   LdtEntry
    );

VOID
NTAPI
Ke386GetGdtEntryThread (
    struct _KTHREAD *Thread,
    ULONG Offset,
    PKGDTENTRY Descriptor
    );

BOOLEAN
NTAPI
Ke386SetIoAccessMap (
    ULONG               MapNumber,
    PKIO_ACCESS_MAP     IoAccessMap
    );

BOOLEAN
NTAPI
Ke386QueryIoAccessMap (
    ULONG              MapNumber,
    PKIO_ACCESS_MAP    IoAccessMap
    );

BOOLEAN
NTAPI
Ke386IoSetAccessProcess (
    struct _KPROCESS    *Process,
    ULONG       MapNumber
    );

VOID
NTAPI
Ke386SetIOPL(
    VOID
    );

NTSTATUS
NTAPI
Ke386CallBios (
    IN ULONG BiosCommand,
    IN OUT PCONTEXT BiosArguments
    );

VOID
NTAPI
KiEditIopmDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
NTAPI
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );

ULONG
Ki386DispatchOpcodeV86 (
    IN PKTRAP_FRAME TrapFrame
    );

ULONG
Ki386DispatchOpcode (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
NTAPI
Ke386SetVdmInterruptHandler (
    IN struct _KPROCESS *Process,
    IN ULONG Interrupt,
    IN USHORT Selector,
    IN ULONG  Offset,
    IN BOOLEAN Gate32
    );
#endif //_X86_
// end_ntosp
//
// i386 ABIOS specific routines.
//

NTSTATUS
NTAPI
KeI386GetLid(
    IN USHORT DeviceId,
    IN USHORT RelativeLid,
    IN BOOLEAN SharedLid,
    IN struct _DRIVER_OBJECT *DeviceObject,
    OUT PUSHORT LogicalId
    );

NTSTATUS
NTAPI
KeI386ReleaseLid(
    IN USHORT LogicalId,
    IN struct _DRIVER_OBJECT *DeviceObject
    );

NTSTATUS
NTAPI
KeI386AbiosCall(
    IN USHORT LogicalId,
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUCHAR RequestBlock,
    IN USHORT EntryPoint
    );

//
// i386 misc routines
//
NTSTATUS
NTAPI
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

VOID
NTAPI
KeI386Call16BitFunction (
    IN OUT PCONTEXT Regs
    );

USHORT
NTAPI
KeI386Call16BitCStyleFunction (
    IN ULONG EntryOffset,
    IN ULONG EntrySelector,
    IN PUCHAR Parameters,
    IN ULONG Size
    );

NTSTATUS
NTAPI
KeI386FlatToGdtSelector(
    IN ULONG SelectorBase,
    IN USHORT Length,
    IN USHORT Selector
    );

NTSTATUS
NTAPI
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

NTSTATUS
NTAPI
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    );


VOID
NTAPI
KeOptimizeProcessorControlState (
    VOID
    );

//
// Vdm specific functions.
//

BOOLEAN
NTAPI
KeVdmInsertQueueApc (
    IN PKAPC             Apc,
    IN struct _KTHREAD  *Thread,
    IN KPROCESSOR_MODE   ApcMode,
    IN PKKERNEL_ROUTINE  KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE  NormalRoutine OPTIONAL,
    IN PVOID             NormalContext OPTIONAL,
    IN KPRIORITY         Increment
    );

FORCEINLINE
VOID
NTAPI
KeVdmClearApcThreadAddress (
    IN PKAPC Apc
    )

{
    if (Apc->Inserted == FALSE) {
        Apc->Thread = NULL;
    }
}

VOID
NTAPI
KeI386VdmInitialize (
    VOID
    );

//
// x86 functions for special instructions
//

VOID
NTAPI
CPUID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

LONGLONG
NTAPI
RDTSC (
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrRegister
    );

VOID
NTAPI
WRMSR (
    IN ULONG MsrRegister,
    IN ULONGLONG MsrValue
    );

//
// i386 Vdm specific data
//
extern ULONG KeI386EFlagsAndMaskV86;
extern ULONG KeI386EFlagsOrMaskV86;
extern ULONG KeI386VirtualIntExtensions;


extern ULONG KeI386CpuType;
extern ULONG KeI386CpuStep;
extern BOOLEAN KeI386NpxPresent;
extern BOOLEAN KeI386FxsrPresent;


//
// i386 Feature bit definitions
//

#define KF_V86_VIS          0x00000001
#define KF_RDTSC            0x00000002
#define KF_CR4              0x00000004
#define KF_CMOV             0x00000008
#define KF_GLOBAL_PAGE      0x00000010
#define KF_LARGE_PAGE       0x00000020
#define KF_MTRR             0x00000040
#define KF_CMPXCHG8B        0x00000080
#define KF_MMX              0x00000100
#define KF_WORKING_PTE      0x00000200
#define KF_PAT              0x00000400
#define KF_FXSR             0x00000800
#define KF_FAST_SYSCALL     0x00001000
#define KF_XMMI             0x00002000
#define KF_3DNOW            0x00004000
#define KF_AMDK6MTRR        0x00008000
#define KF_XMMI64           0x00010000
#define KF_DTS              0x00020000

//
// Define macro to test if x86 feature is present.
//

extern ULONG KiBootFeatureBits;

#define Isx86FeaturePresent(_f_) ((KiBootFeatureBits & (_f_)) != 0)

#endif // _i386_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\kd.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kd.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Kernel Debugger sub-component of NTOS.

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#ifndef _KD_
#define _KD_

// begin_nthal

//
// Define the number of debugging devices we support
//

#define MAX_DEBUGGING_DEVICES_SUPPORTED 2

//
// Status Constants for reading data from comport
//

#define CP_GET_SUCCESS  0
#define CP_GET_NODATA   1
#define CP_GET_ERROR    2

// end_nthal

//
// Debug constants for FreezeFlag
//

#define FREEZE_BACKUP               0x0001
#define FREEZE_SKIPPED_PROCESSOR    0x0002
#define FREEZE_FROZEN               0x0004


//
// System Initialization procedure for KD subcomponent of NTOS
//

BOOLEAN
KdInitSystem(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    );

extern BOOLEAN KdPitchDebugger;
extern BOOLEAN KdAutoEnableOnEvent;
extern BOOLEAN KdIgnoreUmExceptions;

BOOLEAN
KdPollBreakIn (
    VOID
    );

BOOLEAN
KdIsThisAKdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
KdSetOwedBreakpoints(
    VOID
    );

VOID
KdDeleteAllBreakpoints(
    VOID
    );


//
// Data structure for passing information to KdpReportLoadSymbolsStateChange
// function via the debug trap
//

typedef struct _KD_SYMBOLS_INFO {
    IN PVOID BaseOfDll;
    IN ULONG_PTR ProcessId;
    IN ULONG CheckSum;
    IN ULONG SizeOfImage;
} KD_SYMBOLS_INFO, *PKD_SYMBOLS_INFO;


// begin_nthal
//
// Defines the debug port parameters for kernel debugger
//   CommunicationPort - specify which COM port to use as debugging port
//                       0 - use default; N - use COM N.
//   BaudRate - the baud rate used to initialize debugging port
//                       0 - use default rate.
//

typedef struct _DEBUG_PARAMETERS {
    ULONG CommunicationPort;
    ULONG BaudRate;
} DEBUG_PARAMETERS, *PDEBUG_PARAMETERS;

// end_nthal

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_NTOSP_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     *KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT *KdDebuggerNotPresent

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#endif



// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

extern DEBUG_PARAMETERS KdDebugParameters;

//
// This event is provided by the time service.  The debugger
// signals the event when the system time has slipped due
// to debugger activity.
//

VOID
KdUpdateTimeSlipEvent(
    PVOID Event
    );


//
// Let PS update data in the KdDebuggerDataBlock
//

VOID KdUpdateDataBlock(VOID);
ULONG_PTR KdGetDataBlock(VOID);

// begin_ntddk begin_wdm begin_nthal begin_ntifs

NTSTATUS
KdDisableDebugger(
    VOID
    );

NTSTATUS
KdEnableDebugger(
    VOID
    );

//
// KdRefreshDebuggerPresent attempts to communicate with
// the debugger host machine to refresh the state of
// KdDebuggerNotPresent.  It returns the state of
// KdDebuggerNotPresent while the kd locks are held.
// KdDebuggerNotPresent may immediately change state
// after the kd locks are released so it may not
// match the return value.
//

BOOLEAN
KdRefreshDebuggerNotPresent(
    VOID
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTSTATUS
KdPowerTransition(
    IN DEVICE_POWER_STATE newDeviceState
    );

//
// DbgPrint strings will always be logged to a circular buffer. This
// function may be called directly by the debugger service trap handler
// even when the debugger is not enabled.
//

#if DBG
#define KDPRINTDEFAULTBUFFERSIZE   32768
#else
#define KDPRINTDEFAULTBUFFERSIZE   4096
#endif

extern ULONG KdPrintBufferSize;

VOID
KdLogDbgPrint(
    IN PSTRING String
    );

NTSTATUS
KdSetDbgPrintBufferSize(
    IN ULONG Size
    );


__inline
VOID
KdCheckForDebugBreak(
    VOID
    )
/*++

Routine Description:

    If necessary, poll for a request to break-in from the debugger.
    This function should be called by routines that run at an IRQL
    above clock level that want to be broken in by CTRL-C requests
    from the debugger. Crashdump and hiber, for example, run at
    HIGH_LEVEL and explicitly need to poll for breaking.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (KdDebuggerEnabled && KdPollBreakIn()) {
        DbgBreakPointWithStatus (DBG_STATUS_CONTROL_C);
    }
}


//
// Global debug print filter mask.
//

extern ULONG Kd_WIN2000_Mask;

//
// Allow raw tracing data to be exported to the host
// over the kd protocol.
//

VOID
KdReportTraceData(
    IN struct _WMI_BUFFER_HEADER* Buffer,
    IN PVOID Context
    );

//
// Allow file I/O for files on the kd host machine.
// All pointers must refer to nonpaged memory.
//

NTSTATUS
KdCreateRemoteFile(
    OUT PHANDLE Handle,
    OUT PULONG64 Length, OPTIONAL
    IN PUNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    );

NTSTATUS
KdReadRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    );

NTSTATUS
KdWriteRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    );

NTSTATUS
KdCloseRemoteFile(
    IN HANDLE Handle
    );

NTSTATUS
KdPullRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    );

NTSTATUS
KdPushRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    );

#endif  // _KD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\irqli386.inc ===
;++
;
; Copyright (c) 2002  Microsoft Corporation
;
; Module Name:
;
;    irqli386.inc - 386 machine specific IRQL manipulation routines
;
; Abstract:
;
;   This module provides macros to raise, lower and get current IRQL.
;   These routines are abstracted through macros in order to facilitate
;   generation of a kernel that manipulates IRQL directly.
;
;   If _APIC_TPR_ is defined, IRQL is manipulated directly via the PIC.
;   Otherwise, the appropriate HAL routine is called.
;
; Author:
;
;   Forrest Foltz (forrestf) 1/30/2001
;
;
; This module exposes four public macros:
;
; CurrentIrql
; RaiseIrql
; LowerIrql
; LowerIrqlRet
;


ifdef _APIC_TPR_

        APIC_TPR    equ dword ptr ds:0FFFE0080h
        extrn       _HalpIRQLToTPR:DWORD
        extrn       _HalpVectorToIRQL:DWORD

;++
;
;   CurrentIrql
;
;   Macro Description:
;
;       This macro retrieves the current IRQL in eax
;
;   Arguments:
;
;       None
;
;   Return Value:
;
;       The current IRQL is returned in EAX.
;
;--

CurrentIrql macro
        mov     eax, APIC_TPR
        shr     eax, 4
        add     eax, _HalpVectorToIRQL
        movzx   eax, BYTE PTR [eax]
endm

;++
;
;   SetIrql Irql
;
;   Macro Description:
;
;       This macro sets IRQL to the supplied value.  This macro is an
;       internal routine only.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;   Return Value:
;
;       None.
;
;--

SetIrql macro Irql
ifidn <Irql>, <ecx>
        add     ecx, _HalpIRQLToTPR
        movzx   ecx, BYTE PTR [ecx]
else
ifidn <Irql>, <cl>
        movzx   ecx, cl
        add     ecx, _HalpIRQLToTPR
        movzx   ecx, BYTE PTR [ecx]
else
ifnb <Irql>
        mov     ecx, _HalpIRQLToTPR
        movzx   ecx, BYTE PTR [ecx+Irql]
else
.err Irqlparm not supplied to SetIrql
endif
endif
endif
        mov     APIC_TPR, ecx
endm

;++
;
;   LowerIrql Irql
;
;   Macro Description:
;
;       This macro lowers IRQL to the supplied value.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;   Return Value:
;
;       None.
;
;--

LowerIrql macro Irql
        SetIrql Irql
        mov     ecx, APIC_TPR
endm

;++
;
;   LowerIrqlRet Irql
;
;   Macro Description:
;
;       This macro lowers IRQL to the supplied value and returns to the calling
;       routine.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;   Return Value:
;
;       None.
;
;   Comments:
;
;       This macro should be used only in cases where the function epilogue is
;       known to be identical to that of KfLowerIrql().
;
;--

LowerIrqlRet macro Irql
        LowerIrql Irql
        ret
endm

;++
;
;   RaiseIrql Irql [,NoOld]
;
;   Macro Description:
;
;       This macro raises IRQL to the supplied value.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;       NoOld - Optional.  If supplied, no value is returned in eax.
;
;   Return Value:
;
;       Unless the NoOld flag is supplied, eax contains the zero-extended
;       value of the IRQL before raising.
;
;--

RaiseIrql macro Irql, nooldirql
ifidn <nooldirql>, <NoOld>
else
ifnb <nooldirql>
.err RaiseIrql used with optional parm other than NoOld
else
        CurrentIrql
endif
endif
        SetIrql Irql
endm

else

        extrn __imp_@KfRaiseIrql@4:DWORD
        extrn __imp_@KfLowerIrql@4:DWORD
        extrn __imp__KeGetCurrentIrql@0:DWORD

;++
;
;   CurrentIrql
;
;   Macro Description:
;
;       This macro retrieves the current IRQL in eax
;
;   Arguments:
;
;       None
;
;   Return Value:
;
;       The current IRQL is returned in EAX.
;
;--

CurrentIrql macro
        call    __imp__KeGetCurrentIrql@0
endm

;++
;
;   LowerIrql Irql
;
;   Macro Description:
;
;       This macro lowers IRQL to the supplied value.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;   Return Value:
;
;       None.
;
;--

LowerIrql macro Irql
ifidn <Irql>, <cl>
else
ifidn <Irql>, <ecx>
else
        mov     ecx, Irql
endif
endif
        call    __imp_@KfLowerIrql@4
endm

;++
;
;   LowerIrqlRet Irql
;
;   Macro Description:
;
;       This macro lowers IRQL to the supplied value and returns to the calling
;       routine.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;   Return Value:
;
;       None.
;
;   Comments:
;
;       This macro should be used only in cases where the function epilogue is
;       known to be identical to that of KfLowerIrql().
;
;--

LowerIrqlRet macro Irql
ifidn <Irql>, <cl>
else
ifidn <Irql>, <ecx>
else
        mov     ecx, Irql
endif
endif
        jmp     __imp_@KfLowerIrql@4
endm

;++
;
;   RaiseIrql Irql [,NoOld]
;
;   Macro Description:
;
;       This macro raises IRQL to the supplied value.
;
;   Arguments:
;
;       Irql - provides the value for the desired new IRQL.  It is supplied in
;           one of three forms:
;
;           cl    - the value is zero-extended into ecx before use
;           ecx   - cl has already been zero-extended
;           const - Constant expression is used directly
;
;       NoOld - Optional.  If supplied, no value is returned in eax.
;
;   Return Value:
;
;       Unless the NoOld flag is supplied, eax contains the zero-extended
;       value of the IRQL before raising.
;
;--

RaiseIrql macro Irql
ifidn <Irql>, <cl>
else
ifidn <Irql>, <ecx>
else
        mov     ecx, Irql
endif
endif
        call    __imp_@KfRaiseIrql@4
endm

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\intrlk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2001  Microsoft Corporation

Module Name:

    intrlk.h

Abstract:

    This module contains platform independent interlocked functions.

Author:

    David N. Cutler (davec) 15-Feb-2001

Revision History:

--*/

#ifndef _INTRLK_
#define _INTRLK_

//
// The following functions implement interlocked singly linked lists.
//
// WARNING: These lists can only be used when it is known that the ABA
//          removal problem cannot occur. If the ABA problem can occur,
//          then SLIST's should be used.
//

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedPopEntrySingleList (
    IN PSINGLE_LIST_ENTRY ListHead
    )

/*

Routine Description:

    This function pops an entry from the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

Return Value:

    If the list is empty, then NULL is returned. Otherwise, the address of the
    first entry removed from the list is returned as the function
    value.

*/

{

    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY NextEntry;

    FirstEntry = ListHead->Next;
    do {
        if (FirstEntry == NULL) {
            return NULL;
        }

        NextEntry = FirstEntry;
        FirstEntry =
            (PSINGLE_LIST_ENTRY)InterlockedCompareExchangePointer((PVOID *)ListHead,
                                                                  FirstEntry->Next,
                                                                  FirstEntry);

    } while (FirstEntry != NextEntry);
    return FirstEntry;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedPushEntrySingleList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY Entry
    )

/*

Routine Description:

    This function pushes an entry onto the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

    Entry - Supplies a pointer to a single list entry.

Return Value:

    The previous contents of the listhead are returned as the function value.
    If NULL is returned, then the list transitioned for an empty to a non
    empty state.

*/

{

    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY NextEntry;

    FirstEntry = ListHead->Next;
    do {
        Entry->Next = FirstEntry;
        NextEntry = FirstEntry;
        FirstEntry =
            (PSINGLE_LIST_ENTRY)InterlockedCompareExchangePointer((PVOID *)ListHead,
                                                                  Entry,
                                                                  FirstEntry);

    } while (FirstEntry != NextEntry);
    return FirstEntry;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedFlushSingleList (
    IN PSINGLE_LIST_ENTRY ListHead
    )

/*

Routine Description:

    This function pops the entire list from the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

Return Value:

    If the list is empty, then NULL is returned. Otherwise, the address of the
    first entry removed from the list is returned as the function
    value.

*/

{

    return (PSINGLE_LIST_ENTRY)InterlockedExchangePointer((PVOID *)ListHead,
                                                          NULL);
}

#endif // _INTRLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\kddll.h ===
/*++

Copyright (c) 2000 Microsoft Corporation    
    
Module Name:

    kddll.h

Abstract:
    
    Kernel Debugger HW Extension DLL definitions

Author:

    Eric Nelson (enelson) 1/10/2000

Revision History:

--*/

#ifndef __KDDLL_H__
#define __KDDLL_H__


//
// This Kernel Debugger Context structure is used to share
// information between the Kernel Debugger and the Kernel
// Debugger HW extension DLL
//
typedef struct _KD_CONTEXT {
    ULONG KdpDefaultRetries;
    BOOLEAN KdpControlCPending;
} KD_CONTEXT, *PKD_CONTEXT;


//
// Kernel Debugger HW Extension DLL exported functions
//
NTSTATUS
KdD0Transition(
    VOID
    );

NTSTATUS
KdD3Transition(
    VOID
    );

NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
KdReceivePacket(
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength,
    IN OUT PKD_CONTEXT KdContext
    );

NTSTATUS
KdRestore(
    IN BOOLEAN KdSleepTransition
    );

NTSTATUS
KdSave(
    IN BOOLEAN KdSleepTransition
    );

//
// status Constants for Packet waiting
//

#define KDP_PACKET_RECEIVED 0
#define KDP_PACKET_TIMEOUT 1
#define KDP_PACKET_RESEND 2

VOID
KdSendPacket(
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PKD_CONTEXT KdContext
    );

#endif // __KDDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\io.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 12-Apr-1989


Revision History:


--*/

#ifndef _IO_
#define _IO_

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_wdm end_ntndis
//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04    // To be obsoleted soon
#define IRP_MN_KERNEL_CALL              0x04

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

// begin_wdm
//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
// end_wdm
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
// begin_wdm

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b

// end_ntminiport
// end_wdm end_ntddk end_nthal end_ntifs end_ntosp

// The following minor code is reserved as a private WMI minor function
// For drivers who cannot include io.h, please see wmikm.h
//
// begin_wmikm
#define IRP_MN_SET_TRACE_NOTIFY             0x0A

// end_wmikm
// begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
// end_ntddk end_wdm end_nthal end_ntosp

#define IO_OPEN_PAGING_FILE             0x0002
#define IO_OPEN_TARGET_DIRECTORY        0x0004

//
// Flags not passed to driver
//

// begin_ntddk begin_wdm begin_ntosp
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

// end_ntddk end_wdm

#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400

// end_ntosp

// begin_ntifs begin_ntosp

//
//  This flag is only meaning full to IoCreateFileSpecifyDeviceObjectHint.
//  FileHandles created using IoCreateFileSpecifyDeviceObjectHint with this
//  flag set will bypass ShareAccess checks on this file.
//

#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800  // Ignores share access checks on opens.

// end_ntifs end_ntosp

// Define kernel-only, internal option flags
//

#define IO_ATTACH_DEVICE_API            0x80000000


// end_ntifs

//
// Define the driver interfaces required to write memory dumps.
//

//
// Define stall routine type for the dump driver.
//
// begin_ntosp
typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

//
// Define the interfaces for the dump driver's routines.
//

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    IN LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

//
// Actions accepted by DRIVER_WRITE_PENDING
//
#define IO_DUMP_WRITE_FULFILL   0   // fulfill IO request as if DRIVER_WAIT
#define IO_DUMP_WRITE_START     1   // start new IO
#define IO_DUMP_WRITE_RESUME    2   // resume pending IO
#define IO_DUMP_WRITE_FINISH    3   // finish pending IO
#define IO_DUMP_WRITE_INIT      4   // initialize locals

// size of data used by WRITE_PENDING that should be preserved
// between the calls
#define IO_DUMP_WRITE_DATA_PAGES 2
#define IO_DUMP_WRITE_DATA_SIZE (IO_DUMP_WRITE_DATA_PAGES << PAGE_SHIFT)

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE_PENDING) (
    IN LONG Action,
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl,
    IN PVOID LocalData
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

struct _ADAPTER_OBJECT;

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _DUMP_INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG Reserved;             // Was MBR Checksum. Should be zero now.
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
    PDUMP_DRIVER_WRITE_PENDING WritePendingRoutine;
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;
        struct {
            GUID DiskId;
        } Gpt;
    } DiskInfo;
} DUMP_INITIALIZATION_CONTEXT, *PDUMP_INITIALIZATION_CONTEXT;


// begin_ntddk
//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );


// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

// begin_wdm begin_ntifs
//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

// end_ntddk end_wdm end_ntifs

//
// Define the named pipe create parameters structure used for internal calls
// to IoCreateFile when a named pipe is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a named pipe.
//

typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
    ULONG NamedPipeType;
    ULONG ReadMode;
    ULONG CompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

// end_ntosp

//
// Define the mailslot create parameters structure used for internal calls
// to IoCreateFile when a mailslot is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a mailslot.
//

typedef struct _MAILSLOT_CREATE_PARAMETERS {
    ULONG MailslotQuota;
    ULONG MaximumMessageSize;
    LARGE_INTEGER ReadTimeout;
    BOOLEAN TimeoutSpecified;
} MAILSLOT_CREATE_PARAMETERS, *PMAILSLOT_CREATE_PARAMETERS;

//
// Define the dump driver stack context structure
//

typedef struct DUMP_STACK_IMAGE{
    LIST_ENTRY                  Link;
    PLDR_DATA_TABLE_ENTRY       Image;
    PVOID                       ImageBase;
    ULONG                       SizeOfImage;
} DUMP_STACK_IMAGE, *PDUMP_STACK_IMAGE;

typedef struct _DUMP_STACK_CONTEXT {
    DUMP_INITIALIZATION_CONTEXT Init;
    LARGE_INTEGER               PartitionOffset;
    PVOID                       DumpPointers;
    ULONG                       PointersLength;
    PWCHAR                      ModulePrefix;
    LIST_ENTRY                  DriverList;
    ANSI_STRING                 InitMsg;
    ANSI_STRING                 ProgMsg;
    ANSI_STRING                 DoneMsg;
    PVOID                       FileObject;
    enum _DEVICE_USAGE_NOTIFICATION_TYPE    UsageType;
} DUMP_STACK_CONTEXT, *PDUMP_STACK_CONTEXT;

#define IO_DUMP_MAX_MDL_PAGES           8
#define IO_DUMP_MEMORY_BLOCK_PAGES      8
#define IO_DUMP_COMMON_BUFFER_SIZE      0x2000

NTSTATUS
IoGetDumpStack(
    IN PWCHAR ModulePrefix,
    OUT PDUMP_STACK_CONTEXT *DumpStack,
    IN enum _DEVICE_USAGE_NOTIFICATION_TYPE UsageType,
    IN ULONG IgnoreDeviceUsageFailure
    );

NTSTATUS
IoInitializeDumpStack(
    IN PDUMP_STACK_CONTEXT  DumpStack,
    IN PUCHAR               MessageBuffer OPTIONAL
    );

typedef enum _CRASHDUMP_CONFIGURATION {
    CrashDumpDisable = 0,
    CrashDumpReconfigure
} CRASHDUMP_CONFIGURATION;

NTSTATUS
IoConfigureCrashDump(
    CRASHDUMP_CONFIGURATION Config
    );

BOOLEAN
IoInitializeCrashDump(
    IN HANDLE Pagefile
    );

VOID
IoGetDumpHiberRanges (
    IN PVOID                    HiberContext,
    IN PDUMP_STACK_CONTEXT      DumpStack
    );

NTKERNELAPI
BOOLEAN
IoWriteCrashDump(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN PVOID ContextSave,
    IN PKTHREAD Thread,
    OUT PBOOLEAN Reboot
    );

BOOLEAN
IoIsTriageDumpEnabled(
    VOID
    );

BOOLEAN
IoAddTriageDumpDataBlock(
    IN PVOID Address,
    IN ULONG Length
    );


VOID
IoFreeDumpStack(
    IN PDUMP_STACK_CONTEXT DumpStack
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
(*PIO_DPC_ROUTINE) (
    IN PKDPC Dpc,
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID Context
    );

//
// Define driver timer routine type.
//

typedef
VOID
(*PIO_TIMER_ROUTINE) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN PVOID Context
    );

//
// Define driver initialization routine type.
//
typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

// end_wdm
//
// Define driver reinitialization routine type.
//

typedef
VOID
(*PDRIVER_REINITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

// begin_wdm begin_ntndis
//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//
typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );
//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

// end_ntddk end_wdm end_nthal end_ntndis end_ntosp

//
// Define driver FS notification change routine type.
//

typedef
VOID
(*PDRIVER_FS_NOTIFICATION) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN BOOLEAN FsActive
    );

// begin_ntddk begin_wdm begin_ntosp

//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_BASIC_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_STANDARD_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
(*PFAST_IO_LOCK) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_SINGLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL) (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL_BY_KEY) (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
(*PFAST_IO_ACQUIRE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

typedef
VOID
(*PFAST_IO_RELEASE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_NETWORK_OPEN_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
(*PFAST_IO_MDL_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_PREPARE_MDL_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT struct _ERESOURCE **ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _ERESOURCE *ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
BOOLEAN
(*PFAST_IO_READ_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_OPEN) (
    IN struct _IRP *Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

// end_ntddk end_wdm end_ntosp

//
//  Valid values for FS_FILTER_PARAMETERS.AcquireForSectionSynchronization.SyncType
//

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
    SyncTypeOther = 0,
    SyncTypeCreateSection
} FS_FILTER_SECTION_SYNC_TYPE, *PFS_FILTER_SECTION_SYNC_TYPE;

//
//  Parameters union for the operations that
//  are exposed to the filters through the
//  FsFilterCallbacks registration mechanism.
//

typedef union _FS_FILTER_PARAMETERS {

    //
    //  AcquireForModifiedPageWriter
    //

    struct {
        PLARGE_INTEGER EndingOffset;
        PERESOURCE *ResourceToRelease;
    } AcquireForModifiedPageWriter;

    //
    //  ReleaseForModifiedPageWriter
    //

    struct {
        PERESOURCE ResourceToRelease;
    } ReleaseForModifiedPageWriter;

    //
    //  AcquireForSectionSynchronization
    //

    struct {
        FS_FILTER_SECTION_SYNC_TYPE SyncType;
        ULONG PageProtection;
    } AcquireForSectionSynchronization;

    //
    //  Other
    //

    struct {
        PVOID Argument1;
        PVOID Argument2;
        PVOID Argument3;
        PVOID Argument4;
        PVOID Argument5;
    } Others;

} FS_FILTER_PARAMETERS, *PFS_FILTER_PARAMETERS;

//
//  These are the valid values for the Operation field
//  of the FS_FILTER_CALLBACK_DATA structure.
//

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                    (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                    (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                     (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                     (UCHAR)-6

typedef struct _FS_FILTER_CALLBACK_DATA {

    ULONG SizeOfFsFilterCallbackData;
    UCHAR Operation;
    UCHAR Reserved;

    struct _DEVICE_OBJECT *DeviceObject;
    struct _FILE_OBJECT *FileObject;

    FS_FILTER_PARAMETERS Parameters;

} FS_FILTER_CALLBACK_DATA, *PFS_FILTER_CALLBACK_DATA;

//
//  Prototype for the callbacks received before an operation
//  is passed to the base file system.
//
//  A filter can fail this operation, but consistant failure
//  will halt system progress.
//

typedef
NTSTATUS
(*PFS_FILTER_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

//
//  Prototype for the completion callback received after an
//  operation is completed.
//

typedef
VOID
(*PFS_FILTER_COMPLETION_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );

//
//  This is the structure that the file system filter fills in to
//  receive notifications for these locking operations.
//
//  A filter should set the field to NULL for any notification callback
//  it doesn't wish to receive.
//

typedef struct _FS_FILTER_CALLBACKS {

    ULONG SizeOfFsFilterCallbacks;
    ULONG Reserved; //  For alignment

    PFS_FILTER_CALLBACK PreAcquireForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForSectionSynchronization;
    PFS_FILTER_CALLBACK PreReleaseForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForSectionSynchronization;
    PFS_FILTER_CALLBACK PreAcquireForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForCcFlush;
    PFS_FILTER_CALLBACK PreReleaseForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForCcFlush;
    PFS_FILTER_CALLBACK PreAcquireForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForModifiedPageWriter;
    PFS_FILTER_CALLBACK PreReleaseForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForModifiedPageWriter;

} FS_FILTER_CALLBACKS, *PFS_FILTER_CALLBACKS;

NTKERNELAPI
NTSTATUS
FsRtlRegisterFileSystemFilterCallbacks (
    IN struct _DRIVER_OBJECT *FilterDriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Define the I/O system's structure for a connected interrupt.  This is
// useful for connecting an ISR to several different processors.
//

typedef struct _IO_INTERRUPT_STRUCTURE {
    KINTERRUPT InterruptObject;
    PKINTERRUPT InterruptArray[MAXIMUM_PROCESSORS];
    KSPIN_LOCK SpinLock;
} IO_INTERRUPT_STRUCTURE, *PIO_INTERRUPT_STRUCTURE;

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

// end_ntddk end_wdm end_ntifs end_ntosp

//
// Define the I/O system's version of a timer.
//

typedef struct _IO_TIMER {
    CSHORT Type;
    CSHORT TimerFlag;
    LIST_ENTRY TimerList;
    PIO_TIMER_ROUTINE TimerRoutine;
    PVOID Context;
    struct _DEVICE_OBJECT *DeviceObject;
} IO_TIMER, *PIO_TIMER;

//
// Define the client driver object extension header.
//

typedef struct _IO_CLIENT_EXTENSION {
    struct _IO_CLIENT_EXTENSION *NextExtension;
    PVOID ClientIdentificationAddress;
} IO_CLIENT_EXTENSION, *PIO_CLIENT_EXTENSION;

// begin_ntddk begin_nthal begin_ntifs begin_ntosp
//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_) || defined(_NTOSP_))

// begin_wdm
//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

// end_wdm
#else

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_ || _NTOSP_)

// begin_wdm
//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

// end_wdm

typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

// begin_wdm
//
// Define Device Object (DO) flags
//
// end_wdm end_ntddk end_nthal end_ntifs

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

// begin_wdm begin_ntddk begin_nthal begin_ntifs
//
// Device Object structure definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp
//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010
#define DOE_STARTIO_REQUESTED           0x00000020
#define DOE_STARTIO_REQUESTED_BYKEY     0x00000040
#define DOE_STARTIO_CANCELABLE          0x00000080
#define DOE_STARTIO_DEFERRED            0x00000100  // Use non-recursive startio
#define DOE_STARTIO_NO_CANCEL           0x00000200  // Pass non-cancelable IRP to startio

// begin_ntddk begin_nthal begin_ntifs begin_wdm begin_ntosp

struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
                                            // WARNING: Access via PO macros
                                            // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
                                       // Set in the filesystem's volume device object.
                                       // This is a reverse VPB pointer.

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
// end_wdm
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

// begin_wdm

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

    //
    // The client driver object extension field is used by class driver
    // to store per driver information.
    //

    PIO_CLIENT_EXTENSION ClientDriverExtension;

    //
    //  The file system filter callback extension field is used
    //  to safely notify filters of system operations that were
    //  previously not shown to file system filters.
    //

    PFS_FILTER_CALLBACKS FsFilterCallbacks;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;


typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis


// end_ntddk end_wdm end_ntifs end_ntosp

//
// Device Handler Object.   There is one of these objects per PnP
// device.  This object is given to the device driver as a PVOID
// and is used by the driver to refer to a particular device.
//

typedef struct _DEVICE_HANDLER_OBJECT {
    CSHORT Type;
    USHORT Size;

    //
    // Indentifies which bus extender this device handler
    // object is associated with
    //

    struct _BUS_HANDLER *BusHandler;

    //
    // The associated SlotNumber for this device handler
    //

    ULONG SlotNumber;

// end_nthal

    //
    // System internal fields
    //

    //
    // Pnp stuff
    //

    UNICODE_STRING ServiceKeyName;
    ULONG InstanceOrdinal;

// begin_nthal


} DEVICE_HANDLER_OBJECT, *PDEVICE_HANDLER_OBJECT;

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000
#define FO_FILE_OBJECT_HAS_EXTENSION    0x00800000
#define FO_REMOTE_ORIGIN                0x01000000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    ULONG Waiters;
    ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

// end_ntddk end_ntifs end_ntosp

#define IRP_RETRY_IO_COMPLETION         0x00004000
#define IRP_HIGH_PRIORITY_PAGING_IO     0x00008000

//
// Mask currently used by verifier. This should be made 1 flag in the
// next release.
//

#define IRP_VERIFIER_MASK               0xC0000000
#define IRP_SET_USER_EVENT              IRP_CLOSE_OPERATION

// begin_ntddk begin_ntifs begin_ntosp

// begin_wdm
//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// I/O Request Packet (IRP) definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation,
    SingleBusRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;

// begin_ntminiport

// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

// end_ntminiport

typedef struct _DEVICE_CAPABILITIES {
    USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG NoDisplayInUI:1;
    ULONG Reserved:14;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

// begin_ntndis

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

// end_ntndis

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

        //
        // System service parameters for:  NtCreateNamedPipeFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PNAMED_PIPE_CREATE_PARAMETERS Parameters;
        } CreatePipe;

        //
        // System service parameters for:  NtCreateMailslotFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PMAILSLOT_CREATE_PARAMETERS Parameters;
        } CreateMailslot;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            PUNICODE_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;
        } NotifyDirectory;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtQueryEaFile
        //

        struct {
            ULONG Length;
            PVOID EaList;
            ULONG EaListLength;
            ULONG POINTER_ALIGNMENT EaIndex;
        } QueryEa;

        //
        // System service parameters for:  NtSetEaFile
        //

        struct {
            ULONG Length;
        } SetEa;

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } SetVolume;
// begin_ntosp
        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
            PVOID Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            PLARGE_INTEGER Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } LockControl;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //

// end_ntddk end_wdm end_nthal
// end_ntosp

        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

// end_wdm
        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG POINTER_ALIGNMENT Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

// begin_wdm
        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtQueryQuotaInformationFile
        //

        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
        } QueryQuota;

        //
        // System service parameters for:  NtSetQuotaInformationFile
        //

        struct {
            ULONG Length;
        } SetQuota;

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

// end_ntifs

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

// begin_ntifs
        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

    //
    // Indicates the structure version, as anything value belong this will have been added.
    // Use the structure size as the version.
    //

    ULONG Version;

    //
    // Indicates the total number of medium changer devices in the system.
    // This field will be updated by the drivers as it determines that
    // new devices have been found and will be supported.
    //

    ULONG MediumChangerCount;

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

// end_ntddk end_nthal end_ntosp

//
// The following are global counters used by the I/O system to indicate the
// amount of I/O being performed in the system.  The first three counters
// are just that, counts of operations that have been requested, while the
// last three counters track the amount of data transferred for each type
// of I/O request.
//

extern KSPIN_LOCK IoStatisticsLock;
extern ULONG IoReadOperationCount;
extern ULONG IoWriteOperationCount;
extern ULONG IoOtherOperationCount;
extern LARGE_INTEGER IoReadTransferCount;
extern LARGE_INTEGER IoWriteTransferCount;
extern LARGE_INTEGER IoOtherTransferCount;

//
// It is difficult for cached file systems to properly charge quota
// for the storage that they allocate on behalf of user file handles,
// so the following amount of additional quota is charged against each
// handle as a "best guess" as to the amount of quota the file system
// will allocate on behalf of this handle.
//

//
// These numbers are totally arbitrary, and can be changed if it turns out
// that the file systems actually allocate more (or less) on behalf of
// their file objects.  The non-paged pool charge constant is added to the
// size of a FILE_OBJECT to get the actual charge amount.
//

#define IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE    64
#define IO_FILE_OBJECT_PAGED_POOL_CHARGE        1024


// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Public I/O routine definitions
//

NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoAcquireVpbSpinLock(
    OUT PKIRQL Irql
    );

// begin_ntddk begin_nthal end_ntifs begin_ntosp

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

// begin_wdm

NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    );

// begin_ntifs

NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    );

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

NTKERNELAPI
PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );

// end_wdm end_ntifs
//++
//
// VOID
// IoAssignArcName(
//     IN PUNICODE_STRING ArcName,
//     IN PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReprtDetectedDevice
NTKERNELAPI
NTSTATUS
IoAssignResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

// end_ntddk end_nthal end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
typedef enum _IO_PAGING_PRIORITY {
    IoPagingPriorityInvalid,        // Returned if a non-paging IO IRP is passed.
    IoPagingPriorityNormal,         // For regular paging IO
    IoPagingPriorityHigh,           // For high priority paging IO
    IoPagingPriorityReserved1,      // Reserved for future use.
    IoPagingPriorityReserved2       // Reserved for future use.
} IO_PAGING_PRIORITY;
// end_ntddk end_nthal end_wdm end_ntifs end_ntosp


NTKERNELAPI
NTSTATUS
IoAsynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    IN IO_PAGING_PRIORITY   Priority,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PIRP *Irp OPTIONAL
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );

// end_wdm

DECLSPEC_DEPRECATED_DDK                 // Use IoAttachDeviceToDeviceStack
NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

// begin_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

//
// This structure should follow the previous structure field for field.
//
typedef struct _BOOTDISK_INFORMATION_EX {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    );

// end_ntddk end_nthal end_wdm end_ntifs end_ntosp

NTSTATUS
IoBuildPoDeviceNotifyList (
    IN OUT PVOID Order
    );

VOID
IoMovePoNotifyChildren(
    IN PVOID Notify,
    IN PVOID Order
    );

PVOID
IoGetPoNotifyParent(
    PVOID Notify
    );

NTSTATUS
IoNotifyPowerOperationVetoed(
    IN POWER_ACTION             VetoedPowerOperation,
    IN PDEVICE_OBJECT           TargetedDeviceObject    OPTIONAL,
    IN PDEVICE_OBJECT           VetoingDeviceObject
    );

VOID
IoControlPnpDeviceActionQueue(
    BOOLEAN Lock
    );

// begin_ntddk begin_nthal begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTSTATUS
FASTCALL
IofCallDriverSpecifyReturn(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress   OPTIONAL
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTKERNELAPI
VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    );

// begin_ntifs

NTKERNELAPI
NTSTATUS
IoCheckDesiredAccess(
    IN OUT PACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess
    );

NTKERNELAPI
NTSTATUS
IoCheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    );

NTKERNELAPI
NTSTATUS
IoCheckFunctionAccess(
    IN ACCESS_MASK GrantedAccess,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN ULONG IoControlCode,
    IN PVOID Arg1 OPTIONAL,
    IN PVOID Arg2 OPTIONAL
    );


NTKERNELAPI
NTSTATUS
IoCheckQuerySetFileInformation(
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    );

NTKERNELAPI
NTSTATUS
IoCheckQuerySetVolumeInformation(
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    );


NTKERNELAPI
NTSTATUS
IoCheckQuotaBufferValidity(
    IN PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG ErrorOffset
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

//
// This value should be returned from completion routines to continue
// completing the IRP upwards. Otherwise, STATUS_MORE_PROCESSING_REQUIRED
// should be returned.
//
#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS

//
// Completion routines can also use this enumeration in place of status codes.
//
typedef enum _IO_COMPLETION_ROUTINE_RESULT {

    ContinueCompletion = STATUS_CONTINUE_COMPLETION,
    StopCompletion = STATUS_MORE_PROCESSING_REQUIRED

} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

// end_ntifs

NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    );

// end_wdm

NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    );

// begin_wdm begin_ntifs

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );


#define WDM_MAJORVERSION        0x01
#define WDM_MINORVERSION        0x30

NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );

// end_ntddk end_wdm end_ntosp

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObject(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectEx(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PHANDLE FileObjectHandle OPTIONAL
    );

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectLite(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

// begin_nthal begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

// end_wdm

//++
//
// VOID
// IoDeassignArcName(
//     IN PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

// end_ntifs

NTKERNELAPI
VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

// begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );

// end_ntifs

NTKERNELAPI
VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
VOID
IoEnqueueIrp(
    IN PIRP Irp
    );
// end_ntosp

NTKERNELAPI                                             // ntifs
BOOLEAN                                                 // ntifs
IoFastQueryNetworkAttributes(                           // ntifs
    IN POBJECT_ATTRIBUTES ObjectAttributes,             // ntifs
    IN ACCESS_MASK DesiredAccess,                       // ntifs
    IN ULONG OpenOptions,                               // ntifs
    OUT PIO_STATUS_BLOCK IoStatus,                      // ntifs
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer           // ntifs
    );                                                  // ntifs

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

// begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeMdl(
    IN PMDL Mdl
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

VOID
IoFreePoDeviceNotifyList (
    IN OUT PVOID Order
    );

NTSTATUS
IoGetDeviceInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
IoGetLegacyVetoList(
    OUT PWSTR *VetoList OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType
    );

// begin_ntifs begin_ntosp

NTKERNELAPI
PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI                                 // ntddk wdm nthal
PDEVICE_OBJECT                              // ntddk wdm nthal
IoGetAttachedDeviceReference(               // ntddk wdm nthal
    IN PDEVICE_OBJECT DeviceObject          // ntddk wdm nthal
    );                                      // ntddk wdm nthal
                                            // ntddk wdm nthal
NTKERNELAPI
PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI                                 // ntddk nthal ntosp
PCONFIGURATION_INFORMATION                  // ntddk nthal ntosp
IoGetConfigurationInformation( VOID );      // ntddk nthal ntosp

// begin_ntddk begin_wdm begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal end_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    );

// begin_wdm

NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    );

NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );

// begin_nthal

NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,           OPTIONAL // required for PnP drivers
    IN struct _DEVICE_DESCRIPTION *DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

NTKERNELAPI
BOOLEAN
IoForwardIrpSynchronously(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

// end_wdm

NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );

// end_nthal


// begin_wdm

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );

NTKERNELAPI
VOID
IoGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

//
//  The following function is used to tell the caller how much stack is available
//

FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize (
    VOID
    )
{
    ULONG_PTR Top;
    ULONG_PTR Bottom;

    IoGetStackLimits( &Bottom, &Top );
    return((ULONG_PTR)(&Top) - Bottom );
}

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
ULONG
IoGetRequestorProcessId(
    IN PIRP Irp
    );

NTKERNELAPI
PEPROCESS
IoGetRequestorProcess(
    IN PIRP Irp
    );

// end_ntosp

NTKERNELAPI
PIRP
IoGetTopLevelIrp(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// end_ntddk end_wdm end_nthal
// VOID
// IoInitializeTheadedDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// begin_ntddk begin_wdm begin_nthal
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--

#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )

// end_ntddk end_wdm end_nthal
#define IoInitializeThreadedDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeThreadedDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),           \
                     (DeviceObject) ) )
// begin_ntddk begin_wdm begin_nthal

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
VOID
IoReuseIrp(
    IN OUT PIRP Irp,
    IN NTSTATUS Iostatus
    );

// end_wdm

NTKERNELAPI
VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PFILE_OBJECT    FileObject
    );
// end_ntddk end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
IoInitSystem(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))

// end_ntddk end_wdm end_nthal end_ntosp

//++
//
// BOOLEAN
// IoIsFileOpenedExclusively(
//     IN PFILE_OBJECT FileObject
//     )
//
// Routine Description:
//
//     This routine is invoked to determine whether the file open represented
//     by the specified file object is opened exclusively.
//
// Arguments:
//
//     FileObject - Pointer to the file object that represents the open instance
//         of the target file to be tested for exclusive access.
//
// Return Value:
//
//     The function value is TRUE if the open instance of the file is exclusive;
//     otherwise FALSE is returned.
//
//--

#define IoIsFileOpenedExclusively( FileObject ) (\
    (BOOLEAN) !((FileObject)->SharedRead || (FileObject)->SharedWrite || (FileObject)->SharedDelete))

NTKERNELAPI
BOOLEAN
IoIsOperationSynchronous(
    IN PIRP Irp
    );

NTKERNELAPI
BOOLEAN
IoIsSystemThread(
    IN PETHREAD Thread
    );

NTKERNELAPI
BOOLEAN
IoIsValidNameGraftingBuffer(
    IN PIRP Irp,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    );

// begin_wdm

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
IoPageFileCreated(
    IN HANDLE FileHandle
    );

NTKERNELAPI                                             // ntifs
NTSTATUS                                                // ntifs
IoPageRead(                                             // ntifs
    IN PFILE_OBJECT FileObject,                         // ntifs
    IN PMDL MemoryDescriptorList,                       // ntifs
    IN PLARGE_INTEGER StartingOffset,                   // ntifs
    IN PKEVENT Event,                                   // ntifs
    OUT PIO_STATUS_BLOCK IoStatusBlock                  // ntifs
    );                                                  // ntifs

NTKERNELAPI
NTSTATUS
IoAsynchronousPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

// begin_ntddk begin_ntosp
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDeviceProperty
NTKERNELAPI
NTSTATUS
IoQueryDeviceDescription(
    IN PINTERFACE_TYPE BusType OPTIONAL,
    IN PULONG BusNumber OPTIONAL,
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
    IN PULONG ControllerNumber OPTIONAL,
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
    IN PULONG PeripheralNumber OPTIONAL,
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    IN PVOID Context
    );

// end_ntddk end_ntosp


// begin_ntifs

NTSTATUS
IoQueryFileDosDeviceName(
    IN PFILE_OBJECT FileObject,
    OUT POBJECT_NAME_INFORMATION *ObjectNameInformation
    );

NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    );

// begin_ntosp
NTKERNELAPI
VOID
IoQueueThreadIrp(
    IN PIRP Irp
    );
// end_ntosp

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    );

NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    );

NTKERNELAPI
BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    );

NTKERNELAPI
VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );

// end_ntddk end_nthal end_ntosp

NTKERNELAPI
VOID
IoRegisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoRegisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

// begin_wdm

NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    );

// end_ntddk end_nthal end_wdm end_ntosp

NTKERNELAPI
VOID
IoReleaseVpbSpinLock(
    IN KIRQL Irql
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_ntifs end_ntosp

NTKERNELAPI
NTSTATUS
IoReportHalResourceUsage(
    IN PUNICODE_STRING HalName,
    IN PCM_RESOURCE_LIST RawResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN ULONG ResourceListSize
    );

// begin_ntddk begin_ntifs begin_ntosp

DECLSPEC_DEPRECATED_DDK                 // Use IoReportResourceForDetection
NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

// begin_wdm

//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// PDRIVER_CANCEL
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( (PVOID *) &(Irp)->CancelRoutine, (PVOID) (ULONG_PTR)(NewCancelRoutine) ) )

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION __irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    __irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    __irpSp->CompletionRoutine = (Routine);                                   \
    __irpSp->Context = (CompletionContext);                                   \
    __irpSp->Control = 0;                                                     \
    if ((Success)) { __irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { __irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { __irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    );


// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoSetDeviceToVerify(
    IN PETHREAD Thread,
    IN PDEVICE_OBJECT DeviceObject
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    );

// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntosp

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION __irpSp; \
    PIO_STACK_LOCATION __nextIrpSp; \
    __irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    __nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( __nextIrpSp, __irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    __nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) { \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++; }


NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoSetTopLevelIrp(
    IN PIRP Irp
    );

// end_ntifs

// begin_ntddk begin_wdm begin_ntosp


typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    ULONG       HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK Lock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    );
//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID   Tag, // Optional
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    );

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag, // Optional
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//

// end_ntddk end_wdm end_ntosp

NTKERNELAPI
VOID
IoShutdownSystem(
    IN ULONG Phase
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    );

// begin_ntifs

NTKERNELAPI
VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
NTSTATUS
IoSynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

// begin_ntosp

NTKERNELAPI
PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    );

// end_ntosp

NTKERNELAPI
VOID
IoUnregisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoUnregisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

// end_wdm

NTKERNELAPI
VOID
IoUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    );


NTKERNELAPI                                     // ntddk wdm nthal
VOID                                            // ntddk wdm nthal
IoWriteErrorLogEntry(                           // ntddk wdm nthal
    IN PVOID ElEntry                            // ntddk wdm nthal
    );                                          // ntddk wdm nthal

// end_ntifs end_ntosp


typedef BOOLEAN (*PIO_TRAVERSE_WORKER)(
    IN ULONG                Level,
    IN PVOID                DeviceNode,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PVOID                Context
    );

typedef BOOLEAN (*PIO_LEVEL_END_WORKER)(
    IN ULONG                Level,
    IN PVOID                Context
    );

//
// Used by PO to traverse DevNode tree
//

VOID
IoTraverseDeviceTree(
    IN BOOLEAN                  Inverted,
    IN LONG                     CurrentLevel,
    IN PIO_TRAVERSE_WORKER      WorkerFunction,
    IN PIO_LEVEL_END_WORKER     LevelEndFunction,
    IN PVOID                    Context
    );

// begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName,   OPTIONAL
    IN PDRIVER_INITIALIZE InitializationFunction
    );

NTKERNELAPI
VOID
IoDeleteDriver (
    IN PDRIVER_OBJECT DriverObject
    );

// end_nthal end_ntosp

#define _WMIKM_

//
// This defines the codes used to define what a request must do
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = IRP_MN_QUERY_ALL_DATA,
    WmiGetSingleInstance = IRP_MN_QUERY_SINGLE_INSTANCE,
    WmiChangeSingleInstance = IRP_MN_CHANGE_SINGLE_INSTANCE,
    WmiChangeSingleItem = IRP_MN_CHANGE_SINGLE_ITEM,
    WmiEnableEvents = IRP_MN_ENABLE_EVENTS,
    WmiDisableEvents  = IRP_MN_DISABLE_EVENTS,
    WmiEnableCollection = IRP_MN_ENABLE_COLLECTION,
    WmiDisableCollection = IRP_MN_DISABLE_COLLECTION,
    WmiRegisterInfo = IRP_MN_REGINFO,
    WmiExecuteMethodCall = IRP_MN_EXECUTE_METHOD
} WMIACTIONCODE;


//
// This is the prototype for the callback WMI will make to a data provider
//

typedef NTSTATUS (*WMIENTRY)(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    IN PVOID Context,
    OUT PULONG Size
    );

#define WMIREG_FLAG_CALLBACK        0x80000000
// begin_wmikm
//
// The following is set for a KM provider who is considered private to
// kernel tracing
//
#define WMIREG_FLAG_TRACE_PROVIDER          0x00010000

//
// The following mask is to extract the trace callout class
//
#define WMIREG_FLAG_TRACE_NOTIFY_MASK       0x00F00000

//
// We use 4 bits for the trace callout classes.
//
#define WMIREG_NOTIFY_DISK_IO               1 << 20
#define WMIREG_NOTIFY_TDI_IO                2 << 20

// end_wmikm

// begin_ntddk begin_wdm begin_ntifs begin_ntosp begin_ntosp

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

//
// Action code for IoWMIRegistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    );

NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    );

#if defined(_WIN64)
NTKERNELAPI
ULONG IoWMIDeviceObjectToProviderId(
    PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

NTKERNELAPI
NTSTATUS IoWMIOpenBlock(
    IN GUID *DataBlockGuid,
    IN ULONG DesiredAccess,
    OUT PVOID *DataBlockObject
    );


NTKERNELAPI
NTSTATUS IoWMIQueryAllData(
    IN PVOID DataBlockObject,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQueryAllDataMultiple(
    IN PVOID *DataBlockObjectList,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    IN PVOID *DataBlockObjectList,
    IN PUNICODE_STRING InstanceNames,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMISetSingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMISetSingleItem(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMIExecuteMethod(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN OUT PULONG OutBufferSize,
    IN OUT PUCHAR InOutBuffer
    );



typedef VOID (*WMI_NOTIFICATION_CALLBACK)(
    PVOID Wnode,
    PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMISetNotificationCallback(
    IN PVOID Object,
    IN WMI_NOTIFICATION_CALLBACK Callback,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMIHandleToInstanceName(
    IN PVOID DataBlockObject,
    IN HANDLE FileHandle,
    OUT PUNICODE_STRING InstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIDeviceObjectToInstanceName(
    IN PVOID DataBlockObject,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

// end_ntddk end_wdm end_ntifs end_ntosp



NTKERNELAPI
BOOLEAN
WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlock
    );

//
// IoRemoteBootClient indicates whether the system was booted as a remote
// boot client.
//

extern BOOLEAN IoRemoteBootClient;
#if defined(REMOTE_BOOT)
extern BOOLEAN IoCscInitializationFailed;
#endif // defined(REMOTE_BOOT)

// Used to convert a handle to a device stack.
NTSTATUS
IoGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation,
    IN BOOLEAN Quota
    );


// end_ntosp

//
// Safeboot definitions - placeholder until a home can be found.
//

typedef struct _BOOT_LOG_RECORD {
    UNICODE_STRING LoadedString;
    UNICODE_STRING NotLoadedString;
    UNICODE_STRING LogFileName;
    UNICODE_STRING HeaderString;
    ERESOURCE Resource;
    ULONG NextKey;
    BOOLEAN FileLogging;
} BOOT_LOG_RECORD, *PBOOT_LOG_RECORD;

VOID
IopCopyBootLogRegistryToFile(
    VOID
    );

VOID
IopInitializeBootLogging(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PCHAR HeaderString
    );

VOID
IopBootLog(
    PUNICODE_STRING LogEntry,
    BOOLEAN Loaded
    );

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    );

NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    );

NTSTATUS
IoShutdownPnpDevices(
    VOID
    );


VOID
IovFreeIrp(
    IN  PIRP    Irp
    );

PIRP
IovAllocateIrp(
    IN  CCHAR   StackSize,
    IN  BOOLEAN ChargeQuota
    );

VOID
IoVerifierInit(
    IN ULONG VerifierFlags
    );

NTSTATUS
FASTCALL
IovCallDriver(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    );

VOID
FASTCALL
IovCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

PIRP
IovBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );


PIRP
IovBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IovInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );


NTKERNELAPI
PVOID
IoAllocateGenericErrorLogEntry(
    IN UCHAR EntrySize
    );

VOID
IoRetryIrpCompletions(
    VOID
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif
// end_ntddk end_wdm end_ntifs end_ntosp

// begin_ntosp
NTKERNELAPI
VOID
FASTCALL
IoAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );
// end_ntosp


// begin_ntddk
NTKERNELAPI
VOID
FASTCALL
HalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoReadPartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoSetPartitionInformationEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

// begin_ntosp
DECLSPEC_DEPRECATED_DDK                 // Use IoWritePartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTKERNELAPI
NTSTATUS
IoCreateDisk(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _CREATE_DISK* Disk
    );

NTKERNELAPI
NTSTATUS
IoReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX** DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoWritePartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoSetPartitionInformationEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG PartitionNumber,
    IN struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );

NTKERNELAPI
NTSTATUS
IoUpdateDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DISK_GEOMETRY_EX* OldDiskGeometry,
    IN struct _DISK_GEOMETRY_EX* NewDiskGeometry
    );

NTKERNELAPI
NTSTATUS
IoVerifyPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FixErrors
    );

typedef struct _DISK_SIGNATURE {
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;

        struct {
            GUID DiskId;
        } Gpt;
    };
} DISK_SIGNATURE, *PDISK_SIGNATURE;

NTKERNELAPI
NTSTATUS
IoReadDiskSignature(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PDISK_SIGNATURE Signature
    );

// end_ntosp
// end_ntddk

// begin_ntosp begin_ntifs begin_ntddk

NTSTATUS
IoVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );
// end_ntosp end_ntifs end_ntddk

// begin_ntosp begin_ntifs
NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    );

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

// end_ntosp end_ntifs

// begin_ntosp begin_ntifs begin_ntddk

NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    );

// begin_wdm
VOID
IoFreeErrorLogEntry(
    PVOID ElEntry
    );

// Cancel SAFE API set start
//
// The following APIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of APIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue API set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel API code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel API set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//


//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2
#define IO_TYPE_CSQ_EX          3

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef NTSTATUS
(*PIO_CSQ_INSERT_IRP_EX)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp,
    IN OUT PVOID         InsertContext
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

//
// Initializes the cancel queue structure.
//

NTSTATUS
IoCsqInitialize(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );

NTSTATUS
IoCsqInitializeEx(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP_EX            CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );

//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

VOID
IoCsqInsertIrp(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );


NTSTATUS
IoCsqInsertIrpEx(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context,
    IN  PVOID               InsertContext
    );

//
// Returns an IRP if one can be found. NULL otherwise.
//

PIRP
IoCsqRemoveNextIrp(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    );

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

PIRP
IoCsqRemoveIrp(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

// Cancel SAFE API set end

// end_ntosp end_ntifs end_ntddk end_wdm

// begin_ntosp begin_ntifs

NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PVOID DeviceObject
    );

NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

// end_ntosp

NTKERNELAPI
BOOLEAN
IoIsFileOriginRemote(
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI
NTSTATUS
IoSetFileOrigin(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Remote
    );

// end_ntifs

PVOID
IoGetFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject
    );

NTSTATUS
IoChangeFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject,
    IN  PVOID           FilterContext,
    IN  BOOLEAN         Set
    );

BOOLEAN
IoIsDeviceEjectable(
    IN  PDEVICE_OBJECT
    );

NTSTATUS
IoComputeDesiredAccessFileObject(
    IN PFILE_OBJECT FileObject,
    OUT PNTSTATUS DesiredAccess
    );


// begin_ntosp begin_ntifs begin_ntddk

NTSTATUS
IoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    );



IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
    IN    PIRP    IRP
    );


// end_ntosp end_ntifs end_ntddk end_wdm

#endif // _IO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ke.h ===
/*++ BUILD Version: 0028    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ke.h

Abstract:

    This module contains the public (external) header file for the kernel.

Author:

    David N. Cutler (davec) 27-Feb-1989

Revision History:

--*/

#ifndef _KE_
#define _KE_

//
// Define the default quantum decrement values.
//

#define CLOCK_QUANTUM_DECREMENT 3
#define WAIT_QUANTUM_DECREMENT 1
#define LOCK_OWNERSHIP_QUANTUM (WAIT_QUANTUM_DECREMENT * 4)

//
// Define the default ready skip and thread quantum values.
//

#define READY_SKIP_QUANTUM 2
#define THREAD_QUANTUM (READY_SKIP_QUANTUM * CLOCK_QUANTUM_DECREMENT)

//
// Define the round trip decrement count.
//

#define ROUND_TRIP_DECREMENT_COUNT 16

//
// Performance data collection enable definitions.
//
// A definition turns on the respective data collection.
//

//#define _COLLECT_FLUSH_SINGLE_CALLDATA_ 1
//#define _COLLECT_SET_EVENT_CALLDATA_ 1
//#define _COLLECT_WAIT_SINGLE_CALLDATA_ 1

//
// Define thread switch performance data structure.
//

typedef struct _KTHREAD_SWITCH_COUNTERS {
    ULONG FindAny;
    ULONG FindIdeal;
    ULONG FindLast;
    ULONG IdleAny;
    ULONG IdleCurrent;
    ULONG IdleIdeal;
    ULONG IdleLast;
    ULONG PreemptAny;
    ULONG PreemptCurrent;
    ULONG PreemptLast;
    ULONG SwitchToIdle;
} KTHREAD_SWITCH_COUNTERS, *PKTHREAD_SWITCH_COUNTERS;

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

// begin_ntddk begin_wdm begin_ntosp

#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks

// end_ntddk end_wdm end_ntosp

#define EVENT_WAIT_BLOCK 2              // Builtin event pair wait block
#define SEMAPHORE_WAIT_BLOCK 2          // Builtin semaphore wait block
#define TIMER_WAIT_BLOCK 3              // Builtin timer wait block

#if (EVENT_WAIT_BLOCK != SEMAPHORE_WAIT_BLOCK)

#error "wait event and wait semaphore must use same wait block"

#endif

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 256

//
// Get APC environment of current thread.
//

#define KeGetCurrentApcEnvironment() \
    KeGetCurrentThread()->ApcStateIndex

//
// begin_ntddk begin_nthal begin_ntosp begin_ntifs
//

#if defined(_X86_)

#define PAUSE_PROCESSOR _asm { rep nop }

#else

#define PAUSE_PROCESSOR

#endif

// end_ntddk end_nthal end_ntosp end_ntifs

// begin_nthal begin_ntosp

//
// Define macro to generate an affinity mask.
//

#if defined(_NTHAL_) || defined(_NTOSP_)

#define AFFINITY_MASK(n) ((ULONG_PTR)1 << (n))

#else

#if !defined(_WIN64)

#define KiAffinityArray KiMask32Array

#endif

extern const ULONG_PTR KiAffinityArray[];

#define AFFINITY_MASK(n) (KiAffinityArray[n])

#endif

// end_nthal end_ntosp

//
// Define macro to generate priority mask.
//

extern const ULONG KiMask32Array[];

#define PRIORITY_MASK(n) (KiMask32Array[n])

//
// Define query system time macro.
//
// The following AMD64 code reads an unaligned quadword value. The quadword
// value, however, is guaranteed to be within a cache line, and therefore,
// the value will be read atomically.
//

#if defined(_AMD64_)

#define KiQuerySystemTime(CurrentTime) \
    (CurrentTime)->QuadPart = *((LONG64 volatile *)(&SharedUserData->SystemTime))

#else

#define KiQuerySystemTime(CurrentTime) \
    while (TRUE) {                                                                  \
        (CurrentTime)->HighPart = SharedUserData->SystemTime.High1Time;             \
        (CurrentTime)->LowPart = SharedUserData->SystemTime.LowPart;                \
        if ((CurrentTime)->HighPart == SharedUserData->SystemTime.High2Time) break; \
        PAUSE_PROCESSOR                                                             \
    }

#endif

#if defined(_AMD64_)

#define KiQueryLowTickCount() SharedUserData->TickCount.LowPart

#else

#define KiQueryLowTickCount() KeTickCount.LowPart

#endif

//
// Enumerated kernel types
//
// Kernel object types.
//
//  N.B. There are really two types of event objects; NotificationEvent and
//       SynchronizationEvent. The type value for a notification event is 0,
//       and that for a synchronization event 1.
//
//  N.B. There are two types of new timer objects; NotificationTimer and
//       SynchronizationTimer. The type value for a notification timer is
//       8, and that for a synchronization timer is 9. These values are
//       very carefully chosen so that the dispatcher object type AND'ed
//       with 0x7 yields 0 or 1 for event objects and the timer objects.
//

#define DISPATCHER_OBJECT_TYPE_MASK 0x7

typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject,
    ThreadedDpcObject,
    MaximumKernelObject
    } KOBJECTS;

#define KOBJECT_LOCK_BIT 0x80

C_ASSERT((MaximumKernelObject & KOBJECT_LOCK_BIT) == 0);

//
// APC environments.
//

// begin_ntosp

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
    } KAPC_ENVIRONMENT;

// begin_ntddk begin_wdm begin_nthal begin_ntminiport begin_ntifs begin_ntndis

//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

// end_ntddk end_wdm end_nthal end_ntminiport end_ntifs end_ntndis end_ntosp

//
// Process states.
//

typedef enum _KPROCESS_STATE {
    ProcessInMemory,
    ProcessOutOfMemory,
    ProcessInTransition,
    ProcessOutTransition,
    ProcessInSwap,
    ProcessOutSwap
    } KPROCESS_STATE;

//
// Thread scheduling states.
//

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady
    } KTHREAD_STATE;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    Spare2,
    Spare3,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    MaximumWaitReason
    } KWAIT_REASON;

// end_ntddk end_wdm end_nthal

//
// Miscellaneous type definitions
//
// APC state
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;

// end_ntifs end_ntosp

//
// Page frame
//

typedef ULONG KPAGE_FRAME;

//
// Wait block
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// System service table descriptor.
//
// N.B. A system service number has a 12-bit service table offset and a
//      3-bit service table number.
//
// N.B. Descriptor table entries must be a power of 2 in size. Currently
//      this is 16 bytes on a 32-bit system and 32 bytes on a 64-bit
//      system.
//

#define NUMBER_SERVICE_TABLES 4
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 2) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 2) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    PULONG_PTR Base;
    PULONG Count;
    ULONG Limit;

#if defined(_IA64_)

    LONG TableBaseGpOffset;

#endif

    PUCHAR Number;
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;

//
// Procedure type definitions
//
// Debug routine
//

typedef
BOOLEAN
(*PKDEBUG_ROUTINE) (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

typedef
BOOLEAN
(*PKDEBUG_SWITCH_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

typedef enum {
    ContinueError = FALSE,
    ContinueSuccess = TRUE,
    ContinueProcessorReselected,
    ContinueNextProcessor
} KCONTINUE_STATUS;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Thread system function
//

typedef
VOID
(*PKSYSTEM_ROUTINE) (
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;
    BOOLEAN Busy;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
//
// Event pair object
//

typedef struct _KEVENT_PAIR {
    CSHORT Type;
    CSHORT Size;
    KEVENT EventLow;
    KEVENT EventHigh;
} KEVENT_PAIR, *PKEVENT_PAIR, *RESTRICTED_POINTER PRKEVENT_PAIR;

// begin_nthal begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Define the interrupt service function type and the empty struct
// type.
//
// end_ntddk end_wdm end_ntifs end_ntosp

struct _KINTERRUPT;

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

// end_ntddk end_wdm end_ntifs end_ntosp

//
// Interrupt object
//
// N.B. The layout of this structure cannot change. It is exported to HALs
//      to short circuit interrupt dispatch.
//

typedef struct _KINTERRUPT {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY InterruptListEntry;
    PKSERVICE_ROUTINE ServiceRoutine;
    PVOID ServiceContext;
    KSPIN_LOCK SpinLock;
    ULONG TickCount;
    PKSPIN_LOCK ActualLock;
    PKINTERRUPT_ROUTINE DispatchAddress;
    ULONG Vector;
    KIRQL Irql;
    KIRQL SynchronizeIrql;
    BOOLEAN FloatingSave;
    BOOLEAN Connected;
    CCHAR Number;
    BOOLEAN ShareVector;
    KINTERRUPT_MODE Mode;
    ULONG ServiceCount;
    ULONG DispatchCount;

#if defined(_AMD64_)

    PKTRAP_FRAME TrapFrame;

#endif

    ULONG DispatchCode[DISPATCH_LENGTH];
} KINTERRUPT;

typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; // ntndis ntosp

// begin_ntifs begin_ntddk begin_wdm begin_ntosp
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT, KMUTEX, *PKMUTEX, *RESTRICTED_POINTER PRKMUTEX;

// end_ntddk end_wdm end_ntosp
//
// Queue object
//

#define ASSERT_QUEUE(Q) ASSERT(((Q)->Header.Type & ~KOBJECT_LOCK_BIT) == QueueObject);

// begin_ntosp

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;

// end_ntosp

// begin_ntddk begin_wdm begin_ntosp
//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

#if !defined(_X86_)

//
// ALIGNMENT_EXCEPTION_TABLE is used to track alignment exceptions in
// processes that are attached to a debugger.
//

#define ALIGNMENT_RECORDS_PER_TABLE 64
#define MAXIMUM_ALIGNMENT_TABLES    16

typedef struct _ALIGNMENT_EXCEPTION_RECORD {
    PVOID ProgramCounter;
    ULONG Count;
    BOOLEAN AutoFixup;
} ALIGNMENT_EXCEPTION_RECORD, *PALIGNMENT_EXCEPTION_RECORD;

typedef struct _ALIGNMENT_EXCEPTION_TABLE *PALIGNMENT_EXCEPTION_TABLE;
typedef struct _ALIGNMENT_EXCEPTION_TABLE {
    PALIGNMENT_EXCEPTION_TABLE Next;
    ALIGNMENT_EXCEPTION_RECORD RecordArray[ ALIGNMENT_RECORDS_PER_TABLE ];
} ALIGNMENT_EXCEPTION_TABLE;

#endif

// begin_nthal
//
// Define the maximum number of nodes supported.
//
// N.B. Node number must fit in the page color field of a PFN entry.
//

#define MAXIMUM_CCNUMA_NODES    16

// end_nthal
//
// Define node structure for multinode systems.
//

#define KeGetCurrentNode() (KeGetCurrentPrcb()->ParentNode)

typedef struct _KNODE {
    KAFFINITY ProcessorMask;            // Physical & Logical CPUs
    ULONG Color;                        // Public 0 based node color
    ULONG MmShiftedColor;               // MM private shifted color
    PFN_NUMBER FreeCount[2];            // # colored pages free
    SLIST_HEADER DeadStackList;         // MM per node dead stack list
    SLIST_HEADER PfnDereferenceSListHead; // MM per node deferred PFN freelist
    PSLIST_ENTRY PfnDeferredList;       // MM per node deferred PFN list
    UCHAR Seed;                         // Ideal Processor Seed
    UCHAR NodeNumber;
    struct _flags {
        BOOLEAN Removable;              // Node can be removed
    } Flags;

} KNODE, *PKNODE;

extern PKNODE KeNodeBlock[];

//
// Process object structure definition
//

typedef struct _KPROCESS {

    //
    // The dispatch header and profile listhead are fairly infrequently
    // referenced.
    //

    DISPATCHER_HEADER Header;
    LIST_ENTRY ProfileListHead;

    //
    // The following fields are referenced during context switches.
    //

    ULONG_PTR DirectoryTableBase[2];

#if defined(_X86_)

    KGDTENTRY LdtDescriptor;
    KIDTENTRY Int21Descriptor;
    USHORT IopmOffset;
    UCHAR Iopl;
    BOOLEAN Unused;

#endif

#if defined(_AMD64_)

    USHORT IopmOffset;

#endif

#if defined(_IA64_)

    REGION_MAP_INFO ProcessRegion;
    PREGION_MAP_INFO SessionMapInfo;
    ULONG_PTR SessionParentBase;

#endif // _IA64_

    volatile KAFFINITY ActiveProcessors;

    //
    // The following fields are referenced during clock interrupts.
    //

    ULONG KernelTime;
    ULONG UserTime;

    //
    // The following fields are referenced infrequently.
    //

    LIST_ENTRY ReadyListHead;
    SINGLE_LIST_ENTRY SwapListEntry;

#if defined(_X86_)

    PVOID VdmTrapcHandler;

#else

    PVOID Reserved1;

#endif

    LIST_ENTRY ThreadListHead;
    KSPIN_LOCK ProcessLock;
    KAFFINITY Affinity;
    USHORT StackCount;
    SCHAR BasePriority;
    SCHAR ThreadQuantum;
    BOOLEAN AutoAlignment;
    UCHAR State;
    UCHAR ThreadSeed;
    BOOLEAN DisableBoost;
    UCHAR PowerState;
    BOOLEAN DisableQuantum;
    UCHAR IdealNode;
    UCHAR Spare;

#if !defined(_X86_)

    PALIGNMENT_EXCEPTION_TABLE AlignmentExceptionTable;

#endif

} KPROCESS, *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;

//
// Thread object
//

typedef enum _ADJUST_REASON {
    AdjustNone = 0,
    AdjustUnwait = 1,
    AdjustBoost = 2
} ADJUST_REASON;

typedef struct _KTHREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced.
    //

    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListHead;

    //
    // The following fields are referenced during context switches and wait
    // operatings. They have been carefully laid out to get the best cache
    // hit ratios.
    //

    PVOID InitialStack;
    PVOID StackLimit;
    PVOID KernelStack;

#if defined(_IA64_)

    PVOID InitialBStore;
    PVOID BStoreLimit;
    CCHAR Number;          // must match the size of Number in KPCR
                           // set to the processor number last time
                           // this thread uses the high fp register set
                           // see KiRestoreHighFPVolatile in trap.s for details
    BOOLEAN Spare3;
    PVOID KernelBStore;

#endif

    KSPIN_LOCK ThreadLock;
    ULONG ContextSwitches;
    volatile UCHAR State;
    UCHAR NpxState;
    KIRQL WaitIrql;
    KPROCESSOR_MODE WaitMode;
    PVOID Teb;
    KAPC_STATE ApcState;
    KSPIN_LOCK ApcQueueLock;
    LONG_PTR WaitStatus;
    PRKWAIT_BLOCK WaitBlockList;
    BOOLEAN Alertable;
    BOOLEAN WaitNext;
    UCHAR WaitReason;
    SCHAR Priority;
    UCHAR EnableStackSwap;
    volatile UCHAR SwapBusy;
    BOOLEAN Alerted[MaximumMode];
    union {
        LIST_ENTRY WaitListEntry;
        SINGLE_LIST_ENTRY SwapListEntry;
    };

    PRKQUEUE Queue;
    ULONG WaitTime;
    union {
        struct {
            SHORT KernelApcDisable;
            SHORT SpecialApcDisable;
        };

        ULONG CombinedApcDisable;
    };

    KTIMER Timer;
    KWAIT_BLOCK WaitBlock[THREAD_WAIT_OBJECTS + 1];
    LIST_ENTRY QueueListEntry;

    //
    // The following fields are referenced during ready thread and wait
    // completion.
    //

    UCHAR ApcStateIndex;
    BOOLEAN ApcQueueable;
    BOOLEAN Preempted;
    BOOLEAN ProcessReadyQueue;
    BOOLEAN KernelStackResident;
    CHAR Saturation;
    UCHAR IdealProcessor;
    volatile UCHAR NextProcessor;
    SCHAR BasePriority;
    UCHAR Spare4;
    SCHAR PriorityDecrement;
    SCHAR Quantum;
    BOOLEAN SystemAffinityActive;
    CCHAR PreviousMode;
    UCHAR ResourceIndex;
    UCHAR DisableBoost;
    KAFFINITY UserAffinity;
    PKPROCESS Process;
    KAFFINITY Affinity;

    //
    // The below fields are infrequently referenced.
    //

    PVOID ServiceTable;
    PKAPC_STATE ApcStatePointer[2];
    KAPC_STATE SavedApcState;
    PVOID CallbackStack;

#if defined(_IA64_)

    PVOID CallbackBStore;

#endif

    PVOID Win32Thread;
    PKTRAP_FRAME TrapFrame;
    ULONG KernelTime;
    ULONG UserTime;
    PVOID StackBase;
    KAPC SuspendApc;
    KSEMAPHORE SuspendSemaphore;
    PVOID TlsArray;
    PVOID LegoData;
    LIST_ENTRY ThreadListEntry;
    UCHAR LargeStack;
    UCHAR PowerState;
    UCHAR NpxIrql;
    UCHAR Spare5;
    BOOLEAN AutoAlignment;
    UCHAR Iopl;
    CCHAR FreezeCount;
    CCHAR SuspendCount;
    UCHAR Spare0[1];
    UCHAR UserIdealProcessor;
    volatile UCHAR DeferredProcessor;
    UCHAR AdjustReason;
    SCHAR AdjustIncrement;
    UCHAR Spare2[3];

} KTHREAD, *PKTHREAD, *RESTRICTED_POINTER PRKTHREAD;

//
// ccNUMA supported in multiprocessor PAE and WIN64 systems only.
//

#if (defined(_WIN64) || defined(_X86PAE_)) && !defined(NT_UP)

#define KE_MULTINODE

#endif

//
// Profile object structure definition
//

typedef struct _KPROFILE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY ProfileListEntry;
    PKPROCESS Process;
    PVOID RangeBase;
    PVOID RangeLimit;
    ULONG BucketShift;
    PVOID Buffer;
    ULONG Segment;
    KAFFINITY Affinity;
    CSHORT Source;
    BOOLEAN Started;
} KPROFILE, *PKPROFILE, *RESTRICTED_POINTER PRKPROFILE;

//
// Kernel control object functions
//
// APC object
//

// begin_ntosp

NTKERNELAPI
VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN KAPC_ENVIRONMENT Environment,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ProcessorMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    );

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    );

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    );

VOID
KeGenericCallDpc (
    IN PKDEFERRED_ROUTINE Routine,
    IN PVOID Context
    );

VOID
KeSignalCallDpcDone (
    IN PVOID SystemArgument1
    );

LOGICAL
KeSignalCallDpcSynchronize (
    IN PVOID SystemArgument2
    );

// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

// end_ntddk end_wdm end_nthal end_ntifs
NTKERNELAPI
VOID
KeInitializeThreadedDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );
// begin_ntddk begin_wdm begin_nthal begin_ntifs

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

// end_wdm

NTKERNELAPI
VOID
KeSetImportanceDpc (
    IN PRKDPC Dpc,
    IN KDPC_IMPORTANCE Importance
    );

NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    IN PRKDPC Dpc,
    IN CCHAR Number
    );

// begin_wdm

NTKERNELAPI
VOID
KeFlushQueuedDpcs (
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

// end_ntddk end_wdm end_ntifs end_ntosp

//
// Interrupt object
//

NTKERNELAPI                                         
VOID                                                
KeInitializeInterrupt (                             
    IN PKINTERRUPT Interrupt,                       
    IN PKSERVICE_ROUTINE ServiceRoutine,            
    IN PVOID ServiceContext,                        
    IN PKSPIN_LOCK SpinLock OPTIONAL,               
    IN ULONG Vector,                                
    IN KIRQL Irql,                                  
    IN KIRQL SynchronizeIrql,                       
    IN KINTERRUPT_MODE InterruptMode,               
    IN BOOLEAN ShareVector,                         
    IN CCHAR ProcessorNumber,                       
    IN BOOLEAN FloatingSave                         
    );

#if defined(_AMD64_)

#define NO_INTERRUPT_SPINLOCK ((PKSPIN_LOCK)-1I64)

#endif

                                                    
NTKERNELAPI                                         
BOOLEAN                                             
KeConnectInterrupt (                                
    IN PKINTERRUPT Interrupt                        
    );                                              

// end_nthal

NTKERNELAPI
BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

NTKERNELAPI
BOOLEAN
KeSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTKERNELAPI
KIRQL
KeAcquireInterruptSpinLock (
    IN PKINTERRUPT Interrupt
    );

NTKERNELAPI
VOID
KeReleaseInterruptSpinLock (
    IN PKINTERRUPT Interrupt,
    IN KIRQL OldIrql
    );

// end_ntddk end_wdm end_nthal end_ntosp

//
// Profile object
//

VOID
KeInitializeProfile (
    IN PKPROFILE Profile,
    IN PKPROCESS Process OPTIONAL,
    IN PVOID RangeBase,
    IN SIZE_T RangeSize,
    IN ULONG BucketSize,
    IN ULONG Segment,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );

BOOLEAN
KeStartProfile (
    IN PKPROFILE Profile,
    IN PULONG Buffer
    );

BOOLEAN
KeStopProfile (
    IN PKPROFILE Profile
    );

VOID
KeSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );

ULONG
KeQueryIntervalProfile (
    IN KPROFILE_SOURCE Source
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Kernel dispatcher object functions
//
// Event Object
//

// end_wdm end_ntddk end_nthal end_ntifs end_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    IN PRKEVENT Event
    );

// end_wdm end_ntddk end_nthal end_ntifs end_ntosp

#else

#define KeInitializeEvent(_Event, _Type, _State)            \
    (_Event)->Header.Type = (UCHAR)_Type;                   \
    (_Event)->Header.Size =  sizeof(KEVENT) / sizeof(LONG); \
    (_Event)->Header.SignalState = _State;                  \
    InitializeListHead(&(_Event)->Header.WaitListHead)

#define KeClearEvent(Event) (Event)->Header.SignalState = 0

#endif

// begin_ntddk begin_ntifs begin_ntosp

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

// end_ntddk end_ntifs end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
LONG
KeReadStateEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    );

VOID
KeInitializeEventPair (
    IN PKEVENT_PAIR EventPair
    );

#define KeSetHighEventPair(EventPair, Increment, Wait) \
    KeSetEvent(&((EventPair)->EventHigh),              \
               Increment,                              \
               Wait)

#define KeSetLowEventPair(EventPair, Increment, Wait)  \
    KeSetEvent(&((EventPair)->EventLow),               \
               Increment,                              \
               Wait)

//
// Mutant object
//
// begin_ntifs

NTKERNELAPI
VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    );

LONG
KeReadStateMutant (
    IN PRKMUTANT Mutant
    );

NTKERNELAPI
LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Mutex object
//

NTKERNELAPI
VOID
KeInitializeMutex (
    IN PRKMUTEX Mutex,
    IN ULONG Level
    );

NTKERNELAPI
LONG
KeReadStateMutex (
    IN PRKMUTEX Mutex
    );

NTKERNELAPI
LONG
KeReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm
//
// Queue Object.
//

NTKERNELAPI
VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    );

NTKERNELAPI
LONG
KeReadStateQueue (
    IN PRKQUEUE Queue
    );

NTKERNELAPI
LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    );

// begin_ntddk begin_wdm
//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

NTKERNELAPI
LONG
KeReadStateSemaphore (
    IN PRKSEMAPHORE Semaphore
    );

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Process object
//

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY Priority,
    IN KAFFINITY Affinity,
    IN ULONG_PTR DirectoryTableBase[2],
    IN BOOLEAN Enable
    );

LOGICAL
KeForceAttachProcess (
    IN PKPROCESS Process
    );

// begin_ntifs begin_ntosp

NTKERNELAPI
VOID
KeAttachProcess (
    IN PRKPROCESS Process
    );

NTKERNELAPI
VOID
KeDetachProcess (
    VOID
    );

NTKERNELAPI
VOID
KeStackAttachProcess (
    IN PRKPROCESS PROCESS,
    OUT PRKAPC_STATE ApcState
    );

NTKERNELAPI
VOID
KeUnstackDetachProcess (
    IN PRKAPC_STATE ApcState
    );

// end_ntifs end_ntosp

#define KiIsAttachedProcess() \
    (KeGetCurrentThread()->ApcStateIndex == AttachedApcEnvironment)

#if !defined(_NTOSP_)

#define KeIsAttachedProcess() KiIsAttachedProcess()

#else

// begin_ntosp

NTKERNELAPI
BOOLEAN
KeIsAttachedProcess(
    VOID
    );

// end_ntosp

#endif

LONG
KeReadStateProcess (
    IN PRKPROCESS Process
    );

BOOLEAN
KeSetAutoAlignmentProcess (
    IN PRKPROCESS Process,
    IN BOOLEAN Enable
    );

LONG
KeSetProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

KAFFINITY
KeSetAffinityProcess (
    IN PKPROCESS Process,
    IN KAFFINITY Affinity
    );

KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY BasePriority
    );

LOGICAL
KeSetDisableQuantumProcess (
    IN PKPROCESS Process,
    IN LOGICAL Disable
    );

#define KeTerminateProcess(Process) \
    (Process)->StackCount += 1;

//
// Thread object
//

NTSTATUS
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack OPTIONAL,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL,
    IN PVOID Teb OPTIONAL,
    IN PKPROCESS Process
    );

NTSTATUS
KeInitThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack OPTIONAL,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL,
    IN PVOID Teb OPTIONAL,
    IN PKPROCESS Process
    );

VOID
KeUninitThread (
    IN PKTHREAD Thread
    );

VOID
KeStartThread (
    IN PKTHREAD Thread
    );

BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    );

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    );

// begin_ntosp

NTKERNELAPI                                         // ntddk wdm nthal ntifs
NTSTATUS                                            // ntddk wdm nthal ntifs
KeDelayExecutionThread (                            // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE WaitMode,                    // ntddk wdm nthal ntifs
    IN BOOLEAN Alertable,                           // ntddk wdm nthal ntifs
    IN PLARGE_INTEGER Interval                      // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
// end_ntosp

LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    );

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    );

VOID
KeFreezeAllThreads (
    VOID
    );

BOOLEAN
KeQueryAutoAlignmentThread (
    IN PKTHREAD Thread
    );

LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI                                         // ntddk wdm nthal ntifs
KPRIORITY                                           // ntddk wdm nthal ntifs
KeQueryPriorityThread (                             // ntddk wdm nthal ntifs
    IN PKTHREAD Thread                              // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
NTKERNELAPI                                         // ntddk wdm nthal ntifs
ULONG                                               // ntddk wdm nthal ntifs
KeQueryRuntimeThread (                              // ntddk wdm nthal ntifs
    IN PKTHREAD Thread,                             // ntddk wdm nthal ntifs
    OUT PULONG UserTime                             // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
BOOLEAN
KeReadStateThread (
    IN PKTHREAD Thread
    );

VOID
KeReadyThread (
    IN PKTHREAD Thread
    );

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    );

// begin_nthal begin_ntosp

VOID
KeRevertToUserAffinityThread (
    VOID
    );

// end_nthal end_ntosp

VOID
KeRundownThread (
    VOID
    );

KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

// begin_nthal begin_ntosp

VOID
KeSetSystemAffinityThread (
    IN KAFFINITY Affinity
    );

// end_nthal end_ntosp

BOOLEAN
KeSetAutoAlignmentThread (
    IN PKTHREAD Thread,
    IN BOOLEAN Enable
    );

NTKERNELAPI                                         // ntddk nthal ntifs ntosp
LONG                                                // ntddk nthal ntifs ntosp
KeSetBasePriorityThread (                           // ntddk nthal ntifs ntosp
    IN PKTHREAD Thread,                             // ntddk nthal ntifs ntosp
    IN LONG Increment                               // ntddk nthal ntifs ntosp
    );                                              // ntddk nthal ntifs ntosp
                                                    // ntddk nthal ntifs ntosp

// begin_ntifs

NTKERNELAPI
UCHAR
KeSetIdealProcessorThread (
    IN PKTHREAD Thread,
    IN UCHAR Processor
    );

// begin_ntosp
NTKERNELAPI
BOOLEAN
KeSetKernelStackSwapEnable (
    IN BOOLEAN Enable
    );

// end_ntifs

NTKERNELAPI                                         // ntddk wdm nthal ntifs
KPRIORITY                                           // ntddk wdm nthal ntifs
KeSetPriorityThread (                               // ntddk wdm nthal ntifs
    IN PKTHREAD Thread,                             // ntddk wdm nthal ntifs
    IN KPRIORITY Priority                           // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs

// end_ntosp

ULONG
KeSuspendThread (
    IN PKTHREAD
    );

NTKERNELAPI
VOID
KeTerminateThread (
    IN KPRIORITY Increment
    );

BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE
    );

VOID
KeThawAllThreads (
    VOID
    );

// begin_ntddk begin_nthal begin_ntifs begin_ntosp

#if ((defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) ||defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_) || defined(_NTOSP_))

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

NTKERNELAPI
BOOLEAN
KeAreApcsDisabled (
    VOID
    );

// end_wdm

#endif

// begin_wdm

//
// Timer object
//

NTKERNELAPI
VOID
KeInitializeTimer (
    IN PKTIMER Timer
    );

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    PKTIMER Timer
    );

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp

extern volatile KAFFINITY KiIdleSummary;

FORCEINLINE
BOOLEAN
KeIsSMTSetIdle (
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This routine determines whether the complete SMT set associated with the
    specified processor is idle.

Arguments:

    Prcb - Supplies a pointer to a processor control block (PRCB).

Return Value:

    If the specified SMT set is idle, then TRUE is returned. Otherwise, FALSE
    is returned.

--*/

{

#if !defined(NT_UP) && defined(_X86_)

    if ((KiIdleSummary & Prcb->MultiThreadProcessorSet) == Prcb->MultiThreadProcessorSet) {
        return TRUE;

    } else {
        return FALSE;
    }

#else

    UNREFERENCED_PARAMETER(Prcb);

    return TRUE;

#endif

}

/*++

KPROCESSOR_MODE
KeGetPreviousMode (
    VOID
    )

Routine Description:

    This function gets the threads previous mode from the trap frame


Arguments:

   None.

Return Value:

    KPROCESSOR_MODE - Previous mode for this thread.

--*/

#define KeGetPreviousMode() (KeGetCurrentThread()->PreviousMode)

/*++

KPROCESSOR_MODE
KeGetPReviousModeByThread (
    PKTHREAD xxCurrentThread
    )

Routine Description:

    This function gets the threads previous mode from the trap frame.


Arguments:

   xxCurrentThread - Current thread.

   N.B. This must be the current thread.

Return Value:

    KPROCESSOR_MODE - Previous mode for this thread.

--*/

#define KeGetPreviousModeByThread(xxCurrentThread)                          \
    (ASSERT (xxCurrentThread == KeGetCurrentThread ()),                     \
    (xxCurrentThread)->PreviousMode)

VOID
KeCheckForTimer(
    IN PVOID p,
    IN SIZE_T Size
    );

VOID
KeClearTimer (
    IN PKTIMER Timer
    );

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    );

//
// Wait functions
//

NTSTATUS
KiSetServerWaitClientEvent (
    IN PKEVENT SeverEvent,
    IN PKEVENT ClientEvent,
    IN ULONG WaitMode
    );

#define KeSetHighWaitLowEventPair(EventPair, WaitMode)                  \
    KiSetServerWaitClientEvent(&((EventPair)->EventHigh),               \
                               &((EventPair)->EventLow),                \
                               WaitMode)

#define KeSetLowWaitHighEventPair(EventPair, WaitMode)                  \
    KiSetServerWaitClientEvent(&((EventPair)->EventLow),                \
                               &((EventPair)->EventHigh),               \
                               WaitMode)

#define KeWaitForHighEventPair(EventPair, WaitMode, Alertable, TimeOut) \
    KeWaitForSingleObject(&((EventPair)->EventHigh),                    \
                          WrEventPair,                                  \
                          WaitMode,                                     \
                          Alertable,                                    \
                          TimeOut)

#define KeWaitForLowEventPair(EventPair, WaitMode, Alertable, TimeOut)  \
    KeWaitForSingleObject(&((EventPair)->EventLow),                     \
                          WrEventPair,                                  \
                          WaitMode,                                     \
                          Alertable,                                    \
                          TimeOut)

FORCEINLINE
VOID
KeWaitForContextSwap (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine waits until context swap is idle for the specified thread.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    while (Thread->SwapBusy != FALSE) {
        KeYieldProcessor();
    }

#else

    UNREFERENCED_PARAMETER(Thread);

#endif

    return;
}

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

#define KeWaitForMutexObject KeWaitForSingleObject

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray OPTIONAL
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
// Define interprocess interrupt generic call types.
//

typedef
ULONG_PTR
(*PKIPI_BROADCAST_WORKER)(
    IN ULONG_PTR Argument
    );

ULONG_PTR
KeIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    );

// end_ntosp end_ntddk end_wdm end_nthal end_ntifs

//
// Define internal kernel functions.
//
// N.B. These definitions are not public and are used elsewhere only under
//      very special circumstances.
//

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp

//
// On X86 the following routines are defined in the HAL and imported by
// all other modules.
//

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  __declspec(dllimport)

#else

#define _DECL_HAL_KE_IMPORT

#endif

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis end_ntosp

#if defined(NT_UP)

#define KeTestForWaitersQueuedSpinLock(Number) FALSE

#define KeAcquireQueuedSpinLockRaiseToSynch(Number) \
    KeRaiseIrqlToSynchLevel()

#define KeAcquireQueuedSpinLock(Number) \
    KeRaiseIrqlToDpcLevel()

#define KeReleaseQueuedSpinLock(Number, OldIrql) \
    KeLowerIrql(OldIrql)

#define KeTryToAcquireQueuedSpinLockRaiseToSynch(Number, OldIrql) \
    (*(OldIrql) = KeRaiseIrqlToSynchLevel(), TRUE)

#define KeTryToAcquireQueuedSpinLock(Number, OldIrql) \
    (KeRaiseIrql(DISPATCH_LEVEL, OldIrql), TRUE)

#define KeAcquireQueuedSpinLockAtDpcLevel(LockQueue)

#define KeReleaseQueuedSpinLockFromDpcLevel(LockQueue)

#define KeTryToAcquireQueuedSpinLockAtRaisedIrql(LockQueue) (TRUE)

#else // NT_UP

//
// Queued spin lock functions.
//

FORCEINLINE
LOGICAL
KeTestForWaitersQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

{

    PKSPIN_LOCK Spinlock;
    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    Spinlock =
        (PKSPIN_LOCK)((ULONG_PTR)Prcb->LockQueue[Number].Lock & ~(LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER));

    return (*Spinlock != 0);
}

VOID
FASTCALL
KeAcquireQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    );

VOID
FASTCALL
KeReleaseQueuedSpinLockFromDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    );

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLockAtRaisedIrql (
    IN PKSPIN_LOCK_QUEUE QueuedLock
    );

// begin_ntifs begin_ntosp

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    );

_DECL_HAL_KE_IMPORT
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    );

// end_ntifs end_ntosp

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireQueuedSpinLockRaiseToSynch (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    );

_DECL_HAL_KE_IMPORT
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLockRaiseToSynch(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    );

#endif  // NT_UP

#define KeQueuedSpinLockContext(n)  (&(KeGetCurrentPrcb()->LockQueue[n]))

//
// On Uni-processor systems there is no real Dispatcher Database Lock
// so raising to SYNCH won't help get the lock released any sooner.
//

#if defined(NT_UP)

#if defined(_X86_)

#define KiLockDispatcherDatabase(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#else

#define KiLockDispatcherDatabase(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToSynchLevel()

#endif

#else   // NT_UP

#define KiLockDispatcherDatabase(OldIrql) \
    *(OldIrql) = KeAcquireQueuedSpinLockRaiseToSynch(LockQueueDispatcherLock)

#endif  // NT_UP

#if defined(NT_UP)

#define KiLockDispatcherDatabaseAtSynchLevel()
#define KiUnlockDispatcherDatabaseFromSynchLevel()

#else

#define KiLockDispatcherDatabaseAtSynchLevel() \
    KeAcquireQueuedSpinLockAtDpcLevel(&KeGetCurrentPrcb()->LockQueue[LockQueueDispatcherLock])

#define KiUnlockDispatcherDatabaseFromSynchLevel() \
    KeReleaseQueuedSpinLockFromDpcLevel(&KeGetCurrentPrcb()->LockQueue[LockQueueDispatcherLock])

#endif

VOID
FASTCALL
KiSetPriorityThread (
    IN PRKTHREAD Thread,
    IN KPRIORITY Priority
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//
// spin lock functions
//

#if defined(_X86_) && (defined(_WDMDDK_) || defined(WIN9X_COMPAT_SPINLOCK))

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#else

__inline
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    ) 
{
    *SpinLock = 0;
}

#endif

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

// end_wdm end_ntddk

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm begin_ntddk

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#else

//
// These functions are imported for IA64, ntddk, ntifs, nthal, ntosp, and wdm.
// They can be inlined for the system on AMD64.
//

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

#if defined(_IA64_) || defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_) || defined(_WDMDDK_)

// end_wdm end_ntddk

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm begin_ntddk

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#else

#if defined(_AMD64_)

//
// The system version of these functions are defined in amd64.h for AMD64.
//

#endif

#endif

#endif

// end_wdm end_ntddk end_nthal end_ntifs

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KeReleaseSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OldIrql
    );

// end_ntndis end_ntosp

#if !defined(_AMD64_)

BOOLEAN
KeTryToAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock,
    OUT PKIRQL OldIrql
    );

#endif

//
// Enable and disable interrupts.
//
// begin_nthal
//

NTKERNELAPI
BOOLEAN
KeDisableInterrupts (
    VOID
    );

NTKERNELAPI
VOID
KeEnableInterrupts (
    IN BOOLEAN Enable
    );

// end_nthal

//
// Raise and lower IRQL functions.
//

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || !defined(_APIC_TPR_)

// begin_nthal begin_wdm begin_ntddk begin_ntifs begin_ntosp

#if defined(_X86_)

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

// end_wdm

_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

// end_ntddk

_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

// begin_wdm begin_ntddk

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

// end_wdm

// begin_wdm

#elif defined(_IA64_)

//
// These function are defined in IA64.h for the IA64 platform.
//


#elif defined(_AMD64_)

//
// These function are defined in amd64.h for the AMD64 platform.
//

#else

#error "no target architecture"

#endif

// end_nthal end_wdm end_ntddk end_ntifs end_ntosp

#else

extern PUCHAR HalpIRQLToTPR;
extern PUCHAR HalpVectorToIRQL;
#define APIC_TPR ((volatile ULONG *)0xFFFE0080)

#define KeGetCurrentIrql _KeGetCurrentIrql
#define KfLowerIrql _KfLowerIrql
#define KfRaiseIrql _KfRaiseIrql

KIRQL
FORCEINLINE
KeGetCurrentIrql (
    VOID
    )
{
    ULONG tprValue;
    KIRQL currentIrql;

    tprValue = *APIC_TPR;
    currentIrql = HalpVectorToIRQL[ tprValue / 16 ];
    return currentIrql;
}

VOID
FORCEINLINE
KfLowerIrql (
    IN KIRQL NewIrql
    )
{
    ULONG tprValue;

    ASSERT( NewIrql <= KeGetCurrentIrql() );

    tprValue = HalpIRQLToTPR[NewIrql];
    KeMemoryBarrier();
    *APIC_TPR = tprValue;
    *APIC_TPR;
    KeMemoryBarrier();
}   

KIRQL
FORCEINLINE
KfRaiseIrql (
    IN KIRQL NewIrql
    )
{
    KIRQL oldIrql;
    ULONG tprValue;

    oldIrql = KeGetCurrentIrql();
    ASSERT( NewIrql >= oldIrql );

    tprValue = HalpIRQLToTPR[NewIrql];

    KeMemoryBarrier();
    *APIC_TPR = tprValue;
    KeMemoryBarrier();

    return oldIrql;
}

KIRQL
FORCEINLINE
KeRaiseIrqlToDpcLevel (
    VOID
    )
{
    return KfRaiseIrql(DISPATCH_LEVEL);
}

KIRQL
FORCEINLINE
KeRaiseIrqlToSynchLevel (
    VOID
    )
{
    return KfRaiseIrql(SYNCH_LEVEL);
}

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#endif


// begin_ntddk begin_nthal begin_ntifs begin_ntosp
//
// Queued spin lock functions for "in stack" lock handles.
//
// The following three functions RAISE and LOWER IRQL when a queued
// in stack spin lock is acquired or released using these routines.
//

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

// end_ntddk end_nthal end_ntifs end_ntosp

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

// begin_ntddk begin_nthal begin_ntifs begin_ntosp

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

//
// The following two functions do NOT raise or lower IRQL when a queued
// in stack spin lock is acquired or released using these functions.
//

NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

// end_ntddk end_nthal end_ntifs
//
// The following two functions conditionally raise or lower IRQL when a
// queued in-stack spin lock is acquired or released using these functions.
//

NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockForDpc (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

// end_ntosp

//
// Initialize kernel in phase 1.
//

BOOLEAN
KeInitSystem(
    VOID
    );

VOID
KeNumaInitialize(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Miscellaneous kernel functions
//

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef
VOID
(*PKBUGCHECK_CALLBACK_ROUTINE) (
    IN PVOID Buffer,
    IN ULONG Length
    );

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

#define KeInitializeCallbackRecord(CallbackRecord) \
    (CallbackRecord)->State = BufferEmpty

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    );

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PUCHAR Component
    );

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
} KBUGCHECK_CALLBACK_REASON;

typedef
VOID
(*PKBUGCHECK_REASON_CALLBACK_ROUTINE) (
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN struct _KBUGCHECK_REASON_CALLBACK_RECORD* Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    IN PVOID InBuffer;
    IN ULONG InBufferLength;
    IN ULONG MaximumAllowed;
    OUT GUID Guid;
    OUT PVOID OutBuffer;
    OUT ULONG OutBufferLength;
} KBUGCHECK_SECONDARY_DUMP_DATA, *PKBUGCHECK_SECONDARY_DUMP_DATA;

typedef enum _KBUGCHECK_DUMP_IO_TYPE
{
    KbDumpIoInvalid,
    KbDumpIoHeader,
    KbDumpIoBody,
    KbDumpIoSecondaryData,
    KbDumpIoComplete
} KBUGCHECK_DUMP_IO_TYPE;

typedef struct _KBUGCHECK_DUMP_IO {
    IN ULONG64 Offset;
    IN PVOID Buffer;
    IN ULONG BufferLength;
    IN KBUGCHECK_DUMP_IO_TYPE Type;
} KBUGCHECK_DUMP_IO, *PKBUGCHECK_DUMP_IO;

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    );

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PUCHAR Component
    );

typedef
BOOLEAN
(*PNMI_CALLBACK)(
    IN PVOID    Context,
    IN BOOLEAN  Handled
    );

NTKERNELAPI
PVOID
KeRegisterNmiCallback(
    PNMI_CALLBACK   CallbackRoutine,
    PVOID           Context
    );

NTSTATUS
KeDeregisterNmiCallback(
    PVOID Handle
    );

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

// end_ntddk end_nthal end_ntifs end_ntosp

VOID
KeBugCheck2(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN PVOID SaveDataPage
    );

BOOLEAN
KeGetBugMessageText(
    IN ULONG MessageId,
    IN PANSI_STRING ReturnedString OPTIONAL
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// end_ntddk end_wdm end_ntifs end_ntosp

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );

// end_nthal

typedef
PCHAR
(*PKE_BUGCHECK_UNICODE_TO_ANSI) (
    IN PUNICODE_STRING UnicodeString,
    OUT PCHAR AnsiBuffer,
    IN ULONG MaxAnsiLength
    );

VOID
KeDumpMachineState (
    IN PKPROCESSOR_STATE ProcessorState,
    IN PCHAR Buffer,
    IN PULONG_PTR BugCheckParameters,
    IN ULONG NumberOfParameters,
    IN PKE_BUGCHECK_UNICODE_TO_ANSI UnicodeToAnsiRoutine
    );

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PCONTEXT ContextFrame
    );

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    );

// begin_nthal

VOID
__cdecl
KeSaveStateForHibernate(
    IN PKPROCESSOR_STATE ProcessorState
    );

// end_nthal

VOID
KeCopyTrapDispatcher (
    VOID
    );

BOOLEAN
FASTCALL
KeInvalidAccessAllowed (
    IN PVOID TrapInformation OPTIONAL
    );

//
//  GDI TEB Batch Flush routine
//

typedef
VOID
(*PGDI_BATCHFLUSH_ROUTINE) (
    VOID
    );

//
// Find first set left in affinity mask.
//

#if defined(_WIN64)

#if defined(_AMD64_) && !defined(_X86AMD64_)

#define KeFindFirstSetLeftAffinity(Set, Member) BitScanReverse64(Member, Set)

#else

#define KeFindFirstSetLeftAffinity(Set, Member) {                      \
    ULONG _Mask_;                                                      \
    ULONG _Offset_ = 32;                                               \
    if ((_Mask_ = (ULONG)(Set >> 32)) == 0) {                          \
        _Offset_ = 0;                                                  \
        _Mask_ = (ULONG)Set;                                           \
    }                                                                  \
    KeFindFirstSetLeftMember(_Mask_, Member);                          \
    *(Member) += _Offset_;                                             \
}

#endif

#else

#define KeFindFirstSetLeftAffinity(Set, Member)                        \
    KeFindFirstSetLeftMember(Set, Member)

#endif // defined(_WIN64)

//
// Find first set left in 32-bit set.
//

#if defined(_WIN64)

#if defined(_AMD64_) && !defined(_X86AMD64_)

#define KeFindFirstSetLeftMember(Set, Member) BitScanReverse(Member, Set)

#else

extern const CCHAR KiFindFirstSetLeft[];

#define KeFindFirstSetLeftMember(Set, Member) {                        \
    ULONG _Mask;                                                       \
    ULONG _Offset = 16;                                                \
    if ((_Mask = Set >> 16) == 0) {                                    \
        _Offset = 0;                                                   \
        _Mask = Set;                                                   \
    }                                                                  \
    if (_Mask >> 8) {                                                  \
        _Offset += 8;                                                  \
    }                                                                  \
    *(Member) = KiFindFirstSetLeft[Set >> _Offset] + _Offset;          \
}

#endif

#else

FORCEINLINE
ULONG
KiFindFirstSetLeftMemberInt (
    ULONG Set
    )
{
    __asm {
        bsr eax, Set
    }
}

FORCEINLINE
void
KeFindFirstSetLeftMember (
    ULONG Set,
    PULONG Member
    )
{
    *Member = KiFindFirstSetLeftMemberInt (Set);
}

#endif

ULONG
KeFindNextRightSetAffinity (
    ULONG Number,
    KAFFINITY Set
    );

//
// Find first set right in 32-bit set.
//

extern const CCHAR KiFindFirstSetRight[];

#if defined(_X86_)

FORCEINLINE
ULONG
KeFindFirstSetRightMember (
    ULONG Set
    )
{
    __asm {
        bsf eax, Set
    }
}

#else

#define KeFindFirstSetRightMember(Set) \
    ((Set & 0xFF) ? KiFindFirstSetRight[Set & 0xFF] : \
    ((Set & 0xFF00) ? KiFindFirstSetRight[(Set >> 8) & 0xFF] + 8 : \
    ((Set & 0xFF0000) ? KiFindFirstSetRight[(Set >> 16) & 0xFF] + 16 : \
                           KiFindFirstSetRight[Set >> 24] + 24 )))
#endif

//
// TB Flush routines
//

extern volatile LONG KiTbFlushTimeStamp;

NTKERNELAPI
VOID
KeFlushEntireTb (
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors
    );

#if (defined(_M_IX86) || defined(_M_AMD64)) && defined(NT_UP) && \
    !defined(_NTDRIVER_) && !defined(_NTDDK_) && !defined(_NTIFS_) && !defined(_NTHAL_)

FORCEINLINE
VOID
KeFlushProcessTb (
    IN BOOLEAN AllProcessors
    )

{

    UNREFERENCED_PARAMETER(AllProcessors);

    KiFlushProcessTb();
    return;
}

FORCEINLINE
VOID
FASTCALL
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN AllProcesors
    )

{

    UNREFERENCED_PARAMETER (AllProcesors);

#if _MSC_FULL_VER >= 13008806

#if defined(_M_AMD64)

    InvalidatePage(Virtual);

#else

    __asm {
        mov eax, Virtual
        invlpg [eax]
    }

#endif

#else

    KiFlushSingleTb(Virtual);

#endif

    return;
}

#define KeFlushMultipleTb(Number, Virtual, AllProcessors)                    \
{                                                                            \
    ULONG _Index_;                                                           \
    PVOID _VA_;                                                              \
                                                                             \
    for (_Index_ = 0; _Index_ < (Number); _Index_ += 1) {                    \
        _VA_ = (Virtual)[_Index_];                                           \
        KiFlushSingleTb(_VA_);                                               \
    }                                                                        \
}

#else

#if defined(_AMD64_) || defined(_X86_)

VOID
KeFlushProcessTb (
    IN BOOLEAN AllProcessors
    );

#else

#define KeFlushProcessTb(all) KeFlushEntireTb(FALSE, (all))

#endif

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN AllProcesors
    );

VOID
FASTCALL
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN AllProcesors
    );

#endif

#if defined(_IA64_)

VOID
KeFlushMultipleTb64 (
    IN ULONG Number,
    IN PULONG_PTR Virtual,
    IN BOOLEAN AllProcesors
    );

HARDWARE_PTE
KeFlushSingleTb64 (
    IN ULONG_PTR Virtual,
    IN BOOLEAN AllProcesors
    );

#endif

// begin_nthal

BOOLEAN
KiIpiServiceRoutine (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame
    );

// end_nthal

BOOLEAN
KeFreezeExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

KCONTINUE_STATUS
KeSwitchFrozenProcessor (
    IN ULONG ProcessorNumber
    );

VOID
KeGetNonVolatileContextPointers (
    IN PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext
    );

// begin_ntddk

#if defined(_AMD64_) || defined(_X86_)

NTKERNELAPI
BOOLEAN
KeInvalidateAllCaches (
    VOID
    );

#endif

// end_ntddk

#define DMA_READ_DCACHE_INVALIDATE 0x1              // nthal
#define DMA_READ_ICACHE_INVALIDATE 0x2              // nthal
#define DMA_WRITE_DCACHE_SNOOP 0x4                  // nthal
                                                    // nthal
NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeSetDmaIoCoherency (                               // nthal
    IN ULONG Attributes                             // nthal
    );                                              // nthal
                                                    // nthal

#if defined(_AMD64_) || defined(_X86_)

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeSetProfileIrql (                                  // nthal
    IN KIRQL ProfileIrql                            // nthal
    );                                              // nthal
                                                    // nthal
#endif

#if defined(_IA64_)

ULONG
KeReadMbTimeStamp (
    VOID
    );

VOID
KeSynchronizeMemoryAccess (
    VOID
    );

#endif

//
// Interlocked read TB flush entire timestamp.
//

FORCEINLINE
ULONG
KeReadTbFlushTimeStamp (
    VOID
    )

{

#if defined(NT_UP)

    return KiTbFlushTimeStamp;

#else

    LONG Value;

    //
    // While the TB flush time stamp counter is being updated the high
    // order bit of the time stamp value is set. Otherwise, the bit is
    // clear.
    //

    KeMemoryBarrier();

    do {
    } while ((Value = KiTbFlushTimeStamp) < 0);

    return Value;

#endif

}

VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime,
    IN BOOLEAN AdjustInterruptTime,
    IN PLARGE_INTEGER HalTimeToSet OPTIONAL
    );

#define SYSTEM_SERVICE_INDEX 0

// begin_ntosp

#define WIN32K_SERVICE_INDEX 1
#define IIS_SERVICE_INDEX 2

// end_ntosp

// begin_ntosp

NTKERNELAPI
BOOLEAN
KeAddSystemServiceTable(
    IN PULONG_PTR Base,
    IN PULONG Count OPTIONAL,
    IN ULONG Limit,
    IN PUCHAR Number,
    IN ULONG Index
    );

NTKERNELAPI
BOOLEAN
KeRemoveSystemServiceTable(
    IN ULONG Index
    );

// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

#if !defined(_AMD64_)

NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

#endif

NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );

NTKERNELAPI
ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    );

// end_wdm

NTKERNELAPI
KAFFINITY
KeQueryActiveProcessors (
    VOID
    );

// end_ntddk end_nthal end_ntifs end_ntosp

NTSTATUS
KeQueryLogicalProcessorInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength
    );

PKPRCB
KeGetPrcb(
    IN ULONG ProcessorNumber
    );

BOOLEAN
KeAdjustInterruptTime (
    IN LONGLONG TimeDelta
    );

// begin_nthal

NTKERNELAPI
VOID
KeSetTimeIncrement (
    IN ULONG MaximumIncrement,
    IN ULONG MimimumIncrement
    );

// end_nthal

VOID
KeThawExecution (
    IN BOOLEAN Enable
    );

// begin_nthal begin_ntosp

//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalPowerDownRoutine,
    HalRestartRoutine,
    HalRebootRoutine,
    HalInteractiveModeRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

// end_nthal end_ntosp

VOID
KeStartAllProcessors (
    VOID
    );

//
// Balance set manager thread startup function.
//

VOID
KeBalanceSetManager (
    IN PVOID Context
    );

VOID
KeSwapProcessOrStack (
    IN PVOID Context
    );

//
// User mode callback.
//

// begin_ntosp

NTKERNELAPI
NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    );

// end_ntosp

#if defined(_IA64_)

PVOID
KeSwitchKernelStack (
    IN PVOID StackBase,
    IN PVOID StackLimit,
    IN PVOID BStoreLimit
    );

#else

PVOID
KeSwitchKernelStack (
    IN PVOID StackBase,
    IN PVOID StackLimit
    );

#endif // defined(_IA64_)

NTSTATUS
KeRaiseUserException(
    IN NTSTATUS ExceptionCode
    );

// begin_nthal
//
// Find ARC configuration information function.
//

NTKERNELAPI
PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL
    );

NTKERNELAPI
PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationNextEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL,
    IN PCONFIGURATION_COMPONENT_DATA *Resume
    );

// end_nthal

//
// External references to public kernel data structures
//

extern KAFFINITY KeActiveProcessors;
extern LARGE_INTEGER KeBootTime;
extern ULONGLONG KeBootTimeBias;
extern ULONG KeThreadDpcEnable;
extern ULONG KeErrorMask;
extern ULONGLONG KeInterruptTimeBias;
extern LIST_ENTRY KeBugCheckCallbackListHead;
extern LIST_ENTRY KeBugCheckReasonCallbackListHead;
extern KSPIN_LOCK KeBugCheckCallbackLock;
extern PGDI_BATCHFLUSH_ROUTINE KeGdiFlushUserBatch;
extern PLOADER_PARAMETER_BLOCK KeLoaderBlock;       // ntosp
extern ULONG KeMaximumIncrement;
extern ULONG KeMinimumIncrement;
extern NTSYSAPI CCHAR KeNumberProcessors;           // nthal ntosp
extern UCHAR KeNumberNodes;
extern USHORT KeProcessorArchitecture;
extern USHORT KeProcessorLevel;
extern USHORT KeProcessorRevision;
extern ULONG KeFeatureBits;
extern KSPIN_LOCK KiDispatcherLock;
extern ULONG KiDPCTimeout;
extern PKPRCB KiProcessorBlock[];
extern ULONG KiSpinlockTimeout;
extern ULONG KiStackProtectTime;
extern KTHREAD_SWITCH_COUNTERS KeThreadSwitchCounters;
extern ULONG KeLargestCacheLine;

#if defined(_IA64_)

VOID KiNormalSystemCall(VOID);

//
// IA64 CPL CATCHER
//

extern PVOID KeCplCatcher;

#endif

#if !defined(NT_UP)

extern ULONG KeRegisteredProcessors;
extern ULONG KeLicensedProcessors;
extern UCHAR KeProcessNodeSeed;

#endif

extern PULONG KeServiceCountTable;
extern KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES];
extern KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES];

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

#if defined(_IA64_)

extern volatile LARGE_INTEGER KeTickCount;

#elif defined(_X86_)

extern volatile KSYSTEM_TIME KeTickCount;

#endif

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

// begin_nthal

extern PVOID KeUserApcDispatcher;
extern PVOID KeUserCallbackDispatcher;
extern PVOID KeUserExceptionDispatcher;
extern PVOID KeRaiseUserExceptionDispatcher;
extern ULONG KeTimeAdjustment;
extern ULONG KeTimeIncrement;
extern BOOLEAN KeTimeSynchronization;

// end_nthal

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmNonCachedUnordered,       // IA64
    MmUSWCCached,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Routine for setting memory type for physical address ranges.
//

#if defined(_X86_)

NTSTATUS
KeSetPhysicalCacheTypeRange (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

#endif

//
// Routines for zeroing a physical page.
//
// These are defined as calls through a function pointer which is set to
// point at the optimal routine for this processor implementation.
//

#if defined(_X86_) || defined(_IA64_)

typedef
VOID
(FASTCALL *KE_ZERO_PAGE_ROUTINE)(
    IN PVOID PageBase,
    IN SIZE_T NumberOfBytes
    );

extern KE_ZERO_PAGE_ROUTINE KeZeroPages;
extern KE_ZERO_PAGE_ROUTINE KeZeroPagesFromIdleThread;

#else

#define KeZeroPagesFromIdleThread KeZeroPages

VOID
KeZeroPages (
    IN PVOID PageBase,
    IN SIZE_T NumberOfBytes
    );

#endif

#if defined(_IA64_)

VOID
KeEnableSessionSharing(
    PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    );

VOID
KeDetachSessionSpace(
    IN PREGION_MAP_INFO NullSessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    );

VOID
KeAddSessionSpace(
    IN PKPROCESS Process,
    IN PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    );

VOID
KeAttachSessionSpace(
    IN PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    );

VOID
KeDisableSessionSharing(
    IN PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    );

NTSTATUS
KeFlushUserRseState (
    IN PKTRAP_FRAME TrapFrame
    );
VOID
KeSetLowPsrBit (
    IN UCHAR BitPosition,
    IN BOOLEAN Value
    );

#endif

//
// Verifier functions
//

NTSTATUS
KevUtilAddressToFileHeader (
    IN  PVOID Address,
    OUT UINT_PTR *OffsetIntoImage,
    OUT PUNICODE_STRING *DriverName,
    OUT BOOLEAN *InVerifierList
    );

//
// Define guarded mutex structure.
//

typedef struct _KGUARDED_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    union {
        struct {
            SHORT KernelApcDisable;
            SHORT SpecialApcDisable;
        };

        ULONG CombinedApcDisable;
    };

} KGUARDED_MUTEX, *PKGUARDED_MUTEX;

#endif // _KE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\kx.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    kx.h

Abstract:

    This module contains the public (external) header file for the kernel
    that must be included after all other header files.

    WARNING: There is code in windows\core\ntgdi\gre\i386\locka.asm that
             mimics the functions to enter and leave critical regions.
             This is very unfortunate since any changes to the subject
             routines must be reflected in locka.asm also.

Author:

    David N. Cutler (davec) 9-Jul-2002

--*/

#ifndef _KX_
#define _KX_

VOID
KiCheckForKernelApcDelivery (
    VOID
    );

VOID
FASTCALL
KiWaitForGuardedMutexEvent (
    IN PKGUARDED_MUTEX Mutex
    );

FORCEINLINE
VOID
KeEnterGuardedRegionThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function disables special kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    Thread - Supplies a pointer to the current thread.

    N.B. This must be a pointer to the current thread.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    ASSERT(Thread == KeGetCurrentThread());

    ASSERT((Thread->SpecialApcDisable <= 0) && (Thread->SpecialApcDisable != -32768));

    Thread->SpecialApcDisable -= 1;
    KeMemoryBarrierWithoutFence();
    return;
}

FORCEINLINE
VOID
KeEnterGuardedRegion (
    VOID
    )

/*++

Routine Description:

    This function disables special kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KeEnterGuardedRegionThread(KeGetCurrentThread());
    return;
}

FORCEINLINE
VOID
KeLeaveGuardedRegionThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function enables special kernel APC's.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    Thread - Supplies a pointer to the current thread.

    N.B. This must be a pointer to the current thread.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    ASSERT(Thread == KeGetCurrentThread());

    ASSERT(Thread->SpecialApcDisable < 0);

    KeMemoryBarrierWithoutFence();
    if ((Thread->SpecialApcDisable = Thread->SpecialApcDisable + 1) == 0) { 
        KeMemoryBarrier();
        if (Thread->ApcState.ApcListHead[KernelMode].Flink !=       
                                &Thread->ApcState.ApcListHead[KernelMode]) {

            KiCheckForKernelApcDelivery();
        }                                                             
    }                                                                 

    return;
}

FORCEINLINE
VOID
KeLeaveGuardedRegion (
    VOID
    )

/*++

Routine Description:

    This function enables special kernel APC's.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KeLeaveGuardedRegionThread(KeGetCurrentThread());
    return;
}

FORCEINLINE
VOID
KeEnterCriticalRegionThread (
    PKTHREAD Thread
    )

/*++

Routine Description:

    This function disables kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    Thread - Supplies a pointer to the current thread.

    N.B. This must be a pointer to the current thread.

Return Value:

    None.

--*/

{

    ASSERT(Thread == KeGetCurrentThread());

    ASSERT((Thread->KernelApcDisable <= 0) && (Thread->KernelApcDisable != -32768));

    Thread->KernelApcDisable -= 1;
    KeMemoryBarrierWithoutFence();
    return;
}

FORCEINLINE
VOID
KeEnterCriticalRegion (
    VOID
    )

/*++

Routine Description:

    This function disables kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KeEnterCriticalRegionThread(KeGetCurrentThread());
    return;
}

FORCEINLINE
VOID
KeLeaveCriticalRegionThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function enables normal kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    Thread - Supplies a pointer to the current thread.

    N.B. This must be a pointer to the current thread.

Return Value:

    None.

--*/

{

    ASSERT(Thread == KeGetCurrentThread());

    ASSERT(Thread->KernelApcDisable < 0);

    KeMemoryBarrierWithoutFence();
    if ((Thread->KernelApcDisable = Thread->KernelApcDisable + 1) == 0) {
        KeMemoryBarrier();
        if (Thread->ApcState.ApcListHead[KernelMode].Flink !=         
                                &Thread->ApcState.ApcListHead[KernelMode]) {

            if (Thread->SpecialApcDisable == 0) {
                KiCheckForKernelApcDelivery();
            }
        }                                                               
    }

    return;
}

FORCEINLINE
VOID
KeLeaveCriticalRegion (
    VOID
    )

/*++

Routine Description:

    This function enables normal kernel APC's for the current thread.

    N.B. The following code does not require any interlocks. There are
         two cases of interest: 1) On an MP system, the thread cannot
         be running on two processors as once, and 2) if the thread is
         is interrupted to deliver a kernel mode APC which also calls
         this routine, the values read and stored will stack and unstack
         properly.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KeLeaveCriticalRegionThread(KeGetCurrentThread());
    return;
}

FORCEINLINE
BOOLEAN
KeAreApcsDisabled (
    VOID
    )

/*++

Routine description:

    This function returns whether kernel are disabled for the current thread.

Arguments:

    None.

Return Value:

    If either the kernel or special APC disable count is nonzero, then a value
    of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    return (BOOLEAN)(KeGetCurrentThread()->CombinedApcDisable != 0);
}

FORCEINLINE
BOOLEAN
KeAreAllApcsDisabled (
    VOID
    )

/*++

Routine description:

    This function returns whether all APCs are disabled for the current thread.

Arguments:

    None.

Return Value:

    If either the special APC disable count is nonzero or the IRQL is greater
    than or equal to APC_LEVEL, then a value of TRUE is returned. Otherwise,
    a value of FALSE is returned.

--*/

{

    return (BOOLEAN)((KeGetCurrentThread()->SpecialApcDisable != 0) ||
                     (KeGetCurrentIrql() >= APC_LEVEL));
}

FORCEINLINE
VOID
KeInitializeGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function initializes a guarded mutex.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    Mutex->Owner = NULL;
    Mutex->Count = 1;
    Mutex->Contention = 0;
    KeInitializeEvent(&Mutex->Event, SynchronizationEvent, FALSE);
    return;
}

FORCEINLINE
VOID
KeAcquireGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function enters a guarded region and acquires ownership of a guarded
    mutex.

Arguments:

    Mutex  - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Enter a guarded region and decrement the ownership count to determine
    // if the guarded mutex is owned.
    //

    Thread = KeGetCurrentThread();

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    ASSERT(Mutex->Owner != Thread);

    KeEnterGuardedRegionThread(Thread);
    if (InterlockedDecrementAcquire(&Mutex->Count) != 0) {

        //
        // The guarded mutex is owned.
        //
        // Increment contention count and wait for ownership to be granted.
        //

        KiWaitForGuardedMutexEvent(Mutex);
    }

    //
    // Grant ownership of the guarded mutext to the current thread.
    //

    Mutex->Owner = Thread;

#if DBG

    Mutex->SpecialApcDisable = Thread->SpecialApcDisable;

#endif

    return;
}

FORCEINLINE
VOID
KeReleaseGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function releases ownership of a guarded mutex and leaves a guarded
    region.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Clear the owner thread and increment the guarded mutex count to
    // detemine if there are any threads waiting for ownership to be
    // granted.
    //

    Thread = KeGetCurrentThread();

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    ASSERT(Mutex->Owner == Thread);

    ASSERT(Thread->SpecialApcDisable == Mutex->SpecialApcDisable);

    Mutex->Owner = NULL;
    if (InterlockedIncrementRelease(&Mutex->Count) <= 0) {

        //
        // There are one or more threads waiting for ownership of the guarded
        // mutex.
        //

        KeSetEventBoostPriority(&Mutex->Event, NULL);
    }

    //
    // Leave guarded region.
    //

    KeLeaveGuardedRegionThread(Thread);
    return;
}

FORCEINLINE
BOOLEAN
KeTryToAcquireGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function attempts to acquire ownership of a guarded mutex, and if
    successful, enters a guarded region.

Arguments:

    Mutex  - Supplies a pointer to a guarded mutex.

Return Value:

    If the guarded mutex was successfully acquired, then a value of TRUE
    is returned as the function value. Otherwise, a value of FALSE is
    returned.

--*/

{

    PKTHREAD Thread;

    //
    // Enater a guarded region and attempt to acquire ownership of the guarded
    // mutex.
    //

    Thread = KeGetCurrentThread();

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    KeEnterGuardedRegionThread(Thread);
    if (InterlockedCompareExchange(&Mutex->Count, 0, 1) != 1) {

        //
        // The guarded mutex is owned.
        //
        // Leave guarded region and return FALSE.
        //

        KeLeaveGuardedRegionThread(Thread);
        return FALSE;

    } else {

        //
        // Grant ownership of the guarded mutex to the current thread and
        // return TRUE.
        //

        Mutex->Owner = Thread;

#if DBG

        Mutex->SpecialApcDisable = Thread->SpecialApcDisable;

#endif

        return TRUE;
    }
}

FORCEINLINE
VOID
KeAcquireGuardedMutexUnsafe (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function acquires ownership of a guarded mutex, but does enter a
    guarded region.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Decrement the ownership count to determine if the guarded mutex is
    // owned.
    //

    Thread = KeGetCurrentThread();

    ASSERT((KeGetCurrentIrql() == APC_LEVEL) ||
           (Thread->SpecialApcDisable < 0) ||
           (Thread->Teb == NULL) ||
           (Thread->Teb >= MM_SYSTEM_RANGE_START));

    ASSERT(Mutex->Owner != Thread);

    if (InterlockedDecrement(&Mutex->Count) != 0) {

        //
        // The guarded mutex is owned.
        //
        // Increment contention count and wait for ownership to be granted.
        //

        KiWaitForGuardedMutexEvent(Mutex);
    }

    //
    // Grant ownership of the guarded mutex to the current thread.
    //

    Mutex->Owner = Thread;
    return;
}

FORCEINLINE
VOID
KeReleaseGuardedMutexUnsafe (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function releases ownership of a guarded mutex, and does not leave
    a guarded region.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Clear the owner thread and increment the guarded mutex count to
    // determine if there are any threads waiting for ownership to be
    // granted.
    //

    Thread = KeGetCurrentThread();

    ASSERT((KeGetCurrentIrql() == APC_LEVEL) ||
           (Thread->SpecialApcDisable < 0) ||
           (Thread->Teb == NULL) ||
           (Thread->Teb >= MM_SYSTEM_RANGE_START));

    ASSERT(Mutex->Owner == Thread);

    Mutex->Owner = NULL;
    if (InterlockedIncrement(&Mutex->Count) <= 0) {

        //
        // There are one or more threads waiting for ownership of the guarded
        // mutex.
        //

        KeSetEventBoostPriority(&Mutex->Event, NULL);
    }

    return;
}

FORCEINLINE
PKTHREAD
KeGetOwnerGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function returns the owner of the specified guarded mutex.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    If the guarded mutex is owned, then a pointer to the owner thread is
    returned. Otherwise, NULL is returned.

--*/

{
    return Mutex->Owner;
}

FORCEINLINE
BOOLEAN
KeIsGuardedMutexOwned (
    IN PKGUARDED_MUTEX Mutex
    )

/*++

Routine Description:

    This function tests whether the specified guarded mutext is owned.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    A value of TRUE is returned if the guarded mutex is owned. Otherwise,
    a value of FALSE is returned.

--*/

{
    return (BOOLEAN)(Mutex->Count != 1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\lfs.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Lfs.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Log File Service.

Author:
    Brian Andrew    [BrianAn]   20-June-1991


Revision History:

--*/

#ifndef _LFS_
#define _LFS_

//
// The Multi-Sector Header and Update Sequence Array provide detection of
// incomplete multi-sector transfers for devices which either have a
// physical sector size equal to the Sequence Number Stride or greater, or
// which do not transfer sectors out of order.  If a device exists which has
// a sector size smaller than the Sequence Number Stride *and* it sometimes
// transfers sectors out of order, then the Update Sequence Array will not
// provide absolute detection of incomplete transfers.  The Sequence Number
// Stride is set to a small enough number to provide absolute protection for
// all known hard disks.  It is not set any smaller, in order to avoid
// excessive run time and space overhead.
//
// The Multi-Sector Header contains space for a four-byte signature for the
// convenience of its user.  It then provides the offset to and length of the
// the Update Sequence Array.  The Update Sequence Array consists of an array
// of n saved USHORTs, where n is the size of the structure being protected
// divided by the sequence number stride.  (The size of structure being
// protected must be a nonzero power of 2 times the Sequence Number Stride,
// and less than or equal to the physical page size of the machine.)  The
// first word of the Update Sequence Array contains the Update Sequence Number,
// which is a cyclical counter (however 0 is not used) of the number of times
// the containing structure has been written to disk.  Following the Update
// Sequence Number are the n saved USHORTs which were overwritten by the
// Update Sequence Number the last time the containing structure was
// written to disk.
//
// In detail, just prior to each time the protected structure is written to
// disk, the last word in each Sequence Number Stride is saved to its
// respective position in the Sequence Number Array, and then it is overwritten
// with the next Update Sequence Number.  Just after this write, or whenever
// reading the structure, the saved word from the Sequence Number Array is
// restored to its actual position in the structure.  Before restoring the
// saved words on reads, all of the sequence numbers at the end of each
// stride are compared with the actual sequence number at the start of the
// array.  If any of these compares come up not equal, then a failed
// multi-sector transfer has been detected.
//
// The size of the array is determined by the size of the containing structure.
// As a C detail, the array is declared here with a size of 1, since its
// actual size can only be determined at runtime.
//
// The Update Sequence Array should be included at the end of the header of
// the structure it is protecting, since it is variable size.  Its user must
// insure that the correct size is reserved for it, namely:
//
//      (sizeof-structure / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)
//

#define SEQUENCE_NUMBER_STRIDE           (512)

typedef USHORT UPDATE_SEQUENCE_NUMBER, *PUPDATE_SEQUENCE_NUMBER;

//
// This structure must be allocated at the start of the structure being
// protected.
//

#if !defined( _AUTOCHECK_ )

typedef struct _MULTI_SECTOR_HEADER {

    //
    // Space for a four-character signature
    //

    UCHAR Signature[4];

    //
    // Offset to Update Sequence Array, from start of structure.  The Update
    // Sequence Array must end before the last USHORT in the first "sector"
    // of size SEQUENCE_NUMBER_STRIDE.  (I.e., with the current constants,
    // the sum of the next two fields must be <= 510.)
    //

    USHORT UpdateSequenceArrayOffset;

    //
    // Size of Update Sequence Array (from above formula)
    //

    USHORT UpdateSequenceArraySize;

} MULTI_SECTOR_HEADER, *PMULTI_SECTOR_HEADER;

#endif

//
// This array must be present at the offset described above.
//

typedef UPDATE_SEQUENCE_NUMBER UPDATE_SEQUENCE_ARRAY[1];

typedef UPDATE_SEQUENCE_ARRAY *PUPDATE_SEQUENCE_ARRAY;

//
//  The following structure is allocated in the file system's Vcb and
//  its address is passed to Lfs during log file initialization.  It
//  contains the offset of the current write as well as the system
//  page size being used by Lfs.
//

typedef struct _LFS_WRITE_DATA {

    LONGLONG FileOffset;
    ULONG Length;
    ULONG LfsStructureSize;
    PVOID Lfcb;

} LFS_WRITE_DATA, *PLFS_WRITE_DATA;

//
//  The following structure is used to identify a log record by a log
//  sequence number.
//

typedef LARGE_INTEGER LSN, *PLSN;

//
//  The following Lsn will never occur in a file, it is used to indicate
//  a non-lsn.
//

extern LSN LfsZeroLsn;

//
//  We set the default page size to 4K
//

#define LFS_DEFAULT_LOG_PAGE_SIZE           (0x1000)

//
//  The following type defines the different log record types.
//

typedef enum _LFS_RECORD_TYPE {

    LfsClientRecord = 1,
    LfsClientRestart

} LFS_RECORD_TYPE, *PLFS_RECORD_TYPE;

//
//  The following search modes are supported.
//

typedef enum _LFS_CONTEXT_MODE {

    LfsContextUndoNext = 1,
    LfsContextPrevious,
    LfsContextForward

} LFS_CONTEXT_MODE, *PLFS_CONTEXT_MODE;

typedef ULONG TRANSACTION_ID, *PTRANSACTION_ID;

typedef enum _TRANSACTION_STATE {

    TransactionUninitialized = 0,
    TransactionActive,
    TransactionPrepared,
    TransactionCommitted

} TRANSACTION_STATE, *PTRANSACTION_STATE;

//
//  Information conduit back and forth between
//  LFS and its client.
//

typedef enum _LFS_CLIENT_INFO {

    LfsUseUsa = 1,
    LfsPackLog,
    LfsFixedPageSize

} LFS_CLIENT_INFO;

typedef struct _LFS_INFO {

    LOGICAL ReadOnly;
    LOGICAL InRestart;
    LOGICAL BadRestart;
    LFS_CLIENT_INFO LfsClientInfo;

} LFS_INFO, *PLFS_INFO;

typedef PVOID LFS_LOG_HANDLE, *PLFS_LOG_HANDLE;

typedef PVOID LFS_LOG_CONTEXT, *PLFS_LOG_CONTEXT;

//
//  Write Entry for LfsWrite and LfsForceWrite.  The interface to these
//  routines takes a pointer to a Write Entry along with a count of how
//  many Write Entries to expect to describe pieces of the caller's buffer
//  which are supposed to be copied in sequence to the log file.
//

typedef struct _LFS_WRITE_ENTRY {

    PVOID Buffer;
    ULONG ByteLength;

} LFS_WRITE_ENTRY, *PLFS_WRITE_ENTRY;


//
// Global Maintenance routines
//

BOOLEAN
LfsInitializeLogFileService (
    VOID
    );

//
//  Log File Registration routines
//

typedef struct _LOG_FILE_INFORMATION {

    //
    //  This is the total useable space in the log file after space for
    //  headers and Lfs Restart Areas.
    //

    LONGLONG TotalAvailable;

    //
    //  This is the useable space in the log file from the current position
    //  in the log file to the lowest BaseLsn.  This total as returned is not
    //  yet reduced for undo commitments, returned separately below.
    //

    LONGLONG CurrentAvailable;

    //
    //  This is the total undo commitment for all clients of the log file.
    //  LfsWrite requests are refused when the sum of the write size of the
    //  request plus the UndoRequirement for the request plus the TotalUndoCommitment
    //  are greater than the CurrentAvailable.
    //

    LONGLONG TotalUndoCommitment;

    //
    //  This is the total undo commitment for this client.
    //

    LONGLONG ClientUndoCommitment;

    //
    //  Current system Lsn's.  Includes the Oldest, LastFlushed and current
    //  Lsn.
    //

    LSN OldestLsn;
    LSN LastFlushedLsn;
    LSN LastLsn;

} LOG_FILE_INFORMATION, *PLOG_FILE_INFORMATION;

VOID
LfsInitializeLogFile (
    IN PFILE_OBJECT LogFile,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    OUT PLFS_WRITE_DATA WriteData
    );

ULONG
LfsOpenLogFile (
    IN PFILE_OBJECT LogFile,
    IN UNICODE_STRING ClientName,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_LOG_HANDLE LogHandle,
    OUT PLFS_WRITE_DATA WriteData
    );

VOID
LfsCloseLogFile (
    IN LFS_LOG_HANDLE LogHandle
    );

VOID
LfsDeleteLogHandle (
    IN LFS_LOG_HANDLE LogHandle
    );

VOID
LfsReadLogFileInformation (
    IN LFS_LOG_HANDLE LogHandle,
    IN PLOG_FILE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

BOOLEAN
LfsVerifyLogFile (
    IN LFS_LOG_HANDLE LogHandle,
    IN PVOID LogFileHeader,
    IN ULONG Length
    );

//
//  Log File Client Restart routines
//

NTSTATUS
LfsReadRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT PULONG BufferLength,
    IN PVOID Buffer,
    OUT PLSN Lsn
    );

VOID
LfsWriteRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG BufferLength,
    IN PVOID Buffer,
    IN LOGICAL CleanShutdown,
    OUT PLSN Lsn
    );

VOID
LfsSetBaseLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN BaseLsn
    );

//
//  If ResetTotal is positive, then NumberRecords and ResetTotal set the absolute
//  values for the client.  If ResetTotal is negative, then they are adjustments
//  to the totals for this client.
//

VOID
LfsResetUndoTotal (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberRecords,
    IN LONG ResetTotal
    );

//
//  Log File Write routines
//

VOID
LfsGetActiveLsnRange (
    IN LFS_LOG_HANDLE LogHandle,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    );

BOOLEAN
LfsWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    IN ULONG Flags,
    OUT PLSN Lsn
    );

#define LFS_WRITE_FLAG_WRITE_AT_FRONT 1

BOOLEAN
LfsForceWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    OUT PLSN Lsn
    );

VOID
LfsFlushToLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN Lsn
    );

VOID
LfsCheckWriteRange (
    IN PLFS_WRITE_DATA WriteData,
    IN OUT PLONGLONG FlushOffset,
    IN OUT PULONG FlushLength
    );

//
//  Log File Query Record routines
//

VOID
LfsReadLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN FirstLsn,
    IN LFS_CONTEXT_MODE ContextMode,
    OUT PLFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    );

BOOLEAN
LfsReadNextLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT LFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PLSN Lsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    );

VOID
LfsTerminateLogQuery (
    IN LFS_LOG_HANDLE LogHandle,
    IN LFS_LOG_CONTEXT Context
    );

LSN
LfsQueryLastLsn (
    IN LFS_LOG_HANDLE LogHandle
    );

#endif  // LFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\mca.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1991  NCR Corporation

Module Name:

    mca.h

Abstract:

    This module contains the defines and structure definitions for
    Micro Channel machines.

Author:

    David Risner  (o-ncrdr) 21-Jul-1991

Revision History:


--*/

#ifndef _MCA_
#define _MCA_





//
// Define the DMA page register structure (for 8237 compatibility)
//

typedef struct _DMA_PAGE{
    UCHAR Reserved1;
    UCHAR Channel2;
    UCHAR Channel3;
    UCHAR Channel1;
    UCHAR Reserved2[3];
    UCHAR Channel0;
    UCHAR Reserved3;
    UCHAR Channel6;
    UCHAR Channel7;
    UCHAR Channel5;
    UCHAR Reserved4[3];
    UCHAR RefreshPage;
} DMA_PAGE, *PDMA_PAGE;

//
// Define DMA 1 address and count structure (for 8237 compatibility)
//

typedef struct _DMA1_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR DmaBaseCount;
} DMA1_ADDRESS_COUNT, *PDMA1_ADDRESS_COUNT;

//
// Define DMA 2 address and count structure (for 8237 compatibility)
//

typedef struct _DMA2_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR Reserved1;
    UCHAR DmaBaseCount;
    UCHAR Reserved2;
} DMA2_ADDRESS_COUNT, *PDMA2_ADDRESS_COUNT;

//
// Define DMA 1 control register structure (for 8237 compatibility)
//

typedef struct _DMA1_CONTROL {
    DMA1_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR DmaRequest;
    UCHAR SingleMask;
    UCHAR Mode;
    UCHAR ClearBytePointer;
    UCHAR MasterClear;
    UCHAR ClearMask;
    UCHAR AllMask;
} DMA1_CONTROL, *PDMA1_CONTROL;

//
// Define DMA 2 control register structure (for 8237 compatibility)
//

typedef struct _DMA2_CONTROL {
    DMA2_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR Reserved1;
    UCHAR DmaRequest;
    UCHAR Reserved2;    
    UCHAR SingleMask;
    UCHAR Reserved3;    
    UCHAR Mode;
    UCHAR Reserved4;    
    UCHAR ClearBytePointer;
    UCHAR Reserved5;    
    UCHAR MasterClear;
    UCHAR Reserved6;    
    UCHAR ClearMask;
    UCHAR Reserved7;    
    UCHAR AllMask;
    UCHAR Reserved8;    
} DMA2_CONTROL, *PDMA2_CONTROL;

typedef struct _MCA_DMA_CONTROLLER {
    UCHAR DmaFunctionLsb;               // Offset 0x018
    UCHAR DmaFunctionMsb;               // Offset 0x019
    UCHAR DmaFunctionData;              // Offset 0x01a
    UCHAR Reserved01;
    UCHAR ScbAttentionPort;             // Offset 0x01c
    UCHAR ScbCommandPort;               // Offset 0x01d
    UCHAR Reserved02;
    UCHAR ScbStatusPort;                // Offset 0x01f
} MCA_DMA_CONTROLLER, *PMCA_DMA_CONTROLLER;

//
// Define Programmable Option Select register set
//

typedef struct _PROGRAMMABLE_OPTION_SELECT {
    UCHAR AdapterIdLsb;
    UCHAR AdapterIdMsb;
    UCHAR OptionSelectData1;
    UCHAR OptionSelectData2;
    UCHAR OptionSelectData3;
    UCHAR OptionSelectData4;
    UCHAR SubaddressExtensionLsb;
    UCHAR SubaddressExtensionMsb;
} PROGRAMMABLE_OPTION_SELECT, *PPROGRAMMABLE_OPTION_SELECT;

//
// Define Micro Channel i/o address map
//

typedef struct _MCA_CONTROL {
    DMA1_CONTROL Dma1BasePort;          // Offset 0x000
    UCHAR Reserved0[8];
    UCHAR ExtendedDmaBasePort[8];       // Offset 0x018 
    UCHAR Interrupt1ControlPort0;       // Offset 0x020
    UCHAR Interrupt1ControlPort1;       // Offset 0x021
    UCHAR Reserved1[64 - 1];
    UCHAR SystemControlPortB;           // Offset 0x061
    UCHAR Reserved2[32 - 2];
    DMA_PAGE DmaPageLowPort;            // Offset 0x080
    UCHAR Reserved3;
    UCHAR CardSelectedFeedback;         // Offset 0x091
    UCHAR SystemControlPortA;           // Offset 0x092
    UCHAR Reserved4;
    UCHAR SystemBoardSetup;             // Offset 0x094
    UCHAR Reserved5;
    UCHAR AdapterSetup;                 // Offset 0x096
    UCHAR AdapterSetup2;                // Offset 0x097
    UCHAR Reserved7[8];
    UCHAR Interrupt2ControlPort0;       // Offset 0x0a0
    UCHAR Interrupt2ControlPort1;       // Offset 0x0a1
    UCHAR Reserved8[32-2];
    DMA2_CONTROL Dma2BasePort;          // Offset 0x0c0
    UCHAR Reserved9[32];
    PROGRAMMABLE_OPTION_SELECT Pos;     // Offset 0x100
} MCA_CONTROL, *PMCA_CONTROL;

//
// Define POS adapter setup equates for use with AdapterSetup field above
//

#define MCA_ADAPTER_SETUP_ON  0x008
#define MCA_ADAPTER_SETUP_OFF 0x000

//
// Define DMA Extended Function register
//

typedef struct _DMA_EXTENDED_FUNCTION {
    UCHAR ChannelNumber : 3;
    UCHAR Reserved      : 1;
    UCHAR Command       : 4;
} DMA_EXTENDED_FUNCTION, *PDMA_EXTENDED_FUNCTION;

//
// Define Command values
//

#define WRITE_IO_ADDRESS         0x00   // write I/O address reg
#define WRITE_MEMORY_ADDRESS     0x20   // write memory address reg
#define READ_MEMORY_ADDRESS      0x30   // read memory address reg
#define WRITE_TRANSFER_COUNT     0x40   // write transfer count reg
#define READ_TRANSFER_COUNT      0x50   // read transfer count reg
#define READ_STATUS              0x60   // read status register
#define WRITE_MODE               0x70   // write mode register
#define WRITE_ARBUS              0x80   // write arbus register
#define SET_MASK_BIT             0x90   // set bit in mask reg
#define CLEAR_MASK_BIT           0xa0   // clear bit in mask reg
#define MASTER_CLEAR             0xd0   // master clear

//
// Define DMA Extended Mode register
//

typedef struct _DMA_EXTENDED_MODE {
    UCHAR ProgrammedIo      : 1;     // 0 = do not use programmed i/o address
    UCHAR AutoInitialize    : 1;
    UCHAR DmaOpcode         : 1;     // 0 = verify memory, 1 = data transfer
    UCHAR TransferDirection : 1;     // 0 = read memory, 1 = write memory
    UCHAR Reserved1         : 2;
    UCHAR DmaWidth          : 1;     // 0 = 8bit, 1 = 16bit
    UCHAR Reserved2         : 1;
} DMA_EXTENDED_MODE, *PDMA_EXTENDED_MODE;

//
// DMA Extended Mode equates for use with the _DMA_EXTENDED_MODE structure.
//

#define DMA_EXT_USE_PIO       0x01
#define DMA_EXT_NO_PIO        0x00
#define DMA_EXT_VERIFY        0x00
#define DMA_EXT_DATA_XFER     0x01
#define DMA_EXT_WIDTH_8_BIT   0x00
#define DMA_EXT_WIDTH_16_BIT  0x01

//
// DMA mode option definitions
//

#define DMA_MODE_READ          0x00   // read data into memory
#define DMA_MODE_WRITE         0x08   // write data from memory
#define DMA_MODE_VERIFY        0x00   // verify data
#define DMA_MODE_TRANSFER      0x04   // transfer data

// 
// DMA extended mode constants
//

#define MAX_MCA_DMA_CHANNEL_NUMBER  0x07 // maximum MCA DMA channel number
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\lpc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpc.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Local Inter-Process Communication (LPC)
    sub-component of NTOS.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#ifndef _LPC_
#define _LPC_

//
// System Initialization procedure for Lpc subcomponent of NTOS
//

BOOLEAN
LpcInitSystem( VOID );

VOID
LpcExitThread(
    PETHREAD Thread
    );

VOID
LpcDumpThread(
    PETHREAD Thread,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
LpcRequestPort(
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage
    );

NTSTATUS
LpcRequestWaitReplyPort(
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );

NTSTATUS
LpcRequestWaitReplyPortEx (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );

NTSTATUS
LpcDisconnectPort (
    IN PVOID Port
    );

// end_ntosp
//
// The following are global counters used by the LPC component to indicate
// the amount of LPC calls being performed in the system.
//

extern ULONG LpcCallOperationCount;
extern ULONG LpcCallBackOperationCount;
extern ULONG LpcDatagramOperationCount;

//
// Nonpagable portion of a port queue
//
typedef struct _LPCP_NONPAGED_PORT_QUEUE {
    KSEMAPHORE Semaphore;       // Counting semaphore that is incremented
                                // whenever a message is put in receive queue
    struct _LPCP_PORT_OBJECT *BackPointer;
} LPCP_NONPAGED_PORT_QUEUE, *PLPCP_NONPAGED_PORT_QUEUE;

typedef struct _LPCP_PORT_QUEUE {
    PLPCP_NONPAGED_PORT_QUEUE NonPagedPortQueue;
    PKSEMAPHORE Semaphore;      // Counting semaphore that is incremented
                                // whenever a message is put in receive queue
    LIST_ENTRY ReceiveHead;     // list of messages to receive
} LPCP_PORT_QUEUE, *PLPCP_PORT_QUEUE;

#define LPCP_ZONE_ALIGNMENT 16
#define LPCP_ZONE_ALIGNMENT_MASK ~(LPCP_ZONE_ALIGNMENT-1)

//
// This allows ~96 outstanding messages
//

#define LPCP_ZONE_MAX_POOL_USAGE (8*PAGE_SIZE)
typedef struct _LPCP_PORT_ZONE {
    KEVENT FreeEvent;           // Autoclearing event that is whenever the
                                // zone free list goes from empty to non-empty
    ULONG MaxPoolUsage;
    ULONG GrowSize;
    ZONE_HEADER Zone;
} LPCP_PORT_ZONE, *PLPCP_PORT_ZONE;

//
// Data Types and Constants
//

typedef struct _LPCP_PORT_OBJECT {
    struct _LPCP_PORT_OBJECT *ConnectionPort;
    struct _LPCP_PORT_OBJECT *ConnectedPort;
    LPCP_PORT_QUEUE MsgQueue;
    CLIENT_ID Creator;
    PVOID ClientSectionBase;
    PVOID ServerSectionBase;
    PVOID PortContext;
    PETHREAD ClientThread;                  // only SERVER_COMMUNICATION_PORT
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_CLIENT_CONTEXT StaticSecurity;
    LIST_ENTRY LpcReplyChainHead;           // Only in _COMMUNICATION ports
    LIST_ENTRY LpcDataInfoChainHead;        // Only in _COMMUNICATION ports
    union {
        PEPROCESS ServerProcess;                // Only in SERVER_CONNECTION ports
        PEPROCESS MappingProcess;               // Only in _COMMUNICATION    ports
    };
    USHORT MaxMessageLength;
    USHORT MaxConnectionInfoLength;
    ULONG Flags;
    KEVENT WaitEvent;                          // Object is truncated for non-waitable ports
} LPCP_PORT_OBJECT, *PLPCP_PORT_OBJECT;

//
// Valid values for Flags field
//

#define PORT_TYPE                           0x0000000F
#define SERVER_CONNECTION_PORT              0x00000001
#define UNCONNECTED_COMMUNICATION_PORT      0x00000002
#define SERVER_COMMUNICATION_PORT           0x00000003
#define CLIENT_COMMUNICATION_PORT           0x00000004
#define PORT_WAITABLE                       0x20000000
#define PORT_NAME_DELETED                   0x40000000
#define PORT_DYNAMIC_SECURITY               0x80000000

typedef struct _LPCP_MESSAGE {
    union {
        LIST_ENTRY Entry;
        struct {
            SINGLE_LIST_ENTRY FreeEntry;
            ULONG Reserved0;
        };
    };

    PVOID SenderPort;
    PETHREAD RepliedToThread;               // Filled in when reply is sent so recipient
                                            // of reply can dereference it.
    PVOID PortContext;                      // Captured from senders communication port.
    PORT_MESSAGE Request;
} LPCP_MESSAGE, *PLPCP_MESSAGE;

#if DEVL
//
// This bit set in the ZoneIndex field to mark allocated messages.
//

#define LPCP_ZONE_MESSAGE_ALLOCATED (USHORT)0x8000
#endif

//
// This data is placed at the beginning of the Request data for an
// LPC_CONNECTION_REQUEST message.
//

typedef struct _LPCP_CONNECTION_MESSAGE {
    PORT_VIEW ClientView;
    PLPCP_PORT_OBJECT ClientPort;
    PVOID SectionToMap;
    REMOTE_PORT_VIEW ServerView;
} LPCP_CONNECTION_MESSAGE, *PLPCP_CONNECTION_MESSAGE;


#endif  // _LPC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\mi386.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;       MI.INC
;
;   Abstract:
;
;       This module contains equates for x86 machine instructions
;
;   Author:
;
;       Dave Hastings 2 May 1991
;
;   Notes:
;
;       This information used to reside in Trap.asm, but is now needed in
;       multiple source files.
;
;   Revision History:
;--


MAX_INSTRUCTION_LENGTH		EQU	15
MAX_INSTRUCTION_PREFIX_LENGTH	EQU	4
MI_LOCK_PREFIX			EQU	0F0H
MI_ADDR_PREFIX			EQU	067H
MI_TWO_BYTE			EQU	0FH
MI_HLT				EQU	0F4H
MI_LTR_LLDT			EQU	0
MI_LGDT_LIDT_LMSW		EQU	01H
MI_MODRM_MASK			EQU	38H
MI_LLDT_MASK			EQU	10h
MI_LTR_MASK			EQU	18H
MI_LGDT_MASK			EQU	10H
MI_LIDT_MASK			EQU	18H
MI_LMSW_MASK			EQU	30H
MI_SPECIAL_MOV_MASK		EQU	20H
MI_REP_INS_OUTS 		EQU	0F3H
MI_MIN_INS_OUTS 		EQU	06CH
MI_MAX_INS_OUTS 		EQU	06FH

MI_LMSW_OPCODE                  EQU     001H ; second byte of lmsw
MI_CLTS_OPCODE                  EQU     006H ; second byte of clts
MI_GET_CRx_OPCODE               EQU     020H ; mov r32,CRx
MI_SET_CRx_OPCODE               EQU     022h ; mov CRx,r32
MI_GET_TRx_OPCODE               EQU     024H ; mov r32,TRx
MI_SET_TRx_OPCODE               EQU     026H ; mov TRx,r32

MI_REGMASK                      EQU     038H ; REG field mask
MI_REGSHIFT                     EQU     3    ; REG field shift
MI_REGLMSW                      EQU     030h ; REG field for lmsw

MI_MODMASK                      EQU     0C0H ; MOD field mask
MI_MODSHIFT                     EQU     6    ; MOD field shift
MI_MODMOVSPEC                   EQU     0C0H ; MOD field for mov to/from special
MI_MODNONE                      EQU     0

MI_RMMASK                       EQU     007H ; RM field mask
MI_RMBP                         EQU     006H ; RM value for bp reg
MI_RMSIB                        EQU     004H ; RM value for sib

MI_SIB_BASEMASK                 EQU     007H ; SIB BASE field mask
MI_SIB_BASENONE                 EQU     005H
MI_SIB_BASESHIFT                EQU     0

MI_SIB_INDEXMASK                EQU     038H
MI_SIB_INDEXSHIFT               EQU     3
MI_SIB_INDEXNONE                EQU     020H

MI_SIB_SSMASK                   EQU     0c0H
MI_SIB_SSSHIFT                  EQU     6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\mac386.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mac386.inc - 386 machine specific assembler macros
;
; Abstract:
;
;   This module contains 386 machine specific (assembler) macros
;   applicable to code outside the kernel.  Note that
;   ACQUIRE_SPINLOCK_DIRECT assumes the PCR is handy, so it won't
;   work in user mode (with debugging turned on.)
;
; Author:
;
;   Bryan Willman (bryanwi)  1 Aug 90
;

;++
;
;  YIELD
;
;  Macro Description:
;
;     This macro implements the yield instruction
;--


IFDEF _CAPKERN
        extrn   _CAP_Log_NInt:PROC
ENDIF

YIELD macro
ifndef NT_UP
    db  0f3h
    db  090h
endif
endm


if NT_INST
else

;++
;
;  ACQUIRE_SPINLOCK LockAddress, SpinLabel
;
;  Macro Description:
;
;     This macro acquires a kernel spin lock.
;
;     N.B. This macro assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (KSPIN_LOCK) LockAddress - address of SpinLock value
;     SpinLabel   - if acquire spinlock fail, the label to perform the
;                   spin checking.  It could be simply a "label" or
;                   "short label" which means the label is within 128
;                   bytes in distant.
;
;     NoChecking - Not blank, if no debugging code should be generated.
;--

ACQUIRE_SPINLOCK macro   LockAddress, SpinLabel, NoChecking

.errb <LockAddress>
.errb <SpinLabel>

ifndef NT_UP

;
; Attempt to assert the lock
;

ifdef CAPKERN_SYNCH_POINTS
        push    LockAddress
        push    000010101h    ; 1 Dword, Timestamp, Subcode = 1
        call    _CAP_Log_NInt
        add     esp, 8
endif

        lock bts dword ptr [LockAddress], 0     ; test and set the spinlock
        jc      SpinLabel               ; spinlock owned, go SpinLabe

if    DBG
ifb   <NoChecking>
        push    edi                     ; save edi
        mov     edi,fs:PcPrcb
        mov     edi, [edi].PbCurrentThread
        or      edi, 1                  ; spinlock owned
        mov     [LockAddress], edi      ; remember current thread
        pop     edi                     ; restore edi
endif ; NoChecking
endif ; DBG
endif ; NT_UP

endm

;++
;
;  SPIN_ON_SPINLOCK   LockAddress, AcquireLabel
;
;  Macro Description:
;
;     This macro spins on a kernel spin lock.
;
;     N.B. This macro assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (KSPIN_LOCK) LockAddress - address of a SpinLock value
;
;     SpinLabel    - if the test on cleared spinlock sucess, the label
;                    to assert the spin lock.  It could be simply a
;                    "label" or  "short label" which means the label is
;                    within 128 bytes in distance.
;
;     NoChecking - Not blank, if no debugging code should be generated.
;--

SPIN_ON_SPINLOCK macro   LockAddress, AcquireLabel, NoChecking, PollDebugger, NoTimeout

local   a,b,flag                                ; define a local label

.errb <LockAddress>
.errb <AcquireLabel>

ifndef NT_UP
if    DBG

EXTRNP  Kii386SpinOnSpinLock,2
        flag = 0

ifb   <NoChecking>
        flag = flag + 1
endif

ifnb  <Polldebugger>
        flag = flag + 2
endif

ifb   <NoTimeout>
        flag = flag + 4
endif
        stdCall Kii386SpinOnSpinLock,<LockAddress,flag>
        jmp     AcquireLabel

else    ; DBG

;
; Non-Debug version
;

ifdef CAPKERN_SYNCH_POINTS

        push    eax
        push    ebx
        mov     eax, LockAddress
        xor     ebx, ebx
a:      inc     ebx
        test    dword ptr [eax], 1 ; Was spinlock cleared?
        jz      short b                 ; Yes, go get it
        YIELD
        jmp     short a

b:      
        push    eax
        push    ebx
        push    000020102h    ; 2 Dwords, Timestamp, Subcode = 2
        call    _CAP_Log_NInt
        add     esp, 12
        pop     ebx
        pop     eax
        jmp     AcquireLabel

else

a:      test    dword ptr [LockAddress], 1 ; Was spinlock cleared?
        jz      AcquireLabel            ; Yes, go get it
        YIELD
        jmp     short a

endif

endif   ; DBG
endif   ; NT_UP

endm


;++
;
;  TEST_SPINLOCK   LockAddress, BusyLabel
;
;  Macro Description:
;
;     This macro tests a kernel spin lock to see if it's busy.
;     If it's not busy, ACQUIRE_SPINLOCK still needs to be called
;     to obtain the spinlock in a locked manner.
;
;  Arguments:
;
;     (KSPIN_LOCK) LockAddress - address of a SpinLock value


TEST_SPINLOCK macro   LockAddress, BusyLabel
        test    dword ptr [LockAddress], 1 ; spinlock clear?
        jnz     BusyLabel                  ; No, then busy
endm




;++
;
;  RELEASE_SPINLOCK  LockAddress
;
;  Macro Description:
;
;     This macro releases a kernel spin lock.
;
;     N.B. This macro assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (KSPIN_LOCK) LockAddress - Supplies an address to a spin lock value
;     NoChecking - Not blank, if no debugging code should be generated.
;--

RELEASE_SPINLOCK macro   LockAddress, NoChecking
local a
.errb <LockAddress>
ifndef NT_UP
if    DBG
ifb   <NoChecking>
EXTRNP  _KeBugCheckEx,5

        push    edi                     ; save edi
        mov     edi,fs:PcPrcb
        mov     edi,[edi].PbCurrentThread
        or      edi, 1                  ; assume current thread owns the lock
        cmp     edi, [LockAddress]      ; Does current thread own the lock?
        pop     edi                     ; restore edi
        jz      short a                 ; if z, yes, goto a and release lock
        stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,LockAddress,0,0,0>
a:
endif
        lock and dword ptr [LockAddress], 0
else
        lock and byte ptr [LockAddress], 0

endif   ; DBG
ifdef CAPKERN_SYNCH_POINTS
        push    LockAddress
        push    000010107h    ; 1 Dword, Timestamp, Subcode = 7
        call    _CAP_Log_NInt
        add     esp, 8
endif
endif   ; NT_UP
endm


endif
if NT_INST

;
; These are the instrumentation version of the above functions.
; internal use only
;

ACQUIRE_SPINLOCK macro   LockAddress, SpinLabel, NoChecking
EXTRNP  KiInst_AcquireSpinLock,0
ifidni  <&LockAddress>, <eax>
        stdCall KiInst_AcquireSpinLock
else
        push    eax
        mov     eax, LockAddress
        stdCall KiInst_AcquireSpinLock
        pop     eax
endif
        jc      SpinLabel
endm

SPIN_ON_SPINLOCK macro   LockAddress, AcquireLabel, NoChecking, PollDebugger
EXTRNP  KiInst_SpinOnSpinLock,0
ifidni  <&LockAddress>, <eax>
        stdCall KiInst_SpinOnSpinLock
else
        push    eax
        mov     eax, LockAddress
        stdCall KiInst_SpinOnSpinLock
        pop     eax
endif
        jmp     AcquireLabel
endm

TEST_SPINLOCK macro   LockAddress, BusyLabel
EXTRNP  KiInst_TestSpinLock,0
ifidni  <&LockAddress>, <eax>
        stdCall KiInst_TestSpinLock
else
        push    eax
        mov     eax, LockAddress
        stdCall KiInst_TestSpinLock
        pop     eax
endif
        jnc     AcquireLabel
endm

RELEASE_SPINLOCK macro   LockAddress, NoChecking
EXTRNP  KiInst_ReleaseSpinLock,0
ifidni  <&LockAddress>, <eax>
        stdCall KiInst_ReleaseSpinLock
else
        push    eax
        mov     eax, LockAddress
        stdCall KiInst_ReleaseSpinLock
        pop     eax
endif
endm

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\memprint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memprint.h

Abstract:

    Include file for in-memory DbgPrint function.  Including this file
    will change DbgPrints to a routine which puts the display text in a
    circular buffer in memory.  By default, the text is then sent to the
    console via DbgPrint.  By changing the value of the MemPrintFlags
    flag, however, the text may be routed to a file instead, thereby
    significantly speeding up the DbgPrint operation.

Author:

    David Treadwell (davidtr) 05-Oct-1990

Revision History:

--*/

#ifndef _MEMPRINT_
#define _MEMPRINT_

#define MEM_PRINT_FLAG_CONSOLE     0x01
#define MEM_PRINT_FLAG_FILE        0x02
#define MEM_PRINT_FLAG_HEADER      0x04

extern ULONG MemPrintFlags;

#ifdef MIPS
#define MEM_PRINT_DEF_BUFFER_SIZE 16384
#else
#define MEM_PRINT_DEF_BUFFER_SIZE 65536
#endif

//
// The subbuffer count is the number of subbuffers within the circular
// buffer.  A subbuffer is the method used to buffer data between
// MemPrint and writing to disk--when a subbuffer is filled, its
// contents are written to the log file.  This value should be a power
// of two between two and sixty-four (two is necessary to allow writing
// to disk and RAM simultaneously, sixty-four is the maximum number of
// things a thread can wait on at once).
//
//

#define MEM_PRINT_DEF_SUBBUFFER_COUNT 16
#define MEM_PRINT_MAX_SUBBUFFER_COUNT 64

#define MEM_PRINT_LOG_FILE_NAME "\\SystemRoot\\Logfile"

//
// Exported routines.  MemPrintInitialize sets up the circular buffer
// and other memory, MemPrint writes text to the console and/or a
// log file, and MemPrintFlush writes the current subbuffer to disk
// whether or not it is full.
//

VOID
MemPrintInitialize (
    VOID
    );

VOID
MemPrint (
    CHAR *Format, ...
    );

VOID
MemPrintFlush (
    VOID
    );

#define DbgPrint MemPrint

#endif // def _MEMPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\mm.h ===
/*-- BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mm.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the memory management system.

Author:

    Lou Perazzoli (loup) 20-Mar-1989
    Landy Wang (landyw) 02-June-1997

Revision History:

--*/

#ifndef _MM_
#define _MM_

//
// Virtual bias applied when the kernel image was loaded.
//

#if !defined(_WIN64)
extern ULONG_PTR MmVirtualBias;
#else
#define MmVirtualBias   0
#endif

typedef struct _PHYSICAL_MEMORY_RUN {
    PFN_NUMBER BasePage;
    PFN_NUMBER PageCount;
} PHYSICAL_MEMORY_RUN, *PPHYSICAL_MEMORY_RUN;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR {
    ULONG NumberOfRuns;
    PFN_NUMBER NumberOfPages;
    PHYSICAL_MEMORY_RUN Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR, *PPHYSICAL_MEMORY_DESCRIPTOR;

//
// Physical memory blocks.
//

extern PPHYSICAL_MEMORY_DESCRIPTOR MmPhysicalMemoryBlock;

//
// The allocation granularity is 64k.
//

#define MM_ALLOCATION_GRANULARITY ((ULONG)0x10000)

//
// Maximum read ahead size for cache operations.
//

#define MM_MAXIMUM_READ_CLUSTER_SIZE (15)

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
//  Indicates the system may do I/O to physical addresses above 4 GB.
//

extern PBOOLEAN Mm64BitPhysicalAddress;

// end_ntddk end_wdm end_nthal end_ntifs

#else

//
//  Indicates the system may do I/O to physical addresses above 4 GB.
//

extern BOOLEAN Mm64BitPhysicalAddress;

#endif

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//
// Define maximum disk transfer size to be used by MM and Cache Manager,
// so that packet-oriented disk drivers can optimize their packet allocation
// to this size.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG_PTR
// ROUND_TO_PAGES (
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  (((Size) >> PAGE_SHIFT) + \
                               (((Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(COMPUTE_PAGES_SPANNED)   // Use ADDRESS_AND_SIZE_TO_SPAN_PAGES
#endif

#define COMPUTE_PAGES_SPANNED(Va, Size) ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size)

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//++
//
// BOOLEAN
// IS_SYSTEM_ADDRESS
//     IN PVOID Va,
//     )
//
// Routine Description:
//
//     This macro takes a virtual address and returns TRUE if the virtual address
//     is within system space, FALSE otherwise.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns TRUE is the address is in system space.
//
//--

// begin_ntosp
#define IS_SYSTEM_ADDRESS(VA) ((VA) >= MM_SYSTEM_RANGE_START)
// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virtual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) ((Mdl)->StartVa) + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  ((Mdl)->StartVa)

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Section object type.
//

extern POBJECT_TYPE MmSectionObjectType;

//
// PAE PTE mask.
//

extern ULONG MmPaeErrMask;
extern ULONGLONG MmPaeMask;

//
// Number of pages to read in a single I/O if possible.
//

extern ULONG MmReadClusterSize;

//
// Number of colors in system.
//

extern ULONG MmNumberOfColors;

//
// Number of physical pages.
//

extern PFN_COUNT MmNumberOfPhysicalPages;

//
// Lowest physical page number on the system.
//

extern PFN_NUMBER MmLowestPhysicalPage;

//
// Highest physical page number on the system.
//

extern PFN_NUMBER MmHighestPhysicalPage;

//
// Total number of committed pages.
//

extern SIZE_T MmTotalCommittedPages;

extern SIZE_T MmTotalCommitLimit;

extern SIZE_T MmPeakCommitment;

typedef enum _MMSYSTEM_PTE_POOL_TYPE {
    SystemPteSpace,
    NonPagedPoolExpansion,
    MaximumPtePoolTypes
} MMSYSTEM_PTE_POOL_TYPE;

extern ULONG MmTotalFreeSystemPtes[MaximumPtePoolTypes];



//
// Virtual size of system cache in pages.
//

extern ULONG_PTR MmSizeOfSystemCacheInPages;

//
// System cache working set.
//

extern MMSUPPORT MmSystemCacheWs;

//
// Working set manager event.
//

extern KEVENT MmWorkingSetManagerEvent;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize (
    VOID
    );

// end_wdm

NTKERNELAPI
BOOLEAN
MmIsThisAnNtAsSystem (
    VOID
    );

// end_ntddk end_nthal end_ntifs end_ntosp

//
// NT product type.
//

extern ULONG MmProductType;

typedef struct _MMINFO_COUNTERS {
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
} MMINFO_COUNTERS;

typedef MMINFO_COUNTERS *PMMINFO_COUNTERS;

extern MMINFO_COUNTERS MmInfoCounters;



//
// Memory management initialization routine (for both phases).
//

BOOLEAN
MmInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

PPHYSICAL_MEMORY_DESCRIPTOR
MmInitializeMemoryLimits (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PBOOLEAN IncludedType,
    IN OUT PPHYSICAL_MEMORY_DESCRIPTOR Memory OPTIONAL
    );

VOID
MmFreeLoaderBlock (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
MmEnablePAT (
    VOID
    );

PVOID
MmAllocateIndependentPages (
    IN SIZE_T NumberOfBytes,
    IN ULONG NodeNumber
    );

BOOLEAN
MmSetPageProtection (
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG NewProtect
    );

VOID
MmFreeIndependentPages (
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes
    );

//
// Shutdown routine - flushes dirty pages, etc for system shutdown.
//

BOOLEAN
MmShutdownSystem (
    IN ULONG
    );

//
// Routines to deal with working set and commit enforcement.
//

LOGICAL
MmAssignProcessToJob (
    IN PEPROCESS Process
    );

#define MM_WORKING_SET_MAX_HARD_ENABLE      0x1
#define MM_WORKING_SET_MAX_HARD_DISABLE     0x2
#define MM_WORKING_SET_MIN_HARD_ENABLE      0x4
#define MM_WORKING_SET_MIN_HARD_DISABLE     0x8

NTSTATUS
MmEnforceWorkingSetLimit (
    IN PEPROCESS Process,
    IN ULONG Flags
    );

PFN_NUMBER
MmSetPhysicalPagesLimit (
    IN PFN_NUMBER NewPhysicalPagesLimit
    );

//
// Routines to deal with session space.
//

NTSTATUS
MmSessionCreate (
    OUT PULONG SessionId
    );

NTSTATUS
MmSessionDelete (
    IN ULONG SessionId
    );

ULONG
MmGetSessionId (
    IN PEPROCESS Process
    );

ULONG
MmGetSessionIdEx (
    IN PEPROCESS Process
    );

LCID
MmGetSessionLocaleId (
    VOID
    );

VOID
MmSetSessionLocaleId (
    IN LCID LocaleId
    );

PVOID
MmGetSessionById (
    IN ULONG SessionId
    );

PVOID
MmGetNextSession (
    IN PVOID OpaqueSession
    );

PVOID
MmGetPreviousSession (
    IN PVOID OpaqueSession
    );

NTSTATUS
MmQuitNextSession (
    IN PVOID OpaqueSession
    );

NTSTATUS
MmAttachSession (
    IN PVOID OpaqueSession,
    OUT PRKAPC_STATE ApcState
    );

NTSTATUS
MmDetachSession (
    IN PVOID OpaqueSession,
    IN PRKAPC_STATE ApcState
    );

VOID
MmSessionSetUnloadAddress (
    IN PDRIVER_OBJECT pWin32KDevice
    );

NTSTATUS
MmGetSessionMappedViewInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL
    );

//
// Pool support routines to allocate complete pages, not for
// general consumption, these are only used by the executive pool allocator.
//

SIZE_T
MmAvailablePoolInPages (
    IN POOL_TYPE PoolType
    );

LOGICAL
MmResourcesAvailable (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN EX_POOL_PRIORITY Priority
    );

VOID
MiMarkPoolLargeSession (
    IN PVOID VirtualAddress
    );

LOGICAL
MiIsPoolLargeSession (
    IN PVOID VirtualAddress
    );

PVOID
MiAllocatePoolPages (
    IN POOL_TYPE PoolType,
    IN SIZE_T SizeInBytes
    );

ULONG
MiFreePoolPages (
    IN PVOID StartingAddress
    );

PVOID
MiSessionPoolVector (
    VOID
    );

PVOID
MiSessionPoolMutex (
    VOID
    );

PGENERAL_LOOKASIDE
MiSessionPoolLookaside (
    VOID
    );

ULONG
MiSessionPoolSmallLists (
    VOID
    );

PVOID
MiSessionPoolTrackTable (
    VOID
    );

SIZE_T
MiSessionPoolTrackTableSize (
    VOID
    );

PVOID
MiSessionPoolBigPageTable (
    VOID
    );

SIZE_T
MiSessionPoolBigPageTableSize (
    VOID
    );

ULONG
MmGetSizeOfBigPoolAllocation (
    IN PVOID StartingAddress
    );

//
// Routine for determining which pool a given address resides within.
//

POOL_TYPE
MmDeterminePoolType (
    IN PVOID VirtualAddress
    );

LOGICAL
MmIsSystemAddressLocked (
    IN PVOID VirtualAddress
    );

LOGICAL
MmAreMdlPagesLocked (
    IN PMDL MemoryDescriptorList
    );

//
// MmMemoryIsLow is not for general consumption, this is only used
// by the balance set manager.
//

LOGICAL
MmMemoryIsLow (
    VOID
    );

//
// First level fault routine.
//

NTSTATUS
MmAccessFault (
    IN ULONG_PTR FaultStatus,
    IN PVOID VirtualAddress,
    IN KPROCESSOR_MODE PreviousMode,
    IN PVOID TrapInformation
    );

#if defined(_IA64_)
NTSTATUS
MmX86Fault (
    IN ULONG_PTR FaultStatus,
    IN PVOID VirtualAddress,
    IN KPROCESSOR_MODE PreviousMode,
    IN PVOID TrapInformation
    );
#endif

//
// Process Support Routines.
//

BOOLEAN
MmCreateProcessAddressSpace (
    IN ULONG MinimumWorkingSetSize,
    IN PEPROCESS NewProcess,
    OUT PULONG_PTR DirectoryTableBase
    );

NTSTATUS
MmInitializeProcessAddressSpace (
    IN PEPROCESS ProcessToInitialize,
    IN PEPROCESS ProcessToClone OPTIONAL,
    IN PVOID SectionToMap OPTIONAL,
    OUT POBJECT_NAME_INFORMATION * pAuditName OPTIONAL
    );

NTSTATUS
MmInitializeHandBuiltProcess (
    IN PEPROCESS Process,
    OUT PULONG_PTR DirectoryTableBase
    );

NTSTATUS
MmInitializeHandBuiltProcess2 (
    IN PEPROCESS Process
    );

VOID
MmDeleteProcessAddressSpace (
    IN PEPROCESS Process
    );

VOID
MmCleanProcessAddressSpace (
    IN PEPROCESS Process
    );

PFN_NUMBER
MmGetDirectoryFrameFromProcess (
    IN PEPROCESS Process
    );

PFILE_OBJECT
MmGetFileObjectForSection (
    IN PVOID Section
    );

PVOID
MmCreateKernelStack (
    BOOLEAN LargeStack,
    UCHAR Processor
    );

VOID
MmDeleteKernelStack (
    IN PVOID PointerKernelStack,
    IN BOOLEAN LargeStack
    );

LOGICAL
MmIsFileObjectAPagingFile (
    IN PFILE_OBJECT FileObject
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
MmGrowKernelStack (
    IN PVOID CurrentStack
    );
// end_ntosp

#if defined(_IA64_)
NTSTATUS
MmGrowKernelBackingStore (
    IN PVOID CurrentStack
    );
#endif

VOID
MmOutPageKernelStack (
    IN PKTHREAD Thread
    );

VOID
MmInPageKernelStack (
    IN PKTHREAD Thread
    );

VOID
MmOutSwapProcess (
    IN PKPROCESS Process
    );

VOID
MmInSwapProcess (
    IN PKPROCESS Process
    );

NTSTATUS
MmCreateTeb (
    IN PEPROCESS TargetProcess,
    IN PINITIAL_TEB InitialTeb,
    IN PCLIENT_ID ClientId,
    OUT PTEB *Base
    );

NTSTATUS
MmCreatePeb (
    IN PEPROCESS TargetProcess,
    IN PINITIAL_PEB InitialPeb,
    OUT PPEB *Base
    );

VOID
MmDeleteTeb (
    IN PEPROCESS TargetProcess,
    IN PVOID TebBase
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
MmAdjustWorkingSetSize (
    IN SIZE_T WorkingSetMinimum,
    IN SIZE_T WorkingSetMaximum,
    IN ULONG SystemCache,
    IN BOOLEAN IncreaseOkay
    );
// end_ntosp

NTSTATUS
MmAdjustWorkingSetSizeEx (
    IN SIZE_T WorkingSetMinimum,
    IN SIZE_T WorkingSetMaximum,
    IN ULONG SystemCache,
    IN BOOLEAN IncreaseOkay,
    IN ULONG Flags
    );

NTSTATUS
MmQueryWorkingSetInformation (
    IN PSIZE_T PeakWorkingSetSize,
    IN PSIZE_T WorkingSetSize,
    IN PSIZE_T MinimumWorkingSetSize,
    IN PSIZE_T MaximumWorkingSetSize,
    IN PULONG HardEnforcementFlags
    );

VOID
MmWorkingSetManager (
    VOID
    );

VOID
MmEmptyAllWorkingSets (
    VOID
    );

VOID
MmSetMemoryPriorityProcess (
    IN PEPROCESS Process,
    IN UCHAR MemoryPriority
    );

//
// Dynamic system loading support
//

#define MM_LOAD_IMAGE_IN_SESSION    0x1
#define MM_LOAD_IMAGE_AND_LOCKDOWN  0x2

NTSTATUS
MmLoadSystemImage (
    IN PUNICODE_STRING ImageFileName,
    IN PUNICODE_STRING NamePrefix OPTIONAL,
    IN PUNICODE_STRING LoadedBaseName OPTIONAL,
    IN ULONG LoadFlags,
    OUT PVOID *Section,
    OUT PVOID *ImageBaseAddress
    );

VOID
MmFreeDriverInitialization (
    IN PVOID Section
    );

NTSTATUS
MmUnloadSystemImage (
    IN PVOID Section
    );

VOID
MmMakeKernelResourceSectionWritable (
    VOID
    );

#if defined(_WIN64)
PVOID
MmGetMaxWowAddress (
    VOID
    );
#endif

VOID
VerifierFreeTrackedPool (
    IN PVOID VirtualAddress,
    IN SIZE_T ChargedBytes,
    IN LOGICAL CheckType,
    IN LOGICAL SpecialPool
    );

//
//  Hot-patching routines
//

NTSTATUS
MmLockAndCopyMemory (
    IN PSYSTEM_HOTPATCH_CODE_INFORMATION PatchInfo,
    IN KPROCESSOR_MODE ProbeMode
    );

NTSTATUS
MmHotPatchRoutine(
    PSYSTEM_HOTPATCH_CODE_INFORMATION RemoteInfo
    );



//
// Triage support
//

ULONG
MmSizeOfTriageInformation (
    VOID
    );

ULONG
MmSizeOfUnloadedDriverInformation (
    VOID
    );

VOID
MmWriteTriageInformation (
    IN PVOID
    );

VOID
MmWriteUnloadedDriverInformation (
    IN PVOID
    );

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, *PUNLOADED_DRIVERS;

//
// Cache manager support
//

#if defined(_NTDDK_) || defined(_NTIFS_)

// begin_ntifs

NTKERNELAPI
BOOLEAN
MmIsRecursiveIoFault(
    VOID
    );

// end_ntifs
#else

//++
//
// BOOLEAN
// MmIsRecursiveIoFault (
//     VOID
//     );
//
// Routine Description:
//
//
// This macro examines the thread's page fault clustering information
// and determines if the current page fault is occurring during an I/O
// operation.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Returns TRUE if the fault is occurring during an I/O operation,
//     FALSE otherwise.
//
//--

#define MmIsRecursiveIoFault() \
                 ((PsGetCurrentThread()->DisablePageFaultClustering) | \
                  (PsGetCurrentThread()->ForwardClusterOnly))

#endif

//++
//
// VOID
// MmDisablePageFaultClustering
//     OUT PULONG SavedState
//     );
//
// Routine Description:
//
//
// This macro disables page fault clustering for the current thread.
// Note, that this indicates that file system I/O is in progress
// for that thread.
//
// Arguments:
//
//     SavedState - returns previous state of page fault clustering which
//                  is guaranteed to be nonzero
//
// Return Value:
//
//     None.
//
//--

#define MmDisablePageFaultClustering(SavedState) {                                          \
                *(SavedState) = 2 + (ULONG)PsGetCurrentThread()->DisablePageFaultClustering;\
                PsGetCurrentThread()->DisablePageFaultClustering = TRUE; }


//++
//
// VOID
// MmEnablePageFaultClustering
//     IN ULONG SavedState
//     );
//
// Routine Description:
//
//
// This macro enables page fault clustering for the current thread.
// Note, that this indicates that no file system I/O is in progress for
// that thread.
//
// Arguments:
//
//     SavedState - supplies previous state of page fault clustering
//
// Return Value:
//
//     None.
//
//--

#define MmEnablePageFaultClustering(SavedState) {                                               \
                PsGetCurrentThread()->DisablePageFaultClustering = (BOOLEAN)(SavedState - 2); }

//++
//
// VOID
// MmSavePageFaultReadAhead
//     IN PETHREAD Thread,
//     OUT PULONG SavedState
//     );
//
// Routine Description:
//
//
// This macro saves the page fault read ahead value for the specified
// thread.
//
// Arguments:
//
//     Thread - Supplies a pointer to the current thread.
//
//     SavedState - returns previous state of page fault read ahead
//
// Return Value:
//
//     None.
//
//--


#define MmSavePageFaultReadAhead(Thread,SavedState) {               \
                *(SavedState) = (Thread)->ReadClusterSize * 2 +     \
                                (Thread)->ForwardClusterOnly; }

//++
//
// VOID
// MmSetPageFaultReadAhead
//     IN PETHREAD Thread,
//     IN ULONG ReadAhead
//     );
//
// Routine Description:
//
//
// This macro sets the page fault read ahead value for the specified
// thread, and indicates that file system I/O is in progress for that
// thread.
//
// Arguments:
//
//     Thread - Supplies a pointer to the current thread.
//
//     ReadAhead - Supplies the number of pages to read in addition to
//                 the page the fault is taken on.  A value of 0
//                 reads only the faulting page, a value of 1 reads in
//                 the faulting page and the following page, etc.
//
// Return Value:
//
//     None.
//
//--


#define MmSetPageFaultReadAhead(Thread,ReadAhead) {                          \
                (Thread)->ForwardClusterOnly = TRUE;                         \
                if ((ReadAhead) > MM_MAXIMUM_READ_CLUSTER_SIZE) {            \
                    (Thread)->ReadClusterSize = MM_MAXIMUM_READ_CLUSTER_SIZE;\
                } else {                                                     \
                    (Thread)->ReadClusterSize = (ReadAhead);                 \
                } }

//++
//
// VOID
// MmResetPageFaultReadAhead
//     IN PETHREAD Thread,
//     IN ULONG SavedState
//     );
//
// Routine Description:
//
//
// This macro resets the default page fault read ahead value for the specified
// thread, and indicates that file system I/O is not in progress for that
// thread.
//
// Arguments:
//
//     Thread - Supplies a pointer to the current thread.
//
//     SavedState - supplies previous state of page fault read ahead
//
// Return Value:
//
//     None.
//
//--

#define MmResetPageFaultReadAhead(Thread, SavedState) {                     \
                (Thread)->ForwardClusterOnly = (BOOLEAN)((SavedState) & 1); \
                (Thread)->ReadClusterSize = (SavedState) / 2; }

//
// The order of this list is important, the zeroed, free and standby
// must occur before the modified or bad so comparisons can be
// made when pages are added to a list.
//
// NOTE: This field is limited to 8 elements.
//       Also, if this field is expanded, update the MMPFNLIST_* defines in ntmmapi.h
//

#define NUMBER_OF_PAGE_LISTS 8

typedef enum _MMLISTS {
    ZeroedPageList,
    FreePageList,
    StandbyPageList,  //this list and before make up available pages.
    ModifiedPageList,
    ModifiedNoWritePageList,
    BadPageList,
    ActiveAndValid,
    TransitionPage
} MMLISTS;

typedef struct _MMPFNLIST {
    PFN_NUMBER Total;
    MMLISTS ListName;
    PFN_NUMBER Flink;
    PFN_NUMBER Blink;
} MMPFNLIST;

typedef MMPFNLIST *PMMPFNLIST;

extern MMPFNLIST MmModifiedPageListHead;

extern PFN_NUMBER MmThrottleTop;
extern PFN_NUMBER MmThrottleBottom;

//++
//
// BOOLEAN
// MmEnoughMemoryForWrite (
//     VOID
//     );
//
// Routine Description:
//
//
// This macro checks the modified pages and available pages to determine
// to allow the cache manager to throttle write operations.
//
// For NTAS:
// Writes are blocked if there are less than 127 available pages OR
// there are more than 1000 modified pages AND less than 450 available pages.
//
// For DeskTop:
// Writes are blocked if there are less than 30 available pages OR
// there are more than 1000 modified pages AND less than 250 available pages.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if ample memory exists and the write should proceed.
//
//--

#define MmEnoughMemoryForWrite()                         \
            ((MmAvailablePages > MmThrottleTop)          \
                        ||                               \
             (((MmModifiedPageListHead.Total < 1000)) && \
               (MmAvailablePages > MmThrottleBottom)))

// begin_ntosp

NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );


NTKERNELAPI
NTSTATUS
MmMapViewOfSection (
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection (
    IN PEPROCESS Process,
    IN PVOID BaseAddress
     );

// end_ntosp begin_ntifs

BOOLEAN
MmForceSectionClosed (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN BOOLEAN DelayClose
    );

// end_ntifs

NTSTATUS
MmGetFileNameForSection (
    IN PVOID SectionObject,
    OUT PSTRING FileName
    );

NTSTATUS
MmGetFileNameForAddress (
    IN PVOID ProcessVa,
    OUT PUNICODE_STRING FileName
    );

NTSTATUS
MmRemoveVerifierEntry (
    IN PUNICODE_STRING ImageFileName
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

NTSTATUS
MmIsVerifierEnabled (
    OUT PULONG VerifierFlags
    );

NTSTATUS
MmAddVerifierThunks (
    IN PVOID ThunkBuffer,
    IN ULONG ThunkBufferSize
    );

// end_ntddk end_wdm end_ntifs end_ntosp

NTSTATUS
MmAddVerifierEntry (
    IN PUNICODE_STRING ImageFileName
    );

NTSTATUS
MmSetVerifierInformation (
    IN OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );

NTSTATUS
MmGetVerifierInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
MmGetPageFileInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

HANDLE
MmGetSystemPageFile (
    VOID
    );

NTSTATUS
MmExtendSection (
    IN PVOID SectionToExtend,
    IN OUT PLARGE_INTEGER NewSectionSize,
    IN ULONG IgnoreFileSizeChecking
    );

NTSTATUS
MmFlushVirtualMemory (
    IN PEPROCESS Process,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
MmMapViewInSystemCache (
    IN PVOID SectionToMap,
    OUT PVOID *CapturedBase,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PULONG CapturedViewSize
    );

VOID
MmUnmapViewInSystemCache (
    IN PVOID BaseAddress,
    IN PVOID SectionToUnmap,
    IN ULONG AddToFront
    );

BOOLEAN
MmPurgeSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN PLARGE_INTEGER Offset OPTIONAL,
    IN SIZE_T RegionSize,
    IN ULONG IgnoreCacheViews
    );

NTSTATUS
MmFlushSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN PLARGE_INTEGER Offset OPTIONAL,
    IN SIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN ULONG AcquireFile
    );

// begin_ntifs

typedef enum _MMFLUSH_TYPE {
    MmFlushForDelete,
    MmFlushForWrite
} MMFLUSH_TYPE;


BOOLEAN
MmFlushImageSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN MMFLUSH_TYPE FlushType
    );

BOOLEAN
MmCanFileBeTruncated (
    IN PSECTION_OBJECT_POINTERS SectionPointer,
    IN PLARGE_INTEGER NewFileSize
    );


// end_ntifs

ULONG
MmDoesFileHaveUserWritableReferences (
    IN PSECTION_OBJECT_POINTERS SectionPointer
    );

BOOLEAN
MmDisableModifiedWriteOfSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer
    );

BOOLEAN
MmEnableModifiedWriteOfSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer
    );

VOID
MmPurgeWorkingSet (
     IN PEPROCESS Process,
     IN PVOID BaseAddress,
     IN SIZE_T RegionSize
     );

BOOLEAN                                     // ntifs
MmSetAddressRangeModified (                 // ntifs
    IN PVOID Address,                       // ntifs
    IN SIZE_T Length                        // ntifs
    );                                      // ntifs

BOOLEAN
MmCheckCachedPageState (
    IN PVOID Address,
    IN BOOLEAN SetToZero
    );

NTSTATUS
MmCopyToCachedPage (
    IN PVOID Address,
    IN PVOID UserBuffer,
    IN ULONG Offset,
    IN SIZE_T CountInBytes,
    IN BOOLEAN DontZero
    );

VOID
MmUnlockCachedPage (
    IN PVOID AddressInCache
    );

#define MMDBG_COPY_WRITE            0x00000001
#define MMDBG_COPY_PHYSICAL         0x00000002
#define MMDBG_COPY_UNSAFE           0x00000004
#define MMDBG_COPY_CACHED           0x00000008
#define MMDBG_COPY_UNCACHED         0x00000010
#define MMDBG_COPY_WRITE_COMBINED   0x00000020

#define MMDBG_COPY_MAX_SIZE 8

NTSTATUS
MmDbgCopyMemory (
    IN ULONG64 UntrustedAddress,
    IN PVOID Buffer,
    IN ULONG Size,
    IN ULONG Flags
    );

LOGICAL
MmDbgIsLowMemOk (
    IN PFN_NUMBER PageFrameIndex,
    OUT PPFN_NUMBER NextPageFrameIndex,
    IN OUT PULONG CorruptionOffset
    );

VOID
MmHibernateInformation (
    IN PVOID MemoryMap,
    OUT PULONG_PTR HiberVa,
    OUT PPHYSICAL_ADDRESS HiberPte
    );

LOGICAL
MmUpdateMdlTracker (
    IN PMDL MemoryDescriptorList,
    IN PVOID CallingAddress,
    IN PVOID CallersCaller
    );

// begin_ntddk begin_ntifs begin_wdm begin_ntosp

NTKERNELAPI
VOID
MmProbeAndLockProcessPages (
    IN OUT PMDL MemoryDescriptorList,
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );


// begin_nthal
//
// I/O support routines.
//

NTKERNELAPI
VOID
MmProbeAndLockPages (
    IN OUT PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );


NTKERNELAPI
VOID
MmUnlockPages (
    IN PMDL MemoryDescriptorList
    );


NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    IN OUT PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapLockedPages (
    IN PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode
    );

LOGICAL
MmIsIoSpaceActive (
    IN PHYSICAL_ADDRESS StartAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
MmGetSystemRoutineAddress (
    IN PUNICODE_STRING SystemRoutineName
    );

NTKERNELAPI
NTSTATUS
MmAdvanceMdl (
    IN PMDL Mdl,
    IN ULONG NumberOfBytes
    );

// end_wdm

NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN PVOID PageAddress
    );

// begin_wdm
NTKERNELAPI
NTSTATUS
MmProtectMdlSystemAddress (
    IN PMDL MemoryDescriptorList,
    IN ULONG NewProtect
    );

//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//

// begin_ntndis

typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;

// end_ntndis

//
// Note: This function is not available in WDM 1.0
//
NTKERNELAPI
PVOID
MmMapLockedPagesSpecifyCache (
     IN PMDL MemoryDescriptorList,
     IN KPROCESSOR_MODE AccessMode,
     IN MEMORY_CACHING_TYPE CacheType,
     IN PVOID BaseAddress,
     IN ULONG BugCheckOnFailure,
     IN MM_PAGE_PRIORITY Priority
     );

NTKERNELAPI
VOID
MmUnmapLockedPages (
    IN PVOID BaseAddress,
    IN PMDL MemoryDescriptorList
    );

PVOID
MmAllocateMappingAddress (
     IN SIZE_T NumberOfBytes,
     IN ULONG PoolTag
     );

VOID
MmFreeMappingAddress (
     IN PVOID BaseAddress,
     IN ULONG PoolTag
     );

PVOID
MmMapLockedPagesWithReservedMapping (
    IN PVOID MappingAddress,
    IN ULONG PoolTag,
    IN PMDL MemoryDescriptorList,
    IN MEMORY_CACHING_TYPE CacheType
    );

VOID
MmUnmapReservedMapping (
     IN PVOID BaseAddress,
     IN ULONG PoolTag,
     IN PMDL MemoryDescriptorList
     );

// end_wdm

typedef struct _PHYSICAL_MEMORY_RANGE {
    PHYSICAL_ADDRESS BaseAddress;
    LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

NTKERNELAPI
NTSTATUS
MmAddPhysicalMemory (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

// end_ntddk end_nthal end_ntifs
NTKERNELAPI
NTSTATUS
MmAddPhysicalMemoryEx (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes,
    IN ULONG Flags
    );
// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemory (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

// end_ntddk end_nthal end_ntifs
NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemoryEx (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes,
    IN ULONG Flags
    );
// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
PPHYSICAL_MEMORY_RANGE
MmGetPhysicalMemoryRanges (
    VOID
    );

// end_ntddk end_ntifs
NTSTATUS
MmMarkPhysicalMemoryAsGood (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

NTSTATUS
MmMarkPhysicalMemoryAsBad (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

// begin_wdm begin_ntddk begin_ntifs

NTKERNELAPI
PMDL
MmAllocatePagesForMdl (
    IN PHYSICAL_ADDRESS LowAddress,
    IN PHYSICAL_ADDRESS HighAddress,
    IN PHYSICAL_ADDRESS SkipBytes,
    IN SIZE_T TotalBytes
    );

NTKERNELAPI
VOID
MmFreePagesFromMdl (
    IN PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

// end_wdm end_ntddk end_ntifs end_ntosp

NTKERNELAPI
VOID
MmProbeAndLockSelectedPages (
    IN OUT PMDL MemoryDescriptorList,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );

// begin_ntddk begin_ntifs begin_ntosp

NTKERNELAPI
PVOID
MmMapVideoDisplay (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
     );

NTKERNELAPI
VOID
MmUnmapVideoDisplay (
     IN PVOID BaseAddress,
     IN SIZE_T NumberOfBytes
     );

NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmGetVirtualForPhysical (
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory (
    IN SIZE_T NumberOfBytes,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemorySpecifyCache (
    IN SIZE_T NumberOfBytes,
    IN PHYSICAL_ADDRESS LowestAcceptableAddress,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress,
    IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory (
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmFreeContiguousMemorySpecifyCache (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

// end_ntddk end_ntifs end_ntosp end_nthal

NTKERNELAPI
ULONG
MmGatherMemoryForHibernate (
    IN PMDL Mdl,
    IN BOOLEAN Wait
    );

NTKERNELAPI
VOID
MmReturnMemoryForHibernate (
    IN PMDL Mdl
    );

VOID
MmReleaseDumpAddresses (
    IN PFN_NUMBER Pages
    );

// begin_ntddk begin_ntifs begin_nthal begin_ntosp

NTKERNELAPI
PVOID
MmAllocateNonCachedMemory (
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
VOID
MmFreeNonCachedMemory (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid (
    IN PVOID VirtualAddress
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
BOOLEAN
MmIsNonPagedSystemAddressValid (
    IN PVOID VirtualAddress
    );

// begin_wdm

NTKERNELAPI
SIZE_T
MmSizeOfMdl (
    IN PVOID Base,
    IN SIZE_T Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoAllocateMdl
NTKERNELAPI
PMDL
MmCreateMdl (
    IN PMDL MemoryDescriptorList OPTIONAL,
    IN PVOID Base,
    IN SIZE_T Length
    );

NTKERNELAPI
PVOID
MmLockPagableDataSection (
    IN PVOID AddressWithinSection
    );

// end_wdm

NTKERNELAPI
VOID
MmLockPagableSectionByHandle (
    IN PVOID ImageSectionHandle
    );

// end_ntddk end_ntifs end_ntosp
NTKERNELAPI
VOID
MmLockPagedPool (
    IN PVOID Address,
    IN SIZE_T Size
    );

NTKERNELAPI
VOID
MmUnlockPagedPool (
    IN PVOID Address,
    IN SIZE_T Size
    );

// begin_wdm begin_ntddk begin_ntifs begin_ntosp
NTKERNELAPI
VOID
MmResetDriverPaging (
    IN PVOID AddressWithinSection
    );


NTKERNELAPI
PVOID
MmPageEntireDriver (
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmUnlockPagableImageSection(
    IN PVOID ImageSectionHandle
    );

// end_wdm end_ntosp

// begin_ntosp

//
// Note that even though this function prototype
// says "HANDLE", MmSecureVirtualMemory does NOT return
// anything resembling a Win32-style handle.  The return
// value from this function can ONLY be used with MmUnsecureVirtualMemory.
//
NTKERNELAPI
HANDLE
MmSecureVirtualMemory (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG ProbeMode
    );

NTKERNELAPI
VOID
MmUnsecureVirtualMemory (
    IN HANDLE SecureHandle
    );

// end_ntosp

NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    IN PVOID MappedBase
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN OUT PSIZE_T ViewSize
    );

// end_ntddk end_ntifs
NTKERNELAPI
NTSTATUS
MmCommitSessionMappedView (
    IN PVOID MappedAddress,
    IN SIZE_T ViewSize
    );
// begin_ntddk begin_ntifs

NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    IN PVOID MappedBase
    );
// end_ntosp

// begin_wdm begin_ntosp

//++
//
// VOID
// MmInitializeMdl (
//     IN PMDL MemoryDescriptorList,
//     IN PVOID BaseVa,
//     IN SIZE_T Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
            (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (ULONG)(Length); \
    }

//++
//
// PVOID
// MmGetSystemAddressForMdlSafe (
//     IN PMDL MDL,
//     IN MM_PAGE_PRIORITY PRIORITY
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL. If the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
//     Priority - Supplies an indication as to how important it is that this
//                request succeed under low available PTE conditions.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//     Unlike MmGetSystemAddressForMdl, Safe guarantees that it will always
//     return NULL on failure instead of bugchecking the system.
//
//     This macro is not usable by WDM 1.0 drivers as 1.0 did not include
//     MmMapLockedPagesSpecifyCache.  The solution for WDM 1.0 drivers is to
//     provide synchronization and set/reset the MDL_MAPPING_CAN_FAIL bit.
//
//--

#define MmGetSystemAddressForMdlSafe(MDL, PRIORITY)                    \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPagesSpecifyCache((MDL),      \
                                                           KernelMode, \
                                                           MmCached,   \
                                                           NULL,       \
                                                           FALSE,      \
                                                           (PRIORITY))))

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(MmGetSystemAddressForMdl)    // Use MmGetSystemAddressForMdlSafe
#endif

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

//++
//
// VOID
// MmPrepareMdlForReuse (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }

typedef NTSTATUS (*PMM_DLL_INITIALIZE)(
    IN PUNICODE_STRING RegistryPath
    );

typedef NTSTATUS (*PMM_DLL_UNLOAD)(
    VOID
    );


// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

// begin_ntddk begin_nthal

NTKERNELAPI
NTSTATUS
MmCreateMirror (
    VOID
    );

// end_ntddk end_nthal

PVOID
MmAllocateSpecialPool (
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN POOL_TYPE Type,
    IN ULONG SpecialPoolType
    );

VOID
MmFreeSpecialPool (
    IN PVOID P
    );

LOGICAL
MmProtectSpecialPool (
    IN PVOID VirtualAddress,
    IN ULONG NewProtect
    );

LOGICAL
MmIsSpecialPoolAddressFree (
    IN PVOID VirtualAddress
    );

SIZE_T
MmQuerySpecialPoolBlockSize (
    IN PVOID P
    );

LOGICAL
MmIsSpecialPoolAddress (
    IN PVOID VirtualAddress
    );

LOGICAL
MmUseSpecialPool (
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

LOGICAL
MmIsSessionAddress (
    IN PVOID VirtualAddress
    );

PUNICODE_STRING
MmLocateUnloadedDriver (
    IN PVOID VirtualAddress
    );

// begin_ntddk begin_wdm begin_ntosp

//
// Define an empty typedef for the _DRIVER_OBJECT structure so it may be
// referenced by function types before it is actually defined.
//
struct _DRIVER_OBJECT;

NTKERNELAPI
LOGICAL
MmIsDriverVerifying (
    IN struct _DRIVER_OBJECT *DriverObject
    );

// end_ntddk end_wdm end_ntosp

LOGICAL
MmTrimAllSystemPagableMemory (
    IN LOGICAL PurgeTransition
    );

#define MMNONPAGED_QUOTA_INCREASE (64*1024)

#define MMPAGED_QUOTA_INCREASE (512*1024)

#define MMNONPAGED_QUOTA_CHECK (256*1024)

#define MMPAGED_QUOTA_CHECK (1*1024*1024)

BOOLEAN
MmRaisePoolQuota (
    IN POOL_TYPE PoolType,
    IN SIZE_T OldQuotaLimit,
    OUT PSIZE_T NewQuotaLimit
    );

VOID
MmReturnPoolQuota (
    IN POOL_TYPE PoolType,
    IN SIZE_T ReturnedQuota
    );

//
// Zero page thread routine.
//

VOID
MmZeroPageThread (
    VOID
    );

NTSTATUS
MmCopyVirtualMemory (
    IN PEPROCESS FromProcess,
    IN CONST VOID *FromAddress,
    IN PEPROCESS ToProcess,
    OUT PVOID ToAddress,
    IN SIZE_T BufferSize,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PSIZE_T NumberOfBytesCopied
    );

NTSTATUS
MmGetSectionRange (
    IN PVOID AddressWithinSection,
    OUT PVOID *StartingSectionAddress,
    OUT PULONG SizeofSection
    );

// begin_ntosp
VOID
MmMapMemoryDumpMdl (
    IN OUT PMDL MemoryDumpMdl
    );


// begin_ntminiport

//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );

// end_ntminiport

NTSTATUS
MmSetBankedSection (
    IN HANDLE ProcessHandle,
    IN PVOID VirtualAddress,
    IN ULONG BankLength,
    IN BOOLEAN ReadWriteBank,
    IN PBANKED_SECTION_ROUTINE BankRoutine,
    IN PVOID Context);
// end_ntosp

BOOLEAN
MmVerifyImageIsOkForMpUse (
    IN PVOID BaseAddress
    );

NTSTATUS
MmMemoryUsage (
    IN PVOID Buffer,
    IN ULONG Size,
    IN ULONG Type,
    OUT PULONG Length
    );

typedef
VOID
(FASTCALL *PPAGE_FAULT_NOTIFY_ROUTINE) (
    IN NTSTATUS Status,
    IN PVOID VirtualAddress,
    IN PVOID TrapInformation
    );

NTKERNELAPI
VOID
FASTCALL
MmSetPageFaultNotifyRoutine (
    IN PPAGE_FAULT_NOTIFY_ROUTINE NotifyRoutine
    );

NTSTATUS
MmCallDllInitialize (
    IN PKLDR_DATA_TABLE_ENTRY DataTableEntry,
    IN PLIST_ENTRY ModuleListHead
    );

//
// Crash dump only
// Called to initialize the kernel memory for a kernel
// memory dump.
//

typedef
NTSTATUS
(*PMM_SET_DUMP_RANGE) (
    IN struct _MM_KERNEL_DUMP_CONTEXT* Context,
    IN PVOID StartVa,
    IN PFN_NUMBER Pages,
    IN ULONG AddressFlags
    );

typedef
NTSTATUS
(*PMM_FREE_DUMP_RANGE) (
    IN struct _MM_KERNEL_DUMP_CONTEXT* Context,
    IN PVOID StartVa,
    IN PFN_NUMBER Pages,
    IN ULONG AddressFlags
    );

typedef struct _MM_KERNEL_DUMP_CONTEXT {
    PVOID Context;
    PMM_SET_DUMP_RANGE SetDumpRange;
    PMM_FREE_DUMP_RANGE FreeDumpRange;
} MM_KERNEL_DUMP_CONTEXT, *PMM_KERNEL_DUMP_CONTEXT;


VOID
MmGetKernelDumpRange (
    IN PMM_KERNEL_DUMP_CONTEXT Callback
    );

// begin_ntifs

//
// Prefetch public interface.
//

typedef struct _READ_LIST {
    PFILE_OBJECT FileObject;
    ULONG NumberOfEntries;
    LOGICAL IsImage;
    FILE_SEGMENT_ELEMENT List[ANYSIZE_ARRAY];
} READ_LIST, *PREAD_LIST;

NTSTATUS
MmPrefetchPages (
    IN ULONG NumberOfLists,
    IN PREAD_LIST *ReadLists
    );

// end_ntifs

NTSTATUS
MmPrefetchPagesIntoLockedMdl (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN SIZE_T Length,
    OUT PMDL *MdlOut
    );

LOGICAL
MmIsMemoryAvailable (
    IN PFN_NUMBER PagesDesired
    );

NTSTATUS
MmIdentifyPhysicalMemory (
    VOID
    );

PFILE_OBJECT *
MmPerfUnusedSegmentsEnumerate (
    VOID
    );

NTSTATUS
MmPerfSnapShotValidPhysicalMemory (
    VOID
    );

PFILE_OBJECT *
MmPerfVadTreeWalk (
    PEPROCESS Process
    );

#endif  // MM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ncr53c94.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ncr53C94.h

Abstract:

    The module defines the structures, defines and functions for the NCR 53C94
    host bus adapter chip.

Author:

    Jeff Havens  (jhavens) 28-Feb-1991

Revision History:

    R.D. Lanser  (DEC)     05-Oct-1991
        Copied SCSI_REGISTER structure from d3scsidd.c and added check for
        DECSTATION.  Changed the UCHAR's in the read/write register structures
        with SCSI_REGISTER, and added the dot Byte member reference to
        SCSI_WRITE and SCSI_READ macros.



--*/

#ifndef _NCR53C94_
#define _NCR53C94_


//
// Define SCSI Protocol Chip register format.
//

#if defined(DECSTATION)

typedef struct _SCSI_REGISTER {
    UCHAR Byte;
    UCHAR Fill[3];
} SCSI_REGISTER, *PSCSI_REGISTER;

#else

#define SCSI_REGISTER UCHAR

#endif // DECSTATION

//
// SCSI Protocol Chip Definitions.
//
// Define SCSI Protocol Chip Read registers structure.
//

typedef struct _SCSI_READ_REGISTERS {
    SCSI_REGISTER TransferCountLow;
    SCSI_REGISTER TransferCountHigh;
    SCSI_REGISTER Fifo;
    SCSI_REGISTER Command;
    SCSI_REGISTER ScsiStatus;
    SCSI_REGISTER ScsiInterrupt;
    SCSI_REGISTER SequenceStep;
    SCSI_REGISTER FifoFlags;
    SCSI_REGISTER Configuration1;
    SCSI_REGISTER Reserved1;
    SCSI_REGISTER Reserved2;
    SCSI_REGISTER Configuration2;
    SCSI_REGISTER Configuration3;
    SCSI_REGISTER Reserved;
    SCSI_REGISTER TransferCountPage;
    SCSI_REGISTER FifoBottem;
} SCSI_READ_REGISTERS, *PSCSI_READ_REGISTERS;

//
// Define SCSI Protocol Chip Write registers structure.
//

typedef struct _SCSI_WRITE_REGISTERS {
    SCSI_REGISTER TransferCountLow;
    SCSI_REGISTER TransferCountHigh;
    SCSI_REGISTER Fifo;
    SCSI_REGISTER Command;
    SCSI_REGISTER DestinationId;
    SCSI_REGISTER SelectTimeOut;
    SCSI_REGISTER SynchronousPeriod;
    SCSI_REGISTER SynchronousOffset;
    SCSI_REGISTER Configuration1;
    SCSI_REGISTER ClockConversionFactor;
    SCSI_REGISTER TestMode;
    SCSI_REGISTER Configuration2;
    SCSI_REGISTER Configuration3;
    SCSI_REGISTER Reserved;
    SCSI_REGISTER TransferCountPage;
    SCSI_REGISTER FifoBottem;
} SCSI_WRITE_REGISTERS, *PSCSI_WRITE_REGISTERS;

typedef union _SCSI_REGISTERS {
    SCSI_READ_REGISTERS  ReadRegisters;
    SCSI_WRITE_REGISTERS WriteRegisters;
} SCSI_REGISTERS, *PSCSI_REGISTERS;

//
// Define SCSI Command Codes.
//

#define NO_OPERATION_DMA 0x80
#define FLUSH_FIFO 0x1
#define RESET_SCSI_CHIP 0x2
#define RESET_SCSI_BUS 0x3
#define TRANSFER_INFORMATION 0x10
#define TRANSFER_INFORMATION_DMA 0x90
#define COMMAND_COMPLETE 0x11
#define MESSAGE_ACCEPTED 0x12
#define TRANSFER_PAD 0x18
#define SET_ATTENTION 0x1a
#define RESET_ATTENTION 0x1b
#define RESELECT 0x40
#define SELECT_WITHOUT_ATTENTION 0x41
#define SELECT_WITH_ATTENTION 0x42
#define SELECT_WITH_ATTENTION_STOP 0x43
#define ENABLE_SELECTION_RESELECTION 0x44
#define DISABLE_SELECTION_RESELECTION 0x45
#define SELECT_WITH_ATTENTION3 0x46

//
// Define SCSI Status Register structure.
//
typedef struct _SCSI_STATUS {
    UCHAR Phase : 3;
    UCHAR ValidGroup : 1;
    UCHAR TerminalCount : 1;
    UCHAR ParityError : 1;
    UCHAR GrossError : 1;
    UCHAR Interrupt : 1;
} SCSI_STATUS, *PSCSI_STATUS;

//
// Define SCSI Phase Codes.
//

#define DATA_OUT 0x0
#define DATA_IN 0x1
#define COMMAND_OUT 0x2
#define STATUS_IN 0x3
#define MESSAGE_OUT 0x6
#define MESSAGE_IN 0x7

//
// Define SCSI Interrupt Register structure.
//

typedef struct _SCSI_INTERRUPT {
    UCHAR Selected : 1;
    UCHAR SelectedWithAttention : 1;
    UCHAR Reselected : 1;
    UCHAR FunctionComplete : 1;
    UCHAR BusService : 1;
    UCHAR Disconnect : 1;
    UCHAR IllegalCommand : 1;
    UCHAR ScsiReset : 1;
} SCSI_INTERRUPT, *PSCSI_INTERRUPT;

//
// Define SCSI Sequence Step Register structure.
//

typedef struct _SCSI_SEQUENCE_STEP {
    UCHAR Step : 3;
    UCHAR MaximumOffset : 1;
    UCHAR Reserved : 4;
} SCSI_SEQUENCE_STEP, *PSCSI_SEQUENCE_STEP;

//
// Define SCSI Fifo Flags Register structure.
//

typedef struct _SCSI_FIFO_FLAGS {
    UCHAR ByteCount : 5;
    UCHAR FifoStep : 3;
} SCSI_FIFO_FLAGS, *PSCSI_FIFO_FLAGS;

//
// Define SCSI Configuration 1 Register structure.
//

typedef struct _SCSI_CONFIGURATION1 {
    UCHAR HostBusId : 3;
    UCHAR ChipTestEnable : 1;
    UCHAR ParityEnable : 1;
    UCHAR ParityTestMode : 1;
    UCHAR ResetInterruptDisable : 1;
    UCHAR SlowCableMode : 1;
} SCSI_CONFIGURATION1, *PSCSI_CONFIGURATION1;

//
// Define SCSI Configuration 2 Register structure.
//

typedef struct _SCSI_CONFIGURATION2 {
    UCHAR DmaParityEnable : 1;
    UCHAR RegisterParityEnable : 1;
    UCHAR TargetBadParityAbort : 1;
    UCHAR Scsi2 : 1;
    UCHAR HighImpedance : 1;
    UCHAR EnableByteControl : 1;
    UCHAR EnablePhaseLatch : 1;
    UCHAR ReserveFifoByte : 1;
} SCSI_CONFIGURATION2, *PSCSI_CONFIGURATION2;

//
// Define SCSI Configuration 3 Register structure.
//

typedef struct _SCSI_CONFIGURATION3 {
    UCHAR Threshold8 : 1;
    UCHAR AlternateDmaMode : 1;
    UCHAR SaveResidualByte : 1;
    UCHAR FastClock : 1;
    UCHAR FastScsi : 1;
    UCHAR EnableCdb10 : 1;
    UCHAR EnableQueue : 1;
    UCHAR CheckIdMessage : 1;
} SCSI_CONFIGURATION3, *PSCSI_CONFIGURATION3;

//
// Define Emulex FAS 218 unique part Id code.
//

typedef struct _NCR_PART_CODE {
    UCHAR RevisionLevel : 3;
    UCHAR ChipFamily : 5;
}NCR_PART_CODE, *PNCR_PART_CODE;

#define EMULEX_FAS_216 2

//
// SCSI Protocol Chip Control read and write macros.
//

#if defined(DECSTATION)

#define SCSI_READ(ChipAddr, Register) \
    (READ_REGISTER_UCHAR (&((ChipAddr)->ReadRegisters.Register.Byte)))

#define SCSI_WRITE(ChipAddr, Register, Value) \
    WRITE_REGISTER_UCHAR(&((ChipAddr)->WriteRegisters.Register.Byte), (Value))

#else

#define SCSI_READ(ChipAddr, Register) \
    (READ_REGISTER_UCHAR (&((ChipAddr)->ReadRegisters.Register)))

#define SCSI_WRITE(ChipAddr, Register, Value) \
    WRITE_REGISTER_UCHAR(&((ChipAddr)->WriteRegisters.Register), (Value))

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\nic1394.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	nic1394.h

Abstract:

	This module defines the structures, macros, and manifests available
	to IEE1394-aware network components.

Revision History:

	09/14/1998 JosephJ	Created.

--*/

#ifndef	_NIC1394_H_
#define	_NIC1394_H_

///////////////////////////////////////////////////////////////////////////////////
//         					ADDRESS FAMILY VERSION INFORMATION
///////////////////////////////////////////////////////////////////////////////////

//
// The current major and minor version, respectively, of the NIC1394 address family.
//
#define NIC1394_AF_CURRENT_MAJOR_VERSION	5
#define NIC1394_AF_CURRENT_MINOR_VERSION	0

///////////////////////////////////////////////////////////////////////////////////
//         					MEDIA PARAMETERS 									 // 
///////////////////////////////////////////////////////////////////////////////////

//
// 1394 FIFO Address, consisting of the 64-bit UniqueID and the
// 48-bit address offset.
//
typedef struct _NIC1394_FIFO_ADDRESS
{
	UINT64 				UniqueID;
	ULONG           	Off_Low;
	USHORT          	Off_High;

} NIC1394_FIFO_ADDRESS, *PNIC1394_FIFO_ADDRESS;


//	enum to identify which of the two modes of transmission on a 1394 is to be used
//
//

typedef enum _NIC1394_ADDRESS_TYPE
{
	NIC1394AddressType_Channel,		 // Indicates this is a channel address
	NIC1394AddressType_FIFO,		 // Indicates this is a FIFO address

} NIC1394_ADDRESS_TYPE, *PNIC1394_ADDRESS_TYPE;



//
// General form of a 1394 destination, which can specify either a 1394 channel or
// a FIFO address. This structure forms part of the 1394 media-specific
// parameters.
//
typedef struct _NIC1394_DESTINATION
{
	union
	{
		UINT                    Channel;     // IEEE1394 channel number.
		NIC1394_FIFO_ADDRESS    FifoAddress; // IEEE1394 NodeID and address offset.
	};


	NIC1394_ADDRESS_TYPE        AddressType; // Address- asynch or isoch  

} NIC1394_DESTINATION, *PNIC1394_DESTINATION;

//
// Special channels  values
//
#define NIC1394_ANY_CHANNEL 		((UINT)-1) // miniport should pick channel.
#define NIC1394_BROADCAST_CHANNEL	((UINT)-2) // special broadcast channel.

//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains IEEE1394 media specific values in the
// structure NIC1394_MEDIA_PARAMETERS.
//
#define NIC1394_MEDIA_SPECIFIC		0x13940000


//
// NOTE:
// The CO_MEDIA_PARAMETERS.Flags field for FIFO vcs must specify either TRANSMIT_VC
// or RECEIVE_VC, not both. If RECEIVE_VC is specified for a FIFO vc, this vc is
// used to receive on a local FIFO. In this case, the  Destination.RecvFIFO field
// must be set to all-0s when creating the vc. On activation of the vc,
// this field of the updated media parameters will contain the local nodes unique ID
// and the allocated FIFO address.
// 

// 
// 1394 Specific Media parameters - this is the Media specific structure for 1394
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _NIC1394_MEDIA_PARAMETERS
{
	//
	// Identifies destination type (channel or FIFO) and type-specific address.
	//
	NIC1394_DESTINATION 	Destination;

	//
	// Bitmap encoding characteristics of the vc. One or  more NIC1394_VCFLAG_*
	// values.
	//
	ULONG					Flags;  	  	

 	//
	// Maximum size, in bytes, of blocks to be sent on this vc. Must be set to 0
	// if this is a recv-only VCs. The miniport will choose a block size that is a
	// minimum of this value and the value dictated by the bus speed map.
	// Special value (ULONG -1) indicates "maximum possible block size."
	UINT 					MaxSendBlockSize;

	//
	// One of the SCODE_* constants defined in 1394.h. Indicates
	// the maximum speed to be used for blocks sent on this vc. Must be set to 0
	// if this is a recv-only VC. The miniport will choose a speed that is a minimum
	// of this value and the value dicated by the bus speed map.
	// Special value (ULONG -1) indicates "maximum possible speed."
	//
	// TODO: change to ... MaxSendSpeedCode;
	//
	UINT 					MaxSendSpeed;

	//
	// Size, in bytes, of the largest packet that will be sent or received on
	// this VC. The miniport may use this information to set up internal buffers
	// for link-layer fragmentation and reassembly. The miniport will
	// fail attempts to send packets and will discard received packets if the
	// size of these packets is larger than the MTU.
	//
	UINT					MTU;
	//
 	// Amount of bandwidth to reserve, in units of bytes per isochronous frame.
	// Applies only for isochronous transmission, and must be set to 0 for
	// asynchronous transmission (i.e., if the NIC1394_VCFLAG_ISOCHRONOUS bit is 0).
	//
	UINT 					Bandwidth;	

	//
	// One or more NIC1394_FRAMETYPE_* values. The miniport will attempt to send up
	// only pkts with these protocols. However it may send other pkts.
	// The client should be able to deal with this. Must be set to 0 if
	// no framing is used (i.e., if the NIC1394_VCFLAG_FRAMED bit is 0).
	//
	ULONG 					RecvFrameTypes;

} NIC1394_MEDIA_PARAMETERS, *PNIC1394_MEDIA_PARAMETERS;


//
// NIC1394_MEDIA_PARAMETERS.Flags bitfield values
//

//
// Indicates VC will be used for isochronous transmission.
//
#define NIC1394_VCFLAG_ISOCHRONOUS		(0x1 << 1)

//
// Indicates that the vc is used for framed data. If set, the miniport will
// implement link-level fragmentation and reassembly. If clear, the miniport
// will treat data sent and received on this vc as raw data.
//
#define NIC1394_VCFLAG_FRAMED			(0x1 << 2)

//
// Indicates the miniport should allocate the necessary bus resources.
// Currently this only applies for non-broadcast channels, in which case
// the bus resources consist of the network channel number and (for isochronous
// vc's) the bandwidth specified in Bandwidth field.
// This bit does not apply (and should be 0) when creating the broadcast channel
// and either transmit or receive FIFO vcs.
//
#define NIC1394_VCFLAG_ALLOCATE			(0x1 << 3)

//
// End of NIC1394_MEDIA_PARAMETERS.Flags bitfield values.
//

//
// NIC1394_MEDIA_PARAMETERS.FrameType bitfield values
//
#define NIC1394_FRAMETYPE_ARP	 	(0x1<<0) // Ethertype 0x806
#define NIC1394_FRAMETYPE_IPV4	 	(0x1<<1) // Ethertype 0x800
#define NIC1394_FRAMETYPE_IPV4MCAP	(0x1<<2) // Ethertype 0x8861



///////////////////////////////////////////////////////////////////////////////////
//                          INFORMATIONAL OIDs                                   // 
///////////////////////////////////////////////////////////////////////////////////

//
// the structure for returning basic information about the miniport
// returned in response to OID_NIC1394_LOCAL_NODE_INFO. Associated with
// the address family handle.
//
typedef struct _NIC1394_LOCAL_NODE_INFO
{
	UINT64					UniqueID;			// This node's 64-bit Unique ID.
	ULONG					BusGeneration;  	// 1394 Bus generation ID.
	NODE_ADDRESS			NodeAddress; 		// Local nodeID for the current bus
												// generation.
	USHORT					Reserved;			// Padding.
	UINT 					MaxRecvBlockSize; 	// Maximum size, in bytes, of blocks
												// that can be read.
	UINT 					MaxRecvSpeed;		// Max speed which can be accepted
												// -- minimum
												// of the max local link speed and
												// the max local PHY speed.

} NIC1394_LOCAL_NODE_INFO, *PNIC1394_LOCAL_NODE_INFO;


//
// The structure for returning basic information about the specified vc
// returned in response to OID_NIC1394_VC_INFO. Associated with
// a vc handle
//
typedef struct _NIC1394_VC_INFO
{
	//
	// Channel or (unique-ID,offset). In the case of a recv (local) FIFO vc,
	// this will be set to the local node's unique ID and address offset.
	//
	NIC1394_DESTINATION Destination;

} NIC1394_VC_INFO, *PNIC1394_VC_INFO;



///////////////////////////////////////////////////////////////////////////////////
//                          INDICATIONS                                          // 
///////////////////////////////////////////////////////////////////////////////////
// Bus Reset
// Params: NIC1394_LOCAL_NODE_INFO

///////////////////////////////////////////////////////////////////////////////////
//                          PACKET FORMATS                                       // 
///////////////////////////////////////////////////////////////////////////////////


//
// GASP Header, which prefixes all ip/1394 pkts sent over channels.
// TODO: move this withing NIC1394, because it is not exposed to protocols.
//
typedef struct _NIC1394_GASP_HEADER
{
	USHORT	source_ID;
	USHORT	specifier_ID_hi;
	UCHAR	specifier_ID_lo;
	UCHAR	version[3];

}  NIC1394_GASP_HEADER;

//
// Unfragmented encapsulation header.
//
typedef struct _NIC1394_ENCAPSULATION_HEADER
{
	// The Reserved field must be set to 0.
	//
	USHORT Reserved;

	// The EtherType field is set to the byte-swapped version of one of the
	// constants defined immediately below. 
	//
	USHORT EtherType;

	// Ethertypes in machine byte order. These values need to be byteswapped
	// before they are sent on the wire.
	//
	#define NIC1394_ETHERTYPE_IP	0x800
	#define NIC1394_ETHERTYPE_ARP	0x806
	#define NIC1394_ETHERTYPE_MCAP	0x8861

} NIC1394_ENCAPSULATION_HEADER, *PNIC1394_ENCAPSULATION_HEADER;

//
// TODO: get rid of NIC1394_ENCAPSULATION_HEADER
//
typedef
NIC1394_ENCAPSULATION_HEADER
NIC1394_UNFRAGMENTED_HEADER, *PNIC1394_UNFRAGMENTED_HEADER;


//
//			FRAGMENTED PACKET FORMATS
//
//		TODO: move these to inside NIC1394, because they are only
//		used within NIC1394.
//

//
// Fragmented Encapsulation header: first fragment
//
typedef struct _NIC1394_FIRST_FRAGMENT_HEADER
{
	// Contains the 2-bit "lf" field and the 12-bit "buffer_size" field.
	// Use the macros immediately below to extract the above fields from
	// the lfbufsz. This field needs to be byteswapped before it is sent out
	// on the wire.
	//
	USHORT	lfbufsz;

	#define NIC1394_LF_FROM_LFBUFSZ(_lfbufsz) \
							((_lfbufz) >> 14)

	#define NIC1394_BUFFER_SIZE_FROM_LFBUFSZ(_lfbufsz) \
							((_lfbufz) & 0xfff)

	#define NIC1394_MAX_FRAGMENT_BUFFER_SIZE	0xfff

	//
	// specifies what the packet is - an IPV4, ARP, or MCAP packet
	//
	USHORT EtherType;


	// Opaque datagram label. There is no need to byteswap this field before it
	// is sent out on the wire.
	//
	USHORT dgl;

	// Must be set to 0
	//
	USHORT reserved;

}  NIC1394_FIRST_FRAGMENT_HEADER, *PNIC1394_FIRST_FRAGMENT_HEADER;

//
// Fragmented Encapsulation header: second and subsequent fragments
//
typedef struct _NIC1394_FRAGMENT_HEADER
{
#if OBSOLETE
	ULONG lf:2;                         // Bits 0-1
	ULONG rsv0:2;                       // Bits 2-3
	ULONG buffer_size:12;               // Bits 4-15

	ULONG rsv1:4;                       // Bits 16-19
	ULONG fragment_offset:12;           // Bits 20-31

	ULONG dgl:16;                       // Bits 0-15

	ULONG reserved:16;                 	// Bits 16-32 
#endif // OBSOLETE

	// Contains the 2-bit "lf" field and the 12-bit "buffer_size" field.
	// The format is the same as NIC1394_FIRST_FRAGMENT_HEADER.lfbufsz.
	//
	USHORT	lfbufsz;

	// Opaque datagram label. There is no need to byteswap this field before it
	// is setn out on the wire.
	//
	USHORT dgl;

	// Fragment offset. Must be less than or equal to NIC1394_MAX_FRAGMENT_OFFSET.
	// This field needs to be byteswapped before it is sent out on the wire.
	//
	USHORT fragment_offset;

	#define NIC1394_MAX_FRAGMENT_OFFSET 0xfff

}  NIC1394_FRAGMENT_HEADER, *PNIC1394_FRAGMENT_HEADER;





#define OID_1394_ISSUE_BUS_RESET		0x0C010201

#endif	//	 _NIC1394_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\nec98.h ===
/*++

Copyright (c) 1994  NEC Corporation
Copyright (c) 1994  NEC Software, Ltd.

Module Name:

    nec98.h (cf. eisa.h)

Abstract:

    The module defines the structures, and defines  for the NEC PC98 chip set.

Author:

    Michio Nakamura        20-Sep-1994

Revision History:

    Takaaki Tochizawa      13-Mar-1998 Add 2nd DMA for FIR.

--*/

#ifndef _EISA_
#define _EISA_

//
// Define the DMA page register structure.
//

#define DMA_BANK_A31_A24_DR0   0xe05
#define DMA_BANK_A31_A24_DR1   0xe07
#define DMA_BANK_A31_A24_DR2   0xe09
#define DMA_BANK_A31_A24_DR3   0xe0b
#define DMA_INC_ENABLE_A31_A24 0xe0f

//
// Define the DMA 2 page register structure.
//

#define DMA2_BANK_A31_A24_DR5   0xf07
#define DMA2_BANK_A31_A24_DR6   0xf09
#define DMA2_BANK_A31_A24_DR7   0xf0b
#define DMA2_INC_ENABLE_A31_A24 0xf0f

//
// Define the DMA 2 mode change register
//
#define DMA2_MODE_CHANGE      0xf4
#define DMA2_MODE_8237_COMP   0x0
#define DMA2_MODE_71037_A     0x1
#define DMA2_MODE_71037_B     0x2
#define DMA2_MODE_71037_C     0x3

#define DMA_STATUS 0xc8
#define DMA_COMMAND 0xc8
#define SINGLE_MASK 0xca
#define MODE 0xcb
#define CLEAR_BYTE_POINTER 0xcc
#define CLEAR_MASK 0xce

typedef struct _DMA_PAGE{
    UCHAR Reserved1;            // offset 0x20
    UCHAR Channel1;             // offset 0x21
    UCHAR Reserved2;
    UCHAR Channel2;             // offset 0x23
    UCHAR Reserved3;
    UCHAR Channel3;             // offset 0x25
    UCHAR Reserved4;
    UCHAR Channel0;             // offset 0x27
    UCHAR Reserved5[0x120-0x27];// offset 0x120
    UCHAR Channel5;             // offset 0x121
    UCHAR Reserved6;
    UCHAR Channel6;             // offset 0x123
    UCHAR Reserved7;
    UCHAR Channel7;             // offset 0x125
    UCHAR Reserved8[4];
}DMA_PAGE, *PDMA_PAGE;

//
// Define the DMA stop register structure.
//

typedef struct _DMA_CHANNEL_STOP {
    UCHAR ChannelLsb;
    UCHAR ChannelMsb;
    UCHAR ChannelHsb;
    UCHAR Reserved;
}DMA_CHANNEL_STOP, *PDMA_CHANNEL_STOP;

//
// Define DMA 1 address and count structure.
//

typedef struct _DMA1_ADDRESS_COUNT {
    UCHAR Reserved1;
    UCHAR DmaBaseAddress;
    UCHAR Reserved2;
    UCHAR DmaBaseCount;
}DMA1_ADDRESS_COUNT, *PDMA1_ADDRESS_COUNT;


//
// Define DMA 2 address and count structure.
//

typedef struct _DMA2_ADDRESS_COUNT {
    UCHAR Reserved1;
    UCHAR DmaBaseAddress;
    UCHAR Reserved2;
    UCHAR DmaBaseCount;
}DMA2_ADDRESS_COUNT, *PDMA2_ADDRESS_COUNT;

//
// Define DMA 1 control register structure.
//

typedef struct _DMA1_CONTROL {
    DMA1_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR Reserved1;
    UCHAR DmaStatus;            //offset 0x11
    UCHAR Reserved2;
    UCHAR DmaRequest;           //offset 0x13
    UCHAR Reserved3;
    UCHAR SingleMask;           //offset 0x15
    UCHAR Reserved4;
    UCHAR Mode;                 //offset 0x17
    UCHAR Reserved5;
    UCHAR ClearBytePointer;     //offset 0x19
    UCHAR Reserved6;
    UCHAR MasterClear;          //offset 0x1b
    UCHAR Reserved7;
    UCHAR ClearMask;            //offset 0x1d
    UCHAR Reserved;
    UCHAR AllMask;              //offset 0x1f
}DMA1_CONTROL, *PDMA1_CONTROL;

//
// Define DMA 2 control register structure.
//

typedef struct _DMA2_CONTROL {
    UCHAR Reserved8[0x100-0x20];//offset 0x20
    DMA2_ADDRESS_COUNT DmaAddressCount[4]; //offset 0x100
    UCHAR Reserved1;
    UCHAR DmaStatus;            //offset 0x111
    UCHAR Reserved2;
    UCHAR DmaRequest;           //offset 0x113
    UCHAR Reserved3;
    UCHAR SingleMask;           //offset 0x115
    UCHAR Reserved4;
    UCHAR Mode;                 //offset 0x117
    UCHAR Reserved5;
    UCHAR ClearBytePointer;     //offset 0x119
    UCHAR Reserved6;
    UCHAR MasterClear;          //offset 0x11b
    UCHAR Reserved7;
    UCHAR ClearMask;            //offset 0x11d
    UCHAR Reserved;
    UCHAR AllMask;              //offset 0x11f
    UCHAR Reserved9[10];        //offset 0x120
}DMA2_CONTROL, *PDMA2_CONTROL;

//
// Define Timer control register structure.
//

typedef struct _TIMER_CONTROL {
    UCHAR BcdMode : 1;
    UCHAR Mode : 3;
    UCHAR SelectByte : 2;
    UCHAR SelectCounter : 2;
}TIMER_CONTROL, *PTIMER_CONTROL;

//
// Define Timer status register structure.
//

typedef struct _TIMER_STATUS {
    UCHAR BcdMode : 1;
    UCHAR Mode : 3;
    UCHAR SelectByte : 2;
    UCHAR CrContentsMoved : 1;
    UCHAR OutPin : 1;
}TIMER_STATUS, *PTIMER_STATUS;

//
// Define Mode values.
//

#define TM_SIGNAL_END_OF_COUNT  0
#define TM_ONE_SHOT             1
#define TM_RATE_GENERATOR       2
#define TM_SQUARE_WAVE          3
#define TM_SOFTWARE_STROBE      4
#define TM_HARDWARE_STROBE      5

//
// Define SelectByte values
//

#define SB_COUNTER_LATCH        0
#define SB_LSB_BYTE             1
#define SB_MSB_BYTE             2
#define SB_LSB_THEN_MSB         3

//
// Define SelectCounter values.
//

#define SELECT_COUNTER_0        0
#define SELECT_COUNTER_1        1
#define SELECT_COUNTER_2        2
#define SELECT_READ_BACK        3

//
// Define Timer clock for speaker.
//

#define TIMER_CLOCK_IN  1193167     // 1.193Mhz

//
// Define NMI Status/Control register structure.
//

typedef struct _NMI_STATUS {
    UCHAR SpeakerGate : 1;
    UCHAR SpeakerData : 1;
    UCHAR DisableEisaParity : 1;
    UCHAR DisableNmi : 1;
    UCHAR RefreshToggle : 1;
    UCHAR SpeakerTimer : 1;
    UCHAR IochkNmi : 1;
    UCHAR ParityNmi : 1;
}NMI_STATUS, *PNMI_STATUS;

//
// Define NMI Enable register structure.
//

typedef struct _NMI_ENABLE {
   UCHAR RtClockAddress : 7;
   UCHAR NmiDisable : 1;
}NMI_ENABLE, *PNMI_ENABLE;
//
// Define the NMI extended status and control register structure.
//

typedef struct _NMI_EXTENDED_CONTROL {
    UCHAR BusReset : 1;
    UCHAR EnableNmiPort : 1;
    UCHAR EnableFailSafeNmi : 1;
    UCHAR EnableBusMasterTimeout : 1;
    UCHAR Reserved1 : 1;
    UCHAR PendingPortNmi : 1;
    UCHAR PendingBusMasterTimeout : 1;
    UCHAR PendingFailSafeNmi : 1;
}NMI_EXTENDED_CONTROL, *PNMI_EXTENDED_CONTROL;

//
// Define 82357 register structure.
//

typedef struct _EISA_CONTROL {
    union   {
        DMA1_CONTROL Dma1BasePort;          // Offset 0x00
        struct  {
            UCHAR Interrupt1ControlPort0;   // Offset 0x00
            UCHAR Reserved1;
            UCHAR Interrupt1ControlPort1;   // Offset 0x02
            UCHAR Reserved2[5];
            UCHAR Interrupt2ControlPort0;   // Offset 0x08
            UCHAR Reserved3;
            UCHAR Interrupt2ControlPort1;   // Offset 0x0A
            UCHAR Reserved4[sizeof(DMA1_CONTROL)-11];

        };
    };
    union {
        DMA_PAGE DmaPageLowPort;                    // Offset 0x20
        DMA2_CONTROL Dma2BasePort;                  // Offset 0x20
        struct {
            UCHAR Reserved20[9];                    // Offset 0x20
            UCHAR PageIncrementMode;                // Offset 0x29
            UCHAR Reserved21;
            UCHAR InDirectAddress;                  // Offset 0x2b
            UCHAR Reserved22;
            UCHAR InDirectData;                     // Offset 0x2d
            UCHAR Reserved23[0x7f - 0x2e];
            UCHAR PageIncrementMode2;               // Offset 0x7f
            UCHAR Reserved24[0x129 - 0x80];
            UCHAR DMA2PageIncrementMode;            // Offset 0x129
        };
    };
    UCHAR Reserved25[0xfffc - 0x130];               // Offset 0x130
    //
    // No NEC PC98 have 2nd DMA controller. But PC/AT has one. Therefore there are some valuable
    // refer to 2nd DMA in ixisasup.c.
    // I add it following valuable so that HAL builds. HAL of NEC PC98 doesn't use it.
    //
    UCHAR Dma1ExtendedModePort;
    UCHAR Dma2ExtendedModePort;
    UCHAR DmaPageHighPort;
    UCHAR Interrupt1EdgeLevel;
    UCHAR Interrupt2EdgeLevel;

} EISA_CONTROL, *PEISA_CONTROL;

//
// Define initialization command word 1 structure.
//

typedef struct _INITIALIZATION_COMMAND_1 {
    UCHAR Icw4Needed : 1;
    UCHAR CascadeMode : 1;
    UCHAR Unused1 : 2;
    UCHAR InitializationFlag : 1;
    UCHAR Unused2 : 3;
}INITIALIZATION_COMMAND_1, *PINITIALIZATION_COMMAND_1;

//
// Define initialization command word 4 structure.
//

typedef struct _INITIALIZATION_COMMAND_4 {
    UCHAR I80x86Mode : 1;
    UCHAR AutoEndOfInterruptMode : 1;
    UCHAR Unused1 : 2;
    UCHAR SpecialFullyNested : 1;
    UCHAR Unused2 : 3;
}INITIALIZATION_COMMAND_4, *PINITIALIZATION_COMMAND_4;

//
// Define EISA interrupt controller operational command values.
// Define operation control word 2 commands.
//

#define NONSPECIFIC_END_OF_INTERRUPT 0x20
#define SPECIFIC_END_OF_INTERRUPT    0x60

//
// Define external EISA interupts
//

#define EISA_EXTERNAL_INTERRUPTS_1  0xf8
#define EISA_EXTERNAL_INTERRUPTS_2  0xbe

//
// Define the DMA mode register structure.
//

typedef struct _DMA_EISA_MODE {
    UCHAR Channel : 2;
    UCHAR TransferType : 2;
    UCHAR AutoInitialize : 1;
    UCHAR AddressDecrement : 1;
    UCHAR RequestMode : 2;
}DMA_EISA_MODE, *PDMA_EISA_MODE;

//
// Define TransferType values.
//

#define VERIFY_TRANSFER     0x00
#define READ_TRANSFER       0x01        // Read from the device.
#define WRITE_TRANSFER      0x02        // Write to the device.

//
// Define RequestMode values.
//

#define DEMAND_REQUEST_MODE         0x00
#define SINGLE_REQUEST_MODE         0x01
#define BLOCK_REQUEST_MODE          0x02
#define CASCADE_REQUEST_MODE        0x03

//
// Define the DMA extended mode register structure.
//

typedef struct _DMA_EXTENDED_MODE {
    UCHAR ChannelNumber : 2;
    UCHAR TransferSize : 2;
    UCHAR TimingMode : 2;
    UCHAR EndOfPacketInput : 1;
    UCHAR StopRegisterEnabled : 1;
}DMA_EXTENDED_MODE, *PDMA_EXTENDED_MODE;

//
// Define the DMA extended mode register transfer size values.
//

#define BY_BYTE_8_BITS      0
#define BY_WORD_16_BITS     1
#define BY_BYTE_32_BITS     2
#define BY_BYTE_16_BITS     3

//
// Define the DMA extended mode timing mode values.
//

#define COMPATIBLITY_TIMING 0
#define TYPE_A_TIMING       1
#define TYPE_B_TIMING       2
#define BURST_TIMING        3

#ifndef DMA1_COMMAND_STATUS


//
// Define constants used by Intel 8237A DMA chip
//

#define DMA_SETMASK     4
#define DMA_CLEARMASK       0
#define DMA_READ            4  // These two appear backwards, but I think
#define DMA_WRITE           8  // the DMA docs have them mixed up
#define DMA_SINGLE_TRANSFER 0x40
#define DMA_AUTO_INIT       0x10 // Auto initialization mode
#endif


//
// This structure is drive layout and partition information
// for NEC PC-98xx series.
//

typedef struct _PARTITION_INFORMATION_NEC {
    UCHAR PartitionType;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
    ULONG PartitionNumber;
    LARGE_INTEGER IplStartOffset;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    UCHAR BootableFlag;
    UCHAR PartitionName[16];
} PARTITION_INFORMATION_NEC, *PPARTITION_INFORMATION_NEC;

typedef struct _DRIVE_LAYOUT_INFORMATION_NEC {
    ULONG PartitionCount;
    ULONG Signature;
    UCHAR BootRecordNec[8];
    PARTITION_INFORMATION_NEC PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION_NEC, *PDRIVE_LAYOUT_INFORMATION_NEC;

//
// The system has memory over 16MB ?
//
extern UCHAR Over16MBMemoryFlag;

//
// We can't use DMA between 15MB and 16MB.
//
#define NOTDMA_MINIMUM_PHYSICAL_ADDRESS 0x0f00000

//
//
//
VOID
FASTCALL
xHalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

VOID
FASTCALL
xHalIoAssignDriveLetters(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

NTSTATUS
FASTCALL
xHalIoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

NTSTATUS
FASTCALL
xHalIoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTSTATUS
FASTCALL
xHalIoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

#endif //_EISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ntos.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntos.h

Abstract:

    Top level include file for the NTOS component.

Author:

    Steve Wood (stevewo) 28-Feb-1989


Revision History:

--*/

#ifndef _NTOS_
#define _NTOS_

#include <nt.h>
#include <ntrtl.h>
#include "ntosdef.h"
#include "exlevels.h"
#include "exboosts.h"
#include "bugcodes.h"
#include "init.h"
#include "v86emul.h"
#include "procpowr.h"

#if defined(_AMD64_)
#include "amd64.h"

#elif defined(_X86_)
#include "i386.h"

#elif defined(_IA64_)
#include "ia64.h"

#else
#error "no target defined"
#endif // AMD64

#include "intrlk.h"
#include "arc.h"
#include "ke.h"
#include "kd.h"
#include "ex.h"
#include "ps.h"
#include "se.h"
#include "io.h"
#include "ob.h"
#include "mm.h"
#include "lpc.h"
#include "dbgk.h"
#include "lfs.h"
#include "cache.h"
#include "pnp.h"
#include "hal.h"
#include "kx.h"
#include "cm.h"
#include "po.h"
#include "perf.h"
#include "wmi.h"
#include "verifier.h"
#define _NTDDK_

//
// Temp. Until we define a header file for types
// Outside of the kernel these are exported by reference
//

#ifdef _NTDRIVER_
extern POBJECT_TYPE *ExEventPairObjectType;
extern POBJECT_TYPE *PsProcessType;
extern POBJECT_TYPE *PsThreadType;
extern POBJECT_TYPE *PsJobType;
extern POBJECT_TYPE *LpcPortObjectType;
extern POBJECT_TYPE *LpcWaitablePortObjectType;
#else
extern POBJECT_TYPE ExEventPairObjectType;
extern POBJECT_TYPE PsProcessType;
extern POBJECT_TYPE PsThreadType;
extern POBJECT_TYPE PsJobType;
extern POBJECT_TYPE LpcPortObjectType;
extern POBJECT_TYPE LpcWaitablePortObjectType;
#endif // _NTDRIVER

#endif // _NTOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\par1284.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    par1284.h

Abstract:

    This file defines the interface for the 1284 export driver.
    The 1284 export driver will export a 1284 communications interface
    to parallel class drivers.

Author:

    Norbert P. Kusters  9-May-1994

Revision History:

--*/

#ifndef _PAR1284_
#define _PAR1284_

//
// Define the current known 1284 protocols for the parallel port.
//

#define P1284_PROTOCOL_ISA  0   // Centronics with Nibble for reverse.
#define P1284_PROTOCOL_BYTE 1   // Centronics with Byte for reverse.
#define P1284_PROTOCOL_EPP  2   // EPP protocol.
#define P1284_PROTOCOL_ECP  3   // ECP protocol.
#define P1284_NUM_PROTOCOLS 4

//
// Define the interface to the export driver.
//

NTSTATUS
P1284Initialize(
    IN  PUCHAR                      Controller,
    IN  PHYSICAL_ADDRESS            OriginalController,
    IN  BOOLEAN                     UsePICode,
    IN  PPARALLEL_ECP_INFORMATION   EcpInfo,
    OUT PVOID*                      P1284Extension
    );

VOID
P1284Cleanup(
    IN  PVOID   P1284Extension
    );

NTSTATUS
P1284Write(
    IN  PVOID   P1284Extension,
    IN  PVOID   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesTransfered
    );

NTSTATUS
P1284Read(
    IN  PVOID   P1284Extension,
    IN  PVOID   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesTransfered
    );

NTSTATUS
P1284NegotiateProtocol(
    IN  PVOID   P1284Extension,
    OUT PULONG  NegotiatedProtocol
    );

NTSTATUS
P1284SetProtocol(
    IN  PVOID   P1284Extension,
    IN  ULONG   ProtocolNumber,
    IN  BOOLEAN Negotiate
    );

NTSTATUS
P1284QueryDeviceId(
    IN  PVOID   P1284Extension,
    OUT PUCHAR  DeviceIdBuffer,
    IN  ULONG   BufferSize,
    OUT PULONG  DeviceIdSize
    );

#endif // _PAR1284_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ntosdef.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntosdef.h

Abstract:

    Common type definitions for the NTOS component that are private to
    NTOS, but shared between NTOS sub-components.

Author:

    Steve Wood (stevewo) 08-May-1989

Revision History:

--*/

#ifndef _NTOSDEF_
#define _NTOSDEF_

//
// disable these for compiling w4
//
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

// begin_ntosp

//
// Define per processor nonpaged lookaside list descriptor structure.
//

struct _NPAGED_LOOKASIDE_LIST;

typedef struct _PP_LOOKASIDE_LIST {
    struct _GENERAL_LOOKASIDE *P;
    struct _GENERAL_LOOKASIDE *L;
} PP_LOOKASIDE_LIST, *PPP_LOOKASIDE_LIST;

//
// Define the number of small pool lists.
//
// N.B. This value is used in pool.h and is used to allocate single entry
//      lookaside lists in the processor block of each processor.

#define POOL_SMALL_LISTS 32

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
//
// Global flag set by NtPartyByNumber(6) controls behaviour of
// NT.  See \nt\sdk\inc\ntexapi.h for flag definitions
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

// begin_ntndis
//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

// end_ntndis
//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//
//

typedef struct _KAPC {
    CSHORT Type;
    CSHORT Size;
    ULONG Spare0;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is of medium or high importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of high importance, then a DPC interrupt is requested on the
// target processor and the DPC will be processed when the interrupt occurs.
// Otherwise, the DPC execution will be delayed on the target processor until
// the DPC queue depth on the target processor is greater that the maximum
// target depth or the minimum DPC rate on the target processor is less than
// the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed whne the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Define DPC type indicies.
//

#define DPC_NORMAL 0
#define DPC_THREADED 1

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PVOID DpcData;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

// end_ntddk end_wdm end_ntifs end_ntosp end_ntndis

#if defined(NT_UP)

#define HOT_STATISTIC(a) a

#else

#define HOT_STATISTIC(a) (KeGetCurrentPrcb()->a)

#endif

// begin_ntddk begin_wdm begin_ntifs begin_ntosp begin_ntndis

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.
//
// One simply calculates the base of the array by adding one to the base
// MDL pointer:
//
//      Pages = (PPFN_NUMBER) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//


typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_DESCRIBES_AWE           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    { if (KeGetCurrentIrql() > APC_LEVEL) { \
          KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
          ASSERT(FALSE); \
       } \
    }
#else
#define PAGED_CODE() NOP_FUNCTION;
#endif

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp


// begin_ntifs begin_ntosp
//
// Data structure used to represent client security context for a thread.
// This data structure is used to support impersonation.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_CLIENT_CONTEXT {
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_TOKEN ClientToken;
    BOOLEAN DirectlyAccessClientToken;
    BOOLEAN DirectAccessEffectiveOnly;
    BOOLEAN ServerIsRemote;
    TOKEN_CONTROL ClientTokenControl;
    } SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

//
// where
//
//    SecurityQos - is the security quality of service information in effect
//        for this client.  This information is used when directly accessing
//        the client's token.  In this case, the information here over-rides
//        the information in the client's token.  If a copy of the client's
//        token is requested, it must be generated using this information,
//        not the information in the client's token.  In all cases, this
//        information may not provide greater access than the information
//        in the client's token.  In particular, if the client's token is
//        an impersonation token with an impersonation level of
//        "SecurityDelegation", but the information in this field indicates
//        an impersonation level of "SecurityIdentification", then
//        the server may only get a copy of the token with an Identification
//        level of impersonation.
//
//    ClientToken - If the DirectlyAccessClientToken field is FALSE,
//        then this field contains a pointer to a duplicate of the
//        client's token.  Otherwise, this field points directly to
//        the client's token.
//
//    DirectlyAccessClientToken - This boolean flag indicates whether the
//        token pointed to by ClientToken is a copy of the client's token
//        or is a direct reference to the client's token.  A value of TRUE
//        indicates the client's token is directly accessed, FALSE indicates
//        a copy has been made.
//
//    DirectAccessEffectiveOnly - This boolean flag indicates whether the
//        the disabled portions of the token that is currently directly
//        referenced may be enabled.  This field is only valid if the
//        DirectlyAccessClientToken field is TRUE.  In that case, this
//        value supersedes the EffectiveOnly value in the SecurityQos
//        FOR THE CURRENT TOKEN ONLY!  If the client changes to impersonate
//        another client, this value may change.  This value is always
//        minimized by the EffectiveOnly flag in the SecurityQos field.
//
//    ServerIsRemote - If TRUE indicates that the server of the client's
//        request is remote.  This is used for determining the legitimacy
//        of certain levels of impersonation and to determine how to
//        track context.
//
//    ClientTokenControl - If the ServerIsRemote flag is TRUE, and the
//        tracking mode is DYNAMIC, then this field contains a copy of
//        the TOKEN_SOURCE from the client's token to assist in deciding
//        whether the information at the remote server needs to be
//        updated to match the current state of the client's security
//        context.
//
//
//    NOTE: At some point, we may find it worthwhile to keep an array of
//          elements in this data structure, where each element of the
//          array contains {ClientToken, ClientTokenControl} fields.
//          This would allow efficient handling of the case where a client
//          thread was constantly switching between a couple different
//          contexts - presumably impersonating client's of its own.
//
// end_ntifs end_ntosp

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_)) && !defined(_BLDR_)
// begin_ntosp
#if defined(_NTSYSTEM_)

#define NTKERNELAPI

#else

#define NTKERNELAPI DECLSPEC_IMPORT     // wdm ntddk nthal ntndis ntifs

#endif
// end_ntosp
#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.

// begin_ntddk
#if !defined(_NTHAL_) && !defined(_BLDR_)

#define NTHALAPI DECLSPEC_IMPORT            // wdm ntndis ntifs ntosp

#else

#define NTHALAPI                            // nthal

#endif
// end_ntddk

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    union {
        struct {
            UCHAR Type;
            UCHAR Absolute;
            UCHAR Size;
            union {
                UCHAR Inserted;
                BOOLEAN DebugActive;
            };
        };

        volatile LONG Lock;
    };

    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis end_ntosp

#endif // _NTOSDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ob.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ob.h

Abstract:

    This module contains the object manager structure public data
    structures and procedure prototypes to be used within the NT
    system.

Author:

    Steve Wood (stevewo) 28-Mar-1989

Revision History:

--*/

#ifndef _OB_
#define _OB_

//
// System Initialization procedure for OB subcomponent of NTOS
//
BOOLEAN
ObInitSystem( VOID );

VOID
ObShutdownSystem(
    IN ULONG Phase
    );

NTSTATUS
ObInitProcess(
    PEPROCESS ParentProcess OPTIONAL,
    PEPROCESS NewProcess
    );

VOID
ObInitProcess2(
    PEPROCESS NewProcess
    );

VOID
ObKillProcess(
    PEPROCESS Process
    );

VOID
ObClearProcessHandleTable (
    PEPROCESS Process
    );

VOID
ObDereferenceProcessHandleTable (
    PEPROCESS SourceProcess
    );

PHANDLE_TABLE
ObReferenceProcessHandleTable (
    PEPROCESS SourceProcess
    );

ULONG
ObGetProcessHandleCount (
    PEPROCESS Process
    );


NTSTATUS
ObDuplicateObject (
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp begin_ntifs
//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

// end_ntddk end_wdm end_nthal end_ntifs

typedef struct _OBJECT_DUMP_CONTROL {
    PVOID Stream;
    ULONG Detail;
} OB_DUMP_CONTROL, *POB_DUMP_CONTROL;

typedef VOID (*OB_DUMP_METHOD)(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

typedef enum _OB_OPEN_REASON {
    ObCreateHandle,
    ObOpenHandle,
    ObDuplicateHandle,
    ObInheritHandle,
    ObMaxOpenReason
} OB_OPEN_REASON;


typedef NTSTATUS (*OB_OPEN_METHOD)(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    );

typedef BOOLEAN (*OB_OKAYTOCLOSE_METHOD)(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

typedef VOID (*OB_CLOSE_METHOD)(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

typedef VOID (*OB_DELETE_METHOD)(
    IN  PVOID   Object
    );

typedef NTSTATUS (*OB_PARSE_METHOD)(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

typedef NTSTATUS (*OB_SECURITY_METHOD)(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

typedef NTSTATUS (*OB_QUERYNAME_METHOD)(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    );

/*

    A security method and its caller must obey the following w.r.t.
    capturing and probing parameters:

    For a query operation, the caller must pass a kernel space address for
    CapturedLength.  The caller should be able to assume that it points to
    valid data that will not change.  In addition, the SecurityDescriptor
    parameter (which will receive the result of the query operation) must
    be probed for write up to the length given in CapturedLength.  The
    security method itself must always write to the SecurityDescriptor
    buffer in a try clause in case the caller de-allocates it.

    For a set operation, the SecurityDescriptor parameter must have
    been captured via SeCaptureSecurityDescriptor.  This parameter is
    not optional, and therefore may not be NULL.

*/



//
// Prototypes for Win32 WindowStation and Desktop object callout routines
//
typedef struct _WIN32_OPENMETHOD_PARAMETERS {
   OB_OPEN_REASON OpenReason;
   PEPROCESS Process;
   PVOID Object;
   ACCESS_MASK GrantedAccess;
   ULONG HandleCount;
} WIN32_OPENMETHOD_PARAMETERS, *PKWIN32_OPENMETHOD_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_OPENMETHOD_CALLOUT) ( PKWIN32_OPENMETHOD_PARAMETERS );
extern PKWIN32_OPENMETHOD_CALLOUT ExDesktopOpenProcedureCallout;
extern PKWIN32_OPENMETHOD_CALLOUT ExWindowStationOpenProcedureCallout;



typedef struct _WIN32_OKAYTOCLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   HANDLE Handle;
   KPROCESSOR_MODE PreviousMode;
} WIN32_OKAYTOCLOSEMETHOD_PARAMETERS, *PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_OKTOCLOSEMETHOD_CALLOUT) ( PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS );
extern PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExDesktopOkToCloseProcedureCallout;
extern PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExWindowStationOkToCloseProcedureCallout;



typedef struct _WIN32_CLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   ACCESS_MASK GrantedAccess;
   ULONG ProcessHandleCount;
   ULONG SystemHandleCount;
} WIN32_CLOSEMETHOD_PARAMETERS, *PKWIN32_CLOSEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_CLOSEMETHOD_CALLOUT) ( PKWIN32_CLOSEMETHOD_PARAMETERS );
extern PKWIN32_CLOSEMETHOD_CALLOUT ExDesktopCloseProcedureCallout;
extern PKWIN32_CLOSEMETHOD_CALLOUT ExWindowStationCloseProcedureCallout;



typedef struct _WIN32_DELETEMETHOD_PARAMETERS {
   PVOID Object;
} WIN32_DELETEMETHOD_PARAMETERS, *PKWIN32_DELETEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_DELETEMETHOD_CALLOUT) ( PKWIN32_DELETEMETHOD_PARAMETERS );
extern PKWIN32_DELETEMETHOD_CALLOUT ExDesktopDeleteProcedureCallout;
extern PKWIN32_DELETEMETHOD_CALLOUT ExWindowStationDeleteProcedureCallout;


typedef struct _WIN32_PARSEMETHOD_PARAMETERS {
   PVOID ParseObject;
   PVOID ObjectType;
   PACCESS_STATE AccessState;
   KPROCESSOR_MODE AccessMode;
   ULONG Attributes;
   PUNICODE_STRING CompleteName;
   PUNICODE_STRING RemainingName;
   PVOID Context OPTIONAL;
   PSECURITY_QUALITY_OF_SERVICE SecurityQos;
   PVOID *Object;
} WIN32_PARSEMETHOD_PARAMETERS, *PKWIN32_PARSEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_PARSEMETHOD_CALLOUT) ( PKWIN32_PARSEMETHOD_PARAMETERS );
extern PKWIN32_PARSEMETHOD_CALLOUT ExWindowStationParseProcedureCallout;


//
// Object Type Structure
//

typedef struct _OBJECT_TYPE_INITIALIZER {
    USHORT Length;
    BOOLEAN UseDefaultObject;
    BOOLEAN CaseInsensitive;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN MaintainTypeList;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    OB_DUMP_METHOD DumpProcedure;
    OB_OPEN_METHOD OpenProcedure;
    OB_CLOSE_METHOD CloseProcedure;
    OB_DELETE_METHOD DeleteProcedure;
    OB_PARSE_METHOD ParseProcedure;
    OB_SECURITY_METHOD SecurityProcedure;
    OB_QUERYNAME_METHOD QueryNameProcedure;
    OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;

#define OBJECT_LOCK_COUNT 4

typedef struct _OBJECT_TYPE {
    ERESOURCE Mutex;
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;            // Copy from object header for convenience
    PVOID DefaultObject;
    ULONG Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER TypeInfo;
#ifdef POOL_TAGGING
    ULONG Key;
#endif //POOL_TAGGING
    ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];
} OBJECT_TYPE, *POBJECT_TYPE;

//
// Object Directory Structure
//

#define NUMBER_HASH_BUCKETS 37
#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF

typedef struct _OBJECT_DIRECTORY {
    struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[ NUMBER_HASH_BUCKETS ];
    EX_PUSH_LOCK Lock;
    struct _DEVICE_MAP *DeviceMap;
    ULONG SessionId;
#if 0
    USHORT Reserved;
    USHORT SymbolicLinkUsageCount;
#endif
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;
// end_ntosp

//
// Object Directory Entry Structure
//
typedef struct _OBJECT_DIRECTORY_ENTRY {
    struct _OBJECT_DIRECTORY_ENTRY *ChainLink;
    PVOID Object;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;


//
// Symbolic Link Object Structure
//

typedef struct _OBJECT_SYMBOLIC_LINK {
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    UNICODE_STRING LinkTargetRemaining;
    PVOID LinkTargetObject;
    ULONG DosDeviceDriveIndex;  // 1-based index into KUSER_SHARED_DATA.DosDeviceDriveType
} OBJECT_SYMBOLIC_LINK, *POBJECT_SYMBOLIC_LINK;


//
// Device Map Structure
//

typedef struct _DEVICE_MAP {
    POBJECT_DIRECTORY DosDevicesDirectory;
    POBJECT_DIRECTORY GlobalDosDevicesDirectory;
    ULONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[ 32 ];
} DEVICE_MAP, *PDEVICE_MAP;

extern PDEVICE_MAP ObSystemDeviceMap;

//
// Object Handle Count Database
//

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {
    PEPROCESS Process;
    ULONG HandleCount;
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HANDLE_COUNT_DATABASE {
    ULONG CountEntries;
    OBJECT_HANDLE_COUNT_ENTRY HandleCountEntries[ 1 ];
} OBJECT_HANDLE_COUNT_DATABASE, *POBJECT_HANDLE_COUNT_DATABASE;

//
// Object Header Structure
//
// The SecurityQuotaCharged is the amount of quota charged to cover
// the GROUP and DISCRETIONARY ACL fields of the security descriptor
// only.  The OWNER and SYSTEM ACL fields get charged for at a fixed
// rate that may be less than or greater than the amount actually used.
//
// If the object has no security, then the SecurityQuotaCharged and the
// SecurityQuotaInUse fields are set to zero.
//
// Modification of the OWNER and SYSTEM ACL fields should never fail
// due to quota exceeded problems.  Modifications to the GROUP and
// DISCRETIONARY ACL fields may fail due to quota exceeded problems.
//
//


typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    HANDLE RootDirectory;
    PVOID ParseContext;
    KPROCESSOR_MODE ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION;

// begin_ntosp
typedef struct _OBJECT_CREATE_INFORMATION *POBJECT_CREATE_INFORMATION;;

typedef struct _OBJECT_HEADER {
    LONG_PTR PointerCount;
    union {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };
    POBJECT_TYPE Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;

    union {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PSECURITY_DESCRIPTOR SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;
// end_ntosp

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PEPROCESS ExclusiveProcess;
#ifdef _WIN64
    ULONG64  Reserved;   // Win64 requires these structures to be 16 byte aligned.
#endif
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_HANDLE_INFO {
    union {
        POBJECT_HANDLE_COUNT_DATABASE HandleCountDataBase;
        OBJECT_HANDLE_COUNT_ENTRY SingleEntry;
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

// begin_ntosp
typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
#if DBG
    ULONG Reserved2;
    LONG DbgDereferenceCount;
#ifdef _WIN64
    ULONG64  Reserved3;   // Win64 requires these structures to be 16 byte aligned.
#endif
#endif
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;
// end_ntosp

typedef struct _OBJECT_HEADER_CREATOR_INFO {
    LIST_ENTRY TypeList;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Reserved;
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

// begin_ntosp
#define OBJECT_TO_OBJECT_HEADER( o ) \
    CONTAINING_RECORD( (o), OBJECT_HEADER, Body )
// end_ntosp

#define OBJECT_HEADER_TO_EXCLUSIVE_PROCESS( oh ) ((oh->Flags & OB_FLAG_EXCLUSIVE_OBJECT) == 0 ? \
    NULL : (((POBJECT_HEADER_QUOTA_INFO)((PCHAR)(oh) - (oh)->QuotaInfoOffset))->ExclusiveProcess))


#define OBJECT_HEADER_TO_QUOTA_INFO( oh ) ((POBJECT_HEADER_QUOTA_INFO) \
    ((oh)->QuotaInfoOffset == 0 ? NULL : ((PCHAR)(oh) - (oh)->QuotaInfoOffset)))

#define OBJECT_HEADER_TO_HANDLE_INFO( oh ) ((POBJECT_HEADER_HANDLE_INFO) \
    ((oh)->HandleInfoOffset == 0 ? NULL : ((PCHAR)(oh) - (oh)->HandleInfoOffset)))

// begin_ntosp
#define OBJECT_HEADER_TO_NAME_INFO( oh ) ((POBJECT_HEADER_NAME_INFO) \
    ((oh)->NameInfoOffset == 0 ? NULL : ((PCHAR)(oh) - (oh)->NameInfoOffset)))

#define OBJECT_HEADER_TO_CREATOR_INFO( oh ) ((POBJECT_HEADER_CREATOR_INFO) \
    (((oh)->Flags & OB_FLAG_CREATOR_INFO) == 0 ? NULL : ((PCHAR)(oh) - sizeof(OBJECT_HEADER_CREATOR_INFO))))

NTKERNELAPI
NTSTATUS
ObCreateObjectType(
    IN PUNICODE_STRING TypeName,
    IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    OUT POBJECT_TYPE *ObjectType
    );

#define OBJ_PROTECT_CLOSE       0x00000001L

// end_ntosp

VOID
FASTCALL
ObFreeObjectCreateInfoBuffer(
    IN POBJECT_CREATE_INFORMATION ObjectCreateInfo
    );

NTSTATUS
ObSetDirectoryDeviceMap (
    OUT PDEVICE_MAP *ppDeviceMap OPTIONAL,
    IN HANDLE DirectoryHandle
    );

ULONG
ObIsLUIDDeviceMapsEnabled (
    );

ULONG
ObGetSecurityMode (
    );

BOOLEAN
ObIsObjectDeletionInline(
    IN PVOID Object
    );

FORCEINLINE
ULONG
ObSanitizeHandleAttributes (
    IN ULONG HandleAttributes,
    IN KPROCESSOR_MODE Mode
    )
{
    if (Mode == KernelMode) {
        return HandleAttributes & OBJ_VALID_ATTRIBUTES;
    } else {
        return HandleAttributes & (OBJ_VALID_ATTRIBUTES&~OBJ_KERNEL_HANDLE);
    }
}

// begin_nthal

// begin_ntosp

NTKERNELAPI
VOID
ObDeleteCapturedInsertInfo(
    IN PVOID Object
    );


NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN KPROCESSOR_MODE ProbeMode,
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE OwnershipMode,
    IN OUT PVOID ParseContext OPTIONAL,
    IN ULONG ObjectBodySize,
    IN ULONG PagedPoolCharge,
    IN ULONG NonPagedPoolCharge,
    OUT PVOID *Object
    );

//
// These inlines correct an issue where the compiler refetches
// the output object over and over again because it thinks its
// a possible alias for other stores.
//
FORCEINLINE
NTSTATUS
_ObCreateObject(
    IN KPROCESSOR_MODE ProbeMode,
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE OwnershipMode,
    IN OUT PVOID ParseContext OPTIONAL,
    IN ULONG ObjectBodySize,
    IN ULONG PagedPoolCharge,
    IN ULONG NonPagedPoolCharge,
    OUT PVOID *pObject
    )
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObCreateObject (ProbeMode,
                             ObjectType,
                             ObjectAttributes,
                             OwnershipMode,
                             ParseContext,
                             ObjectBodySize,
                             PagedPoolCharge,
                             NonPagedPoolCharge,
                             &Object);
    *pObject = Object;
    return Status;
}

#define ObCreateObject _ObCreateObject


NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PVOID *NewObject OPTIONAL,
    OUT PHANDLE Handle OPTIONAL
    );

// end_nthal

NTKERNELAPI                                                     // ntddk wdm nthal ntifs
NTSTATUS                                                        // ntddk wdm nthal ntifs
ObReferenceObjectByHandle(                                      // ntddk wdm nthal ntifs
    IN HANDLE Handle,                                           // ntddk wdm nthal ntifs
    IN ACCESS_MASK DesiredAccess,                               // ntddk wdm nthal ntifs
    IN POBJECT_TYPE ObjectType OPTIONAL,                        // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE AccessMode,                              // ntddk wdm nthal ntifs
    OUT PVOID *Object,                                          // ntddk wdm nthal ntifs
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   // ntddk wdm nthal ntifs
    );                                                          // ntddk wdm nthal ntifs

FORCEINLINE
NTSTATUS
_ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *pObject,
    OUT POBJECT_HANDLE_INFORMATION pHandleInformation OPTIONAL
    )
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle (Handle,
                                        DesiredAccess,
                                        ObjectType,
                                        AccessMode,
                                        &Object,
                                        pHandleInformation);
    *pObject = Object;
    return Status;
}

#define ObReferenceObjectByHandle _ObReferenceObjectByHandle

NTKERNELAPI
NTSTATUS
ObReferenceFileObjectForWrite(
    IN HANDLE Handle,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *FileObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );


NTKERNELAPI                                                     // ntifs
NTSTATUS                                                        // ntifs
ObOpenObjectByPointer(                                          // ntifs
    IN PVOID Object,                                            // ntifs
    IN ULONG HandleAttributes,                                  // ntifs
    IN PACCESS_STATE PassedAccessState OPTIONAL,                // ntifs
    IN ACCESS_MASK DesiredAccess OPTIONAL,                      // ntifs
    IN POBJECT_TYPE ObjectType OPTIONAL,                        // ntifs
    IN KPROCESSOR_MODE AccessMode,                              // ntifs
    OUT PHANDLE Handle                                          // ntifs
    );                                                          // ntifs

NTSTATUS
ObReferenceObjectByName(
    IN PUNICODE_STRING ObjectName,
    IN ULONG Attributes,
    IN PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );

// end_ntosp

NTKERNELAPI                                                     // ntifs
VOID                                                            // ntifs
ObMakeTemporaryObject(                                          // ntifs
    IN PVOID Object                                             // ntifs
    );                                                          // ntifs

// begin_ntosp

NTKERNELAPI
BOOLEAN
ObFindHandleForObject(
    IN PEPROCESS Process,
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN POBJECT_HANDLE_INFORMATION MatchCriteria OPTIONAL,
    OUT PHANDLE Handle
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
FASTCALL
ObReferenceObjectSafe (
    IN PVOID Object
    );

NTKERNELAPI
LONG_PTR
FASTCALL
ObReferenceObjectEx (
    IN PVOID Object,
    IN ULONG Count
    );

LONG_PTR
FASTCALL
ObDereferenceObjectEx (
    IN PVOID Object,
    IN ULONG Count
    );

NTSTATUS
ObWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

VOID
ObDereferenceObjectDeferDelete (
    IN PVOID Object
    );

// begin_ntifs begin_ntosp
NTKERNELAPI
NTSTATUS
ObQueryNameString(
    IN PVOID Object,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

// end_ntifs end_ntosp

#if DBG
PUNICODE_STRING
ObGetObjectName(
    IN PVOID Object
    );
#endif // DBG

NTSTATUS
ObQueryTypeName(
    IN PVOID Object,
    PUNICODE_STRING ObjectTypeName,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

NTSTATUS
ObQueryTypeInfo(
    IN POBJECT_TYPE ObjectType,
    OUT POBJECT_TYPE_INFORMATION ObjectTypeInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

NTSTATUS
ObDumpObjectByHandle(
    IN HANDLE Handle,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );


NTSTATUS
ObDumpObjectByPointer(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

NTSTATUS
ObSetDeviceMap(
    IN PEPROCESS TargetProcess,
    IN HANDLE DirectoryHandle
    );

NTSTATUS
ObQueryDeviceMapInformation(
    IN PEPROCESS TargetProcess,
    OUT PPROCESS_DEVICEMAP_INFORMATION DeviceMapInformation,
    IN ULONG Flags
    );

VOID
ObInheritDeviceMap(
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess
    );

VOID
ObDereferenceDeviceMap(
    IN PEPROCESS Process
    );

// begin_ntifs begin_ntddk begin_wdm begin_ntosp
NTSTATUS
ObGetObjectSecurity(
    IN PVOID Object,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PBOOLEAN MemoryAllocated
    );

VOID
ObReleaseObjectSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN MemoryAllocated
    );
// end_ntifs end_ntddk end_wdm
NTSTATUS
ObLogSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor,
    ULONG RefBias
    );

VOID
ObDereferenceSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Count
    );

VOID
ObReferenceSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Count
    );

// end_ntosp

NTSTATUS
ObAssignObjectSecurityDescriptor(
    IN PVOID Object,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN POOL_TYPE PoolType
    );

NTSTATUS
ObValidateSecurityQuota(
    IN PVOID Object,
    IN ULONG NewSize
    );

// begin_ntosp
NTKERNELAPI
BOOLEAN
ObCheckCreateObjectAccess(
    IN PVOID DirectoryObject,
    IN ACCESS_MASK CreateAccess,
    IN PACCESS_STATE AccessState OPTIONAL,
    IN PUNICODE_STRING ComponentName,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PNTSTATUS AccessStatus
   );

NTKERNELAPI
BOOLEAN
ObCheckObjectAccess(
    IN PVOID Object,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE AccessMode,
    OUT PNTSTATUS AccessStatus
    );


NTKERNELAPI
NTSTATUS
ObAssignSecurity(
    IN PACCESS_STATE AccessState,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );
// end_ntosp

NTSTATUS                                                        // ntifs
ObQueryObjectAuditingByHandle(                                  // ntifs
    IN HANDLE Handle,                                           // ntifs
    OUT PBOOLEAN GenerateOnClose                                // ntifs
    );                                                          // ntifs

// begin_ntosp
NTSTATUS
ObSetSecurityObjectByPointer (
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
ObSetHandleAttributes (
    IN HANDLE Handle,
    IN POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
ObCloseHandle (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
ObSwapObjectNames (
    IN HANDLE DirectoryHandle,
    IN HANDLE Handle1,
    IN HANDLE Handle2,
    IN ULONG Flags
    );

// end_ntosp

#if DEVL

typedef BOOLEAN (*OB_ENUM_OBJECT_TYPE_ROUTINE)(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG_PTR HandleCount,
    IN ULONG_PTR PointerCount,
    IN PVOID Parameter
    );

NTSTATUS
ObEnumerateObjectsByType(
    IN POBJECT_TYPE ObjectType,
    IN OB_ENUM_OBJECT_TYPE_ROUTINE EnumerationRoutine,
    IN PVOID Parameter
    );

NTSTATUS
ObGetHandleInformation(
    OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ObGetHandleInformationEx (
    OUT PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ObGetObjectInformation(
    IN PCHAR UserModeBufferAddress,
    OUT PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
ObSetSecurityDescriptorInfo(
    IN PVOID Object,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );
// end_ntosp

NTKERNELAPI
NTSTATUS
ObQuerySecurityDescriptorInfo(
    IN PVOID Object,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );

NTSTATUS
ObDeassignSecurity (
    IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

VOID
ObAuditObjectAccess(
    IN HANDLE Handle,
    IN POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    IN ACCESS_MASK DesiredAccess
    );

NTKERNELAPI
VOID
FASTCALL
ObInitializeFastReference (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    );

NTKERNELAPI
PVOID
FASTCALL
ObFastReferenceObject (
    IN PEX_FAST_REF FastRef
    );

NTKERNELAPI
PVOID
FASTCALL
ObFastReferenceObjectLocked (
    IN PEX_FAST_REF FastRef
    );

NTKERNELAPI
VOID
FASTCALL
ObFastDereferenceObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    );

NTKERNELAPI
PVOID
FASTCALL
ObFastReplaceObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    );

#endif // DEVL

#endif // _OB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pciirqmp.h ===
/*++                    

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pciirqmp.h

Abstract:

    This module contains support routines for the Pci Irq Routing.

Author:

    Santosh Jodh (santoshj) 09-June-1998
    
    
Environment:

    Kernel mode

--*/

#ifndef _PCIIRQMP_

#define _PCIIRQMP_

//
// Standard Pci Irq miniport return values (source compatible with W9x).
//

typedef NTSTATUS PCIMPRET;

#define PCIMP_SUCCESS                               STATUS_SUCCESS
#define PCIMP_FAILURE                               STATUS_UNSUCCESSFUL
#define PCIMP_INVALID_LINK                          STATUS_TOO_MANY_LINKS
#define PCIMP_INVALID_IRQ                           STATUS_INVALID_PARAMETER

#define PCIIRQMP_STATUS_NOT_INITIALIZED             STATUS_UNSUCCESSFUL
#define PCIIRQMP_STATUS_ALREADY_INITIALIZED         STATUS_UNSUCCESSFUL
#define PCIIRQMP_STATUS_NO_INSTANCE                 STATUS_UNSUCCESSFUL
#define PCIIRQMP_STATUS_INVALID_INSTANCE            STATUS_UNSUCCESSFUL
#define PCIIRQMP_STATUS_INVALID_PARAMETER           STATUS_UNSUCCESSFUL

//
// Define bits to describe source of routing table.
//

#define PCIMP_VALIDATE_SOURCE_BITS                  1
#define PCIMP_VALIDATE_SOURCE_PCIBIOS               1

//
// Chipset specific flags for individual workarounds.
//
// Bit 0: PCI devices cannot share interrupts.
//
#define PCIIR_FLAG_EXCLUSIVE                        0x00000001

//
// Maximum number of interrupt pins possible on a single
// Pci device (CS offset 3D).
//

#define NUM_IRQ_PINS                                4

//
// Structure definitions for Pci Irq Routing.
//

#pragma pack(push, 1)

//
// Structure of information for one link.
//

typedef struct _PIN_INFO {
    UCHAR   Link;
    USHORT  InterruptMap;
} PIN_INFO, *PPIN_INFO;

//
// Structure of information for one slot entry.
//

typedef struct _SLOT_INFO {
    UCHAR       BusNumber;
    UCHAR       DeviceNumber;
    PIN_INFO    PinInfo[NUM_IRQ_PINS];
    UCHAR       SlotNumber;
    UCHAR       Reserved[1];    
} SLOT_INFO, *PSLOT_INFO;

#pragma pack(pop)

//
// Structure of the $PIR table according to MS specification.
//

typedef struct _PCI_IRQ_ROUTING_TABLE {
    ULONG   Signature;
    USHORT  Version;
    USHORT  TableSize;
    UCHAR   RouterBus;
    UCHAR   RouterDevFunc;
    USHORT  ExclusiveIRQs;
    ULONG   CompatibleRouter;
    ULONG   MiniportData;
    UCHAR   Reserved0[11];
    UCHAR   Checksum;
} PCI_IRQ_ROUTING_TABLE, *PPCI_IRQ_ROUTING_TABLE;

//
// Functions exported by Pci Irq Routing miniport library.
//

NTSTATUS
PciirqmpInit (
    IN ULONG   Instance,       
    IN ULONG   RouterBus,
    IN ULONG   RouterDevFunc
    );

NTSTATUS
PciirqmpExit (
    VOID
    );

NTSTATUS
PciirqmpValidateTable (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN ULONG                   Flags
    );

NTSTATUS    
PciirqmpGetIrq (
    OUT PUCHAR  Irq, 
    IN  UCHAR   Link
    );

NTSTATUS    
PciirqmpSetIrq (
    IN UCHAR Irq, 
    IN UCHAR Link
    );

NTSTATUS    
PciirqmpGetTrigger (
    OUT PULONG Trigger
    );

NTSTATUS
PciirqmpSetTrigger (
    IN ULONG Trigger
    );

#endif  // _PCIIRQMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pci.h ===
/*++

Module Name:

    pci.h

Abstract:

    This is the PCI bus specific header file used by device drivers.

Author:

Revision History:

--*/

#ifndef _PCI_
#define _PCI_

// begin_ntddk begin_ntosp

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//
typedef struct _PCI_AGP_CAPABILITY {
    
    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;


#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_wdm end_ntminiport

// end_ntddk end_ntosp

//
// PCI_REGISTRY_INFO - this structure is passed into the HAL from
// the firmware.  It signifies how many PCI bus(es) are present and
// what style of access the PCI bus(es) support.
//

typedef struct _PCI_REGISTRY_INFO {
    UCHAR       MajorRevision;
    UCHAR       MinorRevision;
    UCHAR       NoBuses;
    UCHAR       HardwareMechanism;
} PCI_REGISTRY_INFO, *PPCI_REGISTRY_INFO;

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     0xCF8
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;


// begin_ntddk begin_ntosp

//
// Portable portion of HAL & HAL bus extender definitions for BUSHANDLER
// BusData for installed PCI buses.
//

typedef VOID
(*PciPin2Line) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

typedef VOID
(*PciLine2Pin) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

typedef VOID
(*PciReadWriteConfig) (
    IN struct _BUS_HANDLER *BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#define PCI_DATA_TAG            ' ICP'
#define PCI_DATA_VERSION        1

typedef struct _PCIBUSDATA {
    ULONG                   Tag;
    ULONG                   Version;
    PciReadWriteConfig      ReadConfig;
    PciReadWriteConfig      WriteConfig;
    PciPin2Line             Pin2Line;
    PciLine2Pin             Line2Pin;
    PCI_SLOT_NUMBER         ParentSlot;
    PVOID                   Reserved[4];
} PCIBUSDATA, *PPCIBUSDATA;

typedef ULONG (*PCI_READ_WRITE_CONFIG)(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef VOID (*PCI_PIN_TO_LINE)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    );

typedef VOID (*PCI_LINE_TO_PIN)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    );

typedef struct _PCI_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard PCI bus interfaces
    //
    PCI_READ_WRITE_CONFIG ReadConfig;
    PCI_READ_WRITE_CONFIG WriteConfig;
    PCI_PIN_TO_LINE PinToLine;
    PCI_LINE_TO_PIN LineToPin;
} PCI_BUS_INTERFACE_STANDARD, *PPCI_BUS_INTERFACE_STANDARD;

#define PCI_BUS_INTERFACE_STANDARD_VERSION 1

// begin_wdm

#define PCI_DEVICE_PRESENT_INTERFACE_VERSION 1

//
// Flags for PCI_DEVICE_PRESENCE_PARAMETERS
//
#define PCI_USE_SUBSYSTEM_IDS   0x00000001
#define PCI_USE_REVISION        0x00000002
// The following flags are only valid for IsDevicePresentEx
#define PCI_USE_VENDEV_IDS      0x00000004
#define PCI_USE_CLASS_SUBCLASS  0x00000008
#define PCI_USE_PROGIF          0x00000010
#define PCI_USE_LOCAL_BUS       0x00000020
#define PCI_USE_LOCAL_DEVICE    0x00000040

//
// Search parameters structure for IsDevicePresentEx
//
typedef struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    
    ULONG Size;
    ULONG Flags;

    USHORT VendorID;
    USHORT DeviceID;
    UCHAR RevisionID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    UCHAR BaseClass;
    UCHAR SubClass;
    UCHAR ProgIf;

} PCI_DEVICE_PRESENCE_PARAMETERS, *PPCI_DEVICE_PRESENCE_PARAMETERS;

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT) (
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN UCHAR RevisionID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN ULONG Flags
);

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT_EX) (
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // pci device info
    //
    PPCI_IS_DEVICE_PRESENT IsDevicePresent;
    
    PPCI_IS_DEVICE_PRESENT_EX IsDevicePresentEx;

} PCI_DEVICE_PRESENT_INTERFACE, *PPCI_DEVICE_PRESENT_INTERFACE;


// end_wdm end_ntddk end_ntosp
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pbios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pbiosp.h

Abstract:

    PnP BIOS/ISA configuration data definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//#include "nthal.h"
//#include "hal.h"

//
// Constants
//

#define SMALL_RESOURCE_TAG          (UCHAR)(0x00)
#define LARGE_RESOURCE_TAG          (UCHAR)(0x80)
#define SMALL_TAG_MASK              0xf8
#define SMALL_TAG_SIZE_MASK         7

//
// Small Resouce Tags with length bits stripped off
//

#define TAG_VERSION                 0x08
#define TAG_LOGICAL_ID              0x10
#define TAG_COMPATIBLE_ID           0x18
#define TAG_IRQ                     0x20
#define TAG_DMA                     0x28
#define TAG_START_DEPEND            0x30
#define TAG_END_DEPEND              0x38
#define TAG_IO                      0x40
#define TAG_IO_FIXED                0x48
#define TAG_VENDOR                  0x70
#define TAG_END                     0x78

//
// Large Resouce Tags
//

#define TAG_MEMORY                  0x81
#define TAG_ANSI_ID                 0x82
#define TAG_UNICODE_ID              0x83
#define TAG_LVENDOR                 0x84
#define TAG_MEMORY32                0x85
#define TAG_MEMORY32_FIXED          0x86

//
// Complete TAG if applicable.
//

#define TAG_COMPLETE_COMPATIBLE_ID  0x1C
#define TAG_COMPLETE_END            0x79

#include "pshpack1.h"

//
// PNP ISA Port descriptor definition
//

typedef struct _PNP_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01000111B, small item name = 08, length = 7
    UCHAR   Information;            // bit [0] = 1 device decodes full 16 bit addr
                                    //         = 0 device decodes ISA addr bits[9-0]
    USHORT  MinimumAddress;
    USHORT  MaximumAddress;
    UCHAR   Alignment;              // Increment in 1 byte blocks
    UCHAR   Length;                 // # contiguous Port requested
} PNP_PORT_DESCRIPTOR, *PPNP_PORT_DESCRIPTOR;

//
// PNP ISA fixed Port descriptor definition
//

typedef struct _PNP_FIXED_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01001011B, small item name = 09, length = 3
    USHORT  MinimumAddress;
    UCHAR   Length;                 // # contiguous Port requested
} PNP_FIXED_PORT_DESCRIPTOR, *PPNP_FIXED_PORT_DESCRIPTOR;

//
// PNP ISA IRQ descriptor definition
//

typedef struct _PNP_IRQ_DESCRIPTOR_ {
    UCHAR   Tag;                    // 0010001XB small item name = 4 length = 2/3
    USHORT  IrqMask;                // bit 0 is irq 0
    UCHAR   Information;            // Optional
} PNP_IRQ_DESCRIPTOR, *PPNP_IRQ_DESCRIPTOR;

//
// Masks for PNP_IRQ_DESCRIPTOR Information byte
//

#define PNP_IRQ_LEVEL_MASK          0xC
#define PNP_IRQ_EDGE_MASK           0x3

//
// PNP ISA DMA descriptor definition
//

typedef struct _PNP_DMA_DESCRIPTOR_ {
    UCHAR   Tag;                    // 00101010B, small item name = 05, length = 2
    UCHAR   ChannelMask;            // bit 0 is channel 0
    UCHAR   Flags;                  // see spec
} PNP_DMA_DESCRIPTOR, *PPNP_DMA_DESCRIPTOR;

//
// PNP ISA MEMORY descriptor
//

typedef struct _PNP_MEMORY_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000001B, Large item name = 1
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    USHORT  MinimumAddress;         // address bit [8-23]
    USHORT  MaximumAddress;         // address bit [8-23]
    USHORT  Alignment;              // 0x0000 = 64KB
    USHORT  MemorySize;             // In 256 byte blocks
} PNP_MEMORY_DESCRIPTOR, *PPNP_MEMORY_DESCRIPTOR;

//
// PNP ISA MEMORY32 descriptor
//

typedef struct _PNP_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000101B, Large item name = 5
    USHORT  Length;                 // Length of the descriptor = 17
    UCHAR   Information;            // See def below
    ULONG   MinimumAddress;         // 32 bit addr
    ULONG   MaximumAddress;         // 32 bit addr
    ULONG   Alignment;              // 32 bit alignment
    ULONG   MemorySize;             // 32 bit length
} PNP_MEMORY32_DESCRIPTOR, *PPNP_MEMORY32_DESCRIPTOR;

//
// PNP ISA FIXED MEMORY32 descriptor
//

typedef struct _PNP_FIXED_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000110B, Large item name = 6
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    ULONG   BaseAddress;            // 32 bit addr
    ULONG   MemorySize;             // 32 bit length
} PNP_FIXED_MEMORY32_DESCRIPTOR, *PPNP_FIXED_MEMORY32_DESCRIPTOR;

#define PNP_MEMORY_ROM_MASK            0x40
#define PNP_MEMORY_SHADOWABLE_MASK     0x20
#define PNP_MEMORY_CONTROL_MASK        0x18
    #define PNP_MEMORY_CONTROL_8BIT       00
    #define PNP_MEMORY_CONTROL_16BIT      01
    #define PNP_MEMORY_CONTROL_8AND16BIT  02
    #define PNP_MEMORY_CONTROL_32BIT      03
#define PNP_MEMORY_SUPPORT_TYPE_MASK   04
#define PNP_MEMORY_CACHE_SUPPORT_MASK  02
#define PNP_MEMORY_WRITE_STATUS_MASK   01

#define UNKNOWN_DOCKING_IDENTIFIER     0xffffffff
#define UNABLE_TO_DETERMINE_DOCK_CAPABILITIES 0x89
#define FUNCTION_NOT_SUPPORTED         0x82
#define SYSTEM_NOT_DOCKED              0x87

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT  Size;
    UCHAR   Node;
    ULONG   ProductId;
    UCHAR   DeviceType[3];
    USHORT  DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, *PPNP_BIOS_DEVICE_NODE;

//
// DeviceType definition
//

#define BASE_TYPE_DOCKING_STATION      0xA

//
// Device attributes definitions
//

#define DEVICE_DISABLEABLE             0x0001
#define DEVICE_CONFIGURABLE            0x0002
#define DEVICE_DOCKING                 0x0020
#define DEVICE_REMOVABLE               0x0040

#define DEVICE_CONFIGURABILITY(x)      ((x)&0x180)
#define DEVICE_CONFIG_STATIC_ONLY      0x0000
#define DEVICE_CONFIG_STATIC_DYNAMIC   0x0080
#define DEVICE_CONFIG_DYNAMIC_ONLY     0x0100

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR   Signature[4];              // $PnP (ascii)
    UCHAR   Revision;
    UCHAR   Length;
    USHORT  ControlField;
    UCHAR   Checksum;
    ULONG   EventFlagAddress;          // Physical address
    USHORT  RealModeEntryOffset;
    USHORT  RealModeEntrySegment;
    USHORT  ProtectedModeEntryOffset;
    ULONG   ProtectedModeCodeBaseAddress;
    ULONG   OemDeviceId;
    USHORT  RealModeDataBaseAddress;
    ULONG  ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, *PPNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Pnp BIOS ControlField masks
//

#define PNP_BIOS_CONTROL_MASK          0x3
#define PNP_BIOS_EVENT_NOT_SUPPORTED   0
#define PNP_BIOS_EVENT_POLLING         1
#define PNP_BIOS_EVENT_ASYNC           2

//
// Pnp Bios event
//

#define ABOUT_TO_CHANGE_CONFIG         1
#define DOCK_CHANGED                   2
#define SYSTEM_DEVICE_CHANGED          3
#define CONFIG_CHANGE_FAILED           4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\perf.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    perf.h

Abstract:

    This module contains the macro definition of all performance hooks.

Author:

    Stephen Hsiao (shsiao) 01-Jan-2000

Revision History:

--*/

#ifndef _PERF_H
#define _PERF_H

#include <wmistr.h>
#include <ntwmi.h>
#include <ntperf.h>

extern PERFINFO_GROUPMASK *PPerfGlobalGroupMask;
extern const PERFINFO_HOOK_HANDLE PerfNullHookHandle;
#define PERF_NULL_HOOK_HANDLE (PerfNullHookHandle)

typedef enum _PERFINFO_START_LOG_LOCATION {
    PERFINFO_START_LOG_AT_BOOT,
    PERFINFO_START_LOG_POST_BOOT,
    PERFINFO_START_LOG_FROM_GLOBAL_LOGGER
} PERFINFO_START_LOG_LOCATION, *PPERFINFO_START_LOG_LOCATION;

typedef struct _PERFINFO_ENTRY_TABLE {
    PVOID *Table;
    LONG NumberOfEntries;
} PERFINFO_ENTRY_TABLE, *PPERFINFO_ENTRY_TABLE;

NTSTATUS
PerfInfoStartLog (
    PERFINFO_GROUPMASK *pGroupMask,
    PERFINFO_START_LOG_LOCATION StartLogLocation
    );

NTSTATUS
PerfInfoStopLog (
    VOID
    );

NTSTATUS
PerfInfoLogFileName(
    PVOID  FileObject,
    PUNICODE_STRING SourceString
    );

ULONG
PerfInfoCalcHashValue(
    PVOID Key,
    ULONG Len
    );

BOOLEAN
PerfInfoAddToFileHash(
    PPERFINFO_ENTRY_TABLE HashTable,
    PVOID ObjectPointer
    );

VOID
ObPerfHandleTableWalk (
    PEPROCESS Process,
    PPERFINFO_ENTRY_TABLE HashTable
    );

VOID
FASTCALL
PerfProfileInterrupt(
    IN KPROFILE_SOURCE Source,
    IN PVOID InstructionPointer
    );

VOID
PerfInfoFlushProfileCache(
    VOID
    );

VOID
FASTCALL
PerfInfoLogInterrupt(
    IN PVOID ServiceRoutine,
    IN ULONG RetVal,
    IN ULONGLONG InitialTime
    );

#define PERFINFO_IS_ANY_GROUP_ON() (PPerfGlobalGroupMask != NULL)

#define PERFINFO_IS_GROUP_ON(_Group) PerfIsGroupOnInGroupMask(_Group, PPerfGlobalGroupMask)

#define PERF_FINISH_HOOK(_HookHandle) WmiReleaseKernelBuffer((_HookHandle).WmiBufferHeader);

NTSTATUS
PerfInfoReserveBytes(
    PPERFINFO_HOOK_HANDLE Hook,
    USHORT HookId,
    ULONG BytesToReserve
    );

NTSTATUS
PerfInfoLogBytes(
    USHORT HookId,
    PVOID Data,
    ULONG NumBytes
    );

NTSTATUS
PerfInfoLogBytesAndUnicodeString(
    USHORT HookId,
    PVOID SourceData,
    ULONG SourceByteCount,
    PUNICODE_STRING String
    );

//
// Macros for TimeStamps
//
#ifdef NTPERF
#if defined(_X86_)
__inline
LONGLONG
PerfGetCycleCount(
    )
{
    __asm{
        RDTSC
    }
}
#elif defined(_AMD64_)
#define PerfGetCycleCount() ReadTimeStampCounter()
#elif defined(_IA64_)
#define PerfGetCycleCount() __getReg(CV_IA64_ApITC)
#else
#error "perf: a target architecture must be defined."
#endif

#define PerfTimeStamp(TS) TS.QuadPart = PerfGetCycleCount();
#else
#define PerfTimeStamp(TS) TS.QuadPart = (*WmiGetCpuClock)();
#endif //NTPERF

//
// Macros used in \nt\base\ntos\io\iomgr\parse.c
//
#define PERFINFO_LOG_FILE_CREATE(FileObject, CompleteName)                                              \
    if (PERFINFO_IS_GROUP_ON(PERF_FILENAME_ALL)){                                                       \
        PerfInfoLogFileName(FileObject, CompleteName);                                                  \
    }

// Macros used in \nt\base\ntos\mm\creasect.c
//
#define PERFINFO_SECTION_CREATE(ControlArea)

//
// Macros used in \nt\base\ntos\ps\psquery.c
//

#define PERFINFO_CONVERT_TO_GUI_THREAD(EThread)                                                         \
    if (PERFINFO_IS_GROUP_ON(PERF_MEMORY)) {                                                            \
        PERFINFO_THREAD_INFORMATION _ThreadInfo;                                                        \
        _ThreadInfo.ProcessId = HandleToUlong((EThread)->Cid.UniqueProcess);                            \
        _ThreadInfo.ThreadId = HandleToUlong((EThread)->Cid.UniqueThread);                              \
        _ThreadInfo.StackBase = (EThread)->Tcb.StackBase;                                               \
        _ThreadInfo.StackLimit = (EThread)->Tcb.StackLimit;                                             \
        _ThreadInfo.UserStackBase = 0;                                                                  \
        _ThreadInfo.UserStackLimit = 0;                                                                 \
        _ThreadInfo.StartAddr = 0;                                                                      \
        _ThreadInfo.Win32StartAddr = 0;                                                                 \
        _ThreadInfo.WaitMode = -1;                                                                      \
        PerfInfoLogBytes(                                                                               \
            PERFINFO_LOG_TYPE_CONVERTTOGUITHREAD,                                                       \
            &_ThreadInfo,                                                                               \
            sizeof(_ThreadInfo)                                                                         \
            );                                                                                          \
    }

//
// Macros used in \NT\PRIVATE\NTOS\ps\psdelete.c
//

#define PERFINFO_PROCESS_DELETE(EProcess)                                                               \
    WmiTraceProcess(EProcess, FALSE);

#define PERFINFO_THREAD_DELETE(EThread)                                                                 \
    WmiTraceThread(EThread, NULL, FALSE);
//
// Macros used in \NT\PRIVATE\NTOS\ps\create.c
//

#define PERFINFO_PROCESS_CREATE(EProcess)                                                               \
    WmiTraceProcess(EProcess, TRUE);

#define PERFINFO_THREAD_CREATE(EThread, ITeb)                                                           \
    WmiTraceThread(EThread, ITeb, TRUE);                                                                \

//
// ntos\ke\ia64\clock.c Sampled Profile stuff for IA64.  The x86 version is in
// assembly.
//
#if defined(_IA64_)
#define PERFINFO_PROFILE(_frame, _source)                                                               \
    if (PERFINFO_IS_GROUP_ON(PERF_PROFILE)) {                                                           \
        PerfProfileInterrupt(_source, (PVOID)_frame->StIIP);                                            \
    }
#endif

#ifdef NTPERF

extern PERFINFO_GROUPMASK StartAtBootGroupMask;
extern ULONG PerfInfo_InitialStackWalk_Threshold_ms;
extern VOID * BBTBuffer;
extern ULONG PerfInfoLoggingToPerfMem;
#define PerfBufHdr() ((PPERFINFO_TRACEBUF_HEADER) BBTBuffer)

#define PERFINFO_IS_PERFMEM_ALLOCATED() (PerfBufHdr() != NULL)

#define PERFINFO_IS_LOGGING_TO_PERFMEM() (PerfInfoLoggingToPerfMem != 0)

#define PERFINFO_SET_LOGGING_TO_PERFMEM(Flag) PerfInfoLoggingToPerfMem = (Flag);

#define PerfQueryBufferSizeBytes() (PAGE_SIZE * (PerfBufHdr()->PagesReserved))

NTSTATUS
PerfInfoStartPerfMemLog(
    );

NTSTATUS
PerfInfoStopPerfMemLog(
    );

PVOID
FASTCALL
PerfInfoReserveBytesFromPerfMem(
    ULONG BytesToReserve
    );

NTSTATUS
PerfInfoSetPerformanceTraceInformation (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );

NTSTATUS
PerfInfoQueryPerformanceTraceInformation (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength
    );

VOID
PerfInfoSetProcessorSpeed(
    VOID
    );

//
// Macros used in \nt\base\ntos\mm\
//

#define PERFINFO_MMINIT_START()                                                                         \
    PerfInfoSetProcessorSpeed();                                                                        \
    if (PerfIsAnyGroupOnInGroupMask(&StartAtBootGroupMask)) {                                           \
        PerfInfoStartLog(&StartAtBootGroupMask, PERFINFO_START_LOG_AT_BOOT);                            \
        PerfBufHdr()->GetStack_CSwitchDelta =                                                           \
           1000 *                                                                                       \
           PerfInfo_InitialStackWalk_Threshold_ms *                                                     \
           PerfBufHdr()->CalcPerfFrequency;                                                             \
                                                                                                        \
        PerfBufHdr()->GetStack_DrvDelayDelta =                                                          \
            PerfBufHdr()->GetStack_CSwitchDelta;                                                        \
    }

#else //NTPERF

#define PERFINFO_MMINIT_START()
#define PERFINFO_IS_LOGGING_TO_PERFMEM() (FALSE)

#endif // NTPERF

#ifndef NTPERF_PRIVATE
#define PERFINFO_ADD_OBJECT_TO_ALLOCATED_TYPE_LIST(CreatorInfo, ObjectType)
#define PERFINFO_ADDPOOLPAGE(CheckType, PoolIndex, Addr, PoolDesc)
#define PERFINFO_ADDTOWS(PageFrame, Address, Pid)
#define PERFINFO_BIGFOOT_REPLACEMENT_CLAIMS(WorkingSetList, WsInfo)
#define PERFINFO_BIGFOOT_REPLACEMENT_FAULTS(WorkingSetList, WsInfo)
#define PERFINFO_BIGPOOLALLOC(Type, PTag, NumBytes, Addr)
#define PERFINFO_CLEAR_OBJECT(CurrentState, Object)
#define PERFINFO_DECLARE_OB_ENUMERATE_ALLOCATED_OBJECTS_BY_TYPE()
#define PERFINFO_DECLARE_OBJECT(Object)
#define PERFINFO_DECREFCNT(PageFrame, Flag, Type)
#define PERFINFO_DEFINE_OB_ENUMERATE_ALLOCATED_OBJECTS_BY_TYPE()
#define PERFINFO_DELETE_STACK(PointerPte, NumberOfPtes)
#define PERFINFO_DETACH_PROCESS(KThread, KProcess)
#define PERFINFO_DO_PAGEFAULT_CLUSTERING() 1
#define PERFINFO_DRIVER_INTENTIONAL_DELAY()
#define PERFINFO_DRIVER_STACKTRACE()
#define PERFINFO_EXALLOCATEPOOLWITHTAG_DECL()
#define PERFINFO_EXFREEPOOLWITHTAG_DECL()
#define PERFINFO_FAULT_NOTIFICATION(Address, TrapInfo)
#define PERFINFO_FREEPOOL(Addr)
#define PERFINFO_FREEPOOLPAGE(CheckType, PoolIndex, Addr, PoolDesc)
#define PERFINFO_GET_PAGE_INFO(PointerPte)
#define PERFINFO_GET_PAGE_INFO_REPLACEMENT(PointerPte)
#define PERFINFO_GET_PAGE_INFO_WITH_DECL(PointerPte)
#define PERFINFO_GROW_STACK(EThread)
#define PERFINFO_HIBER_ADJUST_PAGECOUNT_FOR_BBTBUFFER(pPageCount)
#define PERFINFO_HIBER_DUMP_PERF_BUFFER()
#define PERFINFO_HIBER_HANDLE_BBTBUFFER_RANGE(HiberContext)
#define PERFINFO_HIBER_PAUSE_LOGGING()
#define PERFINFO_HIBER_REINIT_TRACE()
#define PERFINFO_HIBER_START_LOGGING()
#define PERFINFO_HIVECELL_REFERENCE_FLAT(Hive, pcell, Cell)
#define PERFINFO_HIVECELL_REFERENCE_PAGED(Hive, pcell, Cell, Type, Map)
#define PERFINFO_IMAGE_LOAD(LdrDataTableEntry)
#define PERFINFO_IMAGE_UNLOAD(Address)
#define PERFINFO_INIT_KTHREAD(KThread)
#define PERFINFO_INIT_TRACEFLAGS(OptnString, SpecificOptn)
#define PERFINFO_INITIALIZE_OBJECT_ALLOCATED_TYPE_LIST_HEAD(NewObjectType)
#define PERFINFO_INSERT_FRONT_STANDBY(Page)
#define PERFINFO_INSERTINLIST(Page, ListHead)
#define PERFINFO_INSWAP_PROCESS(OutProcess)
#define PERFINFO_LOG_MARK(PMARK)
#define PERFINFO_LOG_MARK_SPRINTF(PMARK, VARIABLE)
#define PERFINFO_LOG_WS_REMOVAL(Type, WsInfo)
#define PERFINFO_LOG_WS_REPLACEMENT(WsInfo)
#define PERFINFO_MOD_PAGE_WRITER3()
#define PERFINFO_MUNG_FILE_OBJECT_TYPE_INITIALIZER(init)
#define PERFINFO_PAGE_INFO_DECL()
#define PERFINFO_PAGE_INFO_REPLACEMENT_DECL()
#define PERFINFO_POOL_ALLOC_COMMON(Type, PTag, NumBytes)
#define PERFINFO_POOLALLOC(Type, PTag, NumBytes)
#define PERFINFO_POOLALLOC_ADDR(Addr)
#define PERFINFO_POOLALLOC_EARLYEXIT()
#define PERFINFO_POWER_BATTERY_LIFE_INFO(_RemainingCapacity, _Rate)
#define PERFINFO_POWER_IDLE_STATE_CHANGE(_PState, _Direction)
#define PERFINFO_PRIVATE_COPY_ON_WRITE(CopyFrom, PAGE_SIZE)
#define PERFINFO_PRIVATE_PAGE_DEMAND_ZERO(VirtualAddress)
#define PERFINFO_REG_DELETE_KEY(KeyControlBlock)
#define PERFINFO_REG_DELETE_VALUE(KeyControlBlock, ValueName)
#define PERFINFO_REG_DUMP_CACHE()
#define PERFINFO_REG_ENUM_KEY(KeyControlBlock, Index)
#define PERFINFO_REG_ENUM_VALUE(KeyControlBlock, Index)
#define PERFINFO_REG_KCB_CREATE(kcb)
#define PERFINFO_REG_NOTIFY(NotifiedKCB, ModifiedKCB)
#define PERFINFO_REG_PARSE(kcb, RemainingName)
#define PERFINFO_REG_QUERY_KEY(KeyControlBlock)
#define PERFINFO_REG_QUERY_MULTIVALUE(KeyControlBlock, CurrentName)
#define PERFINFO_REG_QUERY_VALUE(KeyControlBlock, ValueName)
#define PERFINFO_REG_SET_VALUE_DECL()
#define PERFINFO_REG_SET_VALUE(KeyControlBlock)
#define PERFINFO_REG_SET_VALUE_DONE(ValueName)
#define PERFINFO_REG_SET_VALUE_EXIST()
#define PERFINFO_REG_SET_VALUE_NEW()
#define PERFINFO_REGPARSE(kcb, RemainingName)
#define PERFINFO_REGPARSE_END(status)
#define PERFINFO_REMOVE_OBJECT_FROM_ALLOCATED_TYPE_LIST(CreatorInfo, ObjectHeader)
#define PERFINFO_SECTION_CREATE1(File)
#define PERFINFO_SEGMENT_DELETE(FileName)
#define PERFINFO_SHUTDOWN_LOG_LAST_MEMORY_SNAPSHOT()
#define PERFINFO_SHUTDOWN_DUMP_PERF_BUFFER()
#define PERFINFO_SIGNAL_OBJECT(CurrentState, Object)
#define PERFINFO_SOFTFAULT(PageFrame, Address, Type)
#define PERFINFO_STACKWALK_THRESHHOLD_CM_DECL
#define PERFINFO_STACKWALK_THRESHHOLD_DECL
#define PERFINFO_UNLINKFREEPAGE(Index, Location)
#define PERFINFO_UNLINKPAGE(Index, Location)
#define PERFINFO_UNMUNG_FILE_OBJECT_TYPE_INITIALIZER(init)
#define PERFINFO_UNWAIT_OBJECT(Object, Status)
#define PERFINFO_UNWAIT_OBJECTS(Object, CountIn, WaitType, WaitStatus)
#define PERFINFO_WAIT_ON_OBJECT(Object)
#define PERFINFO_WAIT_ON_OBJECTS(Object, CountIn, WaitType)
#define PERFINFO_WAITLOGGED_DECL
#define PERFINFO_WSMANAGE_ACTUALTRIM(Trim)
#define PERFINFO_WSMANAGE_CHECK()
#define PERFINFO_WSMANAGE_DECL()
#define PERFINFO_WSMANAGE_DUMPENTRIES()
#define PERFINFO_WSMANAGE_DUMPENTRIES_CLAIMS()
#define PERFINFO_WSMANAGE_DUMPENTRIES_FAULTS()
#define PERFINFO_WSMANAGE_DUMPWS(VmSupport, SampledAgeCounts)
#define PERFINFO_WSMANAGE_FINALACTION(TrimAction)
#define PERFINFO_WSMANAGE_LOGINFO_CLAIMS(TrimAction)
#define PERFINFO_WSMANAGE_LOGINFO_FAULTS(TrimAction)
#define PERFINFO_WSMANAGE_STARTLOG()
#define PERFINFO_WSMANAGE_STARTLOG_CLAIMS()
#define PERFINFO_WSMANAGE_STARTLOG_FAULTS()
#define PERFINFO_WSMANAGE_TOTRIM(Trim)
#define PERFINFO_WSMANAGE_TRIMACTION(TrimAction)
#define PERFINFO_WSMANAGE_TRIMEND_CLAIMS(Criteria)
#define PERFINFO_WSMANAGE_TRIMEND_FAULTS(Criteria)
#define PERFINFO_WSMANAGE_TRIMWS(Process, SessionSpace, VmSupport)
#define PERFINFO_WSMANAGE_TRIMWS_CLAIMINFO(VmSupport)
#define PERFINFO_WSMANAGE_TRIMWS_CLAIMINFO(VmSupport)
#define PERFINFO_WSMANAGE_WAITFORWRITER_CLAIMS()
#define PERFINFO_WSMANAGE_WAITFORWRITER_FAULTS()
#define PERFINFO_WSMANAGE_WILLTRIM(ReductionGoal, FreeGoal)
#define PERFINFO_WSMANAGE_WILLTRIM_CLAIMS(Criteria)
#define PERFINFO_WSMANAGE_WILLTRIM_FAULTS(Criteria)
#define PERF_BRANCH_TRACING_OFF_KD()
#define PERF_BRANCH_TRACING_ON_KD()
#define PERF_PF_MODLOAD_DECL()
#define PERF_PF_MODLOAD_SAVE()
#define PERF_PF_MODLOAD_RESTORE()
#define PERF_PF_SANITIZE_CONTEXT(Context)
#define PERF_BRANCH_TRACING_BREAKPOINT(ExceptionRecord, TrapFrame)
#define PERF_ASSERT_TRACING_OFF()
#define PERF_IS_BRANCH_TRACING_ON()
#define PERFINFO_LOG_PREFETCH_BEGIN_TRACE(ScenarioId, ScenarioType, Process)
#define PERFINFO_LOG_PREFETCH_END_TRACE(ScenarioId, ScenarioType, Process, Status)
#define PERFINFO_LOG_PREFETCH_SECTIONS(PrefetchHeader, PrefetchType, PagesToPrefetch)
#define PERFINFO_LOG_PREFETCH_SECTIONS_END(PrefetchHeader, Status, PagesRequested)
#define PERFINFO_LOG_PREFETCH_METADATA(PrefetchHeader)
#define PERFINFO_LOG_PREFETCH_METADATA_END(PrefetchHeader, Status)
#define PERFINFO_LOG_PREFETCH_SCENARIO(PrefetchHeader, ScenarioId, ScenarioType)
#define PERFINFO_LOG_PREFETCH_SCENARIO_END(PrefetchHeader, Status)
#define PERFINFO_LOG_PREFETCH_REQUEST(RequestId, NumLists, RequestLists)
#define PERFINFO_LOG_PREFETCH_READLIST(RequestId, ReadList)
#define PERFINFO_LOG_PREFETCH_READ(FileObject, Offset, ByteCount)

#else
#include "..\perf\perfinfokrn.h"
#endif // !NTPERF_PRIVATE

#endif  // PERF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pnpcvrt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpcvrt.h

Abstract:

    This module contains the declarations for the internal APIs used to
    convert PNP resource descriptors to NT descriptors.

Author:

    Robert Nelson (robertn) 10/13/97


Revision History:


--*/

#ifndef _PNPCVRT_
#define _PNPCVRT_

VOID
PpBiosResourcesSetToDisabled (
    IN OUT PUCHAR BiosData,
    OUT    PULONG Length
    );

#define PPCONVERTFLAG_SET_RESTART_LCPRI               0x00000001
#define PPCONVERTFLAG_FORCE_FIXED_IO_16BIT_DECODE     0x00000002

NTSTATUS
PpBiosResourcesToNtResources (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PUCHAR *BiosData,
    IN ULONG ConvertFlags,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *ReturnedList,
    OUT PULONG ReturnedLength
    );

NTSTATUS
PpCmResourcesToBiosResources (
    IN PCM_RESOURCE_LIST CmResources,
    IN PUCHAR BiosRequirements,
    IN PUCHAR *BiosResources,
    IN PULONG Length
    );

#endif // _PNPCVRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pool.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    pool.h

Abstract:

    Private executive data structures and prototypes for pool management.

    There are a number of different pool types:
        1. NonPaged.
        2. Paged.
        3. Session (always paged, but virtualized per TS session).

Author:

    Lou Perazzoli (loup) 23-Feb-1989
    Landy Wang (landyw) 02-June-1997

Revision History:

--*/

#ifndef _POOL_
#define _POOL_

#if !DBG
#define NO_POOL_CHECKS 1
#endif

#define POOL_CACHE_SUPPORTED 0
#define POOL_CACHE_ALIGN 0

#define NUMBER_OF_POOLS 2

#if defined(NT_UP)
#define NUMBER_OF_PAGED_POOLS 2
#else
#define NUMBER_OF_PAGED_POOLS 4
#endif

#define BASE_POOL_TYPE_MASK 1

#define MUST_SUCCEED_POOL_TYPE_MASK 2

#define CACHE_ALIGNED_POOL_TYPE_MASK 4

#define SESSION_POOL_MASK 32

#define POOL_VERIFIER_MASK 64

#define POOL_DRIVER_MASK 128        // Note this cannot encode into a header.

//
// WARNING: POOL_QUOTA_MASK is overloaded by POOL_QUOTA_FAIL_INSTEAD_OF_RAISE
//          which is exported from ex.h.
//
// WARNING: POOL_RAISE_IF_ALLOCATION_FAILURE is exported from ex.h with a
//          value of 16.
//
// These definitions are used to control the raising of an exception as the
// result of quota and allocation failures.
//

#define POOL_QUOTA_MASK 8

#define POOL_TYPE_MASK (3)

//
// Size of a pool page.
//
// This must be greater than or equal to the page size.
//

#define POOL_PAGE_SIZE  PAGE_SIZE

//
// The page size must be a multiple of the smallest pool block size.
//
// Define the block size.
//

#if (PAGE_SIZE == 0x4000)
#define POOL_BLOCK_SHIFT 5
#elif (PAGE_SIZE == 0x2000)
#define POOL_BLOCK_SHIFT 4
#else

#if defined (_WIN64)
#define POOL_BLOCK_SHIFT 4
#else
#define POOL_BLOCK_SHIFT 3
#endif

#endif

#define POOL_LIST_HEADS (POOL_PAGE_SIZE / (1 << POOL_BLOCK_SHIFT))

#define PAGE_ALIGNED(p) (!(((ULONG_PTR)p) & (POOL_PAGE_SIZE - 1)))

//
// Define page end macro.
//

#define PAGE_END(Address) (((ULONG_PTR)(Address) & (PAGE_SIZE - 1)) == 0)

//
// Define pool descriptor structure.
//

typedef struct _POOL_DESCRIPTOR {
    POOL_TYPE PoolType;
    ULONG PoolIndex;
    ULONG RunningAllocs;
    ULONG RunningDeAllocs;
    ULONG TotalPages;
    ULONG TotalBigPages;
    ULONG Threshold;
    PVOID LockAddress;
    PVOID PendingFrees;
    LONG PendingFreeDepth;
    SIZE_T TotalBytes;
    SIZE_T Spare0;
    LIST_ENTRY ListHeads[POOL_LIST_HEADS];
} POOL_DESCRIPTOR, *PPOOL_DESCRIPTOR;

//
//      Caveat Programmer:
//
//              The pool header must be QWORD (8 byte) aligned in size.  If it
//              is not, the pool allocation code will trash the allocated
//              buffer.
//
//
//
// The layout of the pool header is:
//
//         31              23         16 15             7            0
//         +----------------------------------------------------------+
//         | Current Size |  PoolType+1 |  Pool Index  |Previous Size |
//         +----------------------------------------------------------+
//         |   ProcessBilled   (NULL if not allocated with quota)     |
//         +----------------------------------------------------------+
//         | Zero or more longwords of pad such that the pool header  |
//         | is on a cache line boundary and the pool body is also    |
//         | on a cache line boundary.                                |
//         +----------------------------------------------------------+
//
//      PoolBody:
//
//         +----------------------------------------------------------+
//         |  Used by allocator, or when free FLINK into sized list   |
//         +----------------------------------------------------------+
//         |  Used by allocator, or when free BLINK into sized list   |
//         +----------------------------------------------------------+
//         ... rest of pool block...
//
//
// N.B. The size fields of the pool header are expressed in units of the
//      smallest pool block size.
//

typedef struct _POOL_HEADER {
    union {
        struct {
            USHORT PreviousSize : 9;
            USHORT PoolIndex : 7;
            USHORT BlockSize : 9;
            USHORT PoolType : 7;
        };
        ULONG Ulong1;   // used for InterlockedCompareExchange required by Alpha
    };
#if defined (_WIN64)
    ULONG PoolTag;
#endif
    union {
#if defined (_WIN64)
        EPROCESS *ProcessBilled;
#else
        ULONG PoolTag;
#endif
        struct {
            USHORT AllocatorBackTraceIndex;
            USHORT PoolTagHash;
        };
    };
} POOL_HEADER, *PPOOL_HEADER;

//
// Define size of pool block overhead.
//

#define POOL_OVERHEAD ((LONG)sizeof(POOL_HEADER))

//
// Define size of pool block overhead when the block is on a freelist.
//

#define POOL_FREE_BLOCK_OVERHEAD  (POOL_OVERHEAD + sizeof (LIST_ENTRY))

//
// Define dummy type so computation of pointers is simplified.
//

typedef struct _POOL_BLOCK {
    UCHAR Fill[1 << POOL_BLOCK_SHIFT];
} POOL_BLOCK, *PPOOL_BLOCK;

//
// Define size of smallest pool block.
//

#define POOL_SMALLEST_BLOCK (sizeof(POOL_BLOCK))

//
// Define pool tracking information.
//

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

#if POOL_CACHE_SUPPORTED
#define POOL_BUDDY_MAX PoolBuddyMax
#else
#define POOL_BUDDY_MAX  \
   (POOL_PAGE_SIZE - (POOL_OVERHEAD + POOL_SMALLEST_BLOCK ))
#endif

//
// Pool support routines are not for general consumption.
// These are only used by the memory manager.
//

VOID
ExInitializePoolDescriptor (
    IN PPOOL_DESCRIPTOR PoolDescriptor,
    IN POOL_TYPE PoolType,
    IN ULONG PoolIndex,
    IN ULONG Threshold,
    IN PVOID PoolLock
    );

VOID
ExDrainPoolLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     );

PVOID
ExCreatePoolTagTable (
    IN ULONG NewProcessorNumber,
    IN UCHAR NodeNumber
    );

VOID
ExDeletePoolTagTable (
    IN ULONG NewProcessorNumber
    );

#define EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS         0x1
#define EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS        0x2
#define EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES      0x4
#define EX_KERNEL_VERIFIER_ENABLED                    0x8
#define EX_VERIFIER_DEADLOCK_DETECTION_ENABLED       0x10
#define EX_SPECIAL_POOL_ENABLED                      0x20
#define EX_PRINT_POOL_FAILURES                       0x40
#define EX_STOP_ON_POOL_FAILURES                     0x80
#define EX_SEPARATE_HOT_PAGES_DURING_BOOT           0x100
#define EX_DELAY_POOL_FREES                         0x200

VOID
ExSetPoolFlags (
    IN ULONG PoolFlag
    );

//++
//SIZE_T
//EX_REAL_POOL_USAGE (
//    IN SIZE_T SizeInBytes
//    );
//
// Routine Description:
//
//    This routine determines the real pool cost of the supplied allocation.
//
// Arguments
//
//    SizeInBytes - Supplies the allocation size in bytes.
//
// Return Value:
//
//    TRUE if unused segment trimming should be initiated, FALSE if not.
//
//--

#define EX_REAL_POOL_USAGE(SizeInBytes)                             \
        (((SizeInBytes) > POOL_BUDDY_MAX) ?                         \
            (ROUND_TO_PAGES(SizeInBytes)) :                         \
            (((SizeInBytes) + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) & ~(POOL_SMALLEST_BLOCK - 1)))

typedef struct _POOL_TRACKER_TABLE {
    ULONG Key;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedBytes;
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedBytes;
} POOL_TRACKER_TABLE, *PPOOL_TRACKER_TABLE;

//
// N.B. The last entry of the pool tracker table is used for all overflow
//      table entries.
//

extern PPOOL_TRACKER_TABLE PoolTrackTable;

typedef struct _POOL_TRACKER_BIG_PAGES {
    PVOID Va;
    ULONG Key;
    ULONG NumberOfPages;
    PVOID QuotaObject;
} POOL_TRACKER_BIG_PAGES, *PPOOL_TRACKER_BIG_PAGES;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\po.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1994  International Business Machines Corporation

Module Name:

    po.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the NT Power Management.

Author:

    Ken Reneris (kenr) 19-July-1994
    N. Yoshiyama [IBM Corp.] 01-Mar-1994


Revision History:


--*/



#ifndef _PO_
#define _PO_

#include "xpress.h" // XPRESS declarations

//
// XPRESS compression header (LZNT1 will treat it as erroneous block)
//
#define XPRESS_HEADER_STRING        "\x81\x81xpress"
#define XPRESS_HEADER_STRING_SIZE   8

//
// size of header (shall be at least 16 and be multiple of XPRESS_ALIGNMENT)
//
#define XPRESS_HEADER_SIZE  32

//
// max # of pages Xpress may handle at once
//
#define XPRESS_MAX_PAGES (XPRESS_MAX_BLOCK >> PAGE_SHIFT)

//
// max size of block aligned on page boundary
//
#define XPRESS_MAX_SIZE (XPRESS_MAX_PAGES << PAGE_SHIFT)


#if DBG

VOID
PoPowerTracePrint(
    ULONG    TracePoint,
    ULONG_PTR Caller,
    ULONG_PTR CallerCaller,
    ULONG_PTR DeviceObject,
    ULONG_PTR Irp,
    ULONG_PTR Ios
    );

#define PoPowerTrace(TracePoint,DevObj,Arg1,Arg2) \
{\
    PVOID pptcCaller;      \
    PVOID pptcCallerCaller;  \
    RtlGetCallersAddress(&pptcCaller, &pptcCallerCaller); \
    PoPowerTracePrint(TracePoint, (ULONG_PTR)pptcCaller, (ULONG_PTR)pptcCallerCaller, (ULONG_PTR)DevObj, (ULONG_PTR)Arg1, (ULONG_PTR)Arg2); \
}
#else
#define PoPowerTrace(TracePoint,DevObj,Arg1,Arg2)
#endif

#define POWERTRACE_CALL         0x1
#define POWERTRACE_PRESENT      0x2
#define POWERTRACE_STARTNEXT    0x4
#define POWERTRACE_SETSTATE     0x8
#define POWERTRACE_COMPLETE     0x10


VOID
FASTCALL
PoInitializePrcb (
    PKPRCB      Prcb
    );

BOOLEAN
PoInitSystem (
    IN ULONG    Phase
    );

VOID
PoInitDriverServices (
    IN ULONG    Phase
    );

VOID
PoInitHiberServices (
    IN BOOLEAN  Setup
    );

VOID
PoGetDevicePowerState (
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    OUT DEVICE_POWER_STATE  *DevicePowerState
    );

VOID
PoInitializeDeviceObject (
    IN PDEVOBJ_EXTENSION   DeviceObjectExtension
    );

VOID
PoRunDownDeviceObject (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTKERNELAPI
VOID
PopCleanupPowerState (
    IN OUT PUCHAR PowerState
    );

#define PoRundownThread(Thread)     \
        PopCleanupPowerState(&Thread->Tcb.PowerState)

#define PoRundownProcess(Process)   \
        PopCleanupPowerState(&Process->Pcb.PowerState)

VOID
PoNotifySystemTimeSet (
    VOID
    );

VOID
PoInvalidateDevicePowerRelations(
    PDEVICE_OBJECT  DeviceObject
    );

VOID
PoShutdownBugCheck (
    IN BOOLEAN  AllowCrashDump,
    IN ULONG    BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// begin_nthal

NTKERNELAPI
VOID
PoSetHiberRange (
    IN PVOID     MemoryMap,
    IN ULONG     Flags,
    IN PVOID     Address,
    IN ULONG_PTR Length,
    IN ULONG     Tag
    );

// memory_range.Type
#define PO_MEM_PRESERVE         0x00000001      // memory range needs preserved
#define PO_MEM_CLONE            0x00000002      // Clone this range
#define PO_MEM_CL_OR_NCHK       0x00000004      // Either clone or do not checksum
#define PO_MEM_DISCARD          0x00008000      // This range to be removed
#define PO_MEM_PAGE_ADDRESS     0x00004000      // Arguments passed are physical pages

// end_nthal

#define PoWakeTimerSupported()  \
    (PopCapabilities.RtcWake >= PowerSystemSleeping1)

ULONG
PoSimpleCheck (
    IN ULONG                PatialSum,
    IN PVOID                StartVa,
    IN ULONG_PTR            Length
    );

BOOLEAN
PoSystemIdleWorker (
    IN BOOLEAN IdleWorker
    );

VOID
PoVolumeDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PoSetWarmEjectDevice(
    IN PDEVICE_OBJECT DeviceObject
    ) ;

NTSTATUS
PoGetLightestSystemStateForEject(
    IN   BOOLEAN              DockBeingEjected,
    IN   BOOLEAN              HotEjectSupported,
    IN   BOOLEAN              WarmEjectSupported,
    OUT  PSYSTEM_POWER_STATE  LightestSleepState
    );

// begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
VOID
PoSetSystemState (
    IN EXECUTION_STATE Flags
    );

// begin_ntifs

NTKERNELAPI
PVOID
PoRegisterSystemState (
    IN PVOID StateHandle,
    IN EXECUTION_STATE Flags
    );

// end_ntifs

typedef
VOID
(*PREQUEST_POWER_COMPLETE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PREQUEST_POWER_COMPLETE CompletionFunction,
    IN PVOID Context,
    OUT PIRP *Irp OPTIONAL
    );

NTKERNELAPI
NTSTATUS
PoRequestShutdownEvent (
    OUT PVOID *Event
    );

NTKERNELAPI
NTSTATUS
PoRequestShutdownWait (
    IN PETHREAD Thread
    );

// begin_ntifs

NTKERNELAPI
VOID
PoUnregisterSystemState (
    IN PVOID StateHandle
    );

// begin_nthal

NTKERNELAPI
POWER_STATE
PoSetPowerState (
    IN PDEVICE_OBJECT   DeviceObject,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State
    );

NTKERNELAPI
NTSTATUS
PoCallDriver (
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    );

NTKERNELAPI
VOID
PoStartNextPowerIrp(
    IN PIRP    Irp
    );


NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    IN PDEVICE_OBJECT     DeviceObject,
    IN ULONG              ConservationIdleTime,
    IN ULONG              PerformanceIdleTime,
    IN DEVICE_POWER_STATE State
    );

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5

// end_ntddk end_wdm end_nthal

// Used for queuing work items to be performed at shutdown time.  Same
// rules apply as per Ex work queues.
NTKERNELAPI
NTSTATUS
PoQueueShutdownWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    );

// end_ntosp end_ntifs

//
// Broken functions we don't intend to keep supporting. The code backing these
// should be ripped out in NT5.1
//
typedef
VOID
(*PPO_NOTIFY) (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context,
    IN ULONG            Type,
    IN ULONG            Reserved
    );

#define PO_NOTIFY_D0                        0x00000001
#define PO_NOTIFY_TRANSITIONING_FROM_D0     0x00000002
#define PO_NOTIFY_INVALID                   0x80000000

NTKERNELAPI
NTSTATUS
PoRegisterDeviceNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PPO_NOTIFY       NotificationFunction,
    IN PVOID            NotificationContext,
    IN ULONG            NotificationType,
    OUT PDEVICE_POWER_STATE  DeviceState,
    OUT PVOID           *NotificationHandle
    );

NTKERNELAPI
NTSTATUS
PoCancelDeviceNotify (
    IN PVOID            NotificationHandle
    );


//
// Callout set state failure notification
//

typedef struct {
    NTSTATUS            Status;
    POWER_ACTION        PowerAction;
    SYSTEM_POWER_STATE  MinState;
    ULONG               Flags;
} PO_SET_STATE_FAILURE, *PPO_SET_STATE_FAILURE;

//
// Hibernation file layout:
//      Page 0  - PO_MEMORY_IMAGE
//      Page 1  - Free page array
//      Page 2  - KPROCESSOR_CONTEXT
//      Page 3  - first memory_range_array page
//
// PO_MEMORY_IMAGE:
//      Header in file which contains some information to identify
//      the hibernation, as well as a couple of checksums.
//
// Free page array:
//      A page full of page numbers which identify 4MBs worth of
//      system pages that are not in the restoration image.  These
//      pages are used by the loader (to keep itself out of the way)
//      when restoring the memory image.
//
// KPROCESSOR_CONTEST
//      The context of the processor which hibernated the system.
//      Rest of page is empty.
//
// memory_range_array
//      A page which contains an array of memory_range_array elements
//      where element 0 is a Link entry, and all other elements are
//      Range entries.   The Link entry is used to link to the next
//      such page, and to supply a count of the number of Range entries
//      in the current page.   The range entries each describe one
//      physical memory range which needs restoration and its location
//      in the file.
//

typedef struct _PO_MEMORY_RANGE_ARRAY_RANGE {
    PFN_NUMBER      PageNo;
    PFN_NUMBER      StartPage;
    PFN_NUMBER      EndPage;
    ULONG           CheckSum;
} PO_MEMORY_RANGE_ARRAY_RANGE;

typedef struct _PO_MEMORY_RANGE_ARRAY_LINK {
    struct _PO_MEMORY_RANGE_ARRAY *Next;
    PFN_NUMBER NextTable;
    ULONG CheckSum;
    ULONG EntryCount;
} PO_MEMORY_RANGE_ARRAY_LINK;

typedef struct _PO_MEMORY_RANGE_ARRAY {
    union {
        PO_MEMORY_RANGE_ARRAY_RANGE Range;
        PO_MEMORY_RANGE_ARRAY_LINK Link;
    };
} PO_MEMORY_RANGE_ARRAY, *PPO_MEMORY_RANGE_ARRAY;

#define PO_MAX_RANGE_ARRAY  (PAGE_SIZE / sizeof(PO_MEMORY_RANGE_ARRAY))
#define PO_ENTRIES_PER_PAGE (PO_MAX_RANGE_ARRAY-1)


#define PO_IMAGE_SIGNATURE          'rbih'
#define PO_IMAGE_SIGNATURE_WAKE     'ekaw'
#define PO_IMAGE_SIGNATURE_BREAK    'pkrb'
#define PO_IMAGE_SIGNATURE_LINK     'knil'
#define PO_IMAGE_HEADER_PAGE        0
#define PO_FREE_MAP_PAGE            1
#define PO_PROCESSOR_CONTEXT_PAGE   2
#define PO_FIRST_RANGE_TABLE_PAGE   3

#define PO_COMPRESS_CHUNK_SIZE      4096

//
// Perf information
//
typedef struct _PO_HIBER_PERF {
    ULONGLONG               IoTicks;
    ULONGLONG               InitTicks;
    ULONGLONG               CopyTicks;
    ULONGLONG               StartCount;
    ULONG                   ElapsedTime;
    ULONG                   IoTime;
    ULONG                   CopyTime;
    ULONG                   InitTime;
    ULONG                   PagesWritten;
    ULONG                   PagesProcessed;
    ULONG                   BytesCopied;
    ULONG                   DumpCount;
    ULONG                   FileRuns;

} PO_HIBER_PERF, *PPO_HIBER_PERF;

//
// Define various HiberFlags to control the behavior when restoring
//
#define PO_HIBER_APM_RECONNECT      0x1
#define PO_HIBER_NO_EXECUTE         0x2

typedef struct {
    ULONG                   Signature;
    ULONG                   Version;
    ULONG                   CheckSum;
    ULONG                   LengthSelf;
    PFN_NUMBER              PageSelf;
    ULONG                   PageSize;

    ULONG                   ImageType;
    LARGE_INTEGER           SystemTime;
    ULONGLONG               InterruptTime;
    ULONG                   FeatureFlags;
    UCHAR                   HiberFlags;
    UCHAR                   spare[3];

    ULONG                   NoHiberPtes;
    ULONG_PTR               HiberVa;
    PHYSICAL_ADDRESS        HiberPte;

    ULONG                   NoFreePages;
    ULONG                   FreeMapCheck;
    ULONG                   WakeCheck;

    PFN_NUMBER              TotalPages;
    PFN_NUMBER              FirstTablePage;
    PFN_NUMBER              LastFilePage;

    //
    // Perf stuff
    //
    PO_HIBER_PERF           PerfInfo;
} PO_MEMORY_IMAGE, *PPO_MEMORY_IMAGE;


typedef struct {
    ULONG                   Signature;
    WCHAR                   Name[1];
} PO_IMAGE_LINK, *PPO_IMAGE_LINK;

//
// Returned by Io system
//

typedef struct _PO_DEVICE_NOTIFY {
    LIST_ENTRY              Link;
    PDEVICE_OBJECT          TargetDevice;

    BOOLEAN                 WakeNeeded;
    UCHAR                   OrderLevel;

    PDEVICE_OBJECT          DeviceObject;
    PVOID                   Node;
    PWCHAR                  DeviceName;
    PWCHAR                  DriverName;
    ULONG                   ChildCount;
    ULONG                   ActiveChild;

} PO_DEVICE_NOTIFY, *PPO_DEVICE_NOTIFY;

//
// A PO_DEVICE_NOTIFY_LEVEL structure holds all the PO_DEVICE_NOTIFY
// structures for a given level. Every PO_DEVICE_NOTIFY is on one of
// the lists. As we send power irps, the notify structure progresses
// through all the lists.
//
typedef struct _PO_NOTIFY_ORDER_LEVEL {
    KEVENT     LevelReady;
    ULONG      DeviceCount;     // number of devices on this notify level
    ULONG      ActiveCount;     // number of devices until this level is complete
    LIST_ENTRY WaitSleep;       // waiting for children to complete their Sx irps
    LIST_ENTRY ReadySleep;      // ready to receive a Sx irp
    LIST_ENTRY Pending;         // A Sx or S0 irp is outstanding
    LIST_ENTRY Complete;        // Fully awake.
    LIST_ENTRY ReadyS0;         // Ready to receive a S0 irp
    LIST_ENTRY WaitS0;          // waiting for parent to complete their S0 irp
} PO_NOTIFY_ORDER_LEVEL, *PPO_NOTIFY_ORDER_LEVEL;

#define PO_ORDER_NOT_VIDEO          0x0001
#define PO_ORDER_ROOT_ENUM          0x0002
#define PO_ORDER_PAGABLE            0x0004
#define PO_ORDER_MAXIMUM            0x0007

// notify GDI before this order level
#define PO_ORDER_GDI_NOTIFICATION   (PO_ORDER_PAGABLE)

typedef struct _PO_DEVICE_NOTIFY_ORDER {
    ULONG                   DevNodeSequence;
    PDEVICE_OBJECT          *WarmEjectPdoPointer;
    PO_NOTIFY_ORDER_LEVEL   OrderLevel[PO_ORDER_MAXIMUM+1];
} PO_DEVICE_NOTIFY_ORDER, *PPO_DEVICE_NOTIFY_ORDER;

extern KAFFINITY        PoSleepingSummary;
extern BOOLEAN          PoEnabled;
extern ULONG            PoPowerSequence;
extern BOOLEAN          PoPageLockData;
extern KTIMER           PoSystemIdleTimer;
extern BOOLEAN          PoHiberInProgress;

// PopCapabilities used by some internal macros
extern SYSTEM_POWER_CAPABILITIES PopCapabilities;

extern ULONG        PopShutdownCleanly;

// Set this flag to make general clean shutdown-related things happen
// without setting any of the more specific things.
#define PO_CLEAN_SHUTDOWN_GENERAL  (0x1)

// PO_CLEAN_SHUTDOWN_PAGING forces unlocked pageable data to become
// unavailable once paging is shut down.
#define PO_CLEAN_SHUTDOWN_PAGING   (0x2)

// PO_CLEAN_SHUTDOWN_WORKERS causes the Ex worker threads to be torn
// down at shutdown time (ensuring that their queues are flushed and
// no more work items are posted).
#define PO_CLEAN_SHUTDOWN_WORKERS  (0x4)

// PO_CLEAN_SHUTDOWN_REGISTRY causes all open registry keys to be
// dumped to the debugger at shutdown time.
#define PO_CLEAN_SHUTDOWN_REGISTRY (0x8)

// PO_CLEAN_SHUTDOWN_OB causes the object manager namespace to be
// flushed of all permanent objects, and causes ob cleanup to occur.
#define PO_CLEAN_SHUTDOWN_OB       (0x10)

// PO_CLEAN_SHUTDOWN_PNP causes PNP to QueryRemove/Remove all the PNP devices
// in the system.
#define PO_CLEAN_SHUTDOWN_PNP      (0x20)

// This function returns non-zero if the system should be shut down cleanly.
ULONG
FORCEINLINE
PoCleanShutdownEnabled(
    VOID
    )
{
    return PopShutdownCleanly;
}

// This is the worker queue which po will use for shutdown
#define PO_SHUTDOWN_QUEUE (CriticalWorkQueue)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\procpowr.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000  Microsoft Corporation

Module Name:

    procpowr.h

Abstract:

    This module contains the public (external) header file for the processor
    power states required by the PRCB.

Author:

    Stephane Plante (splante) 17-Oct-2000

Revision History:

--*/

#ifndef _PROCPOWR_H_
#define _PROCPOWR_H_

//
// Power structure in each processors PRCB
//
struct _PROCESSOR_POWER_STATE;      // forward ref

typedef
VOID
(FASTCALL *PPROCESSOR_IDLE_FUNCTION) (
    struct _PROCESSOR_POWER_STATE   *PState
    );

//
// Note: this data structure must contain a number of ULONG such that the
// next structure in the PRCB is aligned on an 16 byte boundary. Currently,
// this means that this structure must have a size that ends on the odd
// eight-byte boundary. In other words, the size of this structure must
// end in 0x8...
//

typedef struct _PROCESSOR_POWER_STATE {
    PPROCESSOR_IDLE_FUNCTION    IdleFunction;
    ULONG                       Idle0KernelTimeLimit;
    ULONG                       Idle0LastTime;

    PVOID                       IdleHandlers;
    PVOID                       IdleState;
    ULONG                       IdleHandlersCount;

    ULONGLONG                   LastCheck;
    PROCESSOR_IDLE_TIMES        IdleTimes;

    ULONG                       IdleTime1;
    ULONG                       PromotionCheck;
    ULONG                       IdleTime2;

    UCHAR                       CurrentThrottle;    // current throttle setting
    UCHAR                       ThermalThrottleLimit;   // max available throttle setting
    UCHAR                       CurrentThrottleIndex;
    UCHAR                       ThermalThrottleIndex;

    ULONG                       PerfSystemTime;
    ULONG                       PerfIdleTime;

// temp for debugging
    ULONGLONG                   DebugDelta;
    ULONG                       DebugCount;

    ULONG                       LastSysTime;
    ULONGLONG                   TotalIdleStateTime[3];
    ULONG                       TotalIdleTransitions[3];
    ULONGLONG                   PreviousC3StateTime;
    UCHAR                       KneeThrottleIndex;
    UCHAR                       ThrottleLimitIndex;
    UCHAR                       PerfStatesCount;
    UCHAR                       ProcessorMinThrottle;
    UCHAR                       ProcessorMaxThrottle;
    UCHAR                       LastBusyPercentage;
    UCHAR                       LastC3Percentage;
    UCHAR                       LastAdjustedBusyPercentage;
    ULONG                       PromotionCount;
    ULONG                       DemotionCount;
    ULONG                       ErrorCount;
    ULONG                       RetryCount;
    ULONG                       Flags;
    LARGE_INTEGER               PerfCounterFrequency;
    ULONG                       PerfTickCount;
    KTIMER                      PerfTimer;
    KDPC                        PerfDpc;
    PPROCESSOR_PERF_STATE       PerfStates;
    PSET_PROCESSOR_THROTTLE2    PerfSetThrottle;
    ULONG                       Spare1[2];
} PROCESSOR_POWER_STATE, *PPROCESSOR_POWER_STATE;

//
// Processor Power State Flags
//
#define PSTATE_SUPPORTS_THROTTLE        0x01
#define PSTATE_ADAPTIVE_THROTTLE        0x02
#define PSTATE_DEGRADED_THROTTLE        0x04
#define PSTATE_CONSTANT_THROTTLE        0x08
#define PSTATE_NOT_INITIALIZED          0x10
#define PSTATE_DISABLE_THROTTLE_NTAPI   0x20
#define PSTATE_DISABLE_THROTTLE_INRUSH  0x40
#define PSTATE_DISABLE_CSTATES          0x80
#define PSTATE_THERMAL_THROTTLE_APPLIED 0x100

//
// Useful masks
//
#define PSTATE_THROTTLE_MASK            (PSTATE_ADAPTIVE_THROTTLE | \
                                         PSTATE_DEGRADED_THROTTLE | \
                                         PSTATE_CONSTANT_THROTTLE)
#define PSTATE_CLEAR_MASK               (PSTATE_SUPPORTS_THROTTLE | \
                                         PSTATE_THROTTLE_MASK)
#define PSTATE_DISABLE_THROTTLE         (PSTATE_DISABLE_THROTTLE_NTAPI | \
                                         PSTATE_DISABLE_THROTTLE_INRUSH)

#endif // _PROCPOWR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ps.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ps.h

Abstract:

    This module contains the process structure public data structures and
    procedure prototypes to be used within the NT system.

Author:

    Mark Lucovsky       16-Feb-1989

Revision History:

--*/

#ifndef _PS_
#define _PS_


//
// Process Object
//

//
// Process object body.  A pointer to this structure is returned when a handle
// to a process object is referenced.  This structure contains a process control
// block (PCB) which is the kernel's representation of a process.
//

#define MEMORY_PRIORITY_BACKGROUND 0
#define MEMORY_PRIORITY_WASFOREGROUND 1
#define MEMORY_PRIORITY_FOREGROUND 2

typedef struct _MMSUPPORT_FLAGS {

    //
    // The next 8 bits are protected by the expansion lock.
    //

    UCHAR SessionSpace : 1;
    UCHAR BeingTrimmed : 1;
    UCHAR SessionLeader : 1;
    UCHAR TrimHard : 1;
    UCHAR MaximumWorkingSetHard : 1;
    UCHAR ForceTrim : 1;
    UCHAR MinimumWorkingSetHard : 1;
    UCHAR Available0 : 1;

    UCHAR MemoryPriority : 8;

    //
    // The next 16 bits are protected by the working set mutex.
    //

    USHORT GrowWsleHash : 1;
    USHORT AcquiredUnsafe : 1;
    USHORT Available : 14;
} MMSUPPORT_FLAGS;

typedef ULONG WSLE_NUMBER, *PWSLE_NUMBER;

typedef struct _MMSUPPORT {
    LIST_ENTRY WorkingSetExpansionLinks;
    LARGE_INTEGER LastTrimTime;

    MMSUPPORT_FLAGS Flags;
    ULONG PageFaultCount;
    WSLE_NUMBER PeakWorkingSetSize;
    WSLE_NUMBER GrowthSinceLastEstimate;

    WSLE_NUMBER MinimumWorkingSetSize;
    WSLE_NUMBER MaximumWorkingSetSize;
    struct _MMWSL *VmWorkingSetList;
    WSLE_NUMBER Claim;

    WSLE_NUMBER NextEstimationSlot;
    WSLE_NUMBER NextAgingSlot;
    WSLE_NUMBER EstimatedAvailable;
    WSLE_NUMBER WorkingSetSize;

    KGUARDED_MUTEX WorkingSetMutex;

} MMSUPPORT, *PMMSUPPORT;

typedef struct _MMADDRESS_NODE {
    union {
        LONG_PTR Balance : 2;
        struct _MMADDRESS_NODE *Parent;
    } u1;
    struct _MMADDRESS_NODE *LeftChild;
    struct _MMADDRESS_NODE *RightChild;
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;
} MMADDRESS_NODE, *PMMADDRESS_NODE;

//
// A pair of macros to deal with the packing of parent & balance in the
// MMADDRESS_NODE.
//

#define SANITIZE_PARENT_NODE(Parent) ((PMMADDRESS_NODE)(((ULONG_PTR)(Parent)) & ~0x3))

//
// Macro to carefully preserve the balance while updating the parent.
//

#define MI_MAKE_PARENT(ParentNode,ExistingBalance) \
                (PMMADDRESS_NODE)((ULONG_PTR)(ParentNode) | ((ExistingBalance) & 0x3))

typedef struct _MM_AVL_TABLE {
    MMADDRESS_NODE  BalancedRoot;
    ULONG_PTR DepthOfTree: 5;
    ULONG_PTR Unused: 3;
#if defined (_WIN64)
    ULONG_PTR NumberGenericTableElements: 56;
#else
    ULONG_PTR NumberGenericTableElements: 24;
#endif
    PVOID NodeHint;
    PVOID NodeFreeHint;
} MM_AVL_TABLE, *PMM_AVL_TABLE;

//
// Client impersonation information.
//

typedef struct _PS_IMPERSONATION_INFORMATION {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
} PS_IMPERSONATION_INFORMATION, *PPS_IMPERSONATION_INFORMATION;

//
// Audit Information structure: this is a member of the EPROCESS structure
// and currently contains only the name of the exec'ed image file.
//

typedef struct _SE_AUDIT_PROCESS_CREATION_INFO {
    POBJECT_NAME_INFORMATION ImageFileName;
} SE_AUDIT_PROCESS_CREATION_INFO, *PSE_AUDIT_PROCESS_CREATION_INFO;

typedef enum _PS_QUOTA_TYPE {
    PsNonPagedPool = 0,
    PsPagedPool    = 1,
    PsPageFile     = 2,
    PsQuotaTypes   = 3
} PS_QUOTA_TYPE, *PPS_QUOTA_TYPE;

typedef struct _EPROCESS_QUOTA_ENTRY {
    SIZE_T Usage;  // Current usage count
    SIZE_T Limit;  // Unhidered progress may be made to this point
    SIZE_T Peak;   // Peak quota usage
    SIZE_T Return; // Quota value to return to the pool once its big enough
} EPROCESS_QUOTA_ENTRY, *PEPROCESS_QUOTA_ENTRY;

//#define PS_TRACK_QUOTA 1

#define EPROCESS_QUOTA_TRACK_MAX 10000

typedef struct _EPROCESS_QUOTA_TRACK {
    SIZE_T Charge;
    PVOID Caller;
    PVOID FreeCaller;
    PVOID Process;
} EPROCESS_QUOTA_TRACK, *PEPROCESS_QUOTA_TRACK;

typedef struct _EPROCESS_QUOTA_BLOCK {
    EPROCESS_QUOTA_ENTRY QuotaEntry[PsQuotaTypes];
    LIST_ENTRY QuotaList; // All additional quota blocks are chained through here
    ULONG ReferenceCount;
    ULONG ProcessCount; // Total number of processes still referencing this block
#if defined (PS_TRACK_QUOTA)
    EPROCESS_QUOTA_TRACK Tracker[2][EPROCESS_QUOTA_TRACK_MAX];
#endif
} EPROCESS_QUOTA_BLOCK, *PEPROCESS_QUOTA_BLOCK;

//
// Pagefault monitoring.
//

typedef struct _PAGEFAULT_HISTORY {
    ULONG CurrentIndex;
    ULONG MaxIndex;
    KSPIN_LOCK SpinLock;
    PVOID Reserved;
    PROCESS_WS_WATCH_INFORMATION WatchInfo[1];
} PAGEFAULT_HISTORY, *PPAGEFAULT_HISTORY;

#define PS_WS_TRIM_FROM_EXE_HEADER        1
#define PS_WS_TRIM_BACKGROUND_ONLY_APP    2

//
// Wow64 process stucture.
//



typedef struct _WOW64_PROCESS {
    PVOID Wow64;
#if defined(_IA64_)
    KGUARDED_MUTEX AlternateTableLock;
    PULONG AltPermBitmap;
#endif
} WOW64_PROCESS, *PWOW64_PROCESS;

#if defined (_WIN64)
#define PS_GET_WOW64_PROCESS(Process) ((Process)->Wow64Process)
#else
#define PS_GET_WOW64_PROCESS(Process) ((Process), ((PWOW64_PROCESS)NULL))
#endif

#define PS_SET_BITS(Flags, Flag) \
    RtlInterlockedSetBitsDiscardReturn (Flags, Flag)

#define PS_TEST_SET_BITS(Flags, Flag) \
    RtlInterlockedSetBits (Flags, Flag)

#define PS_CLEAR_BITS(Flags, Flag) \
    RtlInterlockedClearBitsDiscardReturn (Flags, Flag)

#define PS_TEST_CLEAR_BITS(Flags, Flag) \
    RtlInterlockedClearBits (Flags, Flag)

#define PS_SET_CLEAR_BITS(Flags, sFlag, cFlag) \
    RtlInterlockedSetClearBits (Flags, sFlag, cFlag)

#define PS_TEST_ALL_BITS_SET(Flags, Bits) \
    ((Flags&(Bits)) == (Bits))

// Process structure.
//
// If you remove a field from this structure, please also
// remove the reference to it from within the kernel debugger
// (nt\private\sdktools\ntsd\ntkext.c)
//

typedef struct _EPROCESS {
    KPROCESS Pcb;

    //
    // Lock used to protect:
    // The list of threads in the process.
    // Process token.
    // Win32 process field.
    // Process and thread affinity setting.
    //

    EX_PUSH_LOCK ProcessLock;

    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;

    //
    // Structure to allow lock free cross process access to the process
    // handle table, process section and address space. Acquire rundown
    // protection with this if you do cross process handle table, process
    // section or address space references.
    //

    EX_RUNDOWN_REF RundownProtect;

    HANDLE UniqueProcessId;

    //
    // Global list of all processes in the system. Processes are removed
    // from this list in the object deletion routine.  References to
    // processes in this list must be done with ObReferenceObjectSafe
    // because of this.
    //

    LIST_ENTRY ActiveProcessLinks;

    //
    // Quota Fields.
    //

    SIZE_T QuotaUsage[PsQuotaTypes];
    SIZE_T QuotaPeak[PsQuotaTypes];
    SIZE_T CommitCharge;

    //
    // VmCounters.
    //

    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;

    LIST_ENTRY SessionProcessLinks;

    PVOID DebugPort;
    PVOID ExceptionPort;
    PHANDLE_TABLE ObjectTable;

    //
    // Security.
    //

    EX_FAST_REF Token;

    PFN_NUMBER WorkingSetPage;
    KGUARDED_MUTEX AddressCreationLock;
    KSPIN_LOCK HyperSpaceLock;

    struct _ETHREAD *ForkInProgress;
    ULONG_PTR HardwareTrigger;

    PMM_AVL_TABLE PhysicalVadRoot;
    PVOID CloneRoot;
    PFN_NUMBER NumberOfPrivatePages;
    PFN_NUMBER NumberOfLockedPages;
    PVOID Win32Process;
    struct _EJOB *Job;
    PVOID SectionObject;

    PVOID SectionBaseAddress;

    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    PPAGEFAULT_HISTORY WorkingSetWatch;
    HANDLE Win32WindowStation;
    HANDLE InheritedFromUniqueProcessId;

    PVOID LdtInformation;
    PVOID VadFreeHint;
    PVOID VdmObjects;
    PVOID DeviceMap;

    PVOID Spare0[3];
    union {
        HARDWARE_PTE PageDirectoryPte;
        ULONGLONG Filler;
    };
    PVOID Session;
    UCHAR ImageFileName[ 16 ];

    LIST_ENTRY JobLinks;
    PVOID LockedPagesList;

    LIST_ENTRY ThreadListHead;

    //
    // Used by rdr/security for authentication.
    //

    PVOID SecurityPort;

#ifdef _WIN64
    PWOW64_PROCESS Wow64Process;
#else
    PVOID PaeTop;
#endif

    ULONG ActiveThreads;

    ACCESS_MASK GrantedAccess;

    ULONG DefaultHardErrorProcessing;

    NTSTATUS LastThreadExitStatus;

    //
    // Peb
    //

    PPEB Peb;

    //
    // Pointer to the prefetches trace block.
    //
    EX_FAST_REF PrefetchTrace;

    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;

    SIZE_T CommitChargeLimit;
    SIZE_T CommitChargePeak;

    PVOID AweInfo;

    //
    // This is used for SeAuditProcessCreation.
    // It contains the full path to the image file.
    //

    SE_AUDIT_PROCESS_CREATION_INFO SeAuditProcessCreationInfo;

    MMSUPPORT Vm;

#if !defined(_WIN64)
    LIST_ENTRY MmProcessLinks;
#else
    ULONG Spares[2];
#endif

    ULONG ModifiedPageCount;

    #define PS_JOB_STATUS_NOT_REALLY_ACTIVE      0x00000001UL
    #define PS_JOB_STATUS_ACCOUNTING_FOLDED      0x00000002UL
    #define PS_JOB_STATUS_NEW_PROCESS_REPORTED   0x00000004UL
    #define PS_JOB_STATUS_EXIT_PROCESS_REPORTED  0x00000008UL
    #define PS_JOB_STATUS_REPORT_COMMIT_CHANGES  0x00000010UL
    #define PS_JOB_STATUS_LAST_REPORT_MEMORY     0x00000020UL
    #define PS_JOB_STATUS_REPORT_PHYSICAL_PAGE_CHANGES  0x00000040UL

    ULONG JobStatus;


    //
    // Process flags. Use interlocked operations with PS_SET_BITS, etc
    // to modify these.
    //

    #define PS_PROCESS_FLAGS_CREATE_REPORTED        0x00000001UL // Create process debug call has occurred
    #define PS_PROCESS_FLAGS_NO_DEBUG_INHERIT       0x00000002UL // Don't inherit debug port
    #define PS_PROCESS_FLAGS_PROCESS_EXITING        0x00000004UL // PspExitProcess entered
    #define PS_PROCESS_FLAGS_PROCESS_DELETE         0x00000008UL // Delete process has been issued
    #define PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES      0x00000010UL // Wow64 split pages
    #define PS_PROCESS_FLAGS_VM_DELETED             0x00000020UL // VM is deleted
    #define PS_PROCESS_FLAGS_OUTSWAP_ENABLED        0x00000040UL // Outswap enabled
    #define PS_PROCESS_FLAGS_OUTSWAPPED             0x00000080UL // Outswapped
    #define PS_PROCESS_FLAGS_FORK_FAILED            0x00000100UL // Fork status
    #define PS_PROCESS_FLAGS_WOW64_4GB_VA_SPACE     0x00000200UL // Wow64 process with 4gb virtual address space
    #define PS_PROCESS_FLAGS_ADDRESS_SPACE1         0x00000400UL // Addr space state1
    #define PS_PROCESS_FLAGS_ADDRESS_SPACE2         0x00000800UL // Addr space state2
    #define PS_PROCESS_FLAGS_SET_TIMER_RESOLUTION   0x00001000UL // SetTimerResolution has been called
    #define PS_PROCESS_FLAGS_BREAK_ON_TERMINATION   0x00002000UL // Break on process termination
    #define PS_PROCESS_FLAGS_CREATING_SESSION       0x00004000UL // Process is creating a session
    #define PS_PROCESS_FLAGS_USING_WRITE_WATCH      0x00008000UL // Process is using the write watch APIs
    #define PS_PROCESS_FLAGS_IN_SESSION             0x00010000UL // Process is in a session
    #define PS_PROCESS_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00020000UL // Process must use native address space (Win64 only)
    #define PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE      0x00040000UL // This process has an address space
    #define PS_PROCESS_FLAGS_LAUNCH_PREFETCHED      0x00080000UL // Process launch was prefetched
    #define PS_PROCESS_INJECT_INPAGE_ERRORS         0x00100000UL // Process should be given inpage errors - hardcoded in trap.asm too
    #define PS_PROCESS_FLAGS_VM_TOP_DOWN            0x00200000UL // Process memory allocations default to top-down
    #define PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE      0x00400000UL // We have sent a message for this image
    #define PS_PROCESS_FLAGS_PDE_UPDATE_NEEDED      0x00800000UL // The system PDEs need updating for this process (NT32 only)
    #define PS_PROCESS_FLAGS_VDM_ALLOWED            0x01000000UL // Process allowed to invoke NTVDM support

    union {

        ULONG Flags;

        //
        // Fields can only be set by the PS_SET_BITS and other interlocked
        // macros.  Reading fields is best done via the bit definitions so
        // references are easy to locate.
        //

        struct {
            ULONG CreateReported            : 1;
            ULONG NoDebugInherit            : 1;
            ULONG ProcessExiting            : 1;
            ULONG ProcessDelete             : 1;
            ULONG Wow64SplitPages           : 1;
            ULONG VmDeleted                 : 1;
            ULONG OutswapEnabled            : 1;
            ULONG Outswapped                : 1;
            ULONG ForkFailed                : 1;
            ULONG Wow64VaSpace4Gb           : 1;
            ULONG AddressSpaceInitialized   : 2;
            ULONG SetTimerResolution        : 1;
            ULONG BreakOnTermination        : 1;
            ULONG SessionCreationUnderway   : 1;
            ULONG WriteWatch                : 1;
            ULONG ProcessInSession          : 1;
            ULONG OverrideAddressSpace      : 1;
            ULONG HasAddressSpace           : 1;
            ULONG LaunchPrefetched          : 1;
            ULONG InjectInpageErrors        : 1;
            ULONG VmTopDown                 : 1;
            ULONG ImageNotifyDone           : 1;
            ULONG PdeUpdateNeeded           : 1;    // NT32 only
            ULONG VdmAllowed                : 1;
            ULONG Unused                    : 7;
        };
    };

    NTSTATUS ExitStatus;

    USHORT NextPageColor;
    union {
        struct {
            UCHAR SubSystemMinorVersion;
            UCHAR SubSystemMajorVersion;
        };
        USHORT SubSystemVersion;
    };
    UCHAR PriorityClass;

    MM_AVL_TABLE VadRoot;

} EPROCESS;


typedef EPROCESS *PEPROCESS;

//
// Thread termination port
//

typedef struct _TERMINATION_PORT {
    struct _TERMINATION_PORT *Next;
    PVOID Port;
} TERMINATION_PORT, *PTERMINATION_PORT;


// Thread Object
//
// Thread object body.  A pointer to this structure is returned when a handle
// to a thread object is referenced.  This structure contains a thread control
// block (TCB) which is the kernel's representation of a thread.
//

//
// The upper 4 bits of the CreateTime should be zero on initialization so
// that the shift doesn't destroy anything.
//

#define PS_GET_THREAD_CREATE_TIME(Thread) ((Thread)->CreateTime.QuadPart >> 3)

#define PS_SET_THREAD_CREATE_TIME(Thread, InputCreateTime) \
            ((Thread)->CreateTime.QuadPart = (InputCreateTime.QuadPart << 3))

//
// Macro to return TRUE if the specified thread is impersonating.
//

#define PS_IS_THREAD_IMPERSONATING(Thread) (((Thread)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_IMPERSONATING) != 0)

typedef struct _ETHREAD {
    KTHREAD Tcb;
    union {

        //
        // The fact that this is a union means that all accesses to CreateTime
        // must be sanitized using the two macros above.
        //

        LARGE_INTEGER CreateTime;

        //
        // These fields are accessed only by the owning thread, but can be
        // accessed from within a special kernel APC so IRQL protection must
        // be applied.
        //

        struct {
            unsigned NestedFaultCount : 2;
            unsigned ApcNeeded : 1;
        };
    };

    union {
        LARGE_INTEGER ExitTime;
        LIST_ENTRY LpcReplyChain;
        LIST_ENTRY KeyedWaitChain;
    };
    union {
        NTSTATUS ExitStatus;
        PVOID OfsChain;
    };

    //
    // Registry
    //

    LIST_ENTRY PostBlockList;

    //
    // Single linked list of termination blocks
    //

    union {
        //
        // List of termination ports
        //

        PTERMINATION_PORT TerminationPort;

        //
        // List of threads to be reaped. Only used at thread exit
        //

        struct _ETHREAD *ReaperLink;

        //
        // Keyvalue being waited for
        //
        PVOID KeyedWaitValue;

    };

    KSPIN_LOCK ActiveTimerListLock;
    LIST_ENTRY ActiveTimerListHead;

    CLIENT_ID Cid;

    //
    // Lpc
    //

    union {
        KSEMAPHORE LpcReplySemaphore;
        KSEMAPHORE KeyedWaitSemaphore;
    };

    union {
        PVOID LpcReplyMessage;          // -> Message that contains the reply
        PVOID LpcWaitingOnPort;
    };

    //
    // Security
    //
    //
    //    Client - If non null, indicates the thread is impersonating
    //        a client.
    //

    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    //
    // Io
    //

    LIST_ENTRY IrpList;

    //
    //  File Systems
    //

    ULONG_PTR TopLevelIrp;  // either NULL, an Irp or a flag defined in FsRtl.h
    struct _DEVICE_OBJECT *DeviceToVerify;

    PEPROCESS ThreadsProcess;
    PVOID StartAddress;
    union {
        PVOID Win32StartAddress;
        ULONG LpcReceivedMessageId;
    };
    //
    // Ps
    //

    LIST_ENTRY ThreadListEntry;

    //
    // Rundown protection structure. Acquire this to do cross thread
    // TEB, TEB32 or stack references.
    //

    EX_RUNDOWN_REF RundownProtect;

    //
    // Lock to protect thread impersonation information
    //
    EX_PUSH_LOCK ThreadLock;

    ULONG LpcReplyMessageId;    // MessageId this thread is waiting for reply to

    ULONG ReadClusterSize;

    //
    // Client/server
    //

    ACCESS_MASK GrantedAccess;

    //
    // Flags for cross thread access. Use interlocked operations
    // via PS_SET_BITS etc.
    //

    //
    // Used to signify that the delete APC has been queued or the
    // thread has called PspExitThread itself.
    //

    #define PS_CROSS_THREAD_FLAGS_TERMINATED           0x00000001UL

    //
    // Thread create failed
    //

    #define PS_CROSS_THREAD_FLAGS_DEADTHREAD           0x00000002UL

    //
    // Debugger isn't shown this thread
    //

    #define PS_CROSS_THREAD_FLAGS_HIDEFROMDBG          0x00000004UL

    //
    // Thread is impersonating
    //

    #define PS_CROSS_THREAD_FLAGS_IMPERSONATING        0x00000008UL

    //
    // This is a system thread
    //

    #define PS_CROSS_THREAD_FLAGS_SYSTEM               0x00000010UL

    //
    // Hard errors are disabled for this thread
    //

    #define PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED 0x00000020UL

    //
    // We should break in when this thread is terminated
    //

    #define PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION 0x00000040UL

    //
    // This thread should skip sending its create thread message
    //
    #define PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG    0x00000080UL

    //
    // This thread should skip sending its final thread termination message
    //
    #define PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG 0x00000100UL

    union {

        ULONG CrossThreadFlags;

        //
        // The following fields are for the debugger only. Do not use.
        // Use the bit definitions instead.
        //

        struct {
            ULONG Terminated              : 1;
            ULONG DeadThread              : 1;
            ULONG HideFromDebugger        : 1;
            ULONG ActiveImpersonationInfo : 1;
            ULONG SystemThread            : 1;
            ULONG HardErrorsAreDisabled   : 1;
            ULONG BreakOnTermination      : 1;
            ULONG SkipCreationMsg         : 1;
            ULONG SkipTerminationMsg      : 1;
        };
    };

    //
    // Flags to be accessed in this thread's context only at PASSIVE
    // level -- no need to use interlocked operations.
    //

    union {
        ULONG SameThreadPassiveFlags;

        struct {

            //
            // This thread is an active Ex worker thread; it should
            // not terminate.
            //

            ULONG ActiveExWorker : 1;
            ULONG ExWorkerCanWaitUser : 1;
            ULONG MemoryMaker : 1;

            //
            // Thread is active inthe keyed event code. LPC should not run above this in an APC.
            //
            ULONG KeyedEventInUse : 1;
        };
    };

    //
    // Flags to be accessed in this thread's context only at APC_LEVEL.
    // No need to use interlocked operations.
    //

    union {
        ULONG SameThreadApcFlags;
        struct {

            //
            // The stored thread's MSGID is valid. This is only accessed
            // while the LPC mutex is held so it's an APC_LEVEL flag.
            //

            BOOLEAN LpcReceivedMsgIdValid : 1;
            BOOLEAN LpcExitThreadCalled   : 1;
            BOOLEAN AddressSpaceOwner     : 1;
        };
    };

    BOOLEAN ForwardClusterOnly;
    BOOLEAN DisablePageFaultClustering;

#if defined (PERF_DATA)
    ULONG PerformanceCountLow;
    LONG PerformanceCountHigh;
#endif

} ETHREAD;

typedef ETHREAD *PETHREAD;


//
// The following two inline functions allow a thread or process object to
// be converted into a kernel thread or process, respectively, without
// having to expose the ETHREAD and EPROCESS definitions to the world.
//
// These functions take advantage of the fact that the kernel structures
// appear as the first element in the respective object structures.
//
// The C_ASSERTs that follow ensure that this is the case.
//

// begin_ntosp

PKTHREAD
FORCEINLINE
PsGetKernelThread(
    IN PETHREAD ThreadObject
    )
{
    return (PKTHREAD)ThreadObject;
}

PKPROCESS
FORCEINLINE
PsGetKernelProcess(
    IN PEPROCESS ProcessObject
    )
{
    return (PKPROCESS)ProcessObject;
}

NTSTATUS
PsGetContextThread(
    IN PETHREAD Thread,
    IN OUT PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

NTSTATUS
PsSetContextThread(
    IN PETHREAD Thread,
    IN PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

// end_ntosp

C_ASSERT( FIELD_OFFSET(ETHREAD,Tcb) == 0 );
C_ASSERT( FIELD_OFFSET(EPROCESS,Pcb) == 0 );

//
// Initial PEB
//

typedef struct _INITIAL_PEB {
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    HANDLE Mutant;                      // PEB structure is also updated.
} INITIAL_PEB, *PINITIAL_PEB;

typedef struct _PS_JOB_TOKEN_FILTER {
    ULONG CapturedSidCount ;
    PSID_AND_ATTRIBUTES CapturedSids ;
    ULONG CapturedSidsLength ;

    ULONG CapturedGroupCount ;
    PSID_AND_ATTRIBUTES CapturedGroups ;
    ULONG CapturedGroupsLength ;

    ULONG CapturedPrivilegeCount ;
    PLUID_AND_ATTRIBUTES CapturedPrivileges ;
    ULONG CapturedPrivilegesLength ;
} PS_JOB_TOKEN_FILTER, * PPS_JOB_TOKEN_FILTER ;

//
// Job Object
//
typedef struct _EJOB {
    KEVENT Event;

    //
    // All jobs are chained together via this list.
    // Protected by the global lock PspJobListLock
    //

    LIST_ENTRY JobLinks;

    //
    // All processes within this job. Processes are removed from this
    // list at last dereference. Safe object referencing needs to be done.
    // Protected by the joblock.
    //

    LIST_ENTRY ProcessListHead;
    ERESOURCE JobLock;

    //
    // Accounting Info
    //

    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    ULONG TotalPageFaultCount;
    ULONG TotalProcesses;
    ULONG ActiveProcesses;
    ULONG TotalTerminatedProcesses;

    //
    // Limitable Attributes
    //

    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    ULONG LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    ULONG ActiveProcessLimit;
    KAFFINITY Affinity;
    UCHAR PriorityClass;

    //
    // UI restrictions
    //

    ULONG UIRestrictionsClass;

    //
    // Security Limitations:  write once, read always
    //

    ULONG SecurityLimitFlags;
    PACCESS_TOKEN Token;
    PPS_JOB_TOKEN_FILTER Filter;

    //
    // End Of Job Time Limit
    //

    ULONG EndOfJobTimeAction;
    PVOID CompletionPort;
    PVOID CompletionKey;

    ULONG SessionId;

    ULONG SchedulingClass;

    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;

    //
    // Extended Limits
    //

    IO_COUNTERS IoInfo;         // not used yet
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
    SIZE_T CurrentJobMemoryUsed;

    KGUARDED_MUTEX MemoryLimitsLock;

    //
    // List of jobs in a job set. Processes within a job in a job set
    // can create processes in the same or higher members of the jobset.
    // Protected by the global lock PspJobListLock
    //

    LIST_ENTRY JobSetLinks;

    //
    // Member level for this job in the jobset.
    //

    ULONG MemberLevel;

    //
    // This job has had its last handle closed.
    //

#define PS_JOB_FLAGS_CLOSE_DONE 0x1UL

    ULONG JobFlags;
} EJOB;
typedef EJOB *PEJOB;


//
// Global Variables
//

extern ULONG PsPrioritySeperation;
extern ULONG PsRawPrioritySeparation;
extern LIST_ENTRY PsActiveProcessHead;
extern const UNICODE_STRING PsNtDllPathName;
extern PVOID PsSystemDllBase;
extern PEPROCESS PsInitialSystemProcess;
extern PVOID PsNtosImageBase;
extern PVOID PsHalImageBase;

#if defined(_AMD64_) || defined(_IA64_)

extern INVERTED_FUNCTION_TABLE PsInvertedFunctionTable;

#endif

extern LIST_ENTRY PsLoadedModuleList;
extern ERESOURCE PsLoadedModuleResource;
extern KSPIN_LOCK PsLoadedModuleSpinLock;
extern LCID PsDefaultSystemLocaleId;
extern LCID PsDefaultThreadLocaleId;
extern LANGID PsDefaultUILanguageId;
extern LANGID PsInstallUILanguageId;
extern PEPROCESS PsIdleProcess;
extern SINGLE_LIST_ENTRY PsReaperListHead;
extern WORK_QUEUE_ITEM PsReaperWorkItem;

#define PS_EMBEDDED_NO_USERMODE 1 // no user mode code will run on the system

extern ULONG PsEmbeddedNTMask;

BOOLEAN
PsChangeJobMemoryUsage(
    IN ULONG Flags,
    IN SSIZE_T Amount
    );

VOID
PsReportProcessMemoryLimitViolation(
    VOID
    );

#define THREAD_HIT_SLOTS 750

extern ULONG PsThreadHits[THREAD_HIT_SLOTS];

VOID
PsThreadHit(
    IN PETHREAD Thread
    );

VOID
PsEnforceExecutionTimeLimits(
    VOID
    );

BOOLEAN
PsInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
PsMapSystemDll (
    IN PEPROCESS Process,
    OUT PVOID *DllBase OPTIONAL
    );

VOID
PsInitializeQuotaSystem (
    VOID
    );

LOGICAL
PsShutdownSystem (
    VOID
    );

BOOLEAN
PsWaitForAllProcesses (
    VOID);

NTSTATUS
PsLocateSystemDll (
    BOOLEAN ReplaceExisting
    );

VOID
PsChangeQuantumTable(
    BOOLEAN ModifyActiveProcesses,
    ULONG PrioritySeparation
    );

//
// Get Gurrent Prototypes
//
#define THREAD_TO_PROCESS(Thread) ((Thread)->ThreadsProcess)
#define IS_SYSTEM_THREAD(Thread)  (((Thread)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SYSTEM) != 0)


#define _PsGetCurrentProcess() (CONTAINING_RECORD(((KeGetCurrentThread())->ApcState.Process),EPROCESS,Pcb))
#define PsGetCurrentProcessByThread(xCurrentThread) (ASSERT((xCurrentThread) == PsGetCurrentThread ()),CONTAINING_RECORD(((xCurrentThread)->Tcb.ApcState.Process),EPROCESS,Pcb))

#define _PsGetCurrentThread() (CONTAINING_RECORD((KeGetCurrentThread()),ETHREAD,Tcb))

#if defined(_NTOSP_)

// begin_ntosp
NTKERNELAPI
PEPROCESS
PsGetCurrentProcess(
    VOID
    );

NTKERNELAPI
PETHREAD
PsGetCurrentThread(
    VOID
    );
// end_ntosp

 #else

#define PsGetCurrentProcess() _PsGetCurrentProcess()

#define PsGetCurrentThread() _PsGetCurrentThread()

#endif



//
// Exit kernel mode APC routine.
//

VOID
PsExitSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTSTATUS
PsCreateSystemProcess(
    OUT PHANDLE ProcessHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );

typedef
VOID (*PLEGO_NOTIFY_ROUTINE)(
    PKTHREAD Thread
    );

ULONG
PsSetLegoNotifyRoutine(
    PLEGO_NOTIFY_ROUTINE LegoNotifyRoutine
    );

// begin_ntifs begin_ntddk

typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE)(
    IN HANDLE ParentId,
    IN HANDLE ProcessId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateProcessNotifyRoutine(
    IN PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    );

typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN HANDLE ProcessId,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

NTSTATUS
PsRemoveCreateThreadNotifyRoutine (
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

//
// Structures for Load Image Notify
//

typedef struct _IMAGE_INFO {
    union {
        ULONG Properties;
        struct {
            ULONG ImageAddressingMode  : 8;  // code addressing mode
            ULONG SystemModeImage      : 1;  // system mode image
            ULONG ImageMappedToAllPids : 1;  // image mapped into all processes
            ULONG Reserved             : 22;
        };
    };
    PVOID       ImageBase;
    ULONG       ImageSelector;
    SIZE_T      ImageSize;
    ULONG       ImageSectionNumber;
} IMAGE_INFO, *PIMAGE_INFO;

#define IMAGE_ADDRESSING_MODE_32BIT     3

typedef
VOID
(*PLOAD_IMAGE_NOTIFY_ROUTINE)(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,                // pid into which image is being mapped
    IN PIMAGE_INFO ImageInfo
    );

NTSTATUS
PsSetLoadImageNotifyRoutine(
    IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );

NTSTATUS
PsRemoveLoadImageNotifyRoutine(
    IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );

// end_ntddk

//
// Security Support
//

NTSTATUS
PsAssignImpersonationToken(
    IN PETHREAD Thread,
    IN HANDLE Token
    );

// begin_ntosp

NTKERNELAPI
PACCESS_TOKEN
PsReferencePrimaryToken(
    IN PEPROCESS Process
    );

VOID
PsDereferencePrimaryToken(
    IN PACCESS_TOKEN PrimaryToken
    );

VOID
PsDereferenceImpersonationToken(
    IN PACCESS_TOKEN ImpersonationToken
    );

// end_ntifs
// end_ntosp


#define PsDereferencePrimaryTokenEx(P,T) (ObFastDereferenceObject (&P->Token,(T)))

#define PsDereferencePrimaryToken(T) (ObDereferenceObject((T)))

#define PsDereferenceImpersonationToken(T)                                    \
            {if (ARGUMENT_PRESENT((T))) {                                     \
                (ObDereferenceObject((T)));                                   \
             } else {                                                         \
                ;                                                             \
             }                                                                \
            }


#define PsProcessAuditId(Process)    ((Process)->UniqueProcessId)

// begin_ntosp
// begin_ntifs

NTKERNELAPI
PACCESS_TOKEN
PsReferenceImpersonationToken(
    IN PETHREAD Thread,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

// end_ntifs

PACCESS_TOKEN
PsReferenceEffectiveToken(
    IN PETHREAD Thread,
    OUT PTOKEN_TYPE TokenType,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

// begin_ntifs



LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    );

// end_ntifs
// end_ntosp

#if defined(_NTDDK_) || defined(_NTIFS_)

// begin_ntifs begin_ntosp
BOOLEAN
PsIsThreadTerminating(
    IN PETHREAD Thread
    );

// end_ntifs end_ntosp

#else

//
// BOOLEAN
// PsIsThreadTerminating(
//   IN PETHREAD Thread
//   )
//
//  Returns TRUE if thread is in the process of terminating.
//

#define PsIsThreadTerminating(T)                                            \
    (((T)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) != 0)

#endif

extern BOOLEAN PsImageNotifyEnabled;

VOID
PsCallImageNotifyRoutines(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,                // pid into which image is being mapped
    IN PIMAGE_INFO ImageInfo
    );

// begin_ntifs
// begin_ntosp

NTSTATUS
PsImpersonateClient(
    IN PETHREAD Thread,
    IN PACCESS_TOKEN Token,
    IN BOOLEAN CopyOnOpen,
    IN BOOLEAN EffectiveOnly,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

// end_ntosp

BOOLEAN
PsDisableImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState
    );

VOID
PsRestoreImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState
    );

// end_ntifs

// begin_ntosp begin_ntifs

NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );

// end_ntifs

NTKERNELAPI
VOID
PsRevertThreadToSelf(
    PETHREAD Thread
    );

// end_ntosp


NTSTATUS
PsOpenTokenOfThread(
    IN HANDLE ThreadHandle,
    IN BOOLEAN OpenAsSelf,
    OUT PACCESS_TOKEN *Token,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

NTSTATUS
PsOpenTokenOfProcess(
    IN HANDLE ProcessHandle,
    OUT PACCESS_TOKEN *Token
    );

NTSTATUS
PsOpenTokenOfJob(
    IN HANDLE JobHandle,
    OUT PACCESS_TOKEN * Token
    );

//
// Cid
//

NTSTATUS
PsLookupProcessThreadByCid(
    IN PCLIENT_ID Cid,
    OUT PEPROCESS *Process OPTIONAL,
    OUT PETHREAD *Thread
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    IN HANDLE ProcessId,
    OUT PEPROCESS *Process
    );

NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
    IN HANDLE ThreadId,
    OUT PETHREAD *Thread
    );

// begin_ntifs
//
// Quota Operations
//

VOID
PsChargePoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

NTSTATUS
PsChargeProcessPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

VOID
PsReturnPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

// end_ntifs
// end_ntosp

NTSTATUS
PsChargeProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    );

VOID
PsReturnProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    );

NTSTATUS
PsChargeProcessNonPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );

VOID
PsReturnProcessNonPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );

NTSTATUS
PsChargeProcessPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );

VOID
PsReturnProcessPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );

NTSTATUS
PsChargeProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );

VOID
PsReturnProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    );


//
// Context Management
//

VOID
PspContextToKframes(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT Context
    );

VOID
PspContextFromKframes(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT Context
    );

VOID
PsReturnSharedPoolQuota(
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN ULONG_PTR PagedAmount,
    IN ULONG_PTR NonPagedAmount
    );

PEPROCESS_QUOTA_BLOCK
PsChargeSharedPoolQuota(
    IN PEPROCESS Process,
    IN ULONG_PTR PagedAmount,
    IN ULONG_PTR NonPagedAmount
    );


//
// Exception Handling
//

BOOLEAN
PsForwardException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN DebugException,
    IN BOOLEAN SecondChance
    );

// begin_ntosp

typedef
NTSTATUS
(*PKWIN32_PROCESS_CALLOUT) (
    IN PEPROCESS Process,
    IN BOOLEAN Initialize
    );


typedef enum _PSW32JOBCALLOUTTYPE {
    PsW32JobCalloutSetInformation,
    PsW32JobCalloutAddProcess,
    PsW32JobCalloutTerminate
} PSW32JOBCALLOUTTYPE;

typedef struct _WIN32_JOBCALLOUT_PARAMETERS {
    PVOID Job;
    PSW32JOBCALLOUTTYPE CalloutType;
    IN PVOID Data;
} WIN32_JOBCALLOUT_PARAMETERS, *PKWIN32_JOBCALLOUT_PARAMETERS;


typedef
NTSTATUS
(*PKWIN32_JOB_CALLOUT) (
    IN PKWIN32_JOBCALLOUT_PARAMETERS Parm
     );


typedef enum _PSW32THREADCALLOUTTYPE {
    PsW32ThreadCalloutInitialize,
    PsW32ThreadCalloutExit
} PSW32THREADCALLOUTTYPE;

typedef
NTSTATUS
(*PKWIN32_THREAD_CALLOUT) (
    IN PETHREAD Thread,
    IN PSW32THREADCALLOUTTYPE CalloutType
    );

typedef enum _PSPOWEREVENTTYPE {
    PsW32FullWake,
    PsW32EventCode,
    PsW32PowerPolicyChanged,
    PsW32SystemPowerState,
    PsW32SystemTime,
    PsW32DisplayState,
    PsW32CapabilitiesChanged,
    PsW32SetStateFailed,
    PsW32GdiOff,
    PsW32GdiOn
} PSPOWEREVENTTYPE;

typedef struct _WIN32_POWEREVENT_PARAMETERS {
    PSPOWEREVENTTYPE EventNumber;
    ULONG_PTR Code;
} WIN32_POWEREVENT_PARAMETERS, *PKWIN32_POWEREVENT_PARAMETERS;



typedef enum _POWERSTATETASK {
    PowerState_BlockSessionSwitch,
    PowerState_Init,
    PowerState_QueryApps,
    PowerState_QueryFailed,
    PowerState_SuspendApps,
    PowerState_ShowUI,
    PowerState_NotifyWL,
    PowerState_ResumeApps,
    PowerState_UnBlockSessionSwitch

} POWERSTATETASK;

typedef struct _WIN32_POWERSTATE_PARAMETERS {
    BOOLEAN Promotion;
    POWER_ACTION SystemAction;
    SYSTEM_POWER_STATE MinSystemState;
    ULONG Flags;
    BOOLEAN fQueryDenied;
    POWERSTATETASK PowerStateTask;
} WIN32_POWERSTATE_PARAMETERS, *PKWIN32_POWERSTATE_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_POWEREVENT_CALLOUT) (
    IN PKWIN32_POWEREVENT_PARAMETERS Parm
    );

typedef
NTSTATUS
(*PKWIN32_POWERSTATE_CALLOUT) (
    IN PKWIN32_POWERSTATE_PARAMETERS Parm
    );

typedef
NTSTATUS
(*PKWIN32_OBJECT_CALLOUT) (
    IN PVOID Parm
    );



typedef struct _WIN32_CALLOUTS_FPNS {
    PKWIN32_PROCESS_CALLOUT ProcessCallout;
    PKWIN32_THREAD_CALLOUT ThreadCallout;
    PKWIN32_GLOBALATOMTABLE_CALLOUT GlobalAtomTableCallout;
    PKWIN32_POWEREVENT_CALLOUT PowerEventCallout;
    PKWIN32_POWERSTATE_CALLOUT PowerStateCallout;
    PKWIN32_JOB_CALLOUT JobCallout;
    PVOID BatchFlushRoutine;
    PKWIN32_OBJECT_CALLOUT DesktopOpenProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopOkToCloseProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopCloseProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopDeleteProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationOkToCloseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationCloseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationDeleteProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationParseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationOpenProcedure;
} WIN32_CALLOUTS_FPNS, *PKWIN32_CALLOUTS_FPNS;

NTKERNELAPI
VOID
PsEstablishWin32Callouts(
    IN PKWIN32_CALLOUTS_FPNS pWin32Callouts
    );

typedef enum _PSPROCESSPRIORITYMODE {
    PsProcessPriorityBackground,
    PsProcessPriorityForeground,
    PsProcessPrioritySpinning
} PSPROCESSPRIORITYMODE;

NTKERNELAPI
VOID
PsSetProcessPriorityByClass(
    IN PEPROCESS Process,
    IN PSPROCESSPRIORITYMODE PriorityMode
    );

// end_ntosp

VOID
PsWatchWorkingSet(
    IN NTSTATUS Status,
    IN PVOID PcValue,
    IN PVOID Va
    );

// begin_ntddk begin_nthal begin_ntifs begin_ntosp


HANDLE
PsGetCurrentProcessId( VOID );

HANDLE
PsGetCurrentThreadId( VOID );


// end_ntosp

BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PUNICODE_STRING CSDVersion OPTIONAL
    );

// end_ntddk end_nthal end_ntifs

// begin_ntosp
NTKERNELAPI
ULONG
PsGetCurrentProcessSessionId(
    VOID
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadStackLimit(
    VOID
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadStackBase(
    VOID
    );

NTKERNELAPI
CCHAR
PsGetCurrentThreadPreviousMode(
    VOID
    );

NTKERNELAPI
PERESOURCE
PsGetJobLock(
    PEJOB Job
    );

NTKERNELAPI
ULONG
PsGetJobSessionId(
    PEJOB Job
    );

NTKERNELAPI
ULONG
PsGetJobUIRestrictionsClass(
    PEJOB Job
    );

NTKERNELAPI
LONGLONG
PsGetProcessCreateTimeQuadPart(
    PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetProcessDebugPort(
    PEPROCESS Process
    );

BOOLEAN
PsIsProcessBeingDebugged(
    PEPROCESS Process
    );

NTKERNELAPI
BOOLEAN
PsGetProcessExitProcessCalled(
    PEPROCESS Process
    );

NTKERNELAPI
NTSTATUS
PsGetProcessExitStatus(
    PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetProcessId(
    PEPROCESS Process
    );

NTKERNELAPI
UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    );

#define PsGetCurrentProcessImageFileName() PsGetProcessImageFileName(PsGetCurrentProcess())

NTKERNELAPI
HANDLE
PsGetProcessInheritedFromUniqueProcessId(
    PEPROCESS Process
    );

NTKERNELAPI
PEJOB
PsGetProcessJob(
    PEPROCESS Process
    );

NTKERNELAPI
ULONG
PsGetProcessSessionId(
    PEPROCESS Process
    );

NTKERNELAPI
ULONG
PsGetProcessSessionIdEx(
    PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetProcessSectionBaseAddress(
    PEPROCESS Process
    );


#define PsGetProcessPcb(Process) ((PKPROCESS)(Process))

NTKERNELAPI
PPEB
PsGetProcessPeb(
    PEPROCESS Process
    );

NTKERNELAPI
UCHAR
PsGetProcessPriorityClass(
    PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetProcessWin32WindowStation(
    PEPROCESS Process
    );

#define PsGetCurrentProcessWin32WindowStation() PsGetProcessWin32WindowStation(PsGetCurrentProcess())

NTKERNELAPI
PVOID
PsGetProcessWin32Process(
    PEPROCESS Process
    );

#define PsGetCurrentProcessWin32Process() PsGetProcessWin32Process(PsGetCurrentProcess())

#if defined(_WIN64)
NTKERNELAPI
PVOID
PsGetProcessWow64Process(
    PEPROCESS Process
    );
#endif

NTKERNELAPI
HANDLE
PsGetThreadId(
    PETHREAD Thread
     );

NTKERNELAPI
CCHAR
PsGetThreadFreezeCount(
    PETHREAD Thread
    );

NTKERNELAPI
BOOLEAN
PsGetThreadHardErrorsAreDisabled(
    PETHREAD Thread);

NTKERNELAPI
PEPROCESS
PsGetThreadProcess(
    PETHREAD Thread
     );

#define PsGetCurrentThreadProcess() PsGetThreadProcess(PsGetCurrentThread())

NTKERNELAPI
HANDLE
PsGetThreadProcessId(
    PETHREAD Thread
     );
#define PsGetCurrentThreadProcessId() PsGetThreadProcessId(PsGetCurrentThread())

NTKERNELAPI
ULONG
PsGetThreadSessionId(
    PETHREAD Thread
     );

#define  PsGetThreadTcb(Thread) ((PKTHREAD)(Thread))

NTKERNELAPI
PVOID
PsGetThreadTeb(
    PETHREAD Thread
     );

#define PsGetCurrentThreadTeb() PsGetThreadTeb(PsGetCurrentThread())

NTKERNELAPI
PVOID
PsGetThreadWin32Thread(
    PETHREAD Thread
     );

#define PsGetCurrentThreadWin32Thread() PsGetThreadWin32Thread(PsGetCurrentThread())


NTKERNELAPI                         //ntifs
BOOLEAN                             //ntifs
PsIsSystemThread(                   //ntifs
    PETHREAD Thread                 //ntifs
     );                             //ntifs

NTKERNELAPI
BOOLEAN
PsIsThreadImpersonating (
    IN PETHREAD Thread
    );

NTSTATUS
PsReferenceProcessFilePointer (
    IN PEPROCESS Process,
    OUT PVOID *pFilePointer
    );

NTKERNELAPI
VOID
PsSetJobUIRestrictionsClass(
    PEJOB Job,
    ULONG UIRestrictionsClass
    );

NTKERNELAPI
VOID
PsSetProcessPriorityClass(
    PEPROCESS Process,
    UCHAR PriorityClass
    );

NTKERNELAPI
NTSTATUS
PsSetProcessWin32Process(
    PEPROCESS Process,
    PVOID Win32Process,
    PVOID PrevWin32Proces
    );

NTKERNELAPI
VOID
PsSetProcessWindowStation(
    PEPROCESS Process,
    HANDLE Win32WindowStation
    );


NTKERNELAPI
VOID
PsSetThreadHardErrorsAreDisabled(
    PETHREAD Thread,
    BOOLEAN HardErrorsAreDisabled
    );

NTKERNELAPI
VOID
PsSetThreadWin32Thread(
    PETHREAD Thread,
    PVOID Win32Thread,
    PVOID PrevWin32Thread
    );

NTKERNELAPI
PVOID
PsGetProcessSecurityPort(
    PEPROCESS Process
    );

NTKERNELAPI
NTSTATUS
PsSetProcessSecurityPort(
    PEPROCESS Process,
    PVOID Port
    );

typedef
NTSTATUS
(*PROCESS_ENUM_ROUTINE)(
    IN PEPROCESS Process,
    IN PVOID Context
    );

typedef
NTSTATUS
(*THREAD_ENUM_ROUTINE)(
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PVOID Context
    );

NTSTATUS
PsEnumProcesses (
    IN PROCESS_ENUM_ROUTINE CallBack,
    IN PVOID Context
    );


NTSTATUS
PsEnumProcessThreads (
    IN PEPROCESS Process,
    IN THREAD_ENUM_ROUTINE CallBack,
    IN PVOID Context
    );

PEPROCESS
PsGetNextProcess (
    IN PEPROCESS Process
    );

PETHREAD
PsGetNextProcessThread (
    IN PEPROCESS Process,
    IN PETHREAD Thread
    );

VOID
PsQuitNextProcess (
    IN PEPROCESS Process
    );

VOID
PsQuitNextProcessThread (
    IN PETHREAD Thread
    );

PEJOB
PsGetNextJob (
    IN PEJOB Job
    );

PEPROCESS
PsGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    );

VOID
PsQuitNextJob (
    IN PEJOB Job
    );

VOID
PsQuitNextJobProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsSuspendProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsResumeProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsTerminateProcess(
    IN PEPROCESS Process,
    IN NTSTATUS Status
    );

NTSTATUS
PsSuspendThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

NTSTATUS
PsResumeThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

#ifndef _WIN64
NTSTATUS
PsSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    );

NTSTATUS
PsSetProcessLdtInfo (
    IN PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength
    );
#endif
// end_ntosp

#endif // _PS_P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\pnp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnp.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the kernel-mode Plug and Play manager.

    This file is included by including "ntos.h".

Author:

    Lonny McMichael (lonnym) 02/09/95


Revision History:


--*/

#ifndef _PNP_
#define _PNP_

//
// The following global variables provide/control access to PnP Manager data.
//

extern ERESOURCE  PpRegistryDeviceResource;
extern PDRIVER_OBJECT IoPnpDriverObject;

// begin_ntddk begin_nthal begin_ntifs begin_wdm begin_ntosp

//
// Define PnP Device Property for IoGetDeviceProperty
//

typedef enum {
    DevicePropertyDeviceDescription,
    DevicePropertyHardwareID,
    DevicePropertyCompatibleIDs,
    DevicePropertyBootConfiguration,
    DevicePropertyBootConfigurationTranslated,
    DevicePropertyClassName,
    DevicePropertyClassGuid,
    DevicePropertyDriverKeyName,
    DevicePropertyManufacturer,
    DevicePropertyFriendlyName,
    DevicePropertyLocationInformation,
    DevicePropertyPhysicalDeviceObjectName,
    DevicePropertyBusTypeGuid,
    DevicePropertyLegacyBusType,
    DevicePropertyBusNumber,
    DevicePropertyEnumeratorName,
    DevicePropertyAddress,
    DevicePropertyUINumber,
    DevicePropertyInstallState,
    DevicePropertyRemovalPolicy
} DEVICE_REGISTRY_PROPERTY;

typedef BOOLEAN (*PTRANSLATE_BUS_ADDRESS)(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef struct _DMA_ADAPTER *(*PGET_DMA_ADAPTER)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

typedef ULONG (*PGET_SET_DEVICE_DATA)(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled,
    InstallStateNeedsReinstall,
    InstallStateFailedInstall,
    InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

//
// Define structure returned in response to IRP_MN_QUERY_BUS_INFORMATION by a
// PDO indicating the type of bus the device exists on.
//

typedef struct _PNP_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

//
// Define structure returned in response to IRP_MN_QUERY_LEGACY_BUS_INFORMATION
// by an FDO indicating the type of bus it is.  This is normally the same bus
// type as the device's children (i.e., as retrieved from the child PDO's via
// IRP_MN_QUERY_BUS_INFORMATION) except for cases like CardBus, which can
// support both 16-bit (PCMCIABus) and 32-bit (PCIBus) cards.
//

typedef struct _LEGACY_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

//
// Defines for IoGetDeviceProperty(DevicePropertyRemovalPolicy).
//
typedef enum _DEVICE_REMOVAL_POLICY {

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
    RemovalPolicyNotDetermined = 0,
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
    RemovalPolicyExpectNoRemoval = 1,
    RemovalPolicyExpectOrderlyRemoval = 2,
    RemovalPolicyExpectSurpriseRemoval = 3
// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
                                          ,
    RemovalPolicySuggestOrderlyRemoval = 4,
    RemovalPolicySuggestSurpriseRemoval = 5,
    RemovalPolicyUnspecified = 6
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVICE_REMOVAL_POLICY, *PDEVICE_REMOVAL_POLICY;



typedef struct _BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
    PGET_DMA_ADAPTER GetDmaAdapter;
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;

} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

// end_wdm
typedef struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // config munging routines
    //
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;
    UCHAR CapabilityID;  // 2 (AGPv2 host) or new 0xE (AGPv3 bridge)

} AGP_TARGET_BUS_INTERFACE_STANDARD, *PAGP_TARGET_BUS_INTERFACE_STANDARD;
// begin_wdm

//
// The following definitions are used in ACPI QueryInterface
//
typedef BOOLEAN (* PGPE_SERVICE_ROUTINE) (
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_CONNECT_VECTOR) (
                            PDEVICE_OBJECT,
                            ULONG,
                            KINTERRUPT_MODE,
                            BOOLEAN,
                            PGPE_SERVICE_ROUTINE,
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_DISCONNECT_VECTOR) (
                            PVOID);

typedef NTSTATUS (* PGPE_ENABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_DISABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_CLEAR_STATUS) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef VOID (* PDEVICE_NOTIFY_CALLBACK) (
                            PVOID,
                            ULONG);

typedef NTSTATUS (* PREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK,
                            PVOID);

typedef void (* PUNREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR                     GpeConnectVector;
    PGPE_DISCONNECT_VECTOR                  GpeDisconnectVector;
    PGPE_ENABLE_EVENT                       GpeEnableEvent;
    PGPE_DISABLE_EVENT                      GpeDisableEvent;
    PGPE_CLEAR_STATUS                       GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS      RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS    UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;

// end_wdm end_ntddk

typedef enum _ACPI_REG_TYPE {
    PM1a_ENABLE,
    PM1b_ENABLE,
    PM1a_STATUS,
    PM1b_STATUS,
    PM1a_CONTROL,
    PM1b_CONTROL,
    GP_STATUS,
    GP_ENABLE,
    SMI_CMD,
    MaxRegType
} ACPI_REG_TYPE, *PACPI_REG_TYPE;

typedef USHORT (*PREAD_ACPI_REGISTER) (
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register);

typedef VOID (*PWRITE_ACPI_REGISTER) (
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  );

typedef struct ACPI_REGS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_REGISTER functions
    //
    PREAD_ACPI_REGISTER  ReadAcpiRegister;
    PWRITE_ACPI_REGISTER WriteAcpiRegister;

} ACPI_REGS_INTERFACE_STANDARD, *PACPI_REGS_INTERFACE_STANDARD;


typedef NTSTATUS (*PHAL_QUERY_ALLOCATE_PORT_RANGE) (
  IN BOOLEAN IsSparse,
  IN BOOLEAN PrimaryIsMmio,
  IN PVOID VirtBaseAddr OPTIONAL,
  IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
  IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
  OUT PUSHORT NewRangeId
  );

typedef VOID (*PHAL_FREE_PORT_RANGE)(
    IN USHORT RangeId
    );


typedef struct _HAL_PORT_RANGE_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // QueryAllocateRange/FreeRange functions
    //
    PHAL_QUERY_ALLOCATE_PORT_RANGE QueryAllocateRange;
    PHAL_FREE_PORT_RANGE FreeRange;

} HAL_PORT_RANGE_INTERFACE, *PHAL_PORT_RANGE_INTERFACE;


//
// describe the CMOS HAL interface
//

typedef enum _CMOS_DEVICE_TYPE {
    CmosTypeStdPCAT,
    CmosTypeIntelPIIX4,
    CmosTypeDal1501
} CMOS_DEVICE_TYPE;


typedef
ULONG
(*PREAD_ACPI_CMOS) (
    IN CMOS_DEVICE_TYPE     CmosType,
    IN ULONG                SourceAddress,
    IN PUCHAR               DataBuffer,
    IN ULONG                ByteCount
    );

typedef
ULONG
(*PWRITE_ACPI_CMOS) (
    IN CMOS_DEVICE_TYPE     CmosType,
    IN ULONG                SourceAddress,
    IN PUCHAR               DataBuffer,
    IN ULONG                ByteCount
    );

typedef struct _ACPI_CMOS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_CMOS functions
    //
    PREAD_ACPI_CMOS     ReadCmos;
    PWRITE_ACPI_CMOS    WriteCmos;

} ACPI_CMOS_INTERFACE_STANDARD, *PACPI_CMOS_INTERFACE_STANDARD;

//
// These definitions are used for getting PCI Interrupt Routing interfaces
//

typedef struct {
    PVOID   LinkNode;
    ULONG   StaticVector;
    UCHAR   Flags;
} ROUTING_TOKEN, *PROUTING_TOKEN;

//
// Flag indicating that the device supports
// MSI interrupt routing or that the provided token contains
// MSI routing information
//

#define PCI_MSI_ROUTING         0x1
#define PCI_STATIC_ROUTING      0x2

typedef
NTSTATUS
(*PGET_INTERRUPT_ROUTING)(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    );

typedef
NTSTATUS
(*PSET_INTERRUPT_ROUTING_TOKEN)(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

typedef
VOID
(*PUPDATE_INTERRUPT_LINE)(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR LineRegister
    );

typedef struct _INT_ROUTE_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PGET_INTERRUPT_ROUTING GetInterruptRouting;
    PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken;
    PUPDATE_INTERRUPT_LINE UpdateInterruptLine;

} INT_ROUTE_INTERFACE_STANDARD, *PINT_ROUTE_INTERFACE_STANDARD;

// Some well-known interface versions supported by the PCI Bus Driver

#define PCI_INT_ROUTE_INTRF_STANDARD_VER 1

// end_nthal end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
PpInitSystem (
    VOID
    );

NTKERNELAPI
NTSTATUS
PpDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
IoSynchronousInvalidateDeviceRelations(
    PDEVICE_OBJECT DeviceObject,
    DEVICE_RELATION_TYPE Type
    );

// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
NTSTATUS
IoReportDetectedDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements OPTIONAL,
    IN BOOLEAN ResourceAssigned,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

// begin_wdm

NTKERNELAPI
VOID
IoInvalidateDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_RELATION_TYPE Type
    );

NTKERNELAPI
VOID
IoRequestDeviceEject(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTKERNELAPI
NTSTATUS
IoGetDeviceProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    );

//
// The following definitions are used in IoOpenDeviceRegistryKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

NTKERNELAPI
NTSTATUS
IoOpenDeviceRegistryKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DevInstRegKey
    );

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString,     OPTIONAL
    OUT PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    );

NTKERNELAPI
NTSTATUS
IoSetDeviceInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable
    );

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN ULONG Flags,
    OUT PWSTR *SymbolicLinkList
    );

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE   0x00000001

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
    IN PUNICODE_STRING SymbolicLinkName,
    IN CONST GUID *AliasInterfaceClassGuid,
    OUT PUNICODE_STRING AliasSymbolicLinkName
    );

//
// Define PnP notification event categories
//

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

//
// Define flags that modify the behavior of IoRegisterPlugPlayNotification
// for the various event categories...
//

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    IN PVOID NotificationStructure,
    IN PVOID Context
);


NTKERNELAPI
NTSTATUS
IoRegisterPlugPlayNotification(
    IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    IN ULONG EventCategoryFlags,
    IN PVOID EventCategoryData OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Context,
    OUT PVOID *NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotification(
    IN PVOID NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChange(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    );

typedef
VOID
(*PDEVICE_CHANGE_COMPLETE_CALLBACK)(
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoInvalidateDeviceState(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#define IoAdjustPagingPathCount(_count_,_paging_) {     \
    if (_paging_) {                                     \
        InterlockedIncrement(_count_);                  \
    } else {                                            \
        InterlockedDecrement(_count_);                  \
    }                                                   \
}

NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    IN PDEVICE_CHANGE_COMPLETE_CALLBACK Callback,       OPTIONAL
    IN PVOID Context    OPTIONAL
    );
// end_wdm end_ntosp
//
// Device location interface declarations
//
typedef
NTSTATUS
(*PGET_LOCATION_STRING) (
    IN PVOID Context,
    OUT PWCHAR *LocationStrings
    );

typedef struct _PNP_LOCATION_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // interface specific entry
    //
    PGET_LOCATION_STRING GetLocationString;

} PNP_LOCATION_INTERFACE, *PPNP_LOCATION_INTERFACE;

//
// Resource arbiter declarations
//

typedef enum _ARBITER_ACTION {
    ArbiterActionTestAllocation,
    ArbiterActionRetestAllocation,
    ArbiterActionCommitAllocation,
    ArbiterActionRollbackAllocation,
    ArbiterActionQueryAllocatedResources,
    ArbiterActionWriteReservedResources,
    ArbiterActionQueryConflict,
    ArbiterActionQueryArbitrate,
    ArbiterActionAddReserved,
    ArbiterActionBootAllocation
} ARBITER_ACTION, *PARBITER_ACTION;

typedef struct _ARBITER_CONFLICT_INFO {
    //
    // The device object owning the device that is causing the conflict
    //
    PDEVICE_OBJECT OwningObject;

    //
    // The start of the conflicting range
    //
    ULONGLONG Start;

    //
    // The end of the conflicting range
    //
    ULONGLONG End;

} ARBITER_CONFLICT_INFO, *PARBITER_CONFLICT_INFO;

//
// The parameters for those actions
//

typedef struct _ARBITER_PARAMETERS {

    union {

        struct {

            //
            // Doubly linked list of ARBITER_LIST_ENTRY's
            //
            IN OUT PLIST_ENTRY ArbitrationList;

            //
            // The size of the AllocateFrom array
            //
            IN ULONG AllocateFromCount;

            //
            // Array of resource descriptors describing the resources available
            // to the arbiter for it to arbitrate
            //
            IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

        } TestAllocation;

        struct {

            //
            // Doubly linked list of ARBITER_LIST_ENTRY's
            //
            IN OUT PLIST_ENTRY ArbitrationList;

            //
            // The size of the AllocateFrom array
            //
            IN ULONG AllocateFromCount;

            //
            // Array of resource descriptors describing the resources available
            // to the arbiter for it to arbitrate
            //
            IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

        } RetestAllocation;

        struct {

            //
            // Doubly linked list of ARBITER_LIST_ENTRY's
            //
            IN OUT PLIST_ENTRY ArbitrationList;

        } BootAllocation;

        struct {

            //
            // The resources that are currently allocated
            //
            OUT PCM_PARTIAL_RESOURCE_LIST *AllocatedResources;

        } QueryAllocatedResources;

        struct {

            //
            // This is the device we are trying to find a conflict for
            //
            IN PDEVICE_OBJECT PhysicalDeviceObject;

            //
            // This is the resource to find the conflict for
            //
            IN PIO_RESOURCE_DESCRIPTOR ConflictingResource;

            //
            // Number of devices conflicting on the resource
            //
            OUT PULONG ConflictCount;

            //
            // Pointer to array describing the conflicting device objects and ranges
            //
            OUT PARBITER_CONFLICT_INFO *Conflicts;

        } QueryConflict;

        struct {

            //
            // Doubly linked list of ARBITER_LIST_ENTRY's - should have
            // only one entry
            //
            IN PLIST_ENTRY ArbitrationList;

        } QueryArbitrate;

        struct {

            //
            // Indicates the device whose resources are to be marked as reserved
            //
            PDEVICE_OBJECT ReserveDevice;

        } AddReserved;

    } Parameters;

} ARBITER_PARAMETERS, *PARBITER_PARAMETERS;



typedef enum _ARBITER_REQUEST_SOURCE {

    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported,   // IoReportResourceUsage
    ArbiterRequestHalReported,      // IoReportHalResourceUsage
    ArbiterRequestLegacyAssigned,   // IoAssignResources
    ArbiterRequestPnpDetected,      // IoReportResourceForDetection
    ArbiterRequestPnpEnumerated     // IRP_MN_QUERY_RESOURCE_REQUIREMENTS

} ARBITER_REQUEST_SOURCE;


typedef enum _ARBITER_RESULT {

    ArbiterResultUndefined = -1,
    ArbiterResultSuccess,
    ArbiterResultExternalConflict, // This indicates that the request can never be solved for devices in this list
    ArbiterResultNullRequest       // The request was for length zero and thus no translation should be attempted

} ARBITER_RESULT;

//
// ARBITER_FLAG_BOOT_CONFIG - this indicates that the request is for the
// resources assigned by the firmware/BIOS.  It should be succeeded even if
// it conflicts with another devices boot config.
//

#define ARBITER_FLAG_BOOT_CONFIG 0x00000001

// begin_ntosp

NTKERNELAPI
NTSTATUS
IoReportResourceForDetection(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    OUT PBOOLEAN ConflictDetected
    );

// end_ntosp

typedef struct _ARBITER_LIST_ENTRY {

    //
    // This is a doubly linked list of entries for easy sorting
    //
    LIST_ENTRY ListEntry;

    //
    // The number of alternative allocation
    //
    ULONG AlternativeCount;

    //
    // Pointer to an array of resource descriptors for the possible allocations
    //
    PIO_RESOURCE_DESCRIPTOR Alternatives;

    //
    // The device object of the device requesting these resources.
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Indicates where the request came from
    //
    ARBITER_REQUEST_SOURCE RequestSource;

    //
    // Flags these indicate a variety of things (use ARBITER_FLAG_*)
    //
    ULONG Flags;

    //
    // Space to aid the arbiter in processing the list it is initialized to 0 when
    // the entry is created.  The system will not attempt to interpret it.
    //
    LONG_PTR WorkSpace;

    //
    // Interface Type, Slot Number and Bus Number from Resource Requirements list,
    // used only for reverse identification.
    //
    INTERFACE_TYPE InterfaceType;
    ULONG SlotNumber;
    ULONG BusNumber;

    //
    // A pointer to a descriptor to indicate the resource that was allocated.
    // This is allocated by the system and filled in by the arbiter in response to an
    // ArbiterActionTestAllocation.
    //
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment;

    //
    // Pointer to the alternative that was chosen from to provide the assignment.
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    PIO_RESOURCE_DESCRIPTOR SelectedAlternative;

    //
    // The result of the operation
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    ARBITER_RESULT Result;

} ARBITER_LIST_ENTRY, *PARBITER_LIST_ENTRY;

//
// The arbiter's entry point
//

typedef
NTSTATUS
(*PARBITER_HANDLER) (
    IN PVOID Context,
    IN ARBITER_ACTION Action,
    IN OUT PARBITER_PARAMETERS Parameters
    );

//
// Arbiter interface
//

#define ARBITER_PARTIAL   0x00000001


typedef struct _ARBITER_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Entry point to the arbiter
    //
    PARBITER_HANDLER ArbiterHandler;

    //
    // Other information about the arbiter, use ARBITER_* flags
    //
    ULONG Flags;

} ARBITER_INTERFACE, *PARBITER_INTERFACE;

//
// The directions translation can take place in
//

typedef enum _RESOURCE_TRANSLATION_DIRECTION { // ntosp
    TranslateChildToParent,                    // ntosp
    TranslateParentToChild                     // ntosp
} RESOURCE_TRANSLATION_DIRECTION;              // ntosp

//
// Translation functions
//
// begin_ntosp

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_HANDLER)(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER)(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

//
// Translator Interface
//

typedef struct _TRANSLATOR_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PTRANSLATE_RESOURCE_HANDLER TranslateResources;
    PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements;
} TRANSLATOR_INTERFACE, *PTRANSLATOR_INTERFACE;

// end_ntddk end_ntosp

//
// Legacy Device Detection Handler
//

typedef
NTSTATUS
(*PLEGACY_DEVICE_DETECTION_HANDLER)(
    IN PVOID Context,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
);

//
// Legacy Device Detection Interface
//

typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection;
} LEGACY_DEVICE_DETECTION_INTERFACE, *PLEGACY_DEVICE_DETECTION_INTERFACE;

// end_nthal end_ntifs

// begin_wdm begin_ntddk begin_ntifs begin_nthal begin_ntosp

//
// Header structure for all Plug&Play notification events...
//

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
    USHORT Version; // presently at version 1.
    USHORT Size;    // size (in bytes) of header + event-specific data.
    GUID Event;
    //
    // Event-specific stuff starts here.
    //
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

//
// Notification structure for all EventCategoryHardwareProfileChange events...
//

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // (No event-specific data)
    //
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;


//
// Notification structure for all EventCategoryDeviceInterfaceChange events...
//

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    GUID InterfaceClassGuid;
    PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;


//
// Notification structures for EventCategoryTargetDeviceChange...
//

//
// The following structure is used for TargetDeviceQueryRemove,
// TargetDeviceRemoveCancelled, and TargetDeviceRemoveComplete:
//
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

//
// The following structure header is used for all other (i.e., 3rd-party)
// target device change events.  The structure accommodates both a
// variable-length binary data buffer, and a variable-length unicode text
// buffer.  The header must indicate where the text buffer begins, so that
// the data can be delivered in the appropriate format (ANSI or Unicode)
// to user-mode recipients (i.e., that have registered for handle-based
// notification via RegisterDeviceNotification).
//

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;    // This field must be set to NULL by callers of
                                // IoReportTargetDeviceChange.  Clients that
                                // have registered for target device change
                                // notification on the affected PDO will be
                                // called with this field set to the file object
                                // they specified during registration.
                                //
    LONG NameBufferOffset;      // offset (in bytes) from beginning of
                                // CustomDataBuffer where text begins (-1 if none)
                                //
    UCHAR CustomDataBuffer[1];  // variable-length buffer, containing (optionally)
                                // a binary data at the start of the buffer,
                                // followed by an optional unicode text buffer
                                // (word-aligned).
                                //
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;

// end_wdm end_ntddk end_ntifs end_nthal end_ntosp

NTSTATUS
PpSetCustomTargetEvent(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent                           OPTIONAL,
    OUT PULONG Result                               OPTIONAL,
    IN  PDEVICE_CHANGE_COMPLETE_CALLBACK Callback   OPTIONAL,
    IN  PVOID Context                               OPTIONAL,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION NotificationStructure
    );

NTSTATUS
PpSetTargetDeviceRemove(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN KernelInitiated,
    IN  BOOLEAN NoRestart,
    IN  BOOLEAN OnlyRestartRelations,
    IN  BOOLEAN DoEject,
    IN  ULONG Problem,
    IN  PKEVENT SyncEvent        OPTIONAL,
    OUT PULONG Result            OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType  OPTIONAL,
    OUT PUNICODE_STRING VetoName OPTIONAL
    );

NTSTATUS
PpSetDeviceRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent           OPTIONAL,
    OUT PULONG Result               OPTIONAL
    );

NTSTATUS
PpNotifyUserModeRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject
    );

#define TDF_DEVICEEJECTABLE         0x00000001
#define TDF_NO_RESTART              0x00000002
#define TDF_KERNEL_INITIATED        0x00000004
//
// This flag is valid only if TDF_NO_RESTART is not set. If set, only relations
// are restarted. If not set, original device and relations are restarted.
//
#define TDF_ONLY_RESTART_RELATIONS  0x00000008  

NTSTATUS
PpSetDeviceClassChange(
    IN CONST GUID *EventGuid,
    IN CONST GUID *ClassGuid,
    IN PUNICODE_STRING SymbolicLinkName
    );

VOID
PpSetPlugPlayEvent(
    IN CONST GUID *EventGuid,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PpInitializeNotification(
    VOID
    );

VOID
PpShutdownSystem (
    IN BOOLEAN Reboot,
    IN ULONG Phase,
    IN OUT PVOID *Context
    );

NTSTATUS
PpSetPowerEvent(
    IN   ULONG EventCode,
    IN   ULONG EventData,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    );

NTSTATUS
PpSetHwProfileChangeEvent(
    IN   CONST GUID *EventGuid,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    );

NTSTATUS
PpSetBlockedDriverEvent(
    IN   GUID CONST *BlockedDriverGuid
    );

NTSTATUS
PpSynchronizeDeviceEventQueue(
    VOID
    );

NTSTATUS
PpSetInvalidIDEvent(
    IN   PUNICODE_STRING ParentInstance
    );

NTSTATUS
PpSetPowerVetoEvent(
    IN  POWER_ACTION    VetoedPowerOperation,
    IN  PKEVENT         CompletionEvent         OPTIONAL,
    OUT PNTSTATUS       CompletionStatus        OPTIONAL,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PNP_VETO_TYPE   VetoType,
    IN  PUNICODE_STRING VetoName                OPTIONAL
    );

NTSTATUS
PpPagePathAssign(
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
PpPagePathRelease(
    IN PFILE_OBJECT FileObject
    );

//
// Entry point for USER to deliver notifications (public)
//

// begin_ntosp
ULONG
IoPnPDeliverServicePowerNotification(
    IN   POWER_ACTION           PowerOperation,
    IN   ULONG                  PowerNotificationCode,
    IN   ULONG                  PowerNotificationData,
    IN   BOOLEAN                Synchronous
    );
// end_ntosp

#endif // _PNP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\shpc.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    shpc.h

Abstract:

    Type definitions describing a Standard Hotplug Controller

Author:

    Davis Walker (dwalker) 10 October 2000

Revision History:

--*/

#ifndef _SHPC_
#define _SHPC_

#include "pshpack1.h"

//
// Register set structures
//

//
// Slots Available Registers
//
// This is a two DWORD structure.
//
typedef struct _SHPC_SLOTS_AVAILABLE_REGISTER {

    ULONG NumSlots33Conv:5;          // HWINIT
    ULONG:3;                         // RsvdP
    ULONG NumSlots66PciX:5;          // HWINIT
    ULONG:3;                         // RsvdP
    ULONG NumSlots100PciX:5;         // HWINIT
    ULONG:3;                         // RsvdP
    ULONG NumSlots133PciX:5;         // HWINIT
    ULONG:3;                         // RsvdP

    ULONG NumSlots66Conv:5;          // HWINIT
    ULONG:27;                        // RsvdP

} SHPC_SLOTS_AVAILABLE_REGISTER, *PSHPC_SLOTS_AVAILABLE_REGISTER;

//
// Slot Configuration Register
//
typedef struct _SHPC_SLOT_CONFIGURATION_REGISTER {

    ULONG NumSlots:5;                        // HWINIT
    ULONG:3;                                 // RsvdP
    ULONG FirstDeviceID:5;                   // HWINIT
    ULONG:3;                                 // RsvdP
    ULONG PhysicalSlotNumber:11;             // HWINIT
    ULONG:2;                                 // RsvdP
    ULONG UpDown:1;                          // HWINIT
    ULONG MRLSensorsImplemented:1;           // HWINIT
    ULONG AttentionButtonImplemented:1;      // HWINIT

} SHPC_SLOT_CONFIGURATION_REGISTER, *PSHPC_SLOT_CONFIGURATION_REGISTER;

//
// Secondary Bus Configuration Register
//

typedef enum _SHPC_BUS_SPEED_MODE {

    SHPC_SPEED_33_CONV = 0,
    SHPC_SPEED_66_CONV,
    SHPC_SPEED_66_PCIX,
    SHPC_SPEED_100_PCIX,
    SHPC_SPEED_133_PCIX

} SHPC_BUS_SPEED_MODE, *PSHPC_BUS_SPEED_MODE;

typedef struct _SHPC_BUS_CONFIG_REGISTER {

    ULONG CurrentBusMode:3;           // RO   SHPC_SPEED_XXX
    ULONG Rsvd:21;                           // RsvdP
    ULONG ProgIF:8;                          // RO

} SHPC_BUS_CONFIG_REGISTER, *PSHPC_BUS_CONFIG_REGISTER;

//
// Command Register
//
#define SHPC_SLOT_OPERATION_CODE 0x0
#define SHPC_BUS_SEGMENT_OPERATION_CODE 0x8
#define SHPC_POWER_ALL_SLOTS_CODE 0x48
#define SHPC_ENABLE_ALL_SLOTS_CODE 0x49

//
// Command defines
//

#define IS_COMMAND_SLOT_OPERATION(x)       \
    (x.SlotOperation.CommandCode == SHPC_SLOT_OPERATION_CODE)

#define IS_COMMAND_SET_BUS_SEGMENT(x)      \
    (x.BusSegmentOperation.CommandCode == SHPC_BUS_SEGMENT_OPERATION_CODE)

#define IS_COMMAND_POWER_ALL_SLOTS(x)      \
    (x.AsUchar = SHPC_POWER_ALL_SLOTS_CODE)

#define IS_COMMAND_ENABLE_ALL_SLOTS(x)     \
    (x.AsUchar = SHPC_ENABLE_ALL_SLOTS_CODE)

typedef union _SHPC_CONTROLLER_COMMAND {

    struct {
        UCHAR SlotState:2;
        UCHAR PowerIndicator:2;
        UCHAR AttentionIndicator:2;
        UCHAR CommandCode:2;

    } SlotOperation;

    struct {
        UCHAR BusSpeed:3;       // SHPC_SPEED_XXX
        UCHAR CommandCode:5;

    } BusSegmentOperation;

    struct {
        UCHAR Command:6;
        UCHAR CommandCode:2;

    } General;

    UCHAR AsUchar;

} SHPC_CONTROLLER_COMMAND, *PSHPC_CONTROLLER_COMMAND;

typedef struct _SHPC_COMMAND_STATUS {

    USHORT ControllerBusy:1;           // RO
    USHORT MRLOpen:1;                  // RO
    USHORT InvalidCommand:1;           // RO
    USHORT InvalidSpeedMode:1;         // RO
    USHORT Rsvd:12;                    // RsvdP

} SHPC_COMMAND_STATUS, *PSHPC_COMMAND_STATUS;

typedef struct _SHPC_COMMAND_REGISTER {

    SHPC_CONTROLLER_COMMAND Command;

    struct {
        UCHAR TargetForCommand:4;
        UCHAR Rsvd:4;   // RsvdP
    } Target;

    SHPC_COMMAND_STATUS Status;

} SHPC_COMMAND_REGISTER, *PSHPC_COMMAND_REGISTER;

//
// Interrupt Locator Register
//
typedef struct _SHPC_INT_LOCATOR_REGISTER {

    ULONG CommandCompleteIntPending:1;        // RO
    ULONG InterruptLocator:31;                // RO

} SHPC_INT_LOCATOR_REGISTER, *PSHPC_INT_LOCATOR_REGISTER;

//
// SERR Locator Register
//
typedef struct _SHPC_SERR_LOCATOR_REGISTER {

    ULONG ArbiterSERRPending:1;               // RO
    ULONG SERRLocator:31;                     // RO

} SHPC_SERR_LOCATOR_REGISTER, *PSHPC_SERR_LOCATOR_REGISTER;

//
// Controller SERR-INT Register
//
// The low word is the interrupt mask.  When mask bits are set, the
// corresponding operation is masked out.
//
#define SHPC_MASK_INT_COMMAND_COMPLETE 0x0001
#define SHPC_MASK_INT_GLOBAL           0x0002
#define SHPC_MASK_SERR_GLOBAL          0x0004
#define SHPC_MASK_SERR_ARBITER_TIMEOUT 0x0008
// all other bits in the low word are RsvdP

//
// The high word is the detected word.
//
#define SHPC_DETECTED_COMMAND_COMPLETE 0x0001
#define SHPC_DETECTED_ARBITER_TIMEOUT  0x0002
// all other bits in the high word are RsvdZ

typedef struct _SHPC_SERR_INT_REGISTER {

    USHORT SERRIntMask;
    USHORT SERRIntDetected;

} SHPC_SERR_INT_REGISTER, *PSHPC_SERR_INT_REGISTER;

//
// Slot Specific Registers
//

//
// Status Field
//

#define    SHPC_SLOT_NOP 0
#define    SHPC_SLOT_POWERED  1
#define    SHPC_SLOT_ENABLED 2
#define    SHPC_SLOT_OFF 3

#define    SHPC_INDICATOR_NOP 0
#define    SHPC_INDICATOR_ON 1
#define    SHPC_INDICATOR_BLINK 2
#define    SHPC_INDICATOR_OFF 3

#define    SHPC_PCIX_NO_CAP  0x0
#define    SHPC_PCIX_66_CAP  0x1
#define    SHPC_PCIX_133_CAP 0x3

#define    SHPC_MRL_CLOSED 0
#define    SHPC_MRL_OPEN   1

#define    SHPC_PRSNT_7_5_WATTS 0
#define    SHPC_PRSNT_25_WATTS  1
#define    SHPC_PRSNT_15_WATTS  2
#define    SHPC_PRSNT_EMPTY     3

typedef struct _SHPC_SLOT_STATUS_REGISTER {

    USHORT SlotState:2;                 // SHPC_SLOT_XXX
    USHORT PowerIndicatorState:2;       // SHPC_INDICATOR_XXX
    USHORT AttentionIndicatorState:2;   // SHPC_INDICATOR_XXX
    USHORT PowerFaultDetected:1;
    USHORT AttentionButtonState:1;
    USHORT MRLSensorState:1;            // SHPC_MRL_XXX
    USHORT SpeedCapability:1;
    USHORT PrsntState:2;
    USHORT PCIXCapability:2;            //SHPC_PCIX_XXX
    USHORT Rsvd:2;

} SHPC_SLOT_STATUS_REGISTER, *PSHPC_SLOT_STATUS_REGISTER;

//
// Slot Event Latch Field
//
// This register is a UCHAR with bit meanings defined
// below.
// All undefined bits are RsvdZ
//

#define SHPC_SLOT_EVENT_CARD_PRESENCE  0x01
#define SHPC_SLOT_EVENT_ISO_FAULT      0x02
#define SHPC_SLOT_EVENT_ATTEN_BUTTON   0x04
#define SHPC_SLOT_EVENT_MRL_SENSOR     0x08
#define SHPC_SLOT_EVENT_CONNECT_FAULT  0x10

#define SHPC_SLOT_EVENT_ALL   (SHPC_SLOT_EVENT_CARD_PRESENCE | \
                               SHPC_SLOT_EVENT_ISO_FAULT |     \
                               SHPC_SLOT_EVENT_ATTEN_BUTTON |  \
                               SHPC_SLOT_EVENT_MRL_SENSOR |    \
                               SHPC_SLOT_EVENT_CONNECT_FAULT)

//
// Slot INT-SERR Mask Field
//
// This register is a UCHAR with bit meanings defined below
// All undefined bits are RsvdP
//

#define SHPC_SLOT_INT_CARD_PRESENCE  0x01
#define SHPC_SLOT_INT_ISO_FAULT      0x02
#define SHPC_SLOT_INT_ATTEN_BUTTON   0x04
#define SHPC_SLOT_INT_MRL_SENSOR     0x08
#define SHPC_SLOT_INT_CONNECT_FAULT  0x10
#define SHPC_SLOT_SERR_MRL_SENSOR    0x20
#define SHPC_SLOT_SERR_CONNECT_FAULT 0x40


#define SHPC_SLOT_INT_ALL   (SHPC_SLOT_INT_CARD_PRESENCE |   \
                             SHPC_SLOT_INT_ISO_FAULT |       \
                             SHPC_SLOT_INT_ATTEN_BUTTON |    \
                             SHPC_SLOT_INT_MRL_SENSOR |      \
                             SHPC_SLOT_INT_CONNECT_FAULT)

#define SHPC_SLOT_SERR_ALL  (SHPC_SLOT_SERR_CONNECT_FAULT |  \
                             SHPC_SLOT_SERR_MRL_SENSOR)

//
// Overall Slot Register structure
//
typedef struct _SHPC_SLOT_REGISTER {

    SHPC_SLOT_STATUS_REGISTER SlotStatus;       //RO
    UCHAR SlotEventLatch;
    UCHAR IntSERRMask;

} SHPC_SLOT_REGISTER, *PSHPC_SLOT_REGISTER;

//
// Overall Register Set Structures
//

#define SHPC_MAX_SLOT_REGISTERS  31

typedef struct _SHPC_WORKING_REGISTERS {

    ULONG BaseOffset;

    SHPC_SLOTS_AVAILABLE_REGISTER SlotsAvailable;
    SHPC_SLOT_CONFIGURATION_REGISTER SlotConfig;
    SHPC_BUS_CONFIG_REGISTER BusConfig;

    SHPC_COMMAND_REGISTER Command;

    SHPC_INT_LOCATOR_REGISTER IntLocator;
    SHPC_SERR_LOCATOR_REGISTER SERRLocator;
    SHPC_SERR_INT_REGISTER SERRInt;

    SHPC_SLOT_REGISTER SlotRegisters[SHPC_MAX_SLOT_REGISTERS];

} SHPC_WORKING_REGISTERS, *PSHPC_WORKING_REGISTERS;

//
// Register access structures and defines
//

#define SHPC_NUM_REGISTERS       sizeof(SHPC_WORKING_REGISTERS)/sizeof(ULONG)
#define SHPC_FIRST_SLOT_REG      (SHPC_NUM_REGISTERS - SHPC_MAX_SLOT_REGISTERS)

typedef union _SHPC_REGISTER_SET {

    SHPC_WORKING_REGISTERS WorkingRegisters;

    ULONG AsULONGs[SHPC_NUM_REGISTERS];

} SHPC_REGISTER_SET, *PSHPC_REGISTER_SET;

//
// HBRB defines
//
#define HBRB_PACKAGE_COUNT 2

typedef struct _HBRB_HEADER {
    USHORT VendorID;
    USHORT DeviceID;
    UCHAR RevisionID;
    UCHAR ProgIF;
    UCHAR BusNumber;
    UCHAR HBRBVersion;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONG Size;
    ULONG CapabilitiesPtr;

} HBRB_HEADER, *PHBRB_HEADER;

typedef struct _HBRB_CAPABILITIES_HEADER {
    ULONG CapabilityID;
    ULONG Next;
} HBRB_CAPABILITIES_HEADER, *PHBRB_CAPABILITIES_HEADER;

typedef struct _HBRB_CAPABILITY {
    HBRB_CAPABILITIES_HEADER Header;
    SHPC_WORKING_REGISTERS RegisterSet;

} SHPC_HBRB_CAPABILITY, *PSHPC_HBRB_CAPABILITY;

//
// SHPC config space defines
//
typedef union _SHPC_CONFIG_PENDING {

    struct {
        UCHAR ControllerSERRPending:1;  // RO
        UCHAR ControllerIntPending:1;   // RO
        UCHAR:6;                        // RsvdP

    } Field;

    UCHAR AsUCHAR;

} SHPC_CONFIG_PENDING, *PSHPC_CONFIG_PENDING;

typedef struct _SHPC_CONFIG_SPACE {

    PCI_CAPABILITIES_HEADER Header;                //RO

    UCHAR DwordSelect;
    SHPC_CONFIG_PENDING Pending;

    ULONG Data;

} SHPC_CONFIG_SPACE, *PSHPC_CONFIG_SPACE;

#include "poppack.h"

#define SHPC_CAPABILITY_ID 0xC

//
// Bit type masks
//

//
// XxxRO indicates the mask of bits in the register that are Read Only
// XxxRW indicates the mask of bits in the register that are Read Write
// XxxRWC indicates the mask of bits in the register that are Read/Write Clear
// XxxRsvdP indicates the mask of bits in the register that are Reserved
//      and whose values should be preserved on writes.
// XxxRsvdZ indicates the mask of bits in the register that are Reserved
//      and whose values should be always written as zeros.
//
// All of the listed masks for a register should always add to 0xFFFFFFFF
//

//
// Base Offset Register
//
#define BaseOffsetRO 0xFFFFFFFF

//
// Slots Available Registers
// DWord1 is the lower dword
// DWord2 is the upper dword
//
#define SlotsAvailDWord1RO    0x1F1F1F1F
#define SlotsAvailDWord1RsvdP 0xE0E0E0E0

#define SlotsAvailDWord2RO    0x0000001F
#define SlotsAvailDWord2RsvdP 0xFFFFFFE0

//
// Slot Configuration Register
//
#define SlotConfigRO    0xE7FF1F1F
#define SlotConfigRsvdP 0x1800E0E0

//
// Secondary Bus Configuration Register
// This mask includes the SHPC Programming Interface register
//
#define BusConfigRO     0xFF000007
#define BusConfigRsvdP  0x00FFFFF8

//
// Controller Command/Status Register
// This mask includes both the Command and Command Status registers
//
#define CommandStatusRO    0x000F0000
#define CommandStatusRW    0x00001FFF
#define CommandStatusRsvdP 0xFFF0E000

//
// Interrupt Locator Register
//
#define IntLocatorRO 0xFFFFFFFF

//
// SERR Locator Register
//
#define SERRLocatorRO 0xFFFFFFFF

//
// Controller SERR-INT Register
//
#define ControllerMaskRW      0x0000000F
#define ControllerMaskRWC     0x00030000
#define ControllerMaskRsvdP   0x0000FFF0
#define ControllerMaskRsvdZ   0xFFFC0000

//
// Slot Specific Registers
//
#define SlotRO      0x00003FFF
#define SlotRW      0x7F000000
#define SlotRWC     0x001F0000
#define SlotRsvdP   0x80000000
#define SlotRsvdZ   0x00E0C000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\smbios.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    smbios.h

Abstract:

    This module contains definitions that describe SMBIOS

Author:


    Alan Warwick (AlanWar) 12-Feb-1998


Revision History:


--*/

#ifndef _SMBIOS_
#define _SMBIOS_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)

//
// SMBIOS error codes
#define DMI_SUCCESS 0x00
#define DMI_UNKNOWN_FUNCTION 0x81
#define DMI_FUNCTION_NOT_SUPPORTED 0x82
#define DMI_INVALID_HANDLE 0x83
#define DMI_BAD_PARAMETER 0x84
#define DMI_INVALID_SUBFUNCTION 0x85
#define DMI_NO_CHANGE 0x86
#define DMI_ADD_STRUCTURE_FAILED 0x87

// @@BEGIN_DDKSPLIT

//
// SMBIOS registry values
#define SMBIOSPARENTKEYNAME L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"

#define SMBIOSIDENTIFIERVALUENAME L"Identifier"
#ifdef _IA64_
#define SMBIOSIDENTIFIERVALUEDATA L"SMBIOS"
#else
#define SMBIOSIDENTIFIERVALUEDATA L"PNP BIOS"
#endif
#define SMBIOSDATAVALUENAME     L"Configuration Data"

#define MAXSMBIOSKEYNAMESIZE 256

// @@END_DDKSPLIT

//
// SMBIOS table search
#define SMBIOS_EPS_SEARCH_SIZE      0x10000
#define SMBIOS_EPS_SEARCH_START     0x000f0000
#define SMBIOS_EPS_SEARCH_INCREMENT 0x10

#include <pshpack1.h>
typedef struct _SMBIOS_TABLE_HEADER
{
    UCHAR Signature[4];             // _SM_ (ascii)
    UCHAR Checksum;
    UCHAR Length;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    USHORT MaximumStructureSize;
    UCHAR EntryPointRevision;
    UCHAR Reserved[5];
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} SMBIOS_EPS_HEADER, *PSMBIOS_EPS_HEADER;

#define SMBIOS_EPS_SIGNATURE '_MS_'
#define DMI_EPS_SIGNATURE    'IMD_'

typedef struct _SMBIOS_STRUCT_HEADER
{
    UCHAR Type;
    UCHAR Length;
    USHORT Handle;
    UCHAR Data[];
} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;


typedef struct _DMIBIOS_TABLE_HEADER
{
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} DMIBIOS_EPS_HEADER, *PDMIBIOS_EPS_HEADER;


//
// Definitions for the SMBIOS table BIOS INFORMATION
//
#define SMBIOS_BIOS_INFORMATION_TYPE 0
typedef struct _SMBIOS_BIOS_INFORMATION_STRUCT
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      Handle;

    UCHAR       Vendor;
    UCHAR       Version;
    USHORT      StartingAddressSegment;
    UCHAR       ReleaseDate;
    UCHAR       RomSize;
    ULONG       Characteristics0;
    ULONG       Characteristics1;
    UCHAR       CharacteristicsExtension;
} SMBIOS_BIOS_INFORMATION_STRUCT, *PSMBIOS_BIOS_INFORMATION_STRUCT;



//
// Definitions for the SMBIOS table SYSTEM INFORMATION STRUCTURE
//
#define SMBIOS_SYSTEM_INFORMATION    1
typedef struct _SMBIOS_SYSTEM_INFORMATION_STRUCT
{
    UCHAR Type;
    UCHAR Length;
    USHORT Handle;
    
    UCHAR Manufacturer;     // string
    UCHAR ProductName;      // string
    UCHAR Version;          // string
    UCHAR SerialNumber;     // string
    UCHAR Uuid[16];         // SMBIOS 2.1+
    UCHAR WakeupType;       // SMBIOS 2.1+
} SMBIOS_SYSTEM_INFORMATION_STRUCT, *PSMBIOS_SYSTEM_INFORMATION_STRUCT;

#define SMBIOS_SYSTEM_INFORMATION_LENGTH_20 8



//
// Definitions for the SMBIOS table BASE BOARD INFORMATION
//
#define SMBIOS_BASE_BOARD_INFORMATION_TYPE 2
typedef struct _SMBIOS_BASE_BOARD_INFORMATION_STRUCT
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      Handle;

    UCHAR       Manufacturer;
    UCHAR       Product;
    UCHAR       Version;
    UCHAR       SerialNumber;
} SMBIOS_BASE_BOARD_INFORMATION_STRUCT, *PSMBIOS_BASE_BOARD_INFORMATION_STRUCT;



//
// Definitions for the SMBIOS table BASE BOARD INFORMATION
//
#define SMBIOS_SYSTEM_CHASIS_INFORMATION_TYPE 3
typedef struct _SMBIOS_SYSTEM_CHASIS_INFORMATION_STRUCT
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      Handle;

    UCHAR       Manufacturer;
    UCHAR       ChasisType;
    UCHAR       Version;
    UCHAR       SerialNumber;
    UCHAR       AssetTagNumber;
    UCHAR       BootUpState;
    UCHAR       PowerSupplyState;
    UCHAR       ThernalState;
    UCHAR       SecurityStatus;
    ULONG       OEMDefined;
} SMBIOS_SYSTEM_CHASIS_INFORMATION_STRUCT, *PSMBIOS_SYSTEM_CHASIS_INFORMATION_STRUCT;


//
// Definitions for the SMBIOS table PROCESSOR INFORMATION
//
#define SMBIOS_PROCESSOR_INFORMATION_TYPE 4
typedef struct _SMBIOS_PROCESSOR_INFORMATION_STRUCT
{
    UCHAR       Type;
    UCHAR       Length;
    USHORT      Handle;

    UCHAR       SocketDesignation;
    UCHAR       ProcessorType;
    UCHAR       ProcessorFamily;
    UCHAR       ProcessorManufacturer;
    ULONG       ProcessorID0;
    ULONG       ProcessorID1;
    UCHAR       ProcessorVersion;
    UCHAR       Voltage;
    USHORT      ExternalClock;
    USHORT      MaxSpeed;
    USHORT      CurrentSpeed;
    UCHAR       Status;
    UCHAR       ProcessorUpgrade;
    USHORT      L1CacheHandle;
    USHORT      L2CacheHandle;
    USHORT      L3CacheHandle;
    UCHAR       SerialNumber;
    UCHAR       AssetTag;
} SMBIOS_PROCESSOR_INFORMATION_STRUCT, *PSMBIOS_PROCESSOR_INFORMATION_STRUCT;




//
// Definitions for the SMBIOS table SYSTEM EVENTLOG STRUCTURE
#define SMBIOS_SYSTEM_EVENTLOG 15

//
// ENUM for AccessMethod
//
#define ACCESS_METHOD_INDEXIO_1     0
#define ACCESS_METHOD_INDEXIO_2     1
#define ACCESS_METHOD_INDEXIO_3     2
#define ACCESS_METHOD_MEMMAP        3
#define ACCESS_METHOD_GPNV          4

typedef struct _LOGTYPEDESCRIPTOR
{
    UCHAR LogType;
    UCHAR DataFormatType;
} LOGTYPEDESCRIPTOR, *PLOGTYPEDESCRIPTOR;

typedef struct _ACCESS_METHOD_ADDRESS
{
    union
    {
        struct
        {
            USHORT IndexAddr;
            USHORT DataAddr;            
        } IndexIo;
        
        ULONG PhysicalAddress32;
        
        USHORT GPNVHandle;      
    } AccessMethodAddress;
} ACCESS_METHOD_ADDRESS, *PACCESS_METHOD_ADDRESS;

typedef struct _SMBIOS_SYSTEM_EVENTLOG_STRUCT
{
    UCHAR Type;
    UCHAR Length;
    USHORT Handle;

    USHORT LogAreaLength;
    USHORT LogHeaderStartOffset;
    USHORT LogDataStartOffset;
    UCHAR AccessMethod;
    UCHAR LogStatus;
    ULONG LogChangeToken;
    ACCESS_METHOD_ADDRESS AccessMethodAddress;
    UCHAR LogHeaderFormat;
    UCHAR NumLogTypeDescriptors;
    UCHAR LenLogTypeDescriptors;
    LOGTYPEDESCRIPTOR LogTypeDescriptor[1];
    
} SMBIOS_SYSTEM_EVENTLOG_STRUCT, *PSMBIOS_SYSTEM_EVENTLOG_STRUCT;

#define SMBIOS_SYSTEM_EVENTLOG_LENGTH_20 0x14
#define SMBIOS_SYSTEM_EVENTLOG_LENGTH (FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT, LogTypeDescriptor))

//
// SYSID table search
//

#define SYSID_EPS_SEARCH_SIZE      0x20000
#define SYSID_EPS_SEARCH_START     0x000e0000
#define SYSID_EPS_SEARCH_INCREMENT 0x10

#define SYSID_EPS_SIGNATURE 'SYS_'
#define SYSID_EPS_SIGNATURE2 'DI'

typedef struct _SYSID_EPS_HEADER
{
    UCHAR Signature[7];           // _SYSID_ (ascii)
    UCHAR Checksum;
    USHORT Length;                // Length of SYSID_EPS_HEADER
    ULONG SysIdTableAddress;      // Physical Address of SYSID table
    USHORT SysIdCount;            // Count of SYSIDs in table
    UCHAR BiosRev;                // SYSID Bios revision
} SYSID_EPS_HEADER, *PSYSID_EPS_HEADER;

typedef struct _SYSID_TABLE_ENTRY
{
    UCHAR Type[6];                // _UUID_ or _1394_ (ascii)
    UCHAR Checksum;
    USHORT Length;                // Length of this table
    UCHAR Data[1];                // Variable length UUID/1394 data
} SYSID_TABLE_ENTRY, *PSYSID_TABLE_ENTRY;

#define SYSID_UUID_DATA_SIZE 16

typedef struct _SYSID_UUID_ENTRY
{
    UCHAR Type[6];                // _UUID_ (ascii)
    UCHAR Checksum;
    USHORT Length;                // Length of this table
    UCHAR UUID[SYSID_UUID_DATA_SIZE];  // UUID
} SYSID_UUID_ENTRY, *PSYSID_UUID_ENTRY;

#define SYSID_1394_DATA_SIZE 8

typedef struct _SYSID_1394_ENTRY
{
    UCHAR Type[6];                // _1394_ (ascii)
    UCHAR Checksum;
    USHORT Length;                // Length of this table
    UCHAR x1394Id[SYSID_1394_DATA_SIZE]; // 1394 ID
} SYSID_1394_ENTRY, *PSYSID_1394_ENTRY;

#define LARGEST_SYSID_TABLE_ENTRY (sizeof(SYSID_UUID_ENTRY))

#define SYSID_TYPE_UUID "_UUID_"
#define SYSID_TYPE_1394 "_1394_"
                                    
#include <poppack.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\stktrace.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This header file defines the format of the stack trace data base
    used to track caller backtraces.  This is a header file so debugger
    extensions can lookup entries in the database remotely.

Author:

    Steve Wood (stevewo) 13-Sep-1992

Revision History:

--*/

#ifndef _STKTRACE_H_
#define _STKTRACE_H_

//
// RTL_STACK_TRACE_ENTRY
//    

typedef struct _RTL_STACK_TRACE_ENTRY {

    struct _RTL_STACK_TRACE_ENTRY * HashChain;

    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    
    PVOID BackTrace [MAX_STACK_DEPTH];

} RTL_STACK_TRACE_ENTRY, *PRTL_STACK_TRACE_ENTRY;

//
// RTL_STACK_TRACE_DATABASE
//    

typedef struct _STACK_TRACE_DATABASE {
    
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
        PVOID Lock; // real lock (the other two kept for compatibility)
    };

    PVOID Reserved[3]; // fields no longer used but kept for compatibility
    
    BOOLEAN PreCommitted;
    BOOLEAN DumpInProgress; 

    PVOID CommitBase;
    PVOID CurrentLowerCommitLimit;
    PVOID CurrentUpperCommitLimit;

    PCHAR NextFreeLowerMemory;
    PCHAR NextFreeUpperMemory;

    ULONG NumberOfEntriesLookedUp;
    ULONG NumberOfEntriesAdded;

    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    ULONG NumberOfBuckets;
    PRTL_STACK_TRACE_ENTRY Buckets [1];

} STACK_TRACE_DATABASE, *PSTACK_TRACE_DATABASE;

PSTACK_TRACE_DATABASE
RtlpAcquireStackTraceDataBase ( 
    VOID 
    );

VOID
RtlpReleaseStackTraceDataBase ( 
    VOID 
    );

NTSTATUS
RtlInitializeStackTraceDataBase(
    IN PVOID CommitBase,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize
    );

#endif // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\se.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    se.h

Abstract:

    This module contains the Security routines that are only callable
    from kernel mode.

    This file is included by including "ntos.h".

Author:

    Gary Kimura (GaryKi) 09-Mar-1989

Revision History:



--*/

#ifndef _SE_
#define _SE_



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Kernel mode only data structures                                        //
//  Opaque security data structures are defined in seopaque.h               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
//  Security operation codes
//

typedef enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor,
    QuerySecurityDescriptor,
    DeleteSecurityDescriptor,
    AssignSecurityDescriptor
    } SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp



//
//  Default security quota
//
//  This is the minimum amount of quota (in bytes) that will be
//  charged for security information for an object that has
//  security.
//

#define SE_DEFAULT_SECURITY_QUOTA   2048

// begin_ntifs
//
// Token Flags
//
// Flags that may be defined in the TokenFlags field of the token object,
// or in an ACCESS_STATE structure
//

#define TOKEN_HAS_TRAVERSE_PRIVILEGE    0x01
#define TOKEN_HAS_BACKUP_PRIVILEGE      0x02
#define TOKEN_HAS_RESTORE_PRIVILEGE     0x04
#define TOKEN_HAS_ADMIN_GROUP           0x08
#define TOKEN_IS_RESTRICTED             0x10
#define TOKEN_SESSION_NOT_REFERENCED    0x20
#define TOKEN_SANDBOX_INERT             0x40
#define TOKEN_HAS_IMPERSONATE_PRIVILEGE 0x80

// end_ntifs


//
// General flag
//

#define SE_BACKUP_PRIVILEGES_CHECKED    0x00000010




// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
//
// where
//
//    ClientToken - optionally points to a token object being used by the
//        subject's thread to impersonate a client.  If the subject's
//        thread is not impersonating a client, this field is set to null.
//        The token's reference count is incremented to count this field
//        as an outstanding reference.
//
//    ImpersonationLevel - Contains the impersonation level of the subject's
//        thread.  This field is only meaningful if the ClientToken field
//        is not null.  This field over-rides any higher impersonation
//        level value that might be in the client's token.
//
//    PrimaryToken - points the the subject's primary token.  The token's
//        reference count is incremented to count this field value as an
//        outstanding reference.
//
//    ProcessAuditId - Is an ID assigned to represent the subject's process.
//        As an implementation detail, this is the process object's address.
//        However, this field should not be treated as a pointer, and the
//        reference count of the process object is not incremented to
//        count it as an outstanding reference.
//


// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be imbedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//

#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;



//
// Combine the information that describes the state
// of an access-in-progress into a single structure
//


typedef struct _ACCESS_STATE {
   LUID OperationID;
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor;
   PVOID AuxData;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;

   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

/*
where:

    OperationID - an LUID to identify the operation being performed.  This
        ID will be put in the audit log to allow non-contiguous operations
        on the same object to be associated with one another.

    SecurityEvaluated - a marker to be set by Parse Methods to indicate
        that security access checking and audit logging has been performed.

    Flags - Holds misc flags for reference during the access attempt.

    AuditHandleCreation - a flag set by SeOpenObjectAuditAlarm to indicate
        that auditing is to take place when the handle for the object
        is allocated.

    RemainingDesiredAccess - Access mask containing the access types that
        have not yet been granted.

    PreviouslyGrantedAccess - Access mask containing the access types that
        have been granted, one way or another (for example, a given access
        may be granted as a result of owning a privilege rather than being
        in an ACL.  A routine can check the privilege and mark the access
        as granted without doing a formal access check).

    SubjectSecurityContext - The subject's captured security context

    PrivilegesAllocated - Flag to indicate whether we have allocated
        space for the privilege set from pool memory, so it can be
        freed.

    SecurityDescriptor - Temporarily contains the security descriptor
       for the object being created between the time the user's
       security descriptor is captured and the time the security
       descriptor is passed to SeAssignSecurity.  NO ONE BUT
       SEASSIGNSECURITY SHOULD EVER LOOK IN THIS FIELD FOR AN
       OBJECT'S SECURITY DESCRIPTOR.

    AuxData - points to an auxillary data structure to be used for future
        expansion of the access state in an upwardly compatible way.  This
        field replaces the PrivilegesUsed pointer, which was for internal
        use only.

    Privileges - A set of privileges, some of which may have the
        UsedForAccess bit set.  If the pre-allocated number of privileges
        is not enough, we will allocate space from pool memory to allow
        for growth.

*/



//*******************************************************************************
//                                                                              *
//  Since the AccessState structure is publically exposed to driver             *
//  writers, this structure contains additional data added after NT 3.51.       *
//                                                                              *
//  Its contents must be accessed only through Se level interfaces,             *
//  never directly by name.                                                     *
//                                                                              *
//  This structure is pointed to by the AuxData field of the AccessState.       *
//  It is allocated by SeCreateAccessState and freed by SeDeleteAccessState.    *
//                                                                              *
//  DO NOT EXPOSE THIS STRUCTURE TO THE PUBLIC.                                 *
//                                                                              *
//*******************************************************************************

// begin_ntosp
typedef struct _AUX_ACCESS_DATA {
    PPRIVILEGE_SET PrivilegesUsed;
    GENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessesToAudit;
    ACCESS_MASK MaximumAuditMask;
} AUX_ACCESS_DATA, *PAUX_ACCESS_DATA;
// end_ntosp

/*
where:

    PrivilegesUsed - Points to the set of privileges used during the access
        validation.

    GenericMapping - Points to the generic mapping for the object being accessed.
        Normally this would be filled in with the generic mapping passed to
        SeCreateAccessState, but in the case of the IO system (which does not
        know the type of object being accessed until it parses the name),
        it must be filled in later.  See the discussion of the GenericMapping
        parameter in SeCreateAccessState for more details.

    AccessToAudit - Used as a temporary holding area for the access mask
        to put into the audit record.  This field is necessary because the
        access being put into the newly created handle may not be the ones
        we want to audit.  This occurs when a file is opened for read-only
        transacted mode, where a read only file is opened for write access.
        We don't want to audit the fact that we granted write access, since
        we really didn't, and customers would be confused to see the extra
        bit in the audit record.

   MaximumAuditMask - Stores the audit mask that will be stored into the
        new handle structure to support operation based audits.

*/



//
//  Structure describing whether or not a particular type of event
//  is being audited
//

typedef struct _SE_AUDITING_STATE {
    BOOLEAN AuditOnSuccess;
    BOOLEAN AuditOnFailure;
} SE_AUDITING_STATE, *PSE_AUDITING_STATE;




typedef struct _SE_PROCESS_AUDIT_INFO {
    PEPROCESS Process;
    PEPROCESS Parent;
} SE_PROCESS_AUDIT_INFO, *PSE_PROCESS_AUDIT_INFO;




/************************************************************

                 WARNING WARNING WARNING


    Only add new fields to the end of this structure.


*************************************************************/

// begin_ntifs begin_ntosp

typedef struct _SE_EXPORTS {

    //
    // Privilege values
    //

    LUID    SeCreateTokenPrivilege;
    LUID    SeAssignPrimaryTokenPrivilege;
    LUID    SeLockMemoryPrivilege;
    LUID    SeIncreaseQuotaPrivilege;
    LUID    SeUnsolicitedInputPrivilege;
    LUID    SeTcbPrivilege;
    LUID    SeSecurityPrivilege;
    LUID    SeTakeOwnershipPrivilege;
    LUID    SeLoadDriverPrivilege;
    LUID    SeCreatePagefilePrivilege;
    LUID    SeIncreaseBasePriorityPrivilege;
    LUID    SeSystemProfilePrivilege;
    LUID    SeSystemtimePrivilege;
    LUID    SeProfileSingleProcessPrivilege;
    LUID    SeCreatePermanentPrivilege;
    LUID    SeBackupPrivilege;
    LUID    SeRestorePrivilege;
    LUID    SeShutdownPrivilege;
    LUID    SeDebugPrivilege;
    LUID    SeAuditPrivilege;
    LUID    SeSystemEnvironmentPrivilege;
    LUID    SeChangeNotifyPrivilege;
    LUID    SeRemoteShutdownPrivilege;


    //
    // Universally defined Sids
    //


    PSID  SeNullSid;
    PSID  SeWorldSid;
    PSID  SeLocalSid;
    PSID  SeCreatorOwnerSid;
    PSID  SeCreatorGroupSid;


    //
    // Nt defined Sids
    //


    PSID  SeNtAuthoritySid;
    PSID  SeDialupSid;
    PSID  SeNetworkSid;
    PSID  SeBatchSid;
    PSID  SeInteractiveSid;
    PSID  SeLocalSystemSid;
    PSID  SeAliasAdminsSid;
    PSID  SeAliasUsersSid;
    PSID  SeAliasGuestsSid;
    PSID  SeAliasPowerUsersSid;
    PSID  SeAliasAccountOpsSid;
    PSID  SeAliasSystemOpsSid;
    PSID  SeAliasPrintOpsSid;
    PSID  SeAliasBackupOpsSid;

    //
    // New Sids defined for NT5
    //

    PSID  SeAuthenticatedUsersSid;

    PSID  SeRestrictedSid;
    PSID  SeAnonymousLogonSid;

    //
    // New Privileges defined for NT5
    //

    LUID  SeUndockPrivilege;
    LUID  SeSyncAgentPrivilege;
    LUID  SeEnableDelegationPrivilege;

    //
    // New Sids defined for post-Windows 2000

    PSID  SeLocalServiceSid;
    PSID  SeNetworkServiceSid;

    //
    // New Privileges defined for post-Windows 2000
    //

    LUID  SeManageVolumePrivilege;
    LUID  SeImpersonatePrivilege;
    LUID  SeCreateGlobalPrivilege;

} SE_EXPORTS, *PSE_EXPORTS;

// end_ntifs end_ntosp

/************************************************************


                 WARNING WARNING WARNING


    Only add new fields to the end of this structure.


*************************************************************/



// begin_ntifs
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//              Logon session notification callback routines                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  These callback routines are used to notify file systems that have
//  registered of logon sessions being terminated, so they can cleanup state
//  associated with this logon session
//

typedef NTSTATUS
(*PSE_LOGON_SESSION_TERMINATED_ROUTINE)(
    IN PLUID LogonId);

// end_ntifs





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  Exported Security Macro Definitions                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//++
//
//  ACCESS_MASK
//  SeComputeDeniedAccesses(
//      IN ACCESS_MASK GrantedAccess,
//      IN ACCESS_MASK DesiredAccess
//      );
//
//  Routine Description:
//
//      This routine generates an access mask containing those accesses
//      requested by DesiredAccess that aren't granted by GrantedAccess.
//      The result of this routine may be compared to 0 to determine
//      if a DesiredAccess mask contains any accesses that have not
//      been granted.
//
//      If the result IS ZERO, then all desired accesses have been granted.
//
//  Arguments:
//
//      GrantedAccess - Specifies the granted access mask.
//
//      DesiredAccess - Specifies the desired access mask.
//
//  Return Value:
//
//      An ACCESS_MASK containing the desired accesses that have
//      not been granted.
//
//--

#define SeComputeDeniedAccesses( GrantedAccess, DesiredAccess ) \
    ((~(GrantedAccess)) & (DesiredAccess) )


//++
//
//  BOOLEAN
//  SeComputeGrantedAccesses(
//      IN ACCESS_MASK GrantedAccess,
//      IN ACCESS_MASK DesiredAccess
//      );
//
//  Routine Description:
//
//      This routine generates an access mask containing acccesses
//      requested by DesiredAccess that are granted by GrantedAccess.
//      The result of this routine may be compared to 0 to determine
//      if any desired accesses have been granted.
//
//      If the result IS NON-ZERO, then at least one desired accesses
//      has been granted.
//
//  Arguments:
//
//      GrantedAccess - Specifies the granted access mask.
//
//      DesiredAccess - Specifies the desired access mask.
//
//  Return Value:
//
//      This routine returns TRUE if the DesiredAccess mask does specifies
//      any bits that are set in the GrantedAccess mask.
//
//--

#define SeComputeGrantedAccesses( GrantedAccess, DesiredAccess ) \
    ((GrantedAccess) & (DesiredAccess) )


// begin_ntifs
//++
//
//  ULONG
//  SeLengthSid(
//      IN PSID Sid
//      );
//
//  Routine Description:
//
//      This routine computes the length of a SID.
//
//  Arguments:
//
//      Sid - Points to the SID whose length is to be returned.
//
//  Return Value:
//
//      The length, in bytes of the SID.
//
//--

#define SeLengthSid( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))

// end_ntifs


//++
//  BOOLEAN
//  SeSameToken (
//      IN PTOKEN_CONTROL TokenControl1,
//      IN PTOKEN_CONTROL TokenControl2
//      )
//
//
//  Routine Description:
//
//      This routine returns a boolean value indicating whether the two
//      token control values represent the same token.  The token may
//      have changed over time, but must have the same authentication ID
//      and token ID.  A value of TRUE indicates they
//      are equal.  A value of FALSE indicates they are not equal.
//
//
//
//  Arguments:
//
//      TokenControl1 - Points to a token control to compare.
//
//      TokenControl2 - Points to the other token control to compare.
//
//  Return Value:
//
//      TRUE => The token control values represent the same token.
//
//      FALSE => The token control values do not represent the same token.
//
//
//--

#define SeSameToken(TC1,TC2)  (                                               \
        ((TC1)->TokenId.HighPart == (TC2)->TokenId.HighPart)               && \
        ((TC1)->TokenId.LowPart  == (TC2)->TokenId.LowPart)                && \
        (RtlEqualLuid(&(TC1)->AuthenticationId,&(TC2)->AuthenticationId))     \
        )


// begin_ntifs
//
//VOID
//SeDeleteClientSecurity(
//    IN PSECURITY_CLIENT_CONTEXT ClientContext
//    )
//
///*++
//
//Routine Description:
//
//    This service deletes a client security context block,
//    performing whatever cleanup might be necessary to do so.  In
//    particular, reference to any client token is removed.
//
//Arguments:
//
//    ClientContext - Points to the client security context block to be
//        deleted.
//
//
//Return Value:
//
//
//
//--*/
//--

// begin_ntosp
#define SeDeleteClientSecurity(C)  {                                           \
            if (SeTokenType((C)->ClientToken) == TokenPrimary) {               \
                PsDereferencePrimaryToken( (C)->ClientToken );                 \
            } else {                                                           \
                PsDereferenceImpersonationToken( (C)->ClientToken );           \
            }                                                                  \
        }


//++
//VOID
//SeStopImpersonatingClient()
//
///*++
//
//Routine Description:
//
//    This service is used to stop impersonating a client using an
//    impersonation token.  This service must be called in the context
//    of the server thread which wishes to stop impersonating its
//    client.
//
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//--

#define SeStopImpersonatingClient() PsRevertToSelf()

// end_ntosp end_ntifs

#define SeAssertMappedCanonicalAccess( AccessMask )                  \
    ASSERT(!( ( AccessMask ) &                                       \
            ( GENERIC_READ        |                                  \
              GENERIC_WRITE       |                                  \
              GENERIC_EXECUTE     |                                  \
              GENERIC_ALL ))                                         \
          )
/*++

Routine Description:

    This routine asserts that the given AccessMask does not contain
    any generic access types.

Arguments:

    AccessMask - The access mask to be checked.

Return Value:

    None, or doesn't return.

--*/



#define SeComputeSecurityQuota( Size )                                 \
    (                                                                  \
       ((( Size ) * 2 )  > SE_DEFAULT_SECURITY_QUOTA) ?                \
                    (( Size ) * 2 ) : SE_DEFAULT_SECURITY_QUOTA        \
    )

/*++

Routine Description:

    This macro computes the amount of quota to charge for
    security information.

    The current algorithm is to use the larger of twice the size
    of the Group + Dacl information being applied and the default as
    specified by SE_DEFAULT_SECURITY_QUOTA.

Arguments:

    Size - The size in bytes of the Group + Dacl information being applied
        to the object.

Return Value:

    The size in bytes to charge for security information on this object.

--*/

// begin_ntifs begin_ntosp

//++
//
//  PACCESS_TOKEN
//  SeQuerySubjectContextToken(
//      IN PSECURITY_SUBJECT_CONTEXT SubjectContext
//      );
//
//  Routine Description:
//
//      This routine returns the effective token from the subject context,
//      either the client token, if present, or the process token.
//
//  Arguments:
//
//      SubjectContext - Context to query
//
//  Return Value:
//
//      This routine returns the PACCESS_TOKEN for the effective token.
//      The pointer may be passed to SeQueryInformationToken.  This routine
//      does not affect the lock status of the token, i.e. the token is not
//      locked.  If the SubjectContext has been locked, the token remains locked,
//      if not, the token remains unlocked.
//
//--

#define SeQuerySubjectContextToken( SubjectContext ) \
        ( ARGUMENT_PRESENT( ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken) ? \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken : \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->PrimaryToken )

// end_ntifs end_ntosp





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Define the exported procedures that are callable only from kernel mode   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SeInitSystem( VOID );

VOID
SeSetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );

VOID
SeQuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );


NTSTATUS
SeDefaultObjectMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
SeCaptureSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

NTKERNELAPI
VOID
SeReleaseSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR CapturedSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );

// begin_ntifs

NTKERNELAPI
VOID
SeCaptureSubjectContext (
    OUT PSECURITY_SUBJECT_CONTEXT SubjectContext
    );


NTKERNELAPI
VOID
SeLockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTKERNELAPI
VOID
SeUnlockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTKERNELAPI
VOID
SeReleaseSubjectContext (
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTSTATUS
SeCaptureAuditPolicy(
    IN PTOKEN_AUDIT_POLICY Policy,
    IN KPROCESSOR_MODE RequestorMode,
    IN PVOID CaptureBuffer OPTIONAL,
    IN ULONG CaptureBufferLength,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PTOKEN_AUDIT_POLICY *CapturedPolicy
    );

VOID
SeReleaseAuditPolicy (
    IN PTOKEN_AUDIT_POLICY CapturedPolicy,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );

// end_ntifs end_ntosp

VOID
SeCaptureSubjectContextEx (
    IN PETHREAD Thread,
    IN PEPROCESS Process,
    OUT PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTSTATUS
SeCaptureSecurityQos (
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode,
    IN PBOOLEAN SecurityQosPresent,
    IN PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
    );

VOID
SeFreeCapturedSecurityQos(
    IN PVOID SecurityQos
    );

NTSTATUS
SeCaptureSid (
    IN PSID InputSid,
    IN KPROCESSOR_MODE RequestorMode,
    IN PVOID CaptureBuffer OPTIONAL,
    IN ULONG CaptureBufferLength,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSID *CapturedSid
    );


VOID
SeReleaseSid (
    IN PSID CapturedSid,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );


NTSTATUS
SeCaptureAcl (
    IN PACL InputAcl,
    IN KPROCESSOR_MODE RequestorMode,
    IN PVOID CaptureBuffer OPTIONAL,
    IN ULONG CaptureBufferLength,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PACL *CapturedAcl,
    OUT PULONG AlignedAclSize
    );


VOID
SeReleaseAcl (
    IN PACL CapturedAcl,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );


NTSTATUS
SeCaptureLuidAndAttributesArray (
    IN PLUID_AND_ATTRIBUTES InputArray,
    IN ULONG ArrayCount,
    IN KPROCESSOR_MODE RequestorMode,
    IN PVOID CaptureBuffer OPTIONAL,
    IN ULONG CaptureBufferLength,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PLUID_AND_ATTRIBUTES *CapturedArray,
    OUT PULONG AlignedArraySize
    );



VOID
SeReleaseLuidAndAttributesArray (
    IN PLUID_AND_ATTRIBUTES CapturedArray,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );



NTSTATUS
SeCaptureSidAndAttributesArray (
    IN PSID_AND_ATTRIBUTES InputArray,
    IN ULONG ArrayCount,
    IN KPROCESSOR_MODE RequestorMode,
    IN PVOID CaptureBuffer OPTIONAL,
    IN ULONG CaptureBufferLength,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSID_AND_ATTRIBUTES *CapturedArray,
    OUT PULONG AlignedArraySize
    );


VOID
SeReleaseSidAndAttributesArray (
    IN PSID_AND_ATTRIBUTES CapturedArray,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
NTSTATUS
SeAssignSecurity (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ExplicitDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
NTSTATUS
SeAssignSecurityEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ExplicitDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
NTSTATUS
SeDeassignSecurity (
    IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTKERNELAPI
BOOLEAN
SeAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN BOOLEAN SubjectContextLocked,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


#ifdef SE_NTFS_WORLD_CACHE

VOID
SeGetWorldRights (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK GrantedAccess
    );

#endif

// end_ntddk end_wdm end_ntifs end_ntosp

BOOLEAN
SeProxyAccessCheck (
    IN PUNICODE_STRING Volume,
    IN PUNICODE_STRING RelativePath,
    IN BOOLEAN ContainerObject,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN BOOLEAN SubjectContextLocked,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );

// begin_ntifs begin_ntosp

NTKERNELAPI
BOOLEAN
SePrivilegeCheck(
    IN OUT PPRIVILEGE_SET RequiredPrivileges,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
SeFreePrivileges(
    IN PPRIVILEGE_SET Privileges
    );

// end_ntifs end_ntosp

NTSTATUS
SePrivilegePolicyCheck(
    IN OUT PACCESS_MASK RemainingDesiredAccess,
    IN OUT PACCESS_MASK PreviouslyGrantedAccess,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL,
    IN PACCESS_TOKEN Token OPTIONAL,
    OUT PPRIVILEGE_SET *PrivilegeSet,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
SeGenerateMessage (
    IN PSTRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_TOKEN Token,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted,
    IN HANDLE AuditPort,
    IN HANDLE AlarmPort,
    IN KPROCESSOR_MODE AccessMode
    );

// begin_ntifs

NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    IN PUNICODE_STRING ObjectTypeName,
    IN PVOID Object OPTIONAL,
    IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN ObjectCreated,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode,
    OUT PBOOLEAN GenerateOnClose
    );

NTKERNELAPI
VOID
SeOpenObjectForDeleteAuditAlarm (
    IN PUNICODE_STRING ObjectTypeName,
    IN PVOID Object OPTIONAL,
    IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN ObjectCreated,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode,
    OUT PBOOLEAN GenerateOnClose
    );

VOID
SeDeleteObjectAuditAlarm(
    IN PVOID Object,
    IN HANDLE Handle
    );


// end_ntifs

VOID
SeCloseObjectAuditAlarm(
    IN PVOID Object,
    IN HANDLE Handle,
    IN BOOLEAN GenerateOnClose
    );

VOID
SeCreateInstanceAuditAlarm(
    IN PLUID OperationID OPTIONAL,
    IN PVOID Object,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode
    );

VOID
SeCreateObjectAuditAlarm(
    IN PLUID OperationID OPTIONAL,
    IN PVOID Object,
    IN PUNICODE_STRING ComponentName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN AuditPerformed,
    IN KPROCESSOR_MODE AccessMode
    );

VOID
SeObjectReferenceAuditAlarm(
    IN PLUID OperationID OPTIONAL,
    IN PVOID Object,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode
    );

// begin_ntosp
NTKERNELAPI
VOID
SePrivilegeObjectAuditAlarm(
    IN HANDLE Handle,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode
    );
// end_ntosp

BOOLEAN
SeCheckPrivilegedObject(
    LUID PrivilegeValue,
    HANDLE ObjectHandle,
    ACCESS_MASK DesiredAccess,
    KPROCESSOR_MODE PreviousMode
    );

// begin_ntddk begin_wdm begin_ntifs

NTKERNELAPI
BOOLEAN
SeValidSecurityDescriptor(
    IN ULONG Length,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

// end_ntddk end_wdm end_ntifs



//VOID
//SeImplicitObjectAuditAlarm(
//    IN PLUID OperationID OPTIONAL,
//    IN PVOID Object,
//    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
//    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
//    IN ACCESS_MASK DesiredAccess,
//    IN PPRIVILEGE_SET Privileges OPTIONAL,
//    IN BOOLEAN AccessGranted,
//    IN KPROCESSOR_MODE AccessMode
//    );
//

VOID
SeAuditHandleCreation(
    IN PACCESS_STATE AccessState,
    IN HANDLE Handle
    );



PACCESS_TOKEN
SeMakeSystemToken (
    VOID
    );

PACCESS_TOKEN
SeMakeAnonymousLogonToken (
    VOID
    );

PACCESS_TOKEN
SeMakeAnonymousLogonTokenNoEveryone (
    VOID
    );

VOID
SeGetTokenControlInformation (
    IN PACCESS_TOKEN Token,
    OUT PTOKEN_CONTROL TokenControl
    );

// begin_ntosp
extern struct _OBJECT_TYPE *SeTokenObjectType;

NTKERNELAPI                                     // ntifs
TOKEN_TYPE                                      // ntifs
SeTokenType(                                    // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs

SECURITY_IMPERSONATION_LEVEL
SeTokenImpersonationLevel(
    IN PACCESS_TOKEN Token
    );

NTKERNELAPI                                     // ntifs
BOOLEAN                                         // ntifs
SeTokenIsAdmin(                                 // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs


NTKERNELAPI                                     // ntifs
BOOLEAN                                         // ntifs
SeTokenIsRestricted(                            // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs

NTKERNELAPI
NTSTATUS
SeTokenCanImpersonate(
    IN PACCESS_TOKEN ProcessToken,
    IN PACCESS_TOKEN Token,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
// end_ntosp

NTSTATUS
SeSubProcessToken (
    IN  PACCESS_TOKEN ParentToken,
    OUT PACCESS_TOKEN *ChildToken,
    IN  BOOLEAN MarkAsActive,
    IN  ULONG SessionId
    );

VOID
SeAssignPrimaryToken(
    IN PEPROCESS Process,
    IN PACCESS_TOKEN Token
    );

VOID
SeDeassignPrimaryToken(
    IN PEPROCESS Process
    );

NTSTATUS
SeExchangePrimaryToken(
    IN PEPROCESS Process,
    IN PACCESS_TOKEN NewAccessToken,
    OUT PACCESS_TOKEN *OldAccessToken
    );

NTSTATUS
SeCopyClientToken(
    IN PACCESS_TOKEN ClientToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PACCESS_TOKEN *DuplicateToken
    );

// begin_ntifs
NTSTATUS
SeFilterToken (
    IN PACCESS_TOKEN ExistingToken,
    IN ULONG Flags,
    IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
    IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
    IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
    OUT PACCESS_TOKEN * FilteredToken
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
SeQueryAuthenticationIdToken(
    IN PACCESS_TOKEN Token,
    OUT PLUID AuthenticationId
    );

// end_ntosp
NTKERNELAPI
NTSTATUS
SeQuerySessionIdToken(
    IN PACCESS_TOKEN,
    IN PULONG pSessionId
    );

NTKERNELAPI
NTSTATUS
SeSetSessionIdToken(
    IN PACCESS_TOKEN,
    IN ULONG SessionId
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
SeCreateClientSecurity (
    IN PETHREAD ClientThread,
    IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    IN BOOLEAN RemoteSession,
    OUT PSECURITY_CLIENT_CONTEXT ClientContext
    );
// end_ntosp

NTKERNELAPI
VOID
SeImpersonateClient(
    IN PSECURITY_CLIENT_CONTEXT ClientContext,
    IN PETHREAD ServerThread OPTIONAL
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
SeImpersonateClientEx(
    IN PSECURITY_CLIENT_CONTEXT ClientContext,
    IN PETHREAD ServerThread OPTIONAL
    );
// end_ntosp

NTKERNELAPI
NTSTATUS
SeCreateClientSecurityFromSubjectContext (
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    IN BOOLEAN ServerIsRemote,
    OUT PSECURITY_CLIENT_CONTEXT ClientContext
    );

// end_ntifs

//
// Do not export the following routines to drivers.
// If you need to do so, create a new routine that
// does not take the AuxData parameter and export
// that.
//

// begin_ntosp
NTKERNELAPI
NTSTATUS
SeCreateAccessState(
   IN PACCESS_STATE AccessState,
   IN PAUX_ACCESS_DATA AuxData,
   IN ACCESS_MASK DesiredAccess,
   IN PGENERIC_MAPPING GenericMapping
   );

NTKERNELAPI
VOID
SeDeleteAccessState(
    IN PACCESS_STATE AccessState
    );
// end_ntosp

NTSTATUS
SeCreateAccessStateEx(
   IN PETHREAD Thread OPTIONAL,
   IN PEPROCESS PRocess,
   IN PACCESS_STATE AccessState,
   IN PAUX_ACCESS_DATA AuxData,
   IN ACCESS_MASK DesiredAccess,
   IN PGENERIC_MAPPING GenericMapping OPTIONAL
   );

NTSTATUS
SeUpdateClientSecurity(
    IN PETHREAD ClientThread,
    IN OUT PSECURITY_CLIENT_CONTEXT ClientContext,
    OUT PBOOLEAN ChangesMade,
    OUT PBOOLEAN NewToken
    );

BOOLEAN
SeRmInitPhase1(
    VOID
    );

NTSTATUS
SeInitializeProcessAuditName (
    IN PVOID FileObject,
    IN BOOLEAN bIgnoreAuditPolicy,
    OUT POBJECT_NAME_INFORMATION *pAuditName
    );

NTSTATUS
SeLocateProcessImageName(
    IN PEPROCESS Process,
    IN PUNICODE_STRING *pImageFileName
    );

VOID
SeAuditSystemTimeChange(
    IN LARGE_INTEGER OldTime,
    IN LARGE_INTEGER NewTime
    );


// begin_ntifs begin_ntosp

NTKERNELAPI
NTSTATUS
SeQuerySecurityDescriptorInfo (
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );

NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfo (
    IN PVOID Object OPTIONAL,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfoEx (
    IN PVOID Object OPTIONAL,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTKERNELAPI
NTSTATUS
SeAppendPrivileges(
    PACCESS_STATE AccessState,
    PPRIVILEGE_SET Privileges
    );

// end_ntifs end_ntosp

NTSTATUS
SeComputeQuotaInformationSize(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PULONG Size
    );

VOID
SePrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING ServiceName,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );

NTKERNELAPI                                                     // ntddk ntifs ntosp
BOOLEAN                                                         // ntddk ntifs ntosp
SeSinglePrivilegeCheck(                                         // ntddk ntifs ntosp
    LUID PrivilegeValue,                                        // ntddk ntifs ntosp
    KPROCESSOR_MODE PreviousMode                                // ntddk ntifs ntosp
    );                                                          // ntddk ntifs ntosp

BOOLEAN
SeCheckAuditPrivilege (
   IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
   IN KPROCESSOR_MODE PreviousMode
   );

NTSTATUS
SeAssignWorldSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_INFORMATION SecurityInformation
    );

BOOLEAN
SeFastTraverseCheck(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState    OPTIONAL,
    IN ACCESS_MASK TraverseAccess,
    IN KPROCESSOR_MODE AccessMode
    );

// begin_ntifs

NTKERNELAPI
BOOLEAN
SeAuditingFileEvents(
    IN BOOLEAN AccessGranted,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI
BOOLEAN
SeAuditingFileEventsWithContext(
    IN BOOLEAN AccessGranted,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL
    );

NTKERNELAPI
BOOLEAN
SeAuditingHardLinkEvents(
    IN BOOLEAN AccessGranted,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI
BOOLEAN
SeAuditingHardLinkEventsWithContext(
    IN BOOLEAN AccessGranted,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL
    );

NTKERNELAPI
BOOLEAN
SeAuditingFileOrGlobalEvents(
    IN BOOLEAN AccessGranted,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

NTKERNELAPI
BOOLEAN
FASTCALL
SeDetailedAuditingWithToken(
    IN PACCESS_TOKEN AccessToken OPTIONAL
    );

// end_ntifs

VOID
SeAuditProcessCreation(
    PEPROCESS Process
    );

VOID
SeAuditProcessExit(
    PEPROCESS Process
    );

VOID                                                            // ntifs
SeAuditHardLinkCreation(                                        // ntifs
    IN PUNICODE_STRING FileName,                                // ntifs
    IN PUNICODE_STRING LinkName,                                // ntifs
    IN BOOLEAN bSuccess                                         // ntifs
    );                                                          // ntifs

VOID
SeAuditLPCInvalidUse(
    IN PUNICODE_STRING LpcCallName,
    IN PUNICODE_STRING LpcServerPort
    );

VOID
SeAuditHandleDuplication(
    PVOID SourceHandle,
    PVOID NewHandle,
    PEPROCESS SourceProcess,
    PEPROCESS TargetProcess
    );

VOID
SeMaximumAuditMask(
    IN PACL Sacl,
    IN ACCESS_MASK GrantedAccess,
    IN PACCESS_TOKEN Token,
    OUT PACCESS_MASK pAuditMask
    );

VOID
SeOperationAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName OPTIONAL,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK AuditMask,
    IN PSID UserSid OPTIONAL
    );

VOID
SeAddSaclToProcess(
    IN PEPROCESS Process,
    IN PACCESS_TOKEN Token,
    IN PVOID Reserved
    );

// begin_ntifs

VOID
SeSetAccessStateGenericMapping (
    PACCESS_STATE AccessState,
    PGENERIC_MAPPING GenericMapping
    );

// end_ntifs

// begin_ntifs

NTKERNELAPI
NTSTATUS
SeRegisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    );

NTKERNELAPI
NTSTATUS
SeUnregisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    );

NTKERNELAPI
NTSTATUS
SeMarkLogonSessionForTerminationNotification(
    IN PLUID LogonId
    );

// begin_ntosp

NTKERNELAPI
NTSTATUS
SeQueryInformationToken (
    IN PACCESS_TOKEN Token,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID *TokenInformation
    );

// end_ntifs end_ntosp

NTSTATUS
SeIsChildToken(
    IN HANDLE Token,
    OUT PBOOLEAN IsChild
    );

NTSTATUS
SeIsChildTokenByPointer(
    IN PACCESS_TOKEN Token,
    OUT PBOOLEAN IsChild
    );


NTSTATUS
SeFastFilterToken(
    IN PACCESS_TOKEN ExistingToken,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG Flags,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES GroupsToDisable OPTIONAL,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES PrivilegesToDelete OPTIONAL,
    IN ULONG SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids OPTIONAL,
    IN ULONG SidLength,
    OUT PACCESS_TOKEN * FilteredToken
    );

////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Global, READ ONLY, Security variables                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// **************************************************************
//
//              C A V E A T      P R O G R A M M E R
//
//
//  If you wish to include this file in an NT driver and use SeExports structure
//  defined above, you need to call:
//
//
//      SeEnableAccessToExports()
//
//  exactly once during initialization.
//
//              C A V E A T      P R O G R A M M E R
//
// **************************************************************
#if 0
#define SeEnableAccessToExports() SeExports = *(PSE_EXPORTS *)SeExports;
extern PSE_EXPORTS SeExports;
#else

// begin_ntifs begin_ntosp
//
//  Grants access to SeExports structure
//

extern NTKERNELAPI PSE_EXPORTS SeExports;

// end_ntifs end_ntosp
#endif

//
// Value used to represent the authentication ID of system processes
//

extern const LUID SeSystemAuthenticationId;
extern const LUID SeAnonymousAuthenticationId;

extern const TOKEN_SOURCE SeSystemTokenSource;

//
// Universal well known SIDs
//

extern PSID  SeNullSid;
extern PSID  SeWorldSid;
extern PSID  SeLocalSid;
extern PSID  SeCreatorOwnerSid;
extern PSID  SeCreatorGroupSid;
extern PSID  SeCreatorOwnerServerSid;
extern PSID  SeCreatorGroupServerSid;
extern PSID  SePrincipalSelfSid;


//
// Sids defined by NT
//

extern PSID SeNtAuthoritySid;

extern PSID SeDialupSid;
extern PSID SeNetworkSid;
extern PSID SeBatchSid;
extern PSID SeInteractiveSid;
extern PSID SeLocalSystemSid;
extern PSID SeAuthenticatedUsersSid;
extern PSID SeAliasAdminsSid;
extern PSID SeRestrictedSid;
extern PSID SeAnonymousLogonSid;
extern PSID SeAliasUsersSid;
extern PSID SeAliasGuestsSid;
extern PSID SeAliasPowerUsersSid;
extern PSID SeAliasAccountOpsSid;
extern PSID SeAliasSystemOpsSid;
extern PSID SeAliasPrintOpsSid;
extern PSID SeAliasBackupOpsSid;

//
// Well known tokens
//

extern PACCESS_TOKEN SeAnonymousLogonToken;
extern PACCESS_TOKEN SeAnonymousLogonTokenNoEveryone;

//
// System default DACLs & Security Descriptors
//

extern PSECURITY_DESCRIPTOR SePublicDefaultSd;
extern PSECURITY_DESCRIPTOR SePublicDefaultUnrestrictedSd;
extern PSECURITY_DESCRIPTOR SePublicOpenSd;
extern PSECURITY_DESCRIPTOR SePublicOpenUnrestrictedSd;
extern PSECURITY_DESCRIPTOR SeSystemDefaultSd;
extern PSECURITY_DESCRIPTOR SeLocalServicePublicSd;

extern PACL SePublicDefaultDacl;
extern PACL SePublicDefaultUnrestrictedDacl;
extern PACL SePublicOpenDacl;
extern PACL SePublicOpenUnrestrictedDacl;
extern PACL SeSystemDefaultDacl;
extern PACL SeUnrestrictedDacl;
extern PACL SeLocalServicePublicDacl;

//
//  Well known privilege values
//


extern LUID SeCreateTokenPrivilege;
extern LUID SeAssignPrimaryTokenPrivilege;
extern LUID SeLockMemoryPrivilege;
extern LUID SeIncreaseQuotaPrivilege;
extern LUID SeUnsolicitedInputPrivilege;
extern LUID SeTcbPrivilege;
extern LUID SeSecurityPrivilege;
extern LUID SeTakeOwnershipPrivilege;
extern LUID SeLoadDriverPrivilege;
extern LUID SeCreatePagefilePrivilege;
extern LUID SeIncreaseBasePriorityPrivilege;
extern LUID SeSystemProfilePrivilege;
extern LUID SeSystemtimePrivilege;
extern LUID SeProfileSingleProcessPrivilege;
extern LUID SeCreatePermanentPrivilege;
extern LUID SeBackupPrivilege;
extern LUID SeRestorePrivilege;
extern LUID SeShutdownPrivilege;
extern LUID SeDebugPrivilege;
extern LUID SeAuditPrivilege;
extern LUID SeSystemEnvironmentPrivilege;
extern LUID SeChangeNotifyPrivilege;
extern LUID SeRemoteShutdownPrivilege;
extern LUID SeUndockPrivilege;
extern LUID SeSyncAgentPrivilege;
extern LUID SeEnableDelegationPrivilege;
extern LUID SeManageVolumePrivilege;
extern LUID SeImpersonatePrivilege;
extern LUID SeCreateGlobalPrivilege;

//
// Auditing information array
//

extern SE_AUDITING_STATE SeAuditingState[];

extern const UNICODE_STRING SeSubsystemName;


#endif // _SE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\v86emul.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    v86emul.h

Abstract:

    This module contains the V86 instruction emulator interface definitions
    used by kernel device drivers.

Author:

    Andre Vachon (andreva) 8-Jan-1992

Revision History:


--*/

#ifndef _V86EMUL_
#define _V86EMUL_


// begin_ntminiport begin_ntosp

//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

// end_ntminiport

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data,
    IN ULONG DataLength
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data,
    IN ULONG DataLength // number of words
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data,
    IN ULONG DataLength  // number of dwords
    );

// end_ntosp
#endif // _V86EMUL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\tape.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tape.h

Abstract:

    These are the structures and defines that are used in the
    SCSI tape class drivers. The tape class driver is separated
    into two modules. Tape.c contains code common to all tape
    class drivers including the driver's major entry points.
    The major entry point names each begin with the prefix
    'ScsiTape.' The second module is the device specific code.
    It provides support for a set of functions. Each device
    specific function name is prefixed by 'Tape.'

Author:

    Mike Glass

Revision History:

--*/

#include "scsi.h"
#include "class.h"

//
// Define the maximum inquiry data length.
//

#define MAXIMUM_TAPE_INQUIRY_DATA 252

//
// Tape device data
//

typedef struct _TAPE_DATA {
     ULONG        Flags;
     ULONG        CurrentPartition;
     PVOID        DeviceSpecificExtension;
     PSCSI_INQUIRY_DATA InquiryData;
} TAPE_DATA, *PTAPE_DATA;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION) + sizeof(TAPE_DATA)


//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;


//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;


//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;



//
// The following routines are the exported entry points for
// all tape class drivers. Note all these routines name start
// with 'ScsiTape.'
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ScsiTapeInitialize(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiTapeCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
// The following routines are provided by the tape
// device-specific module. Each routine name is
// prefixed with 'Tape.'

NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    );

NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\wmi.h ===
/*-- BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the WMI subsystem.

Author:

    Jee Fung Pang (JeePang) 01-Jan-2000

Revision History:

--*/

#ifndef _WMI_
#define _WMI_


#ifndef _WMIKM_
#define _WMIKM_
#endif

#ifndef RUN_WPP
#define RUN_WPP
#endif
// begin_ntddk begin_wdm begin_ntifs 
#ifdef RUN_WPP
#include <evntrace.h>
#include <stdarg.h>
#endif // #ifdef RUN_WPP
// end_ntddk end_wdm end_ntifs
#include <wmistr.h>
#include <ntwmi.h>

typedef
__int64
(*WMI_GET_CPUCLOCK_ROUTINE) (
    VOID
    );

extern WMI_GET_CPUCLOCK_ROUTINE WmiGetCpuClock;

extern ULONG WmiUsePerfClock;

typedef
VOID
(*WMI_TRACE_BUFFER_CALLBACK) (
    IN PWMI_BUFFER_HEADER Buffer,
    IN PVOID Context
    );

// begin_wmikm
typedef enum tagWMI_CLOCK_TYPE {
    WMICT_DEFAULT,
    WMICT_SYSTEMTIME,
    WMICT_PERFCOUNTER,
    WMICT_PROCESS,
    WMICT_THREAD,
    WMICT_CPUCYCLE
} WMI_CLOCK_TYPE;

//
// Trace Control APIs
//
NTKERNELAPI
NTSTATUS
WmiStartTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiQueryTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiStopTrace(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiUpdateTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiFlushTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );
//
// Trace Provider APIs
//
NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceEvent(
    IN PWNODE_HEADER Wnode,
    IN KPROCESSOR_MODE RequestorMode
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceFastEvent(
    IN PWNODE_HEADER Wnode
    );

NTKERNELAPI
LONG64
FASTCALL
WmiGetClock(
    IN WMI_CLOCK_TYPE ClockType,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiGetClockType(
    IN TRACEHANDLE LoggerHandle,
    OUT WMI_CLOCK_TYPE *ClockType
    );

// begin_ntddk begin_wdm begin_ntifs

#ifdef RUN_WPP

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN ...
    );

NTKERNELAPI
NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
    );


#endif // #ifdef RUN_WPP

#ifndef TRACE_INFORMATION_CLASS_DEFINE
typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass
} TRACE_INFORMATION_CLASS;

NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );
#define TRACE_INFORMATION_CLASS_DEFINE
#endif // TRACE_INFOPRMATION_CLASS_DEFINE

// end_ntddk end_wdm end_wmikm end_ntifs

NTKERNELAPI
NTSTATUS
WmiSetTraceBufferCallback(
    IN TRACEHANDLE  TraceHandle,
    IN WMI_TRACE_BUFFER_CALLBACK Callback,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
WmiTraceKernelEvent(
    IN ULONG GroupType,
    IN PVOID EventInfo,
    IN ULONG EventInfoLen,
    IN PETHREAD Thread
    );


NTKERNELAPI
PPERFINFO_TRACE_HEADER
FASTCALL
WmiReserveWithPerfHeader(
    IN ULONG AuxSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    );

NTKERNELAPI
ULONG
FASTCALL
WmiReleaseKernelBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    );

NTKERNELAPI
VOID
FASTCALL
WmiTraceProcess(
    IN PEPROCESS Process,
    IN BOOLEAN Create
    );

NTKERNELAPI
VOID
WmiTraceThread(
    IN PETHREAD Thread,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN Create
    );

NTKERNELAPI
NTSTATUS
WmiSetMark(
    IN PWMI_SET_MARK_INFORMATION MarkInfo,
    IN ULONG InBufferLen
    );

NTKERNELAPI
VOID
WmiBootPhase1(
    VOID
    );

//
// Context swap routines
//

VOID
FASTCALL
WmiTraceContextSwap (
    IN PETHREAD pOldEThread,
    IN PETHREAD pNewEThread
    );

VOID
FASTCALL
WmiStartContextSwapTrace
    (
    );

VOID 
FASTCALL
WmiStopContextSwapTrace
    (
    );

#endif // _WMI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\vdmntos.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmntos.h

Abstract:

    This is the include file for the vdm component.  It describes the kernel
    mode visible portions of the vdm component.  The \nt\private\inc\vdm.h
    file describes the portions that are usermode visible.

Author:

    Dave Hastings (daveh) 02-Feb-1992

Revision History:

--*/

#ifndef _VDMNTOS_
#define _VDMNTOS_

//
// Need this #include here because non-x86 ntos\vdm\vdm.c
// references structures defined there.
//

#include "vdm.h"

#if defined(i386)

typedef struct _VDM_IO_LISTHEAD {
    PVDM_IO_HANDLER VdmIoHandlerList;
    ERESOURCE       VdmIoResource;
    ULONG           Context;
} VDM_IO_LISTHEAD, *PVDM_IO_LISTHEAD;


typedef struct _VDM_PROCESS_OBJECTS {
    PVDM_IO_LISTHEAD VdmIoListHead;
    KAPC             QueuedIntApc;
    KAPC             QueuedIntUserApc;
    FAST_MUTEX       DelayIntFastMutex;
    KSPIN_LOCK       DelayIntSpinLock;
    LIST_ENTRY       DelayIntListHead;
    PVDMICAUSERDATA  pIcaUserData;
    PETHREAD         MainThread;
    PVDM_TIB         VdmTib;
    PUCHAR           PrinterState;
    PUCHAR           PrinterControl;
    PUCHAR           PrinterStatus;
    PUCHAR           PrinterHostState;
    USHORT           AdlibStatus;
    USHORT           AdlibIndexRegister;
    USHORT           AdlibPhysPortStart;
    USHORT           AdlibPhysPortEnd;
    USHORT           AdlibVirtPortStart;
    USHORT           AdlibVirtPortEnd;
    USHORT           AdlibAction;
    USHORT           VdmControl;                // See below
    ULONG            PMCliTimeStamp;
} VDM_PROCESS_OBJECTS, *PVDM_PROCESS_OBJECTS;

//
// VdmControl definition
//

#define PM_CLI_CONTROL  1

typedef struct _DelayInterruptsIrq {
    LIST_ENTRY  DelayIntListEntry;
    ULONG       IrqLine;
    PETHREAD    Thread;
    KDPC        Dpc;
    KAPC        Apc;
    KTIMER      Timer;
    BOOLEAN     InUse;
    PETHREAD    MainThread;
} DELAYINTIRQ, *PDELAYINTIRQ;

#define VDMDELAY_NOTINUSE 0
#define VDMDELAY_KTIMER   1
#define VDMDELAY_PTIMER   2
#define VDMDELAY_KAPC     3


VOID
VdmCheckPMCliTimeStamp (
    VOID
    );

VOID
VdmSetPMCliTimeStamp (
    BOOLEAN Reset
    );

VOID
VdmClearPMCliTimeStamp (
    VOID
    );

BOOLEAN
Ps386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber,
    OUT PVDM_IO_HANDLER VdmIoHandler,
    OUT PULONG Context
    );

#define SEL_TYPE_READ       0x00000001
#define SEL_TYPE_WRITE      0x00000002
#define SEL_TYPE_EXECUTE    0x00000004
#define SEL_TYPE_BIG        0x00000008
#define SEL_TYPE_ED         0x00000010
#define SEL_TYPE_2GIG       0x00000020
#define SEL_TYPE_NP         0x00000040

// NPX error exception dispatcher
BOOLEAN
VdmDispatchIRQ13(
    PKTRAP_FRAME TrapFrame
    );

BOOLEAN
VdmSkipNpxInstruction(
    PKTRAP_FRAME TrapFrame,
    ULONG        Address32Bits,
    PUCHAR       istream,
    ULONG        InstructionSize
    );

VOID
VdmEndExecution(
    PKTRAP_FRAME TrapFrame,
    PVDM_TIB VdmTib
    );

NTSTATUS
VdmDispatchInterrupts(
    PKTRAP_FRAME TrapFrame,
    PVDM_TIB     VdmTib
    );

VOID
VdmDispatchException(
     PKTRAP_FRAME TrapFrame,
     NTSTATUS     ExcepCode,
     PVOID        ExcepAddress,
     ULONG        NumParms,
     ULONG        Parm1,
     ULONG        Parm2,
     ULONG        Parm3
     );

ULONG
VdmFetchBop1 (
    IN PVOID Pc
    );

ULONG
VdmFetchBop4 (
    IN PVOID Pc
    );

ULONG
VdmFetchULONG (
    IN PVOID Pc
    );

LOGICAL
VdmDispatchBop (
    IN PKTRAP_FRAME TrapFrame
    );

PVOID
VdmTibPass1 (
    IN ULONG Cs,
    IN ULONG Eip,
    IN ULONG Ebx
    );

VOID
VdmRundownDpcs (
    IN PEPROCESS Process
    );

ULONG
VdmDispatchOpcodeV86_try (
    IN PKTRAP_FRAME TrapFrame
    );

ULONG
VdmDispatchOpcode_try (
    IN PKTRAP_FRAME TrapFrame
    );

#define VdmGetTrapFrame(pKThread) \
        ((PKTRAP_FRAME)( (PUCHAR)(pKThread)->InitialStack -              \
                         sizeof(FX_SAVE_AREA) -                          \
                         ((ULONG)(sizeof(KTRAP_FRAME)+KTRAP_FRAME_ROUND) \
                           & ~(KTRAP_FRAME_ROUND))                       \
                        )                                                \
         )

//
// These values are defined here to describe the structure of an array
// containing running counts of v86 opcode emulation. The array lives in
// ke\i386, but is referenced in ex.
//
#define VDM_INDEX_Invalid             0
#define VDM_INDEX_0F                  1
#define VDM_INDEX_ESPrefix            2
#define VDM_INDEX_CSPrefix            3
#define VDM_INDEX_SSPrefix            4
#define VDM_INDEX_DSPrefix            5
#define VDM_INDEX_FSPrefix            6
#define VDM_INDEX_GSPrefix            7
#define VDM_INDEX_OPER32Prefix        8
#define VDM_INDEX_ADDR32Prefix        9
#define VDM_INDEX_INSB               10
#define VDM_INDEX_INSW               11
#define VDM_INDEX_OUTSB              12
#define VDM_INDEX_OUTSW              13
#define VDM_INDEX_PUSHF              14
#define VDM_INDEX_POPF               15
#define VDM_INDEX_INTnn              16
#define VDM_INDEX_INTO               17
#define VDM_INDEX_IRET               18
#define VDM_INDEX_NPX                19
#define VDM_INDEX_INBimm             20
#define VDM_INDEX_INWimm             21
#define VDM_INDEX_OUTBimm            22
#define VDM_INDEX_OUTWimm            23
#define VDM_INDEX_INB                24
#define VDM_INDEX_INW                25
#define VDM_INDEX_OUTB               26
#define VDM_INDEX_OUTW               27
#define VDM_INDEX_LOCKPrefix         28
#define VDM_INDEX_REPNEPrefix        29
#define VDM_INDEX_REPPrefix          30
#define VDM_INDEX_CLI                31
#define VDM_INDEX_STI                32
#define VDM_INDEX_HLT                33

// The following value must be 1 more than the last defined index value
#define MAX_VDM_INDEX                34

//
// This is the address of the Vdm communication area.
//

#define FIXED_NTVDMSTATE_LINEAR_PC_AT ((PLONG)0x714)

extern ULONG VdmpMaxPMCliTime;

#endif // i386
#endif // _VDMNTOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\verifier.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   verifeir.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    Driver Verifier.


Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/


#ifndef _VERIFIER_
#define _VERIFIER_

//
// Zw verifier macros, thunks and types.
//

#include "..\verifier\vfzwapi.h"

//
// Resource types handled by deadlock detection package.
//

typedef enum _VI_DEADLOCK_RESOURCE_TYPE {
    VfDeadlockUnknown = 0,
    VfDeadlockMutex,
    VfDeadlockMutexAbandoned,
    VfDeadlockFastMutex,
    VfDeadlockFastMutexUnsafe,
    VfDeadlockSpinLock,
    VfDeadlockQueuedSpinLock,
    VfDeadlockTypeMaximum
} VI_DEADLOCK_RESOURCE_TYPE, *PVI_DEADLOCK_RESOURCE_TYPE;

//
// HAL Verifier functions
//


struct _DMA_ADAPTER *
VfGetDmaAdapter(
    IN PDEVICE_OBJECT  PhysicalDeviceObject,
    IN struct _DEVICE_DESCRIPTION  *DeviceDescription,
    IN OUT PULONG  NumberOfMapRegisters
    );

PVOID
VfAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN PULONG NumberOfMapRegisters
    );


#if !defined(NO_LEGACY_DRIVERS)
VOID
VfPutDmaAdapter(
    struct _DMA_ADAPTER * DmaAdapter
    );


PVOID
VfAllocateCommonBuffer(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

VOID
VfFreeCommonBuffer(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

NTSTATUS
VfAllocateAdapterChannel(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG  NumberOfMapRegisters,
    IN PDRIVER_CONTROL  ExecutionRoutine,
    IN PVOID  Context
    );

PHYSICAL_ADDRESS
VfMapTransfer(
    IN struct _DMA_ADAPTER *  DmaAdapter,
    IN PMDL  Mdl,
    IN PVOID  MapRegisterBase,
    IN PVOID  CurrentVa,
    IN OUT PULONG  Length,
    IN BOOLEAN  WriteToDevice
    );

BOOLEAN
VfFlushAdapterBuffers(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

VOID
VfFreeAdapterChannel(
    IN struct _DMA_ADAPTER * DmaAdapter
    );

VOID
VfFreeMapRegisters(
    IN struct _DMA_ADAPTER * DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

ULONG
VfGetDmaAlignment(
    IN struct _DMA_ADAPTER * DmaAdapter
    );

ULONG
VfReadDmaCounter(
    IN struct _DMA_ADAPTER *  DmaAdapter
    );

NTSTATUS
VfGetScatterGatherList (
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PVOID ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

VOID
VfPutScatterGatherList(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN struct _SCATTER_GATHER_LIST * ScatterGather,
    IN BOOLEAN WriteToDevice
    );

PADAPTER_OBJECT
VfLegacyGetAdapter(
    IN struct _DEVICE_DESCRIPTION  *DeviceDescription,
    IN OUT PULONG  NumberOfMapRegisters
    );

#endif

LARGE_INTEGER
VfQueryPerformanceCounter(
    IN PLARGE_INTEGER PerformanceFrequency OPTIONAL
    );

VOID
VfHalDeleteDevice(
    IN PDEVICE_OBJECT  DeviceObject
    );

VOID
VfDisableHalVerifier (
    VOID
    );


//
// Resource interfaces for deadlock detection package.
//

VOID
VfDeadlockDetectionInitialize(
    IN LOGICAL VerifyAllDrivers,
    IN LOGICAL VerifyKernel
    );

VOID
VfDeadlockDetectionCleanup (
    VOID
    );

BOOLEAN
VfDeadlockInitializeResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN BOOLEAN DoNotAcquireLock
    );

VOID
VfDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PKTHREAD Thread,
    IN BOOLEAN TryAcquire,
    IN PVOID Caller
    );

VOID
VfDeadlockReleaseResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PKTHREAD Thread,
    IN PVOID Caller
    );

//
// Used for resource garbage collection.
//

VOID
VfDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    );

//
// Notification from the pool manager so deadlock hierarchies can be terminated.
//

VOID
VerifierDeadlockFreePool(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

//
// Verifier versions to catch file I/O above PASSIVE_LEVEL
//

NTSTATUS
VerifierNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSTATUS
VerifierNtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSTATUS
VerifierNtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

typedef enum {

    //
    // Bugs in this class are severe enough that the hardware should be removed
    // from a running production machine.
    //
    VFFAILURE_FAIL_IN_FIELD = 0,

    //
    // Bugs of this class are severe enough for WHQL to deny a logo for the
    // failing whateverware.
    //
    VFFAILURE_FAIL_LOGO = 1,

    //
    // Bugs of this class stop the machine only if it is running under a kernel
    // debugger.
    //
    VFFAILURE_FAIL_UNDER_DEBUGGER = 2

} VF_FAILURE_CLASS, *PVF_FAILURE_CLASS;



//
// Example usage: (note - perMinorFlags statically preinitialized to zero)
//
// VfFailDeviceNode(
//     PhysicalDeviceObject
//     major,
//     minor,
//     VFFAILURE_FAIL_LOGO,
//     &perMinorFlags,
//     "Device %DevObj mishandled register %Ulong",
//     "%Ulong%DevObj",
//     value,
//     deviceObject
//     );
//
VOID
VfFailDeviceNode(
    IN      PDEVICE_OBJECT      PhysicalDeviceObject,
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    );

//
// Example usage: (note - perMinorFlags statically preinitialized to zero)
//
// VfFailDriver(
//     major,
//     minor,
//     VFFAILURE_FAIL_LOGO,
//     &perMinorFlags,
//     "Driver at %Routine returned %Ulong",
//     "%Ulong%Routine",
//     value,
//     routine
//     );
//
VOID
VfFailDriver(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    );

//
// Example usage: (note - perMinorFlags statically preinitialized to zero)
//
// VfFailSystemBIOS(
//     major,
//     minor,
//     VFFAILURE_FAIL_LOGO,
//     &perMinorFlags,
//     "Driver at %Routine returned %Ulong",
//     "%Ulong%Routine",
//     value,
//     routine
//     );
//
VOID
VfFailSystemBIOS(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    );

typedef enum {

    //
    // Driver object
    //
    VFOBJTYPE_DRIVER = 0,

    //
    // Physical Device Object pointing to hardware
    //
    VFOBJTYPE_DEVICE,

    //
    // System BIOS (no object)
    //
    VFOBJTYPE_SYSTEM_BIOS

} VF_OBJECT_TYPE;

BOOLEAN
VfIsVerificationEnabled(
    IN  VF_OBJECT_TYPE  VfObjectType,
    IN  PVOID           Object          OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\xip.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    xip.h

Abstract:

    Definitions shared between the kernel and XIP driver.

    The XIP driver gets parameters through an exported function
    rather than sharing data.

Author:

    DavePr  2000/10/10
Revision History:

--*/

#ifndef _XIP_
#define _XIP_

#define XIP_POOLTAG ' PIX'

typedef struct _XIP_BOOT_PARAMETERS {
    BOOLEAN    SystemDrive;
    BOOLEAN    ReadOnly;
    PFN_NUMBER BasePage;
    PFN_NUMBER PageCount;
} XIP_BOOT_PARAMETERS, *PXIP_BOOT_PARAMETERS;

typedef enum {
    XIPCMD_NOOP,
    XIPCMD_GETBOOTPARAMETERS,
    XIPCMD_GETBIOSPARAMETERS
} XIPCMD;

#if defined(_AMD64_) || defined(_X86_)

#if !defined(DRIVER)

extern BOOLEAN XIPConfigured;

NTSTATUS
XIPLocatePages(
    IN  PFILE_OBJECT       FileObject,
    OUT PPHYSICAL_ADDRESS  PhysicalAddress
    );

VOID XIPInit(PLOADER_PARAMETER_BLOCK);

#endif //!DRIVER

NTSTATUS
XIPDispatch(
    IN     XIPCMD Command,
    IN OUT PVOID  ParameterBuffer OPTIONAL,
    IN     ULONG  BufferSize
    );

#else

#if !defined(DRIVER)

#define XIPConfigured FALSE
#define XIPLocatePages(fo, ppa) STATUS_NOT_IMPLEMENTED
#define XIPInit(plpb)

#endif

#endif

#endif // _XIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\xpress.h ===
#ifndef _XPRESS_H_
#define _XPRESS_H_

#ifdef _MSC_VER
#pragma once
#endif


/* -------------------------------------------------------------------- */
/*                                                                      */
/*               Copyright (c) 1991-1999 by Andrew Kadatch              */
/*                                                                      */
/* -------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* ---------------------- Common declarations ------------------------- */
/*                        -------------------                           */

// max. size of input block
#define XPRESS_MAX_BLOCK_LOG	16
#define XPRESS_MAX_BLOCK	(1 << XPRESS_MAX_BLOCK_LOG)


// preferred data alignment to avoid misaligned accesses
#define XPRESS_ALIGNMENT	8

// declare default calling convention used in xpress
#if !defined (UNIX) && !defined (XPRESS_CALL)
#define XPRESS_CALL __stdcall
#endif


// user-supplied callback function that allocates memory
// if there is no memory available it shall return NULL
typedef
void *
XPRESS_CALL
  XpressAllocFn
  (
    void *context,	// user-defined context (as passed to XpressEncodeCreate)
    int size		// size of memory block to allocate
  );

// user-supplied callback function that releases memory
typedef
void
XPRESS_CALL
  XpressFreeFn
  (
    void *context,	// user-defined context (as passed to XpressEncodeClose)
    void *address	// pointer to the block to be freed
  );


/* ----------------------------- Encoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressEncodeDummy;} *XpressEncodeStream;

// allocate and initialize encoder's data structures
// returns NULL if callback returned NULL (not enough memory)
XpressEncodeStream
XPRESS_CALL
  XpressEncodeCreate
  (
    int MaxOrigSize,			// max size of original data block
    void *context,			// user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn,		// memory allocation callback
    int CompressionLevel		// use 0 for speed, 9 for quality
  );


// callback function called by XpressEncode to indicate compression progress
typedef
void
XPRESS_CALL
  XpressProgressFn
  (
    void *context,			// user-defined context
    int compressed			// size of processed original data
  );
    

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
int
XPRESS_CALL
  XpressEncode
  (
    XpressEncodeStream stream,		// encoder's workspace
    void *CompAdr, int CompSize,	// compressed data region
    const void *OrigAdr, int OrigSize,	// input data block
    XpressProgressFn *ProgressFn,	// NULL or progress callback
    void *ProgressContext,		// user-defined context that will be passed to ProgressFn
    int ProgressSize			// call ProgressFn each time ProgressSize bytes processed
  );

// invalidate input stream and release workspace memory
void
XPRESS_CALL
  XpressEncodeClose
  (
    XpressEncodeStream stream,		// encoder's workspace
    void *context, XpressFreeFn *FreeFn	// memory releasing callback
  );


/* ----------------------------- Decoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressDecodeDummy;} *XpressDecodeStream;

// allocate memory for decoder. Returns NULL if not enough memory.
XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,			// user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn		// memory allocation callback
  );

// decode compressed block. Returns # of decoded bytes or -1 otherwise
int
XPRESS_CALL
XpressDecode
  (
    XpressDecodeStream stream,		// decoder's workspace
    void *OrigAdr, int OrigSize,	// original data region
    int DecodeSize,			// # of bytes to decode ( <= OrigSize)
    const void *CompAdr, int CompSize	// compressed data block
  );

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,		// encoder's workspace
    void *context,			// user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn			// callback that releases the memory
  );


/* ------------------------------ CRC32 ------------------------------- */
/*                                -----                                 */

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,		// beginning of data block
    int bytes,			// number of bytes
    int crc			// initial value
  );


#ifdef __cplusplus
};
#endif

#endif /* _XPRESS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\hello.c ===
#include <nt.h>

main()
{
    DbgPrint("Hisssssssssssssssss, Viper Lives\n");
    DbgBreakPoint();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\anim.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    anim.c

Abstract:

    Animated logo module.

Notes:

    There are two types of logo displayed when the system starts up.
    
    1. The old one contains both progress bar and a rotation bar displayed over the logo bitmap.
    The rotation bar is a blue-white line moving across the screen from left to right.

    2. The new one (starting with Whistler) contains only a rotation bar and no progress bar.
    The rotation bar in this case is a set of 5 dots (file dots.bmp) moving at the bottom
    of the logo from left to right.

    The rotation bars in both cases are updated on timer. The client of this module will use
    global variables to chose an appropriate animation for workstation, server, full-scale bitmap.
    header bitmap, etc. Here are the variables:

    * RotBarSelection - specifies the rotation bar to display
    * LogoSelection   - specifies the logo to display: is it full screen or header logo

    Two routines are used by other modules to display the animation. Both routines should be
    called only after the glabal flags are set.

    * InbvRotBarInit - initializes a rotation bar to be drawn; this routine must be called
                       immediately after the logo bitmap is shown on the screen.

    * InbvRotateGuiBootDisplay - is a DPC routine for rotation bar update.


    PIX_IN_DOTS ROTATION BAR

    First, a logo bitmap shows up on the screen. There is a line of small "empty" circles under
    the logo. The dots bitmap is moving from left to right along this line:

    o o o O Q @ Q O o o o o o o o o o
          -------->

    To avoid appearance of dots trail left of the moving dots bitmap, an "empty" circle is copied
    over the trail every time the dots bitmap moves right:

    Before step #N:

    o o o O Q @ Q O o o o o o o o o o


    After step #N:

    here the
    "empty" circle
    is placed      ______ here is the
         ___      |       dots bitmap
            |  ___v___
            v |       |
    o o o o o O Q @ Q O o o o o o o o

  
    When the dots show up on the beginning/end of rotation bar, only a part of it is displayed, e.g.:

    Q @ Q O o o o o o o o o o o o o o

    or

    o o o o o o o o o o o o o o O Q @

    To do this, the rotation bar area on the logo bitmap is put once to the off-screen memory and
    any necessary parts of it are then being copied to the display:

     ____________
    |            |
    |  O Q @ Q O o o o o o o o o o o o o
    |  \_____/
    |      |________________________
    |__________________________     |
                               |  __V__
                               V /     \
       o o o o o o o o o o o o o O Q @ Q

    The preparation work is performed in the call to RotBarDotsBmpInit (called via InbvRotBarInit).
    The bitmap drawing operations are performed in RotBarDotsBmpUpdate (called from InbvRotateGuiBootDisplay).


    BLUE LINE ROTATION BAR

    Blue line data is captured from the logo bitmap, placed in a buffer, and then is displayed on each DPC call
    over the logo bitmap. Every time RotBarBlueLineUpdate is called, the point of split is recalculated. The part
    of the line which falls before the split is displayed at the end of line on the display; the part which falls
    after the split is displayed on the beginning:

    In the buffer (copy of original bitmap):

    ooooooooooo*********************oooooooooooooo
                  |
      split ______|

                                     ____ point of concatenation
    Displayed image:                |
                                    V
    ******************ooooooooooooooooooooooooo***

  
Author:

    Peter Alschitz (petera) 08-Aug-2000  (Blue Line code moved from init.c by Steve Wood)

Revision History:

--*/

#include "ntos.h"
#include "stdlib.h"
#include "stdio.h"
#include <string.h>
#include <inbv.h>
#include "anim.h"
#include <bootvid.h>
#include "vga.h"

// bitmap-specific data for rotation bar
ROT_BAR_TYPE RotBarSelection     = RB_UNSPECIFIED;
// LOGO_TYPE    LogoSelection       = LOGO_UNSPECIFIED;

int AnimBarPos = 0;
LONG PaletteNum;
BOOLEAN FadingIn = TRUE;

typedef enum {
    PLT_UNDEFINED,
    PLT_START,
    PLT_CYCLE,
    PLT_COMPLETE
} PLT_RBAR_STATE;

PLT_RBAR_STATE PltRotBarStatus = PLT_UNDEFINED;

#define FADE_GRADES   (20)
#define FULL_PALETTE_SIZE (16)
#define FULL_PALETTE_SIZE_BYTES (FULL_PALETTE_SIZE*sizeof(RGBQUAD))

UCHAR PaletteBmp [128]; // small bitmap
PRGBQUAD PalettePtr = (PRGBQUAD)(PaletteBmp + sizeof(BITMAPINFOHEADER));
PBITMAPINFOHEADER pbih = (PBITMAPINFOHEADER)PaletteBmp;

RGBQUAD MainPalette [FULL_PALETTE_SIZE] = { {0,0,0,0}, {21,26,32,0}, {70,70,70,0}, {210,62,45,0},
											{1,101,83,0}, {5,53,178,0}, {126,126,126,0}, {0,146,137,0},
											{252,127,94,0}, {32,107,247,0}, {255,166,141,0}, {4,220,142,0},
											{27,188,243,0}, {188,188,188,0}, {252,252,252,0}, {255,255,255,0} };

#define COLOR_BLACK      0
#define COLOR_BLUE       2
#define COLOR_DARKGRAY   4
#define COLOR_GRAY       9
#define COLOR_WHITE      15
#define COLOR_FADE_TEXT  1

UCHAR Square1[36];
UCHAR Square2[36];
UCHAR Square3[36];

VOID
RotBarInit (VOID)
/*++

Routine Description:

    This routine is called to initialize 4-color rotation bar
    and fade-in/fade-out effect.

Return Value:

    None.

Environment:

    This routine is called during initialization when BOOTVID.DLL is loaded
    and Logo bitmap is being displayed on the screen.

--*/
{
    pbih->biSize = sizeof (BITMAPINFOHEADER);
    pbih->biWidth = 1;
    pbih->biHeight = 1;
    pbih->biPlanes = 1;
    pbih->biBitCount = 4;
    pbih->biCompression = 0; // BI_RGB
    pbih->biSizeImage = 4;
    pbih->biXPelsPerMeter = 2834;
    pbih->biYPelsPerMeter = 2834;
    pbih->biClrUsed = 0;
    pbih->biClrImportant = 0;

    PltRotBarStatus = PLT_START;
    PaletteNum = 0;
	AnimBarPos = 0;

	VidScreenToBufferBlt(Square1,0,0,6,9,4);
	VidScreenToBufferBlt(Square2,2+6,0,6,9,4);
	VidScreenToBufferBlt(Square3,2*(2+6),0,6,9,4);
	VidSolidColorFill(0,0,22,9,COLOR_BLACK);
}

VOID
FadePalette (UCHAR factor)
{
    int i;
    for (i=0; i<FULL_PALETTE_SIZE; i++) {
        PalettePtr[i].rgbBlue = (UCHAR)(factor * MainPalette[i].rgbBlue / FADE_GRADES);
        PalettePtr[i].rgbGreen = (UCHAR)(factor * MainPalette[i].rgbGreen / FADE_GRADES);
        PalettePtr[i].rgbRed = (UCHAR)(factor * MainPalette[i].rgbRed / FADE_GRADES);
        PalettePtr[i].rgbReserved = 0;
    }
}

VOID
FadePaletteColor (UCHAR factor, UCHAR color)
{
    PalettePtr[color].rgbBlue =	(UCHAR)(factor * MainPalette[color].rgbBlue / FADE_GRADES);
    PalettePtr[color].rgbGreen = (UCHAR)(factor * MainPalette[color].rgbGreen / FADE_GRADES);
    PalettePtr[color].rgbRed = (UCHAR)(factor * MainPalette[color].rgbRed / FADE_GRADES);
    PalettePtr[color].rgbReserved = 0;
}

#define COLOR_BLACK      0
#define COLOR_BLUE       2
#define COLOR_DARKGRAY   4
#define COLOR_GRAY       9
#define COLOR_WHITE      15

#define BLACK_4CLR_BAR memset (PalettePtr+12, 0, CYCLE_PALETTE_SIZE_BYTES)

#define BAR_X (267-(8*3))
#define BAR_Y (354)
#define CELL_X(num) (BAR_X+8*(AnimBarPos+num-2))
#define DRAW_CELL(num) VidBufferToScreenBlt(Square##num,CELL_X(num),BAR_Y,6,9,4)
#define BLK_CELL VidSolidColorFill(BAR_X+8*((AnimBarPos+16)%18),BAR_Y,BAR_X+8*((AnimBarPos+16)%18)+6-1,BAR_Y+9-1,COLOR_BLACK)

VOID
RotBarUpdate (VOID)
/*++

Routine Description:

    This routine is called periodically to update the 4-color rotation bar.
    From call to call it starts with fade-in effect, proceeds to palette-based
    rotation bar animation, and then goes to fade-out effect.
    
Return Value:

    None.

Environment:

    This routine is called from a DPC and cannot be paged.

--*/
{
    UCHAR color;

    switch (PltRotBarStatus) {

        
    case PLT_START:
        FadePalette ((UCHAR)(PaletteNum));
		FadePaletteColor (0, COLOR_FADE_TEXT); // #1 - color of fading text
		if ((++PaletteNum)>=FADE_GRADES) {
			PltRotBarStatus = PLT_CYCLE;
			FadingIn = TRUE;
			PaletteNum = 1;
		}
        break;
        
    case PLT_CYCLE:
		switch (AnimBarPos) {
		case 0:
				BLK_CELL;
				break;
		case 1:
				DRAW_CELL(3);
				break;
		case 2:
				DRAW_CELL(2);
				DRAW_CELL(3);
				break;
		case 16:
				DRAW_CELL(1);
				DRAW_CELL(2);
				BLK_CELL;
				break;
		case 17:
				DRAW_CELL(1);
				BLK_CELL;
				break;
		default:
				DRAW_CELL(1);
				DRAW_CELL(2);
				DRAW_CELL(3);
				if (AnimBarPos>3)
					BLK_CELL;
		}

		AnimBarPos++;
		if ((AnimBarPos) > 17)
			AnimBarPos = 0;

        break;

    case PLT_UNDEFINED:
    case PLT_COMPLETE:
        return;
    }

    if (InbvGetDisplayState() == INBV_DISPLAY_STATE_OWNED) {
        VidBitBlt(PaletteBmp, 0, 480);
    }
}


VOID
InbvRotBarInit ()
/*++

Routine Description:

    This routine is called to initialize rotation bar.
    The choice between rotation bar types is according to
    global variable RotBarSelection.

Return Value:

    None.

Environment:

    This routine is called during initialization when BOOTVID.DLL
    is loaded and Logo bitmap is being displayed on the screen.

--*/
{
    switch (RotBarSelection) {

    case RB_SQUARE_CELLS:
        RotBarInit();
        break;

    case RB_UNSPECIFIED:
    default:
        break;

    }
}

VOID
InbvRotateGuiBootDisplay(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called periodically to update the guiboot display.
    It makes its choice between calling different rotation bar update
    routines according to global variable RotBarSelection.

Return Value:

    None.

Environment:

    This routine is called from a DPC and cannot be paged.

--*/
{
    LARGE_INTEGER Delay;

    Delay.QuadPart = -10 * 1000 * 80;  // 100 milliseconds

    do {

        KeDelayExecutionThread(KernelMode, FALSE, &Delay);

        InbvAcquireLock();

        if (InbvGetDisplayState() == INBV_DISPLAY_STATE_OWNED) {

            switch(RotBarSelection) {

            case RB_SQUARE_CELLS:
                RotBarUpdate();
                break;

            case RB_UNSPECIFIED:
            default:
                break;
            }

        }

        InbvReleaseLock();

    } while (InbvCheckDisplayOwnership());

    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID
FinalizeBootLogo(VOID)
{
    InbvAcquireLock();
	if (InbvGetDisplayState() == INBV_DISPLAY_STATE_OWNED)
		VidSolidColorFill(0,0,639,479, COLOR_BLACK);
    PltRotBarStatus = PLT_COMPLETE;
    InbvReleaseLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\ntkrnlmp.c ===
#include "ntoskrnl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\ntkrnlpa.c ===
#include "ntoskrnl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\anim.h ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

   anim.h

Abstract:

   Animated logo module header file.

Author:

   Peter Alschitz (petera) 08-Aug-2000

--*/

#ifndef _ANIM_H
#define _ANIM_H

//
// selection of rotation bar - depends on logo bitmap contants
//

typedef enum {
    RB_UNSPECIFIED,
    RB_SQUARE_CELLS
} ROT_BAR_TYPE;

//
// Global variables:
//
// type of rotation bar to use
//

extern ROT_BAR_TYPE RotBarSelection;

VOID
InbvRotBarInit(
    VOID
    );

VOID
InbvRotateGuiBootDisplay(
    IN PVOID Context
    );

VOID
FinalizeBootLogo(VOID);

#endif // _ANIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\init.c ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Main source file of the NTOS system initialization subcomponent.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/


#include "ntos.h"
#include "ntimage.h"
#include <zwapi.h>
#include <ntdddisk.h>
#include <kddll.h>
#include <setupblk.h>
#include <fsrtl.h>
#include <ntverp.h>

#include "stdlib.h"
#include "stdio.h"
#include <string.h>

#include <safeboot.h>
#include <inbv.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include "anim.h"
#include "xip.h"

UNICODE_STRING NtSystemRoot;

VOID
ExpInitializeExecutive(
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTKERNELAPI
BOOLEAN
ExpRefreshTimeZoneInformation(
    IN PLARGE_INTEGER CurrentUniversalTime
    );

NTSTATUS
CreateSystemRootLink(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

static USHORT
NameToOrdinal (
    IN PSZ NameOfEntryPoint,
    IN ULONG_PTR DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    );

NTSTATUS
LookupEntryPoint (
    IN PVOID DllBase,
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    );

#if defined(_X86_)

VOID
KiInitializeInterruptTimers(
    VOID
    );

#endif

PFN_COUNT
ExBurnMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_COUNT NumberOfPagesToBurn,
    IN TYPE_OF_MEMORY MemoryTypeForRemovedPages,
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewMemoryDescriptor OPTIONAL
    );

VOID
DisplayFilter(
    PUCHAR *String
    );

NTSTATUS
RtlInitializeStackTraceDataBase(
    IN PVOID CommitBase,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize
    );

BOOLEAN
ExpIsLoaderValid(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef ALLOC_PRAGMA

//
// The INIT section is not pageable during initialization, so these
// functions can be in INIT rather than in .text.
//

#pragma alloc_text(INIT,ExBurnMemory)
#pragma alloc_text(INIT,ExpInitializeExecutive)
#pragma alloc_text(INIT,Phase1Initialization)
#pragma alloc_text(INIT,CreateSystemRootLink)
#pragma alloc_text(INIT,LookupEntryPoint)
#pragma alloc_text(INIT,NameToOrdinal)
#pragma alloc_text(INIT,ExpIsLoaderValid)
#endif

//
// Define global static data used during initialization.
//

ULONG NtGlobalFlag;
extern PMESSAGE_RESOURCE_BLOCK KiBugCheckMessages;

extern UCHAR CmProcessorMismatch;

const ULONG NtMajorVersion = VER_PRODUCTMAJORVERSION;
const ULONG NtMinorVersion = VER_PRODUCTMINORVERSION;

#if DBG
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xC0000000;
#else
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xF0000000;
#endif

#if defined(__BUILDMACHINE__)
#if defined(__BUILDDATE__)
#define B2(w,x,y) "" #w "." #x "." #y
#define B1(w,x,y) B2(w, x, y)
#define BUILD_MACHINE_TAG B1(VER_PRODUCTBUILD, __BUILDMACHINE__, __BUILDDATE__)
#else
#define B2(w,x) "" #w "." #x
#define B1(w,x) B2(w,x)
#define BUILD_MACHINE_TAG B1(VER_PRODUCTBUILD, __BUILDMACHINE__)
#endif
#else
#define BUILD_MACHINE_TAG ""
#endif

const CHAR NtBuildLab[] = BUILD_MACHINE_TAG;

ULONG InitializationPhase;

extern BOOLEAN ShowProgressBar;

extern KiServiceLimit;
extern PMESSAGE_RESOURCE_DATA  KiBugCodeMessages;
extern ULONG KdpTimeSlipPending;
extern BOOLEAN KdBreakAfterSymbolLoad;

extern CM_SYSTEM_CONTROL_VECTOR CmControlVector[];
ULONG CmNtCSDVersion;
ULONG CmBrand;
UNICODE_STRING CmVersionString;
UNICODE_STRING CmCSDVersionString;
ULONG InitSafeBootMode;

BOOLEAN InitIsWinPEMode = FALSE;
ULONG InitWinPEModeType = INIT_WINPEMODE_NONE;

WCHAR NtInitialUserProcessBuffer[128] = L"\\SystemRoot\\System32\\smss.exe";
ULONG NtInitialUserProcessBufferLength =
    sizeof(NtInitialUserProcessBuffer) - sizeof(WCHAR);
ULONG NtInitialUserProcessBufferType = REG_SZ;

#if defined(_X86_)

extern ULONG KeNumprocSpecified;

#endif

typedef struct _EXLOCK {
    KSPIN_LOCK SpinLock;
    KIRQL Irql;
} EXLOCK, *PEXLOCK;

#ifdef ALLOC_PRAGMA
NTSTATUS
ExpInitializeLockRoutine(
    PEXLOCK Lock
    );
#pragma alloc_text(INIT,ExpInitializeLockRoutine)
#endif

BOOLEAN
ExpOkayToLockRoutine(
    IN PEXLOCK Lock
    )
{
    return TRUE;
}

NTSTATUS
ExpInitializeLockRoutine(
    PEXLOCK Lock
    )
{
    KeInitializeSpinLock(&Lock->SpinLock);
    return STATUS_SUCCESS;
}

NTSTATUS
ExpAcquireLockRoutine(
    PEXLOCK Lock
    )
{
    ExAcquireSpinLock(&Lock->SpinLock,&Lock->Irql);
    return STATUS_SUCCESS;
}

NTSTATUS
ExpReleaseLockRoutine(
    PEXLOCK Lock
    )
{
    ExReleaseSpinLock(&Lock->SpinLock,Lock->Irql);
    return STATUS_SUCCESS;
}

#if 0
NTSTATUS
ExpDeleteLockRoutine(
    PEXLOCK Lock
    )
{
    return STATUS_SUCCESS;
}
#endif //0


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif
ULONG CmNtGlobalFlag = 0;
NLSTABLEINFO InitTableInfo;
ULONG InitNlsTableSize;
PVOID InitNlsTableBase;
PFN_COUNT BBTPagesToReserve;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
PVOID InitNlsSectionPointer = NULL;
ULONG InitAnsiCodePageDataOffset = 0;
ULONG InitOemCodePageDataOffset = 0;
ULONG InitUnicodeCaseTableDataOffset = 0;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

PVOID BBTBuffer;
MEMORY_ALLOCATION_DESCRIPTOR BBTMemoryDescriptor;

#define COLOR_BLACK      0
#define COLOR_BLUE       2
#define COLOR_DARKGRAY   4
#define COLOR_GRAY       9
#define COLOR_WHITE      15

extern BOOLEAN InbvBootDriverInstalled;

VOID
DisplayBootBitmap (
    IN BOOLEAN DisplayOnScreen
    )

/*++

Routine Description:

    Draws the gui boot screen.

Arguments:

    DisplayOnScreen - TRUE to dump text to the screen, FALSE otherwise.

Return Value:

    None.

Environment:

    This routine may be called more than once, and should not be marked INIT.

--*/

{
    LARGE_INTEGER DueTime;
    static BOOLEAN FirstCall = TRUE;
    ROT_BAR_TYPE TempRotBarSelection = RB_UNSPECIFIED;


    if (FirstCall == FALSE) {

        //
        // Disable current animation
        //

        InbvAcquireLock();
        RotBarSelection = RB_UNSPECIFIED;
        InbvReleaseLock();
    }

    ShowProgressBar = FALSE;

    if (DisplayOnScreen) {

        PUCHAR BitmapTop, BitmapBottom;

        if (SharedUserData->NtProductType == NtProductWinNt) {

            InbvSetTextColor(COLOR_WHITE);
            InbvSolidColorFill(0, 0,  639, 479, 7); // background
            InbvSolidColorFill(0, 421,  639, 479, 1); // bottom

            BitmapTop = InbvGetResourceAddress(6);
            BitmapBottom = InbvGetResourceAddress(7);
        } else { // srv

            InbvSetTextColor(14);
            InbvSolidColorFill(0, 0,  639, 479, 6); // background
            InbvSolidColorFill(0, 421,  639, 479, 1); // bottom

            BitmapTop = InbvGetResourceAddress(14);
            BitmapBottom = InbvGetResourceAddress(15);
        }

        TempRotBarSelection = RB_UNSPECIFIED;

        InbvSetScrollRegion(32, 80, 631, 400);

        if (BitmapTop && BitmapBottom) {
            InbvBitBlt(BitmapBottom, 0, 419);
            InbvBitBlt(BitmapTop, 0, 0);
        }

    } else {

        PUCHAR BarBitmap = NULL;
        PUCHAR TextBitmap = NULL;
        PUCHAR Bitmap = NULL;
        PUCHAR LogoBitmap = NULL;

        InbvInstallDisplayStringFilter(DisplayFilter);


        if (!InbvBootDriverInstalled) {
            return;
        }

        Bitmap = InbvGetResourceAddress(1);  // workstation bitmap

        if (ExVerifySuite(EmbeddedNT)) { // embd and pro have the same bar, but different text
            TextBitmap = InbvGetResourceAddress(12); // embedded edition title text
            BarBitmap = InbvGetResourceAddress(8); // pro and embedded editions progress bar
        }
        else if (SharedUserData->NtProductType == NtProductWinNt) { // home or pro
        
            if (ExVerifySuite(Personal)) { // home
                BarBitmap = InbvGetResourceAddress(9); // home edition progress bar
                TextBitmap = InbvGetResourceAddress(11); // home edition title text
            }
            else { // pro
                BarBitmap = InbvGetResourceAddress(8); // pro and embedded editions progress bar
                switch (CmBrand) {
                case 1: // TabletPc
                    TextBitmap = InbvGetResourceAddress(17);
                    break;
                case 2: // eHome Freestyle
                    TextBitmap = InbvGetResourceAddress(18);
                    break;
                default: // Professional title text
                    TextBitmap = InbvGetResourceAddress(10);
                }
            }
        }
        else { // srv
            BarBitmap = InbvGetResourceAddress(4); // srv edition progress bar
            LogoBitmap = InbvGetResourceAddress(13); // srv edition logo and title
        }
        
        if (Bitmap) {
            TempRotBarSelection = RB_SQUARE_CELLS;
        }

        //
        // Set positions for scrolling bar.
        //

        if (Bitmap) {
            InbvBitBlt(Bitmap, 0, 0);
            //if (SharedUserData->NtProductType == NtProductServer) {
            if (SharedUserData->NtProductType != NtProductWinNt) {
            
                extern BOOLEAN ExpInTextModeSetup; // defined at base\ntos\ex\exinit.c
                
                // Tweak the logo to make it neutral (e.g. remove "XP")
                {
                    UCHAR sav_copyright[64];
                    InbvScreenToBufferBlt(sav_copyright, 413, 237, 7, 7, 8);
                    InbvSolidColorFill(418,230,454,256,0);
                    InbvBufferToScreenBlt(sav_copyright, 413, 237, 7, 7, 8);
                }
                
                // HACK: in case of "text mode setup" (ExpInTextModeSetup == TRUE)
                // we can't determine the SKU so we displaying neutral bitmap 
                // without specific SKU title (e.g. just Windows) and server's progress bar 
                
                if (ExpInTextModeSetup) {
                    TextBitmap = NULL;
                }
                else {
                    // Overwrite the XP logo with .NET logo
                    if (LogoBitmap) {
                        InbvBitBlt(LogoBitmap, 180, 121);
                    }
                }
            }
        }
        if (TextBitmap) {
            InbvBitBlt(TextBitmap, 220, 272);
        }
        if (BarBitmap) {
            InbvBitBlt(BarBitmap, 0, 0);
        }
    }

    InbvAcquireLock();
    RotBarSelection = TempRotBarSelection;
    InbvRotBarInit();
    InbvReleaseLock();

    if (FirstCall) {

        //
        // If we got here, we are showing the boot bitmap.
        // Start a timer to support animation.
        //

        HANDLE ThreadHandle;

        PsCreateSystemThread(&ThreadHandle,
                             0L,
                             NULL,
                             NULL,
                             NULL,
                             InbvRotateGuiBootDisplay,
                             NULL);
    }

    FirstCall = FALSE;
}

VOID
DisplayFilter(
    IN OUT PUCHAR *String
    )

/*++

Routine Description:

    This routine monitors InbvDisplayString output.  If it sees something
    which needs to be displayed on the screen, it triggers the output screen.

Arguments:

    String - Pointer to a string pointer.

Returns:

    None.

Notes:

    This routine will be called anytime a string is displayed via the
    Inbv routines.  It cannot be paged!

--*/

{
    static const UCHAR EmptyString = 0;
    static BOOLEAN NonDotHit = FALSE;

    if ((NonDotHit == FALSE) && (strcmp(*String, ".") == 0)) {
        *String = (PUCHAR)&EmptyString;
    } else {
        NonDotHit = TRUE;
        InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
        DisplayBootBitmap(TRUE);
    }
}

PFN_COUNT
ExBurnMemory (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PFN_COUNT NumberOfPagesToBurn,
    IN TYPE_OF_MEMORY MemoryTypeForRemovedPages,
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewMemoryDescriptor OPTIONAL
    )

/*++

Routine Description:

    This routine removes memory from the system loader block thus simulating
    a machine with less physical memory without having to physically remove it.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block.

    NumberOfPagesToBurn - Supplies the number of pages to burn.

    MemoryTypeForRemovedPages - Supplies the type to mark into the loader block
                                for the burned pages.

    NewMemoryDescriptor - If non-NULL, this supplies a pointer to a memory
                          block to be used if a split is needed.

Return Value:

    Number of pages actually burned.

Environment:

    Kernel mode.

--*/

{
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PFN_COUNT PagesRemaining;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    PagesRemaining = NumberOfPagesToBurn;

    //
    // Look backwards through physical memory to leave it like
    // it otherwise would be.  ie: that's the way most people add memory
    // modules to their systems.
    //

    ListHead = &LoaderBlock->MemoryDescriptorListHead;
    NextEntry = ListHead->Blink;

    do {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if ((MemoryDescriptor->MemoryType == LoaderFree ||
            MemoryDescriptor->MemoryType == LoaderFirmwareTemporary) &&
            MemoryDescriptor->PageCount != 0) {

            if (MemoryDescriptor->PageCount > PagesRemaining) {

                //
                // This block has enough pages.
                // Split it into two and mark it as requested.
                //

                MemoryDescriptor->PageCount = MemoryDescriptor->PageCount -
                                                PagesRemaining;

                if (ARGUMENT_PRESENT (NewMemoryDescriptor)) {
                    NewMemoryDescriptor->BasePage = MemoryDescriptor->BasePage +
                                                    MemoryDescriptor->PageCount;

                    NewMemoryDescriptor->PageCount = PagesRemaining;

                    NewMemoryDescriptor->MemoryType = MemoryTypeForRemovedPages;

                    InsertTailList (MemoryDescriptor->ListEntry.Blink,
                                    &NewMemoryDescriptor->ListEntry);
                }

                PagesRemaining = 0;
                break;
            }

            PagesRemaining -= MemoryDescriptor->PageCount;
            MemoryDescriptor->MemoryType = MemoryTypeForRemovedPages;
        }

        NextEntry = NextEntry->Blink;

    } while (NextEntry != ListHead);

    return NumberOfPagesToBurn - PagesRemaining;
}

extern BOOLEAN ExpInTextModeSetup;

BOOLEAN
ExpIsLoaderValid(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    ULONG   majorVersion;
    ULONG   minorVersion;
    CHAR    versionBuffer[64];
    PCHAR   major;
    PCHAR   minor;
    ULONG   minSize;

    //
    // Make sure that we got loaded by a matching or newer loader.
    // First do a size check to make sure we can even read the version fields.
    //
    minSize = FIELD_OFFSET(LOADER_PARAMETER_EXTENSION, MinorVersion) + RTL_FIELD_SIZE(LOADER_PARAMETER_EXTENSION, MinorVersion);
    if (LoaderBlock->Extension->Size >= minSize) {

        //
        // Safe to do the version check.
        //
        major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
        minor = strchr(major, '.');
        majorVersion = atoi(major);
        if( minor != NULL ) {

            *minor++ = '\0';
            minorVersion = atoi(minor);
        } else {

            minorVersion = 0;
        }

        //
        // Check the version.
        //
        if (LoaderBlock->Extension->MajorVersion > majorVersion ||
            (LoaderBlock->Extension->MajorVersion == majorVersion &&
                LoaderBlock->Extension->MinorVersion >= minorVersion)) {

            return TRUE;
        }
    }

    return FALSE;
}


VOID
ExpInitializeExecutive(
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine is called from the kernel initialization routine during
    bootstrap to initialize the executive and all of its subcomponents.
    Each subcomponent is potentially called twice to perform Phase 0, and
    then Phase 1 initialization. During Phase 0 initialization, the only
    activity that may be performed is the initialization of subcomponent
    specific data. Phase 0 initialization is performed in the context of
    the kernel start up routine with interrupts disabled. During Phase 1
    initialization, the system is fully operational and subcomponents may
    do any initialization that is necessary.

Arguments:

    Number - Supplies the processor number currently initializing.

    LoaderBlock - Supplies a pointer to a loader parameter block.

Return Value:

    None.

--*/

{
    PFN_COUNT PagesToBurn;
    PCHAR Options;
    PCHAR MemoryOption;
    NTSTATUS Status;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PLIST_ENTRY NextEntry;
    ANSI_STRING AnsiString;
    STRING NameString;
    CHAR Buffer[ 256 ];
    BOOLEAN BufferSizeOk;
    ULONG ImageCount;
    ULONG i;
    ULONG_PTR ResourceIdPath[3];
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    PMESSAGE_RESOURCE_DATA  MessageData;
    CHAR VersionBuffer[ 64 ];
    PCHAR s;
    PLIST_ENTRY NextMd;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;

    if (!ExpIsLoaderValid(LoaderBlock)) {

        KeBugCheckEx(MISMATCHED_HAL, 
                     3, 
                     LoaderBlock->Extension->Size,
                     LoaderBlock->Extension->MajorVersion,
                     LoaderBlock->Extension->MinorVersion
                     );
    }

    //
    // Initialize PRCB pool lookaside pointers.
    //

    ExInitPoolLookasidePointers ();

    if (Number == 0) {

        //
        // Determine whether this is textmode setup and whether this is a
        // remote boot client.
        //

        ExpInTextModeSetup = FALSE;
        IoRemoteBootClient = FALSE;

        if (LoaderBlock->SetupLoaderBlock != NULL) {

            if ((LoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_TEXTMODE) != 0) {
                ExpInTextModeSetup = TRUE;
            }

            if ((LoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_REMOTE_BOOT) != 0) {
                IoRemoteBootClient = TRUE;
                ASSERT( _memicmp( LoaderBlock->ArcBootDeviceName, "net(0)", 6 ) == 0 );
            }
        }

#if defined(REMOTE_BOOT)
        SharedUserData->SystemFlags = 0;
        if (IoRemoteBootClient) {
            SharedUserData->SystemFlags |= SYSTEM_FLAG_REMOTE_BOOT_CLIENT;
        }
#endif // defined(REMOTE_BOOT)

        //
        // Indicate that we are in phase 0.
        //

        InitializationPhase = 0L;

        Options = LoaderBlock->LoadOptions;

        if (Options != NULL) {

            //
            // If in BBT mode, remove the requested amount of memory from the
            // loader block and use it for BBT purposes instead.
            //

            _strupr(Options);

            MemoryOption = strstr(Options, "PERFMEM");

            if (MemoryOption != NULL) {
                MemoryOption = strstr (MemoryOption,"=");
                if (MemoryOption != NULL) {
                    PagesToBurn = (PFN_COUNT) atol (MemoryOption + 1);

                    //
                    // Convert MB to pages.
                    //

                    PagesToBurn *= ((1024 * 1024) / PAGE_SIZE);

                    if (PagesToBurn != 0) {

                        PERFINFO_INIT_TRACEFLAGS(Options, MemoryOption);

                        BBTPagesToReserve = ExBurnMemory (LoaderBlock,
                                                          PagesToBurn,
                                                          LoaderBBTMemory,
                                                          &BBTMemoryDescriptor);
                    }
                }
            }

            //
            // Burn memory - consume the amount of memory
            // specified in the OS Load Options.  This is used
            // for testing reduced memory configurations.
            //

            MemoryOption = strstr(Options, "BURNMEMORY");

            if (MemoryOption != NULL) {
                MemoryOption = strstr(MemoryOption,"=");
                if (MemoryOption != NULL ) {

                    PagesToBurn = (PFN_COUNT) atol (MemoryOption + 1);

                    //
                    // Convert MB to pages.
                    //

                    PagesToBurn *= ((1024 * 1024) / PAGE_SIZE);

                    if (PagesToBurn != 0) {
                        ExBurnMemory (LoaderBlock,
                                      PagesToBurn,
                                      LoaderBad,
                                      NULL);
                    }
                }
            }
        }

        //
        // Initialize the translation tables using the loader
        // loaded tables.
        //

        InitNlsTableBase = LoaderBlock->NlsData->AnsiCodePageData;
        InitAnsiCodePageDataOffset = 0;
        InitOemCodePageDataOffset = (ULONG)((PUCHAR)LoaderBlock->NlsData->OemCodePageData - (PUCHAR)LoaderBlock->NlsData->AnsiCodePageData);
        InitUnicodeCaseTableDataOffset = (ULONG)((PUCHAR)LoaderBlock->NlsData->UnicodeCaseTableData - (PUCHAR)LoaderBlock->NlsData->AnsiCodePageData);

        RtlInitNlsTables(
            (PVOID)((PUCHAR)InitNlsTableBase+InitAnsiCodePageDataOffset),
            (PVOID)((PUCHAR)InitNlsTableBase+InitOemCodePageDataOffset),
            (PVOID)((PUCHAR)InitNlsTableBase+InitUnicodeCaseTableDataOffset),
            &InitTableInfo
            );

        RtlResetRtlTranslations(&InitTableInfo);

        //
        // Initialize the Hardware Architecture Layer (HAL).
        //

        if (HalInitSystem(InitializationPhase, LoaderBlock) == FALSE) {
            KeBugCheck(HAL_INITIALIZATION_FAILED);
        }

#if defined(_APIC_TPR_)

        HalpIRQLToTPR = LoaderBlock->Extension->HalpIRQLToTPR;
        HalpVectorToIRQL = LoaderBlock->Extension->HalpVectorToIRQL;

#endif

        //
        // Enable interrupts now that the HAL has initialized.
        //

#if defined(_X86_)

        _enable();

#endif

        //
        // Set the interrupt time forward so the Win32 tick count will wrap
        // within one hour to make rollover errors show up in fewer than 49.7
        // days.
        //

#if DBG

        KeAdjustInterruptTime((LONGLONG)(MAXULONG - (60 * 60 * 1000)) * 10 * 1000);

#endif

        //
        // Initialize the crypto exponent...  Set to 0 when systems leave ms!
        //

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building kernel with TESTKEY enabled!")
#else
#define TEST_BUILD_EXPONENT 0
#endif
        SharedUserData->CryptoExponent = TEST_BUILD_EXPONENT;

#if DBG
        NtGlobalFlag |= FLG_ENABLE_CLOSE_EXCEPTIONS |
                        FLG_ENABLE_KDEBUG_SYMBOL_LOAD;
#endif

        sprintf( Buffer, "C:%s", LoaderBlock->NtBootPathName );
        RtlInitString( &AnsiString, Buffer );
        Buffer[ --AnsiString.Length ] = '\0';
        NtSystemRoot.Buffer = SharedUserData->NtSystemRoot;
        NtSystemRoot.MaximumLength = sizeof( SharedUserData->NtSystemRoot );
        NtSystemRoot.Length = 0;
        Status = RtlAnsiStringToUnicodeString( &NtSystemRoot,
                                               &AnsiString,
                                               FALSE
                                             );
        if (!NT_SUCCESS( Status )) {
            KeBugCheck(SESSION3_INITIALIZATION_FAILED);
            }

        //
        // Find the address of BugCheck message block resource and put it
        // in KiBugCodeMessages.
        //
        // WARNING: This code assumes that the KLDR_DATA_TABLE_ENTRY for
        // ntoskrnl.exe is always the first in the loaded module list.
        //

        DataTableEntry = CONTAINING_RECORD(LoaderBlock->LoadOrderListHead.Flink,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);

        ResourceIdPath[0] = 11;
        ResourceIdPath[1] = 1;
        ResourceIdPath[2] = 0;

        Status = LdrFindResource_U (DataTableEntry->DllBase,
                                    ResourceIdPath,
                                    3,
                                    (VOID *) &ResourceDataEntry);

        if (NT_SUCCESS(Status)) {

            Status = LdrAccessResource (DataTableEntry->DllBase,
                                        ResourceDataEntry,
                                        &MessageData,
                                        NULL);

            if (NT_SUCCESS(Status)) {
                KiBugCodeMessages = MessageData;
            }
        }

#if !defined(NT_UP)

        //
        // Verify that the kernel and HAL images are suitable for MP systems.
        //
        // N.B. Loading of kernel and HAL symbols now occurs in kdinit.
        //

        ImageCount = 0;
        NextEntry = LoaderBlock->LoadOrderListHead.Flink;
        while ((NextEntry != &LoaderBlock->LoadOrderListHead) && (ImageCount < 2)) {
            DataTableEntry = CONTAINING_RECORD(NextEntry,
                                               KLDR_DATA_TABLE_ENTRY,
                                               InLoadOrderLinks);
            ImageCount += 1;
            if ( !MmVerifyImageIsOkForMpUse(DataTableEntry->DllBase) ) {
                KeBugCheckEx(UP_DRIVER_ON_MP_SYSTEM,
                            (ULONG_PTR)DataTableEntry->DllBase,
                            0,
                            0,
                            0);

            }

            NextEntry = NextEntry->Flink;

        }

#endif // !defined(NT_UP)

        //
        // Get system control values out of the registry.
        //

        CmGetSystemControlValues(LoaderBlock->RegistryBase, &CmControlVector[0]);
        CmNtGlobalFlag &= FLG_VALID_BITS;   // Toss bogus bits.

#ifdef VER_PRODUCTRCVERSION
        if ((CmNtCSDVersion & 0xFFFF0000) == 0) {
            CmNtCSDVersion |= VER_PRODUCTRCVERSION << 16;
        }
#endif

        NtGlobalFlag |= CmNtGlobalFlag;

#if !DBG
        if (!(CmNtGlobalFlag & FLG_ENABLE_KDEBUG_SYMBOL_LOAD)) {
            NtGlobalFlag &= ~FLG_ENABLE_KDEBUG_SYMBOL_LOAD;
        }
#endif

        //
        // Initialize the ExResource package.
        //

        if (!ExInitSystem()) {
            KeBugCheck(PHASE0_INITIALIZATION_FAILED);
        }

        //
        // Get multinode configuration (if any).
        //

        KeNumaInitialize();

        //
        // Initialize memory management and the memory allocation pools.
        //

        MmInitSystem (0, LoaderBlock);

        //
        // Scan the loaded module list and load the driver image symbols.
        //

        ImageCount = 0;
        NextEntry = LoaderBlock->LoadOrderListHead.Flink;
        while (NextEntry != &LoaderBlock->LoadOrderListHead) {

            BufferSizeOk = TRUE;

            if (ImageCount >= 2) {
                ULONG Count;
                WCHAR *Filename;
                ULONG Length;

                //
                // Get the address of the data table entry for the next component.
                //

                DataTableEntry = CONTAINING_RECORD(NextEntry,
                                                   KLDR_DATA_TABLE_ENTRY,
                                                   InLoadOrderLinks);

                //
                // Load the symbols via the kernel debugger
                // for the next component.
                //
                if (DataTableEntry->FullDllName.Buffer[0] == L'\\') {
                    //
                    // Correct fullname already available
                    //
                    Filename = DataTableEntry->FullDllName.Buffer;
                    Length = DataTableEntry->FullDllName.Length / sizeof(WCHAR);
                    if (sizeof(Buffer) < Length + sizeof(ANSI_NULL)) {
                        //
                        // DllName too long.
                        //
                        BufferSizeOk = FALSE;
                    } else {
                        Count = 0;
                        do {
                            Buffer[Count++] = (CHAR)*Filename++;
                        } while (Count < Length);

                        Buffer[Count] = 0;
                    }
                } else {
                    //
                    // Assume drivers
                    //
                    if (sizeof(Buffer) < 18 + NtSystemRoot.Length / sizeof(WCHAR) - 2
                                            + DataTableEntry->BaseDllName.Length / sizeof(WCHAR)
                                            + sizeof(ANSI_NULL)) {
                        //
                        // ignore the driver entry, it must have been corrupt.
                        //
                        BufferSizeOk = FALSE;

                    } else {
                        
                        sprintf (Buffer, "%ws\\System32\\Drivers\\%wZ",
                                 &SharedUserData->NtSystemRoot[2],
                                 &DataTableEntry->BaseDllName);
                    }
                }
                if (BufferSizeOk) {
                    RtlInitString (&NameString, Buffer );
                    DbgLoadImageSymbols (&NameString,
                                         DataTableEntry->DllBase,
                                         (ULONG)-1);

#if !defined(NT_UP)
                    if (!MmVerifyImageIsOkForMpUse(DataTableEntry->DllBase)) {
                        KeBugCheckEx(UP_DRIVER_ON_MP_SYSTEM,(ULONG_PTR)DataTableEntry->DllBase,0,0,0);
                    }
#endif // NT_UP
                }

            }
            ImageCount += 1;
            NextEntry = NextEntry->Flink;
        }

        //
        // If break after symbol load is specified, then break into the
        // debugger.
        //

        if (KdBreakAfterSymbolLoad != FALSE) {
            DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        }


        //
        // Turn on the headless terminal now, if we are of a sufficiently
        // new vintage of loader
        //
        if (LoaderBlock->Extension->Size >= sizeof (LOADER_PARAMETER_EXTENSION)) {
            HeadlessInit(LoaderBlock);
        }


        //
        // These fields are supported for legacy 3rd party 32-bit software
        // only.  New code should call NtQueryInformationSystem() to get them.
        //

#if defined(_WIN64)

        SharedUserData->Reserved1 = 0x7ffeffff; // 2gb HighestUserAddress
        SharedUserData->Reserved3 = 0x80000000; // 2gb SystemRangeStart

#else

        //
        // Set the highest user address and the start of the system range in
        // the shared memory block.
        //
        // N.B. This is not a constant value if the target system is an x86
        //      with 3gb of user virtual address space.
        //

        SharedUserData->Reserved1 = (ULONG)MM_HIGHEST_USER_ADDRESS;
        SharedUserData->Reserved3 = (ULONG)MmSystemRangeStart;

#endif

        //
        // Snapshot the NLS tables into paged pool and then
        // reset the translation tables.
        //
        // Walk through the memory descriptors and size the NLS data.
        //

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {

            MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                                 MEMORY_ALLOCATION_DESCRIPTOR,
                                                 ListEntry);

            if (MemoryDescriptor->MemoryType == LoaderNlsData) {
                InitNlsTableSize += MemoryDescriptor->PageCount*PAGE_SIZE;
            }

            NextMd = MemoryDescriptor->ListEntry.Flink;
        }

        InitNlsTableBase = ExAllocatePoolWithTag (NonPagedPool,
                                                  InitNlsTableSize,
                                                  ' slN');

        if (InitNlsTableBase == NULL) {
            KeBugCheck(PHASE0_INITIALIZATION_FAILED);
        }

        //
        // Copy the NLS data into the dynamic buffer so that we can
        // free the buffers allocated by the loader. The loader guarantees
        // contiguous buffers and the base of all the tables is the ANSI
        // code page data.
        //

        RtlCopyMemory (InitNlsTableBase,
                       LoaderBlock->NlsData->AnsiCodePageData,
                       InitNlsTableSize);

        RtlInitNlsTables ((PVOID)((PUCHAR)InitNlsTableBase+InitAnsiCodePageDataOffset),
            (PVOID)((PUCHAR)InitNlsTableBase+InitOemCodePageDataOffset),
            (PVOID)((PUCHAR)InitNlsTableBase+InitUnicodeCaseTableDataOffset),
            &InitTableInfo);

        RtlResetRtlTranslations (&InitTableInfo);

        //
        // Determine System version information.
        //

        DataTableEntry = CONTAINING_RECORD(LoaderBlock->LoadOrderListHead.Flink,
                                            KLDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);
        if (CmNtCSDVersion & 0xFFFF) {
            Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0,
                                WINDOWS_NT_CSD_STRING, &MessageEntry);
            if (NT_SUCCESS( Status )) {
                RtlInitAnsiString( &AnsiString, MessageEntry->Text );
                AnsiString.Length -= 2;
                sprintf( Buffer,
                         "%Z %u%c",
                         &AnsiString,
                         (CmNtCSDVersion & 0xFF00) >> 8,
                         (CmNtCSDVersion & 0xFF) ? 'A' + (CmNtCSDVersion & 0xFF) - 1 : '\0');
            }
            else {
                sprintf( Buffer, "CSD %04x", CmNtCSDVersion );
            }
        }
        else {
            CmCSDVersionString.MaximumLength = (USHORT) sprintf( Buffer, VER_PRODUCTBETA_STR );
        }

        //
        // High-order 16-bits of CSDVersion contain RC number.  If non-zero
        // display it after the Service Pack number.
        //

        if (CmNtCSDVersion & 0xFFFF0000) {
            s = Buffer + strlen( Buffer );
            if (s != Buffer) {
                *s++ = ',';
                *s++ = ' ';
                }
            Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0,
                                WINDOWS_NT_RC_STRING, &MessageEntry);

            if (NT_SUCCESS(Status)) {
                RtlInitAnsiString( &AnsiString, MessageEntry->Text );
                AnsiString.Length -= 2;
            }
            else {
                RtlInitAnsiString( &AnsiString, "RC" );
            }

            s += sprintf( s,
                          "%Z %u",
                          &AnsiString,
                          (CmNtCSDVersion & 0xFF000000) >> 24
                        );
            if (CmNtCSDVersion & 0x00FF0000) {
                s += sprintf( s, ".%u", (CmNtCSDVersion & 0x00FF0000) >> 16 );
            }
            *s++ = '\0';
        }

        RtlInitAnsiString( &AnsiString, Buffer );
        Status = RtlAnsiStringToUnicodeString( &CmCSDVersionString, &AnsiString, TRUE );
        if (!NT_SUCCESS (Status)) {
            KeBugCheckEx(PHASE0_INITIALIZATION_FAILED,Status,0,0,0);
        }

        sprintf( VersionBuffer, "%u.%u", NtMajorVersion, NtMinorVersion );
        RtlCreateUnicodeStringFromAsciiz( &CmVersionString, VersionBuffer );
        
        if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {

            PVOID StackTraceDataBase;
            ULONG StackTraceDataBaseLength;
            NTSTATUS Status;

            StackTraceDataBaseLength =  512 * 1024;
            switch ( MmQuerySystemSize() ) {
                case MmMediumSystem :
                    StackTraceDataBaseLength = 1024 * 1024;
                    break;

                case MmLargeSystem :
                    StackTraceDataBaseLength = 2048 * 1024;
                    break;
            }

            StackTraceDataBase = ExAllocatePoolWithTag( NonPagedPool,
                                         StackTraceDataBaseLength,
                                         'catS');

            if (StackTraceDataBase != NULL) {
                
                KdPrint(( "INIT: Kernel mode stack back trace enabled "
                          "with %u KB buffer.\n", StackTraceDataBaseLength / 1024 ));
                
                Status = RtlInitializeStackTraceDataBase (StackTraceDataBase,
                                                          StackTraceDataBaseLength,
                                                          StackTraceDataBaseLength);
            } else {
                Status = STATUS_NO_MEMORY;
            }

            if (!NT_SUCCESS( Status )) {
                KdPrint(( "INIT: Unable to initialize stack trace data base - Status == %lx\n", Status ));
            }
        }

        if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
            RtlInitializeExceptionLog(MAX_EXCEPTION_LOG);
        }

        ExInitializeHandleTablePackage();

#if DBG
        //
        // Allocate and zero the system service count table.
        //

        KeServiceDescriptorTable[0].Count =
                    (PULONG)ExAllocatePoolWithTag(NonPagedPool,
                                           KiServiceLimit * sizeof(ULONG),
                                           'llac');
        KeServiceDescriptorTableShadow[0].Count = KeServiceDescriptorTable[0].Count;
        if (KeServiceDescriptorTable[0].Count != NULL ) {
            RtlZeroMemory((PVOID)KeServiceDescriptorTable[0].Count,
                          KiServiceLimit * sizeof(ULONG));
        }
#endif

        if (!ObInitSystem()) {
            KeBugCheck(OBJECT_INITIALIZATION_FAILED);
        }

        if (!SeInitSystem()) {
            KeBugCheck(SECURITY_INITIALIZATION_FAILED);
        }

        if (PsInitSystem(0, LoaderBlock) == FALSE) {
            KeBugCheck(PROCESS_INITIALIZATION_FAILED);
        }

        if (!PpInitSystem()) {
            KeBugCheck(PP0_INITIALIZATION_FAILED);
        }

        //
        // Initialize debug system.
        //

        DbgkInitialize ();

        //
        // Compute the tick count multiplier that is used for computing the
        // windows millisecond tick count and copy the resultant value to
        // the memory that is shared between user and kernel mode.
        //

        ExpTickCountMultiplier = ExComputeTickCountMultiplier(KeMaximumIncrement);
        SharedUserData->TickCountMultiplier = ExpTickCountMultiplier;

        //
        // Set the base os version into shared memory
        //

        SharedUserData->NtMajorVersion = NtMajorVersion;
        SharedUserData->NtMinorVersion = NtMinorVersion;

        //
        // Set the supported image number range used to determine by the
        // loader if a particular image can be executed on the host system.
        // Eventually this will need to be dynamically computed. Also set
        // the architecture specific feature bits.
        //

#if defined(_AMD64_)

        SharedUserData->ImageNumberLow = IMAGE_FILE_MACHINE_AMD64;
        SharedUserData->ImageNumberHigh = IMAGE_FILE_MACHINE_AMD64;

#elif defined(_X86_)

        SharedUserData->ImageNumberLow = IMAGE_FILE_MACHINE_I386;
        SharedUserData->ImageNumberHigh = IMAGE_FILE_MACHINE_I386;

#elif defined(_IA64_)

        SharedUserData->ImageNumberLow = IMAGE_FILE_MACHINE_IA64;
        SharedUserData->ImageNumberHigh = IMAGE_FILE_MACHINE_IA64;

#else

#error "no target architecture"

#endif

    }
    else {

        //
        // Initialize the Hardware Architecture Layer (HAL).
        //

        if (HalInitSystem(InitializationPhase, LoaderBlock) == FALSE) {
            KeBugCheck(HAL_INITIALIZATION_FAILED);
        }
    }

    return;
}

VOID
xcpt4 (
    VOID
    );


VOID
Phase1Initialization(
    IN PVOID Context
    )
{
    PCHAR s;
    PLOADER_PARAMETER_BLOCK LoaderBlock;
    PETHREAD Thread;
    PKPRCB Prcb;
    KPRIORITY Priority;
    NTSTATUS Status;
    UNICODE_STRING SessionManager;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID Address;
    PFN_COUNT MemorySize;
    SIZE_T Size;
    ULONG Index;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    LARGE_INTEGER UniversalTime;
    LARGE_INTEGER CmosTime;
    LARGE_INTEGER OldTime;
    TIME_FIELDS TimeFields;
    UNICODE_STRING UnicodeDebugString;
    ANSI_STRING AnsiDebugString;
    UNICODE_STRING EnvString, NullString, UnicodeSystemDriveString;
    CHAR DebugBuffer[256];
    CHAR BootLogBuffer[256];        // must be the same size as DebugBuffer
    PWSTR Src, Dst;
    BOOLEAN ResetActiveTimeBias;
    HANDLE NlsSection;
    LARGE_INTEGER SectionSize;
    LARGE_INTEGER SectionOffset;
    PVOID SectionBase;
    PVOID ViewBase;
    ULONG CacheViewSize;
    SIZE_T CapturedViewSize;
    ULONG SavedViewSize;
    LONG BootTimeZoneBias;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    CHAR VersionBuffer[24];
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
#ifndef NT_UP
    PMESSAGE_RESOURCE_ENTRY MessageEntry1;
#endif
    PCHAR MPKernelString;
    PCHAR Options;
    PCHAR YearOverrideOption, SafeModeOption, BootLogOption;
    LONG  CurrentYear = 0;
    PSTR SafeBoot;
    BOOLEAN UseAlternateShell = FALSE;
#if defined(REMOTE_BOOT)
    BOOLEAN NetBootRequiresFormat = FALSE;
    BOOLEAN NetBootDisconnected = FALSE;
    CHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
    UNICODE_STRING TmpUnicodeString;
#endif // defined(REMOTE_BOOT)
    BOOLEAN NOGUIBOOT;
    BOOLEAN SOS;
    PVOID Environment;

    //
    // The following is a dummy reference to an inline function to force a
    // reference to the function so it won't get discard before it can be
    // exported.
    //

    KeAreApcsDisabled();

    //
    // Set the phase number and raise the priority of current thread to
    // a high priority so it will not be preempted during initialization.
    //

    ResetActiveTimeBias = FALSE;
    InitializationPhase = 1;
    Thread = PsGetCurrentThread();
    Priority = KeSetPriorityThread( &Thread->Tcb,MAXIMUM_PRIORITY - 1 );

    LoaderBlock = (PLOADER_PARAMETER_BLOCK)Context;

    //
    // Put Phase 1 initialization calls here.
    //

    if (HalInitSystem(InitializationPhase, LoaderBlock) == FALSE) {
        KeBugCheck(HAL1_INITIALIZATION_FAILED);
    }

    //
    // Allow the boot video driver to behave differently based on the
    // OsLoadOptions.
    //

    Options = LoaderBlock->LoadOptions ? _strupr(LoaderBlock->LoadOptions) : NULL;

    if (Options) {
        NOGUIBOOT = (BOOLEAN)(strstr(Options, "NOGUIBOOT") != NULL);
    } else {
        NOGUIBOOT = FALSE;
    }

    InbvEnableBootDriver((BOOLEAN)!NOGUIBOOT);

    //
    // There is now enough functionality for the system Boot Video
    // Driver to run.
    //

    InbvDriverInitialize(LoaderBlock, 18);

    if (NOGUIBOOT) {

        //
        // If the user specified the noguiboot switch we don't want to
        // use the bootvid driver, so release display ownership.
        //

        InbvNotifyDisplayOwnershipLost(NULL);
    }

    if (Options) {
        SOS = (BOOLEAN)(strstr(Options, "SOS") != NULL);
    } else {
        SOS = FALSE;
    }

    if (NOGUIBOOT) {
        InbvEnableDisplayString(FALSE);
    } else {
        InbvEnableDisplayString(SOS);
        DisplayBootBitmap(SOS);
    }

    //
    // Check whether we are booting into WinPE
    //
    if (Options) {
        if (strstr(Options, "MININT") != NULL) {
            InitIsWinPEMode = TRUE;

            if (strstr(Options, "INRAM") != NULL) {
                InitWinPEModeType |= INIT_WINPEMODE_INRAM;
            } else {
                InitWinPEModeType |= INIT_WINPEMODE_REGULAR;
            }                            
        }
    }    

    //
    // Now that the HAL is available and memory management has sized
    // memory, display the initial system banner containing the version number.
    // Under normal circumstances, this is the first message displayed
    // to the user by the OS.
    //

    DataTableEntry = CONTAINING_RECORD(LoaderBlock->LoadOrderListHead.Flink,
                                        KLDR_DATA_TABLE_ENTRY,
                                        InLoadOrderLinks);

    Status = RtlFindMessage (DataTableEntry->DllBase,
                             11,
                             0,
                             WINDOWS_NT_BANNER,
                             &MessageEntry);

    s = DebugBuffer;

    if (CmCSDVersionString.Length != 0) {
        s += sprintf( s, ": %wZ", &CmCSDVersionString );
    }

    *s++ = '\0';

    sprintf( VersionBuffer, "%u.%u", NtMajorVersion, NtMinorVersion );

    if (NT_SUCCESS(Status)) {
        sprintf (s,
             MessageEntry->Text,
             VersionBuffer,
             NtBuildNumber & 0xFFFF,
             DebugBuffer);
    } else {
        //
        // Could not find the WINDOWS_NT_BANNER message.
        //
        sprintf (s, "MICROSOFT (R) WINDOWS (TM)\n");
    }

    InbvDisplayString(s);

    RtlCopyMemory (BootLogBuffer, DebugBuffer, sizeof(DebugBuffer));

    //
    // Initialize the Power subsystem.
    //

    if (!PoInitSystem(0)) {
        KeBugCheck(INTERNAL_POWER_ERROR);
    }

    //
    // The user may have put a /YEAR=2000 switch on
    // the OSLOADOPTIONS line.  This allows us to
    // enforce a particular year on hardware that
    // has a broken clock.
    //

    if (Options) {
        YearOverrideOption = strstr(Options, "YEAR");
        if (YearOverrideOption != NULL) {
            YearOverrideOption = strstr(YearOverrideOption,"=");
        }
        if (YearOverrideOption != NULL) {
            CurrentYear = atol(YearOverrideOption + 1);
        }
    }

    //
    // Initialize the system time and set the time the system was booted.
    //
    // N.B. This cannot be done until after the phase one initialization
    //      of the HAL Layer.
    //

    if (ExCmosClockIsSane
        && HalQueryRealTimeClock(&TimeFields)) {

        //
        // If appropriate, override the year.
        //
        if (YearOverrideOption) {
            TimeFields.Year = (SHORT)CurrentYear;
        }

        RtlTimeFieldsToTime(&TimeFields, &CmosTime);
        UniversalTime = CmosTime;
        if ( !ExpRealTimeIsUniversal ) {

            //
            // If the system stores time in local time. This is converted to
            // universal time before going any further
            //
            // If we have previously set the time through NT, then
            // ExpLastTimeZoneBias should contain the timezone bias in effect
            // when the clock was set.  Otherwise, we will have to resort to
            // our next best guess which would be the programmed bias stored in
            // the registry
            //

            if ( ExpLastTimeZoneBias == -1 ) {
                ResetActiveTimeBias = TRUE;
                ExpLastTimeZoneBias = ExpAltTimeZoneBias;
                }

            ExpTimeZoneBias.QuadPart = Int32x32To64(
                                ExpLastTimeZoneBias*60,   // Bias in seconds
                                10000000
                                );
            SharedUserData->TimeZoneBias.High2Time = ExpTimeZoneBias.HighPart;
            SharedUserData->TimeZoneBias.LowPart = ExpTimeZoneBias.LowPart;
            SharedUserData->TimeZoneBias.High1Time = ExpTimeZoneBias.HighPart;
            UniversalTime.QuadPart = CmosTime.QuadPart + ExpTimeZoneBias.QuadPart;
        }
        KeSetSystemTime(&UniversalTime, &OldTime, FALSE, NULL);

        //
        // Notify other components that the system time has been set
        //

        PoNotifySystemTimeSet();

        KeBootTime = UniversalTime;
        KeBootTimeBias = 0;
    }

    MPKernelString = "";

#ifndef NT_UP

    //
    // Enforce processor licensing.
    //

    if (KeLicensedProcessors) {
        if (KeRegisteredProcessors > KeLicensedProcessors) {
            KeRegisteredProcessors = KeLicensedProcessors;
        }
    }

    if (Options) {
        ULONG NewRegisteredProcessors;
        PCHAR NumProcOption;

        NumProcOption = strstr(Options, "NUMPROC");
        if (NumProcOption != NULL) {
            NumProcOption = strstr(NumProcOption,"=");
        }
        if (NumProcOption != NULL) {
            NewRegisteredProcessors = atol(NumProcOption+1);
            if (NewRegisteredProcessors < KeRegisteredProcessors) {
                KeRegisteredProcessors = NewRegisteredProcessors;
            }

#if defined(_X86_)

            KeNumprocSpecified = NewRegisteredProcessors;

#endif

        }
    }

    //
    // If this is an MP build of the kernel start any other processors now
    //

    KeStartAllProcessors();

    //
    // Since starting processors has thrown off the system time, get it again
    // from the RTC and set the system time again.
    //

    if (ExCmosClockIsSane
        && HalQueryRealTimeClock(&TimeFields)) {

        if (YearOverrideOption) {
            TimeFields.Year = (SHORT)CurrentYear;
        }

        RtlTimeFieldsToTime(&TimeFields, &CmosTime);

        if ( !ExpRealTimeIsUniversal ) {
            UniversalTime.QuadPart = CmosTime.QuadPart + ExpTimeZoneBias.QuadPart;
        }

        KeSetSystemTime(&UniversalTime, &OldTime, TRUE, NULL);
    }

    //
    // Set the affinity of the system process and all of its threads to
    // all processors in the host configuration.
    //

    KeSetAffinityProcess(KeGetCurrentThread()->ApcState.Process,
                         KeActiveProcessors);

    Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0,
                        WINDOWS_NT_MP_STRING, &MessageEntry1);

    if (NT_SUCCESS( Status )) {
        MPKernelString = MessageEntry1->Text;
    }
    else {
        MPKernelString = "MultiProcessor Kernel\r\n";
    }
#endif

    //
    // Signify to the HAL that all processors have been started and any
    // post initialization should be performed.
    //

    if (!HalAllProcessorsStarted()) {
        KeBugCheck(HAL1_INITIALIZATION_FAILED);
    }

    RtlInitAnsiString( &AnsiDebugString, MPKernelString );
    if (AnsiDebugString.Length >= 2) {
        AnsiDebugString.Length -= 2;
    }

    //
    // Now that the processors have started, display number of processors
    // and size of memory.
    //

    Status = RtlFindMessage( DataTableEntry->DllBase,
                             11,
                             0,
                             KeNumberProcessors > 1 ? WINDOWS_NT_INFO_STRING_PLURAL
                                                    : WINDOWS_NT_INFO_STRING,
                             &MessageEntry
                           );

    MemorySize = 0;
    for (Index=0; Index < MmPhysicalMemoryBlock->NumberOfRuns; Index++) {
        MemorySize += (PFN_COUNT)MmPhysicalMemoryBlock->Run[Index].PageCount;
    }

    sprintf (DebugBuffer,
             NT_SUCCESS(Status) ? MessageEntry->Text : "%u System Processor [%u MB Memory] %Z\n",
             KeNumberProcessors,
             (MemorySize + (1 << (20 - PAGE_SHIFT)) - 1) >> (20 - PAGE_SHIFT),
             &AnsiDebugString);

    InbvDisplayString(DebugBuffer);
    InbvUpdateProgressBar(5);

#if defined(REMOTE_BOOT)
    //
    // Save any information from NetBoot for later.
    //

    if (IoRemoteBootClient) {

        ULONG Flags;

        ASSERT(LoaderBlock->SetupLoaderBlock != NULL);

        Flags = LoaderBlock->SetupLoaderBlock->Flags;

        NetBootDisconnected = (BOOLEAN)((Flags & SETUPBLK_FLAGS_DISCONNECTED) != 0);
        NetBootRequiresFormat = (BOOLEAN)((Flags & SETUPBLK_FLAGS_FORMAT_NEEDED) != 0);

        memcpy(NetBootHalName,
               LoaderBlock->SetupLoaderBlock->NetBootHalName,
               sizeof(NetBootHalName));
    }
#endif // defined(REMOTE_BOOT)

    //
    // Initialize OB, EX, KE, and KD.
    //

    if (!ObInitSystem()) {
        KeBugCheck(OBJECT1_INITIALIZATION_FAILED);
    }

    if (!ExInitSystem()) {
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,STATUS_UNSUCCESSFUL,0,1,0);
    }

    if (!KeInitSystem()) {
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,STATUS_UNSUCCESSFUL,0,2,0);
    }

    if (!KdInitSystem(InitializationPhase, NULL)) {
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,STATUS_UNSUCCESSFUL,0,3,0);
    }

    //
    // SE expects directory and executive objects to be available, but
    // must be before device drivers are initialized.
    //

    if (!SeInitSystem()) {
        KeBugCheck(SECURITY1_INITIALIZATION_FAILED);
    }

    InbvUpdateProgressBar(10);

    //
    // Create the symbolic link to \SystemRoot.
    //

    Status = CreateSystemRootLink(LoaderBlock);
    if ( !NT_SUCCESS(Status) ) {
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,Status,0,0,0);
    }

    if (MmInitSystem(1, LoaderBlock) == FALSE) {
        KeBugCheck(MEMORY1_INITIALIZATION_FAILED);
    }

    //
    // Snapshot the NLS tables into a page file backed section, and then
    // reset the translation tables.
    //

    SectionSize.HighPart = 0;
    SectionSize.LowPart = InitNlsTableSize;

    Status = ZwCreateSection(
                &NlsSection,
                SECTION_ALL_ACCESS,
                NULL,
                &SectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("INIT: Nls Section Creation Failed %x\n",Status));
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,1,0,0);
    }

    Status = ObReferenceObjectByHandle(
                NlsSection,
                SECTION_ALL_ACCESS,
                MmSectionObjectType,
                KernelMode,
                &InitNlsSectionPointer,
                NULL
                );

    ZwClose(NlsSection);

    if ( !NT_SUCCESS(Status) ) {
        KdPrint(("INIT: Nls Section Reference Failed %x\n",Status));
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,2,0,0);
    }

    SectionBase = NULL;
    CacheViewSize = SectionSize.LowPart;
    SavedViewSize = CacheViewSize;
    SectionSize.LowPart = 0;

    Status = MmMapViewInSystemCache (InitNlsSectionPointer,
                                     &SectionBase,
                                     &SectionSize,
                                     &CacheViewSize);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("INIT: Map In System Cache Failed %x\n",Status));
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,3,0,0);
    }

    //
    // Copy the NLS data into the dynamic buffer so that we can
    // free the buffers allocated by the loader. The loader guarantees
    // contiguous buffers and the base of all the tables is the ANSI
    // code page data.
    //

    RtlCopyMemory (SectionBase, InitNlsTableBase, InitNlsTableSize);

    //
    // Unmap the view to remove all pages from memory.  This prevents
    // these tables from consuming memory in the system cache while
    // the system cache is underutilized during bootup.
    //

    MmUnmapViewInSystemCache (SectionBase, InitNlsSectionPointer, FALSE);

    SectionBase = NULL;

    //
    // Map it back into the system cache, but now the pages will no
    // longer be valid.
    //

    Status = MmMapViewInSystemCache(
                InitNlsSectionPointer,
                &SectionBase,
                &SectionSize,
                &SavedViewSize
                );

    if ( !NT_SUCCESS(Status) ) {
        KdPrint(("INIT: Map In System Cache Failed %x\n",Status));
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,4,0,0);
    }

    ExFreePool(InitNlsTableBase);

    InitNlsTableBase = SectionBase;

    RtlInitNlsTables(
        (PVOID)((PUCHAR)InitNlsTableBase+InitAnsiCodePageDataOffset),
        (PVOID)((PUCHAR)InitNlsTableBase+InitOemCodePageDataOffset),
        (PVOID)((PUCHAR)InitNlsTableBase+InitUnicodeCaseTableDataOffset),
        &InitTableInfo
        );

    RtlResetRtlTranslations(&InitTableInfo);

    ViewBase = NULL;
    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    CapturedViewSize = 0;

    //
    // Map the system dll into the user part of the address space
    //

    Status = MmMapViewOfSection (InitNlsSectionPointer,
                                 PsGetCurrentProcess(),
                                 &ViewBase,
                                 0L,
                                 0L,
                                 &SectionOffset,
                                 &CapturedViewSize,
                                 ViewShare,
                                 0L,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("INIT: Map In User Portion Failed %x\n",Status));
        KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,5,0,0);
    }

    RtlCopyMemory (ViewBase, InitNlsTableBase, InitNlsTableSize);

    InitNlsTableBase = ViewBase;

    //
    // Initialize the cache manager.
    //

    if (!CcInitializeCacheManager()) {
        KeBugCheck(CACHE_INITIALIZATION_FAILED);
    }

    //
    // Config management (particularly the registry) gets initialized in
    // two parts.  Part 1 makes \REGISTRY\MACHINE\SYSTEM and
    // \REGISTRY\MACHINE\HARDWARE available.  These are needed to
    // complete IO init.
    //

    if (!CmInitSystem1(LoaderBlock)) {
        KeBugCheck(CONFIG_INITIALIZATION_FAILED);
    }

    //
    // Initialize the prefetcher after registry is initialized so we can
    // query the prefetching parameters.
    //

    CcPfInitializePrefetcher();

    InbvUpdateProgressBar(15);

    //
    // Compute timezone bias and next cutover date.
    //

    BootTimeZoneBias = ExpLastTimeZoneBias;
    ExpRefreshTimeZoneInformation(&CmosTime);

    if (ResetActiveTimeBias) {
        ExLocalTimeToSystemTime(&CmosTime,&UniversalTime);
        KeBootTime = UniversalTime;
        KeBootTimeBias = 0;
        KeSetSystemTime(&UniversalTime, &OldTime, FALSE, NULL);
    }
    else {

        //
        // Check to see if a timezone switch occurred prior to boot...
        //

        if (BootTimeZoneBias != ExpLastTimeZoneBias) {
            ZwSetSystemTime(NULL,NULL);
        }
    }


    if (!FsRtlInitSystem()) {
        KeBugCheck(FILE_INITIALIZATION_FAILED);
    }

    //
    // Initialize the range list package - this must be before PNP
    // initialization as PNP uses range lists.
    //

    RtlInitializeRangeListPackage();

    HalReportResourceUsage();

    KdDebuggerInitialize1(LoaderBlock);

    //
    // Perform phase1 initialization of the Plug and Play manager.  This
    // must be done before the I/O system initializes.
    //

    if (!PpInitSystem()) {
        KeBugCheck(PP1_INITIALIZATION_FAILED);
    }

    InbvUpdateProgressBar(20);

    //
    // LPC needs to be initialized before the I/O system, since
    // some drivers may create system threads that will terminate
    // and cause LPC to be called.
    //

    if (!LpcInitSystem()) {
        KeBugCheck(LPC_INITIALIZATION_FAILED);
    }

    //
    // Check for the existence of the safeboot option.
    //

    if (Options) {
        SafeBoot = strstr(Options,SAFEBOOT_LOAD_OPTION_A);
    } else {
        SafeBoot = FALSE;
    }

    if (SafeBoot) {

        //
        // Isolate the safeboot option.
        //

        SafeBoot += strlen(SAFEBOOT_LOAD_OPTION_A);

        //
        // Set the safeboot mode.
        //

        if (strncmp(SafeBoot,SAFEBOOT_MINIMAL_STR_A,strlen(SAFEBOOT_MINIMAL_STR_A))==0) {
            InitSafeBootMode = SAFEBOOT_MINIMAL;
            SafeBoot += strlen(SAFEBOOT_MINIMAL_STR_A);
        } else if (strncmp(SafeBoot,SAFEBOOT_NETWORK_STR_A,strlen(SAFEBOOT_NETWORK_STR_A))==0) {
            InitSafeBootMode = SAFEBOOT_NETWORK;
            SafeBoot += strlen(SAFEBOOT_NETWORK_STR_A);
        } else if (strncmp(SafeBoot,SAFEBOOT_DSREPAIR_STR_A,strlen(SAFEBOOT_DSREPAIR_STR_A))==0) {
            InitSafeBootMode = SAFEBOOT_DSREPAIR;
            SafeBoot += strlen(SAFEBOOT_DSREPAIR_STR_A);
        } else {
            InitSafeBootMode = 0;
        }

        if (*SafeBoot && strncmp(SafeBoot,SAFEBOOT_ALTERNATESHELL_STR_A,strlen(SAFEBOOT_ALTERNATESHELL_STR_A))==0) {
            UseAlternateShell = TRUE;
        }

        if (InitSafeBootMode) {

            PKLDR_DATA_TABLE_ENTRY DataTableEntry;
            PMESSAGE_RESOURCE_ENTRY MessageEntry;
            ULONG MsgId = 0;


            DataTableEntry = CONTAINING_RECORD(LoaderBlock->LoadOrderListHead.Flink,
                                                KLDR_DATA_TABLE_ENTRY,
                                                InLoadOrderLinks);

            switch (InitSafeBootMode) {
                case SAFEBOOT_MINIMAL:
                    MsgId = BOOTING_IN_SAFEMODE_MINIMAL;
                    break;

                case SAFEBOOT_NETWORK:
                    MsgId = BOOTING_IN_SAFEMODE_NETWORK;
                    break;

                case SAFEBOOT_DSREPAIR:
                    MsgId = BOOTING_IN_SAFEMODE_DSREPAIR;
                    break;
            }

            Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0, MsgId, &MessageEntry);
            if (NT_SUCCESS( Status )) {
                InbvDisplayString(MessageEntry->Text);
            }
        }
    }

    //
    // Check for the existence of the bootlog option.
    //

    if (Options) {
        BootLogOption = strstr(Options, "BOOTLOG");
    } else {
        BootLogOption = FALSE;
    }

    if (BootLogOption) {
         Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0, BOOTLOG_ENABLED, &MessageEntry);
        if (NT_SUCCESS( Status )) {
            InbvDisplayString(MessageEntry->Text);
        }
        IopInitializeBootLogging(LoaderBlock, BootLogBuffer);
    }

    //
    // Now that system time is running, initialize more of the Executive.
    //

    ExInitSystemPhase2();

    InbvUpdateProgressBar(25);

    //
    // Allow time slip notification changes.
    //

    KdpTimeSlipPending = 0;


    //
    // If we are running XIP, we have to initialize XIP before the I/O system calls xipdisk.sys
    // This is defined to be nothing on platforms that do not support XIP.
    //
    XIPInit(LoaderBlock);

    //
    // Initialize the Io system.
    //
    // IoInitSystem updates progress bar updates from 25 to 75 %.
    //

    InbvSetProgressBarSubset(25, 75);

    if (!IoInitSystem(LoaderBlock)) {
        KeBugCheck(IO1_INITIALIZATION_FAILED);
    }

    //
    // Clear progress bar subset, goes back to absolute mode.
    //

    InbvSetProgressBarSubset(0, 100);

    //
    // Set the registry value that indicates we've booted in safeboot mode.
    //

    if (InitSafeBootMode) {

        HANDLE hSafeBoot,hOption;
        UNICODE_STRING string;
        OBJECT_ATTRIBUTES objectAttributes;
        ULONG disposition;
        UCHAR Buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + 32];
        ULONG length;
        PKEY_VALUE_PARTIAL_INFORMATION keyValue;

        InitializeObjectAttributes(
            &objectAttributes,
            &CmRegistryMachineSystemCurrentControlSetControlSafeBoot,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey(
            &hSafeBoot,
            KEY_ALL_ACCESS,
            &objectAttributes
            );

        if (NT_SUCCESS(Status)) {

            if (UseAlternateShell) {

                RtlInitUnicodeString( &string, L"AlternateShell" );

                keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
                RtlZeroMemory(Buffer, sizeof(Buffer));

                Status = NtQueryValueKey(
                    hSafeBoot,
                    &string,
                    KeyValuePartialInformation,
                    keyValue,
                    sizeof(Buffer),
                    &length
                    );
                if (!NT_SUCCESS(Status)) {
                    UseAlternateShell = FALSE;
                }
            }

            RtlInitUnicodeString( &string, L"Option" );

            InitializeObjectAttributes(
                &objectAttributes,
                &string,
                OBJ_CASE_INSENSITIVE,
                hSafeBoot,
                NULL
                );

            Status = ZwCreateKey(
                &hOption,
                KEY_ALL_ACCESS,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &disposition
                );

            NtClose(hSafeBoot);

            if (NT_SUCCESS(Status)) {
                RtlInitUnicodeString( &string, L"OptionValue" );
                Status = NtSetValueKey(
                    hOption,
                    &string,
                    0,
                    REG_DWORD,
                    &InitSafeBootMode,
                    sizeof(ULONG)
                    );

                if (UseAlternateShell) {
                    RtlInitUnicodeString( &string, L"UseAlternateShell" );
                    Index = 1;
                    Status = NtSetValueKey(
                        hOption,
                        &string,
                        0,
                        REG_DWORD,
                        &Index,
                        sizeof(ULONG)
                        );
                }

                NtClose(hOption);
            }
        }
    }

    //
    // Create the Mini NT boot key, to indicate to the user mode
    // programs that we are in Mini NT environment.
    //

    if (InitIsWinPEMode) {
        WCHAR               KeyName[256] = {0};
        HANDLE              hControl;
        UNICODE_STRING      String;
        OBJECT_ATTRIBUTES   ObjAttrs;
        ULONG               Disposition;

        wcsncpy(KeyName, CmRegistryMachineSystemCurrentControlSet.Buffer,
                    CmRegistryMachineSystemCurrentControlSet.Length);

        wcscat(KeyName, L"\\Control");

        RtlInitUnicodeString(&String, KeyName);

        InitializeObjectAttributes(
            &ObjAttrs,
            &String,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey(
            &hControl,
            KEY_ALL_ACCESS,
            &ObjAttrs
            );

        if (NT_SUCCESS(Status)) {
            HANDLE  hMiniNT;

            RtlInitUnicodeString(&String, L"MiniNT");

            InitializeObjectAttributes(
                &ObjAttrs,
                &String,
                OBJ_CASE_INSENSITIVE,
                hControl,
                NULL
                );

            Status = ZwCreateKey(
                &hMiniNT,
                KEY_ALL_ACCESS,
                &ObjAttrs,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &Disposition
                );

            if (NT_SUCCESS(Status)) {
                ZwClose(hMiniNT);
            }

            ZwClose(hControl);
        }

        //
        // If we could not create the key, then bug check
        // since we can't boot into mini NT anyway.
        //

        if (!NT_SUCCESS(Status)) {
            KeBugCheckEx(PHASE1_INITIALIZATION_FAILED,Status,6,0,0);
        }
    }

    //
    // Begin paging the executive if desired.
    //

    MmInitSystem(2, LoaderBlock);

    InbvUpdateProgressBar(80);


#if defined(_X86_)

    //
    // Initialize Vdm specific stuff
    //
    // Note:  If this fails, Vdms may not be able to run, but it isn't
    //        necessary to bugcheck the system because of this.
    //

    KeI386VdmInitialize();

#if !defined(NT_UP)

    //
    // Now that the error log interface has been initialized, write
    // an informational message if it was determined that the
    // processors in the system are at differing revision levels.
    //

    if (CmProcessorMismatch != 0) {

        PIO_ERROR_LOG_PACKET ErrLog;

        ErrLog = IoAllocateGenericErrorLogEntry(ERROR_LOG_MAXIMUM_SIZE);

        if (ErrLog) {

            //
            // Fill it in and write it out.
            //

            ErrLog->FinalStatus = STATUS_MP_PROCESSOR_MISMATCH;
            ErrLog->ErrorCode = STATUS_MP_PROCESSOR_MISMATCH;
            ErrLog->UniqueErrorValue = CmProcessorMismatch;

            IoWriteErrorLogEntry(ErrLog);
        }
    }

#endif // !NT_UP

#endif // _X86_

    if (!PoInitSystem(1)) {
        KeBugCheck(INTERNAL_POWER_ERROR);
    }

    //
    // Okay to call PsInitSystem now that \SystemRoot is defined so it can
    // locate NTDLL.DLL and SMSS.EXE.
    //

    if (PsInitSystem(1, LoaderBlock) == FALSE) {
        KeBugCheck(PROCESS1_INITIALIZATION_FAILED);
    }

    InbvUpdateProgressBar(85);

    //
    // Force KeBugCheck to look at PsLoadedModuleList now that it is setup.
    //

    if (LoaderBlock == KeLoaderBlock) {
        KeLoaderBlock = NULL;
    }

    //
    // Free loader block.
    //

    MmFreeLoaderBlock (LoaderBlock);
    LoaderBlock = NULL;
    Context = NULL;

    //
    // Perform Phase 1 Reference Monitor Initialization.  This includes
    // creating the Reference Monitor Command Server Thread, a permanent
    // thread of the System Init process.  That thread will create an LPC
    // port called the Reference Monitor Command Port through which
    // commands sent by the Local Security Authority Subsystem will be
    // received.  These commands (e.g. Enable Auditing) change the Reference
    // Monitor State.
    //

    if (!SeRmInitPhase1()) {
        KeBugCheck(REFMON_INITIALIZATION_FAILED);
    }

    InbvUpdateProgressBar(90);

    //
    // Set up process parameters for the Session Manager Subsystem.
    //
    // NOTE: Remote boot allocates an extra DOS_MAX_PATH_LENGTH number of
    // WCHARs in order to hold command line arguments to smss.exe.
    //

    Size = sizeof( *ProcessParameters ) +
           ((DOS_MAX_PATH_LENGTH * 6) * sizeof( WCHAR ));
    ProcessParameters = NULL;
    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&ProcessParameters,
                                      0,
                                      &Size,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (!NT_SUCCESS( Status )) {
#if DBG
        sprintf(DebugBuffer,
                "INIT: Unable to allocate Process Parameters. 0x%lx\n",
                Status);

        RtlInitAnsiString(&AnsiDebugString, DebugBuffer);
        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDebugString,
                                              &AnsiDebugString,
                                          TRUE)) == FALSE) {
            KeBugCheck(SESSION1_INITIALIZATION_FAILED);
        }
        ZwDisplayString(&UnicodeDebugString);
#endif // DBG
        KeBugCheckEx(SESSION1_INITIALIZATION_FAILED,Status,0,0,0);
    }

    ProcessParameters->Length = (ULONG)Size;
    ProcessParameters->MaximumLength = (ULONG)Size;

    //
    // Reserve the low 1 MB of address space in the session manager.
    // Setup gets started using a replacement for the session manager
    // and that process needs to be able to use the vga driver on x86,
    // which uses int10 and thus requires the low 1 meg to be reserved
    // in the process. The cost is so low that we just do this all the
    // time, even when setup isn't running.
    //

    ProcessParameters->Flags = RTL_USER_PROC_PARAMS_NORMALIZED | RTL_USER_PROC_RESERVE_1MB;

    Size = PAGE_SIZE;
    Environment = NULL;
    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                      &Environment,
                                      0,
                                      &Size,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (!NT_SUCCESS( Status )) {
#if DBG
        sprintf(DebugBuffer,
                "INIT: Unable to allocate Process Environment 0x%lx\n",
                Status);

        RtlInitAnsiString(&AnsiDebugString, DebugBuffer);
        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDebugString,
                                              &AnsiDebugString,
                                          TRUE)) == FALSE) {
            KeBugCheck(SESSION2_INITIALIZATION_FAILED);
        }
        ZwDisplayString(&UnicodeDebugString);
#endif // DBG
        KeBugCheckEx(SESSION2_INITIALIZATION_FAILED,Status,0,0,0);
    }

    ProcessParameters->Environment = Environment;

    Dst = (PWSTR)(ProcessParameters + 1);
    ProcessParameters->CurrentDirectory.DosPath.Buffer = Dst;
    ProcessParameters->CurrentDirectory.DosPath.MaximumLength = DOS_MAX_PATH_LENGTH * sizeof( WCHAR );
    RtlCopyUnicodeString( &ProcessParameters->CurrentDirectory.DosPath,
                          &NtSystemRoot
                        );

    Dst = (PWSTR)((PCHAR)ProcessParameters->CurrentDirectory.DosPath.Buffer +
                  ProcessParameters->CurrentDirectory.DosPath.MaximumLength
                 );
    ProcessParameters->DllPath.Buffer = Dst;
    ProcessParameters->DllPath.MaximumLength = DOS_MAX_PATH_LENGTH * sizeof( WCHAR );
    RtlCopyUnicodeString( &ProcessParameters->DllPath,
                          &ProcessParameters->CurrentDirectory.DosPath
                        );
    RtlAppendUnicodeToString( &ProcessParameters->DllPath, L"\\System32" );

    Dst = (PWSTR)((PCHAR)ProcessParameters->DllPath.Buffer +
                  ProcessParameters->DllPath.MaximumLength
                 );
    ProcessParameters->ImagePathName.Buffer = Dst;
    ProcessParameters->ImagePathName.MaximumLength = DOS_MAX_PATH_LENGTH * sizeof( WCHAR );

    if (NtInitialUserProcessBufferType != REG_SZ ||
        (NtInitialUserProcessBufferLength != (ULONG)-1 &&
         (NtInitialUserProcessBufferLength < sizeof(WCHAR) ||
          NtInitialUserProcessBufferLength >
          sizeof(NtInitialUserProcessBuffer) - sizeof(WCHAR)))) {

        KeBugCheckEx(SESSION2_INITIALIZATION_FAILED,
                     STATUS_INVALID_PARAMETER,
                     NtInitialUserProcessBufferType,
                     NtInitialUserProcessBufferLength,
                     sizeof(NtInitialUserProcessBuffer));
    }

    // Executable names with spaces don't need to
    // be supported so just find the first space and
    // assume it terminates the process image name.
    Src = NtInitialUserProcessBuffer;
    while (*Src && *Src != L' ') {
        Src++;
    }

    ProcessParameters->ImagePathName.Length =
        (USHORT)((PUCHAR)Src - (PUCHAR)NtInitialUserProcessBuffer);
    RtlCopyMemory(ProcessParameters->ImagePathName.Buffer,
                  NtInitialUserProcessBuffer,
                  ProcessParameters->ImagePathName.Length);
    ProcessParameters->ImagePathName.Buffer[ProcessParameters->ImagePathName.Length / sizeof(WCHAR)] = UNICODE_NULL;

    Dst = (PWSTR)((PCHAR)ProcessParameters->ImagePathName.Buffer +
                  ProcessParameters->ImagePathName.MaximumLength
                 );
    ProcessParameters->CommandLine.Buffer = Dst;
    ProcessParameters->CommandLine.MaximumLength = DOS_MAX_PATH_LENGTH * sizeof( WCHAR );
    RtlAppendUnicodeToString(&ProcessParameters->CommandLine,
                             NtInitialUserProcessBuffer);

#if defined(REMOTE_BOOT)
    //
    // Pass additional parameters for remote boot clients.
    //

    if (IoRemoteBootClient && !ExpInTextModeSetup) {

        RtlAppendUnicodeToString(&ProcessParameters->CommandLine, L" NETBOOT");

        RtlAppendUnicodeToString(&ProcessParameters->CommandLine, L" NETBOOTHAL ");
        AnsiDebugString.Length = strlen(NetBootHalName);
        AnsiDebugString.MaximumLength = sizeof(NetBootHalName);
        AnsiDebugString.Buffer = NetBootHalName;
        Status = RtlAnsiStringToUnicodeString(&TmpUnicodeString, &AnsiDebugString, TRUE);
        if (!NT_SUCCESS (Status)) {
            KeBugCheckEx(SESSION2_INITIALIZATION_FAILED,Status,1,0,0);
        }

        RtlAppendUnicodeStringToString(&ProcessParameters->CommandLine, &TmpUnicodeString);
        (RtlFreeStringRoutine)(TmpUnicodeString.Buffer);

        if (NetBootDisconnected) {
            RtlAppendUnicodeToString(&ProcessParameters->CommandLine, L" NETBOOTDISCONNECTED");
        }
        if (NetBootRequiresFormat) {
            RtlAppendUnicodeToString(&ProcessParameters->CommandLine, L" NETBOOTFORMAT");
        }
    }
#endif // defined(REMOTE_BOOT)

    NullString.Buffer = L"";
    NullString.Length = sizeof(WCHAR);
    NullString.MaximumLength = sizeof(WCHAR);

    EnvString.Buffer = ProcessParameters->Environment;
    EnvString.Length = 0;
    EnvString.MaximumLength = (USHORT)Size;

    RtlAppendUnicodeToString( &EnvString, L"Path=" );
    RtlAppendUnicodeStringToString( &EnvString, &ProcessParameters->DllPath );
    RtlAppendUnicodeStringToString( &EnvString, &NullString );

    UnicodeSystemDriveString = NtSystemRoot;
    UnicodeSystemDriveString.Length = 2 * sizeof( WCHAR );
    RtlAppendUnicodeToString( &EnvString, L"SystemDrive=" );
    RtlAppendUnicodeStringToString( &EnvString, &UnicodeSystemDriveString );
    RtlAppendUnicodeStringToString( &EnvString, &NullString );

    RtlAppendUnicodeToString( &EnvString, L"SystemRoot=" );
    RtlAppendUnicodeStringToString( &EnvString, &NtSystemRoot );
    RtlAppendUnicodeStringToString( &EnvString, &NullString );


#if 0
    KdPrint(( "ProcessParameters at %lx\n", ProcessParameters ));
    KdPrint(( "    CurDir:    %wZ\n", &ProcessParameters->CurrentDirectory.DosPath ));
    KdPrint(( "    DllPath:   %wZ\n", &ProcessParameters->DllPath ));
    KdPrint(( "    ImageFile: %wZ\n", &ProcessParameters->ImagePathName ));
    KdPrint(( "    Environ:   %lx\n", ProcessParameters->Environment ));
    Src = ProcessParameters->Environment;
    while (*Src) {
        KdPrint(( "        %ws\n", Src ));
        while (*Src++) {
            ;
        }
    }
#endif

    //
    // Notify boot prefetcher of boot progress.
    //

    CcPfBeginBootPhase(PfSessionManagerInitPhase);

    SessionManager = ProcessParameters->ImagePathName;
    Status = RtlCreateUserProcess(
                &SessionManager,
                OBJ_CASE_INSENSITIVE,
                RtlDeNormalizeProcessParams( ProcessParameters ),
                NULL,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                &ProcessInformation);

    if (InbvBootDriverInstalled)
    {
        FinalizeBootLogo();
    }

    if (!NT_SUCCESS(Status)) {
#if DBG
        sprintf(DebugBuffer,
                "INIT: Unable to create Session Manager. 0x%lx\n",
                Status);

        RtlInitAnsiString(&AnsiDebugString, DebugBuffer);
        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDebugString,
                                              &AnsiDebugString,
                                          TRUE)) == FALSE) {
            KeBugCheck(SESSION3_INITIALIZATION_FAILED);
        }
        ZwDisplayString(&UnicodeDebugString);
#endif // DBG
        KeBugCheckEx(SESSION3_INITIALIZATION_FAILED,Status,0,0,0);
    }

    Status = ZwResumeThread(ProcessInformation.Thread,NULL);

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        sprintf(DebugBuffer,
                "INIT: Unable to resume Session Manager. 0x%lx\n",
                Status);

        RtlInitAnsiString(&AnsiDebugString, DebugBuffer);
        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDebugString,
                                              &AnsiDebugString,
                                          TRUE)) == FALSE) {
            KeBugCheck(SESSION4_INITIALIZATION_FAILED);
        }
        ZwDisplayString(&UnicodeDebugString);
#endif // DBG
        KeBugCheckEx(SESSION4_INITIALIZATION_FAILED,Status,0,0,0);
    }

    InbvUpdateProgressBar(100);

    //
    // Turn on debug output so that we can see chkdsk run.
    //

    InbvEnableDisplayString(TRUE);

    //
    // Wait five seconds for the session manager to get started or
    // terminate. If the wait times out, then the session manager
    // is assumed to be healthy and the zero page thread is called.
    //

    OldTime.QuadPart = Int32x32To64(5, -(10 * 1000 * 1000));
    Status = ZwWaitForSingleObject(
                ProcessInformation.Process,
                FALSE,
                &OldTime
                );

    if (Status == STATUS_SUCCESS) {

#if DBG

        sprintf(DebugBuffer, "INIT: Session Manager terminated.\n");
        RtlInitAnsiString(&AnsiDebugString, DebugBuffer);
        Status = RtlAnsiStringToUnicodeString(&UnicodeDebugString,
                                              &AnsiDebugString,
                                              TRUE);

        if (!NT_SUCCESS (Status)) {
            KeBugCheckEx(SESSION4_INITIALIZATION_FAILED,Status,1,0,0);
        }

        ZwDisplayString(&UnicodeDebugString);

#endif // DBG

        KeBugCheck(SESSION5_INITIALIZATION_FAILED);

    }

    //
    // Don't need these handles anymore.
    //

    ZwClose( ProcessInformation.Thread );
    ZwClose( ProcessInformation.Process );

    //
    // Free up memory used to pass arguments to session manager.
    //

    Size = 0;
    Address = Environment;
    ZwFreeVirtualMemory( NtCurrentProcess(),
                         (PVOID *)&Address,
                         &Size,
                         MEM_RELEASE
                       );

    Size = 0;
    Address = ProcessParameters;
    ZwFreeVirtualMemory( NtCurrentProcess(),
                         (PVOID *)&Address,
                         &Size,
                         MEM_RELEASE
                       );

    InitializationPhase += 1;

#if defined(_X86_)

    KiInitializeInterruptTimers();

#endif

    MmZeroPageThread();
}

NTSTATUS
CreateSystemRootLink(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

{
    HANDLE handle;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    STRING linkString;
    UNICODE_STRING linkUnicodeString;
    NTSTATUS status;
    UCHAR deviceNameBuffer[256];
    STRING deviceNameString;
    UNICODE_STRING deviceNameUnicodeString;
    HANDLE linkHandle;

#if DBG

    UCHAR debugBuffer[256];
    STRING debugString;
    UNICODE_STRING debugUnicodeString;

#endif

    //
    // Create the root directory object for the \ArcName directory.
    //

    RtlInitUnicodeString( &nameString, L"\\ArcName" );

    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                NULL,
                                SePublicDefaultUnrestrictedSd );

    status = NtCreateDirectoryObject( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,status,1,0,0);
        return status;
    } else {
        (VOID) NtClose( handle );
    }

    //
    // Create the root directory object for the \Device directory.
    //

    RtlInitUnicodeString( &nameString, L"\\Device" );


    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                NULL,
                                SePublicDefaultUnrestrictedSd );

    status = NtCreateDirectoryObject( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,status,2,0,0);
        return status;
    } else {
        (VOID) NtClose( handle );
    }

    //
    // Create the symbolic link to the root of the system directory.
    //

    RtlInitAnsiString( &linkString, INIT_SYSTEMROOT_LINKNAME );

    status = RtlAnsiStringToUnicodeString( &linkUnicodeString,
                                           &linkString,
                                           TRUE);

    if (!NT_SUCCESS( status )) {
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,status,3,0,0);
        return status;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &linkUnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                NULL,
                                SePublicDefaultUnrestrictedSd );

    //
    // Use ARC device name and system path from loader.
    //

    sprintf( deviceNameBuffer,
             "\\ArcName\\%s%s",
             LoaderBlock->ArcBootDeviceName,
             LoaderBlock->NtBootPathName);

    deviceNameBuffer[strlen(deviceNameBuffer)-1] = '\0';

    RtlInitString( &deviceNameString, deviceNameBuffer );

    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                           &deviceNameString,
                                           TRUE );

    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString( &linkUnicodeString );
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,status,4,0,0);
        return status;
    }

    status = NtCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         &deviceNameUnicodeString );

    RtlFreeUnicodeString( &linkUnicodeString );
    RtlFreeUnicodeString( &deviceNameUnicodeString );

    if (!NT_SUCCESS(status)) {
        KeBugCheckEx(SYMBOLIC_INITIALIZATION_FAILED,status,5,0,0);
        return status;
    }

#if DBG

    sprintf( debugBuffer, "INIT: %s => %s\n",
             INIT_SYSTEMROOT_LINKNAME,
             deviceNameBuffer );

    RtlInitAnsiString( &debugString, debugBuffer );

    status = RtlAnsiStringToUnicodeString( &debugUnicodeString,
                                           &debugString,
                                           TRUE );

    if (NT_SUCCESS(status)) {
        ZwDisplayString( &debugUnicodeString );
        RtlFreeUnicodeString( &debugUnicodeString );
    }

#endif // DBG

    NtClose( linkHandle );

    return STATUS_SUCCESS;
}

#if 0

PVOID
LookupImageBaseByName (
    IN PLIST_ENTRY ListHead,
    IN PSZ         Name
    )
/*++

    Lookups BaseAddress of ImageName - returned value can be used
    to find entry points via LookupEntryPoint

--*/
{
    PKLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY         Next;
    PVOID               Base;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    NTSTATUS            status;

    Next = ListHead->Flink;
    if (!Next) {
        return NULL;
    }

    RtlInitAnsiString(&ansiString, Name);
    status = RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, TRUE );
    if (!NT_SUCCESS (status)) {
        return NULL;
    }

    Base = NULL;
    while (Next != ListHead) {
        Entry = CONTAINING_RECORD(Next, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        if (RtlEqualUnicodeString (&unicodeString, &Entry->BaseDllName, TRUE)) {
            Base = Entry->DllBase;
            break;
        }
    }

    RtlFreeUnicodeString( &unicodeString );
    return Base;
}

#endif

NTSTATUS
LookupEntryPoint (
    IN PVOID DllBase,
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    )
/*++

Routine Description:

    Returns the address of an entry point given the DllBase and PSZ
    name of the entry point in question

--*/

{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportSize;
    USHORT Ordinal;
    PULONG Addr;
    CHAR NameBuffer[64];

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        RtlImageDirectoryEntryToData(
            DllBase,
            TRUE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &ExportSize);

#if DBG
    if (!ExportDirectory) {
        DbgPrint("LookupENtryPoint: Can't locate system Export Directory\n");
    }
#endif

    if ( strlen(NameOfEntryPoint) > sizeof(NameBuffer)-2 ) {
        return STATUS_INVALID_PARAMETER;
    }

    strcpy(NameBuffer,NameOfEntryPoint);

    Ordinal = NameToOrdinal(
                NameBuffer,
                (ULONG_PTR)DllBase,
                ExportDirectory->NumberOfNames,
                (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfNames),
                (PUSHORT)((ULONG_PTR)DllBase + ExportDirectory->AddressOfNameOrdinals)
                );

    //
    // If Ordinal is not within the Export Address Table,
    // then DLL does not implement function.
    //

    if ( (ULONG)Ordinal >= ExportDirectory->NumberOfFunctions ) {
        return STATUS_PROCEDURE_NOT_FOUND;
    }

    Addr = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfFunctions);
    *AddressOfEntryPoint = (PVOID)((ULONG_PTR)DllBase + Addr[Ordinal]);
    return STATUS_SUCCESS;
}

static USHORT
NameToOrdinal (
    IN PSZ NameOfEntryPoint,
    IN ULONG_PTR DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    )
{

    ULONG SplitIndex;
    LONG CompareResult;

    if ( NumberOfNames == 0 ) {
        return (USHORT)-1;
    }

    SplitIndex = NumberOfNames >> 1;

    CompareResult = strcmp(NameOfEntryPoint, (PSZ)(DllBase + NameTableBase[SplitIndex]));

    if ( CompareResult == 0 ) {
        return NameOrdinalTableBase[SplitIndex];
    }

    if ( NumberOfNames == 1 ) {
        return (USHORT)-1;
    }

    if ( CompareResult < 0 ) {
        NumberOfNames = SplitIndex;
    } else {
        NameTableBase = &NameTableBase[SplitIndex+1];
        NameOrdinalTableBase = &NameOrdinalTableBase[SplitIndex+1];
        NumberOfNames = NumberOfNames - SplitIndex - 1;
    }

    return NameToOrdinal(NameOfEntryPoint,DllBase,NumberOfNames,NameTableBase,NameOrdinalTableBase);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\ntkrpamp.c ===
#include "ntoskrnl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\bootvid.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    bootvid.c

Abstract:

    This file implements the interface between the kernel, and the
    graphical boot driver.

Author:

    Erick Smith (ericks) Feb. 3, 1998

Environment:

    kernel mode

Revision History:

--*/

#include "ntos.h"
#include "ntimage.h"
#include <zwapi.h>
#include <ntdddisk.h>
#include <setupblk.h>
#include <fsrtl.h>
#include <ntverp.h>

#include "stdlib.h"
#include "stdio.h"
#include <string.h>

#include <safeboot.h>

#include <inbv.h>
#include <bootvid.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include "anim.h"

ULONG InbvTerminalBkgdColor = HEADLESS_TERM_DEFAULT_BKGD_COLOR;
ULONG InbvTerminalTextColor = HEADLESS_TERM_DEFAULT_TEXT_COLOR;

PUCHAR
FindBitmapResource(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR ResourceIdentifier
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,InbvIndicateProgress)
#pragma alloc_text(INIT,InbvDriverInitialize)
#pragma alloc_text(INIT,FindBitmapResource)
#endif

//
// System global variable
//

BOOLEAN InbvBootDriverInstalled = FALSE;
BOOLEAN InbvDisplayDebugStrings = FALSE;
INBV_DISPLAY_STATE InbvDisplayState = INBV_DISPLAY_STATE_OWNED;

KSPIN_LOCK BootDriverLock;
KIRQL InbvOldIrql;

INBV_RESET_DISPLAY_PARAMETERS InbvResetDisplayParameters = NULL;
INBV_DISPLAY_STRING_FILTER    InbvDisplayFilter          = NULL;

#define MAX_RESOURCES 16

ULONG   ResourceCount = 0;
PUCHAR  ResourceList[MAX_RESOURCES];

ULONG   ProgressBarLeft;
ULONG   ProgressBarTop;
BOOLEAN ShowProgressBar = TRUE;

struct _InbvProgressState {
    ULONG   Floor;
    ULONG   Ceiling;
    ULONG   Bias;
} InbvProgressState;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

struct _BT_PROGRESS_INDICATOR {
    ULONG   Count;
    ULONG   Expected;
    ULONG   Percentage;
} InbvProgressIndicator = { 0, 25, 0 };


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

VOID
InbvAcquireLock(
    VOID
    )

/*++

Routine Description:

    This is an internal function used to grab the boot driver lock.  This
    ensures that only one thread will enter the driver code at a time.

Notes:

    You must call ReleaseLock for each call to AcquireLock.

--*/

{
    KIRQL Irql;
    KIRQL LocalIrql;

    LocalIrql = KeGetCurrentIrql();

    if (LocalIrql <= DISPATCH_LEVEL) {

        while (!KeTestSpinLock(&BootDriverLock))
            ;
        KeRaiseIrql(DISPATCH_LEVEL, &Irql);
        LocalIrql = Irql;
    }

    KiAcquireSpinLock(&BootDriverLock);
    InbvOldIrql = LocalIrql;
}

VOID
InbvReleaseLock(
    VOID
    )

/*++

Routine Description:

    This routine releases the boot driver lock.

--*/

{
    KIRQL OldIrql = InbvOldIrql;

    KiReleaseSpinLock(&BootDriverLock);

    if (OldIrql <= DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}

BOOLEAN
InbvTestLock(
    VOID
    )

/*++

Routine Description:

    This routine allows you to try to acquire the display lock.  If it
    can't get the lock right away, it returns failure.

Returns:

    TRUE  - If you aqcuired the lock.
    FALSE - If another thread is currently using the boot driver.

Notes:

    You must call InbvReleaseLock if this function returns TRUE!

--*/

{
    KIRQL Irql;

    if (KeTryToAcquireSpinLock(&BootDriverLock, &Irql)) {
        InbvOldIrql = Irql;
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
InbvEnableBootDriver(
    BOOLEAN bEnable
    )

/*++

Routine Description:

    This routine allows the kernel to control whether Inbv
    calls make it through to the boot driver, and when they don't.

Arguments:

    bEnable - If TRUE, we will allow Inbv calls to display,
              otherwise we will not.

--*/

{
    if (InbvBootDriverInstalled) {

        if (InbvDisplayState < INBV_DISPLAY_STATE_LOST) {

            //
            // We can only wait for our lock, and execute our clean up code
            // if the driver is installed.
            //

            InbvAcquireLock();

            if (InbvDisplayState == INBV_DISPLAY_STATE_OWNED) {
                VidCleanUp();
            }

            InbvDisplayState = (bEnable ? INBV_DISPLAY_STATE_OWNED : INBV_DISPLAY_STATE_DISABLED);
            InbvReleaseLock();
        }

    } else {

        //
        // This allow us to set display state before boot driver starts.
        //

        InbvDisplayState = (bEnable ? INBV_DISPLAY_STATE_OWNED : INBV_DISPLAY_STATE_DISABLED);
    }
}

BOOLEAN
InbvEnableDisplayString(
    BOOLEAN bEnable
    )

/*++

Routine Description:

    This routine allows the kernel to control when HalDisplayString
    calls make it through to the boot driver, and when they don't.

Arguments:

    bEnable - If TRUE, we will allow HalDisplayString calls to display,
              otherwise we will not.

Returns:

    TRUE  - If display string were currently being dumped.
    FALSE - otherwise.

--*/

{
    BOOLEAN PrevValue = InbvDisplayDebugStrings;

    InbvDisplayDebugStrings = bEnable;

    return PrevValue;
}


BOOLEAN
InbvIsBootDriverInstalled(
    VOID
    )

/*++

Routine Description:

    This routine allows a component to determine if the gui boot
    driver is in use.

--*/

{
    return InbvBootDriverInstalled;
}

BOOLEAN
InbvResetDisplay(
    )

/*++

Routine Description:

    This routine will reset the display from text mode to a
    supported graphics mode.

Notes:

    This routine expects the display to be in text mode when called.

--*/

{
    if (InbvBootDriverInstalled && (InbvDisplayState == INBV_DISPLAY_STATE_OWNED)) {
        VidResetDisplay(TRUE);
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
InbvScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows for copying portions of video memory into system
    memory.

Arguments:

    Buffer - Location in which to place the video image.

    x, y - X and Y coordinates of top-left corner of image.

    width, height - The width and height of the image in pixels.

    lDelta - width of the buffer in bytes

Notes:

    This routine does not automatically acquire the device lock, so
    the caller must call InbvAquireLock or InbvTestLock to acquire
    the device lock.

--*/

{
    if (InbvBootDriverInstalled && (InbvDisplayState == INBV_DISPLAY_STATE_OWNED)) {
        VidScreenToBufferBlt(Buffer, x, y, width, height, lDelta);
    }
}

VOID
InbvBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows for copying previously saved portions of video
    memory back to the screen.

Arguments:

    Buffer - Location in which to place the video image.

    x, y - X and Y coordinates of top-left corner of image.

    width, height - The width and height of the image in pixels.

    lDelta - width of the buffer in bytes

Notes:

    This routine does not automatically acquire the device lock, so
    the caller must call InbvAquireLock or InbvTestLock to acquire
    the device lock.

--*/

{
    if (InbvBootDriverInstalled && (InbvDisplayState == INBV_DISPLAY_STATE_OWNED)) {
        VidBufferToScreenBlt(Buffer, x, y, width, height, lDelta);
    }
}

VOID
InbvBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    )

/*++

Routine Description:

    This routine blts the bitmap described in 'Buffer' to the location
    x and y on the screen.

Arguments:

    Buffer - points to a bitmap (in the same format as stored on disk).

    x, y - the upper left corner at which the bitmap will be drawn.

--*/

{
    if (InbvBootDriverInstalled && (InbvDisplayState == INBV_DISPLAY_STATE_OWNED)) {
        InbvAcquireLock();
        VidBitBlt(Buffer, x, y);
        InbvReleaseLock();
    }
}

VOID
InbvSolidColorFill(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2,
    ULONG color
    )

/*++

Routine Description:

    This routine fills a rectangular portion of the screen with a
    given color.

--*/

{
    ULONG x, y;
    HEADLESS_CMD_SET_COLOR HeadlessCmd;
    
    if (InbvDisplayState == INBV_DISPLAY_STATE_OWNED) {
        InbvAcquireLock();

        if (InbvBootDriverInstalled) {
            VidSolidColorFill(x1, y1, x2, y2, color);
        }
        
        //
        // Now fill in the area on the terminal
        //
        
        InbvTerminalBkgdColor = HEADLESS_TERM_DEFAULT_BKGD_COLOR;
        
        HeadlessCmd.FgColor = InbvTerminalTextColor;
        HeadlessCmd.BkgColor = InbvTerminalBkgdColor;
        HeadlessDispatch(HeadlessCmdSetColor,
                         &HeadlessCmd,
                         sizeof(HEADLESS_CMD_SET_COLOR),
                         NULL,
                         NULL
                        );
              
        //
        // All block fills come in as if on VGA (640x480).  The terminal is only 24x80
        // so just assume it is full screen reset for now. This works because the only
        // thing enables terminal output is KeBugCheckEx(), which does a full screen fill.
        //
        HeadlessDispatch(HeadlessCmdClearDisplay, NULL, 0, NULL, NULL);
        
        InbvReleaseLock();
    }
}

ULONG
InbvSetTextColor(
    ULONG Color
    )

/*++

Routine Description:

    Sets the text color used when dislaying text.

Arguments:

    Color - the new text color.

Returns:

    The previous text color.

--*/

{
    HEADLESS_CMD_SET_COLOR HeadlessCmd;

    InbvTerminalTextColor = HEADLESS_TERM_DEFAULT_TEXT_COLOR;
    
    HeadlessCmd.FgColor = InbvTerminalTextColor;
    HeadlessCmd.BkgColor = InbvTerminalBkgdColor;
    HeadlessDispatch(HeadlessCmdSetColor,
                     &HeadlessCmd,
                     sizeof(HEADLESS_CMD_SET_COLOR),
                     NULL,
                     NULL
                    );

    return VidSetTextColor(Color);
}

VOID
InbvInstallDisplayStringFilter(
    INBV_DISPLAY_STRING_FILTER DisplayFilter
    )

/*++

--*/

{
    InbvDisplayFilter = DisplayFilter;
}

BOOLEAN
InbvDisplayString(
    PUCHAR Str
    )

/*++

Routine Description:

    This routine displays a string on the screen.

Arguments:

    Str - The string to be displayed.

--*/

{
    PUCHAR *String = &Str;

    if (InbvDisplayState == INBV_DISPLAY_STATE_OWNED) {

        if (InbvDisplayDebugStrings) {

        if (InbvDisplayFilter) {
            InbvDisplayFilter(String);
        }

        
            InbvAcquireLock();
            
            if (InbvBootDriverInstalled) {
                VidDisplayString(*String);
            }
            
        //
        // Since the command structure is exactly a string, we can do this. The
        // ASSERT() will catch if this ever changes.  If it does change, then
        // we will need to allocate a structure, or have one pre-allocated, for
        // filling in and copying over the string.
        //
        ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0); 
        
        HeadlessDispatch(HeadlessCmdPutString,
                         *String,
                         strlen(*String) + sizeof(UCHAR),
                         NULL,
                         NULL
                        );
        
        
            InbvReleaseLock();
        }

        return TRUE;

    } else {

        return FALSE;
    }
}

#define PROGRESS_BAR_TICK_WIDTH    9
#define PROGRESS_BAR_TICK_HEIGHT   8
#define PROGRESS_BAR_TICKS        18
#define PROGRESS_BAR_COLOR        11

VOID
InbvSetProgressBarCoordinates(
    ULONG x,
    ULONG y
    )

/*++

Routine Description:

    This routine sets the upper left coordinate of the progress bar.

Arguments:

    x, y - upper left coordinate of progress bar.

--*/

{
    ProgressBarLeft = x;
    ProgressBarTop  = y;
    ShowProgressBar = TRUE;
}

VOID
InbvUpdateProgressBar(
    ULONG Percentage
    )

/*++

Routine Description:

    This routine is called by the system during startup to update
    the status bar displayed on the gui boot screen.

--*/

{
    int i, Ticks;

    if (ShowProgressBar && InbvBootDriverInstalled && (InbvDisplayState == INBV_DISPLAY_STATE_OWNED)) {

        //
        // Draw the ticks for the current percentage
        //

        //
        // The following calculations are biased by 100 do that 
        // InbvProgressState.Bias can be expressed as an integer fraction.
        //

        Ticks =  Percentage * InbvProgressState.Bias;
        Ticks += InbvProgressState.Floor;
        Ticks *= PROGRESS_BAR_TICKS;
        Ticks /= 10000;

        for (i=0; i<Ticks; i++) {
            InbvAcquireLock();
            VidSolidColorFill(ProgressBarLeft + (i * PROGRESS_BAR_TICK_WIDTH),
                              ProgressBarTop,
                              ProgressBarLeft + ((i + 1) * PROGRESS_BAR_TICK_WIDTH) - 2,
                              ProgressBarTop + PROGRESS_BAR_TICK_HEIGHT - 1,
                              PROGRESS_BAR_COLOR);
            InbvReleaseLock();
        }

    }
}

VOID
InbvSetProgressBarSubset(
    ULONG   Floor,
    ULONG   Ceiling
    )

/*++

Routine Description:

    Sets floor and ceiling for subsequent calls to InbvUpdateProgressBar.
    While a floor and ceiling are in effect, a caller's 100% is a
    percentage of this range.   If floor and ceiling are zero, the
    entire range is used.

Arguments:

    Floor   Lower limit of the subset.
    Ceiling Upper limit of the subset.

Return Value:

    None.

--*/

{
    ASSERT(Floor < Ceiling);
    ASSERT(Ceiling <= 100);

    InbvProgressState.Floor = Floor * 100;
    InbvProgressState.Ceiling = Ceiling * 100;
    InbvProgressState.Bias = (Ceiling - Floor);
}

VOID
InbvIndicateProgress(
    VOID
    )

/*++

Routine Description:

    This routine is called to indicate that progress is being 
    made.  The number of calls is counted and compared to the
    expected number of calls, the boot progress bar is updated
    apropriately.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Percentage;

    InbvProgressIndicator.Count++;

    //
    // Calculate how far along we think we are.
    //

    Percentage = (InbvProgressIndicator.Count * 100) /
                  InbvProgressIndicator.Expected;

    //
    // The Expected number of calls can vary from boot to boot
    // but should remain relatively constant.  Allow for the
    // possibility we were called more than we expected to be.
    // (The progress bar simply stalls at this point).
    //

    if (Percentage > 99) {
        Percentage = 99;
    }

    //
    // See if the progress bar should be updated.
    //

    if (Percentage != InbvProgressIndicator.Percentage) {
        InbvProgressIndicator.Percentage = Percentage;
        InbvUpdateProgressBar(Percentage);
    }
}

PUCHAR
FindBitmapResource(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR ResourceIdentifier
    )

/*++

Routine Description:

    Gets a pointer to the bitmap image compiled into this binary, 
        if one exists. 

Arguments:

    LoaderBlock - Used in obtaining the bitmap resource
    ResourceIdentifier - Identifier for the resource to return the address for

Return Value:

    Pointer to bitmap resource, if successful.  NULL otherwise.

--*/

{
    NTSTATUS                   Status;
    PLIST_ENTRY                Entry;
    PKLDR_DATA_TABLE_ENTRY      DataTableEntry;
    ULONG_PTR                   ResourceIdPath[3];
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    PUCHAR                     Bitmap;
    UNICODE_STRING             KernelString1;
    UNICODE_STRING             KernelString2;

    RtlInitUnicodeString(&KernelString1, L"NTOSKRNL.EXE");
    RtlInitUnicodeString(&KernelString2, L"NTKRNLMP.EXE");

    //
    // Find our loader block entry
    //

    Entry = LoaderBlock->LoadOrderListHead.Flink;
    while (Entry != &LoaderBlock->LoadOrderListHead) {
    
        //
        // Get the address of the data table entry for this component.
        //
        
        DataTableEntry = CONTAINING_RECORD(Entry,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);

        //
        // Case-insensitive comparison with "NTOSKRNL.EXE" and "NTKRNLMP.EXE"
        //

        if (RtlEqualUnicodeString(&DataTableEntry->BaseDllName, 
                                  &KernelString1,
                                  TRUE) == TRUE) {
            break;
        }

        if (RtlEqualUnicodeString(&DataTableEntry->BaseDllName, 
                                  &KernelString2,
                                  TRUE) == TRUE) {
            break;
        }

        Entry = Entry->Flink;
    }

    //
    // If we couldn't find ntoskrnl in the loader list, give up
    //

    if (Entry == &LoaderBlock->LoadOrderListHead) {
        return NULL;
    }

    ResourceIdPath[0] = 2;  // RT_BITMAP = 2
    ResourceIdPath[1] = ResourceIdentifier;
    ResourceIdPath[2] = 0;  // ??

    Status = LdrFindResource_U( DataTableEntry->DllBase,
                                ResourceIdPath,
                                3,
                                (VOID *) &ResourceDataEntry );

    if (!NT_SUCCESS(Status)) {
        return NULL;
    }

    Status = LdrAccessResource( DataTableEntry->DllBase,
                                ResourceDataEntry,
                                &Bitmap,
                                NULL );
    if (!NT_SUCCESS(Status)) {
        return NULL;
    }
    
    return Bitmap;
}

PUCHAR
InbvGetResourceAddress(
    IN ULONG ResourceNumber
    )

/*++

Routine Description:

    This routine returns the cached resources address for a given
    resource.

--*/

{
    if (ResourceNumber <= ResourceCount) {
        return ResourceList[ResourceNumber-1];
    } else {
        return NULL;
    }
}

BOOLEAN
InbvDriverInitialize(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    ULONG Count
    )

/*++

Routine Description:

    This routine will call into the graphical boot driver and give the
    driver a chance to initialize.  At this point, the boot driver
    should determine whether it can run on the hardware in the machine.

--*/

{
    ULONG i;
    ULONG_PTR p;
    PCHAR Options;
    BOOLEAN DispModeChange = FALSE;

    //
    // Only do this once.
    //

    if (InbvBootDriverInstalled == TRUE) {
        return TRUE;
    }

    KeInitializeSpinLock(&BootDriverLock);

    if (InbvDisplayState == INBV_DISPLAY_STATE_OWNED) {

        Options = LoaderBlock->LoadOptions ? _strupr(LoaderBlock->LoadOptions) : NULL;

        if (Options) {
            DispModeChange = (BOOLEAN)(strstr(Options, "BOOTLOGO") == NULL);
        } else {
            DispModeChange = TRUE;
        }
    }

    InbvBootDriverInstalled = VidInitialize(DispModeChange);

    if (InbvBootDriverInstalled == FALSE) {
        return FALSE;
    }

    ResourceCount = Count;

    for (i=1; i<=Count; i++) {
        p = (ULONG_PTR) i;
        ResourceList[i-1] = FindBitmapResource(LoaderBlock, p);
    }

    //
    // Set prograss bar to full range.
    //

    InbvSetProgressBarSubset(0, 100);

    return InbvBootDriverInstalled;
}

VOID
InbvNotifyDisplayOwnershipLost(
    INBV_RESET_DISPLAY_PARAMETERS ResetDisplayParameters
    )

/*++

Routine Description:

    This routine is called by the hal when the hal looses
    display ownership.  At this point win32k.sys has taken
    over.

--*/

{
    if (InbvBootDriverInstalled) {

        //
        // We can only wait for our lock, and execute our clean up code
        // if the driver is installed and we still own the display.
        //

        InbvAcquireLock();
        if (InbvDisplayState != INBV_DISPLAY_STATE_LOST) {
            VidCleanUp();
        }
        InbvDisplayState = INBV_DISPLAY_STATE_LOST;
        InbvResetDisplayParameters = ResetDisplayParameters;
        InbvReleaseLock();

    } else {

        InbvDisplayState = INBV_DISPLAY_STATE_LOST;
        InbvResetDisplayParameters = ResetDisplayParameters;
    }
}

VOID
InbvAcquireDisplayOwnership(
    VOID
    )

/*++

Routine Description:

    Allows the kernel to reaquire ownership of the display.

--*/

{
    if (InbvResetDisplayParameters && (InbvDisplayState == INBV_DISPLAY_STATE_LOST)) {
        InbvResetDisplayParameters(80,50);
    }

    InbvDisplayState = INBV_DISPLAY_STATE_OWNED;
}

VOID
InbvSetDisplayOwnership(
    BOOLEAN DisplayOwned
    )

/*++

Routine Description:

    This routine allows the kernel to set a display state.  This is useful
    after a hibernate.  At this point win32k will reacquire display ownership
    but will not tell us.

Arguments:

    Whether the display is owned or not.

--*/

{
    if (DisplayOwned) {
        InbvDisplayState = INBV_DISPLAY_STATE_OWNED;
    } else {
        InbvDisplayState = INBV_DISPLAY_STATE_LOST;
    }
}

BOOLEAN
InbvCheckDisplayOwnership(
    VOID
    )

/*++

Routine Description:

    Indicates whether the Hal owns the display.

--*/

{
    return (InbvDisplayState != INBV_DISPLAY_STATE_LOST);
}

INBV_DISPLAY_STATE
InbvGetDisplayState(
    VOID
    )

/*++

Routine Description:

    Indicates whether the Hal owns the display.

--*/

{
    return InbvDisplayState;
}

VOID
InbvSetScrollRegion(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2
    )

/*++

Routine Description:

    Control what portions of the screen are used for text.

Arguments:

    Lines - number of lines of text.

--*/

{
    VidSetScrollRegion(x1, y1, x2, y2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\ntoskrnl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntoskrnl.c

Abstract:

    Test program for the INIT subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support reading/writing from com ports.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "ntos.h"
#include "ntimage.h"
#include <zwapi.h>
#include <ntdddisk.h>
#include <setupblk.h>
#include <fsrtl.h>
#include <ntverp.h>

#include "stdlib.h"
#include "stdio.h"
#include <string.h>

#include <safeboot.h>

#include <inbv.h>
#include <bootvid.h>


//
// Define COM Port registers.
//

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_FCR     0x02            // FIFO Control Register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10            // Break detect
#define COM_FE      0x08            // Framing error
#define COM_PE      0x04            // Parity error
#define COM_OE      0x02            // Overrun error

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_56000    57600
#define BD_115200   115200

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// Status Constants for reading data from comport
//

#define CP_GET_SUCCESS  0
#define CP_GET_NODATA   1
#define CP_GET_ERROR    2

//
// This bit controls the loopback testing mode of the device. Basically
// the outputs are connected to the inputs (and vice versa).
//

#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//

#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//

#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//

#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//

#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//

#define SERIAL_MSR_DCD      0x80

typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

//
// Define wait timeout value.
//

#define TIMEOUT_COUNT 1024 * 200


//
// Define COM Port function prototypes.
//

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    );

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    );

BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    );

UCHAR
CpReadLsr (
    IN PCPPORT Port,
    IN UCHAR Waiting
    );

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    );

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForData,
    BOOLEAN PollOnly
    );

VOID
CpPutByte (
    PCPPORT Port,
    UCHAR Byte
    );

//
// Define debugger port initial state.
//
CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };


//
// We'll use these to fill in some function pointers,
// which in turn will be used to read/write from the
// UART.  We can't simply assign the function pointers
// to point to READ_PORT_UCHAR/READ_REGISTER_UCHAR and
// WRITE_PORT_UCHAR/WRITE_REGISTER_UCHAR, because in
// the case of IA64, some of these functions are macros.
//
// To get around this, build these dummy functions that
// will inturn simply call the correct READ/WRITE functions/macros.
//
UCHAR
MY_READ_PORT_UCHAR( IN PUCHAR Addr )
{
    return( READ_PORT_UCHAR(Addr) );
}

UCHAR
MY_READ_REGISTER_UCHAR( IN PUCHAR Addr )
{
    return( READ_REGISTER_UCHAR(Addr) );
}


VOID
MY_WRITE_PORT_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_PORT_UCHAR(Addr, Value);
}

VOID
MY_WRITE_REGISTER_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_REGISTER_UCHAR(Addr, Value);
}


//
// Routines for reading/writing bytes out to the UART.
// We may redefine these later if we're working on a
// memory mapped I/O device, but for now, default to
// the read/write port UCHAR functions.
//
UCHAR (*READ_UCHAR)( IN PUCHAR Addr ) = MY_READ_PORT_UCHAR;
VOID (*WRITE_UCHAR)( IN PUCHAR Addr, IN UCHAR Value ) = MY_WRITE_PORT_UCHAR;




BOOLEAN
InbvPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress,
    OUT PULONG BlFileId,
    IN BOOLEAN IsMMIOAddress
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.
    
    BlFileId - A place to store a fake file Id, if successful.

    IsMMIOAddress - Indicates whether or not the given PortAddress
                    parameter is in MMIO address space.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{


    
    //
    // we need to handle the case where we're dealing with
    // MMIO space (as opposed to System I/O space).
    //
    if( IsMMIOAddress ) {
        PHYSICAL_ADDRESS    PhysAddr;
        PVOID               MyPtr;

        PhysAddr.QuadPart = (ULONG_PTR)PortAddress;
        MyPtr = MmMapIoSpace(PhysAddr,(1+COM_MSR),FALSE);
        if( !MyPtr ) {
            return FALSE;
        }
        PortAddress = MyPtr;

        READ_UCHAR = MY_READ_REGISTER_UCHAR;
        WRITE_UCHAR = MY_WRITE_REGISTER_UCHAR;

    } else {

        // System IO space.
        READ_UCHAR = MY_READ_PORT_UCHAR;
        WRITE_UCHAR = MY_WRITE_PORT_UCHAR;
    }

    
    
    //
    // If the baud rate is not specified, then default the baud rate to 19.2.
    //

    if (BaudRate == 0) {
        BaudRate = BD_19200;
    }

    //
    // If a port number is not specified, then attempt to use port 2 then
    // port 1. Otherwise, use the specified port.
    //

    if (PortNumber == 0) {
        if (CpDoesPortExist((PUCHAR)COM2_PORT)) {
            PortNumber = 2;
            PortAddress = (PUCHAR)COM2_PORT;

        } else if (CpDoesPortExist((PUCHAR)COM1_PORT)) {
            PortNumber = 1;
            PortAddress = (PUCHAR)COM1_PORT;

        } else {
            return FALSE;
        }

    } else {

        if( PortAddress == NULL ) {

            //
            // The port address wasn't specified.  Guess what it
            // is based on the COM port number.
            //
            switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)0x3f8;
                break;

            case 2:
                PortAddress = (PUCHAR)0x2f8;
                break;

            case 3:
                PortAddress = (PUCHAR)0x3e8;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)0x2e8;
            }
        }
    }

    //
    // Check if the port is already in use.
    //
    if (Port[PortNumber-1].Address != NULL) {
        return FALSE;
    }


    //
    // Initialize the specified port.
    //

    CpInitialize(&(Port[PortNumber-1]),
                 PortAddress,
                 BaudRate);

    *BlFileId = (PortNumber-1);
    return TRUE;
}


BOOLEAN
InbvPortTerminate(
    IN ULONG BlFileId
    )

/*++

Routine Description:

    This functions closes the com port.

Arguments:

    BlFileId - File Id to be stored.

Returned Value:

    TRUE - port was closed successfully.

--*/

{
    //
    // Check if the port is already in use.
    //
    if (Port[BlFileId].Address != NULL) {
        //
        // Do any cleanup necessary here.  Note that we don't require any 
        // cleanup today so this is a NOP.
        //
        NOTHING;
    } 

    Port[BlFileId].Address = NULL;
    return(TRUE);

}





VOID
InbvPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    CpPutByte(&Port[BlFileId], Output);
    
#if 0
    if (Output == '\n') {
        CpPutByte(&(Port[BlFileId]), '\r');       
    }
#endif
}

VOID
InbvPortPutString (
    IN ULONG BlFileId,
    IN PUCHAR Output
    )

/*++

Routine Description:

    Write a string to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data string.

Return Value:

    None.

--*/

{
    if (BlFileId == 0) {
        return;
    }
    
    while (*Output != '\0') {
        InbvPortPutByte(BlFileId, *Output);
        Output++;
    }
}


BOOLEAN
InbvPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    TRUE if successful, else FALSE.

--*/

{
    return (CpGetByte(&(Port[BlFileId]), Input, TRUE, FALSE) == CP_GET_SUCCESS);
}

BOOLEAN
InbvPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    TRUE if there is data waiting, else FALSE.

--*/

{
    CHAR Input;

    return (CpGetByte(&(Port[BlFileId]), &Input, FALSE, TRUE) == CP_GET_SUCCESS);
}

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{

    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    WRITE_UCHAR(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    WRITE_UCHAR(hwport, ier);

    return;
}

VOID
InbvPortEnableFifo(
    IN ULONG    DeviceId,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the 16550 UART.
    Note that the behaviour is undefined for the 16450, but practically,
    this should have no effect.

Arguments:

    DeviceId - Value returned by InbvPortInitialize()
    bEnable  - if TRUE, FIFO is enabled
               if FALSE, FIFO  is disabled

Return Value:

    None

--*/
{

    CpEnableFifo(
        Port[DeviceId].Address,
        bEnable
        );        

}

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the
    UART at the address specified.  If this is a 16550,
    this works.  The behaviour on a 16450 is not defined,
    but practically, there is no effect.

Arguments:

    Address - address of hw port.
    bEnable - if TRUE, FIFO is enabled
              if FALSE, FIFO  is disabled

Return Value:

    None

--*/
{
    //
    // Enable the FIFO in the UART. The behaviour is undefined on the
    // 16450, but practically, it should just ignore the command.
    //
    PUCHAR hwport = Address;
    hwport += COM_FCR;
    WRITE_UCHAR(hwport, bEnable);   // set the FIFO state
}

BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine will attempt to place the port into its
    diagnostic mode.  If it does it will twiddle a bit in
    the modem control register.  If the port exists this
    twiddling should show up in the modem status register.

    NOTE: This routine must be called before the device is
          enabled for interrupts, this includes setting the
          output2 bit in the modem control register.

    This is blatantly stolen from TonyE's code in ntos\dd\serial\serial.c.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.

    FALSE - Port doesn't exist.

--*/

{

    UCHAR OldModemStatus;
    UCHAR ModemStatus;
    BOOLEAN ReturnValue = TRUE;

    //
    // Save the old value of the modem control register.
    //
    OldModemStatus = READ_UCHAR(Address + COM_MCR);

    //
    // Set the port into diagnostic mode.
    //

    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Bang on it again to make sure that all the lower bits
    // are clear.
    //

    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Read the modem status register.  The high for bits should
    // be clear.
    //

    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (ModemStatus & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
                       SERIAL_MSR_RI  | SERIAL_MSR_DCD)) {
        ReturnValue = FALSE;
        goto AllDone;
    }

    //
    // So far so good.  Now turn on OUT1 in the modem control register
    // and this should turn on ring indicator in the modem status register.
    //

    WRITE_UCHAR(Address + COM_MCR, (SERIAL_MCR_OUT1 | SERIAL_MCR_LOOP));
    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (!(ModemStatus & SERIAL_MSR_RI)) {
        ReturnValue = FALSE;
        goto AllDone;
    }

    //
    // Put the modem control back into a clean state.
    //

AllDone:
    WRITE_UCHAR(Address + COM_MCR, OldModemStatus);
    return ReturnValue;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/

{

    static  UCHAR ringflag = 0;
    UCHAR   lsr, msr;

    lsr = READ_UCHAR(Port->Address + COM_LSR);
    if ((lsr & waiting) == 0) {
        msr = READ_UCHAR (Port->Address + COM_MSR);
        ringflag |= (msr & SERIAL_MSR_RI) ? 1 : 2;
        if (ringflag == 3) {

            //
            // The ring indicate line has toggled, use modem control from
            // now on.
            //

            Port->Flags |= PORT_MODEMCONTROL;
        }
    }

    return lsr;
}

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{

    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = READ_UCHAR(hwport);

    lcr |= LC_DLAB;
    WRITE_UCHAR(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    WRITE_UCHAR(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    WRITE_UCHAR(hwport, (UCHAR)(divisorlatch & 0xff));

    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    WRITE_UCHAR(hwport, 3);

    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
    return;
}

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte,
    BOOLEAN PollOnly
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.
        
        PollOnly - flag indicates whether to return immediately, not reading the byte, or not.

    Return Value:

        CP_GET_SUCCESS if data returned, or if data is ready and PollOnly is TRUE.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{

    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //

    if (Port->Address == NULL) {
        return CP_GET_NODATA;
    }

    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);
        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //

            //
            // If we get an overrun error, and there is data ready, we should
            // return the data we have, so we ignore overrun errors.  Reading
            // the LSR clears this bit, so the first read already cleared the
            // overrun error.
            //
            if (lsr & (COM_FE | COM_PE)) {
                *Byte = 0;
                return CP_GET_ERROR;
            }

            if (PollOnly) {
                return CP_GET_SUCCESS;
            }

            //
            // fetch the byte
            //

            *Byte = READ_UCHAR(Port->Address + COM_DAT);
            if (Port->Flags & PORT_MODEMCONTROL) {

                //
                // Using modem control.  If no CD, then skip this byte.
                //

                if ((READ_UCHAR(Port->Address + COM_MSR) & MS_CD) == 0) {
                    continue;
                }
            }

            return CP_GET_SUCCESS;
        }
    }

    CpReadLsr(Port, 0);
    return CP_GET_NODATA;
}

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{

    UCHAR   msr, lsr;

    //
    // If modem control, make sure DSR, CTS and CD are all set before
    // sending any data.
    //

    while ((Port->Flags & PORT_MODEMCONTROL)  &&
           (msr = READ_UCHAR(Port->Address + COM_MSR) & MS_DSRCTSCD) != MS_DSRCTSCD) {

        //
        // If no CD, and there's a charactor ready, eat it
        //

        lsr = CpReadLsr(Port, 0);
        if ((msr & MS_CD) == 0  && (lsr & COM_DATRDY) == COM_DATRDY) {
            READ_UCHAR(Port->Address + COM_DAT);
        }
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    WRITE_UCHAR(Port->Address + COM_DAT, Byte);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\vga.h ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    vga.h

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03b4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03b5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03bA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03bA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x03c0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03c0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x03c1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03c2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03c2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03c3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03c4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03c5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03c6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03c7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03c7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03c8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03c9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03cA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03cC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03cE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03cF  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x03d4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03d5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03dA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03dA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// prototypes
//

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    );

BOOLEAN
VgaIsPresent(
    VOID
    );

#define BI_RLE4 2

#pragma pack(1)

typedef struct _BITMAPFILEHEADER {

    USHORT bfType;
    ULONG bfSize;
    USHORT bfReserved1;
    USHORT bfReserved2;
    ULONG bfOffBits;
} BITMAPFILEHEADER, *PBITMAPFILEHEADER;

typedef struct _BITMAPINFOHEADER {

    ULONG biSize;
    LONG biWidth;
    LONG biHeight;
    USHORT biPlanes;
    USHORT biBitCount;
    ULONG biCompression;
    ULONG biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    ULONG biClrUsed;
    ULONG biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct _RGBQUAD {

    UCHAR rgbBlue;
    UCHAR rgbGreen;
    UCHAR rgbRed;
    UCHAR rgbReserved;
} RGBQUAD, *PRGBQUAD;

#pragma pack()

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    );

VOID
DisplayCharacter(
    UCHAR c,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    );

VOID
DisplayStringXY(
    PUCHAR s,
    ULONG x,
    ULONG y,
    ULONG fore_color,
    ULONG back_color
    );

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    );

VOID
VgaScroll(
    ULONG CharHeight
    );

VOID
PreserveRow(
    ULONG y,
    ULONG CharHeight,
    BOOLEAN bRestore
    );

VOID
SetPaletteEntry(
    ULONG index,
    ULONG RGB
    );

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    );

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    );

VOID
InitializePalette(
    VOID
    );

VOID
WaitForVsync(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\i386\_excptlst.asm ===
page	,132
	title	excptlist - defines some public constants
;***
;Stolen from dllsupp.asm in the CRT's.
;
;*******************************************************************************

; offset, with respect to FS, of pointer to currently active exception handler.
; referenced by compiler generated code for SEH and by _setjmp().

	public	__except_list
__except_list	equ	0

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\pae\makefile.inc ===
$(TARGET_DIRECTORY).prf: ..\up\$(TARGET_DIRECTORY).prf
    copy $** 

!INCLUDE ..\up\makefile.inc

obj\i386\ntkrnlpa.obj: ..\ntoskrnl.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\paemp\makefile.inc ===
$(TARGET_DIRECTORY).prf: ..\mp\$(TARGET_DIRECTORY).prf
    copy $** 

!INCLUDE ..\up\makefile.inc

obj\i386\ntkrpamp.obj: ..\ntoskrnl.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\mp\makefile.inc ===
obj\$(TARGET_DIRECTORY)\ntoskrnl.prf: $(TARGET_DIRECTORY).prf
    copy $(TARGET_DIRECTORY).prf ..\ntkrnlmp.prf

!INCLUDE ..\up\makefile.inc

obj\alpha\ntkrnlmp.obj: ..\ntoskrnl.c

obj\i386\ntkrnlmp.obj: ..\ntoskrnl.c

obj\mips\ntkrnlmp.obj: ..\ntoskrnl.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\up\makefile.inc ===
!if exist($(TARGET_DIRECTORY).inc)
!include $(TARGET_DIRECTORY).inc
!endif

$(O)\$(NTTEST).def: ..\ntoskrnl.src ..\$(TARGET_DIRECTORY)def.src
    copy ..\ntoskrnl.src+..\$(TARGET_DIRECTORY)def.src $(O)\$(NTTEST).pp
    $(TARGET_CPP) -nologo -EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) $(O)\$(NTTEST).pp > $@
    -del $(O)\$(NTTEST).pp

$(NTTEST).prf: $(TARGET_DIRECTORY).prf
    copy $** $@

$(DDK_LIB_PATH)\ntoskrnl.lib : $(O)\$(NTTEST).lib
    $(PUBLISH_CMD) {$**=$@}

$(O)\$(NTTEST).lib $(O)\$(NTTEST).exp: \
!if $(386)
        ..\$(TARGET_DIRECTORY)\excptlst.obj \
        $(PROJECT_LIB_PATH)\sehprolg.obj \
        $(PROJECT_LIB_PATH)\seccook.obj \
        $(PROJECT_LIB_PATH)\loadcfg.obj \
!endif
!if "$(BUILD_PASS)" != "PASS2"
        $(KERNEL_LIBS) \
!endif	
        $(O)\$(NTTEST).def
    -$(LIB_NAME) @<<
$(LINK_LIB_IGNORE_FLAG)
-def:$(O)\$(NTTEST).def
-debugtype:cv
-out:$(@R).lib
-machine:$(MACHINE_TYPE)
$(KERNEL_LIBS)
<<NOKEEP
    -$(LIB_NAME) -out:$(@R).lib @<<
$(@R).lib
!if $(386)
..\$(TARGET_DIRECTORY)\excptlst.obj
$(PROJECT_LIB_PATH)\sehprolg.obj
$(PROJECT_LIB_PATH)\seccook.obj
$(PROJECT_LIB_PATH)\loadcfg.obj
!elseif $(IA64)
$(PROJECT_LIB_PATH)\_memmove.obj
$(PROJECT_LIB_PATH)\_memset.obj
$(PROJECT_LIB_PATH)\_memcpy.obj
!endif
<<NOKEEP

..\init.c: $(SDK_INC_PATH)\ntverp.h

..\ntoskrnl.rc: ..\..\nls\$(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\ioguid.c ===
#include <iop.h>
#undef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY
#include <initguid.h>
#include <diskguid.h>
#include <devguid.h>
#include <ioevent.h>
#include <wdmguid.h>
#include <pnpmgr.h>
#include <pnpsetup.h>
#include <ntddstor.h>
#include <dockintf.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iop.h ===
/*++ BUILD Version: 0002

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iop.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 17-Apr-1989


Revision History:


--*/

#ifndef _IOP_
#define _IOP_

#include "ntos.h"
#include "iopcmn.h"
#include "ioverifier.h"
#include "zwapi.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#if 0
extern ULONG BreakDiskByteOffset;
extern ULONG BreakPfn;

extern ULONG IoDeviceHandlerObjectSize;



#if defined(REMOTE_BOOT)
VOID
IopShutdownCsc (
    VOID
    );
#endif

//
// dump support routines
//

#endif




#endif // _IOP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iopcmn.h ===
/*++ BUILD Version: 0002

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iop.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 17-Apr-1989


Revision History:


--*/

#ifndef _IOPCMN_
#define _IOPCMN_

//
// This macro returns the pointer to the beginning of the data
// area of KEY_VALUE_FULL_INFORMATION structure.
// In the macro, k is a pointer to KEY_VALUE_FULL_INFORMATION structure.
//

#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

#define ALIGN_POINTER(Offset) (PVOID) \
        ((((ULONG_PTR)(Offset) + sizeof(ULONG_PTR)-1)) & (~(sizeof(ULONG_PTR) - 1)))

#define ALIGN_POINTER_OFFSET(Offset) (ULONG_PTR) ALIGN_POINTER(Offset)

//
// IO manager exports to Driver Verifier
//
NTSTATUS
IopInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

extern POBJECT_TYPE IoDeviceObjectType;

#include "pnpmgr\pplastgood.h"

//++
//
// VOID
// IopInitializeIrp(
//     IN OUT PIRP Irp,
//     IN USHORT PacketSize,
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Initializes an IRP.
//
// Arguments:
//
//     Irp - a pointer to the IRP to initialize.
//
//     PacketSize - length, in bytes, of the IRP.
//
//     StackSize - Number of stack locations in the IRP.
//
// Return Value:
//
//     None.
//
//--

#define IopInitializeIrp( Irp, PacketSize, StackSize ) {          \
    RtlZeroMemory( (Irp), (PacketSize) );                         \
    (Irp)->Type = (CSHORT) IO_TYPE_IRP;                           \
    (Irp)->Size = (USHORT) ((PacketSize));                        \
    (Irp)->StackCount = (CCHAR) ((StackSize));                    \
    (Irp)->CurrentLocation = (CCHAR) ((StackSize) + 1);           \
    (Irp)->ApcEnvironment = KeGetCurrentApcEnvironment();         \
    InitializeListHead (&(Irp)->ThreadListEntry);                 \
    (Irp)->Tail.Overlay.CurrentStackLocation =                    \
        ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +                  \
            sizeof( IRP ) +                                       \
            ( (StackSize) * sizeof( IO_STACK_LOCATION )))); }

//
// IO manager exports to PNP
//

BOOLEAN
IopCallBootDriverReinitializationRoutines(
    );

BOOLEAN
IopCallDriverReinitializationRoutines(
    );

VOID
IopCreateArcNames(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

PSECURITY_DESCRIPTOR
IopCreateDefaultDeviceSecurityDescriptor(
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN DeviceHasName,
    IN PUCHAR Buffer,
    OUT PACL *AllocatedAcl,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    );

NTSTATUS
IopGetDriverNameFromKeyNode(
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING DriverName
    );

NTSTATUS
IopGetRegistryKeyInformation(
    IN HANDLE KeyHandle,
    OUT PKEY_FULL_INFORMATION *Information
    );

NTSTATUS
IopGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    );

NTSTATUS
IopInitializeBuiltinDriver(
    IN PUNICODE_STRING DriverName,
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_INITIALIZE DriverInitializeRoutine,
    IN PKLDR_DATA_TABLE_ENTRY TableEntry,
    IN BOOLEAN IsFilter,
    OUT PDRIVER_OBJECT *DriverObject
    );

NTSTATUS
IopInvalidateVolumesForDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
IopIsRemoteBootCard(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PWCHAR HwIds
    );

NTSTATUS
IopLoadDriver(
    IN  HANDLE      KeyHandle,
    IN  BOOLEAN     CheckForSafeBoot,
    IN  BOOLEAN     IsFilter,
    OUT NTSTATUS   *DriverEntryStatus
    );

BOOLEAN
IopMarkBootPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

LOGICAL
IopNotifyPnpWhenChainDereferenced(
    IN PDEVICE_OBJECT *PhysicalDeviceObjects,
    IN ULONG DeviceObjectCount,
    IN BOOLEAN Query,
    OUT PDEVICE_OBJECT *VetoingDevice
    );

VOID
FORCEINLINE
IopQueueThreadIrp(
     IN PIRP Irp
     )
/*++

Routine Description:

    This routine queues the specified I/O Request Packet (IRP) to the thread
    whose TCB address is stored in the packet.

Arguments:

    Irp - Supplies the IRP to be queued for the specified thread.

Return Value:

    None.

--*/
{
    PETHREAD Thread;
    PLIST_ENTRY Head, Entry;

    Thread = Irp->Tail.Overlay.Thread;
    Head = &Thread->IrpList;
    Entry = &Irp->ThreadListEntry;

    KeEnterGuardedRegionThread (&Thread->Tcb);

    InsertHeadList( Head,
                    Entry );

    KeLeaveGuardedRegionThread (&Thread->Tcb);

}

PDRIVER_OBJECT
IopReferenceDriverObjectByName (
    IN PUNICODE_STRING DriverName
    );

BOOLEAN
IopSafebootDriverLoad(
    PUNICODE_STRING DriverId
    );

NTSTATUS
IopSetupRemoteBootCard(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN HANDLE UniqueIdHandle,
    IN PUNICODE_STRING UnicodeDeviceInstance
    );

extern PVOID IopLoaderBlock;
extern POBJECT_TYPE IoDriverObjectType;
extern POBJECT_TYPE IoFileObjectType;


//
// Title Index to set registry key value
//

#define TITLE_INDEX_VALUE 0

//++
//
// VOID
// IopWstrToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PCWSTR p
//     )
//
//--
#define IopWstrToUnicodeString(u, p)                                    \
                                                                        \
    (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    (u)->Buffer = (p)

//
// Remote Boot exports to PNP
//

NTSTATUS
IopStartTcpIpForRemoteBoot (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// Remote Boot exports to IO
//
NTSTATUS
IopAddRemoteBootValuesToRegistry (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
IopStartNetworkForRemoteBoot (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// PNP Manager exports to IO
//

typedef struct _DEVICE_NODE DEVICE_NODE, *PDEVICE_NODE;

VOID
IopChainDereferenceComplete(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN BOOLEAN          OnCleanStack
    );

NTSTATUS
IopCreateRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
IopInitializePlugPlayServices(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG Phase
    );

NTSTATUS
IopOpenRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess
    );

VOID
IopDestroyDeviceNode(
    PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopDriverLoadingFailed(
    IN HANDLE KeyHandle OPTIONAL,
    IN PUNICODE_STRING KeyName OPTIONAL
    );

BOOLEAN
IopInitializeBootDrivers(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PDRIVER_OBJECT *PreviousDriver
    );

BOOLEAN
IopInitializeSystemDrivers(
    VOID
    );

BOOLEAN
IopIsLegacyDriver (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
IopMarkHalDeviceNode(
    VOID
    );

NTSTATUS
IopPrepareDriverLoading(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN BOOLEAN IsFilter
    );

NTSTATUS
IopPnpDriverStarted(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ServiceName
    );

NTSTATUS
IopSynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation,
    OUT PULONG_PTR Information
    );

NTSTATUS
IopUnloadDriver(
    IN PUNICODE_STRING DriverServiceName,
    IN BOOLEAN InvokedByPnpMgr
    );
VOID
IopIncrementDeviceObjectHandleCount(
    IN  PDEVICE_OBJECT  DeviceObject
    );

VOID
IopDecrementDeviceObjectHandleCount(
    IN  PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
IopBuildFullDriverPath(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING FullPath
    );

#endif // _IOPCMN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\ioverifier.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ioverifier.h

Abstract:

    This header contains or includes all the prototypes neccessary for the I/O
    subsystem specific portions of the driver verifier.

Author:

    Adrian J. Oney (adriao) 28-Feb-1999

Revision History:


--*/

#include "..\verifier\vfdef.h"

#ifndef _IOVERIFIER_H_
#define _IOVERIFIER_H_

typedef struct _IOV_INIT_DATA {

    ULONG InitFlags;
    ULONG VerifierFlags;

} IOV_INIT_DATA, *PIOV_INIT_DATA;

#define IOVP_COMPLETE_REQUEST(Apc,Sa1,Sa2)   \
    {   \
        if (IopVerifierOn) \
            IovpCompleteRequest((Apc), (Sa1), (Sa2));   \
    }

#define IOV_INITIALIZE_IRP(Irp, PacketSize, StackSize)   \
    {   \
        if (IopVerifierOn) \
            IovInitializeIrp((Irp), (PacketSize), (StackSize));   \
    }

#define IOV_DELETE_DEVICE(DeviceObject)   \
    {   \
        if (IopVerifierOn) \
            IovDeleteDevice(DeviceObject);   \
    }

#define IOV_DETACH_DEVICE(DeviceObject)   \
    {   \
        if (IopVerifierOn) \
            IovDetachDevice(DeviceObject);   \
    }

#define IOV_ATTACH_DEVICE_TO_DEVICE_STACK(SourceDeviceObject, TargetDeviceObject)   \
    {   \
        if (IopVerifierOn) \
            IovAttachDeviceToDeviceStack((SourceDeviceObject), (TargetDeviceObject));   \
    }

#define IOV_CANCEL_IRP(Irp, ReturnValue) \
        IovCancelIrp((Irp), (ReturnValue))

#define IOV_UNLOAD_DRIVERS() \
    {   \
        if (IopVerifierOn) \
                IovUnloadDrivers (); \
    }

VOID
IovpSpecialIrpVerifierInitWorker(
    IN PVOID Parameter
    );

VOID
IovpCompleteRequest(
    IN PKAPC Apc,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IovInitializeIrp(
    PIRP    Irp,
    USHORT  PacketSize,
    CCHAR   StackSize
    );

VOID
IovAttachDeviceToDeviceStack(
    PDEVICE_OBJECT  SourceDevice,
    PDEVICE_OBJECT  TargetDevice
    );

VOID
IovDeleteDevice(
    PDEVICE_OBJECT  DeleteDevice
    );

VOID
IovDetachDevice(
    PDEVICE_OBJECT  TargetDevice
    );

BOOLEAN
IovCancelIrp(
    PIRP    Irp,
    BOOLEAN *returnValue
    );

NTSTATUS
IovUnloadDrivers (
    VOID);

#endif // _IOVERIFIER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iovutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iovutil.c

Abstract:

    This module implements various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.c

--*/

#include "iop.h"
#include "pnpi.h"
#include "arbiter.h"
#include "dockintf.h"
#include "pnprlist.h"
#include "pnpiop.h"
#include "iovputil.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, IovUtilInit)
//#pragma alloc_text(PAGEVRFY, IovUtilMarkDeviceObject)
//#pragma alloc_text(PAGEVRFY, IovUtilMarkStack)
//#pragma alloc_text(PAGEVRFY, IovUtilWatermarkIrp)

#ifndef NO_VERIFIER
#pragma alloc_text(PAGEVRFY, IovUtilGetLowerDeviceObject)
#pragma alloc_text(PAGEVRFY, IovUtilGetBottomDeviceObject)
#pragma alloc_text(PAGEVRFY, IovUtilGetUpperDeviceObject)
#pragma alloc_text(PAGEVRFY, IovUtilIsVerifiedDeviceStack)
#pragma alloc_text(PAGEVRFY, IovUtilFlushStackCache)
#pragma alloc_text(PAGEVRFY, IovUtilFlushVerifierDriverListCache)
#pragma alloc_text(PAGEVRFY, IovpUtilFlushListCallback)
#pragma alloc_text(PAGEVRFY, IovUtilIsPdo)
#pragma alloc_text(PAGEVRFY, IovUtilIsWdmStack)
#pragma alloc_text(PAGEVRFY, IovUtilHasDispatchHandler)
#pragma alloc_text(PAGEVRFY, IovUtilIsInFdoStack)
#pragma alloc_text(PAGEVRFY, IovUtilIsRawPdo)
#pragma alloc_text(PAGEVRFY, IovUtilIsDesignatedFdo)
#pragma alloc_text(PAGEVRFY, IovUtilIsDeviceObjectMarked)
#endif // NO_VERIFIER

#endif // ALLOC_PRAGMA

//
// This entire implementation is specific to the verifier
//
#ifndef NO_VERIFIER

BOOLEAN IovUtilVerifierEnabled = FALSE;


VOID
FASTCALL
IovUtilInit(
    VOID
    )
{
    IovUtilVerifierEnabled = TRUE;
}


VOID
FASTCALL
IovUtilGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  UpperDeviceObject,
    OUT PDEVICE_OBJECT  *LowerDeviceObject
    )
/*++

Routine Description:

    This routine returns the device object below the passed in parameter. In
    other words, it is the inverse of DeviceObject->AttachedDevice. Note that
    the returned device object is referenced by this routine.

Arguments:

    UpperDeviceObject   - Device object to look beneath.
    LowerDeviceObject   - Receives device object beneath UpperDeviceObject, or
                          NULL if none.

Return Value:

    None.

--*/
{
    PDEVOBJ_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceAttachedTo;
    KIRQL               irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    deviceExtension = UpperDeviceObject->DeviceObjectExtension;
    deviceAttachedTo = deviceExtension->AttachedTo;

    if (deviceAttachedTo) {

        ObReferenceObject(deviceAttachedTo);
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    *LowerDeviceObject = deviceAttachedTo;
}


VOID
FASTCALL
IovUtilGetBottomDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PDEVICE_OBJECT  *BottomDeviceObject
    )
/*++

Routine Description:

    This routine returns the device object at the bottom of the stack in which
    the passed in parameter is a member. In other words, it is the inverse of
    IoGetAttachedDeviceReference. Note that the returned device object is
    referenced by this routine.

Arguments:

    DeviceObject        - Device object to examine.
    BottomDeviceObject  - Receives device object at the bottom of DeviceObject's
                          stack, NULL if none.

Return Value:

    None.

--*/
{
    PDEVOBJ_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      lowerDeviceObject, deviceAttachedTo;
    KIRQL               irql;

    deviceAttachedTo = DeviceObject;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    do {
        lowerDeviceObject = deviceAttachedTo;
        deviceExtension = lowerDeviceObject->DeviceObjectExtension;
        deviceAttachedTo = deviceExtension->AttachedTo;

    } while ( deviceAttachedTo );

    ObReferenceObject(lowerDeviceObject);

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    *BottomDeviceObject = lowerDeviceObject;
}


VOID
FASTCALL
IovUtilGetUpperDeviceObject(
    IN  PDEVICE_OBJECT  LowerDeviceObject,
    OUT PDEVICE_OBJECT  *UpperDeviceObject
    )
/*++

Routine Description:

    This routine returns the device object above the passed in parameter. In
    other words, it retrieves DeviceObject->AttachedDevice under the database
    lock.. Note that the returned device object is referenced by this routine.

Arguments:

    LowerDeviceObject   - Device object to look above.
    UpperDeviceObject   - Receives device object above LowerDeviceObject, or
                          NULL if none.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT      deviceAbove;
    KIRQL               irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    deviceAbove = LowerDeviceObject->AttachedDevice;
    if (deviceAbove) {

        ObReferenceObject(deviceAbove);
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    *UpperDeviceObject = deviceAbove;
}


BOOLEAN
FASTCALL
IovUtilIsVerifiedDeviceStack(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine determines whether a device object in the stack is marked for
    verification.

Arguments:

    DeviceObject        - Device object to examine.

Return Value:

    TRUE if at least one device object in the stack is marked for verification,
    FALSE otherwise.

--*/
{
    PDEVOBJ_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      currentDevObj, deviceAttachedTo;
    BOOLEAN             stackIsInteresting;
    KIRQL               irql;

    //
    // Quickly check the cached result stored on the device object...
    //
    if (DeviceObject->DeviceObjectExtension->ExtensionFlags & DOV_EXAMINED) {

        stackIsInteresting =
           ((DeviceObject->DeviceObjectExtension->ExtensionFlags & DOV_TRACKED) != 0);

        return stackIsInteresting;
    }

    //
    // Walk the entire stack and update everything appropriately.
    //
    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    stackIsInteresting = FALSE;
    deviceAttachedTo = DeviceObject;
    do {
        currentDevObj = deviceAttachedTo;
        deviceExtension = currentDevObj->DeviceObjectExtension;
        deviceAttachedTo = deviceExtension->AttachedTo;

        //
        // Remember this...
        //
        if (MmIsDriverVerifying(currentDevObj->DriverObject)) {

            stackIsInteresting = TRUE;
        }

    } while (deviceAttachedTo &&
             (!(deviceAttachedTo->DeviceObjectExtension->ExtensionFlags & DOV_EXAMINED))
            );

    if (deviceAttachedTo &&
        (deviceAttachedTo->DeviceObjectExtension->ExtensionFlags & DOV_TRACKED)) {

        //
        // Propogate upwards the "interesting-ness" of the last examined device
        // in the stack...
        //
        stackIsInteresting = TRUE;
    }

    //
    // Walk upwards, marking everything examined and appropriately tracked.
    //
    do {
        deviceExtension = currentDevObj->DeviceObjectExtension;

        if (stackIsInteresting) {

            deviceExtension->ExtensionFlags |= DOV_TRACKED;

        } else {

            deviceExtension->ExtensionFlags &=~ DOV_TRACKED;
        }

        deviceExtension->ExtensionFlags |= DOV_EXAMINED;

        currentDevObj = currentDevObj->AttachedDevice;

    } while (currentDevObj);

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return stackIsInteresting;
}


VOID
FASTCALL
IovUtilFlushStackCache(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  DATABASELOCKSTATE   DatabaseLockState
    )
/*++

Routine Description:

    This routine causes the verifier to reexamine the stack of which the given
    device object is a member. This needs to be done whenever the attachment
    chain is updated.

Arguments:

    DeviceObject      - Device that is a member of the stack requiring
                        reexamination.
    DatabaseLockState - Indicates current state of Database lock, either
                        DATABASELOCKSTATE_HELD or DATABASELOCKSTATE_NOT_HELD.
                        If the lock is not held, this routine will acquire and
                        release it.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT      pBottomDeviceObject, pCurrentDeviceObject;
    PDEVOBJ_EXTENSION   deviceExtension;
    KIRQL               irql;

    if (DatabaseLockState == DATABASELOCKSTATE_NOT_HELD) {

        irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    }

    //
    // Walk to the bottom of the stack
    //
    pCurrentDeviceObject = DeviceObject;
    do {
        pBottomDeviceObject = pCurrentDeviceObject;
        deviceExtension = pBottomDeviceObject->DeviceObjectExtension;
        pCurrentDeviceObject = deviceExtension->AttachedTo;

    } while ( pCurrentDeviceObject );

    //
    // Walk back up clearing the appropriate flags.
    //
    pCurrentDeviceObject = pBottomDeviceObject;
    while(pCurrentDeviceObject) {

        deviceExtension = pCurrentDeviceObject->DeviceObjectExtension;
        deviceExtension->ExtensionFlags &= ~(DOV_EXAMINED | DOV_TRACKED);
        pCurrentDeviceObject = pCurrentDeviceObject->AttachedDevice;
    }

    if (DatabaseLockState == DATABASELOCKSTATE_NOT_HELD) {

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }
}


VOID
FASTCALL
IovUtilFlushVerifierDriverListCache(
    VOID
    )
/*++

Routine Description:

    This routine causes the verifier to reexamine all previously examined
    stacks. This is a prerequisite for updating the list of verified drivers.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // We must be called at PASSIVE_LEVEL!
    //
    PAGED_CODE();

    ObEnumerateObjectsByType(
        IoDeviceObjectType,
        IovpUtilFlushListCallback,
        NULL
        );
}


BOOLEAN
IovpUtilFlushListCallback(
    IN PVOID            Object,
    IN PUNICODE_STRING  ObjectName,
    IN ULONG_PTR        HandleCount,
    IN ULONG_PTR        PointerCount,
    IN PVOID            Context
    )
/*++

Routine Description:

    This is a worker routine for IovUtilFlushVerifierDriverListCache. It is
    called on each device object in the system.

Arguments:

    Object          - Device Object enumerated by ObEnumerateObjectsByType.
    ObjectName      - Name of the object
    HandleCount     - Handle count of the object
    PointerCount    - Pointer count of the object
    Context         - Context supplied to ObEnumerateObjectsByType (not used)

Return Value:

    BOOLEAN that indicates whether the enumeration should continue.

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDEVOBJ_EXTENSION   deviceExtension;

    deviceObject = (PDEVICE_OBJECT) Object;
    deviceExtension = deviceObject->DeviceObjectExtension;

    if (PointerCount || HandleCount) {

        deviceExtension->ExtensionFlags &= ~(DOV_EXAMINED | DOV_TRACKED);
    }

    return TRUE;
}


VOID
IovUtilRelateDeviceObjects(
    IN     PDEVICE_OBJECT   FirstDeviceObject,
    IN     PDEVICE_OBJECT   SecondDeviceObject,
    OUT    DEVOBJ_RELATION  *DeviceObjectRelation
    )
/*++

Routine Description:

    This routine determines the relationship between two device objects,
    relative to their stacks.

Arguments:

    FirstDeviceObject - First device object

    SecondDeviceObject - Second device object

    DeviceObjectRelation - Receives stack relationship of device objects:

        DEVOBJ_RELATION_IDENTICAL -
            The two device objects are identical.

        DEVOBJ_RELATION_FIRST_IMMEDIATELY_ABOVE_SECOND -
            The first device object is immediately above the second device
            object in the same stack.

        DEVOBJ_RELATION_FIRST_ABOVE_SECOND -
            The first device object is above the second device object in the
            same stack, but not immediately above.

        DEVOBJ_RELATION_FIRST_IMMEDIATELY_BELOW_SECOND -
            The first device object is immediately below the second device
            object in the same stack.

        DEVOBJ_RELATION_FIRST_BELOW_SECOND -
            The first device object is below the second device object in the
            same stack, but not immediately above.

        DEVOBJ_RELATION_NOT_IN_SAME_STACK -
            The device objects do not belong to the same stack.

Return Value:

    None.

--*/
{
    PDEVOBJ_EXTENSION deviceExtension;
    PDEVICE_OBJECT upperDevobj, lowerDeviceObject, deviceAttachedTo;
    ULONG result;
    KIRQL irql;

    //
    // Try the easiest early out
    //
    if (FirstDeviceObject == SecondDeviceObject) {

        *DeviceObjectRelation = DEVOBJ_RELATION_IDENTICAL;
        return;
    }

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Try the most common early out
    //
    if (FirstDeviceObject == SecondDeviceObject->AttachedDevice){

        *DeviceObjectRelation = DEVOBJ_RELATION_FIRST_IMMEDIATELY_ABOVE_SECOND;
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return;

    } else if (FirstDeviceObject->AttachedDevice == SecondDeviceObject) {

        *DeviceObjectRelation = DEVOBJ_RELATION_FIRST_IMMEDIATELY_BELOW_SECOND;
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return;
    }

    //
    // We'll have to walk a stack. Start by getting the bottom of the first
    // device object.
    //
    deviceAttachedTo = FirstDeviceObject;
    do {
        if (deviceAttachedTo == SecondDeviceObject) {

            break;
        }

        lowerDeviceObject = deviceAttachedTo;
        deviceExtension = lowerDeviceObject->DeviceObjectExtension;
        deviceAttachedTo = deviceExtension->AttachedTo;

    } while ( deviceAttachedTo );

    //
    // If deviceAttachedTo isn't NULL, then we walked down from
    // FirstDeviceObject and found SecondDeviceObject.
    //
    if (deviceAttachedTo) {

        *DeviceObjectRelation = DEVOBJ_RELATION_FIRST_ABOVE_SECOND;
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return;
    }

    //
    // Now try walking *up* FirstDeviceObject and see if we find
    // SecondDeviceObject.
    //
    upperDevobj = FirstDeviceObject->AttachedDevice;
    while(upperDevobj && (upperDevobj != SecondDeviceObject)) {

        upperDevobj = upperDevobj->AttachedDevice;
    }

    if (upperDevobj == NULL) {

        *DeviceObjectRelation = DEVOBJ_RELATION_NOT_IN_SAME_STACK;

    } else {

        *DeviceObjectRelation = DEVOBJ_RELATION_FIRST_BELOW_SECOND;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
}


BOOLEAN
IovUtilIsPdo(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT possiblePdo;
    BOOLEAN isPdo;

    IovUtilGetBottomDeviceObject(DeviceObject, &possiblePdo);
    if (possiblePdo != DeviceObject) {

        ObDereferenceObject(possiblePdo);
        return FALSE;
    }

    deviceNode = possiblePdo->DeviceObjectExtension->DeviceNode;

    isPdo =
        (deviceNode && (!(deviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)));

    //
    // Free our reference.
    //
    ObDereferenceObject(possiblePdo);

    return isPdo;
}


BOOLEAN
IovUtilIsWdmStack(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT possiblePdo;
    BOOLEAN isWdmStack;

    IovUtilGetBottomDeviceObject(DeviceObject, &possiblePdo);

    deviceNode = possiblePdo->DeviceObjectExtension->DeviceNode;

    isWdmStack =
        (deviceNode && (!(deviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)));

    //
    // Free our reference.
    //
    ObDereferenceObject(possiblePdo);

    return isWdmStack;
}


BOOLEAN
FASTCALL
IovUtilHasDispatchHandler(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  UCHAR           MajorFunction
    )
{
    return (DriverObject->MajorFunction[MajorFunction] != IopInvalidDeviceRequest);
}


BOOLEAN
FASTCALL
IovUtilIsInFdoStack(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVOBJ_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceAttachedTo, lowerDevobj;
    KIRQL irql;

    deviceAttachedTo = DeviceObject;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    do {

        if (IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_BOTTOM_OF_FDO_STACK)) {

            break;
        }

        deviceAttachedTo = deviceAttachedTo->DeviceObjectExtension->AttachedTo;

    } while ( deviceAttachedTo );

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return (deviceAttachedTo != NULL);
}


BOOLEAN
FASTCALL
IovUtilIsRawPdo(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    return IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_RAW_PDO);
}


BOOLEAN
FASTCALL
IovUtilIsDesignatedFdo(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    return IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DESIGNATED_FDO);
}


VOID
FASTCALL
IovUtilMarkDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  MARK_TYPE       MarkType
    )
{
    PULONG extensionFlags;

    if (!IovUtilVerifierEnabled) {

        return;
    }

    extensionFlags = &DeviceObject->DeviceObjectExtension->ExtensionFlags;

    switch(MarkType) {

        case MARKTYPE_DELETED:
            *extensionFlags |= DOV_DELETED;
            break;

        case MARKTYPE_BOTTOM_OF_FDO_STACK:
            *extensionFlags |= DOV_BOTTOM_OF_FDO_STACK;
            break;

        case MARKTYPE_DESIGNATED_FDO:
            *extensionFlags |= DOV_DESIGNATED_FDO;
            break;

        case MARKTYPE_RAW_PDO:
            *extensionFlags |= DOV_RAW_PDO;
            break;

        case MARKTYPE_DEVICE_CHECKED:
            *extensionFlags |= DOV_FLAGS_CHECKED;
            break;

        case MARKTYPE_RELATION_PDO_EXAMINED:
            *extensionFlags |= DOV_FLAGS_RELATION_EXAMINED;
            break;

        default:
            ASSERT(0);
            break;
    }
}


BOOLEAN
FASTCALL
IovUtilIsDeviceObjectMarked(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  MARK_TYPE       MarkType
    )
{
    ULONG extensionFlags;

    extensionFlags = DeviceObject->DeviceObjectExtension->ExtensionFlags;

    switch(MarkType) {

        case MARKTYPE_DELETED:
            return ((extensionFlags & DOV_DELETED) != 0);

        case MARKTYPE_BOTTOM_OF_FDO_STACK:
            return ((extensionFlags & DOV_BOTTOM_OF_FDO_STACK) != 0);

        case MARKTYPE_DESIGNATED_FDO:
            return ((extensionFlags & DOV_DESIGNATED_FDO) != 0);

        case MARKTYPE_RAW_PDO:
            return ((extensionFlags & DOV_RAW_PDO) != 0);

        case MARKTYPE_DEVICE_CHECKED:
            return ((extensionFlags & DOV_FLAGS_CHECKED) != 0);

        case MARKTYPE_RELATION_PDO_EXAMINED:
            return ((extensionFlags & DOV_FLAGS_RELATION_EXAMINED) != 0);

        default:
            ASSERT(0);
            return FALSE;
    }
}


VOID
FASTCALL
IovUtilMarkStack(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  PDEVICE_OBJECT  BottomOfFdoStack        OPTIONAL,
    IN  PDEVICE_OBJECT  FunctionalDeviceObject  OPTIONAL,
    IN  BOOLEAN         RawStack
    )
/*++

  Description:

    This routine marks device objects in a PnP stack appropriately. It is
    called by AddDevice once the stack is properly constructed.

  Arguments:

     PhysicalDeviceObject - Device object at the bottom of the PnP stack.

     BottomOfFdoStack - First device object added during AddDevice. Below this
                        device object is either a bus filter or the PDO itself.

     FunctionalDeviceObject - Specifies the device object as identified in the
                              service branch. This should be NULL if the devnode
                              is raw and no overriding service was specified.

     RawStack - True if stack was marked raw.

  Return Value:

     None.

--*/
{
    PDEVICE_OBJECT trueFunctionalDeviceObject;

    if (BottomOfFdoStack) {

        IovUtilMarkDeviceObject(BottomOfFdoStack, MARKTYPE_BOTTOM_OF_FDO_STACK);
    }

    if (FunctionalDeviceObject) {

        trueFunctionalDeviceObject = FunctionalDeviceObject;

        if (IovUtilVerifierEnabled) {

            VfDevObjAdjustFdoForVerifierFilters(&trueFunctionalDeviceObject);
        }

        IovUtilMarkDeviceObject(trueFunctionalDeviceObject, MARKTYPE_DESIGNATED_FDO);

    } else if (RawStack) {

        IovUtilMarkDeviceObject(PhysicalDeviceObject, MARKTYPE_DESIGNATED_FDO);
        IovUtilMarkDeviceObject(PhysicalDeviceObject, MARKTYPE_RAW_PDO);
    }
}


VOID
FASTCALL
IovUtilWatermarkIrp(
    IN PIRP  Irp,
    IN ULONG Flags
    )
{
    if (IovUtilVerifierEnabled) {

        VfIrpWatermark(Irp, Flags);
    }
}


#else // NO_VERIFIER

//
// The code below should be built into a future stub that deadens out IO
// support for the verifier.
//

VOID
FASTCALL
IovUtilInit(
    VOID
    )
{
}


VOID
FASTCALL
IovUtilMarkDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  MARK_TYPE       MarkType
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(MarkType);
}


VOID
FASTCALL
IovUtilMarkStack(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  PDEVICE_OBJECT  BottomOfFdoStack        OPTIONAL,
    IN  PDEVICE_OBJECT  FunctionalDeviceObject  OPTIONAL,
    IN  BOOLEAN         RawStack
    )
{
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);
    UNREFERENCED_PARAMETER(BottomOfFdoStack);
    UNREFERENCED_PARAMETER(FunctionalDeviceObject);
    UNREFERENCED_PARAMETER(RawStack);
}


VOID
FASTCALL
IovUtilWatermarkIrp(
    IN PIRP  Irp,
    IN ULONG Flags
    )
{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Flags);
}


#endif // NO_VERIFIER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iovputil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iovputil.h

Abstract:

    This header contains the private declarations need for various driver
    verification utilities. It should be included by iovutil.c only!

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.h

--*/

//
// These must coexist with the DOE_ flags.
//
#define DOV_EXAMINED                   0x80000000
#define DOV_TRACKED                    0x40000000
#define DOV_DESIGNATED_FDO             0x20000000
#define DOV_BOTTOM_OF_FDO_STACK        0x10000000
#define DOV_RAW_PDO                    0x08000000
#define DOV_DELETED                    0x04000000
#define DOV_FLAGS_CHECKED              0x02000000
#define DOV_FLAGS_RELATION_EXAMINED    0x01000000

BOOLEAN
IovpUtilFlushListCallback(
    IN PVOID            Object,
    IN PUNICODE_STRING  ObjectName,
    IN ULONG_PTR        HandleCount,
    IN ULONG_PTR        PointerCount,
    IN PVOID            Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\netboot.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netboot.c

Abstract:

    This module contains the code to initialize network boot.

Author:

    Chuck Lenzmeier (chuckl) December 27, 1996

Environment:

    Kernel mode, system initialization code

Revision History:

    Colin Watson (colinw) November 1997 Add CSC support

--*/

#include "iop.h"
#pragma hdrstop

#include <regstrp.h>

#include <ntddip.h>
#include <nbtioctl.h>
#include <ntddnfs.h>
#include <ntddbrow.h>
#include <ntddtcp.h>
#include <setupblk.h>
#include <remboot.h>
#ifdef ALLOC_DATA_PRAGMA
#pragma  const_seg("INITCONST")
#endif
#include <oscpkt.h>
#include <windef.h>
#include <tdiinfo.h>

#ifndef NT
#define NT
#include <ipinfo.h>
#undef NT
#else
#include <ipinfo.h>
#endif

#include <devguid.h>

extern BOOLEAN ExpInTextModeSetup;

BOOLEAN IopRemoteBootCardInitialized = FALSE;


//
// TCP/IP definitions
//

#define DEFAULT_DEST                    0
#define DEFAULT_DEST_MASK               0
#define DEFAULT_METRIC                  1

NTSTATUS
IopWriteIpAddressToRegistry(
        HANDLE handle,
        PWCHAR regkey,
        PUCHAR value
        );

NTSTATUS
IopTCPQueryInformationEx(
    IN HANDLE                 TCPHandle,
    IN TDIObjectID FAR       *ID,
    OUT void FAR             *Buffer,
    IN OUT DWORD FAR         *BufferSize,
    IN OUT BYTE FAR          *Context
    );

NTSTATUS
IopTCPSetInformationEx(
    IN HANDLE             TCPHandle,
    IN TDIObjectID FAR   *ID,
    IN void FAR          *Buffer,
    IN DWORD FAR          BufferSize
    );

NTSTATUS
IopSetDefaultGateway(
    IN ULONG GatewayAddress
    );

NTSTATUS
IopCacheNetbiosNameForIpAddress(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
IopAssignNetworkDriveLetter (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


//
// The following allows the I/O system's initialization routines to be
// paged out of memory.
//

#ifdef ALLOC_PRAGMA
__inline long
htonl(long x);
#pragma alloc_text(INIT,IopAddRemoteBootValuesToRegistry)
#pragma alloc_text(INIT,IopStartNetworkForRemoteBoot)
#pragma alloc_text(INIT,IopStartTcpIpForRemoteBoot)
#pragma alloc_text(INIT,IopIsRemoteBootCard)
#pragma alloc_text(INIT,IopSetupRemoteBootCard)
#pragma alloc_text(INIT,IopAssignNetworkDriveLetter)
#pragma alloc_text(INIT,IopWriteIpAddressToRegistry)
#pragma alloc_text(INIT,IopSetDefaultGateway)
#pragma alloc_text(INIT,htonl)
#pragma alloc_text(INIT,IopCacheNetbiosNameForIpAddress)
#pragma alloc_text(INIT,IopTCPQueryInformationEx)
#pragma alloc_text(INIT,IopTCPSetInformationEx)
#endif


NTSTATUS
IopAddRemoteBootValuesToRegistry (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE handle;
    HANDLE serviceHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING string;
    CHAR addressA[16];
    WCHAR addressW[16];
    STRING addressStringA;
    UNICODE_STRING addressStringW;
    PUCHAR addressPointer;
    PUCHAR p;
    PUCHAR q;
    PUCHAR ntName;
    PWCHAR imagePath;
    STRING ansiString;
    UNICODE_STRING unicodeString;
    UNICODE_STRING dnsNameString;
    UNICODE_STRING netbiosNameString;
    ULONG tmpValue;
    ULONG bufferLength;
    PUCHAR buffer = NULL;

    //
    // allocate a scratch buffer, making it as large as we'll need.
    //
    bufferLength = sizeof("\\Device\\LanmanRedirector") + strlen(LoaderBlock->NtBootPathName);
                        
    if (LoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_TEXTMODE) {
        bufferLength = max(
                        bufferLength, 
                        sizeof("\\Device\\LanmanRedirector") + strlen(LoaderBlock->SetupLoaderBlock->MachineDirectoryPath));
    }
    
    bufferLength = max(
                    bufferLength,
                    sizeof(L"system32\\drivers\\") + wcslen(LoaderBlock->SetupLoaderBlock->NetbootCardDriverName)*sizeof(WCHAR));
    
    buffer = ExAllocatePoolWithTag( NonPagedPool, bufferLength, 'bRoI' );
    if (buffer == NULL) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to allocate buffer\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    
    ntName = buffer;
    imagePath = (PWCHAR)buffer;

    if (LoaderBlock->SetupLoaderBlock->ComputerName[0] != 0) {

        //
        // Convert the name to a Netbios name.
        //

        _wcsupr( LoaderBlock->SetupLoaderBlock->ComputerName );

        RtlInitUnicodeString( &dnsNameString, LoaderBlock->SetupLoaderBlock->ComputerName );

        status = RtlDnsHostNameToComputerName(
                     &netbiosNameString,
                     &dnsNameString,
                     TRUE);            // allocate netbiosNameString

        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Failed RtlDnsHostNameToComputerName: %x\n", status ));
            goto cleanup;
        }

        //
        // Add a value for the computername.
        //

        IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName" );

        InitializeObjectAttributes(
            &objectAttributes,
            &string,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtOpenKey( &handle, KEY_ALL_ACCESS, &objectAttributes );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open ComputerName key: %x\n", status ));
            RtlFreeUnicodeString( &netbiosNameString );
            goto cleanup;
        }

        IopWstrToUnicodeString( &string, L"ComputerName" );

        status = NtSetValueKey(
                    handle,
                    &string,
                    0,
                    REG_SZ,
                    netbiosNameString.Buffer,
                    netbiosNameString.Length + sizeof(WCHAR)
                    );
        NtClose( handle );
        RtlFreeUnicodeString( &netbiosNameString );

        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to set ComputerName value: %x\n", status ));
            goto cleanup;
        }

        //
        // Add a value for the host name.
        //

        IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters" );

        InitializeObjectAttributes(
            &objectAttributes,
            &string,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtOpenKey( &handle, KEY_ALL_ACCESS, &objectAttributes );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open Tcpip\\Parameters key: %x\n", status ));
            goto cleanup;
        }

        _wcslwr( LoaderBlock->SetupLoaderBlock->ComputerName );

        IopWstrToUnicodeString( &string, L"Hostname" );

        status = NtSetValueKey(
                    handle,
                    &string,
                    0,
                    REG_SZ,
                    LoaderBlock->SetupLoaderBlock->ComputerName,
                    (wcslen(LoaderBlock->SetupLoaderBlock->ComputerName) + 1) * sizeof(WCHAR)
                    );
        NtClose( handle );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to set Hostname value: %x\n", status ));
            goto cleanup;
        }
    }

    //
    //  If the UNC path to the system files is supplied then store it in the registry.
    //

    ASSERT( _stricmp(LoaderBlock->ArcBootDeviceName,"net(0)") == 0 );

    IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey( &handle, KEY_ALL_ACCESS, &objectAttributes );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open Control key: %x\n", status ));
        goto skiproot;
    }

    p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
    if ( (p != NULL) && (*(p+1) == 0) ) {

        //
        // NtBootPathName ends with a backslash, so we need to back up
        // to the previous backslash.
        //

        q = p;
        *q = 0;
        p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
        *q = '\\';
    }
    if ( p == NULL ) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: malformed NtBootPathName: %s\n", LoaderBlock->NtBootPathName ));
        NtClose( handle );
        goto skiproot;
    }
    *p = 0;                                 // terminate \server\share\images\machine

    strcpy( ntName, "\\Device\\LanmanRedirector");
    strcat( ntName, LoaderBlock->NtBootPathName );  // append \server\share\images\machine
    *p = '\\';

    RtlInitAnsiString( &ansiString, ntName );
    
    status = RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, TRUE );
    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to convert RemoteBootRoot value: %x\n", status ));
    } else {
    
        IopWstrToUnicodeString( &string, L"RemoteBootRoot" );
    
        status = NtSetValueKey(
                    handle,
                    &string,
                    0,
                    REG_SZ,
                    unicodeString.Buffer,
                    unicodeString.Length + sizeof(WCHAR)
                    );
    
        RtlFreeUnicodeString( &unicodeString );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to set RemoteBootRoot value: %x\n", status ));
        }
    }

    if ((LoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_TEXTMODE) != 0) {

        strcpy( ntName, "\\Device\\LanmanRedirector");
        strcat( ntName, LoaderBlock->SetupLoaderBlock->MachineDirectoryPath );
        RtlInitAnsiString( &ansiString, ntName );
        status = RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, TRUE );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to convert RemoteBootMachineDirectory value: %x\n", status ));
        } else {
        
            IopWstrToUnicodeString( &string, L"RemoteBootMachineDirectory" );
    
            status = NtSetValueKey(
                        handle,
                        &string,
                        0,
                        REG_SZ,
                        unicodeString.Buffer,
                        unicodeString.Length + sizeof(WCHAR)
                        );
    
            RtlFreeUnicodeString( &unicodeString );
            if ( !NT_SUCCESS(status) ) {
                KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to set RemoteBootMachineDirectory value: %x\n", status ));
            }
        }
    }

    NtClose( handle );

skiproot:

    //
    // Add registry values for the IP address and subnet mask received
    // from DHCP. These are stored under the Tcpip service key and are
    // read by both Tcpip and Netbt. The adapter name used is the known
    // GUID for the NetbootCard.
    //

    IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey( &handle, KEY_ALL_ACCESS, &objectAttributes );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open Tcpip\\Parameters\\Interfaces\\{54C7D140-09EF-11D1-B25A-F5FE627ED95E} key: %x\n", status ));
        goto cleanup;
    }

    status = IopWriteIpAddressToRegistry(handle,
                                         L"DhcpIPAddress",
                                         (PUCHAR)&(LoaderBlock->SetupLoaderBlock->IpAddress)
                                        );

    if ( !NT_SUCCESS(status)) {
        NtClose(handle);
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to write DhcpIPAddress: %x\n", status ));
        goto cleanup;
    }

    status = IopWriteIpAddressToRegistry(handle,
                                         L"DhcpSubnetMask",
                                         (PUCHAR)&(LoaderBlock->SetupLoaderBlock->SubnetMask)
                                        );

    if ( !NT_SUCCESS(status)) {
        NtClose(handle);
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to write DhcpSubnetMask: %x\n", status ));
        goto cleanup;
    }

    status = IopWriteIpAddressToRegistry(handle,
                                         L"DhcpDefaultGateway",
                                         (PUCHAR)&(LoaderBlock->SetupLoaderBlock->DefaultRouter)
                                        );

    NtClose(handle);

    if ( !NT_SUCCESS(status)) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to write DhcpDefaultGateway: %x\n", status ));
        goto cleanup;
    }

    //
    // Create the service key for the netboot card. We need to have
    // the Type value there or the card won't be initialized.
    //

    status = IopOpenRegistryKeyEx(&handle,
                                  NULL,
                                  &CmRegistryMachineSystemCurrentControlSetServices,
                                  KEY_ALL_ACCESS
                                  );

    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open CurrentControlSet\\Services: %x\n", status ));
        goto cleanup;
    }

    RtlInitUnicodeString(&string, LoaderBlock->SetupLoaderBlock->NetbootCardServiceName);

    InitializeObjectAttributes(&objectAttributes,
                               &string,
                               OBJ_CASE_INSENSITIVE,
                               handle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );

    status = ZwCreateKey(&serviceHandle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &tmpValue     // disposition
                         );

    ZwClose(handle);

    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to open/create netboot card service key: %x\n", status ));
        goto cleanup;
    }

    //
    // Store the image path.
    //

    IopWstrToUnicodeString(&string, L"ImagePath");
    wcscpy(imagePath, L"system32\\drivers\\");
    wcscat(imagePath, LoaderBlock->SetupLoaderBlock->NetbootCardDriverName);

    status = ZwSetValueKey(serviceHandle,
                           &string,
                           TITLE_INDEX_VALUE,
                           REG_SZ,
                           imagePath,
                           (wcslen(imagePath) + 1) * sizeof(WCHAR)
                           );

    if (!NT_SUCCESS(status)) {
        NtClose(serviceHandle);
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to write ImagePath: %x\n", status ));
        goto cleanup;
    }

    //
    // Store the type.
    //

    IopWstrToUnicodeString(&string, L"Type");
    tmpValue = 1;

    status = ZwSetValueKey(serviceHandle,
                  &string,
                  TITLE_INDEX_VALUE,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );

    NtClose(serviceHandle);

    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAddRemoteBootValuesToRegistry: Unable to write Type: %x\n", status ));
    }

cleanup:

    if (buffer) {
        ExFreePool( buffer );
        buffer = NULL;
    }

    return status;
}

NTSTATUS
IopStartNetworkForRemoteBoot (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    NTSTATUS status;
    HANDLE dgHandle;
    HANDLE keyHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING string;
    UNICODE_STRING computerName;
    UNICODE_STRING domainName;
    PUCHAR buffer;
    ULONG bufferLength;
    PLMR_REQUEST_PACKET rrp;
    PLMDR_REQUEST_PACKET drrp;
    WKSTA_INFO_502 wkstaConfig;
    WKSTA_TRANSPORT_INFO_0 wkstaTransportInfo;
    LARGE_INTEGER interval;
    ULONG length;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    BOOLEAN startDatagramReceiver;
    ULONG enumerateAttempts;
    HANDLE RdrHandle;
    HANDLE eventHandle;

    //
    // Initialize for cleanup.
    //

    buffer = NULL;
    computerName.Buffer = NULL;
    domainName.Buffer = NULL;
    dgHandle = NULL;
    RdrHandle = NULL;
    eventHandle = NULL;

    //
    // Allocate a temporary buffer. It has to be big enough for all the
    // various FSCTLs we send down.
    //

    bufferLength = max(sizeof(LMR_REQUEST_PACKET) + (MAX_PATH + 1) * sizeof(WCHAR) +
                                                 (DNLEN + 1) * sizeof(WCHAR),
                       max(sizeof(LMDR_REQUEST_PACKET),
                           FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + MAX_PATH));
    bufferLength = max(bufferLength, sizeof(LMMR_RI_INITIALIZE_SECRET));

    buffer = ExAllocatePoolWithTag( NonPagedPool, bufferLength, 'bRoI' );
    if (buffer == NULL) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to allocate buffer\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    rrp = (PLMR_REQUEST_PACKET)buffer;
    drrp = (PLMDR_REQUEST_PACKET)buffer;

    //
    // Open the redirector and the datagram receiver.
    //

    IopWstrToUnicodeString( &string, L"\\Device\\LanmanRedirector" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtCreateFile(
                &RdrHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to open redirector: %x\n", status ));
        goto cleanup;
    }

    IopWstrToUnicodeString( &string, DD_BROWSER_DEVICE_NAME_U );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtCreateFile(
                &dgHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to open datagram receiver: %x\n", status ));
        goto cleanup;
    }

    status = NtCreateEvent( 
                        &eventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to createevent redirector: %x\n", status ));
        goto cleanup;
    }

    //
    // If the setup loader block has a disk secret in it provided by the
    // loader, pass this down to the redirector (do this before sending
    // the LMR_START, since that uses this information).
    //

    {
        PLMMR_RI_INITIALIZE_SECRET RbInit = (PLMMR_RI_INITIALIZE_SECRET)buffer;

        ASSERT(LoaderBlock->SetupLoaderBlock->NetBootSecret != NULL);
        RtlCopyMemory(
            &RbInit->Secret,
            LoaderBlock->SetupLoaderBlock->NetBootSecret,
            sizeof(RI_SECRET));

        status = NtFsControlFile(
                    RdrHandle,
                    eventHandle,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_LMMR_RI_INITIALIZE_SECRET,
                    buffer,
                    sizeof(LMMR_RI_INITIALIZE_SECRET),
                    NULL,
                    0
                    );

        if (status == STATUS_PENDING) {
            NtWaitForSingleObject(
                            eventHandle,
                            FALSE,
                            NULL);
            
            status = ioStatusBlock.Status;
        }

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }
        
        NtClearEvent( eventHandle );

        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopStartNetworkForRemoteBoot: Unable to FSCTL(RB initialize) redirector: %x\n", status ));
            goto cleanup;
        }
    }

    //
    // Read the computer name and domain name from the registry so we
    // can give them to the datagram receiver. During textmode setup
    // the domain name will not be there, so we won't start the datagram
    // receiver, which is fine.
    //
    IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey( &keyHandle, KEY_ALL_ACCESS, &objectAttributes );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to open ComputerName key: %x\n", status ));
        goto cleanup;
    }

    IopWstrToUnicodeString( &string, L"ComputerName" );

    keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    RtlZeroMemory(buffer, bufferLength);

    status = NtQueryValueKey(
                 keyHandle,
                 &string,
                 KeyValuePartialInformation,
                 keyValue,
                 bufferLength,
                 &length);

    NtClose( keyHandle );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to query ComputerName value: %x\n", status ));
        goto cleanup;
    }

    if ( !RtlCreateUnicodeString(&computerName, (PWSTR)keyValue->Data) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to create ComputerName string\n" ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    domainName.Length = 0;

    IopWstrToUnicodeString( &string, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\DomainName" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey( &keyHandle, KEY_ALL_ACCESS, &objectAttributes );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to open DomainName key: %x\n", status ));
        startDatagramReceiver = FALSE;
    } else {

        IopWstrToUnicodeString( &string, L"DomainName" );

        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
        RtlZeroMemory(buffer, bufferLength);

        status = NtQueryValueKey(
                     keyHandle,
                     &string,
                     KeyValuePartialInformation,
                     keyValue,
                     bufferLength,
                     &length);

        NtClose( keyHandle );
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopStartNetworkForRemoteBoot: Unable to query Domain value: %x\n", status ));
            startDatagramReceiver = FALSE;
        } else {
            if ( !RtlCreateUnicodeString(&domainName, (PWSTR)keyValue->Data) ) {
                KdPrint(( "IopStartNetworkForRemoteBoot: Unable to create DomainName string\n" ));
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto cleanup;
            }
            startDatagramReceiver = TRUE;
        }
    }

    //
    // Tell the redir to start.
    //

    rrp->Type = ConfigInformation;
    rrp->Version = REQUEST_PACKET_VERSION;

    rrp->Parameters.Start.RedirectorNameLength = computerName.Length;
    RtlCopyMemory(rrp->Parameters.Start.RedirectorName,
                  computerName.Buffer,
                  computerName.Length);

    rrp->Parameters.Start.DomainNameLength = domainName.Length;
    RtlCopyMemory(((PUCHAR)rrp->Parameters.Start.RedirectorName) + computerName.Length,
                  domainName.Buffer,
                  domainName.Length);

    RtlFreeUnicodeString(&computerName);
    RtlFreeUnicodeString(&domainName);

    wkstaConfig.wki502_char_wait = 3600;
    wkstaConfig.wki502_maximum_collection_count = 16;
    wkstaConfig.wki502_collection_time = 250;
    wkstaConfig.wki502_keep_conn = 600;
    wkstaConfig.wki502_max_cmds = 5;
    wkstaConfig.wki502_sess_timeout = 45;
    wkstaConfig.wki502_siz_char_buf = 512;
    wkstaConfig.wki502_max_threads = 17;
    wkstaConfig.wki502_lock_quota = 6144;
    wkstaConfig.wki502_lock_increment = 10;
    wkstaConfig.wki502_lock_maximum = 500;
    wkstaConfig.wki502_pipe_increment = 10;
    wkstaConfig.wki502_pipe_maximum = 500;
    wkstaConfig.wki502_cache_file_timeout = 40;
    wkstaConfig.wki502_dormant_file_limit = 45;
    wkstaConfig.wki502_read_ahead_throughput = MAXULONG;
    wkstaConfig.wki502_num_mailslot_buffers = 3;
    wkstaConfig.wki502_num_srv_announce_buffers = 20;
    wkstaConfig.wki502_max_illegal_datagram_events = 5;
    wkstaConfig.wki502_illegal_datagram_event_reset_frequency = 60;
    wkstaConfig.wki502_log_election_packets = FALSE;
    wkstaConfig.wki502_use_opportunistic_locking = TRUE;
    wkstaConfig.wki502_use_unlock_behind = TRUE;
    wkstaConfig.wki502_use_close_behind = TRUE;
    wkstaConfig.wki502_buf_named_pipes = TRUE;
    wkstaConfig.wki502_use_lock_read_unlock = TRUE;
    wkstaConfig.wki502_utilize_nt_caching = TRUE;
    wkstaConfig.wki502_use_raw_read = TRUE;
    wkstaConfig.wki502_use_raw_write = TRUE;
    wkstaConfig.wki502_use_write_raw_data = TRUE;
    wkstaConfig.wki502_use_encryption = TRUE;
    wkstaConfig.wki502_buf_files_deny_write = TRUE;
    wkstaConfig.wki502_buf_read_only_files = TRUE;
    wkstaConfig.wki502_force_core_create_mode = TRUE;
    wkstaConfig.wki502_use_512_byte_max_transfer = FALSE;

    status = NtFsControlFile(
                RdrHandle,
                eventHandle,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_LMR_START | 0x80000000,
                rrp,
                sizeof(LMR_REQUEST_PACKET) +
                    rrp->Parameters.Start.RedirectorNameLength +
                    rrp->Parameters.Start.DomainNameLength,
                &wkstaConfig,
                sizeof(wkstaConfig)
                );

    if (status == STATUS_PENDING) {
        NtWaitForSingleObject(
                        eventHandle,
                        FALSE,
                        NULL);
        
        status = ioStatusBlock.Status;
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartNetworkForRemoteBoot: Unable to FSCTL(start) redirector: %x\n", status ));
        goto cleanup;
    }

    NtClearEvent( eventHandle );

    if (startDatagramReceiver) {

        //
        // Tell the datagram receiver to start.
        //

        drrp->Version = LMDR_REQUEST_PACKET_VERSION;

        drrp->Parameters.Start.NumberOfMailslotBuffers = 16;
        drrp->Parameters.Start.NumberOfServerAnnounceBuffers = 20;
        drrp->Parameters.Start.IllegalDatagramThreshold = 5;
        drrp->Parameters.Start.EventLogResetFrequency = 60;
        drrp->Parameters.Start.LogElectionPackets = FALSE;

        drrp->Parameters.Start.IsLanManNt = FALSE;

        status = NtDeviceIoControlFile(
                    dgHandle,
                    eventHandle,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    IOCTL_LMDR_START,
                    drrp,
                    sizeof(LMDR_REQUEST_PACKET),
                    NULL,
                    0
                    );

        if ( status == STATUS_PENDING ) {
            NtWaitForSingleObject(
                            eventHandle,
                            FALSE,
                            NULL);

            status = ioStatusBlock.Status;
        }

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        NtClearEvent( eventHandle );
        
        NtClose( dgHandle );
        dgHandle = NULL;

        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopStartNetworkForRemoteBoot: Unable to IOCTL(start) datagram receiver: %x\n", status ));
            goto cleanup;
        }

    } else {
        
        NtClose( dgHandle );
        dgHandle = NULL;

        //
        // Tell the redir to bind to the transports.
        //
        // Note: In the current redirector implementation, this call just
        // tells the redirector to register for TDI PnP notifications.
        // Starting the datagram receiver also does this, so we only issue
        // this FSCTL if we're not starting the datagram receiver.
        //

        status = NtFsControlFile(
                    RdrHandle,
                    eventHandle,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_LMR_BIND_TO_TRANSPORT | 0x80000000,
                    NULL,
                    0,
                    NULL,
                    0
                    );
        
        if ( status == STATUS_PENDING ) {
            NtWaitForSingleObject(
                            eventHandle,
                            FALSE,
                            NULL);
        
            status = ioStatusBlock.Status;
        }


        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        NtClearEvent( eventHandle );
        
        if ( !NT_SUCCESS(status) ) {
            KdPrint(( "IopStartNetworkForRemoteBoot: Unable to FSCTL(bind) redirector: %x\n", status ));
            goto cleanup;
        }
    }

    {

        //
        // Loop until the redirector is bound to the transport. It may take a
        // while because TDI defers notification of binding to a worker thread.
        // We start with a half a second wait and double it each time, trying
        // five times total.
        //

        interval.QuadPart = -500 * 1000 * 10;    // 1/2 second, relative
        enumerateAttempts = 0;

        while (TRUE) {

            KeDelayExecutionThread(KernelMode, FALSE, &interval);

            RtlZeroMemory(rrp, sizeof(LMR_REQUEST_PACKET));

            rrp->Type = EnumerateTransports;
            rrp->Version = REQUEST_PACKET_VERSION;

            status = NtFsControlFile(
                        RdrHandle,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        FSCTL_LMR_ENUMERATE_TRANSPORTS,
                        rrp,
                        sizeof(LMR_REQUEST_PACKET),
                        &wkstaTransportInfo,
                        sizeof(wkstaTransportInfo)
                        );

            if ( NT_SUCCESS(status) ) {
                status = ioStatusBlock.Status;
            }
            if ( !NT_SUCCESS(status) ) {
                //KdPrint(( "IopStartNetworkForRemoteBoot: Unable to FSCTL(enumerate) redirector: %x\n", status ));
            } else if (rrp->Parameters.Get.TotalBytesNeeded == 0) {
                //KdPrint(( "IopStartNetworkForRemoteBoot: FSCTL(enumerate) returned 0 entries\n" ));
            } else {
                break;
            }

            ++enumerateAttempts;

            if (enumerateAttempts == 5) {
                KdPrint(( "IopStartNetworkForRemoteBoot: Redirector didn't start\n" ));
                status = STATUS_REDIRECTOR_NOT_STARTED;
                goto cleanup;
            }

            interval.QuadPart *= 2;

        }
    }

    //
    // Prime the transport.
    //
    IopSetDefaultGateway(LoaderBlock->SetupLoaderBlock->DefaultRouter);
    IopCacheNetbiosNameForIpAddress(LoaderBlock);

    IopAssignNetworkDriveLetter(LoaderBlock);

cleanup:

    RtlFreeUnicodeString( &computerName );
    RtlFreeUnicodeString( &domainName );
    if ( buffer != NULL ) {
        ExFreePool( buffer );
    }

    if ( dgHandle != NULL ) {
        NtClose( dgHandle );
    }

    if (eventHandle) {
        NtClose( eventHandle );
    }

    if (RdrHandle) {
        NtClose( RdrHandle );
    }

    return status;
}

VOID
IopAssignNetworkDriveLetter (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    PUCHAR p;
    PUCHAR q;
    PUCHAR ntName;
    STRING ansiString;
    UNICODE_STRING unicodeString;
    UNICODE_STRING unicodeString2;
    NTSTATUS status;

    //
    // Create the symbolic link of X: to the redirector. We do this
    // after the redirector has loaded, but before AssignDriveLetters
    // is called the first time in textmode setup (once that has
    // happened, the drive letters will stick).
    //
    // Note that we use X: for the textmode setup phase of a remote
    // installation. But for a true remote boot, we use C:.
    //

    if ((LoaderBlock->SetupLoaderBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL |
                                                 SETUPBLK_FLAGS_SYSPREP_INSTALL)) != 0) {
        IopWstrToUnicodeString( &unicodeString2, L"\\DosDevices\\X:");
    } else {
        IopWstrToUnicodeString( &unicodeString2, L"\\DosDevices\\C:");
    }

    //
    // If this is a remote boot setup boot, NtBootPathName is of the
    // form \<server>\<share>\setup\<install-directory>\<platform>.
    // We want the root of the X: drive to be the root of the install
    // directory.
    //
    // If this is a normal remote boot, NtBootPathName is of the form
    // \<server>\<share>\images\<machine>\winnt. We want the root of
    // the X: drive to be the root of the machine directory.
    //
    // Thus in either case, we need to remove the last element of the
    // path.
    //

    p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
    if ( (p != NULL) && (*(p+1) == 0) ) {

        //
        // NtBootPathName ends with a backslash, so we need to back up
        // to the previous backslash.
        //

        q = p;
        *q = 0;
        p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
        *q = '\\';
    }
    if ( p == NULL ) {
        KdPrint(( "IopAssignNetworkDriveLetter: malformed NtBootPathName: %s\n", LoaderBlock->NtBootPathName ));
        KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );
    }
    *p = 0;                                 // terminate \server\share\images\machine

    ntName = ExAllocatePoolWithTag( 
                        NonPagedPool, 
                        sizeof("\\Device\\LanmanRedirector") + strlen(LoaderBlock->NtBootPathName), 
                        'bRoI' );

    if (!ntName) {
        KdPrint(( "IopAssignNetworkDriveLetter: unable to alloc memory" ));
        KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );
    }

    strcpy( ntName, "\\Device\\LanmanRedirector");
    strcat( ntName, LoaderBlock->NtBootPathName );  // append \server\share\images\machine

    RtlInitAnsiString( &ansiString, ntName );
    
    status = RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, TRUE );
    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAssignNetworkDriveLetter: unable to convert DOS link for redirected boot drive: %x\n", status ));
        KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );
    }

    status = IoCreateSymbolicLink(&unicodeString2, &unicodeString);
    if (!NT_SUCCESS(status)) {
        KdPrint(( "IopAssignNetworkDriveLetter: unable to create DOS link for redirected boot drive: %x\n", status ));
        KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );
    }
    // DbgPrint("IopAssignNetworkDriveLetter: assigned %wZ to %wZ\n", &unicodeString2, &unicodeString);

    RtlFreeUnicodeString( &unicodeString );

    *p = '\\';                              // restore string

    ExFreePool( ntName );

    return;
}


NTSTATUS
IopStartTcpIpForRemoteBoot (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UNICODE_STRING IpString;
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE handle = NULL;
    HANDLE eventHandle = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    IP_SET_ADDRESS_REQUEST IpRequest;

    RtlInitUnicodeString( &IpString, DD_IP_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &IpString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    RtlZeroMemory(&IpRequest, sizeof(IpRequest));
    IpRequest.Context = (USHORT)2;
    IpRequest.Address = LoaderBlock->SetupLoaderBlock->IpAddress;
    IpRequest.SubnetMask = LoaderBlock->SetupLoaderBlock->SubnetMask;

    status = NtCreateFile(
                &handle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartTcpIpForRemoteBoot: Unable to open IP: %x\n", status ));
        goto cleanup;
    }

    status = NtCreateEvent(
                        &eventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE );
    if ( !NT_SUCCESS(status)) {
        KdPrint(( "IopStartTcpIpForRemoteBoot: Unable to create event: %x\n", status ));
        goto cleanup;
    }

    status = NtDeviceIoControlFile(
                handle,
                eventHandle,
                NULL,
                NULL,
                &ioStatusBlock,
                IOCTL_IP_SET_ADDRESS,
                &IpRequest,
                sizeof(IP_SET_ADDRESS_REQUEST),
                NULL,
                0
                );

    if ( status == STATUS_PENDING ) {
        NtWaitForSingleObject(
                        eventHandle,
                        FALSE,
                        NULL);
    
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopStartTcpIpForRemoteBoot: Unable to IOCTL IP: %x\n", status ));

        //
        // if we got a duplicate name error this means that there is another 
        // network node with the same address as us.  This is a fatal
        // error, and we bugcheck with the ip address as a parameter so that 
        // the network administrator can determine how they assigned duplicate
        // addresses on the network.
        //
        if (status == STATUS_DUPLICATE_NAME) {
            KeBugCheckEx( 
                NETWORK_BOOT_DUPLICATE_ADDRESS,
                LoaderBlock->SetupLoaderBlock->IpAddress,
                0,
                0,
                0 );
        }
        goto cleanup;
    }

cleanup:

    if (eventHandle != NULL) {
        NtClose( handle );
    }

    if (handle != NULL) {
        NtClose( handle );
    }

    return status;
}

BOOLEAN
IopIsRemoteBootCard(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PWCHAR HwIds
    )

/*++

Routine Description:

    This function determines if the card described by the hwIds is the
    remote boot network card. It checks against the hardware ID for the
    card that is stored in the setup loader block.

    THIS ASSUMES THAT IOREMOTEBOOTCLIENT IS TRUE AND THAT LOADERBLOCK
    IS VALID.

Arguments:

    DeviceNode - Device node for the card in question.

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

    HwIds - The hardware IDs for the device in question.

Return Value:

    TRUE or FALSE.

--*/

{
    PSETUP_LOADER_BLOCK setupLoaderBlock;
    PWCHAR curHwId;

    //
    // setupLoaderBlock will always be non-NULL if we are
    // remote booting, even if we are not in setup.
    //

    setupLoaderBlock = LoaderBlock->SetupLoaderBlock;

    //
    // Scan through the HwIds for a match.
    //

    curHwId = HwIds;

    while (*curHwId != L'\0') {
        
#if defined (_IA64_)
        
        //
        // On IA64, PXE may not have told the BINL service enough details about
        // the NIC hardware, so the PNP ID may not be exact.  We should test against
        // the PNP ID of the that BINL gave setupldr and then to us.
        //
        if (_wcsnicmp(curHwId, setupLoaderBlock->NetbootCardHardwareId, wcslen(setupLoaderBlock->NetbootCardHardwareId)) == 0) {
#else
        if (wcscmp(curHwId, setupLoaderBlock->NetbootCardHardwareId) == 0) {
#endif

            ULONG BusNumber, DeviceNumber, FunctionNumber;

            //
            // PCI's encoding is this: fff ddddd
            // PXE's encoding is this: ddddd fff
            //

            BusNumber = (ULONG)((((PNET_CARD_INFO)setupLoaderBlock->NetbootCardInfo)->pci.BusDevFunc) >> 8);
            DeviceNumber = (ULONG)(((((PNET_CARD_INFO)setupLoaderBlock->NetbootCardInfo)->pci.BusDevFunc) & 0xf8) >> 3);
            FunctionNumber = (ULONG)(((((PNET_CARD_INFO)setupLoaderBlock->NetbootCardInfo)->pci.BusDevFunc) & 0x3));

            KdPrint(("IopIsRemoteBootCard: FOUND %ws\n", setupLoaderBlock->NetbootCardHardwareId));
            if ((ResourceRequirements->BusNumber != BusNumber) ||
                ((ResourceRequirements->SlotNumber & 0x1f) != DeviceNumber) ||
                (((ResourceRequirements->SlotNumber >> 5) & 0x3) != FunctionNumber)) {
                KdPrint(("IopIsRemoteBootCard: ignoring non-matching card:\n"));
                KdPrint(("  devnode bus %d, busdevfunc bus %d\n",
                    ResourceRequirements->BusNumber,
                    BusNumber));
                KdPrint(("  devnode slot %d (%d %d), busdevfunc slot %d (%d %d)\n",
                    ResourceRequirements->SlotNumber,
                    (ResourceRequirements->SlotNumber & 0x1f),
                    ((ResourceRequirements->SlotNumber >> 5) & 0x3),
                    (ULONG)(((PNET_CARD_INFO)setupLoaderBlock->NetbootCardInfo)->pci.BusDevFunc),
                    DeviceNumber,
                    FunctionNumber));
                return FALSE;
            } else {
                return TRUE;
            }
        }
        curHwId += (wcslen(curHwId) + 1);
    }

    return FALSE;
}

NTSTATUS
IopSetupRemoteBootCard(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN HANDLE UniqueIdHandle,
    IN PUNICODE_STRING UnicodeDeviceInstance
    )

/*++

Routine Description:

    This function modifies the registry to set up the netboot card.
    We must do this here since the card is needed to boot, we can't
    wait for the class installer to run.

    THIS ASSUMES THAT IOREMOTEBOOTCLIENT IS TRUE.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

    UniqueIdHandle - A handle to the device's unique node under the
        Enum key.

    UnicodeDeviceInstance - The device instance assigned to the device.

Return Value:

    Status of the operation.

--*/

{
    PSETUP_LOADER_BLOCK setupLoaderBlock;
    UNICODE_STRING unicodeName, pnpInstanceId, keyName;
    HANDLE tmpHandle;
    HANDLE parametersHandle = NULL;
    HANDLE currentControlSetHandle = NULL;
    HANDLE remoteBootHandle = NULL;
    HANDLE instanceHandle = NULL;
    PWCHAR componentIdBuffer, curComponentIdLoc;
    PCHAR registryList;
    ULONG componentIdLength;
    WCHAR tempNameBuffer[32];
    WCHAR tempValueBuffer[128];
    NTSTATUS status;
    ULONG tmpValue, length;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    PKEY_VALUE_BASIC_INFORMATION keyValueBasic;
    UCHAR dataBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + 128];
    ULONG enumerateIndex;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    //
    // If we already think we have initialized a remote boot card, then
    // exit (should not really happen once we identify cards using the
    // bus/slot.
    //

    if (IopRemoteBootCardInitialized) {
        return STATUS_SUCCESS;
    }

    //
    // setupLoaderBlock will always be non-NULL if we are
    // remote booting, even if we are not in setup.
    //

    setupLoaderBlock = LoaderBlock->SetupLoaderBlock;

    //
    // Open the current control set.
    //

    status = IopOpenRegistryKeyEx(&currentControlSetHandle,
                                  NULL,
                                  &CmRegistryMachineSystemCurrentControlSet,
                                  KEY_ALL_ACCESS
                                  );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Open the Control\RemoteBoot key, which may not exist.
    //

    IopWstrToUnicodeString(&unicodeName, L"Control\\RemoteBoot");

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeName,
                               OBJ_CASE_INSENSITIVE,
                               currentControlSetHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );

    status = ZwCreateKey(&remoteBootHandle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &disposition
                         );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Open the key where the netui code stores information about the cards.
    // During textmode setup this will fail because the Control\Network
    // key is not there. After that it should work, although we may need
    // to create the last node in the path.
    //

    IopWstrToUnicodeString(&unicodeName, L"Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}");

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeName,
                               OBJ_CASE_INSENSITIVE,
                               currentControlSetHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );

    status = ZwCreateKey(&instanceHandle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &disposition
                         );

    if (NT_SUCCESS(status)) {

        //
        // If the PnpInstanceID of the first netboot card matches the one
        // for this device node, and the NET_CARD_INFO that the loader
        // found is the same as the one we saved, then this is the same
        // card with the same instance ID as before, so we don't need to
        // do anything.
        //

        IopWstrToUnicodeString(&unicodeName, L"PnPInstanceID");
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)dataBuffer;
        RtlZeroMemory(dataBuffer, sizeof(dataBuffer));

        status = ZwQueryValueKey(
                     instanceHandle,
                     &unicodeName,
                     KeyValuePartialInformation,
                     keyValue,
                     sizeof(dataBuffer),
                     &length);

        //
        // Check that it matches. We can init the string because we zeroed
        // the dataBuffer before reading the key, so even if the
        // registry value had no NULL at the end that is OK.
        //

        if ((NT_SUCCESS(status)) &&
            (keyValue->Type == REG_SZ)) {

            RtlInitUnicodeString(&pnpInstanceId, (PWSTR)(keyValue->Data));

            if (RtlEqualUnicodeString(UnicodeDeviceInstance, &pnpInstanceId, TRUE)) {

                //
                // Instance ID matched, see if the NET_CARD_INFO matches.
                //

                IopWstrToUnicodeString(&unicodeName, L"NetCardInfo");
                RtlZeroMemory(dataBuffer, sizeof(dataBuffer));

                status = ZwQueryValueKey(
                             remoteBootHandle,
                             &unicodeName,
                             KeyValuePartialInformation,
                             keyValue,
                             sizeof(dataBuffer),
                             &length);

                if ((NT_SUCCESS(status)) &&
                    (keyValue->Type == REG_BINARY) &&
                    (keyValue->DataLength == sizeof(NET_CARD_INFO)) &&
                    (memcmp(keyValue->Data, setupLoaderBlock->NetbootCardInfo, sizeof(NET_CARD_INFO)) == 0)) {

                    //
                    // Everything matched, so no need to do any setup.
                    //

                    status = STATUS_SUCCESS;
                    goto cleanup;

                }
            }
        }
    }


    //
    // We come through here if the saved registry data was missing or
    // not correct. Write all the relevant values to the registry.
    //


    //
    // Service name is in the loader block.
    //

    IopWstrToUnicodeString(&unicodeName, REGSTR_VALUE_SERVICE);
    status = ZwSetValueKey(UniqueIdHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  setupLoaderBlock->NetbootCardServiceName,
                  (wcslen(setupLoaderBlock->NetbootCardServiceName) + 1) * sizeof(WCHAR)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // ClassGUID is the known net card GUID.
    //

    IopWstrToUnicodeString(&unicodeName, REGSTR_VALUE_CLASSGUID);
    status = ZwSetValueKey(UniqueIdHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  L"{4D36E972-E325-11CE-BFC1-08002BE10318}",
                  sizeof(L"{4D36E972-E325-11CE-BFC1-08002BE10318}")
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Driver is the first net card.
    //

    IopWstrToUnicodeString(&unicodeName, REGSTR_VALUE_DRIVER);
    status = ZwSetValueKey(UniqueIdHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  L"{4D36E972-E325-11CE-BFC1-08002BE10318}\\0000",
                  sizeof(L"{4D36E972-E325-11CE-BFC1-08002BE10318}\\0000")
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    //
    // Open a handle for card parameters. We write RemoteBootCard plus
    // whatever the BINL server told us to write.
    //

    status = IopOpenRegistryKeyEx(&tmpHandle,
                                  NULL,
                                  &CmRegistryMachineSystemCurrentControlSetControlClass,
                                  KEY_ALL_ACCESS
                                  );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    IopWstrToUnicodeString(&unicodeName, L"{4D36E972-E325-11CE-BFC1-08002BE10318}\\0000");

    status = IopOpenRegistryKeyEx(&parametersHandle,
                                  tmpHandle,
                                  &unicodeName,
                                  KEY_ALL_ACCESS
                                  );

    ZwClose(tmpHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // We know that this is a different NIC, so remove all the old parameters.
    //

    keyValueBasic = (PKEY_VALUE_BASIC_INFORMATION)dataBuffer;
    enumerateIndex = 0;

    while (TRUE) {

        RtlZeroMemory(dataBuffer, sizeof(dataBuffer));

        status = ZwEnumerateValueKey(
                    parametersHandle,
                    enumerateIndex,
                    KeyValueBasicInformation,
                    keyValueBasic,
                    sizeof(dataBuffer),
                    &length
                    );
        if (status == STATUS_NO_MORE_ENTRIES) {
            status = STATUS_SUCCESS;
            break;
        }

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // We don't delete "NetCfgInstanceID", it won't change and
        // its presence signifies to the net class installer that
        // this is a replacement not a clean install.
        //

        if (_wcsicmp(keyValueBasic->Name, L"NetCfgInstanceID") != 0) {

            RtlInitUnicodeString(&keyName, keyValueBasic->Name);
            status = ZwDeleteValueKey(
                        parametersHandle,
                        &keyName
                        );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

        } else {

            enumerateIndex = 1;   // leave NetCfgInstanceID at index 0
        }

    }

    //
    // Write a parameter called RemoteBootCard set to TRUE, this
    // is primarily so NDIS can recognize this as such.
    //

    IopWstrToUnicodeString(&unicodeName, L"RemoteBootCard");
    tmpValue = 1;
    status = ZwSetValueKey(parametersHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    //
    // Store any other parameters sent from the server.
    //

    registryList = setupLoaderBlock->NetbootCardRegistry;

    if (registryList != NULL) {

        STRING aString;
        UNICODE_STRING uString, uString2;

        //
        // The registry list is a series of name\0type\0value\0, with
        // a final \0 at the end. It is in ANSI, not UNICODE.
        //
        // All values are stored under parametersHandle. Type is 1 for
        // DWORD and 2 for SZ.
        //

        uString.Buffer = tempNameBuffer;
        uString.MaximumLength = sizeof(tempNameBuffer);

        while (*registryList != '\0') {

            //
            // First the name.
            //

            RtlInitString(&aString, registryList);
            status = RtlAnsiStringToUnicodeString(&uString, &aString, FALSE);
            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            //
            // Now the type.
            //

            registryList += (strlen(registryList) + 1);

            if (*registryList == '1') {

                //
                // A DWORD, parse it.
                //

                registryList += 2;   // skip "1\0"
                tmpValue = 0;

                while (*registryList != '\0') {
                    tmpValue = (tmpValue * 10) + (*registryList - '0');
                    ++registryList;
                }

                status = ZwSetValueKey(parametersHandle,
                              &uString,
                              TITLE_INDEX_VALUE,
                              REG_DWORD,
                              &tmpValue,
                              sizeof(tmpValue)
                              );
                if (!NT_SUCCESS(status)) {
                    goto cleanup;
                }

                registryList += (strlen(registryList) + 1);

            } else if (*registryList == '2') {

                //
                // An SZ, convert to Unicode.
                //

                registryList += 2;   // skip "2\0"

                uString2.Buffer = tempValueBuffer;
                uString2.MaximumLength = sizeof(tempValueBuffer);
                RtlInitAnsiString(&aString, registryList);
                status = RtlAnsiStringToUnicodeString(&uString2, &aString, FALSE);
                if (!NT_SUCCESS(status)) {
                    goto cleanup;
                }

                status = ZwSetValueKey(parametersHandle,
                              &uString,
                              TITLE_INDEX_VALUE,
                              REG_SZ,
                              uString2.Buffer,
                              uString2.Length + sizeof(WCHAR)
                              );
                if (!NT_SUCCESS(status)) {
                    goto cleanup;
                }

                registryList += (strlen(registryList) + 1);

            } else {

                //
                // Not "1" or "2", so stop processing registryList.
                //

                break;

            }

        }

    }

    //
    // Save the NET_CARD_INFO so we can check it next time.
    //

    IopWstrToUnicodeString(&unicodeName, L"NetCardInfo");

    status = ZwSetValueKey(remoteBootHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_BINARY,
                  setupLoaderBlock->NetbootCardInfo,
                  sizeof(NET_CARD_INFO)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    //
    // Save the hardware ID, driver name, and service name,
    // so the loader can read  those if the server is down
    // on subsequent boots.
    //

    IopWstrToUnicodeString(&unicodeName, L"HardwareId");
    status = ZwSetValueKey(remoteBootHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  setupLoaderBlock->NetbootCardHardwareId,
                  (wcslen(setupLoaderBlock->NetbootCardHardwareId) + 1) * sizeof(WCHAR)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    IopWstrToUnicodeString(&unicodeName, L"DriverName");
    status = ZwSetValueKey(remoteBootHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  setupLoaderBlock->NetbootCardDriverName,
                  (wcslen(setupLoaderBlock->NetbootCardDriverName) + 1) * sizeof(WCHAR)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    IopWstrToUnicodeString(&unicodeName, L"ServiceName");
    status = ZwSetValueKey(remoteBootHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  setupLoaderBlock->NetbootCardServiceName,
                  (wcslen(setupLoaderBlock->NetbootCardServiceName) + 1) * sizeof(WCHAR)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    //
    // Save the device instance, in case we need to ID the card later.
    //

    IopWstrToUnicodeString(&unicodeName, L"DeviceInstance");
    status = ZwSetValueKey(remoteBootHandle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_SZ,
                  UnicodeDeviceInstance->Buffer,
                  UnicodeDeviceInstance->Length + sizeof(WCHAR)
                  );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Make sure we only pick one card to setup this way!
    //

    IopRemoteBootCardInitialized = TRUE;


cleanup:
    if (instanceHandle != NULL) {
        ZwClose(instanceHandle);
    }
    if (remoteBootHandle != NULL) {
        ZwClose(remoteBootHandle);
    }
    if (parametersHandle != NULL) {
        ZwClose(parametersHandle);
    }
    if (currentControlSetHandle != NULL) {
        ZwClose(currentControlSetHandle);
    }

    return status;

}

NTSTATUS
IopWriteIpAddressToRegistry(
        HANDLE handle,
        PWCHAR regkey,
        PUCHAR value
        )
{
    NTSTATUS status;
    UNICODE_STRING string;
    CHAR addressA[17];
    WCHAR addressW[17];
    STRING addressStringA;
    UNICODE_STRING addressStringW;

    RtlInitUnicodeString( &string, regkey );

    RtlZeroMemory(addressW,sizeof(addressW));
    
    //
    // note that value is PUCHAR, therefore the largest
    // each %d could expand to is 255, which means that our
    // buffer cannot overflow.
    //
    sprintf(addressA, "%d.%d.%d.%d",
             value[0],
             value[1],
             value[2],
             value[3]);

    RtlInitAnsiString(&addressStringA, addressA);
    addressStringW.Buffer = addressW;
    addressStringW.MaximumLength = sizeof(addressW);

    status = RtlAnsiStringToUnicodeString(&addressStringW, &addressStringA, FALSE);
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopWriteIpAddressToRegistry: Unable to convert %ws value: %x\n", regkey, status ));
        goto cleanup;
    }

    //
    // we are setting a REG_MULTI_SZ, this has an extra NULL at the
    // end of it.  Our buffer has an extra character in it to account
    // for this.
    //
    status = NtSetValueKey(
                handle,
                &string,
                0,
                REG_MULTI_SZ,
                addressW,
                addressStringW.Length + sizeof(WCHAR)
                );
    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "IopWriteIpAddressToRegistry: Unable to set %ws value: %x\n", regkey, status ));
        goto cleanup;
    }

cleanup:
    return status;
}


NTSTATUS
IopSetDefaultGateway(
    IN ULONG GatewayAddress
    )
/*++

Routine Description:

    This function adds a default gateway entry from the router table.

Arguments:

    GatewayAddress - Address of the default gateway.

Return Value:

    Error Code.

--*/
{
    NTSTATUS Status;

    HANDLE Handle = NULL;
    BYTE Context[CONTEXT_SIZE];
    TDIObjectID ID;
    DWORD Size;
    IPSNMPInfo IPStats;
    IPAddrEntry *AddrTable = NULL;
    DWORD NumReturned;
    DWORD Type;
    DWORD i;
    DWORD MatchIndex;
    IPRouteEntry RouteEntry;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK ioStatusBlock;

    if (GatewayAddress == 0) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString( &NameString, DD_TCP_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &NameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(Status) ) {
        KdPrint(( "IopSetDefaultGateway: Unable to open TCPIP: %x\n", Status ));
        return Status;
    }

    //
    // Get the NetAddr info, to find an interface index for the gateway.
    //

    ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = IP_MIB_STATS_ID;

    Size = sizeof(IPStats);
    memset(&IPStats, 0x0, Size);
    memset(Context, 0x0, CONTEXT_SIZE);

    Status = IopTCPQueryInformationEx(
                Handle,
                &ID,
                &IPStats,
                &Size,
                Context);

    if (!NT_SUCCESS(Status)) {
        KdPrint(( "IopSetDefaultGateway: Unable to query TCPIP(1): %x\n", Status ));
        goto Cleanup;
    }

    Size = IPStats.ipsi_numaddr * sizeof(IPAddrEntry);
    AddrTable = ExAllocatePoolWithTag(PagedPool, Size, 'bRoI');

    if (AddrTable == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    memset(Context, 0x0, CONTEXT_SIZE);

    Status = IopTCPQueryInformationEx(
                Handle,
                &ID,
                AddrTable,
                &Size,
                Context);

    if (!NT_SUCCESS(Status)) {
        KdPrint(( "IopSetDefaultGateway: Unable to query TCPIP(2): %x\n", Status ));
        goto Cleanup;
    }

    NumReturned = Size/sizeof(IPAddrEntry);

    //
    // We've got the address table. Loop through it. If we find an exact
    // match for the gateway, then we're adding or deleting a direct route
    // and we're done. Otherwise try to find a match on the subnet mask,
    // and remember the first one we find.
    //

    Type = IRE_TYPE_INDIRECT;
    for (i = 0, MatchIndex = 0xffff; i < NumReturned; i++) {

        if( AddrTable[i].iae_addr == GatewayAddress ) {

            //
            // Found an exact match.
            //

            MatchIndex = i;
            Type = IRE_TYPE_DIRECT;
            break;
        }

        //
        // The next hop is on the same subnet as this address. If
        // we haven't already found a match, remember this one.
        //

        if ( (MatchIndex == 0xffff) &&
             (AddrTable[i].iae_addr != 0) &&
             (AddrTable[i].iae_mask != 0) &&
             ((AddrTable[i].iae_addr & AddrTable[i].iae_mask) ==
                (GatewayAddress  & AddrTable[i].iae_mask)) ) {

            MatchIndex = i;
        }
    }

    //
    // We've looked at all of the entries. See if we found a match.
    //

    if (MatchIndex == 0xffff) {
        //
        // Didn't find a match.
        //

        Status = STATUS_UNSUCCESSFUL;
        KdPrint(( "IopSetDefaultGateway: Unable to find match for gateway\n" ));
        goto Cleanup;
    }

    //
    // We've found a match. Fill in the route entry, and call the
    // Set API.
    //

    RouteEntry.ire_dest = DEFAULT_DEST;
    RouteEntry.ire_index = AddrTable[MatchIndex].iae_index;
    RouteEntry.ire_metric1 = DEFAULT_METRIC;
    RouteEntry.ire_metric2 = (DWORD)(-1);
    RouteEntry.ire_metric3 = (DWORD)(-1);
    RouteEntry.ire_metric4 = (DWORD)(-1);
    RouteEntry.ire_nexthop = GatewayAddress;
    RouteEntry.ire_type = Type;
    RouteEntry.ire_proto = IRE_PROTO_NETMGMT;
    RouteEntry.ire_age = 0;
    RouteEntry.ire_mask = DEFAULT_DEST_MASK;
    RouteEntry.ire_metric5 = (DWORD)(-1);
    RouteEntry.ire_context = 0;

    Size = sizeof(RouteEntry);

    ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

    Status = IopTCPSetInformationEx(
                Handle,
                &ID,
                &RouteEntry,
                Size );

    if (!NT_SUCCESS(Status)) {
        KdPrint(( "IopSetDefaultGateway: Unable to set default gateway: %x\n", Status ));
    }

    NtClose(Handle);

    Handle = NULL;

Cleanup:

    if (Handle != NULL) {
        NtClose(Handle);
    }

    if( AddrTable != NULL ) {
        ExFreePool( AddrTable );
    }

    return Status;
}


__inline long
htonl(long x)
{
        return((((x) >> 24) & 0x000000FFL) |
           (((x) >>  8) & 0x0000FF00L) |
           (((x) <<  8) & 0x00FF0000L) |
           (((x) << 24) & 0xFF000000L));
}

NTSTATUS
IopCacheNetbiosNameForIpAddress(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function takes an IP address, and submits it to NetBt for name resolution.

Arguments:

    IpAddress - Address to resolve

Return Value:

    Error Code.

--*/
{
    NTSTATUS Status;
    HANDLE Handle = NULL;
    BYTE Context[CONTEXT_SIZE];
    DWORD Size;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK ioStatusBlock;
    tREMOTE_CACHE cacheInfo;
    PCHAR serverName;
    PCHAR endOfServerName;
    HANDLE EventHandle;

    //
    // Open NetBT.
    //

    RtlInitUnicodeString(
        &NameString,
        L"\\Device\\NetBT_Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
        );

    InitializeObjectAttributes(
        &objectAttributes,
        &NameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(Status) ) {
        KdPrint(( "IopCacheNetbiosNameForIpAddress: Unable to open NETBT: %x\n", Status ));
        return Status;
    }

    //
    // Get the server's name.
    //
    // If this is a remote boot setup boot, NtBootPathName is of the
    // form \<server>\<share>\setup\<install-directory>\<platform>.
    // If this is a normal remote boot, NtBootPathName is of the form
    // \<server>\<share>\images\<machine>\winnt.
    //
    // Thus in either case, we need to isolate the first element of the
    // path.
    //

    serverName = LoaderBlock->NtBootPathName;
    if ( *serverName == '\\' ) {
        serverName++;
    }
    endOfServerName = strchr( serverName, '\\' );
    if ( endOfServerName == NULL ) {
        endOfServerName = strchr( serverName, '\0' );
    }

    //
    // Fill in the tREMOTE_CACHE structure.
    //

    memset(&cacheInfo, 0x0, sizeof(cacheInfo));

    memset(cacheInfo.name, ' ', NETBIOS_NAMESIZE);
    ASSERT(NETBIOS_NAMESIZE >= (ULONG)(endOfServerName - serverName));
    memcpy(
        cacheInfo.name, 
        serverName, 
        min(
          (ULONG)(endOfServerName - serverName),
          NETBIOS_NAMESIZE));
    cacheInfo.IpAddress = htonl(LoaderBlock->SetupLoaderBlock->ServerIpAddress);
    cacheInfo.Ttl = MAXULONG;

    //
    // Submit the IOCTL.
    //

    Status = NtCreateEvent( 
                    &EventHandle,
                    EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE );
    if ( !NT_SUCCESS(Status) ) {
        KdPrint(( "IopCacheNetbiosNameForIpAddress: Unable to createevent: %x\n", Status ));
        NtClose(Handle);
        return(Status);
    }

    Status = NtDeviceIoControlFile(
               Handle,
               EventHandle,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_NETBT_ADD_TO_REMOTE_TABLE,
               &cacheInfo,
               sizeof(cacheInfo),
               Context,
               sizeof(Context)
               );

    if (Status == STATUS_PENDING) {
        NtWaitForSingleObject(
                EventHandle,
                FALSE,
                NULL);

        Status = ioStatusBlock.Status;
    }
    
    if ( NT_SUCCESS(Status) ) {
        Status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(Status) ) {
        KdPrint(( "IopCacheNetbiosNameForIpAddress: Adapter status failed: %x\n", Status ));
    }

    NtClose(Handle);
    NtClose(EventHandle);

    return Status;
}


NTSTATUS
IopTCPQueryInformationEx(
    IN HANDLE                 TCPHandle,
    IN TDIObjectID FAR       *ID,
    OUT void FAR             *Buffer,
    IN OUT DWORD FAR         *BufferSize,
    IN OUT BYTE FAR          *Context
    )
/*++

Routine Description:

    This routine provides the interface to the TDI QueryInformationEx
    facility of the TCP/IP stack on NT. Someday, this facility will be
    part of TDI.

Arguments:

    TCPHandle     - Open handle to the TCP driver
    ID            - The TDI Object ID to query
    Buffer        - Data buffer to contain the query results
    BufferSize    - Pointer to the size of the results buffer. Filled in
                    with the amount of results data on return.
    Context       - Context value for the query. Should be zeroed for a
                    new query. It will be filled with context
                    information for linked enumeration queries.

Return Value:

    An NTSTATUS value.

--*/

{
    TCP_REQUEST_QUERY_INFORMATION_EX   queryBuffer;
    DWORD                              queryBufferSize;
    NTSTATUS                           status;
    IO_STATUS_BLOCK                    ioStatusBlock;
    HANDLE EventHandle = NULL;


    if (TCPHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    queryBufferSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    memcpy(&(queryBuffer.ID), ID, sizeof(TDIObjectID));
    memcpy(&(queryBuffer.Context), Context, CONTEXT_SIZE);

    status = NtCreateEvent( 
                        &EventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE );
    
    if (!NT_SUCCESS(status)) {
        return(status);
    }

    status = NtDeviceIoControlFile(
                 TCPHandle,                       // Driver handle
                 EventHandle,                     // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IOCTL_TCP_QUERY_INFORMATION_EX,  // Control code
                 &queryBuffer,                    // Input buffer
                 queryBufferSize,                 // Input buffer size
                 Buffer,                          // Output buffer
                 *BufferSize                      // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        NtWaitForSingleObject(
            EventHandle,
            FALSE,
            NULL);

        status = ioStatusBlock.Status;
    }
    
    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if (status == STATUS_SUCCESS) {
        //
        // Copy the return context to the caller's context buffer
        //
        memcpy(Context, &(queryBuffer.Context), CONTEXT_SIZE);
        *BufferSize = (ULONG)ioStatusBlock.Information;
        status = ioStatusBlock.Status;
    } else {
        *BufferSize = 0;
    }

    NtClose(EventHandle);

    return(status);
}


NTSTATUS
IopTCPSetInformationEx(
    IN HANDLE             TCPHandle,
    IN TDIObjectID FAR   *ID,
    IN void FAR          *Buffer,
    IN DWORD FAR          BufferSize
    )
/*++

Routine Description:

    This routine provides the interface to the TDI SetInformationEx
    facility of the TCP/IP stack on NT. Someday, this facility will be
    part of TDI.

Arguments:

    TCPHandle     - Open handle to the TCP driver
    ID            - The TDI Object ID to set
    Buffer        - Data buffer containing the information to be set
    BufferSize    - The size of the set data buffer.

Return Value:

    An NTSTATUS value.

--*/

{
    PTCP_REQUEST_SET_INFORMATION_EX    setBuffer;
    NTSTATUS                           status;
    IO_STATUS_BLOCK                    ioStatusBlock;
    DWORD                              setBufferSize;
    HANDLE                             EventHandle;


    if (TCPHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    setBufferSize = FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) + BufferSize;

    setBuffer = ExAllocatePoolWithTag(PagedPool, setBufferSize, 'bRoI');

    if (setBuffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    setBuffer->BufferSize = BufferSize;

    memcpy(&(setBuffer->ID), ID, sizeof(TDIObjectID));

    memcpy(&(setBuffer->Buffer[0]), Buffer, BufferSize);

    status = NtCreateEvent( 
                        &EventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE );
    
    if (!NT_SUCCESS(status)) {
        ExFreePool(setBuffer);
        return(status);
    }

    status = NtDeviceIoControlFile(
                 TCPHandle,                       // Driver handle
                 EventHandle,                     // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IOCTL_TCP_SET_INFORMATION_EX,    // Control code
                 setBuffer,                       // Input buffer
                 setBufferSize,                   // Input buffer size
                 NULL,                            // Output buffer
                 0                                // Output buffer size
                 );


    if (status == STATUS_PENDING) {
        NtWaitForSingleObject(
            EventHandle,
            FALSE,
            NULL);
    
        status = ioStatusBlock.Status;
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    NtClose(EventHandle);

    ExFreePool(setBuffer);

    return(status);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma  const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iovutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iovutil.h

Abstract:

    This header exposes various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.h

--*/

typedef enum {

    DATABASELOCKSTATE_HELD,
    DATABASELOCKSTATE_NOT_HELD

} DATABASELOCKSTATE;

typedef enum  {

    DEVOBJ_RELATION_IDENTICAL,
    DEVOBJ_RELATION_FIRST_IMMEDIATELY_ABOVE_SECOND,
    DEVOBJ_RELATION_FIRST_IMMEDIATELY_BELOW_SECOND,
    DEVOBJ_RELATION_FIRST_ABOVE_SECOND,
    DEVOBJ_RELATION_FIRST_BELOW_SECOND,
    DEVOBJ_RELATION_NOT_IN_SAME_STACK

} DEVOBJ_RELATION, *PDEVOBJ_RELATION;

typedef enum {

    MARKTYPE_DELETED,
    MARKTYPE_BOTTOM_OF_FDO_STACK,
    MARKTYPE_DESIGNATED_FDO,
    MARKTYPE_RAW_PDO,
    MARKTYPE_DEVICE_CHECKED,
    MARKTYPE_RELATION_PDO_EXAMINED

} MARK_TYPE;

VOID
FASTCALL
IovUtilInit(
    VOID
    );

VOID
FASTCALL
IovUtilGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  UpperDeviceObject,
    OUT PDEVICE_OBJECT  *LowerDeviceObject
    );

VOID
FASTCALL
IovUtilGetBottomDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PDEVICE_OBJECT  *BottomDeviceObject
    );

VOID
FASTCALL
IovUtilGetUpperDeviceObject(
    IN  PDEVICE_OBJECT  LowerDeviceObject,
    OUT PDEVICE_OBJECT  *UpperDeviceObject
    );

BOOLEAN
FASTCALL
IovUtilIsVerifiedDeviceStack(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
FASTCALL
IovUtilFlushVerifierDriverListCache(
    VOID
    );

VOID
FASTCALL
IovUtilFlushStackCache(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  DATABASELOCKSTATE   DatabaseLockState
    );

VOID
IovUtilRelateDeviceObjects(
    IN     PDEVICE_OBJECT   FirstDeviceObject,
    IN     PDEVICE_OBJECT   SecondDeviceObject,
    OUT    DEVOBJ_RELATION  *DeviceObjectRelation
    );

BOOLEAN
IovUtilIsPdo(
    IN  PDEVICE_OBJECT  DeviceObject
    );

BOOLEAN
IovUtilIsWdmStack(
    IN  PDEVICE_OBJECT  DeviceObject
    );

BOOLEAN
FASTCALL
IovUtilHasDispatchHandler(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  UCHAR           MajorFunction
    );

BOOLEAN
FASTCALL
IovUtilIsInFdoStack(
    IN PDEVICE_OBJECT   DeviceObject
    );

BOOLEAN
FASTCALL
IovUtilIsRawPdo(
    IN  PDEVICE_OBJECT  DeviceObject
    );

BOOLEAN
FASTCALL
IovUtilIsDesignatedFdo(
    IN  PDEVICE_OBJECT  DeviceObject
    );

VOID
FASTCALL
IovUtilMarkDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  MARK_TYPE       MarkType
    );

BOOLEAN
FASTCALL
IovUtilIsDeviceObjectMarked(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  MARK_TYPE       MarkType
    );

VOID
FASTCALL
IovUtilMarkStack(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  PDEVICE_OBJECT  BottomOfFdoStack        OPTIONAL,
    IN  PDEVICE_OBJECT  FunctionalDeviceObject  OPTIONAL,
    IN  BOOLEAN         RawStack
    );

VOID
FASTCALL
IovUtilWatermarkIrp(
    IN  PIRP    Irp,
    IN  ULONG   Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=io

TARGETNAME=io
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc;          \
         ..\pnpmgr;             \
         ..\..\pnp;             \
         $(DDK_INC_PATH);       \
         $(NET_INC_PATH);       \
         $(HALKIT_INC_PATH)

SOURCES= \
        ..\ioguid.c   \
        ..\iovutil.c  \
        ..\netboot.c  \
        ..\sessnirp.c \
        ..\trackirp.c

NTTEST=
OPTIONAL_NTTEST=tio

PRECOMPILED_INCLUDE=..\iop.h
PRECOMPILED_PCH=iop.pch
PRECOMPILED_OBJ=iop.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\sessnirp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sessnirp.h

Abstract:

Author:

    Adrian J. Oney (adriao) 11-Feb-1999

Revision History:


--*/


#ifndef _SESSIONIRP_H_
#define _SESSIONIRP_H_

PIOV_SESSION_DATA
FASTCALL
IovpSessionDataCreate(
    IN      PDEVICE_OBJECT       DeviceObject,
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    OUT     PBOOLEAN             SurrogateSpawned
    );

VOID
FASTCALL
IovpSessionDataAdvance(
    IN      PDEVICE_OBJECT       DeviceObject,
    IN      PIOV_SESSION_DATA    IovSessionData,
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    OUT     PBOOLEAN             SurrogateSpawned
    );

VOID
FASTCALL
IovpSessionDataReference(
    IN      PIOV_SESSION_DATA IovSessionData
    );

VOID
FASTCALL
IovpSessionDataDereference(
    IN      PIOV_SESSION_DATA IovSessionData
    );

VOID
FASTCALL
IovpSessionDataClose(
    IN      PIOV_SESSION_DATA IovSessionData
    );

VOID
IovpSessionDataDeterminePolicy(
    IN      PIOV_REQUEST_PACKET IovRequestPacket,
    IN      PDEVICE_OBJECT      DeviceObject,
    OUT     PBOOLEAN            Trackable,
    OUT     PBOOLEAN            UseSurrogateIrp
    );

BOOLEAN
FASTCALL
IovpSessionDataAttachSurrogate(
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    IN      PIOV_SESSION_DATA    IovSessionData
    );

VOID
FASTCALL
IovpSessionDataFinalizeSurrogate(
    IN      PIOV_SESSION_DATA    IovSessionData,
    IN OUT  PIOV_REQUEST_PACKET  IovPacket,
    IN      PIRP                 Irp
    );

VOID
FASTCALL
IovpSessionDataBufferIO(
    IN OUT  PIOV_REQUEST_PACKET  IovSurrogatePacket,
    IN      PIRP                 SurrogateIrp
    );

VOID
FASTCALL
IovpSessionDataUnbufferIO(
    IN OUT  PIOV_REQUEST_PACKET  IovSurrogatePacket,
    IN      PIRP                 SurrogateIrp
    );

#endif // _SESSIONIRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\trackirp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trackirp.h

Abstract:

    The module associated with the header asserts Irps are handled correctly
    by drivers. No IRP-major specific testing is done;

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Revision History:


--*/

#ifndef _TRACKIRP_H_
#define _TRACKIRP_H_

#if DBG
extern ULONG IovpIrpTrackingSpewLevel;
#endif

#define IRP_DIAG_HAS_SURROGATE         0x02000000
#define IRP_DIAG_IS_SURROGATE          0x01000000


//#define TRACKFLAG_ACTIVE               0x00000001
#define TRACKFLAG_SURROGATE            0x00000002
#define TRACKFLAG_HAS_SURROGATE        0x00000004
#define TRACKFLAG_PROTECTEDIRP         0x00000008

#define TRACKFLAG_QUEUED_INTERNALLY    0x00000010
#define TRACKFLAG_BOGUS                0x00000020
#define TRACKFLAG_RELEASED             0x00000040
#define TRACKFLAG_SRB_MUNGED           0x00000080
#define TRACKFLAG_SWAPPED_BACK         0x00000100
#define TRACKFLAG_DIRECT_BUFFERED      0x00000200
#define TRACKFLAG_WATERMARKED          0x00100000
#define TRACKFLAG_IO_ALLOCATED         0x00200000
#define TRACKFLAG_UNWOUND_BADLY        0x00400000
#define TRACKFLAG_PASSED_AT_BAD_IRQL   0x02000000
#define TRACKFLAG_IN_TRANSIT           0x40000000

#define STACKFLAG_NO_HANDLER           0x80000000
#define STACKFLAG_REQUEST_COMPLETED    0x40000000
#define STACKFLAG_CHECK_FOR_REFERENCE  0x20000000
#define STACKFLAG_REACHED_PDO          0x10000000
#define STACKFLAG_FIRST_REQUEST        0x08000000
#define STACKFLAG_UNWOUND_PENDING      0x04000000
#define STACKFLAG_FAILURE_FORWARDED    0x02000000
#define STACKFLAG_BOGUS_IRP_TOUCHED    0x01000000

#define CALLFLAG_STACK_DATA_ALLOCATED  0x80000000
#define CALLFLAG_COMPLETED             0x40000000
#define CALLFLAG_IS_REMOVE_IRP         0x20000000
#define CALLFLAG_REMOVING_FDO_STACK_DO 0x10000000
#define CALLFLAG_OVERRIDE_STATUS       0x08000000
#define CALLFLAG_TOPMOST_IN_SLOT       0x04000000
#define CALLFLAG_MARKED_PENDING        0x02000000
#define CALLFLAG_ARRIVED_PENDING       0x01000000

#define ALLOCFLAG_PROTECTEDIRP         0x00000001

#define SESSIONFLAG_UNWOUND_INCONSISTANT    0x00000001
#define SESSIONFLAG_MARKED_INCONSISTANT     0x00000002

#define IRP_SYSTEM_RESTRICTED          0x00000001
#define IRP_BOGUS                      0x00000002

#define SL_NOTCOPIED                   0x10

#define IRP_ALLOCATION_MONITORED       0x80

#define STARTED_TOP_OF_STACK        1
#define FORWARDED_TO_NEXT_DO        2
#define SKIPPED_A_DO                3
#define STARTED_INSIDE_STACK        4
#define CHANGED_STACKS_AT_BOTTOM    5
#define CHANGED_STACKS_MID_STACK    6

typedef enum {

    DEFERACTION_QUEUE_WORKITEM,
    DEFERACTION_QUEUE_PASSIVE_TIMER,
    DEFERACTION_QUEUE_DISPATCH_TIMER,
    DEFERACTION_NORMAL

} DEFER_ACTION;

typedef struct _DEFERRAL_CONTEXT {

    PIOV_REQUEST_PACKET     IovRequestPacket;
    PIO_COMPLETION_ROUTINE  OriginalCompletionRoutine;
    PVOID                   OriginalContext;
    PIRP                    OriginalIrp;
    CCHAR                   OriginalPriorityBoost;
    PDEVICE_OBJECT          DeviceObject;
    PIO_STACK_LOCATION      IrpSpNext;
    WORK_QUEUE_ITEM         WorkQueueItem;
    KDPC                    DpcItem;
    KTIMER                  DeferralTimer;
    DEFER_ACTION            DeferAction;

} DEFERRAL_CONTEXT, *PDEFERRAL_CONTEXT;

//
// These are in trackirp.c
//

VOID
FASTCALL
IovpPacketFromIrp(
    IN  PIRP                Irp,
    OUT PIOV_REQUEST_PACKET *IovPacket
    );

BOOLEAN
FASTCALL
IovpCheckIrpForCriticalTracking(
    IN  PIRP                Irp
    );

VOID
FASTCALL
IovpCallDriver1(
    IN     PDEVICE_OBJECT               DeviceObject,
    IN OUT PIRP                        *IrpPointer,
    IN OUT PIOFCALLDRIVER_STACKDATA     IofCallDriverStackData  OPTIONAL,
    IN     PVOID                        CallerAddress
    );

VOID
FASTCALL
IovpCallDriver2(
    IN     PDEVICE_OBJECT               DeviceObject,
    IN OUT NTSTATUS                    *FinalStatus,
    IN     PIOFCALLDRIVER_STACKDATA     IofCallDriverStackData  OPTIONAL
    );

VOID
FASTCALL
IovpCompleteRequest1(
    IN     PIRP               Irp,
    IN     CCHAR              PriorityBoost,
    IN OUT PIOFCOMPLETEREQUEST_STACKDATA CompletionPacket
    );

VOID
FASTCALL
IovpCompleteRequest2(
    IN     PIRP               Irp,
    IN OUT PIOFCOMPLETEREQUEST_STACKDATA CompletionPacket
    );

VOID
FASTCALL
IovpCompleteRequest3(
    IN     PIRP               Irp,
    IN     PVOID              Routine,
    IN OUT PIOFCOMPLETEREQUEST_STACKDATA CompletionPacket
    );

VOID
FASTCALL
IovpCompleteRequest4(
    IN     PIRP               Irp,
    IN     NTSTATUS           ReturnedStatus,
    IN OUT PIOFCOMPLETEREQUEST_STACKDATA CompletionPacket
    );

VOID
FASTCALL
IovpCompleteRequest5(
    IN     PIRP               Irp,
    IN OUT PIOFCOMPLETEREQUEST_STACKDATA CompletionPacket
    );

VOID
FASTCALL
IovpCompleteRequestApc(
    IN     PIRP               Irp,
    IN     PVOID              BestStackOffset
    );

VOID
FASTCALL
IovpCancelIrp(
    IN     PIRP               Irp,
    IN OUT PBOOLEAN           CancelHandled,
    IN OUT PBOOLEAN           ReturnValue
    );

VOID
IovpExamineIrpStackForwarding(
    IN OUT  PIOV_REQUEST_PACKET  IovPacket,
    IN      BOOLEAN              IsNewSession,
    IN      ULONG                ForwardMethod,
    IN      PDEVICE_OBJECT       DeviceObject,
    IN      PIRP                 Irp,
    IN      PVOID                CallerAddress,
    IN OUT  PIO_STACK_LOCATION  *IoCurrentStackLocation,
    OUT     PIO_STACK_LOCATION  *IoLastStackLocation,
    OUT     ULONG               *StackLocationsAdvanced
    );

NTSTATUS
IovpSwapSurrogateIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
FASTCALL
IovpExamineDevObjForwarding(
    IN  PDEVICE_OBJECT DeviceBeingCalled,
    IN  PDEVICE_OBJECT DeviceLastCalled,
    OUT PULONG         ForwardingTechnique
    );

VOID
FASTCALL
IovpFinalizeIrpSettings(
    IN OUT PIOV_REQUEST_PACKET   IrpTrackingData,
    IN BOOLEAN                   SurrogateIrpSwapped
    );

NTSTATUS
IovpInternalCompletionTrap(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IovpInternalDeferredCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
IovpInternalCompleteAfterWait(
    IN PVOID Context
    );

VOID
IovpInternalCompleteAtDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
IovpAdvanceStackDownwards(
    IN  PIOV_STACK_LOCATION   StackDataArray,
    IN  CCHAR                 CurrentLocation,
    IN  PIO_STACK_LOCATION    IrpSp,
    IN  PIO_STACK_LOCATION    IrpLastSp OPTIONAL,
    IN  ULONG                 LocationsAdvanced,
    IN  BOOLEAN               IsNewRequest,
    IN  BOOLEAN               MarkAsTaken,
    OUT PIOV_STACK_LOCATION   *StackLocationInfo
    );

VOID
IovpBuildMiniIrpSnapshot(
    IN  PIRP                Irp,
    OUT IRP_MINI_SNAPSHOT   *IrpSnapshot
    );

#define SPECIALIRP_MARK_NON_TRACKABLE(Irp) { \
    (Irp)->Flags |= IRPFLAG_EXAMINE_NOT_TRACKED; \
}

#define SPECIALIRP_IOF_COMPLETE_1(Irp, PriorityBoost, CompletionPacket) \
{\
    IovpCompleteRequest1((Irp), (PriorityBoost), (CompletionPacket));\
}

#define SPECIALIRP_IOF_COMPLETE_2(Irp, CompletionPacket) \
{\
    IovpCompleteRequest2((Irp), (CompletionPacket));\
}

#define SPECIALIRP_IOF_COMPLETE_3(Irp, Routine, CompletionPacket) \
{\
    IovpCompleteRequest3((Irp), (Routine), (CompletionPacket));\
}

#define SPECIALIRP_IOF_COMPLETE_4(Irp, ReturnedStatus, CompletionPacket) \
{\
    IovpCompleteRequest4((Irp), (ReturnedStatus), (CompletionPacket));\
}

#define SPECIALIRP_IOF_COMPLETE_5(Irp, CompletionPacket) \
{\
    IovpCompleteRequest5((Irp), (CompletionPacket));\
}

#define SPECIALIRP_IO_CANCEL_IRP(Irp, CancelHandled, ReturnValue) \
{\
    IovpCancelIrp((Irp), (CancelHandled), (ReturnValue));\
}

#define SPECIALIRP_WATERMARK_IRP(Irp, Flags) \
{\
    IovUtilWatermarkIrp(Irp, Flags);\
}

#define SPECIALIRP_IOP_COMPLETE_REQUEST(Irp, StackPointer) \
{\
    IovpCompleteRequestApc(Irp, StackPointer);\
}

#if DBG
#define TRACKIRP_DBGPRINT(txt,level) \
{ \
    if (IovpIrpTrackingSpewLevel>(level)) { \
        DbgPrint##txt ; \
    }\
}
#else
#define TRACKIRP_DBGPRINT(txt,level)
#endif

#endif // _TRACKIRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\trackirp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    trackirp.c

Abstract:

    This module tracks irps and verified drivers when people do bad things with
    them.

    Note to people hitting bugs in these code paths due to core changes:

    -   "This file is NOT vital to operation of the OS, and could easily be
         disabled while a redesign to compensate for the core change is
         implemented." - the author

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

--*/

#include "iop.h"
#include "pnpi.h"
#include "arbiter.h"
#include "dockintf.h"
#include "pnprlist.h"
#include "pnpiop.h"

#if (( defined(_X86_) ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

#define POOL_TAG_DEFERRED_CONTEXT   'dprI'

//
// This entire file is only present if NO_SPECIAL_IRP isn't defined
//
#ifndef NO_SPECIAL_IRP

//
// When enabled, everything is locked down on demand...
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, IovpPacketFromIrp)
#pragma alloc_text(PAGEVRFY, IovpCheckIrpForCriticalTracking)
#pragma alloc_text(PAGEVRFY, IovpCallDriver1)
#pragma alloc_text(PAGEVRFY, IovpCallDriver2)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest1)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest2)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest3)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest4)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest5)
#pragma alloc_text(PAGEVRFY, IovpCompleteRequest)
#pragma alloc_text(PAGEVRFY, IovpCancelIrp)
#pragma alloc_text(PAGEVRFY, IovpInternalCompletionTrap)
#pragma alloc_text(PAGEVRFY, IovpSwapSurrogateIrp)
#pragma alloc_text(PAGEVRFY, IovpExamineDevObjForwarding)
#pragma alloc_text(PAGEVRFY, IovpExamineIrpStackForwarding)
#pragma alloc_text(PAGEVRFY, IovpInternalDeferredCompletion)
#pragma alloc_text(PAGEVRFY, IovpInternalCompleteAfterWait)
#pragma alloc_text(PAGEVRFY, IovpInternalCompleteAtDPC)
#pragma alloc_text(PAGEVRFY, IovpAdvanceStackDownwards)
#pragma alloc_text(PAGEVRFY, IovpBuildMiniIrpSnapshot)
#endif

//
// This counter is used in picking random IRPs to cancel
//
ULONG IovpCancelCount = 0;

//
// Debug spew level
//
#if DBG
ULONG IovpIrpTrackingSpewLevel = 0;
#endif

/*
 * - The IRP verification code works as follows -
 *
 * To enforce the correct handling of an IRP, we must maintain some data about
 * it. But the IRP is a public structure and as drivers are allowed to create
 * IRPs without using IoAllocateIrp we cannot add any fields to it. Therefore
 * we maintain out own side structures that are looked up via a hash table.
 *
 * IOV_REQUEST_PACKETs cover the lifetime of the IRP from allocation to
 * deallocation, and from there (sans pointer) until all "references" have
 * been dropped, which may happen long after the IRP itself was freed and
 * recycled.
 *
 * When an IRP is progress down a stack, a "session" is allocated. An
 * IovRequestPacket has a current session until such time as the IRP is
 * completed. The session still exists until all references are dropped, but
 * before that happens a new session may become the current session (ie the IRP
 * was sent back down before the previous call stacks unwound). The tracking
 * data is held around until all sessions have decayed.
 *
 * Each session has an array of stack locations corresponding to those in use
 * by the IRP. These IOV_STACK_LOCATIONs are used to track "requests" within
 * the IRP, ie the passage of a major/minor/parameter set down the stack.
 * Of course multiple requests may exist in the same session/stack at once.
 *
 * Finally, surrogates. The IoVerifier may "switch" the IRP in use as it goes
 * down the stack. In this case the new IRP is usually allocated from the
 * special pool and freed as early as possible to catch bugs (people who touch
 * after completes). Each surrogate gets it's own IovRequestPacket, which is
 * linked to the previous surrogate or real irp in use prior to it.
 *
 *   +--------------------+                     +--------------------+
 *   | IOV_REQUEST_PACKET |                     | IOV_REQUEST_PACKET |
 *   |   (original irp)   |<--------------------|    (surrogate)     |
 *   |                    |                     |                    |
 *   +--------------------+                     +--------------------+
 *                 ||
 *                 v
 *    +-------------------+       +-------------------------+
 *    | IOV_SESSION_DATA  |       | IOV_STACK_LOCATION[...] |
 *    | (current session) |------>|    (per IrpSp data)     |
 *    |                   |       |                         |
 *    +-------------------+       +-------------------------+
 *
 */

/*
 * The routines listed below -
 *   IovpCallDriver1
 *   IovpCallDriver2
 *   IovpCompleteRequest1
 *   IovpCompleteRequest2
 *   IovpCompleteRequest3
 *   IovpCompleteRequest4
 *   IovpCompleteRequest5
 *   IovpCompleteRequest
 *   IovpCancelIrp
 * and their helper routines
 *   IovpSwapSurrogateIrp
 *   IovpPacketFromIrp
 *
 * - all hook into various parts IofCallDriver and IofCompleteRequest to
 * track the IRP through it's life and determine whether it has been handled
 * correctly. Some of them may even change internal variables in the hooked
 * function. Most dramatically, IovpCallDriver1 may build a replacement Irp
 * which will take the place of the one passed into IoCallDriver.
 *
 *   All of the below functions use a tracking structure called (reasonably
 * enough) IRP_TRACKING_DATA. This lasts the longer of the call stack
 * unwinding or the IRP completing.
 *
 */


VOID
FASTCALL
IovpPacketFromIrp(
    IN  PIRP                Irp,
    OUT PIOV_REQUEST_PACKET *IovPacket
    )
{
    //
    // The examined flag is set on any IRP that has come through
    // IofCallDriver. We use the flag to detect whether we have seen the IRP
    // before.
    //
    switch(Irp->Flags&IRPFLAG_EXAMINE_MASK) {

        case IRPFLAG_EXAMINE_NOT_TRACKED:

            //
            // This packet is marked do not touch. So we ignore it.
            //
            *IovPacket = NULL;
            return;

        case IRPFLAG_EXAMINE_TRACKED:

            //
            // This packet has been marked. We should find it.
            //
            *IovPacket = VfPacketFindAndLock(Irp);
            ASSERT(*IovPacket != NULL);
            return;

        case IRPFLAG_EXAMINE_UNMARKED:

            *IovPacket = VfPacketFindAndLock(Irp);
            if (*IovPacket) {

                //
                // Was tracked but cache flag got wiped. Replace.
                //
                Irp->Flags |= IRPFLAG_EXAMINE_TRACKED;

            } else if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_TRACK_IRPS)) {

                //
                // Create the packet
                //
                *IovPacket = VfPacketCreateAndLock(Irp);
                if (*IovPacket) {

                    //
                    // Mark it
                    //
                    Irp->Flags |= IRPFLAG_EXAMINE_TRACKED;
                } else {

                    //
                    // No memory, try to keep it out of the IRP assert though.
                    //
                    Irp->Flags |= IRPFLAG_EXAMINE_NOT_TRACKED;
                }
            } else {

                //
                // Do as told, don't track through IofCallDriver.
                //
                Irp->Flags |= IRPFLAG_EXAMINE_NOT_TRACKED;
            }
            return;

        default:
            ASSERT(0);
            *IovPacket = NULL;
            return;
    }
}


BOOLEAN
FASTCALL
IovpCheckIrpForCriticalTracking(
    IN  PIRP                Irp
    )
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;

    switch(Irp->Flags&IRPFLAG_EXAMINE_MASK) {

        case IRPFLAG_EXAMINE_NOT_TRACKED:

            //
            // Noncritical, we can avoid tracking this if memory is tight.
            //
            return FALSE;

        case IRPFLAG_EXAMINE_TRACKED:

            //
            // Might be critical.
            //
            iovPacket = VfPacketFindAndLock(Irp);

            ASSERT(iovPacket);

            if (iovPacket == NULL) {

                return FALSE;
            }

            break;

        case IRPFLAG_EXAMINE_UNMARKED:

            iovPacket = VfPacketFindAndLock(Irp);

            if (iovPacket) {

                //
                // Was tracked but cache flag got wiped. Replace.
                //
                Irp->Flags |= IRPFLAG_EXAMINE_TRACKED;
                break;
            }

            //
            // Noncritical.
            //
            Irp->Flags |= IRPFLAG_EXAMINE_NOT_TRACKED;
            return FALSE;

        default:
            ASSERT(0);
            return FALSE;
    }

    //
    // Look for a session. This IRP is critical if it's already in play.
    //
    iovSessionData = VfPacketGetCurrentSessionData(iovPacket);

    VfPacketReleaseLock(iovPacket);
    return (iovSessionData != NULL);
}


VOID
FASTCALL
IovpCallDriver1(
    IN      PDEVICE_OBJECT              DeviceObject,
    IN OUT  PIRP                       *IrpPointer,
    IN OUT  PIOFCALLDRIVER_STACKDATA    IofCallDriverStackData  OPTIONAL,
    IN      PVOID                       CallerAddress           OPTIONAL
    )
/*++

  Description:

    This routine is called by IofCallDriver just before adjusting
    the IRP stack and calling the driver's dispatch routine.

  Arguments:

    DeviceObject           - Device object passed into IofCallDriver.

    IrpPointer             - a pointer* to the IRP passed in to
                             IofCallDriver. This routine may
                             change the pointer if a surrogate
                             IRP is allocated.

    IofCallDriverStackData - Pointer to a local variable on
                             IofCallDriver's stack to store data.
                             The stored information will be picked
                             up by IovpCallDriver2, and
                             may be adjusted at other times.

    CallerAddress          - Address of the caller. May be NULL in cases where
                             the caller is unknown.

  Return Value:

     None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    PIOV_STACK_LOCATION iovCurrentStackLocation;
    PIRP irp, replacementIrp;
    PIO_STACK_LOCATION irpSp, irpLastSp;
    BOOLEAN isNewSession, isNewRequest, previouslyInUse, surrogateSpawned;
    ULONG isSameStack;
    ULONG locationsAdvanced, completeStyle;
    PDEVICE_OBJECT pdo, lowerDeviceObject;
    PDRIVER_OBJECT driverObject;
    PVOID dispatchRoutine;
    LARGE_INTEGER arrivalTime;
    KIRQL invocationIrql;

    if (IofCallDriverStackData == NULL) {

        //
        // Nothing to track.
        //
        return;
    }

    irp = *IrpPointer;
    irpSp = IoGetNextIrpStackLocation( irp );
    invocationIrql = KeGetCurrentIrql();

    //
    // Get a verifier packet for the IRP. Note that we come back at dispatch
    // level with a lock held if a packet was available.
    //
    IovpPacketFromIrp(irp, &iovPacket);
    if (iovPacket == NULL) {

        //
        // Nothing to track, get out.
        //
        return;
    }

    //
    // Set the arrival and departure Irqls (note that future code will make the
    // arrival irql different for PoCallDriver.)
    //
    iovPacket->ArrivalIrql = invocationIrql;
    iovPacket->DepartureIrql = invocationIrql;

    //
    // Snapshot the arrival time of this IRP.
    //
    KeQuerySystemTime(&arrivalTime);

    //
    // If we are going to die shortly, kindly say so.
    //
    if (DeviceObject == NULL) {

        WDM_FAIL_ROUTINE((
            DCERROR_NULL_DEVOBJ_FORWARDED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }

    //
    // Find the current session. The session terminates when the final top-level
    // completion routine gets called.
    //
    iovSessionData = VfPacketGetCurrentSessionData(iovPacket);

    if (iovSessionData) {

        //
        // Pre-existing session (ie, the IRP is being forwarded.)
        //
        ASSERT(iovPacket->Flags&TRACKFLAG_ACTIVE);
        isNewSession = FALSE;

        IovpSessionDataAdvance(
            DeviceObject,
            iovSessionData,      // This param is optional.
            &iovPacket,
            &surrogateSpawned
            );

    } else if (!(iovPacket->Flags&TRACKFLAG_ACTIVE)){

        //
        // New session. Mark the IRP as "active".
        //
        iovPacket->Flags |= TRACKFLAG_ACTIVE;
        isNewSession = TRUE;

        iovSessionData = IovpSessionDataCreate(
            DeviceObject,
            &iovPacket,
            &surrogateSpawned
            );

    } else {

        //
        // Might hit this path under low memory, or we are tracking allocations
        // but not the IRP sessions themselves.
        //
    }

    //
    // Let IovpCallDriver2 know what it's tracking (IovPacket will be
    // ignored if IovSessionData is NULL)
    //
    IofCallDriverStackData->IovSessionData = iovSessionData;
    IofCallDriverStackData->IovPacket = iovPacket;
    IofCallDriverStackData->DispatchRoutine = DeviceObject->DriverObject->MajorFunction[irpSp->MajorFunction];

    if (iovSessionData == NULL) {

        VfPacketReleaseLock(iovPacket);
        return;
    }

    VfPacketLogEntry(iovPacket, IOV_EVENT_IO_CALL_DRIVER, CallerAddress, 0);

    if (surrogateSpawned) {

        //
        // iovPacket was changed to cover the surrogate IRP. Update our own
        // local variable and IofCallDriver's local variable appropriately.
        //
        irp = iovPacket->TrackedIrp;
        irpSp = IoGetNextIrpStackLocation(irp);
        *IrpPointer = irp;
    }

    if (isNewSession) {

        IovUtilGetBottomDeviceObject(DeviceObject, &pdo);
        VfIrpLogRecordEvent(iovPacket->VerifierSettings, pdo, irp);
        ObDereferenceObject(pdo);
        VfPacketReference(iovPacket, IOVREFTYPE_POINTER);
        IovpSessionDataReference(iovSessionData);
    }

    if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        //
        // If someone has given us an IRP with a cancel routine, beat them. Drivers
        // set cancel routines when they are going to be pending IRPs *themselves*
        // and should remove them before passing the IRP below. This is also true
        // as the driver will *not* call your cancel routine if he writes in his
        // own (which it may). Nor is the lower driver expected to put yours back
        // either...
        //
        if (irp->CancelRoutine) {

            WDM_FAIL_ROUTINE((
                DCERROR_CANCELROUTINE_FORWARDED,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                irp
                ));

            irp->CancelRoutine = NULL;
        }
    }

    //
    // Now do any checking that requires tracking data.
    //
    if (iovPacket->Flags&TRACKFLAG_QUEUED_INTERNALLY) {

        //
        // We internally queue irps to catch bugs. When we are doing this, we
        // force the stack returned status to STATUS_PENDING, and we queue the
        // irp and release it on a timer. We also may make the IRP non-touchable.
        // This particular caller is trying to forward an IRP he doesn't own,
        // and we didn't actually end up with an untouchable irp.
        //
        WDM_FAIL_ROUTINE((
            DCERROR_QUEUED_IRP_FORWARDED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }

    //
    // Figure out how many stack locations we've moved up since we've last seen
    // this IRP, and determine if the stack locations were copied appropriately.
    // We also need to see exactly how the IRP was forwarded (down the stack,
    // to another stack, straight to the PDO, etc).
    //
    IovpExamineDevObjForwarding(
        DeviceObject,
        iovSessionData->DeviceLastCalled,
        &iovSessionData->ForwardMethod
        );

    IovpExamineIrpStackForwarding(
        iovPacket,
        isNewSession,
        iovSessionData->ForwardMethod,
        DeviceObject,
        irp,
        CallerAddress,
        &irpSp,
        &irpLastSp,
        &locationsAdvanced
        );

    TRACKIRP_DBGPRINT((
        "  CD1: Current, Last = (%x, %x)\n",
        irp->CurrentLocation,
        iovPacket->LastLocation
        ), 3);

    //
    // Figure out whether this is a new request or not, and record a
    // pointer in this slot to the requests originating slot as appropriate.
    //
    isNewRequest = VfMajorIsNewRequest(irpLastSp, irpSp);

    //
    // Record information in our private stack locations and
    // write that back into the "stack" data itself...
    //
    previouslyInUse = IovpAdvanceStackDownwards(
        iovSessionData->StackData,
        irp->CurrentLocation,
        irpSp,
        irpLastSp,
        locationsAdvanced,
        isNewRequest,
        TRUE,
        &iovCurrentStackLocation
        );

    ASSERT(iovCurrentStackLocation);

    if (previouslyInUse) {

        ASSERT(!isNewRequest);
        ASSERT(!isNewSession);
        iovCurrentStackLocation->PerfDispatchStart = arrivalTime;

    } else {

        IofCallDriverStackData->Flags |= CALLFLAG_TOPMOST_IN_SLOT;
        InitializeListHead(&IofCallDriverStackData->SharedLocationList);

        iovCurrentStackLocation->PerfDispatchStart = arrivalTime;
        iovCurrentStackLocation->PerfStackLocationStart = arrivalTime;

        //
        // Record the first thread this IRP slot was dispatched to.
        //
        iovCurrentStackLocation->ThreadDispatchedTo = PsGetCurrentThread();
        if (isNewRequest) {

            iovCurrentStackLocation->InitialStatusBlock = irp->IoStatus;
            iovCurrentStackLocation->LastStatusBlock = irp->IoStatus;
            if (isNewSession) {

                iovCurrentStackLocation->Flags |= STACKFLAG_FIRST_REQUEST;
            }
        }
    }

    //
    // Record whether this is the last device object for this IRP...
    // PDO's have devnodes filled out, so look for that field.
    // Actually, we can't quite do that trick as during Bus
    // enumeration a bus filter might be sending down Irps before
    // the OS has ever seen the node. So we assume a devobj is a
    // PDO if he has never attached to anyone.
    //
    IovUtilGetLowerDeviceObject(DeviceObject, &lowerDeviceObject);
    if (lowerDeviceObject) {
        ObDereferenceObject(lowerDeviceObject);
    } else {
        iovCurrentStackLocation->Flags |= STACKFLAG_REACHED_PDO;
    }

    //
    // Record who is getting this IRP (we will blame any mistakes on him
    // if this request gets completed.) Note that we've already asserted
    // DeviceObject is non-NULL...
    //
    driverObject = DeviceObject->DriverObject;
    dispatchRoutine = driverObject->MajorFunction[irpSp->MajorFunction];
    iovCurrentStackLocation->LastDispatch = dispatchRoutine;

    //
    // Uncomplete the request if we are heading back down with it...
    //
    iovCurrentStackLocation->Flags &= ~STACKFLAG_REQUEST_COMPLETED;

    //
    // This IofCallDriver2 dude will need to be told what his status should
    // be later. Add him to the linked list of addresses to scribble away
    // stati when the appropriate level is completed.
    //
    InsertHeadList(
        &iovCurrentStackLocation->CallStackData,
        &IofCallDriverStackData->SharedLocationList
        );

    //
    // More IofCallDriver2 stuff, tell him the stack location.
    //
    IofCallDriverStackData->IovStackLocation = iovCurrentStackLocation;

    //
    // Snapshot the IRP in case we need to give a summary of it even after the
    // IRP has been freed.
    //
    IovpBuildMiniIrpSnapshot(irp, &IofCallDriverStackData->IrpSnapshot);

    //
    // If the IRP has arrived pending, we are probably looking at someone
    // "wrapping" the IoCallDriver and intending to return STATUS_PENDING
    // (PoCallDriver does this). We must remember this, because the unwind
    // should be treated as if STATUS_PENDING was returned.
    //
    if (irpSp->Control & SL_PENDING_RETURNED) {

        IofCallDriverStackData->Flags |= CALLFLAG_ARRIVED_PENDING;
    }

    // If it's a remove IRP, mark everyone appropriately
    if ((irpSp->MajorFunction == IRP_MJ_PNP)&&
        (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE)) {

        IofCallDriverStackData->Flags |= CALLFLAG_IS_REMOVE_IRP;

        IovUtilGetBottomDeviceObject(DeviceObject, &pdo);
        ASSERT(pdo);
        IofCallDriverStackData->RemovePdo = pdo;
        ObDereferenceObject(pdo);
        if (IovUtilIsInFdoStack(DeviceObject) && (!IovUtilIsRawPdo(DeviceObject))) {

            IofCallDriverStackData->Flags |= CALLFLAG_REMOVING_FDO_STACK_DO;
        }
    }

    if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&
        VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_MONITOR_MAJORS)) {

        //
        // Do IRP-major specific assertions as appropriate
        //
        if (isNewSession) {

            VfMajorVerifyNewIrp(
                iovPacket,
                irp,
                irpSp,
                iovCurrentStackLocation,
                CallerAddress
                );
        }

        if (isNewRequest) {

            VfMajorVerifyNewRequest(
                iovPacket,
                DeviceObject,
                irpLastSp,
                irpSp,
                iovCurrentStackLocation,
                CallerAddress
                );
        }

        VfMajorVerifyIrpStackDownward(
            iovPacket,
            DeviceObject,
            irpLastSp,
            irpSp,
            iovCurrentStackLocation,
            CallerAddress
            );
    }

    //
    // Update our fields
    //
    iovSessionData->DeviceLastCalled = DeviceObject;
    iovPacket->LastLocation = irp->CurrentLocation;
    iovCurrentStackLocation->RequestsFirstStackLocation->LastStatusBlock = irp->IoStatus;

    //
    // Dope the next stack location so we can detect usage of
    // IoCopyCurrentIrpStackLocationToNext or IoSetCompletionRoutine.
    //
    if (irp->CurrentLocation>1) {
        IoSetNextIrpStackLocation( irp );
        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->Control |= SL_NOTCOPIED;
        IoSkipCurrentIrpStackLocation( irp );
    }

    //
    // Randomly set the cancel flag on a percentage of forwarded IRPs. Many
    // drivers queue first and after dequeue assume the cancel routine they
    // set must have been cleared if Cancel = TRUE. They don't handle the case
    // were the Irp was cancelled in flight.
    //
    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_RANDOMLY_CANCEL_IRPS) &&
        (!(irp->Flags & IRP_PAGING_IO))) {

        if (((++IovpCancelCount) % 4000) == 0) {

            irp->Cancel = TRUE;
        }
    }

    //
    // Assert LastLocation is consistent with an IRP that may be completed.
    //
    ASSERT(iovSessionData->StackData[iovPacket->LastLocation-1].InUse);

    IovpSessionDataReference(iovSessionData);
    VfPacketReference(iovPacket, IOVREFTYPE_PACKET);
    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
IovpCallDriver2(
    IN      PDEVICE_OBJECT              DeviceObject,
    IN OUT  NTSTATUS                    *FinalStatus,
    IN      PIOFCALLDRIVER_STACKDATA    IofCallDriverStackData  OPTIONAL
    )
/*++

  Description:

    This routine is called by IofCallDriver just after the driver's dispatch
    routine has been called.

  Arguments:

    DeviceObject           - Device object passed into IofCallDriver.

    FinalStatus            - A pointer to the status returned by the dispatch
                             routine. This may be changed if all IRPs are being
                             forced "pending".

    IofCallDriverStackData - Pointer to a local variable on IofCallDriver's
                             stack to retreive data stored by IovpCallDriver1.

  Return Value:

     None.

--*/
{
    NTSTATUS status, lastStatus;
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    ULONG refCount;
    PIOV_STACK_LOCATION iovCurrentStackLocation;
    PPVREMOVAL_OPTION removalOption;
    BOOLEAN pendingReturned;
    PDEVICE_OBJECT lowerDevObj;

    if (IofCallDriverStackData == NULL) {

        return;
    }

    iovSessionData = IofCallDriverStackData->IovSessionData;
    if (iovSessionData == NULL) {

        return;
    }

    iovPacket = IofCallDriverStackData->IovPacket;

    ASSERT(iovPacket);
    VfPacketAcquireLock(iovPacket);

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_CALL_DRIVER_UNWIND,
        IofCallDriverStackData->DispatchRoutine,
        *FinalStatus
        );

    //
    // The IRP should be considered to have had pending returned if it arrived
    // pending or the return status was STATUS_PENDING.
    //
    pendingReturned =
        ((*FinalStatus == STATUS_PENDING) ||
        (IofCallDriverStackData->Flags & CALLFLAG_ARRIVED_PENDING));

    //
    // Also ensure People don't detach/delete on surprise-remove
    //
    if ((IofCallDriverStackData->Flags&CALLFLAG_IS_REMOVE_IRP) &&
        VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings,
        VERIFIER_OPTION_MONITOR_REMOVES)) {

        //
        // Per bad spec, detaching and deleting occurs *after* the IRP is
        // completed.
        //
        if (!pendingReturned) {

            IovUtilGetLowerDeviceObject(DeviceObject, &lowerDevObj);

            //
            // We can look at this because the caller has committed to this being
            // completed now, and we are on the original thread.
            //
            // N.B. This works because all the objects in the stack have been
            // referenced during a remove. If we decide to only reference the
            // top object, this logic would break...
            //
            if (IofCallDriverStackData->Flags&CALLFLAG_REMOVING_FDO_STACK_DO) {

                //
                // FDO, Upper, & Lower filters *must* go. Note that lowerDevObj
                // should be null as we should have detached.
                //
                removalOption = PPVREMOVAL_SHOULD_DELETE;

            } else {

                removalOption = PpvUtilGetDevnodeRemovalOption(
                    IofCallDriverStackData->RemovePdo
                    );
            }

            if (removalOption == PPVREMOVAL_SHOULD_DELETE) {

                //
                // IoDetachDevice and IoDeleteDevice should have been called.
                // First verify IoDetachDevice...
                //
                if (lowerDevObj) {

                    WDM_FAIL_ROUTINE((
                        DCERROR_SHOULDVE_DETACHED,
                        DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                        IofCallDriverStackData->DispatchRoutine,
                        &IofCallDriverStackData->IrpSnapshot,
                        DeviceObject
                        ));
                }

                //
                // Now verify IoDeleteDevice
                //
                if (!IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DELETED)) {

                    WDM_FAIL_ROUTINE((
                        DCERROR_SHOULDVE_DELETED,
                        DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                        IofCallDriverStackData->DispatchRoutine,
                        &IofCallDriverStackData->IrpSnapshot,
                        DeviceObject
                        ));
                }

            } else if (removalOption == PPVREMOVAL_SHOULDNT_DELETE) {

                //
                // Did we mistakenly leave? Verify we aren't a bus filter that
                // has been fooled. In that case, no checking can be done...
                //
                ASSERT(!(IofCallDriverStackData->Flags&CALLFLAG_REMOVING_FDO_STACK_DO));

                if (DeviceObject == IofCallDriverStackData->RemovePdo) {

                    //
                    // Check PDO's - did we mistakenly delete ourselves?
                    //
                    if (IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DELETED)) {

                        WDM_FAIL_ROUTINE((
                            DCERROR_DELETED_PRESENT_PDO,
                            DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                            IofCallDriverStackData->DispatchRoutine,
                            &IofCallDriverStackData->IrpSnapshot,
                            DeviceObject
                            ));
                    }

                } else if (!IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DELETED)) {

                    //
                    // Check bus filters. Bus filters better not have detached
                    // or deleted themselves, as the PDO is still present!
                    //
                    if (lowerDevObj == NULL) {

                        //
                        // Oops, it detached. Baad bus filter...
                        //
                        WDM_FAIL_ROUTINE((
                            DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED,
                            DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                            IofCallDriverStackData->DispatchRoutine,
                            &IofCallDriverStackData->IrpSnapshot,
                            DeviceObject
                            ));
                    }

                    if (IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DELETED)) {

                        //
                        // It deleted itself. Also very bad...
                        //
                        WDM_FAIL_ROUTINE((
                            DCERROR_BUS_FILTER_ERRONEOUSLY_DELETED,
                            DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                            IofCallDriverStackData->DispatchRoutine,
                            &IofCallDriverStackData->IrpSnapshot,
                            DeviceObject
                            ));
                    }
                }
            }

            if (lowerDevObj) {

                ObDereferenceObject(lowerDevObj);
            }
        }
    }

    if ((IofCallDriverStackData->Flags&CALLFLAG_COMPLETED) &&
        VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_MONITOR_PENDING_IO) &&
        (!(iovSessionData->SessionFlags & SESSIONFLAG_MARKED_INCONSISTANT))) {

        //
        // The rules for the pending bit require that it be set only if
        // STATUS_PENDING is returned, and likewise STATUS_PENDING can be returned
        // only if the IRP is marked pending.
        //
        if (IofCallDriverStackData->Flags&CALLFLAG_MARKED_PENDING) {

            if (!pendingReturned) {

                if (IofCallDriverStackData->IrpSnapshot.IoStackLocation.MajorFunction != IRP_MJ_POWER) {

                    //
                    // ADRIAO BUGBUG 2001/06/21 - Some bugs left uncaught
                    //     The verifier only fails IRPs with the DEFER_IO
                    // flag set right now because we've been failing the
                    // wrong driver until very very recently. Even worse,
                    // that driver has been the verifier filters
                    // themselves, and we don't check the kernel by
                    // default. Also, PoCallDriver doesn't always mark the
                    // IRP stack location pending, so we may fail a driver
                    // due to the PoCallDriver bug (we also caught this
                    // late cause it's been harmless).
                    //
                    // We will address all this stuff next release.
                    //
                    WDM_FAIL_ROUTINE((
                        DCERROR_PENDING_MARKED_NOT_RETURNED,
                        DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_STATUS,
                        IofCallDriverStackData->DispatchRoutine,
                        &IofCallDriverStackData->IrpSnapshot,
                        *FinalStatus
                        ));
                }

                iovSessionData->SessionFlags |= SESSIONFLAG_MARKED_INCONSISTANT;
            }

        } else if (pendingReturned) {

            if (IofCallDriverStackData->IrpSnapshot.IoStackLocation.MajorFunction != IRP_MJ_POWER) {

                //
                // ADRIAO BUGBUG 2001/06/21 - Some bugs left uncaught
                //     The verifier only fails IRPs with the DEFER_IO
                // flag set right now because we've been failing the
                // wrong driver until very very recently. Even worse,
                // that driver has been the verifier filters
                // themselves, and we don't check the kernel by
                // default. Also, PoCallDriver doesn't always mark the
                // IRP stack location pending, so we may fail a driver
                // due to the PoCallDriver bug (we also caught this
                // late cause it's been harmless).
                //
                // We will address all this stuff next release.
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_PENDING_RETURNED_NOT_MARKED_2,
                    DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_STATUS,
                    IofCallDriverStackData->DispatchRoutine,
                    &IofCallDriverStackData->IrpSnapshot,
                    *FinalStatus
                    ));
            }

            iovSessionData->SessionFlags |= SESSIONFLAG_MARKED_INCONSISTANT;
        }
    }

    if (IofCallDriverStackData->Flags&CALLFLAG_COMPLETED) {

        TRACKIRP_DBGPRINT((
            "  Verifying status in CD2\n"
            ),2);

        if ((*FinalStatus != IofCallDriverStackData->ExpectedStatus)&&
            (*FinalStatus != STATUS_PENDING)) {

            if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&
                (!(iovSessionData->SessionFlags&SESSIONFLAG_UNWOUND_INCONSISTANT))) {

                //
                // The completion routine and the return value don't match. Hey!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_INCONSISTANT_STATUS,
                    DCPARAM_IRPSNAP + DCPARAM_ROUTINE + DCPARAM_STATUS*2,
                    IofCallDriverStackData->DispatchRoutine,
                    &IofCallDriverStackData->IrpSnapshot,
                    IofCallDriverStackData->ExpectedStatus,
                    *FinalStatus
                    ));
            }

            iovSessionData->SessionFlags |= SESSIONFLAG_UNWOUND_INCONSISTANT;

        } else if (*FinalStatus == 0xFFFFFFFF) {

            if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

                //
                // This status value is illegal. If we see it, we probably have
                // an uninitialized variable...
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_UNINITIALIZED_STATUS,
                    DCPARAM_IRPSNAP + DCPARAM_ROUTINE,
                    IofCallDriverStackData->DispatchRoutine,
                    &IofCallDriverStackData->IrpSnapshot
                    ));
            }
        }

        //
        // We do not need to remove ourselves from the list because
        // we will not be completed twice (InUse is NULL makes sure).
        //

    } else {

        //
        // OK, we haven't completed yet. Status better
        // be pending...
        //
        TRACKIRP_DBGPRINT((
            "  Verifying status is STATUS_PENDING in CR2\n"
            ), 2);

        if (*FinalStatus != STATUS_PENDING) {

            if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&
                (!(iovPacket->Flags&TRACKFLAG_UNWOUND_BADLY))) {

                //
                // We got control before this slot was completed. This is
                // legal as long as STATUS_PENDING was returned (it was not),
                // so it's bug time. Note that the IRP may not be safe to touch.
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_IRP_RETURNED_WITHOUT_COMPLETION,
                    DCPARAM_IRPSNAP + DCPARAM_ROUTINE,
                    IofCallDriverStackData->DispatchRoutine,
                    &IofCallDriverStackData->IrpSnapshot
                    ));
            }

            iovPacket->Flags |= TRACKFLAG_UNWOUND_BADLY;
        }

        iovCurrentStackLocation = (PIOV_STACK_LOCATION)(IofCallDriverStackData->IovStackLocation);
        ASSERT(iovCurrentStackLocation->InUse);

        //
        // Here we mark the stack location as having unwound with
        // STATUS_PENDING. We do this to verifier the driver has marked the IRP
        // pending before completion.
        //
        iovCurrentStackLocation->Flags |= STACKFLAG_UNWOUND_PENDING;

        ASSERT(!IsListEmpty(&iovCurrentStackLocation->CallStackData));

        //
        // We now extricate ourselves from the list.
        //
        RemoveEntryList(&IofCallDriverStackData->SharedLocationList);
    }

    if ((IofCallDriverStackData->Flags&CALLFLAG_OVERRIDE_STATUS)&&
        (!pendingReturned)) {

        *FinalStatus = IofCallDriverStackData->NewStatus;
    }

    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_FORCE_PENDING) &&
        (!(IofCallDriverStackData->Flags&CALLFLAG_IS_REMOVE_IRP))) {

        //
        // We also have the option of causing trouble by making every Irp
        // look as if were pending.
        //
        *FinalStatus = STATUS_PENDING;
    }

    IovpSessionDataDereference(iovSessionData);
    VfPacketDereference(iovPacket, IOVREFTYPE_PACKET);
    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
IovpCompleteRequest1(
    IN      PIRP                            Irp,
    IN      CCHAR                           PriorityBoost,
    IN OUT  PIOFCOMPLETEREQUEST_STACKDATA   CompletionPacket
    )
/*++

  Description

    This routine is called the moment IofCompleteRequest is invoked, and
    before any completion routines get called and before the IRP stack
    is adjusted in any way.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IofCompleteRequest.

    PriorityBoost          - The priority boost passed into
                             IofCompleteRequest.

    CompletionPacket       - A pointer to a local variable on the stack of
                             IofCompleteRequest. The information stored in
                             this local variable will be picked up by
                             IovpCompleteRequest2-5.
  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    BOOLEAN slotIsInUse;
    PIOV_STACK_LOCATION iovCurrentStackLocation;
    ULONG locationsAdvanced, stackHash;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT lowerDevobj;
    PVOID callerAddress;
    KIRQL invocationIrql;

    invocationIrql = KeGetCurrentIrql();

    iovPacket = VfPacketFindAndLock(Irp);

    CompletionPacket->RaisedCount = 0;

    if (iovPacket == NULL) {

        CompletionPacket->IovSessionData = NULL;
        return;
    }

    if (RtlCaptureStackBackTrace(3, 1, &callerAddress, &stackHash) != 1) {

        callerAddress = NULL;
    }

    VfPacketLogEntry(iovPacket, IOV_EVENT_IO_COMPLETE_REQUEST, callerAddress, 0);

    //
    // Set the arrival and departure Irqls.
    //
    iovPacket->ArrivalIrql = invocationIrql;
    iovPacket->DepartureIrql = invocationIrql;

    iovSessionData = VfPacketGetCurrentSessionData(iovPacket);

    CompletionPacket->IovSessionData = iovSessionData;
    CompletionPacket->IovRequestPacket = iovPacket;

    if (iovSessionData == NULL) {

        //
        // We just got a look at the allocation, not the session itself.
        // This can happen if a driver calls IofCompleteRequest on an internally
        // generated IRP before calling IofCallDriver. NPFS does this.
        //
        VfPacketReleaseLock(iovPacket);
        return;
    }

    TRACKIRP_DBGPRINT((
        "  CR1: Current, Last = (%x, %x)\n",
        Irp->CurrentLocation, iovPacket->LastLocation
        ), 3);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (iovPacket->Flags&TRACKFLAG_QUEUED_INTERNALLY) {

        //
        // We are probably going to die now. Anyway, it was a good life...
        //
        WDM_FAIL_ROUTINE((
            DCERROR_QUEUED_IRP_COMPLETED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            callerAddress,
            Irp
            ));
    }

    //
    // This would be *very* bad - someone is completing an IRP that is
    // currently in progress...
    //
    ASSERT(!(Irp->Flags&IRP_DIAG_HAS_SURROGATE));

    //
    // Hmmm, someone is completing an IRP that IoCallDriver never called. These
    // is possible but rather gross, so we warn.
    //
    if (Irp->CurrentLocation == ((CCHAR) Irp->StackCount + 1)) {

        WDM_FAIL_ROUTINE((
            DCERROR_UNFORWARDED_IRP_COMPLETED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            callerAddress,
            Irp
            ));
    }

    //
    // Check for leaked Cancel routines.
    //
    if (Irp->CancelRoutine) {

        if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_VERIFY_CANCEL_LOGIC)) {

            WDM_FAIL_ROUTINE((
                DCERROR_CANCELROUTINE_AFTER_COMPLETION,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                callerAddress,
                Irp
                ));
        }
    }

    //
    // Record priority for our own later recompletion...
    //
    iovPacket->PriorityBoost = PriorityBoost;

    //
    // We have the option of causing trouble by making every Irp look
    // as if were pending. It is best to do it here, as this also takes
    // care of anybody who has synchronized the IRP and thus does not need
    // to mark it pending in his completion routine.
    //
    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_FORCE_PENDING)) {

        IoMarkIrpPending(Irp);
    }

    //
    // Do this so that if the IRP comes down again, it looks like a new one
    // to the "forward them correctly" code.
    //
    iovSessionData->DeviceLastCalled = NULL;

    locationsAdvanced = iovPacket->LastLocation - Irp->CurrentLocation;

    //
    // Remember this so that we can detect the case where someone is completing
    // to themselves.
    //
    CompletionPacket->LocationsAdvanced = locationsAdvanced;

    //
    // If this failed, somebody skipped then completed.
    //
    ASSERT(locationsAdvanced);

    //
    // If somebody called IoSetNextIrpStackLocation, and then completed,
    // update our internal stack locations (slots) as appropriate.
    //
    slotIsInUse = IovpAdvanceStackDownwards(
         iovSessionData->StackData,
         Irp->CurrentLocation,
         irpSp,
         irpSp + locationsAdvanced,
         locationsAdvanced,
         FALSE,
         FALSE,
         &iovCurrentStackLocation
         );

    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
IovpCompleteRequest2(
    IN      PIRP                            Irp,
    IN OUT  PIOFCOMPLETEREQUEST_STACKDATA   CompletionPacket
    )
/*++

  Description:

    This routine is called for each stack location that might have a completion
    routine.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IofCompleteRequest.

    CompletionPacket       - A pointer to a local variable on the stack of
                             IofCompleteRequest. The information stored in
                             this local variable will be picked up by
                             IovpCompleteRequest4&5.

  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    BOOLEAN raiseToDPC, newlyCompleted, requestFinalized;
    KIRQL oldIrql;
    PIOV_STACK_LOCATION iovCurrentStackLocation, requestsFirstStackLocation;
    NTSTATUS status, entranceStatus;
    PIOFCALLDRIVER_STACKDATA IofCallDriverStackData;
    PIO_STACK_LOCATION irpSp;
    ULONG refAction;
    PLIST_ENTRY listEntry;

    iovSessionData = CompletionPacket->IovSessionData;
    if (iovSessionData == NULL) {

        return;
    }

    iovPacket = CompletionPacket->IovRequestPacket;
    ASSERT(iovPacket);
    VfPacketAcquireLock(iovPacket);

    ASSERT(iovSessionData == VfPacketGetCurrentSessionData(iovPacket));

    ASSERT(!Irp->CancelRoutine);

    status = Irp->IoStatus.Status;

    TRACKIRP_DBGPRINT((
        "  CR2: Current, Last = (%x, %x)\n",
        Irp->CurrentLocation, iovPacket->LastLocation
        ), 3);

    iovCurrentStackLocation = iovSessionData->StackData + Irp->CurrentLocation -1;
    TRACKIRP_DBGPRINT((
        "  Smacking %lx in CR2\n",
        iovCurrentStackLocation-iovSessionData->StackData
        ), 2);

    if (Irp->CurrentLocation <= iovPacket->TopStackLocation) {

        //
        // Might this be false if the completion routine is to an
        // internal stack loc as set up by IoSetNextIrpStackLocation?
        //
        ASSERT(iovCurrentStackLocation->InUse);

        //
        // Determine if a request was newly completed. Note that
        // several requests may exist within an IRP if it is being
        // "reused". For instance, in response to a IRP_MJ_READ, a
        // driver might convert it into a IRP_MJ_PNP request for the
        // rest of the stack. The two are treated as seperate requests.
        //
        requestsFirstStackLocation = iovCurrentStackLocation->RequestsFirstStackLocation;
        TRACKIRP_DBGPRINT((
            "  CR2: original request for %lx is %lx\n",
            iovCurrentStackLocation-iovSessionData->StackData,
            requestsFirstStackLocation-iovSessionData->StackData
            ), 3);

        ASSERT(requestsFirstStackLocation);
        if (requestsFirstStackLocation->Flags&STACKFLAG_REQUEST_COMPLETED) {
            newlyCompleted = FALSE;
        } else {
            requestsFirstStackLocation->Flags|=STACKFLAG_REQUEST_COMPLETED;
            newlyCompleted = TRUE;
            TRACKIRP_DBGPRINT((
                "  CR2: Request %lx newly completed by %lx\n",
                requestsFirstStackLocation-iovSessionData->StackData,
                iovCurrentStackLocation-iovSessionData->StackData
                ), 3);
        }
        requestFinalized = (iovCurrentStackLocation == requestsFirstStackLocation);
        if (requestFinalized) {

            TRACKIRP_DBGPRINT((
                "  CR2: Request %lx finalized\n",
                iovCurrentStackLocation-iovSessionData->StackData
                ), 3);
        }

        //
        // OK -
        //       If we haven't unwound yet, then IofCallDriverStackData will
        // start out non-NULL, in which case we will scribble away the final
        // completion routine status to everybody asking (could be multiple
        // if they IoSkip'd).
        //       On the other hand, everybody might have unwound, in which
        // case IofCallDriver(...) will start out NULL, and we will already have
        // asserted if STATUS_PENDING wasn't returned much much earlier...
        //       Finally, this slot may not have been "prepared" if an
        // internal stack location called IoSetNextIrpStackLocation, thus
        // consuming a stack location. In this case, IofCallDriverStackData
        // will come from a zero'd slot, and we will do nothing, which is
        // also fine.
        //
        irpSp = IoGetNextIrpStackLocation(Irp);

        if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&
            VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_MONITOR_MAJORS)) {

            VfMajorVerifyIrpStackUpward(
                iovPacket,
                irpSp,
                iovCurrentStackLocation,
                newlyCompleted,
                requestFinalized
                );
        }

        entranceStatus = status;

        if ((VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_MONITOR_PENDING_IO)) &&
            (!(iovSessionData->SessionFlags & SESSIONFLAG_MARKED_INCONSISTANT))) {

            if (iovCurrentStackLocation->Flags & STACKFLAG_UNWOUND_PENDING) {

                if (!Irp->PendingReturned) {

                    if (Irp->Flags & IRP_DEFER_IO_COMPLETION) {

                        //
                        // ADRIAO BUGBUG 2001/06/21 - Some bugs left uncaught
                        //     The verifier only fails IRPs with the DEFER_IO
                        // flag set right now because we've been failing the
                        // wrong driver until very very recently. Even worse,
                        // that driver has been the verifier filters
                        // themselves, and we don't check the kernel by
                        // default. Also, PoCallDriver doesn't always mark the
                        // IRP stack location pending, so we may fail a driver
                        // due to the PoCallDriver bug (we also caught this
                        // late cause it's been harmless).
                        //
                        // We will address all this stuff next release.
                        //
                        WDM_FAIL_ROUTINE((
                            DCERROR_PENDING_RETURNED_NOT_MARKED,
                            DCPARAM_IRP + DCPARAM_ROUTINE + DCPARAM_STATUS,
                            iovCurrentStackLocation->LastDispatch,
                            Irp,
                            status
                            ));
                    }

                    iovSessionData->SessionFlags |= SESSIONFLAG_MARKED_INCONSISTANT;
                }
            }
        }

        while(!IsListEmpty(&iovCurrentStackLocation->CallStackData)) {

            //
            // Pop off the list head.
            //
            listEntry = RemoveHeadList(&iovCurrentStackLocation->CallStackData);
            IofCallDriverStackData = CONTAINING_RECORD(
                listEntry,
                IOFCALLDRIVER_STACKDATA,
                SharedLocationList);

            ASSERT(!(IofCallDriverStackData->Flags&CALLFLAG_COMPLETED));

            IofCallDriverStackData->Flags |= CALLFLAG_COMPLETED;
            IofCallDriverStackData->ExpectedStatus = status;

            if (Irp->PendingReturned) {

                IofCallDriverStackData->Flags |= CALLFLAG_MARKED_PENDING;
            }

            if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_ROTATE_STATUS) &&
                 (!(iovPacket->Flags&TRACKFLAG_BOGUS)) &&
                 VfMajorAdvanceIrpStatus(irpSp, entranceStatus, &status)) {

                //
                // Purposely munge the returned status for everyone at this
                // layer to flush more bugs. We are specifically trolling for
                // this buggy sequence:
                //    Irp->IoStatus.Status = STATUS_SUCCESS;
                //    IoSkipCurrentIrpStackLocation(Irp);
                //    IoCallDriver(DeviceBelow, Irp);
                //    return STATUS_SUCCESS;
                //
                IofCallDriverStackData->Flags |= CALLFLAG_OVERRIDE_STATUS;
                IofCallDriverStackData->NewStatus = status;
            }
        }
        Irp->IoStatus.Status = status;

        //
        // Set InUse = FALSE  and  CallStackData = NULL
        //
        RtlZeroMemory(iovCurrentStackLocation, sizeof(IOV_STACK_LOCATION));
        InitializeListHead(&iovCurrentStackLocation->CallStackData);
    } else {

        ASSERT(0);
    }

    //
    // Once we return, we may be completed again before IofCompleteRequest3
    // get's called, so we make sure we are at DPC level throughout.
    //
    raiseToDPC = FALSE;

    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_COMPLETE_AT_DISPATCH)) {

        if (!CompletionPacket->RaisedCount) {

            //
            // Copy away the callers IRQL
            //
            CompletionPacket->PreviousIrql = iovPacket->DepartureIrql;
            raiseToDPC = TRUE;
        }
        CompletionPacket->RaisedCount++;
    }

    iovPacket->LastLocation = Irp->CurrentLocation+1;

    if (iovPacket->TopStackLocation == Irp->CurrentLocation) {

        CompletionPacket->IovSessionData = NULL;
        CompletionPacket->IovRequestPacket = NULL;

        if (iovPacket->Flags&TRACKFLAG_SURROGATE) {

            //
            // Scribble away the real completion routine and corrosponding control
            //
            irpSp = IoGetNextIrpStackLocation(Irp);
            iovPacket->RealIrpCompletionRoutine = irpSp->CompletionRoutine;
            iovPacket->RealIrpControl = irpSp->Control;
            iovPacket->RealIrpContext = irpSp->Context;

            //
            // We want to peek at the Irp prior to completion. This is why we
            // have expanded the initial number of stack locations with the
            // driver verifier enabled.
            //
            IoSetCompletionRoutine(
                Irp,
                IovpSwapSurrogateIrp,
                Irp,
                TRUE,
                TRUE,
                TRUE
                );

        } else {

            //
            // Close this session as the IRP has entirely completed. We drop
            // the pointer count we added to the tracking data here for the
            // same reason.
            //
            irpSp = IoGetNextIrpStackLocation(Irp);
            if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

                VfMajorVerifyFinalIrpStack(iovPacket, irpSp);
            }

            ASSERT(iovPacket->TopStackLocation == Irp->CurrentLocation);
            IovpSessionDataClose(iovSessionData);
            IovpSessionDataDereference(iovSessionData);
            VfPacketDereference(iovPacket, IOVREFTYPE_POINTER);
        }

    } else {

        //
        // We will be seeing this IRP again. Hold a session count and a ref
        // count against it.
        //
        IovpSessionDataReference(iovSessionData);
        VfPacketReference(iovPacket, IOVREFTYPE_PACKET);
    }

    //
    // Assert LastLocation is consistent with an IRP that may be completed.
    //
    if (iovPacket->LastLocation < iovPacket->TopStackLocation) {

        ASSERT(iovSessionData->StackData[iovPacket->LastLocation-1].InUse);
    }

    VfPacketReleaseLock(iovPacket);

    if (raiseToDPC) {
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    }

    CompletionPacket->LocationsAdvanced--;
}


VOID
FASTCALL
IovpCompleteRequest3(
    IN      PIRP                            Irp,
    IN      PVOID                           Routine,
    IN OUT  PIOFCOMPLETEREQUEST_STACKDATA   CompletionPacket
    )
/*++

  Description:

    This routine is called just before each completion routine is invoked.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IofCompleteRequest.

    Routine                - The completion routine about to be called.

    CompletionPacket       - A pointer to data on the callers stack. This will
                             be picked up IovpCompleteRequest4 and
                             IovpCompleteRequest5.

  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    PIO_STACK_LOCATION irpSpCur, irpSpNext;
    PDEFERRAL_CONTEXT deferralContext;

    iovSessionData = CompletionPacket->IovSessionData;
    if (iovSessionData == NULL) {

        return;
    }

    iovPacket = CompletionPacket->IovRequestPacket;
    ASSERT(iovPacket);
    VfPacketAcquireLock(iovPacket);
    VfPacketLogEntry(iovPacket, IOV_EVENT_IO_COMPLETION_ROUTINE, Routine, 0);

    //
    // Verify all completion routines are in nonpaged code, exempting one
    // special case - when a driver completes the IRP to itself by calling
    // IoSetNextStackLocation before calling IoCompleteRequest.
    //
    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        if ((CompletionPacket->LocationsAdvanced <= 0) &&
            (MmIsSystemAddressLocked(Routine) == FALSE)) {

            //DbgPrint(
            //    "Verifier Notes: LocationsAdvanced %d\n",
            //    CompletionPacket->LocationsAdvanced
            //    );

            WDM_FAIL_ROUTINE((
                DCERROR_COMPLETION_ROUTINE_PAGABLE,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                Routine,
                Irp
                ));
        }
    }

    //
    // Setup fields for those assertion functions that will be called *after*
    // the completion routine has been called.
    //
    irpSpCur = IoGetCurrentIrpStackLocation(Irp);
    CompletionPacket->IsRemoveIrp =
       ((Irp->CurrentLocation <= (CCHAR) Irp->StackCount) &&
        (irpSpCur->MajorFunction == IRP_MJ_PNP) &&
        (irpSpCur->MinorFunction == IRP_MN_REMOVE_DEVICE));

    CompletionPacket->CompletionRoutine = Routine;

    //
    // Is this a completion routine that should be called later? Note that this
    // is only legal if we are pending the IRPs (because to the upper driver,
    // IofCallDriver is returning before it's completion routine has been called)
    //
    if ((!CompletionPacket->IsRemoveIrp)&&
       (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_DEFER_COMPLETION)||
        VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_COMPLETE_AT_PASSIVE))) {

        ASSERT(VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_FORCE_PENDING));

        irpSpNext = IoGetNextIrpStackLocation(Irp);

        deferralContext = ExAllocatePoolWithTag(
           NonPagedPool,
           sizeof(DEFERRAL_CONTEXT),
           POOL_TAG_DEFERRED_CONTEXT
           );

        if (deferralContext) {

            //
            // Swap the original completion and context for our own.
            //
            deferralContext->IovRequestPacket          = iovPacket;
            deferralContext->IrpSpNext                 = irpSpNext;
            deferralContext->OriginalCompletionRoutine = irpSpNext->CompletionRoutine;
            deferralContext->OriginalContext           = irpSpNext->Context;
            deferralContext->OriginalIrp               = Irp;
            deferralContext->OriginalPriorityBoost     = iovPacket->PriorityBoost;

            irpSpNext->CompletionRoutine = IovpInternalDeferredCompletion;
            irpSpNext->Context           = deferralContext;
            VfPacketReference(iovPacket, IOVREFTYPE_POINTER);
        }
    }

    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
IovpCompleteRequest4(
    IN      PIRP                            Irp,
    IN      NTSTATUS                        ReturnedStatus,
    IN OUT  PIOFCOMPLETEREQUEST_STACKDATA   CompletionPacket
    )
/*++

  Description:

    This assert routine is called just after each completion routine is
    invoked (but not if STATUS_MORE_PROCESSING is returned)

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IofCompleteRequest.

    Routine                - The completion routine called.

    ReturnedStatus         - The status value returned.

    CompletionPacket       - A pointer to data on the callers stack. This was
                             filled in by IovpCompleteRequest3.

  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    PIO_STACK_LOCATION irpSp;
    PVOID routine;

    routine = CompletionPacket->CompletionRoutine;
    iovSessionData = CompletionPacket->IovSessionData;

    if (iovSessionData == NULL) {

        return;
    }

    iovPacket = CompletionPacket->IovRequestPacket;
    ASSERT(iovPacket);
    VfPacketAcquireLock(iovPacket);

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_COMPLETION_ROUTINE_UNWIND,
        routine,
        ReturnedStatus
        );

    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_FORCE_PENDING)) {

        if ((ReturnedStatus != STATUS_MORE_PROCESSING_REQUIRED)&&
            (iovPacket->pIovSessionData == iovSessionData)) {

            //
            // At this point, we know the completion routine is required to have
            // set the IRP pending bit, because we've hardwired everyone below
            // him to return pending, and we've marked the pending returned bit.
            // Verify he did his part
            //
            irpSp = IoGetCurrentIrpStackLocation(Irp);
            if (!(irpSp->Control & SL_PENDING_RETURNED )) {

                 WDM_FAIL_ROUTINE((
                     DCERROR_PENDING_BIT_NOT_MIGRATED,
                     DCPARAM_IRP + DCPARAM_ROUTINE,
                     routine,
                     Irp
                     ));

                 //
                 // This will keep the IRP above from erroneously asserting (and
                 // correctly hanging).
                 //
                 IoMarkIrpPending(Irp);
            }
        }
    }
    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
IovpCompleteRequest5(
    IN      PIRP                            Irp,
    IN OUT  PIOFCOMPLETEREQUEST_STACKDATA   CompletionPacket
    )
/*++

  Description:

    This routine is called for each stack location that could have had a
    completion routine, after any possible completion routine has been
    called.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IofCompleteRequest.

    CompletionPacket       - A pointer to a local variable on the stack of
                             IofCompleteRequest. This information was stored
                             by IovpCompleteRequest2 and 3.

  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PIOV_SESSION_DATA iovSessionData;
    PIOV_STACK_LOCATION iovCurrentStackLocation;
    NTSTATUS status;

    iovSessionData = CompletionPacket->IovSessionData;

    if (iovSessionData) {

        iovPacket = CompletionPacket->IovRequestPacket;
        ASSERT(iovPacket);
        VfPacketAcquireLock(iovPacket);

        ASSERT((!CompletionPacket->RaisedCount) ||
               (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_COMPLETE_AT_DISPATCH)));

        IovpSessionDataDereference(iovSessionData);
        VfPacketDereference(iovPacket, IOVREFTYPE_PACKET);
        VfPacketReleaseLock(iovPacket);
    }

    //
    // When this count is at zero, we have unnested out of every
    // completion routine, so it is OK to return back to our original IRQL
    //
    if (CompletionPacket->RaisedCount) {

        if (!(--CompletionPacket->RaisedCount)) {
            //
            // Undo IRQL madness (wouldn't want to return to
            // the caller at DPC, would we now?)
            //
            KeLowerIrql(CompletionPacket->PreviousIrql);
        }
    }
}


VOID
FASTCALL
IovpCompleteRequestApc(
    IN     PIRP                          Irp,
    IN     PVOID                         BestStackOffset
    )
/*++

  Description:

    This routine is after the APC for completing IRPs and fired.

  Arguments:

    Irp                    - A pointer to the IRP passed into retrieved from
                             the APC in IopCompleteRequest.

    BestStackOffset        - A pointer to a last parameter passed on the stack.
                             We use this to detect the case where a driver has
                             ignored STATUS_PENDING and left the UserIosb on
                             it's stack.

  Return Value:

     None.
--*/
{
#if DBG
#if defined(_X86_)
    PUCHAR addr;
    PIOV_REQUEST_PACKET iovPacket;

    addr = (PUCHAR)Irp->UserIosb;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)BestStackOffset)) {

        iovPacket = VfPacketFindAndLock(Irp);

        RtlAssert("UserIosb below stack pointer", __FILE__, (ULONG) iovPacket,
                  "Call AdriaO");

        VfPacketReleaseLock(iovPacket);
    }

    addr = (PUCHAR)Irp->UserEvent;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)BestStackOffset)) {

        iovPacket = VfPacketFindAndLock(Irp);

        RtlAssert("UserEvent below stack pointer", __FILE__, (ULONG) iovPacket,
                  "Call AdriaO");

        VfPacketReleaseLock(iovPacket);
    }
#endif
#endif
}


BOOLEAN
IovpAdvanceStackDownwards(
    IN  PIOV_STACK_LOCATION   StackDataArray,
    IN  CCHAR                 CurrentLocation,
    IN  PIO_STACK_LOCATION    IrpSp,
    IN  PIO_STACK_LOCATION    IrpLastSp OPTIONAL,
    IN  ULONG                 LocationsAdvanced,
    IN  BOOLEAN               IsNewRequest,
    IN  BOOLEAN               MarkAsTaken,
    OUT PIOV_STACK_LOCATION   *StackLocationInfo
    )
{
    PIOV_STACK_LOCATION  iovCurrentStackLocation, advancedLocationData, requestOriginalSLD;
    PIO_STACK_LOCATION   irpSpTemp;
    PLARGE_INTEGER       dispatchTime, stackTime;
    BOOLEAN              isNewSession, wasInUse;
    PVOID                dispatchRoutine;

    isNewSession = (IrpLastSp == NULL);
    ASSERT((!isNewSession) || (LocationsAdvanced == 1));
    ASSERT(isNewSession || ((ULONG) (IrpLastSp - IrpSp) == LocationsAdvanced));

    //
    // This function is called by IoCallDriver prior to decrementing
    // CurrentLocation field. As the OS bugchecks if it hits zero, the field
    // should as least be two here. We only subtract one as to reserve an extra
    // empty slot at the head of the array.
    //
    iovCurrentStackLocation = StackDataArray + CurrentLocation -1;

    TRACKIRP_DBGPRINT((
        "  Smacking %lx (%lx) to valid in SD\n",
        CurrentLocation -1, iovCurrentStackLocation
        ), 2);

    //
    // Is this slot already active? IE, did someone skip and then forward the
    // IRP?
    //
    if (iovCurrentStackLocation->InUse) {

        //
        // IoSkipCurrentIrpStackLocation was used by the forwarder. Don't
        // reinitialize the data.
        //
        ASSERT(!LocationsAdvanced); // && (!isNewSession)
        ASSERT(IrpSp == iovCurrentStackLocation->IrpSp);

    } else if (MarkAsTaken) {

        //
        // ADRIAO N.B. 01/02/1999 -
        //     Is the below assertion is not true in the case of an internally
        // forwarded, completed, and then externally forwarded IRP?
        //
        ASSERT(LocationsAdvanced); // || isNewSession

        //
        // Initialize the stack slot appropriately.
        //
        RtlZeroMemory(iovCurrentStackLocation, sizeof(IOV_STACK_LOCATION));
        InitializeListHead(&iovCurrentStackLocation->CallStackData);
        iovCurrentStackLocation->IrpSp = IrpSp;
    }

    //
    // Determine the last original request. A "Request" is block of data in a
    // stack location that is progressively copied downwards as the IRP is
    // forwarded (ie, a forwarded START IRP, a forwarded IOCTL, etc). A clever
    // driver writer could use his own stack location to send down a quick
    // query before forwarding along the original request. We correctly
    // differentiate between those two unique requests within the IRP using
    // code below.
    //
    if (isNewSession) {

        //
        // *We* are the original request. None of these fields below should
        // be used.
        //
        dispatchRoutine = NULL;
        requestOriginalSLD = NULL;
        stackTime = NULL;
        dispatchTime = NULL;

    } else if (LocationsAdvanced) {

        //
        // To get the original request (the pointer to the Irp slot that
        // represents where we *first* saw this request), we go backwards to get
        // the most recent previous irp slot data (set up when the device above
        // forwarded this Irp to us), and we read what it's original request was.
        // We also get the dispatch routine for that slot, which we will use to
        // backfill skipped slots if we advanced more than one Irp stack
        // location this time (ie, someone called IoSetNextIrpStackLocation).
        //
        dispatchTime       = &iovCurrentStackLocation[LocationsAdvanced].PerfDispatchStart;
        stackTime          = &iovCurrentStackLocation[LocationsAdvanced].PerfStackLocationStart;
        dispatchRoutine    = iovCurrentStackLocation[LocationsAdvanced].LastDispatch;
        requestOriginalSLD = iovCurrentStackLocation[LocationsAdvanced].RequestsFirstStackLocation;

        ASSERT(dispatchRoutine);
        ASSERT(iovCurrentStackLocation[LocationsAdvanced].InUse);
        ASSERT(requestOriginalSLD->RequestsFirstStackLocation == requestOriginalSLD);
        iovCurrentStackLocation->RequestsFirstStackLocation = requestOriginalSLD;

    } else {

        //
        // We skipped. The slot should already be filled.
        //
        dispatchRoutine = NULL;
        dispatchTime = NULL;
        stackTime = NULL;
        requestOriginalSLD = iovCurrentStackLocation->RequestsFirstStackLocation;
        ASSERT(requestOriginalSLD);
        ASSERT(requestOriginalSLD->RequestsFirstStackLocation == requestOriginalSLD);
    }

    //
    // The previous request seen is in requestOriginalSLD (NULL if none). If
    // we advanced more than one stack location (ie, someone called
    // IoSetNextIrpStackLocation), we need to update the slots we never saw get
    // consumed. Note that the dispatch routine we set in the slot is for the
    // driver that owned the last slot - we do not use the device object at
    // that IrpSp because it might be stale (or perhaps even NULL).
    //
    advancedLocationData = iovCurrentStackLocation;
    irpSpTemp = IrpSp;
    while(LocationsAdvanced>1) {
        advancedLocationData++;
        LocationsAdvanced--;
        irpSpTemp++;
        TRACKIRP_DBGPRINT((
            "  Late smacking %lx to valid in CD1\n",
            advancedLocationData - StackDataArray
            ), 3);

        ASSERT(!advancedLocationData->InUse);
        RtlZeroMemory(advancedLocationData, sizeof(IOV_STACK_LOCATION));
        InitializeListHead(&advancedLocationData->CallStackData);
        advancedLocationData->InUse = TRUE;
        advancedLocationData->IrpSp = irpSpTemp;

        advancedLocationData->RequestsFirstStackLocation = requestOriginalSLD;
        advancedLocationData->PerfDispatchStart = *dispatchTime;
        advancedLocationData->PerfStackLocationStart = *stackTime;
        advancedLocationData->LastDispatch = dispatchRoutine;
    }

    //
    // For the assertion below...
    //
    if (LocationsAdvanced) {
        irpSpTemp++;
    }
    ASSERT((irpSpTemp == IrpLastSp)||(IrpLastSp == NULL));

    //
    // Write out the slot we're using.
    //
    *StackLocationInfo = iovCurrentStackLocation;

    if (!MarkAsTaken) {
        return iovCurrentStackLocation->InUse;
    }

    //
    // Record a pointer in this slot to the requests originating slot as
    // appropriate.
    //
    if (IsNewRequest) {

        TRACKIRP_DBGPRINT((
            "  CD1: %lx is a new request\n",
            advancedLocationData-StackDataArray
            ), 3);

        ASSERT(LocationsAdvanced == 1);

        iovCurrentStackLocation->RequestsFirstStackLocation = iovCurrentStackLocation;

    } else if (LocationsAdvanced) {

        ASSERT(!isNewSession);

        TRACKIRP_DBGPRINT((
            "  CD1: %lx is a request for %lx\n",
            advancedLocationData-StackDataArray,
            requestOriginalSLD-StackDataArray
            ), 3);

    } else {

        //
        // As we skipped, the request should not have changed. If it did,
        // either guy we called trashed the stack given to him (giving none
        // to the dude under him), or we incorrectly saw a new request when
        // we shouldn't have (see previous comment).
        //
        ASSERT(!isNewSession);
        ASSERT(advancedLocationData->RequestsFirstStackLocation == requestOriginalSLD);
    }

    wasInUse = iovCurrentStackLocation->InUse;
    iovCurrentStackLocation->InUse = TRUE;
    return wasInUse;
}


VOID
IovpExamineIrpStackForwarding(
    IN OUT  PIOV_REQUEST_PACKET  IovPacket,
    IN      BOOLEAN              IsNewSession,
    IN      ULONG                ForwardMethod,
    IN      PDEVICE_OBJECT       DeviceObject,
    IN      PIRP                 Irp,
    IN      PVOID                CallerAddress,
    IN OUT  PIO_STACK_LOCATION  *IoCurrentStackLocation,
    OUT     PIO_STACK_LOCATION  *IoLastStackLocation,
    OUT     ULONG               *StackLocationsAdvanced
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp, irpLastSp;
    BOOLEAN isSameStack, multiplyStacked;
    ULONG locationsAdvanced;
    PDEVICE_OBJECT upperDevice;

    irpSp = *IoCurrentStackLocation;

    if (!IsNewSession) {

        //
        // We are sitting on current next being one back (-1) from
        // CurrentStackLocation.
        //
        locationsAdvanced = IovPacket->LastLocation-Irp->CurrentLocation;
        irpLastSp = Irp->Tail.Overlay.CurrentStackLocation+((ULONG_PTR)locationsAdvanced-1);

    } else {

        //
        // New IRP, so no last SP and we always advance "1"
        //
        locationsAdvanced = 1;
        irpLastSp = NULL;
    }

    if ((!IsNewSession) &&
        VfSettingsIsOptionEnabled(IovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        //
        // As the control field is zeroed by IoCopyCurrentStackLocation, we
        // dope each stack location with the value SL_NOTCOPIED. If it is
        // zeroed or the IRP stack location has stayed the same, the one of
        // the two API's was called. Otherwise the next stack location wasn't
        // set up properly (I have yet to find a case otherwise)...
        //
        if ((irpSp->Control&SL_NOTCOPIED)&&
            IovPacket->LastLocation != Irp->CurrentLocation) {

#if 0
            WDM_FAIL_ROUTINE((
                DCERROR_NEXTIRPSP_DIRTY,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));
#endif
        }

        //
        // Now check for people who copy the stack locations and forget to
        // wipe out previous completion routines.
        //
        if (locationsAdvanced) {

            //
            // IoCopyCurrentStackLocation copies everything but Completion,
            // Context, and Control
            //
            isSameStack = RtlEqualMemory(irpSp, irpLastSp,
                FIELD_OFFSET(IO_STACK_LOCATION, Control));

            isSameStack &= RtlEqualMemory(&irpSp->Parameters, &irpLastSp->Parameters,
                FIELD_OFFSET(IO_STACK_LOCATION, DeviceObject)-
                FIELD_OFFSET(IO_STACK_LOCATION, Parameters));

            isSameStack &= (irpSp->FileObject == irpLastSp->FileObject);

            //
            // We should *never* see this on the stack! If we do, something
            // quite bizarre has happened...
            //
            ASSERT(irpSp->CompletionRoutine != IovpSwapSurrogateIrp);

            if (isSameStack) {

                //
                // We caught them doing something either very bad or quite
                // inefficient. We can tell which based on whether there is
                // a completion routine.
                //
                if ((irpSp->CompletionRoutine == irpLastSp->CompletionRoutine)&&
                    (irpSp->Context == irpLastSp->Context) &&
                    (irpSp->Control == irpLastSp->Control) &&
                    (irpSp->CompletionRoutine != NULL)) {

                    //
                    // The driver might have copied the entire stack location
                    // on purpose if more than one device object for the same
                    // driver exists in the stack.
                    //
                    IovUtilGetUpperDeviceObject(
                        irpLastSp->DeviceObject,
                        &upperDevice
                        );

                    multiplyStacked = (upperDevice &&
                        (upperDevice->DriverObject == irpLastSp->DeviceObject->DriverObject));

                    if (upperDevice) {

                        ObDereferenceObject(upperDevice);
                    }

                    if (!multiplyStacked) {

                        //
                        // Duplication of both the completion and the context
                        // while not properly zeroing the control field is enough
                        // to make me believe the caller has made a vexing mistake.
                        //
                        WDM_FAIL_ROUTINE((
                            DCERROR_IRPSP_COPIED,
                            DCPARAM_IRP + DCPARAM_ROUTINE,
                            CallerAddress,
                            Irp
                            ));

                        //
                        // Repair the stack
                        //
                        irpSp->CompletionRoutine = NULL;
                        irpSp->Control = 0;
                    }

                } else if (!irpSp->CompletionRoutine) {

                    if (!(irpSp->Control&SL_NOTCOPIED) &&
                        VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_FLAG_UNNECCESSARY_COPIES)
                        ) {

                        WDM_FAIL_ROUTINE((
                            DCERROR_UNNECCESSARY_COPY,
                            DCPARAM_IRP + DCPARAM_ROUTINE,
                            CallerAddress,
                            Irp
                            ));
                    }

                    IoSetCompletionRoutine(
                        Irp,
                        IovpInternalCompletionTrap,
                        IoGetCurrentIrpStackLocation( Irp ),
                        TRUE,
                        TRUE,
                        TRUE
                        );
                }
            }

        } else if (VfSettingsIsOptionEnabled(IovPacket->VerifierSettings, VERIFIER_OPTION_CONSUME_ALWAYS)) {

            if (ForwardMethod == FORWARDED_TO_NEXT_DO) {

                if (Irp->CurrentLocation<=2) {

                    WDM_FAIL_ROUTINE((
                        DCERROR_INSUFFICIENT_STACK_LOCATIONS,
                        DCPARAM_IRP + DCPARAM_ROUTINE,
                        CallerAddress,
                        Irp
                        ));

                } else {

                    //
                    // Back up the skip, then copy. Add a completion routine with
                    // unique and assertable context to catch people who clumsily
                    // Rtl-copy stack locations (we can't catch them if the caller
                    // above used an empty stack with no completion routine)...
                    //
                    IoSetNextIrpStackLocation( Irp );

                    //
                    // Set the trap...
                    //
                    IoCopyCurrentIrpStackLocationToNext( Irp );
                    IoSetCompletionRoutine(
                        Irp,
                        IovpInternalCompletionTrap,
                        IoGetCurrentIrpStackLocation( Irp ),
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    //
                    // This is our new reality...
                    //
                    locationsAdvanced = 1;
                    irpSp = IoGetNextIrpStackLocation( Irp );
                }
            }
        }
    }

    *IoCurrentStackLocation = irpSp;
    *IoLastStackLocation = irpLastSp;
    *StackLocationsAdvanced = locationsAdvanced;
}


NTSTATUS
IovpInternalCompletionTrap(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

  Description:

    This routine does nothing but act as a trap for people
    incorrectly copying stack locations...

  Arguments:

    DeviceObject           - Device object set at this level of the completion
                             routine - ignored.

    Irp                    - A pointer to the IRP.

    Context                - Context should equal the Irp's stack location -
                             this is asserted.

  Return Value:

     STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION irpSp;

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT((PVOID) irpSp == Context);

    return STATUS_SUCCESS;
}


VOID
IovpInternalCompleteAtDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    IovpInternalCompleteAfterWait(DeferredContext);
}


VOID
IovpInternalCompleteAfterWait(
    IN PVOID Context
    )
{
    PDEFERRAL_CONTEXT deferralContext = (PDEFERRAL_CONTEXT) Context;
    PIO_STACK_LOCATION irpSpNext;
    NTSTATUS status;

    if (deferralContext->DeferAction == DEFERACTION_QUEUE_PASSIVE_TIMER) {

        //
        // Wait the appropriate amount of time if so ordered...
        //
        ASSERT(KeGetCurrentIrql()==PASSIVE_LEVEL);
        KeWaitForSingleObject(
            &deferralContext->DeferralTimer,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }

    VfPacketAcquireLock(deferralContext->IovRequestPacket);

    VfIrpMakeTouchable(deferralContext->OriginalIrp);

    irpSpNext = IoGetNextIrpStackLocation( deferralContext->OriginalIrp );

    ASSERT(irpSpNext == deferralContext->IrpSpNext);
    ASSERT(irpSpNext->CompletionRoutine == deferralContext->OriginalCompletionRoutine);
    ASSERT(irpSpNext->Context == deferralContext->OriginalContext);

    ASSERT(deferralContext->IovRequestPacket->Flags & TRACKFLAG_QUEUED_INTERNALLY);
    deferralContext->IovRequestPacket->Flags &= ~TRACKFLAG_QUEUED_INTERNALLY;

    VfPacketDereference(deferralContext->IovRequestPacket, IOVREFTYPE_POINTER);
    VfPacketReleaseLock(deferralContext->IovRequestPacket);

    status = irpSpNext->CompletionRoutine(
        deferralContext->DeviceObject,
        deferralContext->OriginalIrp,
        irpSpNext->Context
        );

    if (status!=STATUS_MORE_PROCESSING_REQUIRED) {

        IoCompleteRequest(deferralContext->OriginalIrp, deferralContext->OriginalPriorityBoost);
    }
    ExFreePool(deferralContext);
}


NTSTATUS
IovpInternalDeferredCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

  Description:

    This function is slipped in as a completion routine when we are
    "deferring" completion via work item, etc.

  Arguments:

    DeviceObject           - Device object set at this level of the completion
                             routine - passed on.

    Irp                    - A pointer to the IRP.

    Context                - Context block that includes original completion
                             routine.

  Return Value:

     NTSTATUS

--*/
{
    PDEFERRAL_CONTEXT deferralContext = (PDEFERRAL_CONTEXT) Context;
    PIO_STACK_LOCATION irpSpNext;
    BOOLEAN passiveCompletionOK;
    DEFER_ACTION deferAction;
    ULONG refAction;
    LARGE_INTEGER deltaTime;
    PVERIFIER_SETTINGS_SNAPSHOT verifierOptions;
    LONG deferralTime;

    //
    // Retrieve time delta.
    //
    VfSettingsGetValue(
        deferralContext->IovRequestPacket->VerifierSettings,
        VERIFIER_VALUE_IRP_DEFERRAL_TIME,
        (PULONG) &deferralTime
        );

    //
    // Do delta time conversion.
    //
    deltaTime.QuadPart = -deferralTime;

    //
    // The *next* stack location holds our completion and context. The current
    // stack location has already been wiped.
    //
    irpSpNext = IoGetNextIrpStackLocation( Irp );

    ASSERT((PVOID) irpSpNext->CompletionRoutine == IovpInternalDeferredCompletion);

    //
    // Put everything back in case someone is looking...
    //
    irpSpNext->CompletionRoutine = deferralContext->OriginalCompletionRoutine;
    irpSpNext->Context = deferralContext->OriginalContext;

    //
    // Some IRP dispatch routines cannot be called at passive. Two examples are
    // paging IRPs (cause we could switch) and Power IRPs. As we don't check yet,
    // if we "were" completed passive, continue to do so, but elsewhere...
    //
    passiveCompletionOK = (KeGetCurrentIrql()==PASSIVE_LEVEL);

    VfPacketAcquireLock(deferralContext->IovRequestPacket);

    //
    // Verify all completion routines are in nonpaged code.
    //
    if (VfSettingsIsOptionEnabled(
        deferralContext->IovRequestPacket->VerifierSettings,
        VERIFIER_OPTION_POLICE_IRPS
        )) {

        if (MmIsSystemAddressLocked(irpSpNext->CompletionRoutine) == FALSE) {

            WDM_FAIL_ROUTINE((
                DCERROR_COMPLETION_ROUTINE_PAGABLE,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                irpSpNext->CompletionRoutine,
                Irp
                ));
        }
    }

    verifierOptions = deferralContext->IovRequestPacket->VerifierSettings;

    ASSERT(VfSettingsIsOptionEnabled(verifierOptions, VERIFIER_OPTION_FORCE_PENDING));

    if (VfSettingsIsOptionEnabled(verifierOptions, VERIFIER_OPTION_DEFER_COMPLETION)) {

        //
        // Now see whether we can safely defer completion...
        //
        if (VfSettingsIsOptionEnabled(verifierOptions, VERIFIER_OPTION_COMPLETE_AT_PASSIVE)) {

            deferAction = passiveCompletionOK ? DEFERACTION_QUEUE_PASSIVE_TIMER :
                                                DEFERACTION_NORMAL;

        } else if (VfSettingsIsOptionEnabled(verifierOptions, VERIFIER_OPTION_COMPLETE_AT_DISPATCH)) {

            deferAction = DEFERACTION_QUEUE_DISPATCH_TIMER;

        } else {

            deferAction = (KeGetCurrentIrql()==DISPATCH_LEVEL) ?
                DEFERACTION_QUEUE_DISPATCH_TIMER :
                DEFERACTION_QUEUE_PASSIVE_TIMER;
        }

    } else if (VfSettingsIsOptionEnabled(verifierOptions, VERIFIER_OPTION_COMPLETE_AT_PASSIVE)) {

        deferAction = passiveCompletionOK ? DEFERACTION_QUEUE_WORKITEM :
                                            DEFERACTION_NORMAL;
    } else {

        deferAction = DEFERACTION_NORMAL;
        KDASSERT(0);
    }

    if (deferAction != DEFERACTION_NORMAL) {

        //
        // Set this flag. If anybody uses this IRP while this flag is on, complain
        // immediately!
        //
        ASSERT(!(deferralContext->IovRequestPacket->Flags&TRACKFLAG_QUEUED_INTERNALLY));
        deferralContext->IovRequestPacket->Flags |= TRACKFLAG_QUEUED_INTERNALLY;
        deferralContext->DeviceObject = DeviceObject;
        VfIrpMakeUntouchable(Irp);

    } else {

        VfPacketDereference(deferralContext->IovRequestPacket, IOVREFTYPE_POINTER);
    }

    VfPacketReleaseLock(deferralContext->IovRequestPacket);

    deferralContext->DeferAction = deferAction;

    switch(deferAction) {

        case DEFERACTION_QUEUE_PASSIVE_TIMER:
            KeInitializeTimerEx(&deferralContext->DeferralTimer, SynchronizationTimer);
            KeSetTimerEx(
                &deferralContext->DeferralTimer,
                deltaTime,
                0,
                NULL
                );

            //
            // Fall through...
            //

        case DEFERACTION_QUEUE_WORKITEM:

            //
            // Queue this up so we can complete this passively.
            //
            ExInitializeWorkItem(
                (PWORK_QUEUE_ITEM)&deferralContext->WorkQueueItem,
                IovpInternalCompleteAfterWait,
                deferralContext
                );

            ExQueueWorkItem(
                (PWORK_QUEUE_ITEM)&deferralContext->WorkQueueItem,
                DelayedWorkQueue
                );

            return STATUS_MORE_PROCESSING_REQUIRED;

        case DEFERACTION_QUEUE_DISPATCH_TIMER:

            KeInitializeDpc(
                &deferralContext->DpcItem,
                IovpInternalCompleteAtDPC,
                deferralContext
                );

            KeInitializeTimerEx(&deferralContext->DeferralTimer, SynchronizationTimer);
            KeSetTimerEx(
                &deferralContext->DeferralTimer,
                deltaTime,
                0,
                &deferralContext->DpcItem
                );
            return STATUS_MORE_PROCESSING_REQUIRED;

        case DEFERACTION_NORMAL:
        default:

            ExFreePool(deferralContext);
            return irpSpNext->CompletionRoutine(DeviceObject, Irp, irpSpNext->Context);
    }
}


NTSTATUS
IovpSwapSurrogateIrp(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp,
    IN      PVOID           Context
    )
/*++

  Description:

    This completion routine will copy back the surrogate IRP
    to the original and complete the original IRP.

  Arguments:

    DeviceObject           - Device object set at this level
                             of the completion routine - ignored.

    Irp                    - A pointer to the IRP.

    Context                - Context should equal the IRP - this is
                             asserted.

  Return Value:

     STATUS_MORE_PROCESSING_REQUIRED...

--*/
{
    PIOV_REQUEST_PACKET iovPacket, iovPrevPacket;
    PIOV_SESSION_DATA iovSessionData;
    ULONG irpSize;
    PIRP realIrp;
    BOOLEAN freeTrackingData;
    NTSTATUS status, lockedStatus;
    CCHAR priorityBoost;
    PVOID completionRoutine;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN locked;

    //
    // If this one fails, somebody has probably copied the stack
    // inclusive with our completion routine. We should already
    // have caught this...
    //
    ASSERT(Irp == Context);

    iovPacket = VfPacketFindAndLock(Irp);
    ASSERT(iovPacket);

    if (iovPacket == NULL) {

        return STATUS_SUCCESS;
    }

    ASSERT(iovPacket->TopStackLocation == Irp->CurrentLocation);

    iovSessionData = VfPacketGetCurrentSessionData(iovPacket);
    ASSERT(iovSessionData);

    //
    // Put everything back
    //
    ASSERT(iovPacket->ChainHead != (PIOV_DATABASE_HEADER) iovPacket);

    iovPrevPacket = (PIOV_REQUEST_PACKET) VfIrpDatabaseEntryGetChainPrevious(
        (PIOV_DATABASE_HEADER) iovPacket
        );

    realIrp = iovPrevPacket->TrackedIrp;
    irpSize = IoSizeOfIrp( Irp->StackCount );

    //
    // Back the IRP stack up so that the original completion routine
    // is called if appropriate
    //
    IoSetNextIrpStackLocation(Irp);
    IoSetNextIrpStackLocation(realIrp);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    irpSp->CompletionRoutine = iovPacket->RealIrpCompletionRoutine;
    irpSp->Control           = iovPacket->RealIrpControl;
    irpSp->Context           = iovPacket->RealIrpContext;

    //
    // Record final data and make any accesses to the surrogate IRP
    // crash.
    //
    irpSp = IoGetNextIrpStackLocation(Irp);
    if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        VfMajorVerifyFinalIrpStack(iovPacket, irpSp);
    }

    priorityBoost = iovPacket->PriorityBoost;
    VfPacketDereference(iovPacket, IOVREFTYPE_POINTER);
    IovpSessionDataFinalizeSurrogate(iovSessionData, iovPacket, Irp);
    IovpSessionDataClose(iovSessionData);
    IovpSessionDataDereference(iovSessionData);

    TRACKIRP_DBGPRINT((
        "  Swapping surrogate IRP %lx back to %lx (Tracking data %lx)\n",
        Irp,
        realIrp,
        iovPacket
        ), 1);

    iovPacket->Flags |= TRACKFLAG_SWAPPED_BACK;

    //
    // We have to be a bit more careful since the chain has been split. Release
    // the locks in the proper order.
    //
    VfPacketReleaseLock(iovPrevPacket);
    VfPacketReleaseLock(iovPacket);

    //
    // Send the IRP onwards and upwards.
    //
    IoCompleteRequest(realIrp, priorityBoost);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
FASTCALL
IovpCancelIrp(
    IN     PIRP             Irp,
    OUT    PBOOLEAN         CancelHandled,
    OUT    PBOOLEAN         ReturnValue
    )
/*++

  Description:

    This routine is called by IoCancelIrp and returns TRUE iff
    the cancelation was handled internally here (in which case
    IoCancelIrp should do nothing).

    We need to handle the call internally when we are currently
    dealing with a surrogate. In this case, we make sure the
    surrogate is cancelled instead.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IoCancelIrp.

    CancelHandled          - Indicates whether the IRP cancellation
                             was handled entirely by this routine.

    ReturnValue            - Set to the value IoCancelIrp
                             should return if the IRP cancelation
                             was handled entirely by this routine.

  Return Value:

     None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket, iovNextPacket;
    PIRP irpToCancel;
    KIRQL irql;

    *CancelHandled = FALSE;

    iovPacket = VfPacketFindAndLock(Irp);
    if (iovPacket == NULL) {

        return;
    }

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_CANCEL_IRP,
        NULL,
        0
        );

    //
    // If the IRP is queued internally, touching it is not very safe as we may
    // have temporarily removed the page's backing. Restore the backing while
    // under the IRPs track lock.
    //

    if (iovPacket->Flags&TRACKFLAG_QUEUED_INTERNALLY) {

        VfIrpMakeTouchable(Irp);
    }

    if (!(iovPacket->Flags&TRACKFLAG_ACTIVE)) {

        //
        // We've already completed the IRP, and the only reason it's
        // still being tracked is because of it's allocation.
        // So it is not ours to cancel.
        //
        VfPacketReleaseLock(iovPacket);
        return;
    }

    if (!(iovPacket->Flags&TRACKFLAG_HAS_SURROGATE)) {

        //
        // Cancel of an IRP that doesn't have an active surrogate. Let it
        // proceed normally.
        //
        VfPacketReleaseLock(iovPacket);
        return;
    }

    if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        if (Irp->CancelRoutine) {

            WDM_FAIL_ROUTINE((
                DCERROR_CANCELROUTINE_ON_FORWARDED_IRP,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                Irp->CancelRoutine,
                Irp
                ));

            //
            // We will ignore this routine. As we should...
            //
        }
    }

    iovNextPacket = (PIOV_REQUEST_PACKET) VfIrpDatabaseEntryGetChainNext(
        (PIOV_DATABASE_HEADER) iovPacket
        );

    Irp->Cancel = TRUE;
    *CancelHandled = TRUE;
    irpToCancel = iovNextPacket->TrackedIrp;
    VfPacketReleaseLock(iovPacket);
    *ReturnValue = IoCancelIrp(irpToCancel);

    return;
}


/*
 * Device Object functions
 *   IovpExamineDevObjForwarded
 *
 */

VOID
FASTCALL
IovpExamineDevObjForwarding(
    IN     PDEVICE_OBJECT DeviceBeingCalled,
    IN     PDEVICE_OBJECT DeviceLastCalled      OPTIONAL,
    OUT    PULONG         ForwardTechnique
    )
/*++

    Returns:

        STARTED_TOP_OF_STACK
        FORWARDED_TO_NEXT_DO
        SKIPPED_A_DO
        STARTED_INSIDE_STACK
        CHANGED_STACKS_AT_BOTTOM
        CHANGED_STACKS_MID_STACK

--*/

{
    PDEVICE_OBJECT upperObject;
    DEVOBJ_RELATION deviceObjectRelation;
    ULONG result;

    if (DeviceLastCalled == NULL) {

        IovUtilGetUpperDeviceObject(DeviceBeingCalled, &upperObject);

        if (upperObject) {

            ObDereferenceObject(upperObject);
            *ForwardTechnique = STARTED_INSIDE_STACK;

        } else {

            *ForwardTechnique = STARTED_TOP_OF_STACK;
        }

        return;
    }

    IovUtilRelateDeviceObjects(
        DeviceBeingCalled,
        DeviceLastCalled,
        &deviceObjectRelation
        );

    switch(deviceObjectRelation) {

        case DEVOBJ_RELATION_IDENTICAL:

            //
            // We map forwarded nowhere to forwarded ahead.
            //
            result = FORWARDED_TO_NEXT_DO;
            break;

        case DEVOBJ_RELATION_FIRST_IMMEDIATELY_BELOW_SECOND:
            result = FORWARDED_TO_NEXT_DO;
            break;

        case DEVOBJ_RELATION_FIRST_BELOW_SECOND:

            //
            // This is very likely a driver forwarding IRPs directly to the PDO.
            //
            result = SKIPPED_A_DO;
            break;

        case DEVOBJ_RELATION_FIRST_IMMEDIATELY_ABOVE_SECOND:
        case DEVOBJ_RELATION_FIRST_ABOVE_SECOND:

            //
            // Weird. Really???? Did the IRP truely go backwards, *up* the
            // stack?
            //
            ASSERT(0);
            result = SKIPPED_A_DO;
            break;


        case DEVOBJ_RELATION_NOT_IN_SAME_STACK:

            IovUtilGetUpperDeviceObject(DeviceBeingCalled, &upperObject);

            if (upperObject) {

                ObDereferenceObject(upperObject);
                result = CHANGED_STACKS_MID_STACK;

            } else {

                result = CHANGED_STACKS_AT_BOTTOM;
            }
            break;

        default:
            ASSERT(0);
            result = FORWARDED_TO_NEXT_DO;
            break;
    }

    *ForwardTechnique = result;
}


VOID
IovpBuildMiniIrpSnapshot(
    IN  PIRP                Irp,
    OUT IRP_MINI_SNAPSHOT   *IrpSnapshot
    )
/*++

Routine Description:

    This routine builds a minimal snapshot of an IRP. It covers the Irp pointer
    and the stack location contents.

Parameters:

    Irp                    - A pointer to the IRP to snapshot. The *next* stack
                             location of the IRP is snapshotted by this
                             function.

    IrpSnapshot            - Receives snapshot of IRP.

Return Value:

    None.

--*/
{
    IrpSnapshot->Irp = Irp;

    RtlCopyMemory(
        &IrpSnapshot->IoStackLocation,
        IoGetNextIrpStackLocation(Irp),
        sizeof(IO_STACK_LOCATION)
        );
}

#endif // NO_SPECIAL_IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\sessnirp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sessnirp.c

Abstract:

    I/O Verifier irp support routines.

Author:

    Adrian Oney (adriao)

Environment:

    Kernel mode

Revision History:


--*/

#include "iop.h"
#include "srb.h"

//
// This entire file is only present if NO_SPECIAL_IRP isn't defined
//
#ifndef NO_SPECIAL_IRP

//
// When enabled, everything is locked down on demand...
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, IovpSessionDataCreate)
#pragma alloc_text(PAGEVRFY, IovpSessionDataAdvance)
#pragma alloc_text(PAGEVRFY, IovpSessionDataReference)
#pragma alloc_text(PAGEVRFY, IovpSessionDataDereference)
#pragma alloc_text(PAGEVRFY, IovpSessionDataClose)
#pragma alloc_text(PAGEVRFY, IovpSessionDataDeterminePolicy)
#pragma alloc_text(PAGEVRFY, IovpSessionDataAttachSurrogate)
#pragma alloc_text(PAGEVRFY, IovpSessionDataFinalizeSurrogate)
#pragma alloc_text(PAGEVRFY, IovpSessionDataBufferIO)
#pragma alloc_text(PAGEVRFY, IovpSessionDataUnbufferIO)
#endif

#define POOL_TAG_SESSION_DATA       'sprI'
#define POOL_TAG_DIRECT_BUFFER      'BprI'

PIOV_SESSION_DATA
FASTCALL
IovpSessionDataCreate(
    IN      PDEVICE_OBJECT       DeviceObject,
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    OUT     PBOOLEAN             SurrogateSpawned
    )
/*++

  Description:

    This routine creates tracking data for a new IRP. It must be called on the
    thread the IRP was originally sent down...

  Arguments:

    Irp                    - Irp to track.

  Return Value:

    iovPacket block, NULL if no memory.

--*/
{
    PIRP irp, surrogateIrp;
    PIOV_SESSION_DATA iovSessionData;
    PIOV_REQUEST_PACKET headPacket;
    ULONG sessionDataSize;
    BOOLEAN trackable, useSurrogateIrp;

    *SurrogateSpawned = FALSE;

    headPacket = (PIOV_REQUEST_PACKET) (*IovPacketPointer)->ChainHead;
    ASSERT(headPacket == (*IovPacketPointer));
    irp = headPacket->TrackedIrp;

    //
    // Check the IRP appropriately
    //
    IovpSessionDataDeterminePolicy(
        headPacket,
        DeviceObject,
        &trackable,
        &useSurrogateIrp
        );

    if (!trackable) {

        return NULL;
    }

    //
    // One extra stack location is allocated as the "zero'th" is used to
    // simplify some logic...
    //
    sessionDataSize =
        sizeof(IOV_SESSION_DATA)+
        irp->StackCount*sizeof(IOV_STACK_LOCATION) +
        VfSettingsGetSnapshotSize();

    iovSessionData = ExAllocatePoolWithTag(
        NonPagedPool,
        sessionDataSize,
        POOL_TAG_SESSION_DATA
        );

    if (iovSessionData == NULL) {

        return NULL;
    }

    RtlZeroMemory(iovSessionData, sessionDataSize);

    iovSessionData->VerifierSettings = (PVERIFIER_SETTINGS_SNAPSHOT)
        (((PUCHAR) iovSessionData) + (sessionDataSize-VfSettingsGetSnapshotSize()));

    RtlCopyMemory(
        iovSessionData->VerifierSettings,
        headPacket->VerifierSettings,
        VfSettingsGetSnapshotSize()
        );

    iovSessionData->IovRequestPacket = headPacket;
    InsertHeadList(&headPacket->SessionHead, &iovSessionData->SessionLink);

    if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_DEFER_COMPLETION)||
        VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_COMPLETE_AT_PASSIVE)) {

        VfSettingsSetOption(iovSessionData->VerifierSettings, VERIFIER_OPTION_FORCE_PENDING, TRUE);
    }

    //
    // If DeferIoCompletion is set we definitely want to monitor pending I/O, as
    // screwing it up is gaurenteed to be fatal!
    //
    if ((irp->Flags & IRP_DEFER_IO_COMPLETION) &&
        VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        VfSettingsSetOption(iovSessionData->VerifierSettings, VERIFIER_OPTION_MONITOR_PENDING_IO, TRUE);
    }

    headPacket->pIovSessionData = iovSessionData;
    headPacket->TopStackLocation = irp->CurrentLocation;
    headPacket->Flags |= TRACKFLAG_ACTIVE;
    headPacket->Flags &= ~
        (
        TRACKFLAG_QUEUED_INTERNALLY|
        TRACKFLAG_RELEASED|
        TRACKFLAG_SRB_MUNGED|
        TRACKFLAG_SWAPPED_BACK
        );

    iovSessionData->BestVisibleIrp = irp;
    if (useSurrogateIrp) {

        //
        // We will track the IRP using a surrogate.
        //
        *SurrogateSpawned = IovpSessionDataAttachSurrogate(
            IovPacketPointer,
            iovSessionData
            );
    }

    TRACKIRP_DBGPRINT((
        "  SSN CREATE(%x)->%x\n",
        headPacket,
        iovSessionData
        ), 3);

    return iovSessionData;
}


VOID
FASTCALL
IovpSessionDataAdvance(
    IN      PDEVICE_OBJECT       DeviceObject,
    IN      PIOV_SESSION_DATA    IovSessionData,
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    OUT     PBOOLEAN             SurrogateSpawned
    )
{
    *SurrogateSpawned = FALSE;
}


VOID
FASTCALL
IovpSessionDataDereference(
    IN PIOV_SESSION_DATA IovSessionData
    )
{
    PIOV_REQUEST_PACKET iovPacket;

    iovPacket = IovSessionData->IovRequestPacket;
    ASSERT((PIOV_REQUEST_PACKET) iovPacket->ChainHead == iovPacket);

    ASSERT_SPINLOCK_HELD(&iovPacket->HeaderLock);
    ASSERT(IovSessionData->SessionRefCount > 0);
    ASSERT(iovPacket->ReferenceCount >= 0);

    TRACKIRP_DBGPRINT((
        "  SSN DEREF(%x) %x--\n",
        IovSessionData,
        IovSessionData->SessionRefCount
        ), 3);

    IovSessionData->SessionRefCount--;
    if (!IovSessionData->SessionRefCount) {

        ASSERT(iovPacket->pIovSessionData != IovSessionData);
        ASSERT(iovPacket->ReferenceCount > iovPacket->PointerCount);
        //ASSERT(IsListEmpty(&IovSessionData->SessionLink));
        RemoveEntryList(&IovSessionData->SessionLink);
        InitializeListHead(&IovSessionData->SessionLink);

        VfPacketDereference(iovPacket, IOVREFTYPE_PACKET);

        ExFreePool(IovSessionData);
    }
}


VOID
FASTCALL
IovpSessionDataReference(
    IN PIOV_SESSION_DATA IovSessionData
    )
{
    PIOV_REQUEST_PACKET iovPacket;

    iovPacket = IovSessionData->IovRequestPacket;
    ASSERT((PIOV_REQUEST_PACKET) iovPacket->ChainHead == iovPacket);

    ASSERT_SPINLOCK_HELD(&iovPacket->HeaderLock);
    ASSERT(IovSessionData->SessionRefCount >= 0);
    ASSERT(iovPacket->ReferenceCount >= 0);

    TRACKIRP_DBGPRINT((
        "  SSN REF(%x) %x++\n",
        IovSessionData,
        IovSessionData->SessionRefCount
        ), 3);

    if (!IovSessionData->SessionRefCount) {

        VfPacketReference(iovPacket, IOVREFTYPE_PACKET);
    }
    IovSessionData->SessionRefCount++;
}


VOID
FASTCALL
IovpSessionDataClose(
    IN PIOV_SESSION_DATA IovSessionData
    )
{
   PIOV_REQUEST_PACKET iovPacket = IovSessionData->IovRequestPacket;

   ASSERT_SPINLOCK_HELD(&iovPacket->HeaderLock);

   ASSERT(iovPacket == (PIOV_REQUEST_PACKET) iovPacket->ChainHead);
   ASSERT(iovPacket->pIovSessionData == IovSessionData);

   TRACKIRP_DBGPRINT((
       "  SSN CLOSE(%x)\n",
       IovSessionData
       ), 3);

   iovPacket->Flags &= ~TRACKFLAG_ACTIVE;
   iovPacket->pIovSessionData = NULL;
}


VOID
IovpSessionDataDeterminePolicy(
    IN   PIOV_REQUEST_PACKET IovRequestPacket,
    IN   PDEVICE_OBJECT      DeviceObject,
    OUT  PBOOLEAN            Trackable,
    OUT  PBOOLEAN            UseSurrogateIrp
    )
/*++

  Description:

    This routine is called by IovpCallDriver1 to determine which IRPs should
    be tracked and how that tracking should be done.

  Arguments:

    IovRequestPacket - Verifier data representing the incoming IRP

    DeviceObject - Device object the IRP is being forwarded to

    Trackable - Set if the IRP should be marked trackable

    UseSurrogateIrp - Set a surrogate should be created for this IRP

  Return Value:

     None.

--*/
{
    PIO_STACK_LOCATION irpSp;
    PIRP irp;

    irp = IovRequestPacket->TrackedIrp;

    //
    // Determine whether we are to monitor this IRP. If we are going to test
    // any one driver in a stack, then we must unfortunately monitor the IRP's
    // progress through the *entire* stack. Thus our granularity here is stack
    // based, not device based! We will compensate for this somewhat in the
    // driver check code, which will attempt to ignore asserts from those
    // "non-targetted" drivers who happen to have messed up in our stack...
    //
    *Trackable = IovUtilIsVerifiedDeviceStack(DeviceObject);

    irpSp = IoGetNextIrpStackLocation(irp);

    if (VfSettingsIsOptionEnabled(IovRequestPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

        *UseSurrogateIrp = VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SURROGATE_IRPS);
        *UseSurrogateIrp &= (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SMASH_SRBS) ||
                             (irpSp->MajorFunction != IRP_MJ_SCSI));
    } else {

        *UseSurrogateIrp = FALSE;
    }
}


BOOLEAN
FASTCALL
IovpSessionDataAttachSurrogate(
    IN OUT  PIOV_REQUEST_PACKET  *IovPacketPointer,
    IN      PIOV_SESSION_DATA    IovSessionData
    )
/*++

  Description:

    This routine creates tracking data for a new IRP. It must be called on the
    thread the IRP was originally sent down...

  Arguments:

    IovPacketPointer       - Pointer to IRP packet to attach surrogate to. If
                             a surrogate can be attached the packet will be
                             updated to track the surrogate.

    SurrogateIrp           - Prepared surrogate IRP to attach.

  Return Value:

    iovPacket block, NULL if no memory.

--*/
{

    PIOV_REQUEST_PACKET iovSurrogatePacket, iovPacket, headPacket;
    PIRP surrogateIrp, irp;
    PIO_STACK_LOCATION irpSp;
    PSCSI_REQUEST_BLOCK srb;
    CCHAR activeSize;

    iovPacket = *IovPacketPointer;
    ASSERT_SPINLOCK_HELD(&iovPacket->HeaderLock);

    ASSERT(VfIrpDatabaseEntryGetChainNext((PIOV_DATABASE_HEADER) iovPacket) == NULL);

    ASSERT(iovPacket->Flags & TRACKFLAG_ACTIVE);

    irp = iovPacket->TrackedIrp;
    activeSize = (irp->CurrentLocation-1);
    ASSERT(activeSize);

    //
    // We now try to make a copy of this new IRP which we will track. We
    // do this so that we may free *every* tracked IRP immediately upon
    // completion.
    // Technically speaking, we only need to allocate what's left of the
    // stack, not the entire thing. But using the entire stack makes our
    // work much much easier. Specifically the session stack array may depend
    // on this.
    //
    // ADRIAO N.B. 03/04/1999 - Make this work only copying a portion of the
    // IRP.
    //
    surrogateIrp = VfIrpAllocate(irp->StackCount); // activeSize

    if (surrogateIrp == NULL) {

        return FALSE;
    }

    //
    // Now set up the new IRP - we do this here so VfPacketCreateAndLock
    // can peek at it's fields. Start with the IRP header.
    //
    RtlCopyMemory(surrogateIrp, irp, sizeof(IRP));

    //
    // Adjust StackCount and CurrentLocation
    //
    surrogateIrp->StackCount = irp->StackCount; // activeSize
    surrogateIrp->Tail.Overlay.CurrentStackLocation =
        ((PIO_STACK_LOCATION) (surrogateIrp+1))+activeSize;

    //
    // Our new IRP "floats", and is not attached to any thread.
    // Note that all cancels due to thread death will come through the
    // original IRP.
    //
    InitializeListHead(&surrogateIrp->ThreadListEntry);

    //
    // Our new IRP also is not connected to user mode.
    //
    surrogateIrp->UserEvent = NULL;
    surrogateIrp->UserIosb = NULL;

    //
    // Now copy over only the active portions of IRP. Be very careful to not
    // assume that the last stack location is right after the end of the IRP,
    // as we may change this someday!
    //
    irpSp = (IoGetCurrentIrpStackLocation(irp)-activeSize);
    RtlCopyMemory(surrogateIrp+1, irpSp, sizeof(IO_STACK_LOCATION)*activeSize);

    //
    // Zero the portion of the new IRP we won't be using (this should
    // eventually go away).
    //
    RtlZeroMemory(
        ((PIO_STACK_LOCATION) (surrogateIrp+1))+activeSize,
        sizeof(IO_STACK_LOCATION)*(surrogateIrp->StackCount - activeSize)
        );

    //
    // Now create a surrogate packet to track the new IRP.
    //
    iovSurrogatePacket = VfPacketCreateAndLock(surrogateIrp);
    if (iovSurrogatePacket == NULL) {

        VfIrpFree(surrogateIrp);
        return FALSE;
    }

    headPacket = (PIOV_REQUEST_PACKET) iovPacket->ChainHead;

    ASSERT(iovSurrogatePacket->LockIrql == DISPATCH_LEVEL);
    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // We will flag this bug later.
    //
    irp->CancelRoutine = NULL;

    //
    // Let's take advantage of the original IRP not being the thing partied on
    // now; store a pointer to our tracking data in the information field. We
    // don't use this, but it's nice when debugging...
    //
    irp->IoStatus.Information = (ULONG_PTR) iovPacket;

    //
    // ADRIAO N.B. #28 06/10/98 - This is absolutely *gross*, and not
    //                            deterministic enough for my tastes.
    //
    // For IRP_MJ_SCSI (ie, IRP_MJ_INTERNAL_DEVICE_CONTROL), look and see
    // if we have an SRB coming through. If so, fake out the OriginalRequest
    // IRP pointer as appropriate.
    //
    if (irpSp->MajorFunction == IRP_MJ_SCSI) {
        srb = irpSp->Parameters.Others.Argument1;
        if (VfUtilIsMemoryRangeReadable(srb, SCSI_REQUEST_BLOCK_SIZE, VFMP_INSTANT_NONPAGED)) {
            if ((srb->Length == SCSI_REQUEST_BLOCK_SIZE)&&(srb->OriginalRequest == irp)) {
                srb->OriginalRequest = surrogateIrp;
                headPacket->Flags |= TRACKFLAG_SRB_MUNGED;
            }
        }
    }

    //
    // Since the replacement will never make it back to user mode (the real
    // IRP shall of course), we will steal a field or two for debugging info.
    //
    surrogateIrp->UserIosb = (PIO_STATUS_BLOCK) iovPacket;

    //
    // Now that everything is built correctly, attach the surrogate. The
    // surrogate holds down the packet we are attaching to. When the surrogate
    // dies we will remove this reference.
    //
    VfPacketReference(iovPacket, IOVREFTYPE_POINTER);

    //
    // Stamp IRPs appropriately.
    //
    surrogateIrp->Flags |= IRP_DIAG_IS_SURROGATE;
    irp->Flags |= IRP_DIAG_HAS_SURROGATE;

    //
    // Mark packet as surrogate and inherit appropriate fields from iovPacket.
    //
    iovSurrogatePacket->Flags |= TRACKFLAG_SURROGATE | TRACKFLAG_ACTIVE;
    iovSurrogatePacket->pIovSessionData = iovPacket->pIovSessionData;

    RtlCopyMemory(
        iovSurrogatePacket->VerifierSettings,
        iovPacket->VerifierSettings,
        VfSettingsGetSnapshotSize()
        );

    iovSurrogatePacket->LastLocation = iovPacket->LastLocation;
    iovSurrogatePacket->TopStackLocation = irp->CurrentLocation;

    iovSurrogatePacket->ArrivalIrql = iovPacket->ArrivalIrql;
    iovSurrogatePacket->DepartureIrql = iovPacket->DepartureIrql;

    iovPacket->Flags |= TRACKFLAG_HAS_SURROGATE;

    //
    // Link in the new surrogate
    //
    VfIrpDatabaseEntryAppendToChain(
        (PIOV_DATABASE_HEADER) iovPacket,
        (PIOV_DATABASE_HEADER) iovSurrogatePacket
        );

    *IovPacketPointer = iovSurrogatePacket;

    IovpSessionDataBufferIO(
        iovSurrogatePacket,
        surrogateIrp
        );

    return TRUE;
}


VOID
FASTCALL
IovpSessionDataFinalizeSurrogate(
    IN      PIOV_SESSION_DATA    IovSessionData,
    IN OUT  PIOV_REQUEST_PACKET  IovPacket,
    IN      PIRP                 SurrogateIrp
    )
/*++

  Description:

    This routine removes the flags from both the real and
    surrogate IRP and records the final IRP settings. Finally,
    the surrogate IRP is made "untouchable" (decommitted).

  Arguments:

    iovPacket              - Pointer to the IRP tracking data.

  Return Value:

     None.
--*/
{
    PIOV_REQUEST_PACKET iovPrevPacket;
    NTSTATUS status, lockedStatus;
    ULONG nonInterestingFlags;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;

    ASSERT(IovPacket->Flags&TRACKFLAG_SURROGATE);

    ASSERT(VfPacketGetCurrentSessionData(IovPacket) == IovSessionData);

    IovPacket->pIovSessionData = NULL;

    //
    // It's a surrogate, do as appropriate.
    //
    ASSERT(IovPacket->TopStackLocation == SurrogateIrp->CurrentLocation+1);

    IovpSessionDataUnbufferIO(IovPacket, SurrogateIrp);

    iovPrevPacket = (PIOV_REQUEST_PACKET) VfIrpDatabaseEntryGetChainPrevious(
        (PIOV_DATABASE_HEADER) IovPacket
        );

    irp = iovPrevPacket->TrackedIrp;

    //
    // Carry the pending bit over.
    //
    if (SurrogateIrp->PendingReturned) {
        IoMarkIrpPending(irp);
    }

    nonInterestingFlags = (
        IRPFLAG_EXAMINE_MASK |
        IRP_DIAG_IS_SURROGATE|
        IRP_DIAG_HAS_SURROGATE
        );

    //
    // Wipe the flags nice and clean
    //
    SurrogateIrp->Flags &= ~IRP_DIAG_IS_SURROGATE;
    irp->Flags          &= ~IRP_DIAG_HAS_SURROGATE;

    //
    // ASSERT portions of the IRP header have not changed.
    //
    ASSERT(irp->StackCount == SurrogateIrp->StackCount); // Later to be removed

    ASSERT(irp->Type == SurrogateIrp->Type);
    ASSERT(irp->RequestorMode == SurrogateIrp->RequestorMode);
    ASSERT(irp->ApcEnvironment == SurrogateIrp->ApcEnvironment);
    ASSERT(irp->AllocationFlags == SurrogateIrp->AllocationFlags);
    ASSERT(irp->Tail.Overlay.Thread == SurrogateIrp->Tail.Overlay.Thread);

    ASSERT(
        irp->Overlay.AsynchronousParameters.UserApcRoutine ==
        SurrogateIrp->Overlay.AsynchronousParameters.UserApcRoutine
        );

    ASSERT(
        irp->Overlay.AsynchronousParameters.UserApcContext ==
        SurrogateIrp->Overlay.AsynchronousParameters.UserApcContext
        );

    ASSERT(
        irp->Tail.Overlay.OriginalFileObject ==
        SurrogateIrp->Tail.Overlay.OriginalFileObject
        );

    ASSERT(
        irp->Tail.Overlay.AuxiliaryBuffer ==
        SurrogateIrp->Tail.Overlay.AuxiliaryBuffer
        );

/*
    ASSERT(
        irp->AssociatedIrp.SystemBuffer ==
        SurrogateIrp->AssociatedIrp.SystemBuffer
        );

    ASSERT(
        (irp->Flags          & ~nonInterestingFlags) ==
        (SurrogateIrp->Flags & ~nonInterestingFlags)
        );

    ASSERT(irp->MdlAddress == SurrogateIrp->MdlAddress);
*/
    //
    // ADRIAO N.B. 02/28/1999 -
    //     How do these change as an IRP progresses?
    //
    irp->Flags |= SurrogateIrp->Flags;
    irp->MdlAddress = SurrogateIrp->MdlAddress;
    irp->AssociatedIrp.SystemBuffer = SurrogateIrp->AssociatedIrp.SystemBuffer;

    //
    // ADRIAO N.B. 10/18/1999 - UserBuffer is edited by netbios on Type3 device
    //                          ioctls. Yuck!
    //
    irp->UserBuffer = SurrogateIrp->UserBuffer;

    if ((irp->Flags&IRP_DEALLOCATE_BUFFER)&&
        (irp->AssociatedIrp.SystemBuffer == NULL)) {

        irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Copy the salient fields back. We only need to touch certain areas of the
    // header.
    //
    irp->IoStatus = SurrogateIrp->IoStatus;
    irp->PendingReturned = SurrogateIrp->PendingReturned;
    irp->Cancel = SurrogateIrp->Cancel;

    iovPrevPacket->Flags &= ~TRACKFLAG_HAS_SURROGATE;

    //
    // Record data from it and make the system fault if the IRP is touched
    // after this completion routine.
    //
    IovSessionData->BestVisibleIrp = irp;

    IovSessionData->IovRequestPacket = iovPrevPacket;

    VfIrpDatabaseEntryRemoveFromChain((PIOV_DATABASE_HEADER) IovPacket);

    VfPacketDereference(iovPrevPacket, IOVREFTYPE_POINTER);

    ASSERT(IovPacket->PointerCount == 0);

    VfIrpFree(SurrogateIrp);
}


VOID
FASTCALL
IovpSessionDataBufferIO(
    IN OUT  PIOV_REQUEST_PACKET  IovSurrogatePacket,
    IN      PIRP                 SurrogateIrp
    )
{
    PMDL mdl;
    ULONG bufferLength;
    PUCHAR bufferVA, systemDestVA;
    PVOID systemBuffer;
    PIO_STACK_LOCATION irpSp;

    if (!VfSettingsIsOptionEnabled(IovSurrogatePacket->VerifierSettings, VERIFIER_OPTION_BUFFER_DIRECT_IO)) {

        return;
    }

    if (SurrogateIrp->Flags & IRP_PAGING_IO) {

        return;
    }

    if (SurrogateIrp->MdlAddress == NULL) {

        return;
    }

    if (SurrogateIrp->MdlAddress->Next) {

        return;
    }

    if (SurrogateIrp->Flags & IRP_BUFFERED_IO) {

        return;
    }

    irpSp = IoGetNextIrpStackLocation(SurrogateIrp);

    if (irpSp->MajorFunction != IRP_MJ_READ) {

        return;
    }

    //
    // Extract length and VA from the MDL.
    //
    bufferLength = SurrogateIrp->MdlAddress->ByteCount;
    bufferVA = (PUCHAR) SurrogateIrp->MdlAddress->StartVa +
                        SurrogateIrp->MdlAddress->ByteOffset;

    //
    // Allocate memory and make it the target of the MDL
    //
    systemBuffer = ExAllocatePoolWithTagPriority(
        NonPagedPool,
        bufferLength,
        POOL_TAG_DIRECT_BUFFER,
        HighPoolPrioritySpecialPoolOverrun
        );

    if (systemBuffer == NULL) {

        return;
    }

    //
    // Save off a pointer to the Mdl's buffer. This should never fail, but
    // one never knows...
    //
    systemDestVA =
        MmGetSystemAddressForMdlSafe(SurrogateIrp->MdlAddress, HighPagePriority);

    if (systemDestVA == NULL) {

        ASSERT(0);
        ExFreePool(systemBuffer);
        return;
    }

    //
    // Allocate a MDL, update the IRP.
    //
    mdl = IoAllocateMdl(
        systemBuffer,
        bufferLength,
        FALSE,
        TRUE,
        SurrogateIrp
        );

    if (mdl == NULL) {

        ExFreePool(systemBuffer);
        return;
    }

    MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    IovSurrogatePacket->SystemDestVA = systemDestVA;
    IovSurrogatePacket->Flags |= TRACKFLAG_DIRECT_BUFFERED;
}


VOID
FASTCALL
IovpSessionDataUnbufferIO(
    IN OUT  PIOV_REQUEST_PACKET  IovSurrogatePacket,
    IN      PIRP                 SurrogateIrp
    )
{
    PMDL mdl;
    ULONG surrogateLength, originalLength;
    ULONG_PTR bufferLength;
    PUCHAR surrogateVA, originalVA, systemDestVA;
    PVOID systemBuffer;
    PIOV_REQUEST_PACKET iovPrevPacket;
    PIRP irp;

    if (!(IovSurrogatePacket->Flags & TRACKFLAG_DIRECT_BUFFERED)) {

        return;
    }

    iovPrevPacket = (PIOV_REQUEST_PACKET) VfIrpDatabaseEntryGetChainPrevious(
        (PIOV_DATABASE_HEADER) IovSurrogatePacket
        );

    irp = iovPrevPacket->TrackedIrp;

    ASSERT(SurrogateIrp->MdlAddress);
    ASSERT(SurrogateIrp->MdlAddress->Next == NULL);
    ASSERT(irp->MdlAddress);
    ASSERT(irp->MdlAddress->Next == NULL);
    ASSERT(!(SurrogateIrp->Flags & IRP_BUFFERED_IO));
    ASSERT(!(irp->Flags & IRP_BUFFERED_IO));

    //
    // Extract length and VA from the MDLs.
    //
    surrogateLength = SurrogateIrp->MdlAddress->ByteCount;
    surrogateVA = (PUCHAR) SurrogateIrp->MdlAddress->StartVa +
                           SurrogateIrp->MdlAddress->ByteOffset;

    //
    // We use these only for the purpose of assertions.
    //
    originalLength = irp->MdlAddress->ByteCount;
    originalVA = (PUCHAR) irp->MdlAddress->StartVa +
                          irp->MdlAddress->ByteOffset;

    ASSERT(surrogateLength == originalLength);
    ASSERT(SurrogateIrp->IoStatus.Information <= originalLength);

    //
    // Get the target buffer address and the length to write.
    //
    bufferLength = SurrogateIrp->IoStatus.Information;
    systemDestVA = IovSurrogatePacket->SystemDestVA;

    //
    // Copy things over.
    //
    RtlCopyMemory(systemDestVA, surrogateVA, bufferLength);

    //
    // Unlock the MDL. We have to do this ourselves as this IRP is not going to
    // progress through all of IoCompleteRequest.
    //
    MmUnlockPages(SurrogateIrp->MdlAddress);

    //
    // Cleanup.
    //
    IoFreeMdl(SurrogateIrp->MdlAddress);

    //
    // Free our allocated VA
    //
    ExFreePool(surrogateVA);

    //
    // Hack the MDL back as IovpSessionDataFinalizeSurrogate requires it.
    //
    SurrogateIrp->MdlAddress = irp->MdlAddress;

    IovSurrogatePacket->Flags &= ~TRACKFLAG_DIRECT_BUFFERED;
}

#endif // NO_SPECIAL_IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\arcsec.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    arcsec.c

Abstract:

    This module contains subroutines for protecting the system
    partition on an ARC system.

Author:

    Jim Kelly  (JimK) 13-Jan-1993

Environment:

    Kernel mode - system initialization

Revision History:


--*/

#include "iomgr.h"

//
// Define procedures local to this module.
//

NTSTATUS
IopApplySystemPartitionProt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IopProtectSystemPartition)
#pragma alloc_text(INIT,IopApplySystemPartitionProt)
#endif

//
// This name must match the name use by the DISK MANAGER utility.
// The Disk Manager creates and sets the value of this registry
// key.  We only look at it.
//

#define IOP_SYSTEM_PART_PROT_KEY    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
#define IOP_SYSTEM_PART_PROT_VALUE  L"Protect System Partition"

BOOLEAN
IopProtectSystemPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine assigns protection to the system partition of an
    ARC system, if necessary.  If this is not an ARC system, or
    the system partition does not need to be protected, then this
    routine does nothing.


Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

Return Value:

    The function value is a BOOLEAN indicating whether or not protection
    has been appropriately applied.   TRUE indicates no errors were
    encountered.  FALSE indicates an error was encountered.


--*/

{

    //
    // We only entertain the possibility of assigning protection
    // to the system partition if we are an ARC system.  For the
    // time being, the best way to determine if you are an ARC
    // system is to see if you aren't and X86 machine.  DavidRo
    // believes that at some point in the future we will have
    // ARC compliant X86 machines.  At that point in time, we
    // will need to change the following #ifdef's into something
    // that does a run-time determination.
    //

#ifdef i386  // if (!ARC-Compliant system)

    UNREFERENCED_PARAMETER (LoaderBlock);

    //
    // Nothing to do for non-ARC systems
    //

    return(TRUE);


#else // ARC-COMPLIANT system

    NTSTATUS status;
    NTSTATUS tmpStatus;
    HANDLE keyHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    UNICODE_STRING valueName;
    ULONG resultLength;
    ULONG keyBuffer[sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG )];
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;

    //
    // This is an ARC system.  Attempt to retrieve information from the registry
    // indicating whether or not we should protect the system partition.
    //

    RtlInitUnicodeString( &keyName, IOP_SYSTEM_PART_PROT_KEY );
    InitializeObjectAttributes( &objectAttributes,
                                &keyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    status = NtOpenKey( &keyHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS( status )) {

        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION) &keyBuffer[0];
        RtlInitUnicodeString( &valueName, IOP_SYSTEM_PART_PROT_VALUE );
        status = NtQueryValueKey( keyHandle,
                                  &valueName,
                                  KeyValuePartialInformation,
                                  keyValue,
                                  sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG ),
                                  &resultLength );

        if (NT_SUCCESS( status )) {

            PBOOLEAN applyIt;

            //
            // The appropriate information was located in the registry.  Now
            // determine whether or not is indicates that protection is to be
            // applied.
            //

            applyIt = &(keyValue->Data[0]);

            if (*applyIt) {
                status = IopApplySystemPartitionProt( LoaderBlock );
            }
        }

        tmpStatus = NtClose( keyHandle );
        ASSERT(NT_SUCCESS( tmpStatus ));
    }


    return TRUE;

#endif // ARC-COMPLIANT system
}

NTSTATUS
IopApplySystemPartitionProt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine applies protection to the system partition that
    prevents all users except administrators from accessing the
    partition.


    This routine is only used during system initialization.
    As such, all memory allocations are expected to succeed.
    Success is tested only with assertions.


Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

Return Value:

    The function value is the final status from attempting to set the system
    partition protection.


--*/

{
    NTSTATUS status;
    PACL dacl;
    SECURITY_DESCRIPTOR securityDescriptor;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG length;
    CHAR ArcNameFmt[12];

    ArcNameFmt[0] = '\\';
    ArcNameFmt[1] = 'A';
    ArcNameFmt[2] = 'r';
    ArcNameFmt[3] = 'c';
    ArcNameFmt[4] = 'N';
    ArcNameFmt[5] = 'a';
    ArcNameFmt[6] = 'm';
    ArcNameFmt[7] = 'e';
    ArcNameFmt[8] = '\\';
    ArcNameFmt[9] = '%';
    ArcNameFmt[10] = 's';
    ArcNameFmt[11] = '\0';

    ASSERT( ARGUMENT_PRESENT( LoaderBlock ) );
    ASSERT( ARGUMENT_PRESENT( LoaderBlock->ArcHalDeviceName ) );

    //
    // Build an appropriate discretionary ACL.
    //

    length = (ULONG) sizeof( ACL ) +
             ( 2 * ((ULONG) sizeof( ACCESS_ALLOWED_ACE ))) +
             SeLengthSid( SeLocalSystemSid ) +
             SeLengthSid( SeAliasAdminsSid ) +
             8; // The 8 is just for good measure

    dacl = (PACL) ExAllocatePool( PagedPool, length );
    if (!dacl) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( dacl, length, ACL_REVISION2 );
    if (NT_SUCCESS( status )) {

        status = RtlAddAccessAllowedAce( dacl,
                                         ACL_REVISION2,
                                         GENERIC_ALL,
                                         SeLocalSystemSid );
        if (NT_SUCCESS( status )) {

            status = RtlAddAccessAllowedAce( dacl,
                                             ACL_REVISION2,
                                             GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | READ_CONTROL,
                                             SeAliasAdminsSid );
            if (NT_SUCCESS( status )) {

                //
                // Put it in a security descriptor so that it may be applied to
                // the system partition device.
                //

                status = RtlCreateSecurityDescriptor( &securityDescriptor,
                                                      SECURITY_DESCRIPTOR_REVISION );
                if (NT_SUCCESS( status )) {

                    status = RtlSetDaclSecurityDescriptor( &securityDescriptor,
                                                           TRUE,
                                                           dacl,
                                                           FALSE );
                }
            }
        }
    }

    if (!NT_SUCCESS( status )) {
        ExFreePool( dacl );
        return status;
    }

    //
    // Open the ARC boot device and apply the ACL.
    //

    {
        NTSTATUS tmpStatus;
        CHAR deviceNameBuffer[256];
        STRING deviceNameString;
        UNICODE_STRING deviceNameUnicodeString;
        HANDLE deviceHandle;
        IO_STATUS_BLOCK ioStatusBlock;

        //
        // Begin by formulating the ARC name of the boot device in the ARC
        // name space.
        //

        sprintf( deviceNameBuffer,
                 ArcNameFmt,
                 LoaderBlock->ArcHalDeviceName );

        RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

        status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                               &deviceNameString,
                                               TRUE );

        if (NT_SUCCESS( status )) {

            InitializeObjectAttributes( &objectAttributes,
                                        &deviceNameUnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            status = ZwOpenFile( &deviceHandle,
                                 WRITE_DAC,
                                 &objectAttributes,
                                 &ioStatusBlock,
                                 TRUE,
                                 0 );

            RtlFreeUnicodeString( &deviceNameUnicodeString );

            if (NT_SUCCESS( status )) {


                //
                // Apply the ACL built above to the system partition device
                // object.
                //

                status = ZwSetSecurityObject( deviceHandle,
                                              DACL_SECURITY_INFORMATION,
                                              &securityDescriptor );

                tmpStatus = NtClose( deviceHandle );
            }
        }
    }

    //
    // Free the memory used to hold the ACL.
    //

    ExFreePool( dacl );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract

    This module contains the code to implement the NtCreateFile,
    the NtCreateNamedPipeFile and the NtCreateMailslotFile system
    services.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtCreateFile)
#pragma alloc_text(PAGE, NtCreateNamedPipeFile)
#pragma alloc_text(PAGE, NtCreateMailslotFile)
#endif

NTSTATUS
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )

/*++

Routine Description:

    This service opens or creates a file, or opens a device.  It is used to
    establish a file handle to the open device/file that can then be used
    in subsequent operations to perform I/O operations on.  For purposes of
    readability, files and devices are treated as "files" throughout the
    majority of this module and the system service portion of the I/O system.
    The only time a distinction is made is when it is important to determine
    which is really being accessed.  Then a distinction is also made in the
    comments.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.  This
        parameter only has an affect if the file is created.  Further, if
        not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    CreateDisposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file if
        it is created.

    EaLength - Supplies the length of the EaBuffer.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to do the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         AllocationSize,
                         FileAttributes,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         EaBuffer,
                         EaLength,
                         CreateFileTypeNone,
                         (PVOID)NULL,
                         0 );
}

NTSTATUS
NtCreateNamedPipeFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN PLARGE_INTEGER DefaultTimeout OPTIONAL
     )

/*++

Routine Description:

    Creates and opens the server end handle of the first instance of a
    specific named pipe or another instance of an existing named pipe.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    CreateDisposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    NamedPipeType - Type of named pipe to create (Bitstream or message).

    ReadMode - Mode in which to read the pipe (Bitstream or message).

    CompletionMode - Specifies how the operation is to be completed.

    MaximumInstances - Maximum number of simultaneous instances of the named
        pipe.

    InboundQuota - Specifies the pool quota that is reserved for writes to the
        inbound side of the named pipe.

    OutboundQuota - Specifies the pool quota that is reserved for writes to
        the inbound side of the named pipe.

    DefaultTimeout - Optional pointer to a timeout value that is used if a
        timeout value is not specified when waiting for an instance of a named
        pipe.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    NAMED_PIPE_CREATE_PARAMETERS namedPipeCreateParameters;

    PAGED_CODE();

    //
    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then capture it in the named pipe create parameter structure.
    //

    if (ARGUMENT_PRESENT( DefaultTimeout )) {

        //
        // Indicate that a default timeout period was specified.
        //

        namedPipeCreateParameters.TimeoutSpecified = TRUE;

        //
        // A default timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
        //

        if (KeGetPreviousMode() != KernelMode) {
            try {
                ProbeForReadSmallStructure ( DefaultTimeout,
                                             sizeof( LARGE_INTEGER ),
                                             sizeof( ULONG ) );
                namedPipeCreateParameters.DefaultTimeout = *DefaultTimeout;
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Something went awry attempting to access the parameter.
                // Get the reason for the error and return it as the status
                // value from this service.
                //

                return GetExceptionCode();
            }
        } else {

            //
            // The caller's mode was kernel so simply store the parameter.
            //

            namedPipeCreateParameters.DefaultTimeout = *DefaultTimeout;
        }
    } else {

        //
        // Indicate that no default timeout period was specified.
        //

        namedPipeCreateParameters.TimeoutSpecified = FALSE;
    }

    //
    // Store the remainder of the named pipe-specific parameters in the
    // structure for use in the call to the common create file routine.
    //

    namedPipeCreateParameters.NamedPipeType = NamedPipeType;
    namedPipeCreateParameters.ReadMode = ReadMode;
    namedPipeCreateParameters.CompletionMode = CompletionMode;
    namedPipeCreateParameters.MaximumInstances = MaximumInstances;
    namedPipeCreateParameters.InboundQuota = InboundQuota;
    namedPipeCreateParameters.OutboundQuota = OutboundQuota;

    //
    // Simply perform the remainder of the service by allowing the common
    // file creation code to do the work.
    //

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNamedPipe,
                         &namedPipeCreateParameters,
                         0 );
}

NTSTATUS
NtCreateMailslotFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     )

/*++

Routine Description:

    Creates and opens the server end handle of a mailslot file.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Address of the caller's I/O status block.

    CreateOptions - Caller options for how to perform the create/open.

    MailslotQuota - Specifies the pool quota that is reserved for writes
        to this mailslot.

    MaximumMessageSize - Specifies the size of the largest message that
        can be written to this mailslot.

    ReadTimeout - The timeout period for a read operation.  This must
        be specified as a relative time.

Return Value:

    The function value is the final status of the create operation.

--*/

{
    MAILSLOT_CREATE_PARAMETERS mailslotCreateParameters;

    PAGED_CODE();

    //
    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then capture it in the mailslot create parameter structure.
    //

    if (ARGUMENT_PRESENT( ReadTimeout )) {

        //
        // Indicate that a read timeout period was specified.
        //

        mailslotCreateParameters.TimeoutSpecified = TRUE;

        //
        // A read timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
        //

        if (KeGetPreviousMode() != KernelMode) {
            try {
                ProbeForReadSmallStructure( ReadTimeout,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                mailslotCreateParameters.ReadTimeout = *ReadTimeout;
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Something went awry attempting to access the parameter.
                // Get the reason for the error and return it as the status
                // value from this service.
                //

                return GetExceptionCode();
            }
        } else {

            //
            // The caller's mode was kernel so simply store the parameter.
            //

            mailslotCreateParameters.ReadTimeout = *ReadTimeout;
        }
    } else {

        //
        // Indicate that no default timeout period was specified.
        //

        mailslotCreateParameters.TimeoutSpecified = FALSE;
    }

    //
    // Store the mailslot-specific parameters in the structure for use
    // in the call to the common create file routine.
    //

    mailslotCreateParameters.MailslotQuota = MailslotQuota;
    mailslotCreateParameters.MaximumMessageSize = MaximumMessageSize;

    //
    // Simply perform the remainder of the service by allowing the common
    // file creation code to do the work.
    //

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_CREATE,
                         CreateOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeMailslot,
                         &mailslotCreateParameters,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\dev2dos.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dev2dos.c

Abstract:

    This module implements the device object to DOS name routine.

Author:

    Norbert Kusters (norbertk)  21-Oct-1998
    Nar Ganapathy (narg)        1-April-2000 - Moved the code to IO manager

Environment:

    Kernel Mode.

Revision History:

--*/

#include <iomgr.h>
#include <mountdev.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' d2D')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' d2D')
#endif

NTSTATUS
IoVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

#if defined(ALLOC_PRAGMA) 
#pragma alloc_text(PAGE,IoVolumeDeviceToDosName)
#endif

NTSTATUS
IoVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    )

/*++

Routine Description:

    This routine returns a valid DOS path for the given device object.
    This caller of this routine must call ExFreePool on DosName->Buffer
    when it is no longer needed.

Arguments:

    VolumeDeviceObject  - Supplies the volume device object.

    DosName             - Returns the DOS name for the volume

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT          volumeDeviceObject = VolumeDeviceObject;
    PMOUNTDEV_NAME          name;
    CHAR                    output[512], out[sizeof(MOUNTMGR_VOLUME_PATHS)];
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    UNICODE_STRING          mountmgrName;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    PMOUNTMGR_VOLUME_PATHS  paths;
    ULONG                   len;

    //
    //  We are using a stack event and so must be at passive.
    //
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    name = (PMOUNTDEV_NAME) output;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        volumeDeviceObject, NULL, 0, name, 512,
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(volumeDeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitUnicodeString(&mountmgrName, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&mountmgrName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    paths = (PMOUNTMGR_VOLUME_PATHS) out;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH,
                                        deviceObject, name, 512,
                                        paths, sizeof(MOUNTMGR_VOLUME_PATHS),
                                        FALSE, &event, &ioStatus);
    if (!irp)  {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW) {
        ObDereferenceObject(fileObject);
        return status;
    }

    len = sizeof(MOUNTMGR_VOLUME_PATHS) + paths->MultiSzLength;

    //
    // Ensure that there is no overflow.
    //

    if (len > MAXUSHORT) {
        ObDereferenceObject(fileObject);
        return STATUS_INVALID_BUFFER_SIZE;
    }

    paths = ExAllocatePool(PagedPool, len);
    if (!paths) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH,
                                        deviceObject, name, 512,
                                        paths, len, FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(paths);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(paths);
        ObDereferenceObject(fileObject);
        return status;
    }

    DosName->Length = (USHORT) paths->MultiSzLength - 2*sizeof(WCHAR);
    DosName->MaximumLength = DosName->Length + sizeof(WCHAR);
    DosName->Buffer = (PWCHAR) paths;

    RtlCopyMemory(paths, paths->MultiSz, DosName->Length);
    DosName->Buffer[DosName->Length/sizeof(WCHAR)] = 0;

    ObDereferenceObject(fileObject);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\complete.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    complete.c

Abstract:

   This module implements the executive I/O completion object. Functions are
   provided to create, open, query, and wait for I/O completion objects.

Author:

    David N. Cutler (davec) 25-Feb-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "iomgr.h"


//
// Define forward referenced function prototypes.
//

VOID
IopFreeMiniPacket (
    PIOP_MINI_COMPLETION_PACKET MiniPacket
    );

//
// Define section types for appropriate functions.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtCreateIoCompletion)
#pragma alloc_text(PAGE, NtOpenIoCompletion)
#pragma alloc_text(PAGE, NtQueryIoCompletion)
#pragma alloc_text(PAGE, NtRemoveIoCompletion)
#pragma alloc_text(PAGE, NtSetIoCompletion)
#pragma alloc_text(PAGE, IoSetIoCompletion)
#pragma alloc_text(PAGE, IopFreeMiniPacket)
#pragma alloc_text(PAGE, IopDeleteIoCompletion)
#endif

NTSTATUS
NtCreateIoCompletion (
    IN PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function creates an I/O completion object, sets the maximum
    target concurrent thread count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    IoCompletionHandle - Supplies a pointer to a variable that receives
        the I/O completion object handle.

    DesiredAccess - Supplies the desired types of access for the I/O
        completion object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    Count - Supplies the target maximum  number of threads that should
        be concurrently active. If this parameter is not specified, then
        the number of processors is used.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PVOID IoCompletion;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create an I/O completion object. If the probe fails, then
    // return the exception code as the service status. Otherwise, return the
    // status value returned by the object insertion routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(IoCompletionHandle);
        }

        //
        // Allocate I/O completion object.
        //

        Status = ObCreateObject(PreviousMode,
                                IoCompletionObjectType,
                                ObjectAttributes,
                                PreviousMode,
                                NULL,
                                sizeof(KQUEUE),
                                0,
                                0,
                                (PVOID *)&IoCompletion);

        //
        // If the I/O completion object was successfully allocated, then
        // initialize the object and attempt to insert it in the handle
        // table of the current process.
        //

        if (NT_SUCCESS(Status)) {
            KeInitializeQueue((PKQUEUE)IoCompletion, Count);
            Status = ObInsertObject(IoCompletion,
                                    NULL,
                                    DesiredAccess,
                                    0,
                                    (PVOID *)NULL,
                                    &Handle);

            //
            // If the I/O completion object was successfully inserted in
            // the handle table of the current process, then attempt to
            // write the handle value. If the write attempt fails, then
            // do not report an error. When the caller attempts to access
            // the handle value, an access violation will occur.
            //

            if (NT_SUCCESS(Status)) {
                try {
                    *IoCompletionHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        Status = GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an I/O completion object with the
    specified desired access.

Arguments:

    IoCompletionHandle - Supplies a pointer to a variable that receives
        the completion object handle.

    DesiredAccess - Supplies the desired types of access for the I/O
        completion object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address,
    // and attempt to open an I/O completion object. If the probe fails,
    // then return the exception code as the service status. Otherwise,
    // return the status value returned by the object open routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(IoCompletionHandle);
        }

        //
        // Open handle to the completion object with the specified desired
        // access.
        //

        Status = ObOpenObjectByName(ObjectAttributes,
                                    IoCompletionObjectType,
                                    PreviousMode,
                                    NULL,
                                    DesiredAccess,
                                    NULL,
                                    &Handle);

        //
        // If the open was successful, then attempt to write the I/O
        // completion object handle value. If the write attempt fails,
        // then do not report an error. When the caller attempts to
        // access the handle value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                *IoCompletionHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        Status = GetExceptionCode();
    }


    //
    // Return service status.
    //

    return Status;
}


NTSTATUS
NtQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of an I/O completion object and returns
    the requested information in the specified record structure.

Arguments:

    IoCompletionHandle - Supplies a handle to an I/O completion object.

    IoCompletionInformationClass - Supplies the class of information being
        requested.

    IoCompletionInformation - Supplies a pointer to a record that receives
        the requested information.

    IoCompletionInformationLength - Supplies the length of the record that
        receives the requested information.

    ReturnLength - Supplies an optional pointer to a variable that receives
        the actual length of the information that is returned.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PVOID IoCompletion;
    LONG Depth;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the I/O completion object, and return the specified information. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    try {

        //
        // Get previous processor mode and probe output arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure(IoCompletionInformation,
                                        sizeof(IO_COMPLETION_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        //
        // Check argument validity.
        //

        if (IoCompletionInformationClass != IoCompletionBasicInformation) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (IoCompletionInformationLength != sizeof(IO_COMPLETION_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Reference the I/O completion object by handle.
        //

        Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                           IO_COMPLETION_QUERY_STATE,
                                           IoCompletionObjectType,
                                           PreviousMode,
                                           &IoCompletion,
                                           NULL);

        //
        // If the reference was successful, then read the current state of
        // the I/O completion object, dereference the I/O completion object,
        // fill in the information structure, and return the structure length
        // if specified. If the write of the I/O completion information or
        // the return length fails, then do not report an error. When the
        // caller accesses the information structure or length an access
        // violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            Depth = KeReadStateQueue((PKQUEUE)IoCompletion);
            ObDereferenceObject(IoCompletion);
            try {
                ((PIO_COMPLETION_BASIC_INFORMATION)IoCompletionInformation)->Depth = Depth;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(IO_COMPLETION_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }

    //
    // If an exception occurs during the probe of the output arguments, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        Status = GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletionHandle - Supplies a handle to the io completion port
        that the caller intends to queue a completion packet to

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{
    PVOID IoCompletion;
    NTSTATUS Status;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       IO_COMPLETION_MODIFY_STATE,
                                       IoCompletionObjectType,
                                       KeGetPreviousMode(),
                                       &IoCompletion,
                                       NULL);

    if (NT_SUCCESS(Status)) {
        Status = IoSetIoCompletion(IoCompletion,
                                   KeyContext,
                                   ApcContext,
                                   IoStatus,
                                   IoStatusInformation,
                                   TRUE);

        ObDereferenceObject(IoCompletion);
        }
    return Status;

}

NTSTATUS
NtRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes an entry from an I/O completion object. If there
    are currently no entries available, then the calling thread waits for
    an entry.

Arguments:

    Completion - Supplies a handle to an I/O completion object.

    KeyContext - Supplies a pointer to a variable that receives the key
        context that was specified when the I/O completion object was
        assoicated with a file object.

    ApcContext - Supplies a pointer to a variable that receives the
        context that was specified when the I/O operation was issued.

    IoStatus - Supplies a pointer to a variable that receives the
        I/O completion status.

    Timeout - Supplies a pointer to an optional time out value.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PLARGE_INTEGER CapturedTimeout;
    PLIST_ENTRY Entry;
    PVOID IoCompletion;
    PIRP Irp;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    LARGE_INTEGER TimeoutValue;
    PVOID LocalApcContext;
    PVOID LocalKeyContext;
    IO_STATUS_BLOCK LocalIoStatusBlock;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Establish an exception handler, probe the I/O context, the I/O
    // status, and the optional timeout value if specified, reference
    // the I/O completion object, and attempt to remove an entry from
    // the I/O completion object. If the probe fails, then return the
    // exception code as the service status. Otherwise, return a value
    // dependent on the outcome of the queue removal.
    //

    try {

        //
        // Get previous processor mode and probe the I/O context, status,
        // and timeout if necessary.
        //

        CapturedTimeout = NULL;
        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUlong_ptr((PULONG_PTR)ApcContext);
            ProbeForWriteUlong_ptr((PULONG_PTR)KeyContext);
            ProbeForWriteIoStatus(IoStatusBlock);
            if (ARGUMENT_PRESENT(Timeout)) {
                CapturedTimeout = &TimeoutValue;
                TimeoutValue = ProbeAndReadLargeInteger(Timeout);
            }

        } else{
            if (ARGUMENT_PRESENT(Timeout)) {
                CapturedTimeout = Timeout;
            }
        }

        //
        // Reference the I/O completion object by handle.
        //

        Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                           IO_COMPLETION_MODIFY_STATE,
                                           IoCompletionObjectType,
                                           PreviousMode,
                                           &IoCompletion,
                                           NULL);

        //
        // If the reference was successful, then attempt to remove an entry
        // from the I/O completion object. If an entry is removed from the
        // I/O completion object, then capture the completion information,
        // release the associated IRP, and attempt to write the completion
        // inforamtion. If the write of the completion infomation fails,
        // then do not report an error. When the caller attempts to access
        // the completion information, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            Entry = KeRemoveQueue((PKQUEUE)IoCompletion,
                                  PreviousMode,
                                  CapturedTimeout);

            //
            // N.B. The entry value returned can be the address of a list
            //      entry, STATUS_USER_APC, or STATUS_TIMEOUT.
            //

            if (((LONG_PTR)Entry == STATUS_TIMEOUT) ||
                ((LONG_PTR)Entry == STATUS_USER_APC)) {
                Status = (NTSTATUS)((LONG_PTR)Entry);

            } else {

                //
                // Set the completion status, capture the completion
                // information, deallocate the associated IRP, and
                // attempt to write the completion information.
                //

                Status = STATUS_SUCCESS;
                try {
                    MiniPacket = CONTAINING_RECORD(Entry,
                                                   IOP_MINI_COMPLETION_PACKET,
                                                   ListEntry);

                    if ( MiniPacket->PacketType == IopCompletionPacketIrp ) {
                        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
                        LocalApcContext = Irp->Overlay.AsynchronousParameters.UserApcContext;
                        LocalKeyContext = (PVOID)Irp->Tail.CompletionKey;
                        LocalIoStatusBlock = Irp->IoStatus;
                        IoFreeIrp(Irp);

                    } else {

                        LocalApcContext = MiniPacket->ApcContext;
                        LocalKeyContext = (PVOID)MiniPacket->KeyContext;
                        LocalIoStatusBlock.Status = MiniPacket->IoStatus;
                        LocalIoStatusBlock.Information = MiniPacket->IoStatusInformation;
                        IopFreeMiniPacket(MiniPacket);
                    }

                    *ApcContext = LocalApcContext;
                    *KeyContext = LocalKeyContext;
                    *IoStatusBlock = LocalIoStatusBlock;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }

            //
            // Deference I/O completion object.
            //

            ObDereferenceObject(IoCompletion);
        }

    //
    // If an exception occurs during the probe of the previous count, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        Status = GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation,
    IN BOOLEAN Quota
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletion - Supplies a a pointer to the completion port that the caller
        intends to queue a completion packet to.

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion.

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion.

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion.

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PGENERAL_LOOKASIDE Lookaside;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;
    ULONG PacketType;
    PKPRCB Prcb;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Attempt to allocate the minpacket from the per processor lookaside list.
    //

    PacketType = IopCompletionPacketMini;
    Prcb = KeGetCurrentPrcb();
    Lookaside = Prcb->PPLookasideList[LookasideCompletionList].P;
    Lookaside->TotalAllocates += 1;
    MiniPacket = (PVOID)InterlockedPopEntrySList(&Lookaside->ListHead);

    //
    // If the per processor lookaside list allocation failed, then attempt to
    // allocate from the system lookaside list.
    //

    if (MiniPacket == NULL) {
        Lookaside->AllocateMisses += 1;
        Lookaside = Prcb->PPLookasideList[LookasideCompletionList].L;
        Lookaside->TotalAllocates += 1;
        MiniPacket = (PVOID)InterlockedPopEntrySList(&Lookaside->ListHead);
    }

    //
    // If both lookaside allocation attempts failed, then attempt to allocate
    // from pool.
    //

    if (MiniPacket == NULL) {
        Lookaside->AllocateMisses += 1;

        //
        // If quota is specified, then allocate pool with quota charged.
        // Otherwise, allocate pool without quota.
        //

        if (Quota != FALSE) {
            PacketType = IopCompletionPacketQuota;
            try {
                MiniPacket = ExAllocatePoolWithQuotaTag(NonPagedPool,
                                                        sizeof(*MiniPacket),
                                                        ' pcI');

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            MiniPacket = ExAllocatePoolWithTagPriority(NonPagedPool,
                                               sizeof(*MiniPacket),
                                               ' pcI',
                                               LowPoolPriority);
        }
    }

    //
    // If a minipacket was successfully allocated, then initialize and
    // queue the packet to the specified I/O completion queue.
    //

    if (MiniPacket != NULL) {
        MiniPacket->PacketType = PacketType;
        MiniPacket->KeyContext = KeyContext;
        MiniPacket->ApcContext = ApcContext;
        MiniPacket->IoStatus = IoStatus;
        MiniPacket->IoStatusInformation = IoStatusInformation;
        KeInsertQueue((PKQUEUE)IoCompletion, &MiniPacket->ListEntry);

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
IopFreeMiniPacket (
    PIOP_MINI_COMPLETION_PACKET MiniPacket
    )

/*++

Routine Description:

    This function free the specefied I/O completion packet.

Arguments:

    MiniPacket - Supplies a pointer to an I/O completion minipacket.

Return Value:

    None.

--*/

{

    PGENERAL_LOOKASIDE Lookaside;
    PKPRCB Prcb;

    //
    // If the minipacket cannot be returned to either the per processor or
    // system lookaside list, then free the minipacket to pool. Otherwise,
    // release the quota if quota was allocated and push the entry onto
    // one of the lookaside lists.
    //

    Prcb = KeGetCurrentPrcb();
    Lookaside = Prcb->PPLookasideList[LookasideCompletionList].P;
    Lookaside->TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {
        Lookaside->FreeMisses += 1;
        Lookaside = Prcb->PPLookasideList[LookasideCompletionList].L;
        Lookaside->TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {
            Lookaside->FreeMisses += 1;
            ExFreePool(MiniPacket);

        } else {
            if (MiniPacket->PacketType == IopCompletionPacketQuota) {
                ExReturnPoolQuota(MiniPacket);
            }

            InterlockedPushEntrySList(&Lookaside->ListHead,
                                      (PSLIST_ENTRY)MiniPacket);
        }

    } else {
        if (MiniPacket->PacketType == IopCompletionPacketQuota) {
            ExReturnPoolQuota(MiniPacket);
        }

        InterlockedPushEntrySList(&Lookaside->ListHead,
                                  (PSLIST_ENTRY)MiniPacket);
    }

    return;
}

VOID
IopDeleteIoCompletion (
    IN PVOID    Object
    )

/*++

Routine Description:

    This function is the delete routine for I/O completion objects. Its
    function is to release all the entries in the repsective completion
    queue and to rundown all threads that are current associated.

Arguments:

    Object - Supplies a pointer to an executive I/O completion object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY FirstEntry;
    PIRP Irp;
    PLIST_ENTRY NextEntry;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Rundown threads associated with the I/O completion object and get
    // the list of unprocessed I/O completion IRPs.
    //

    FirstEntry = KeRundownQueue((PKQUEUE)Object);
    if (FirstEntry != NULL) {
        NextEntry = FirstEntry;
        do {
            MiniPacket = CONTAINING_RECORD(NextEntry,
                                           IOP_MINI_COMPLETION_PACKET,
                                           ListEntry);

            NextEntry = NextEntry->Flink;
            if (MiniPacket->PacketType == IopCompletionPacketIrp) {
                Irp = CONTAINING_RECORD(MiniPacket, IRP, Tail.Overlay.ListEntry);
                IoFreeIrp(Irp);

            } else {
                IopFreeMiniPacket(MiniPacket);
            }

        } while (FirstEntry != NextEntry);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\cancelapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cancelapi.c

Abstract:

    This module contains the cancel safe DDI set

Author:

    Nar Ganapathy (narg) 1-Jan-1999

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

//
// The library exposes everything with the name "Wdmlib". This ensures drivers
// using the backward compatible Cancel DDI Lib won't opportunistically pick
// up the kernel exports just because they were built using the XP DDK.
//
#if CSQLIB

#define CSQLIB_DDI(x) Wdmlib##x

#else

#define CSQLIB_DDI(x) x

#endif

VOID
IopCsqCancelRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine removes the IRP that's associated with a context from the queue.
    It's expected that this routine will be called from a timer or DPC or other threads which complete an
    IO. Note that the IRP associated with this context could already have been freed.

Arguments:

    Csq - Pointer to the cancel queue.
    Context - Context associated with Irp.


Return Value:

    Returns the IRP associated with the context. If the value is not NULL, the IRP was successfully
    retrieved and can be used safely. If the value is NULL, the IRP was already canceled.

--*/
{
    KIRQL   irql;
    PIO_CSQ_IRP_CONTEXT irpContext;
    PIO_CSQ cfq;

    UNREFERENCED_PARAMETER (DeviceObject);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    irpContext = Irp->Tail.Overlay.DriverContext[3];

    if (irpContext->Type == IO_TYPE_CSQ_IRP_CONTEXT) {
        cfq = irpContext->Csq;
    } else if ((irpContext->Type == IO_TYPE_CSQ) ||
                (irpContext->Type == IO_TYPE_CSQ_EX)) {
        cfq = (PIO_CSQ)irpContext;
    } else {

        //
        // Bad type
        //

        ASSERT(0);
        return;
    }

    ASSERT(cfq);

    cfq->ReservePointer = NULL; // Force drivers to be good citizens

    cfq->CsqAcquireLock(cfq, &irql);
    cfq->CsqRemoveIrp(cfq, Irp);


    //
    // Break the association if necessary.
    //

    if (irpContext != (PIO_CSQ_IRP_CONTEXT)cfq) {
        irpContext->Irp = NULL;

        Irp->Tail.Overlay.DriverContext[3] = NULL;
    }
    cfq->CsqReleaseLock(cfq, irql);

    cfq->CsqCompleteCanceledIrp(cfq, Irp);
}

NTSTATUS
CSQLIB_DDI(IoCsqInitialize)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    )
/*++

Routine Description:

    This routine initializes the Cancel queue

Arguments:

    Csq - Pointer to the cancel queue.


Return Value:

    The function returns STATUS_SUCCESS on successful initialization

--*/
{
    Csq->CsqInsertIrp = CsqInsertIrp;
    Csq->CsqRemoveIrp = CsqRemoveIrp;
    Csq->CsqPeekNextIrp = CsqPeekNextIrp;
    Csq->CsqAcquireLock = CsqAcquireLock;
    Csq->CsqReleaseLock = CsqReleaseLock;
    Csq->CsqCompleteCanceledIrp = CsqCompleteCanceledIrp;
    Csq->ReservePointer = NULL;

    Csq->Type = IO_TYPE_CSQ;

    return STATUS_SUCCESS;
}

NTSTATUS
CSQLIB_DDI(IoCsqInitializeEx)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP_EX            CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    )
/*++

Routine Description:

    This routine initializes the Cancel queue

Arguments:

    Csq - Pointer to the cancel queue.


Return Value:

    The function returns STATUS_SUCCESS on successful initialization

--*/
{
    Csq->CsqInsertIrp = (PIO_CSQ_INSERT_IRP)CsqInsertIrp;
    Csq->CsqRemoveIrp = CsqRemoveIrp;
    Csq->CsqPeekNextIrp = CsqPeekNextIrp;
    Csq->CsqAcquireLock = CsqAcquireLock;
    Csq->CsqReleaseLock = CsqReleaseLock;
    Csq->CsqCompleteCanceledIrp = CsqCompleteCanceledIrp;
    Csq->ReservePointer = NULL;

    Csq->Type = IO_TYPE_CSQ_EX;

    return STATUS_SUCCESS;
}

NTSTATUS
CSQLIB_DDI(IoCsqInsertIrpEx)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context,
    IN  PVOID               InsertContext
    )
/*++

Routine Description:

    This routine inserts the IRP into the queue and associates the context with the IRP.
    The context has to be in non-paged pool if the context will be used in a DPC or interrupt routine.
    The routine assumes that Irp->Tail.Overlay.DriverContext[3] is available for use by the APIs.
    It's ok to pass a NULL context if the driver assumes that it will always use IoCsqRemoveNextIrp to
    remove an IRP.

Arguments:

    Csq - Pointer to the cancel queue.
    Irp - Irp to be inserted
    Context - Context to be associated with Irp.
    InsertContext - Context passed to the driver's insert IRP routine.


Return Value:

    NTSTATUS - Status returned by the driver's insert IRP routine. If the driver's insert IRP
    routine returns an error status, the IRP is not inserted and the same status is returned
    by this API. This allows drivers to implement startIo kind of functionality.

--*/
{
    KIRQL           irql;
    PDRIVER_CANCEL  cancelRoutine;
    PVOID           originalDriverContext;
    NTSTATUS        status = STATUS_SUCCESS;

    //
    // Set the association between the context and the IRP.
    //

    if (Context) {
        Irp->Tail.Overlay.DriverContext[3] = Context;
        Context->Irp = Irp;
        Context->Csq = Csq;
        Context->Type = IO_TYPE_CSQ_IRP_CONTEXT;
    } else {
        Irp->Tail.Overlay.DriverContext[3] = Csq;
    }


    Csq->ReservePointer = NULL; // Force drivers to be good citizens

    originalDriverContext = Irp->Tail.Overlay.DriverContext[3];

    Csq->CsqAcquireLock(Csq, &irql);


    //
    // If the driver wants to fail the insert then do this.
    //

    if (Csq->Type == IO_TYPE_CSQ_EX) {

        PIO_CSQ_INSERT_IRP_EX   func;

        func = (PIO_CSQ_INSERT_IRP_EX)Csq->CsqInsertIrp;
        status = func(Csq, Irp, InsertContext);

        if (!NT_SUCCESS(status)) {

            Csq->CsqReleaseLock(Csq, irql);

            return status;
        }

    } else {
        Csq->CsqInsertIrp(Csq, Irp);
    }

    IoMarkIrpPending(Irp);

    cancelRoutine = IoSetCancelRoutine(Irp, IopCsqCancelRoutine);


    ASSERT(!cancelRoutine);

    if (Irp->Cancel) {

        cancelRoutine = IoSetCancelRoutine(Irp, NULL);

        if (cancelRoutine) {

            Csq->CsqRemoveIrp(Csq, Irp);

            if (Context) {
                Context->Irp = NULL;
            }

            Irp->Tail.Overlay.DriverContext[3] = NULL;


            Csq->CsqReleaseLock(Csq, irql);

            Csq->CsqCompleteCanceledIrp(Csq, Irp);

        } else {

            //
            // The cancel routine beat us to it.
            //

            Csq->CsqReleaseLock(Csq, irql);
        }

    } else {

        Csq->CsqReleaseLock(Csq, irql);

    }
    return status;
}

VOID
CSQLIB_DDI(IoCsqInsertIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    )
{
    (VOID)CSQLIB_DDI(IoCsqInsertIrpEx)(Csq, Irp, Context, NULL);
}

PIRP
CSQLIB_DDI(IoCsqRemoveNextIrp)(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    )
/*++

Routine Description:

    This routine removes the next IRP from the queue. This routine will enumerate the queue
    and return an IRP that's not canceled. If an IRP in the queue is canceled it goes to the next
    IRP. If no IRP is available it returns a NULL. The IRP returned is safe and cannot be canceled.

Arguments:

    Csq - Pointer to the cancel queue.


Return Value:

    Returns the IRP or NULL.

--*/
{
    KIRQL   irql;
    PIO_CSQ_IRP_CONTEXT context;
    PDRIVER_CANCEL  cancelRoutine;
    PIRP    irp;


    irp = NULL;

    Csq->ReservePointer = NULL; // Force drivers to be good citizens
    Csq->CsqAcquireLock(Csq, &irql);

    irp = Csq->CsqPeekNextIrp(Csq, NULL, PeekContext);

    while (1) {

        //
        // This routine will return a pointer to the next IRP in the queue adjacent to
        // the irp passed as a parameter. If the irp is NULL, it returns the IRP at the head of
        // the queue.
        //

        if (!irp) {
            Csq->CsqReleaseLock(Csq, irql);
            return NULL;
        }

        cancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (!cancelRoutine) {
            irp = Csq->CsqPeekNextIrp(Csq, irp, PeekContext);
            continue;
        }

        Csq->CsqRemoveIrp(Csq, irp);    // Remove this IRP from the queue

        break;
    }

    context = irp->Tail.Overlay.DriverContext[3];
    if (context->Type == IO_TYPE_CSQ_IRP_CONTEXT) {
        context->Irp = NULL;
        ASSERT(context->Csq == Csq);
    }

    irp->Tail.Overlay.DriverContext[3] = NULL;


    Csq->CsqReleaseLock(Csq, irql);

    return irp;
}

PIRP
CSQLIB_DDI(IoCsqRemoveIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    )
/*++

Routine Description:

    This routine removes the IRP that's associated with a context from the queue.
    It's expected that this routine will be called from a timer or DPC or other threads which complete an
    IO. Note that the IRP associated with this context could already have been freed.

Arguments:

    Csq - Pointer to the cancel queue.
    Context - Context associated with Irp.


Return Value:

    Returns the IRP associated with the context. If the value is not NULL, the IRP was successfully
    retrieved and can be used safely. If the value is NULL, the IRP was already canceled.

--*/
{
    KIRQL   irql;
    PIRP    irp;
    PDRIVER_CANCEL  cancelRoutine;

    Csq->ReservePointer = NULL; // Force drivers to be good citizens

    Csq->CsqAcquireLock(Csq, &irql);

    if (Context->Irp ) {

        ASSERT(Context->Csq == Csq);

        irp = Context->Irp;


        cancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (!cancelRoutine) {
            Csq->CsqReleaseLock(Csq, irql);
            return NULL;
        }

        ASSERT(Context == irp->Tail.Overlay.DriverContext[3]);

        Csq->CsqRemoveIrp(Csq, irp);

        //
        // Break the association.
        //

        Context->Irp = NULL;
        irp->Tail.Overlay.DriverContext[3] = NULL;

        ASSERT(Context->Csq == Csq);

        Csq->CsqReleaseLock(Csq, irql);

        return irp;

    } else {

        Csq->CsqReleaseLock(Csq, irql);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\dir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module contains the code to implement the NtQueryDirectoryFile,
    and the NtNotifyChangeDirectoryFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 21-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

NTSTATUS
BuildQueryDirectoryIrp(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan,
    IN UCHAR MinorFunction,
    OUT BOOLEAN *SynchronousIo,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT PIRP *Irp,
    OUT PFILE_OBJECT *FileObject,
    OUT KPROCESSOR_MODE *RequestorMode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildQueryDirectoryIrp)
#pragma alloc_text(PAGE, NtQueryDirectoryFile)
#pragma alloc_text(PAGE, NtNotifyChangeDirectoryFile)
#endif

NTSTATUS
BuildQueryDirectoryIrp(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan,
    IN UCHAR MinorFunction,
    OUT BOOLEAN *SynchronousIo,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT PIRP *Irp,
    OUT PFILE_OBJECT *FileObject,
    OUT KPROCESSOR_MODE *RequestorMode
    )

/*++

Routine Description:

    This service operates on a directory file or OLE container specified by the
    FileHandle parameter.  The service returns information about files in the
    directory or embeddings and streams in the container specified by the file
    handle.  The ReturnSingleEntry parameter specifies that only a single entry
    should be returned rather than filling the buffer.  The actual number of
    files whose information is returned, is the smallest of the following:

        o  One entry, if the ReturnSingleEntry parameter is TRUE.

        o  The number of entries whose information fits into the specified
           buffer.

        o  The number of entries that exist.

        o  One entry if the optional FileName parameter is specified.

    If the optional FileName parameter is specified, then the only information
    that is returned is for that single entries, if it exists.  Note that the
    file name may not specify any wildcard characters according to the naming
    conventions of the target file system.  The ReturnSingleEntry parameter is
    simply ignored.

    The information that is obtained about the entries in the directory or OLE
    container is based on the FileInformationClass parameter.  Legal values are
    hard coded based on the MinorFunction.

Arguments:

    FileHandle - Supplies a handle to the directory file or OLE container for
        which information should be returned.

    Event - Supplies an optional event to be set to the Signaled state when
        the query is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        query is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the contents of the directory.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory or OLE container.

    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that
        only a single entry should be returned.

    FileName - Optionally supplies a file name within the specified directory
        or OLE container.

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.  This parameter must be
        set to TRUE by the caller the first time the service is invoked.

    MinorFunction - IRP_MN_QUERY_DIRECTORY or IRP_MN_QUERY_OLE_DIRECTORY

    SynchronousIo - pointer to returned BOOLEAN; TRUE if synchronous I/O

    DeviceObject - pointer to returned pointer to device object

    Irp - pointer to returned pointer to device object

    FileObject - pointer to returned pointer to file object

    RequestorMode - pointer to returned requestor mode

Return Value:

    The status returned is STATUS_SUCCESS if a valid irp was created for the
    query operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT eventObject = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);
    *RequestorMode = requestorMode;

    try {

        if (requestorMode != KernelMode) {

            ULONG operationlength = 0;  // assume invalid

            //
            // The caller's access mode is not kernel so probe and validate
            // each of the arguments as necessary.  If any failures occur,
            // the condition handler will be invoked to handle them.  It
            // will simply cleanup and return an access violation status
            // code back to the system service dispatcher.
            //

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock, ApcRoutine);

            //
            // Ensure that the FileInformationClass parameter is legal for
            // querying information about files in the directory or object.
            //

            if (FileInformationClass == FileDirectoryInformation) {
                operationlength = sizeof(FILE_DIRECTORY_INFORMATION);
            } else if (MinorFunction == IRP_MN_QUERY_DIRECTORY) {
                switch (FileInformationClass)
                {
                case FileFullDirectoryInformation:
                    operationlength = sizeof(FILE_FULL_DIR_INFORMATION);
                    break;

                case FileIdFullDirectoryInformation:
                    operationlength = sizeof(FILE_ID_FULL_DIR_INFORMATION);
                    break;

                case FileBothDirectoryInformation:
                    operationlength = sizeof(FILE_BOTH_DIR_INFORMATION);
                    break;

                case FileIdBothDirectoryInformation:
                    operationlength = sizeof(FILE_ID_BOTH_DIR_INFORMATION);
                    break;

                case FileNamesInformation:
                    operationlength = sizeof(FILE_NAMES_INFORMATION);
                    break;

                case FileObjectIdInformation:
                    operationlength = sizeof(FILE_OBJECTID_INFORMATION);
                    break;

                case FileQuotaInformation:
                    operationlength = sizeof(FILE_QUOTA_INFORMATION);
                    break;

                case FileReparsePointInformation:
                    operationlength = sizeof(FILE_REPARSE_POINT_INFORMATION);
                    break;                    
                }
            }

            //
            // If the FileInformationClass parameter is illegal, fail now.
            //

            if (operationlength == 0) {
                return STATUS_INVALID_INFO_CLASS;
            }

            //
            // Ensure that the caller's supplied buffer is at least large enough
            // to contain the fixed part of the structure required for this
            // query.
            //

            if (Length < operationlength) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }


            //
            // The FileInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FileInformation,
                               Length,
                               IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
            
#else
            ProbeForWrite( FileInformation,
                           Length,
                           IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif
        }

        //
        // If the optional FileName parameter was specified, then it must be
        // readable by the caller.  Capture the file name string in a pool
        // block.  Note that if an error occurs during the copy, the cleanup
        // code in the exception handler will deallocate the pool before
        // returning an access violation status.
        //

        if (ARGUMENT_PRESENT( FileName )) {

            UNICODE_STRING fileName;
            PUNICODE_STRING nameBuffer;

            //
            // Capture the string descriptor itself to ensure that the
            // string is readable by the caller without the caller being
            // able to change the memory while its being checked.
            //

            if (requestorMode != KernelMode) {
                fileName = ProbeAndReadUnicodeString( FileName );
            } else {
                fileName = *FileName;
            }

            //
            // If the length is not an even number of bytes
            // return an error.
            //

            if (fileName.Length & (sizeof(WCHAR) - 1)) {
                return STATUS_INVALID_PARAMETER;
            }

            if (fileName.Length) {

                //
                // The length of the string is non-zero, so probe the
                // buffer described by the descriptor if the caller was
                // not kernel mode.  Likewise, if the caller's mode was
                // not kernel, then check the length of the name string
                // to ensure that it is not too long.
                //

                if (requestorMode != KernelMode) {
                    ProbeForRead( fileName.Buffer,
                                  fileName.Length,
                                  sizeof( UCHAR ) );
                    //
                    // account for unicode
                    //

                    if (fileName.Length > MAXIMUM_FILENAME_LENGTH<<1) {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }
                }

                //
                // Allocate an auxiliary buffer large enough to contain
                // a file name descriptor and to hold the entire file
                // name itself.  Copy the body of the string into the
                // buffer.
                //

                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           fileName.Length + sizeof( UNICODE_STRING ) );
                RtlCopyMemory( auxiliaryBuffer + sizeof( UNICODE_STRING ),
                               fileName.Buffer,
                               fileName.Length );

                //
                // Finally, build the Unicode string descriptor in the
                // auxiliary buffer.
                //

                nameBuffer = (PUNICODE_STRING) auxiliaryBuffer;
                nameBuffer->Length = fileName.Length;
                nameBuffer->MaximumLength = fileName.Length;
                nameBuffer->Buffer = (PWSTR) (auxiliaryBuffer + sizeof( UNICODE_STRING ) );
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while probing the caller's buffers,
        // attempting to allocate a pool buffer, or while trying to copy
        // the caller's data.  Determine what happened, clean everything
        // up, and return an appropriate error status code.
        //

        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }


        return GetExceptionCode();
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_LIST_DIRECTORY,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if (!NT_SUCCESS( status )) {
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }
    *FileObject = fileObject;

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            (POBJECT_HANDLE_INFORMATION) NULL );
        if (!NT_SUCCESS( status )) {
            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }
                if (eventObject != NULL) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        *SynchronousIo = TRUE;
    } else {
        *SynchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    *DeviceObject = deviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !(*SynchronousIo) );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    *Irp = irp;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = MinorFunction;
    irpSp->FileObject = fileObject;

    // Also, copy the caller's parameters to the service-specific portion of
    // the IRP.
    //

    irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer
        // and specify that it should be deallocated on completion.  Also
        // indicate that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception handler
        // that will perform cleanup if the operation fails.
        //

        try {

            //
            // Allocate the intermediary system buffer from nonpaged pool and
            // charge quota for it.
            //

            irp->AssociatedIrp.SystemBuffer =
                ExAllocatePoolWithQuota( NonPagedPool, Length );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either probing the caller's
            // buffer or allocate the system buffer.  Determine what actually
            // happened, clean everything up, and return an appropriate error
            // status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

        //
        // Remember the address of the caller's buffer so the copy can take
        // place during I/O completion.  Also, set the flags so that the
        // completion code knows to do the copy and to deallocate the buffer.
        //

        irp->UserBuffer = FileInformation;
        irp->Flags = (ULONG) (IRP_BUFFERED_IO |
                              IRP_DEALLOCATE_BUFFER |
                              IRP_INPUT_OPERATION);

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This is
        // done using an exception handler that will perform cleanup if the
        // operation fails.
        //

        mdl = (PMDL) NULL;

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of the
            // IRP.  Probe and lock the pages associated with the caller's
            // buffer for write access and fill in the MDL with the PFNs of
            // those pages.
            //

            mdl = IoAllocateMdl( FileInformation, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
            MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either probing the caller's
            // buffer or allocating the MDL.  Determine what actually happened,
            // clean everything up, and return an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = FileInformation;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileInformationClass;
    irpSp->Parameters.QueryDirectory.FileIndex = 0;
    irpSp->Parameters.QueryDirectory.FileName = (PUNICODE_STRING) auxiliaryBuffer;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }

    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Return with everything set up for the caller to complete the I/O.
    //

    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service operates on a directory file specified by the FileHandle
    parameter.  The service returns information about files in the directory
    specified by the file handle.  The ReturnSingleEntry parameter specifies
    that only a single entry should be returned rather than filling the buffer.
    The actual number of files whose information is returned, is the smallest
    of the following:

        o  One entry, if the ReturnSingleEntry parameter is TRUE.

        o  The number of files whose information fits into the specified
           buffer.

        o  The number of files that exist.

        o  One entry if the optional FileName parameter is specified.

    If the optional FileName parameter is specified, then the only information
    that is returned is for that single file, if it exists.  Note that the
    file name may not specify any wildcard characters according to the naming
    conventions of the target file system.  The ReturnSingleEntry parameter is
    simply ignored.

    The information that is obtained about the files in the directory is based
    on the FileInformationClass parameter.  The legal values are as follows:

        o  FileNamesInformation

        o  FileDirectoryInformation

        o  FileFullDirectoryInformation

        o  FileBothDirectoryInformation

        o  FileIdBothDirectoryInformation

Arguments:

    FileHandle - Supplies a handle to the directory file for which information
        should be returned.

    Event - Supplies an optional event to be set to the Signaled state when
        the query is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        query is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the contents of the directory.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory.

    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that
        only a single entry should be returned.

    FileName - Optionally supplies a file name within the specified directory.

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.  This parameter must be
        set to TRUE by the caller the first time the service is invoked.

Return Value:

    The status returned is success if the query operation was properly queued
    to the I/O system.  Once the operation completes, the status of the query
    can be determined by examining the Status field of the I/O status block.

--*/

{
    NTSTATUS status;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PFILE_OBJECT fileObject;
    KPROCESSOR_MODE requestorMode;

    PAGED_CODE();

    //
    // Build the irp with the appropriate minor function & allowed info levels.
    //

    status = BuildQueryDirectoryIrp( FileHandle,
                                     Event,
                                     ApcRoutine,
                                     ApcContext,
                                     IoStatusBlock,
                                     FileInformation,
                                     Length,
                                     FileInformationClass,
                                     ReturnSingleEntry,
                                     FileName,
                                     RestartScan,
                                     IRP_MN_QUERY_DIRECTORY,
                                     &synchronousIo,
                                     &deviceObject,
                                     &irp,
                                     &fileObject,
                                     &requestorMode);
    if (status  == STATUS_SUCCESS) {

        //
        // Queue the packet, call the driver, and synchronize appopriately with
        // I/O completion.
        //
        status = IopSynchronousServiceTail( deviceObject,
                                            irp,
                                            fileObject,
                                            TRUE,
                                            requestorMode,
                                            synchronousIo,
                                            OtherTransfer );
    }
    return status;
}

NTSTATUS
NtNotifyChangeDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    )

/*++

Routine Description:

    This service monitors a directory file for changes.  Once a change is
    made to the directory specified by the FileHandle parameter, the I/O
    operation is completed.

Arguments:

    FileHandle - Supplies a handle to the file whose EAs should be changed.

    Event - Supplies an optional event to be set to the Signaled state when the
        change is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the change
        is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of variable to receive the names of the files or
        directories that have changed since the last time that the service
        was invoked.

    Length - Length of the output buffer.  On the first call, this parameter
        also serves as a guideline for how large to make the system's
        internal buffer.  Specifying a buffer length of zero causes the request
        to complete when changes are made, but no information about the
        changes are returned.

    CompletionFilter - Indicates the types of changes to files or directories
        within the directory that will complete the I/O operation.

    WatchTree - A BOOLEAN value that indicates whether or not changes to
        directories below the directory referred to by the FileHandle
        parameter cause the operation to complete.

Return Value:

    The status returned is success if the operation was properly queued to the
    I/O system.  Once the operation completes, the status of the operation can
    be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT eventObject = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The Buffer parameter must be writeable by the caller.
            //

            if (Length != 0) {
                ProbeForWrite( Buffer,
                               Length,
                               sizeof( ULONG ) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's I/O status
            // block.  Simply return the appropriate error status code.
            //

            return GetExceptionCode();

        }

        //
        // The CompletionFilter parameter must not contain any values which
        // are illegal, nor may it not specifiy anything at all.  Likewise,
        // the caller must supply a non-null buffer.
        //

        if (((CompletionFilter & ~FILE_NOTIFY_VALID_MASK) ||
            !CompletionFilter)) {
            return STATUS_INVALID_PARAMETER;
        }

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_LIST_DIRECTORY,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            (POBJECT_HANDLE_INFORMATION) NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject != NULL) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and the parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    if (Length != 0) {

        if (deviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The device does not support direct I/O.  Allocate a system
            // buffer and specify that it should be deallocated on completion.
            // Also indicate that this is an input operation so the data will
            // be copied into the caller's buffer.  This is done using an
            // exception handler that will perform cleanup if the operation
            // fails.
            //

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool
                // and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                     ExAllocatePoolWithQuota( NonPagedPool, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while attempting to allocate the
                // intermediary system buffer.  Clean everything up and return
                // an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can take
            // place during I/O completion.  Also, set the flags so that the
            // completion code knows to do the copy and to deallocate the
            // buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags = IRP_BUFFERED_IO |
                         IRP_DEALLOCATE_BUFFER |
                         IRP_INPUT_OPERATION;

        } else if (deviceObject->Flags & DO_DIRECT_IO) {

            //
            // This is a direct I/O operation.  Allocate an MDL and invoke the
            // memory management routine to lock the buffer into memory.  This
            // is done using an exception handler that will perform cleanup if
            // the operation fails.
            //

            PMDL mdl;

            mdl = (PMDL) NULL;

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for write access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer of allocating the MDL.  Determine what actually
                // happened, clean everything up, and return an appropriate
                // error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

        } else {

            //
            // Pass the address of the user's buffer so the driver has access
            // to it.  It is now the driver's responsibility to do everything.
            //

            irp->UserBuffer = Buffer;

        }
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.NotifyDirectory.Length = Length;
    irpSp->Parameters.NotifyDirectory.CompletionFilter = CompletionFilter;
    if (WatchTree) {
        irpSp->Flags = SL_WATCH_TREE;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      FALSE,
                                      requestorMode,
                                      synchronousIo,
                                      OtherTransfer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\devctrl.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module contains the code to implement the NtDeviceIoControlFile system
    service for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 16-Oct-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtDeviceIoControlFile)
#endif

NTSTATUS
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the device driver associated with the file
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        device driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the device driver.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\dumpctl.h ===
#include "ntiodump.h"

//
// Define the type for a dump control block.  This structure is used to
// describe all of the data, drivers, and memory necessary to dump all of
// physical memory to the disk after a bugcheck.
//

typedef struct _MINIPORT_NODE {
    LIST_ENTRY ListEntry;
    PKLDR_DATA_TABLE_ENTRY DriverEntry;
    ULONG DriverChecksum;
} MINIPORT_NODE, *PMINIPORT_NODE;

#define IO_TYPE_DCB                     0xff

#define DCB_DUMP_ENABLED                 0x01
#define DCB_SUMMARY_ENABLED              0x02
#define DCB_DUMP_HEADER_ENABLED          0x10
#define DCB_SUMMARY_DUMP_ENABLED         0x20
#define DCB_TRIAGE_DUMP_ENABLED          0x40
#define DCB_TRIAGE_DUMP_ACT_UPON_ENABLED 0x80

typedef struct _DUMP_CONTROL_BLOCK {
    UCHAR Type;
    CHAR Flags;
    USHORT Size;
    CCHAR NumberProcessors;
    CHAR Reserved;
    USHORT ProcessorArchitecture;
    PDUMP_STACK_CONTEXT DumpStack;
    ULONG MemoryDescriptorLength;
    PLARGE_INTEGER FileDescriptorArray;
    ULONG FileDescriptorSize;
    PULONG HeaderPage;
    PFN_NUMBER HeaderPfn;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG BuildNumber;
    CHAR VersionUser[32];
    ULONG HeaderSize;               // Size of dump header includes summary dump.
    LARGE_INTEGER DumpFileSize;     // Size of dump file.
    ULONG TriageDumpFlags;          // Flags for triage dump.
    PUCHAR TriageDumpBuffer;        // Buffer for triage dump.
    ULONG TriageDumpBufferSize;     // Size of triage dump buffer.
} DUMP_CONTROL_BLOCK, *PDUMP_CONTROL_BLOCK;

//
// Processor specific macros.
//

#if defined(_AMD64_)

#define PROGRAM_COUNTER(_context)   ((ULONG_PTR)(_context)->Rip)
#define STACK_POINTER(_context)     ((ULONG_PTR)(_context)->Rsp)
#define CURRENT_IMAGE_TYPE()        IMAGE_FILE_MACHINE_AMD64
#define PaeEnabled() TRUE

#elif defined(_X86_)

#define PROGRAM_COUNTER(_context)   ((_context)->Eip)
#define STACK_POINTER(_context)     ((_context)->Esp)
#define CURRENT_IMAGE_TYPE()        IMAGE_FILE_MACHINE_I386
#define PaeEnabled() X86PaeEnabled()

#elif defined(_IA64_)

#define PROGRAM_COUNTER(_context)   ((_context)->StIIP)
#define STACK_POINTER(_context)     ((_context)->IntSp)
#define CURRENT_IMAGE_TYPE()        IMAGE_FILE_MACHINE_IA64
#define PaeEnabled() (FALSE)

#else

#error ("unknown processor type")

#endif

//
// min3(_a,_b,_c)
//
// Same as min() but takes 3 parameters.
//

#define min3(_a,_b,_c) ( min ( min ((_a), (_b)), min ((_a), (_c))) )

#define CRASHDUMP_ERROR     DPFLTR_ERROR_LEVEL
#define CRASHDUMP_WARNING   DPFLTR_WARNING_LEVEL
#define CRASHDUMP_TRACE     DPFLTR_TRACE_LEVEL
#define CRASHDUMP_INFO      DPFLTR_INFO_LEVEL
#define CRASHDUMP_VERBOSE   (DPFLTR_INFO_LEVEL + 100)

ULONG
IopGetDumpControlBlockCheck (
    IN PDUMP_CONTROL_BLOCK  Dcb
    );


//
// The remainder of this file verifies that the DUMP_HEADER32, DUMP_HEADER64,
// MEMORY_DUMP32 and MEMORY_DUMP64 structures have been defined correctly.
// If you die on one of the asserts, it means you changed on of the crashdump
// structures without knowing how it affected the rest of the system.
//

//
// Define dump header longword offset constants. Note: these constants are
// should no longer be used in accessing the fields. Use the MEMORY_DUMP32
// and MEMORY_DUMP64 structures instead.
//

#define DHP_PHYSICAL_MEMORY_BLOCK        (25)
#define DHP_CONTEXT_RECORD               (200)
#define DHP_EXCEPTION_RECORD             (500)
#define DHP_DUMP_TYPE                    (994)
#define DHP_REQUIRED_DUMP_SPACE          (1000)
#define DHP_CRASH_DUMP_TIMESTAMP         (1008)
#define DHP_SUMMARY_DUMP_RECORD          (1024)


//
// Validate the MEMORY_DUMP32 structure.
//

C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, PhysicalMemoryBlock) == DHP_PHYSICAL_MEMORY_BLOCK * 4);
C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, ContextRecord) == DHP_CONTEXT_RECORD * 4);
C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, Exception) == DHP_EXCEPTION_RECORD * 4);
C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, DumpType) == DHP_DUMP_TYPE * 4 );
C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, RequiredDumpSpace) == DHP_REQUIRED_DUMP_SPACE * 4);
C_ASSERT ( FIELD_OFFSET (DUMP_HEADER32, SystemTime) == DHP_CRASH_DUMP_TIMESTAMP * 4);
C_ASSERT ( sizeof (DUMP_HEADER32) == 4096 );
C_ASSERT ( FIELD_OFFSET (MEMORY_DUMP32, Summary) == 4096);

//
// Verify that the PHYSICAL_MEMORY_RUN and PHYSICAL_MEMORY_DESCRIPTOR
// structs match up.
//


#if !defined (_WIN64)

C_ASSERT ( sizeof (PHYSICAL_MEMORY_RUN) == sizeof (PHYSICAL_MEMORY_RUN32) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_RUN, BasePage) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_RUN32, BasePage) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_RUN, PageCount) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_RUN32, PageCount) );


C_ASSERT ( sizeof (PHYSICAL_MEMORY_DESCRIPTOR) == sizeof (PHYSICAL_MEMORY_DESCRIPTOR) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, NumberOfRuns) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR32, NumberOfRuns) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, NumberOfPages) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR32, NumberOfPages) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, Run) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR32, Run) );

#else // IA64

C_ASSERT ( sizeof (PHYSICAL_MEMORY_RUN) == sizeof (PHYSICAL_MEMORY_RUN64) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_RUN, BasePage) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_RUN64, BasePage) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_RUN, PageCount) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_RUN64, PageCount) );


C_ASSERT ( sizeof (PHYSICAL_MEMORY_DESCRIPTOR) == sizeof (PHYSICAL_MEMORY_DESCRIPTOR) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, NumberOfRuns) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR64, NumberOfRuns) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, NumberOfPages) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR64, NumberOfPages) &&
           FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR, Run) ==
                FIELD_OFFSET (PHYSICAL_MEMORY_DESCRIPTOR64, Run) );
#endif




//
// Verify we have enough room for the CONTEXT record.
//

C_ASSERT (sizeof (CONTEXT) <= sizeof ((PDUMP_HEADER)NULL)->ContextRecord);

#if defined(_AMD64_)
C_ASSERT (sizeof (DUMP_HEADER) == (2 * PAGE_SIZE));
#else
C_ASSERT (sizeof (DUMP_HEADER) == PAGE_SIZE);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\dumpctl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dumpctl.c

Abstract:

    This module contains the code to dump memory to disk after a crash.

Author:

    Darryl E. Havens (darrylh) 17-dec-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"
#include "dumpctl.h"
#include "ntddft.h"
#include <inbv.h>
#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>

extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;

typedef struct _TRIAGE_PTR_DATA_BLOCK {
    PUCHAR MinAddress;
    PUCHAR MaxAddress;
} TRIAGE_PTR_DATA_BLOCK, *PTRIAGE_PTR_DATA_BLOCK;

// A triage dump is sixteen pages long.  Some of that is
// header information and at least a few other pages will
// be used for basic dump information so limit the number
// of extra data blocks to something less than sixteen
// to save array space.
#define IO_MAX_TRIAGE_DUMP_DATA_BLOCKS 8

//
// Global variables
//

extern PVOID MmPfnDatabase;
extern PFN_NUMBER MmHighestPossiblePhysicalPage;

#if defined (_IA64_)
extern PFN_NUMBER MmSystemParentTablePage;
#endif

ULONG IopAutoReboot;

NTSTATUS IopFinalCrashDumpStatus = -1;
ERESOURCE IopCrashDumpLock;

ULONG IopNumTriageDumpDataBlocks;
TRIAGE_PTR_DATA_BLOCK IopTriageDumpDataBlocks[IO_MAX_TRIAGE_DUMP_DATA_BLOCKS];

//
// If space is available in a triage dump it's possible
// to add "interesting" data pages referenced by runtime
// information such as context registers.  The following
// lists are offsets into the CONTEXT structure of pointers
// which usually point to interesting data.  They are
// in priority order.
//

#define IOP_LAST_CONTEXT_OFFSET 0xffff

#if defined(_X86_)
USHORT IopRunTimeContextOffsets[] = {
    FIELD_OFFSET(CONTEXT, Ebx),
    FIELD_OFFSET(CONTEXT, Esi),
    FIELD_OFFSET(CONTEXT, Edi),
    FIELD_OFFSET(CONTEXT, Ecx),
    FIELD_OFFSET(CONTEXT, Edx),
    FIELD_OFFSET(CONTEXT, Eax),
    FIELD_OFFSET(CONTEXT, Eip),
    IOP_LAST_CONTEXT_OFFSET
};
#elif defined(_IA64_)
USHORT IopRunTimeContextOffsets[] = {
    FIELD_OFFSET(CONTEXT, IntS0),
    FIELD_OFFSET(CONTEXT, IntS1),
    FIELD_OFFSET(CONTEXT, IntS2),
    FIELD_OFFSET(CONTEXT, IntS3),
    FIELD_OFFSET(CONTEXT, StIIP),
    IOP_LAST_CONTEXT_OFFSET
};
#elif defined(_AMD64_)
USHORT IopRunTimeContextOffsets[] = {
    FIELD_OFFSET(CONTEXT, Rbx),
    FIELD_OFFSET(CONTEXT, Rsi),
    FIELD_OFFSET(CONTEXT, Rdi),
    FIELD_OFFSET(CONTEXT, Rcx),
    FIELD_OFFSET(CONTEXT, Rdx),
    FIELD_OFFSET(CONTEXT, Rax),
    FIELD_OFFSET(CONTEXT, Rip),
    IOP_LAST_CONTEXT_OFFSET
};
#else
USHORT IopRunTimeContextOffsets[] = {
    IOP_LAST_CONTEXT_OFFSET
};
#endif

//
// Set IopIgnoreDumpCheck to TRUE when debugging dumps to prevent
// the checksum from interfering with debugging.
//

LOGICAL IopIgnoreDumpCheck = FALSE;

//
// Max dump transfer sizes
//

#define IO_DUMP_MAXIMUM_TRANSFER_SIZE   ( 1024 * 64 )
#define IO_DUMP_MINIMUM_TRANSFER_SIZE   ( 1024 * 32 )
#define IO_DUMP_MINIMUM_FILE_SIZE       ( PAGE_SIZE * 256 )
#define MAX_UNICODE_LENGTH              ( 512 )

#define DEFAULT_DRIVER_PATH             ( L"\\SystemRoot\\System32\\Drivers\\" )
#define DEFAULT_DUMP_DRIVER             ( L"\\SystemRoot\\System32\\Drivers\\diskdump.sys" )
#define SCSIPORT_DRIVER_NAME            ( L"scsiport.sys" )
#define STORPORT_DRIVER_NAME            ( L"storport.sys" )
#ifdef _WIN64
#define MAX_TRIAGE_STACK_SIZE           ( 32 * 1024 )
#else
#define MAX_TRIAGE_STACK_SIZE           ( 16 * 1024 )
#endif
#define DEFAULT_TRIAGE_DUMP_FLAGS       ( 0xFFFFFFFF )

//
// for memory allocations
//

#define DUMP_TAG ('pmuD')
#undef ExAllocatePool
#define ExAllocatePool(Pool,Size) ExAllocatePoolWithTag(Pool,Size,DUMP_TAG)

//
// Function prototypes
//

NTSTATUS
IoConfigureCrashDump(
    CRASHDUMP_CONFIGURATION Configuration
    );

BOOLEAN
IoInitializeCrashDump(
    IN HANDLE hPageFile
    );

NTSTATUS
IopWriteTriageDump(
    IN ULONG FieldsToWrite,
    IN PDUMP_DRIVER_WRITE WriteRoutine,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG DiverTransferSize,
    IN PCONTEXT Context,
    IN PKTHREAD Thread,
    IN LPBYTE Buffer,
    IN ULONG BufferSize,
    IN ULONG ServicePackBuild,
    IN ULONG TriageOptions
    );

NTSTATUS
IopWriteSummaryDump(
    IN PRTL_BITMAP PageMap,
    IN PDUMP_DRIVER_WRITE WriteRoutine,
    IN PANSI_STRING ProgressMessage,
    IN PUCHAR MessageBuffer,
    IN OUT PLARGE_INTEGER * Mcb,
    IN ULONG DiverTransferSize
    );

NTSTATUS
IopWriteToDisk(
    IN PVOID Buffer,
    IN ULONG WriteLength,
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG DriverTransferSize,
    IN KBUGCHECK_DUMP_IO_TYPE DataType
    );

VOID
IopMapPhysicalMemory(
    IN OUT PMDL Mdl,
    IN ULONG64 MemoryAddress,
    IN ULONG Length
    );

NTSTATUS
IopLoadDumpDriver (
    IN OUT PDUMP_STACK_CONTEXT DumpStack,
    IN PWCHAR DriverNameString,
    IN PWCHAR NewBaseNameString
    );

NTSTATUS
IopInitializeSummaryDump(
    IN OUT PMEMORY_DUMP MemoryDump,
    IN PDUMP_CONTROL_BLOCK DumpControlBlock
    );

NTSTATUS
IopWriteSummaryHeader(
    IN PSUMMARY_DUMP SummaryHeader,
    IN PDUMP_DRIVER_WRITE Write,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG WriteSize,
    IN ULONG Length
    );

VOID
IopMapVirtualToPhysicalMdl(
    IN OUT PMDL pMdl,
    IN ULONG_PTR dwMemoryAddress,
    IN ULONG    dwLength
    );

ULONG
IopCreateSummaryDump (
    IN PMEMORY_DUMP MemoryDump
    );

NTSTATUS
IopInvokeSecondaryDumpDataCallbacks(
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG DriverTransferSize,
    IN BYTE* Buffer,
    IN ULONG BufferSize,
    IN ULONG MaxTotal,
    IN ULONG MaxPerCallback,
    OUT OPTIONAL PULONG SpaceNeeded
    );

NTSTATUS
IopInvokeDumpIoCallbacks(
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN KBUGCHECK_DUMP_IO_TYPE Type
    );


NTSTATUS
IopGetDumpStack (
    IN PWCHAR                         ModulePrefix,
    OUT PDUMP_STACK_CONTEXT           *pDumpStack,
    IN PUNICODE_STRING                pUniDeviceName,
    IN PWSTR                          pDumpDriverName,
    IN DEVICE_USAGE_NOTIFICATION_TYPE UsageType,
    IN ULONG                          IgnoreDeviceUsageFailure
    );

BOOLEAN
IopInitializeDCB(
    );

LARGE_INTEGER
IopCalculateRequiredDumpSpace(
    IN ULONG            dwDmpFlags,
    IN ULONG            dwHeaderSize,
    IN PFN_NUMBER       dwMaxPages,
    IN PFN_NUMBER       dwMaxSummaryPages,
    IN BOOLEAN          LargestPossibleSize
    );

NTSTATUS
IopCompleteDumpInitialization(
    IN HANDLE     FileHandle
    );

#ifdef ALLOC_PRAGMA
VOID
IopReadDumpRegistry(
    OUT PULONG dumpControl,
    OUT PULONG numberOfHeaderPages,
    OUT PULONG autoReboot,
    OUT PULONG dumpFileSize
    );
VOID
IopFreeDCB(
    BOOLEAN FreeDCB
    );

#pragma alloc_text(PAGE,IoGetDumpStack)
#pragma alloc_text(PAGE,IopGetDumpStack)
#pragma alloc_text(PAGE,IopLoadDumpDriver)
#pragma alloc_text(PAGE,IoFreeDumpStack)
#pragma alloc_text(PAGE,IopCompleteDumpInitialization)
#pragma alloc_text(PAGE,IopFreeDCB)
#pragma alloc_text(PAGE,IopReadDumpRegistry)
#pragma alloc_text(PAGE,IopInitializeDCB)
#pragma alloc_text(PAGE,IopConfigureCrashDump)
#pragma alloc_text(PAGE,IoInitializeCrashDump)
#pragma alloc_text(PAGE,IoConfigureCrashDump)
#endif


#if defined (i386)

//
// Functions
//


BOOLEAN
X86PaeEnabled(
    )

/*++

Routine Description:

    Is PAE currently enabled?

Return Values:

    Return TRUE if PAE is enabled in the CR4 register, FALSE otherwise.

--*/

{
    ULONG Reg_Cr4;

    _asm {
        _emit 0Fh
        _emit 20h
        _emit 0E0h  ;; mov eax, cr4
        mov Reg_Cr4, eax
    }

    return (Reg_Cr4 & CR4_PAE ? TRUE : FALSE);
}

#endif


BOOLEAN
IopIsAddressRangeValid(
    IN PVOID VirtualAddress,
    IN SIZE_T Length
    )

/*++

Routine Description:

    Validate a range of addresses.

Arguments:

    Virtual Address - Beginning of of memory block to validate.

    Length - Length of memory block to validate.

Return Value:

    TRUE - Address range is valid.

    FALSE - Address range is not valid.

--*/

{
    UINT_PTR Va;
    ULONG Pages;

    Va = (UINT_PTR) PAGE_ALIGN (VirtualAddress);
    Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES (VirtualAddress, Length);

    while (Pages) {

        if ((Va < 0x10000) ||
            (!MmIsAddressValid ( (LPVOID) Va))) {
            return FALSE;
        }

        Va += PAGE_SIZE;
        Pages--;
    }

    return TRUE;
}

BOOLEAN
IoAddTriageDumpDataBlock(
    IN PVOID Address,
    IN ULONG Length
    )

/*++

Routine Description:

    Add an entry to the list of data blocks that should
    be saved in any triage dump generated.  The entire
    block must be valid for any of it to be saved.

Arguments:

    Address - Beginning of data block.

    Length - Length of data block.  This must be less than
             the triage dump size.

Return Value:

    TRUE - Block was added.

    FALSE - Block was not added.

--*/

{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    PUCHAR MinAddress, MaxAddress;

    if (Length >= TRIAGE_DUMP_SIZE ||
        !IopIsAddressRangeValid(Address, Length)) {
        return FALSE;
    }
    
    MinAddress = (PUCHAR)Address;
    MaxAddress = MinAddress + Length;
    
    //
    // Minimize overlap between the new block and existing blocks.
    // Blocks cannot simply be merged as blocks are inserted in
    // priority order for storage in the dump.  Combining a low-priority
    // block with a high-priority block could lead to a medium-
    // priority block being bumped improperly from the dump.
    //

    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++) {
        
        if (MinAddress >= Block->MaxAddress ||
            MaxAddress <= Block->MinAddress) {
            // No overlap.
            continue;
        }

        //
        // Trim overlap out of the new block.  If this
        // would split the new block into pieces don't
        // trim to keep things simple.  Content may then
        // be duplicated in the dump.
        //
        
        if (MinAddress >= Block->MinAddress) {
            if (MaxAddress <= Block->MaxAddress) {
                // New block is completely contained.
                return TRUE;
            }

            // New block extends above the current block
            // so trim off the low-range overlap.
            MinAddress = Block->MaxAddress;
        } else if (MaxAddress <= Block->MaxAddress) {
            // New block extends below the current block
            // so trim off the high-range overlap.
            MaxAddress = Block->MinAddress;
        }
    }

    if (IopNumTriageDumpDataBlocks >= IO_MAX_TRIAGE_DUMP_DATA_BLOCKS) {
        return FALSE;
    }

    Block = IopTriageDumpDataBlocks + IopNumTriageDumpDataBlocks++;
    Block->MinAddress = MinAddress;
    Block->MaxAddress = MaxAddress;

    return TRUE;
}

VOID
IopAddRunTimeTriageDataBlocks(
    IN PCONTEXT Context,
    IN PVOID* StackMin,
    IN PVOID* StackMax,
    IN PVOID* StoreMin,
    IN PVOID* StoreMax
    )

/*++

Routine Description:

    Add data blocks referenced by the context or
    other runtime state.

Arguments:

    Context - Context record at the time the dump is being generated for.

    StackMin, StackMax - Stack memory boundaries.  Stack memory is
                         stored elsewhere in the dump.

    StoreMin, StoreMax - Backing store memory boundaries.  Store memory
                         is stored elsewhere in the dump.

Return Value:

    None.

--*/

{
    PUSHORT ContextOffset;

    ContextOffset = IopRunTimeContextOffsets;
    while (*ContextOffset < IOP_LAST_CONTEXT_OFFSET) {

        PVOID* Ptr;

        //
        // Retrieve possible pointers from the context
        // registers.
        //
        
        Ptr = *(PVOID**)((PUCHAR)Context + *ContextOffset);

        // Stack and backing store memory is already saved
        // so ignore any pointers that fall into those ranges.
        if ((Ptr < StackMin || Ptr >= StackMax) &&
            (Ptr < StoreMin || Ptr >= StoreMax)) {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(Ptr), PAGE_SIZE);
        }
        
        ContextOffset++;
    }
}



NTSTATUS
IoGetDumpStack (
    IN PWCHAR                          ModulePrefix,
    OUT PDUMP_STACK_CONTEXT          * pDumpStack,
    IN  DEVICE_USAGE_NOTIFICATION_TYPE UsageType,
    IN  ULONG                          IgnoreDeviceUsageFailure
    )
/*++

Routine Description:

    This routine loads a dump stack instance and returns an allocated
    context structure to track the loaded dumps stack.

Arguments:

    ModePrefix      - The prefix to prepent to BaseName during the load
                      operation.  This allows loading the same drivers
                      multiple times with different virtual names and
                      linkages.

    pDumpStack      - The returned dump stack context structure

    UsageType       - The Device Notification Usage Type for this file, that
                      this routine will send as to the device object once the
                      file has been successfully created and initialized.

    IgnoreDeviceUsageFailure - If the Device Usage Notification Irp fails, allow
                      this to succeed anyway.

Return Value:

    Status

--*/
{

    PAGED_CODE();
    return IopGetDumpStack(ModulePrefix,
                           pDumpStack,
                           &IoArcBootDeviceName,
                           DEFAULT_DUMP_DRIVER,
                           UsageType,
                           IgnoreDeviceUsageFailure
                           );
}


BOOLEAN
IoIsTriageDumpEnabled(
    VOID
    )
{
    if (IopDumpControlBlock &&
        (IopDumpControlBlock->Flags & DCB_TRIAGE_DUMP_ENABLED)) {
        return TRUE;
    }

    return FALSE;
}



VOID
IopDisplayString(
    IN PCCHAR FormatString,
    ...
    )

/*++

Routine Description:

    Display a string to the boot video console. This will also print the
    string to the debugger, if the proper flags have been enabled.

Arguments:

    String - String to display.

Return Value:

    None.

--*/
{
    va_list ap;
    CHAR    buffer [ 128 ];

    va_start( ap, FormatString );

    _vsnprintf( buffer,
                sizeof ( buffer ),
                FormatString,
                ap );
    buffer[sizeof(buffer) - 1] = 0;

    //
    // Display the string to the boot video monitor.
    //

    InbvDisplayString ( (PUCHAR) buffer );

    //
    // And, optionally, to the debugger.
    //

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP [DISP]: %s\r",
                buffer ));

    va_end(ap);

}


typedef struct _INTERNAL_GEOMETRY {
    DISK_GEOMETRY Geometry;
    LARGE_INTEGER DiskSize;
    DISK_PARTITION_INFO PartitionInfo;
} INTERNAL_GEOMETRY, *PINTERNAL_GEOMETRY;

C_ASSERT ( FIELD_OFFSET (INTERNAL_GEOMETRY, PartitionInfo) == FIELD_OFFSET (DISK_GEOMETRY_EX, Data) );


NTSTATUS
IopGetDumpStack (
    IN PWCHAR                         ModulePrefix,
    OUT PDUMP_STACK_CONTEXT         * DumpStackBuffer,
    IN PUNICODE_STRING                UniDeviceName,
    IN PWCHAR                         DumpDriverName,
    IN DEVICE_USAGE_NOTIFICATION_TYPE UsageType,
    IN ULONG                          IgnoreDeviceUsageFailure
    )
/*++

Routine Description:

    This routine loads a dump stack instance and returns an allocated
    context structure to track the loaded dumps stack.

Arguments:

    ModePrefix      - The prefix to prepent to BaseName during the load
                      operation.  This allows loading the same drivers
                      multiple times with different virtual names and
                      linkages.

    DumpStackBuffer - The returned dump stack context structure

    DeviceName     - The name of the target dump device

    DumpDriverName - The name of the target dump driver

    UsageType       - The Device Notification Usage Type for this file, that
                      this routine will send as to the device object once the
                      file has been successfully created and initialized.

    IgnoreDeviceUsageFailure - If the Device Usage Notification Irp fails, allow
                      this to succeed anyway.

Return Value:

    Status

--*/
{
    PDUMP_STACK_CONTEXT         DumpStack;
    PCHAR                       Buffer;
    ANSI_STRING                 AnsiString;
    UNICODE_STRING              TempName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    Status;
    HANDLE                      DeviceHandle;
    SCSI_ADDRESS                ScsiAddress;
    BOOLEAN                     ScsiDump;
    PARTITION_INFORMATION_EX    PartitionInfo;
    PFILE_OBJECT                FileObject;
    PDEVICE_OBJECT              DeviceObject;
    PDUMP_POINTERS              DumpPointers;
    UNICODE_STRING              DriverName;
    PDRIVER_OBJECT              DriverObject;
    PIRP                        Irp;
    PIO_STACK_LOCATION          IrpSp;
    IO_STATUS_BLOCK             IoStatus;
    PWCHAR                      DumpName;
    PWCHAR                      NameOffset;
    KEVENT                      Event;
    PVOID                       p1;
    PHYSICAL_ADDRESS            pa;
    ULONG                       i;
    IO_STACK_LOCATION           irpSp;
    PINTERNAL_GEOMETRY          Geometry;
    PDUMP_INITIALIZATION_CONTEXT DumpInit;


    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: Prefix:%ws stk: %x device:%ws driver:%ws\n",
                ModulePrefix,
                DumpStackBuffer,
                UniDeviceName->Buffer,
                DumpDriverName
                ));

    ASSERT (DeviceUsageTypeUndefined != UsageType);

    DumpStack = ExAllocatePool (
                    NonPagedPool,
                    sizeof (DUMP_STACK_CONTEXT) + sizeof (DUMP_POINTERS)
                    );

    if (!DumpStack) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(DumpStack, sizeof(DUMP_STACK_CONTEXT)+sizeof(DUMP_POINTERS));
    DumpInit = &DumpStack->Init;
    DumpPointers = (PDUMP_POINTERS) (DumpStack + 1);
    DumpStack->DumpPointers = DumpPointers;
    InitializeListHead (&DumpStack->DriverList);
    DumpName = NULL;

    //
    // Allocate scratch buffer
    //

    Buffer = ExAllocatePool (PagedPool, PAGE_SIZE);
    if (!Buffer) {
        ExFreePool (DumpStack);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!KeGetBugMessageText(BUGCODE_PSS_CRASH_INIT, &DumpStack->InitMsg) ||
        !KeGetBugMessageText(BUGCODE_PSS_CRASH_PROGRESS, &DumpStack->ProgMsg) ||
        !KeGetBugMessageText(BUGCODE_PSS_CRASH_DONE, &DumpStack->DoneMsg)) {
            Status = STATUS_UNSUCCESSFUL;
            goto Done;
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        UniDeviceName,
        OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = ZwOpenFile(
              &DeviceHandle,
              FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
              &ObjectAttributes,
              &IoStatus,
              FILE_SHARE_READ | FILE_SHARE_WRITE,
              FILE_NON_DIRECTORY_FILE
              );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Could not open boot device partition, %s\n",
                    Buffer
                    ));
        goto Done;
    }

    //
    // Check to see whether or not the system was booted from a SCSI device.
    //

    Status = ZwDeviceIoControlFile (
                    DeviceHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_SCSI_GET_ADDRESS,
                    NULL,
                    0,
                    &ScsiAddress,
                    sizeof( SCSI_ADDRESS )
                    );

    if (Status == STATUS_PENDING) {
        ZwWaitForSingleObject (
                DeviceHandle,
                FALSE,
                NULL
                );

        Status = IoStatus.Status;
    }

    ScsiDump = (BOOLEAN) (NT_SUCCESS(Status));

    //
    // If SCSI then allocate storage to contain the target address information.
    //

    DumpInit->TargetAddress = NULL;

    if (ScsiDump) {

        DumpInit->TargetAddress = ExAllocatePool(
                                    NonPagedPool,
                                    sizeof (SCSI_ADDRESS)
                                    );
        //
        // Formerly, this allocation was allowed to fail and the dump port
        // driver would search for a disk with a matching signature. No
        // longer. If we can't allocate a SCSI address, just fail.
        // Note, if we always pass in a valid SCSI target address, then the
        // disk signature isn't really necessary, but leave it in for now.
        //

        if (DumpInit->TargetAddress == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Done;
        }

        RtlCopyMemory(
                DumpInit->TargetAddress,
                &ScsiAddress,
                sizeof(SCSI_ADDRESS)
                );
    }

    //
    // Determine the disk signature for the device from which the system was
    // booted and get the partition offset.
    //

    Status = ZwDeviceIoControlFile(
                    DeviceHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_DISK_GET_PARTITION_INFO_EX,
                    NULL,
                    0,
                    &PartitionInfo,
                    sizeof( PartitionInfo )
                    );

    if (Status == STATUS_PENDING) {
        ZwWaitForSingleObject (
            DeviceHandle,
            FALSE,
            NULL
            );

        Status = IoStatus.Status;
    }

    //
    // Use the scratch buffer for the geometry.
    //

    Geometry = (PINTERNAL_GEOMETRY) Buffer;

    Status = ZwDeviceIoControlFile(
                    DeviceHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                    NULL,
                    0,
                    Geometry,
                    sizeof (*Geometry)
                    );

    if (Status == STATUS_PENDING) {
        ZwWaitForSingleObject (
            DeviceHandle,
            FALSE,
            NULL
            );

        Status = IoStatus.Status;
    }

    //
    // Copy the signature, either MBR or GPT.
    //

    DumpInit->PartitionStyle = Geometry->PartitionInfo.PartitionStyle;
    if ( DumpInit->PartitionStyle == PARTITION_STYLE_MBR ) {
        DumpInit->DiskInfo.Mbr.Signature = Geometry->PartitionInfo.Mbr.Signature;
        DumpInit->DiskInfo.Mbr.CheckSum = Geometry->PartitionInfo.Mbr.CheckSum;
    } else {
        DumpInit->DiskInfo.Gpt.DiskId = Geometry->PartitionInfo.Gpt.DiskId;
    }

    //
    // The scratch buffer is now free to use.
    //
    Geometry = NULL;

    //
    // Get the adapter object and base mapping registers for the disk from
    // the disk driver.  These will be used to call the HAL once the system
    // system has crashed, since it is not possible at that point to recreate
    // them from scratch.
    //

    ObReferenceObjectByHandle (
            DeviceHandle,
            0,
            IoFileObjectType,
            KernelMode,
            (PVOID *) &FileObject,
            NULL
            );


    DeviceObject = IoGetRelatedDeviceObject (FileObject);

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest(
                IOCTL_SCSI_GET_DUMP_POINTERS,
                DeviceObject,
                DumpPointers,
                sizeof (DUMP_POINTERS),
                DumpPointers,
                sizeof (DUMP_POINTERS),
                FALSE,
                &Event,
                &IoStatus
                );

    if (!Irp) {
        ObDereferenceObject (FileObject);
        ZwClose (DeviceHandle);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Done;
    }

    IrpSp = IoGetNextIrpStackLocation (Irp);

    IrpSp->FileObject = FileObject;

    Status = IoCallDriver( DeviceObject, Irp );

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatus.Status;
    }

    if (!NT_SUCCESS(Status) ||
        IoStatus.Information < FIELD_OFFSET(DUMP_POINTERS, DeviceObject)) {

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Could not get dump pointers; error = %x, length %x\n",
                    Status,
                    IoStatus.Information
                    ));

        ObDereferenceObject (FileObject);
        ZwClose (DeviceHandle);
        goto Done;
    }
    DumpStack->PointersLength = (ULONG) IoStatus.Information;

    //
    // If the driver returned a pointer to a device object, that is the
    // object for the dump driver  (non-scsi case)
    //

    DeviceObject = (PDEVICE_OBJECT) DumpPointers->DeviceObject;
    if (DeviceObject) {
        DriverObject = DeviceObject->DriverObject;

        //
        // Loop through the name of the driver looking for the end of the name,
        // which is the name of the dump image.
        //

        DumpName = DriverObject->DriverName.Buffer;
        while ( NameOffset = wcsstr( DumpName, L"\\" )) {
            DumpName = ++NameOffset;
        }

        ScsiDump = FALSE;
    }

    //
    // Release the handle, but keep the reference to the file object as it
    // will be needed at free dump dump driver time
    //

    DumpStack->FileObject = FileObject;
    ZwClose (DeviceHandle);

    //
    // Fill in some DumpInit results
    //

    DumpInit->Length             = sizeof (DUMP_INITIALIZATION_CONTEXT);
    DumpInit->Reserved           = 0;
    DumpInit->StallRoutine       = &KeStallExecutionProcessor;
    DumpInit->AdapterObject      = DumpPointers->AdapterObject;
    DumpInit->MappedRegisterBase = DumpPointers->MappedRegisterBase;
    DumpInit->PortConfiguration  = DumpPointers->DumpData;

    DumpStack->ModulePrefix      = ModulePrefix;
    DumpStack->PartitionOffset   = PartitionInfo.StartingOffset;
    DumpStack->UsageType         = DeviceUsageTypeUndefined;

    //
    // The minimum common buffer size is IO_DUMP_COMMON_BUFFER_SIZE (compatability)
    // This is used by the dump driver for SRB extension, CachedExtension, and sense buffer
    //

    if (DumpPointers->CommonBufferSize < IO_DUMP_COMMON_BUFFER_SIZE) {
        DumpPointers->CommonBufferSize = IO_DUMP_COMMON_BUFFER_SIZE;
    }  
    DumpInit->CommonBufferSize = DumpPointers->CommonBufferSize;

    //
    // Allocate the required common buffers
    //

    if (DumpPointers->AllocateCommonBuffers) {

        for (i=0; i < 2; i++) {
            //
            //  Don't use the adapter's DmaOperations to allocate the CommonBuffer.
            //  Some adapters support 64-bit DMA, but then fail crashdump if the CommonBuffer
            //  is above 4GB in physical RAM, making this unreliable.
            //  (We no longer support legacy ISA adapters that require he DMA buffer
            //   to be in the low 16MB).
            //
            pa.QuadPart = 0x0ffffffffL;
            p1 = MmAllocateContiguousMemory(DumpPointers->CommonBufferSize, pa);
            if (!p1) {
                KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                            CRASHDUMP_ERROR,
                            "CRASHDUMP: Could not allocate common buffers for dump\n"
                            ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Done;
            }

            pa = MmGetPhysicalAddress(p1);
            DumpInit->CommonBuffer[i] = p1;
            DumpInit->PhysicalAddress[i] = pa;
        }
    }

    //
    // Determine whether or not the system booted from SCSI.
    //

    ASSERT (DumpPointers->UseDiskDump == TRUE ||
            DumpPointers->UseDiskDump == FALSE);
            
    if (DumpPointers->UseDiskDump || ScsiDump) {
    
        //
        // Load the boot disk and port driver to be used by the various
        // miniports for writing memory to the disk.
        //

        //
        // NB: Using the UseDiskDump flag to determine whether this is
        // a SCSIPORT miniport or a STORPORT miniport is gross. Fix this
        // when we fix crashdump.
        //
        
        Status = IopLoadDumpDriver (
                        DumpStack,
                        DumpDriverName,
                        ScsiDump ? SCSIPORT_DRIVER_NAME : STORPORT_DRIVER_NAME
                        );

        if (!NT_SUCCESS(Status)) {

            IopLogErrorEvent(0,9,STATUS_SUCCESS,IO_DUMP_DRIVER_LOAD_FAILURE,0,NULL,0,NULL);
            goto Done;
        }
    }

    if (ScsiDump) {

        //
        // The disk and port dump driver has been loaded.  Load the appropriate
        // miniport driver as well so that the boot device can be accessed.
        //

        DriverName.Length = 0;
        DriverName.Buffer = (PVOID) Buffer;
        DriverName.MaximumLength = PAGE_SIZE;


        //
        // The system was booted from SCSI. Get the name of the appropriate
        // miniport driver and load it.
        //

        sprintf(Buffer, "\\Device\\ScsiPort%d", ScsiAddress.PortNumber );
        RtlInitAnsiString( &AnsiString, Buffer );
        Status = RtlAnsiStringToUnicodeString( &TempName, &AnsiString, TRUE );
        if (NT_SUCCESS(Status)){
            InitializeObjectAttributes(
                        &ObjectAttributes,
                        &TempName,
                        0,
                        NULL,
                        NULL
                        );

            Status = ZwOpenFile(
                        &DeviceHandle,
                        FILE_READ_ATTRIBUTES,
                        &ObjectAttributes,
                        &IoStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NON_DIRECTORY_FILE
                        );

            RtlFreeUnicodeString( &TempName );
        }          
        
        if (!NT_SUCCESS( Status )) {
            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                           CRASHDUMP_ERROR,
                           "CRASHDUMP: Could not open SCSI port %d, error = %x\n",
                           ScsiAddress.PortNumber,
                           Status
                           ));
            goto Done;
        }

        //
        // Convert the file handle into a pointer to the device object, and
        // get the name of the driver from its driver object.
        //

        ObReferenceObjectByHandle(
                    DeviceHandle,
                    0,
                    IoFileObjectType,
                    KernelMode,
                    (PVOID *) &FileObject,
                    NULL
                    );

        DriverObject = FileObject->DeviceObject->DriverObject;
        ObDereferenceObject( FileObject );
        ZwClose( DeviceHandle );
        //
        // Loop through the name of the driver looking for the end of the name,
        // which is the name of the miniport image.
        //

        DumpName = DriverObject->DriverName.Buffer;
        while ( NameOffset = wcsstr( DumpName, L"\\" )) {
            DumpName = ++NameOffset;
        }
    }

    //
    // Load the dump driver
    //

    if (!DumpName) {
        Status = STATUS_NOT_SUPPORTED;
        goto Done;
    }

    swprintf ((PWCHAR) Buffer, L"\\SystemRoot\\System32\\Drivers\\%s.sys", DumpName);
    Status = IopLoadDumpDriver (
                    DumpStack,
                    (PWCHAR) Buffer,
                    NULL
                    );
    if (!NT_SUCCESS(Status)) {

        IopLogErrorEvent(0,10,STATUS_SUCCESS,IO_DUMP_DRIVER_LOAD_FAILURE,0,NULL,0,NULL);
        goto Done;
    }

    //
    // Claim the file as part of specific device usage path.
    //

    FileObject = DumpStack->FileObject;
    DeviceObject = IoGetRelatedDeviceObject (FileObject);

    RtlZeroMemory (&irpSp, sizeof (IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
    irpSp.Parameters.UsageNotification.Type = UsageType;
    irpSp.Parameters.UsageNotification.InPath = TRUE;
    irpSp.FileObject = FileObject;

    Status = IopSynchronousCall (DeviceObject, &irpSp, NULL);

    if (!NT_SUCCESS(Status) && IgnoreDeviceUsageFailure) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_WARNING,
                    "CRASHDUMP: IopGetDumpStack: DEVICE_USAGE_NOTIFICATION "
                       "Error ignored (%x)\n",
                    Status
                    ));

        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status)) {
        DumpStack->UsageType = UsageType;
    }

Done:
    if (NT_SUCCESS(Status)) {
        *DumpStackBuffer = DumpStack;
    } else {
        IoFreeDumpStack (DumpStack);
    }
    ExFreePool (Buffer);
    return Status;
}



NTSTATUS
IopLoadDumpDriver (
    IN OUT PDUMP_STACK_CONTEXT  DumpStack,
    IN PWCHAR DriverNameString,
    IN PWCHAR NewBaseNameString OPTIONAL
    )
/*++

Routine Description:

    Worker function for IoGetDumpStack to load a particular driver into
    the current DumpStack being created

Arguments:

    DumpStack           - Dump driver stack being built

    DriverNameString    - The string name of the driver to load

    NewBaseNameString   - The modified basename of the driver once loaded

Return Value:

    Status

--*/
{
    NTSTATUS                Status;
    PDUMP_STACK_IMAGE       DumpImage;
    UNICODE_STRING          DriverName;
    UNICODE_STRING          BaseName;
    UNICODE_STRING          Prefix;
    PUNICODE_STRING         LoadBaseName;

    //
    // Allocate space to track this dump driver
    //

    DumpImage = ExAllocatePool(
                        NonPagedPool,
                        sizeof (DUMP_STACK_IMAGE)
                        );

    if (!DumpImage) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Load the system image
    //

    RtlInitUnicodeString (&DriverName, DriverNameString);
    RtlInitUnicodeString (&Prefix, DumpStack->ModulePrefix);
    LoadBaseName = NULL;
    if (NewBaseNameString) {
        LoadBaseName = &BaseName;
        RtlInitUnicodeString (&BaseName, NewBaseNameString);
        BaseName.MaximumLength = Prefix.Length + BaseName.Length;
        BaseName.Buffer = ExAllocatePool (
                            NonPagedPool,
                            BaseName.MaximumLength
                            );


        if (!BaseName.Buffer) {
            ExFreePool (DumpImage);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        BaseName.Length = 0;
        RtlAppendUnicodeStringToString (&BaseName, &Prefix);
        RtlAppendUnicodeToString (&BaseName, NewBaseNameString);
    }
    else {
        BaseName.Buffer = NULL;
    }

    Status = MmLoadSystemImage(
                &DriverName,
                &Prefix,
                LoadBaseName,
                MM_LOAD_IMAGE_AND_LOCKDOWN,
                &DumpImage->Image,
                &DumpImage->ImageBase
                );

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: MmLoadAndLockSystemImage\n"
                "           DumpImage %p Image %p Base %p\n",
                DumpImage,
                DumpImage->Image,
                DumpImage->ImageBase
                ));

    if (BaseName.Buffer) {
        ExFreePool (BaseName.Buffer);
    }

    if (!NT_SUCCESS (Status)) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Could not load %wZ; error = %x\n",
                    &DriverName,
                    Status
                    ));

        ExFreePool (DumpImage);
        return Status;
    }

    //
    // Put this driver on the list of drivers to be processed at crash time
    //

    DumpImage->SizeOfImage = DumpImage->Image->SizeOfImage;
    InsertTailList (&DumpStack->DriverList, &DumpImage->Link);
    return STATUS_SUCCESS;
}


ULONG
IopGetDumpControlBlockCheck (
    IN PDUMP_CONTROL_BLOCK  Dcb
    )
/*++

Routine Description:

    Return the current checksum total for the Dcb

Arguments:

    DumpStack           - Dump driver stack to checksum

Return Value:

    Checksum value

--*/
{
    ULONG                   Check;
    PLIST_ENTRY             Link;
    PDUMP_STACK_IMAGE       DumpImage;
    PMAPPED_ADDRESS         MappedAddress;
    PDUMP_STACK_CONTEXT     DumpStack;

    //
    // Check the DCB, memory descriptor array, and the FileDescriptorArray
    //

    Check = PoSimpleCheck(0, Dcb, sizeof(DUMP_CONTROL_BLOCK));

    Check = PoSimpleCheck(Check, Dcb->FileDescriptorArray, Dcb->FileDescriptorSize);

    DumpStack = Dcb->DumpStack;
    if (DumpStack) {

        //
        // Include the dump stack context structure, and dump driver images
        //

        Check = PoSimpleCheck(Check, DumpStack, sizeof(DUMP_STACK_CONTEXT));
        Check = PoSimpleCheck(Check, DumpStack->DumpPointers, DumpStack->PointersLength);

        for (Link = DumpStack->DriverList.Flink;
             Link != &DumpStack->DriverList;
             Link = Link->Flink) {

            DumpImage = CONTAINING_RECORD(Link, DUMP_STACK_IMAGE, Link);
            Check = PoSimpleCheck(Check, DumpImage, sizeof(DUMP_STACK_IMAGE));

#if !defined (_IA64_)

            //
            // ISSUE - 2000/02/14 - math: Add image check image for IA64.
            //
            // Disable the image checksum on IA64 because it's broken.


            Check = PoSimpleCheck(Check, DumpImage->ImageBase, DumpImage->SizeOfImage);
#endif

        }

        //
        // Include the mapped addresses
        //
        // If this is non-null it is treated as a PMAPPED_ADDRESS * (see scsiport and atdisk)
        //
        if (DumpStack->Init.MappedRegisterBase != NULL) {
            MappedAddress = *(PMAPPED_ADDRESS *)DumpStack->Init.MappedRegisterBase;
        } else {
            MappedAddress = NULL;
        }

        while (MappedAddress) {
            Check = PoSimpleCheck (Check, MappedAddress, sizeof(MAPPED_ADDRESS));
            MappedAddress = MappedAddress->NextMappedAddress;
        }
    }

    return Check;
}


NTSTATUS
IoInitializeDumpStack (
    IN PDUMP_STACK_CONTEXT  DumpStack,
    IN PUCHAR               MessageBuffer OPTIONAL
    )
/*++

Routine Description:

    Initialize the dump driver stack referenced by DumpStack to perform IO.

Arguments:

    DumpStack   - Dump driver stack being initialized

Return Value:

    Status

--*/
{

    PDUMP_INITIALIZATION_CONTEXT    DumpInit;
    PLIST_ENTRY                     Link;
    NTSTATUS                        Status;
    PDRIVER_INITIALIZE              DriverInit;
    PDUMP_STACK_IMAGE               DumpImage;


    DumpInit = &DumpStack->Init;

    //
    // ISSUE - 2000/02/07 - math: Verify checksum on DumpStack structure
    //

    //
    // Initializes the dump drivers
    //

    for (Link = DumpStack->DriverList.Flink;
         Link != &DumpStack->DriverList;
         Link = Link->Flink) {

        DumpImage = CONTAINING_RECORD(Link, DUMP_STACK_IMAGE, Link);

        //
        // Call this driver's driver init.  Only the first driver gets the
        // dump initialization context
        //

        DriverInit = (PDRIVER_INITIALIZE) (ULONG_PTR) DumpImage->Image->EntryPoint;
        Status = DriverInit (NULL, (PUNICODE_STRING) DumpInit);
        DumpInit = NULL;

        if (!NT_SUCCESS(Status)) {
            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Unable to initialize driver; error = %x\n",
                        Status
                        ));
            return Status;
        }
    }

    DumpInit = &DumpStack->Init;

    //
    // Display string we are starting
    //

    if (MessageBuffer) {
        IopDisplayString ( (PCCHAR) MessageBuffer );
    }

    //
    // Open the partition from which the system was booted.
    // This returns TRUE if the disk w/the appropriate signature was found,
    // otherwise a NULL, in which case there is no way to continue.
    //

    if (!DumpInit->OpenRoutine (DumpStack->PartitionOffset)) {

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Could not find/open partition offset\n"
                    ));
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}


VOID
IoGetDumpHiberRanges (
    IN PVOID                    HiberContext,
    IN PDUMP_STACK_CONTEXT      DumpStack
    )
/*++

Routine Description:

    Adds the dump driver stack storage to the hibernate range list,
    to inform the hibernate procedure which pages need cloned,
    discarded or not checksumed as they are in use by the dump
    stack.

Arguments:

    HiberContext        - Pointer to the hiber context structure

    DumpStack           - Dump driver stack being initialized

Return Value:

    None

--*/
{
    PDUMP_POINTERS              DumpPointers;
    PDUMP_STACK_IMAGE           DumpImage;
    PLIST_ENTRY                 Link;

    DumpPointers = DumpStack->DumpPointers;

    //
    // Report the common buffer
    //

    if (DumpPointers->CommonBufferVa) {
        PoSetHiberRange (
            HiberContext,
            PO_MEM_CL_OR_NCHK,
            DumpPointers->CommonBufferVa,
            DumpPointers->CommonBufferSize,
            'fubc'
            );
    }

    //
    // Dump the entire image of the dump drivers
    //

    for (Link = DumpStack->DriverList.Flink;
         Link != &DumpStack->DriverList;
         Link = Link->Flink) {

        DumpImage = CONTAINING_RECORD(Link, DUMP_STACK_IMAGE, Link);

        PoSetHiberRange (
            HiberContext,
            PO_MEM_CL_OR_NCHK,
            DumpImage->ImageBase,
            DumpImage->SizeOfImage,
            'gmID'
            );
    }
}


VOID
IoFreeDumpStack (
    IN PDUMP_STACK_CONTEXT     DumpStack
    )
/*++

Routine Description:

    Free the dump driver stack referenced by DumpStack

Arguments:

    DumpStack           - Dump driver stack being initialized

Return Value:

    None

--*/
{
    PDUMP_INITIALIZATION_CONTEXT     DumpInit;
    PDUMP_STACK_IMAGE               DumpImage;
    PDEVICE_OBJECT                  DeviceObject;
    IO_STATUS_BLOCK                 IoStatus;
    PIRP                            Irp;
    KEVENT                          Event;
    NTSTATUS                        Status;
    ULONG                           i;
    PFILE_OBJECT                    FileObject;
    IO_STACK_LOCATION               irpSp;

    PAGED_CODE();
    DumpInit = &DumpStack->Init;

    //
    // Release the claim to this file as a specific device usage path.
    //

    FileObject = DumpStack->FileObject;
    if (FileObject) {
        DeviceObject = IoGetRelatedDeviceObject (FileObject);

        RtlZeroMemory (&irpSp, sizeof (IO_STACK_LOCATION));

        irpSp.MajorFunction = IRP_MJ_PNP;
        irpSp.MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
        irpSp.Parameters.UsageNotification.Type = DumpStack->UsageType;
        irpSp.Parameters.UsageNotification.InPath = FALSE;
        irpSp.FileObject = FileObject;

        if (DeviceUsageTypeUndefined != DumpStack->UsageType) {
            Status = IopSynchronousCall (DeviceObject, &irpSp, NULL);
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    //
    // Free any common buffers which where allocated
    //

    for (i=0; i < 2; i++) {
        if (DumpInit->CommonBuffer[i]) {
            MmFreeContiguousMemory (DumpInit->CommonBuffer[i]);
            DumpInit->CommonBuffer[i] = NULL;
        }
    }

    //
    // Unload the dump drivers
    //

    while (!IsListEmpty(&DumpStack->DriverList)) {
        DumpImage = CONTAINING_RECORD(DumpStack->DriverList.Blink, DUMP_STACK_IMAGE, Link);
        RemoveEntryList (&DumpImage->Link);
        MmUnloadSystemImage (DumpImage->Image);
        ExFreePool (DumpImage);
    }

    //
    // Inform the driver stack that the dump registartion is over
    //

    if (DumpStack->FileObject) {
        DeviceObject = IoGetRelatedDeviceObject ((PFILE_OBJECT) DumpStack->FileObject);

        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        Irp = IoBuildDeviceIoControlRequest(
                    IOCTL_SCSI_FREE_DUMP_POINTERS,
                    DeviceObject,
                    DumpStack->DumpPointers,
                    sizeof (DUMP_POINTERS),
                    NULL,
                    0,
                    FALSE,
                    &Event,
                    &IoStatus
                    );
        if (Irp){
            PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(Irp);
            
            nextSp->FileObject = DumpStack->FileObject;
            Status = IoCallDriver( DeviceObject, Irp );
            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
                Status = IoStatus.Status;
            }
        }
        
        ObDereferenceObject( DumpStack->FileObject );
    }
    //
    // Free the target address if it exists
    //
    if (DumpStack->Init.TargetAddress) {
        ExFreePool( DumpStack->Init.TargetAddress);
    }
    //
    // Free the dump stack context
    //

    ExFreePool (DumpStack);
}

VOID
IopGetSecondaryDumpDataLimits(
    ULONG Flags,
    OUT PULONG MaxData,
    OUT PULONG MaxPerCallback
    )
{
    // When the selected dump type is small also
    // limit the amount of secondary dump data.
    // This prevents overzealous secondary dumpers from
    // creating multi-megabyte secondary dumps when triage
    // dumps are selected.
    if (!(Flags & DCB_DUMP_ENABLED) ||
        (Flags & DCB_DUMP_HEADER_ENABLED)) {
        *MaxData = 0;
        *MaxPerCallback = 0;
    } else if (Flags & DCB_TRIAGE_DUMP_ENABLED) {
        *MaxData = 16 * PAGE_SIZE;
        *MaxPerCallback = 2 * PAGE_SIZE;
    } else {
        // Arbitrarily limit maximum data amount to 256MB.
        // There shouldn't be any reason that callers should
        // have anywhere near that much data that wouldn't
        // get picked up by a full dump.
        *MaxData = 256 * 1024 * 1024;
        *MaxPerCallback = *MaxData / 4;
    }
}

NTSTATUS
IopGetSecondaryDumpDataSpace(
    IN PDUMP_CONTROL_BLOCK dcb,
    OUT PULONG Space
    )
{
    ULONG MaxDumpData;
    ULONG MaxPerCallbackDumpData;
    NTSTATUS NtStatus;

    IopGetSecondaryDumpDataLimits(dcb->Flags,
                                  &MaxDumpData, &MaxPerCallbackDumpData);

    NtStatus = IopInvokeSecondaryDumpDataCallbacks(NULL, NULL, NULL, 0,
                                                   (PBYTE)dcb->HeaderPage,
                                                   PAGE_SIZE,
                                                   MaxDumpData,
                                                   MaxPerCallbackDumpData,
                                                   Space);
    if (!NT_SUCCESS(NtStatus)) {
        *Space = 0;
    }

    return NtStatus;
}


NTSTATUS
IopInitializeDumpSpaceAndType(
    IN PDUMP_CONTROL_BLOCK dcb,
    IN OUT PMEMORY_DUMP MemoryDump,
    IN ULONG SecondarySpace
    )
{
    LARGE_INTEGER Space;

    Space.QuadPart = 0;

    if (dcb->Flags & DCB_TRIAGE_DUMP_ENABLED) {

        //
        // Fixed size dump for triage-dumps.
        //

        MemoryDump->Header.DumpType = DUMP_TYPE_TRIAGE;
        MemoryDump->Header.MiniDumpFields = dcb->TriageDumpFlags;
        Space.QuadPart = TRIAGE_DUMP_SIZE;


    } else if (dcb->Flags & DCB_SUMMARY_DUMP_ENABLED) {

        MemoryDump->Header.DumpType = DUMP_TYPE_SUMMARY;
        Space = IopCalculateRequiredDumpSpace(
                                dcb->Flags,
                                dcb->HeaderSize,
                                MmPhysicalMemoryBlock->NumberOfPages,
                                MemoryDump->Summary.Pages,
                                FALSE
                                );
    } else {

        if (dcb->Flags & DCB_DUMP_HEADER_ENABLED) {
            MemoryDump->Header.DumpType = DUMP_TYPE_HEADER;
        }

        Space = IopCalculateRequiredDumpSpace(
                                dcb->Flags,
                                dcb->HeaderSize,
                                MmPhysicalMemoryBlock->NumberOfPages,
                                MmPhysicalMemoryBlock->NumberOfPages,
                                FALSE
                                );
    }

    //
    // Add in any secondary space.
    //

    Space.QuadPart += SecondarySpace;
    
    //
    // If the calculated size is larger than the pagefile, truncate it to
    // the pagefile size.
    //

    if (Space.QuadPart > dcb->DumpFileSize.QuadPart) {
        Space.QuadPart = dcb->DumpFileSize.QuadPart;
    }

    MemoryDump->Header.RequiredDumpSpace = Space;

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: Dump File Size set to %I64x\n",
                Space.QuadPart
                ));

    return STATUS_SUCCESS;
}


BOOLEAN
IoWriteCrashDump(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN PVOID ContextSave,
    IN PKTHREAD Thread,
    OUT PBOOLEAN Reboot
    )

/*++

Routine Description:

    This routine checks to see whether or not crash dumps are enabled and, if
    so, writes all of physical memory to the system disk's paging file.

Arguments:

    BugCheckCode/ParameterN - Code and parameters w/which BugCheck was called.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDUMP_CONTROL_BLOCK dcb;
    PDUMP_STACK_CONTEXT dumpStack;
    PDUMP_DRIVER_WRITE write;
    PDUMP_DRIVER_FINISH finishUp;
    PDUMP_HEADER header;
    PCONTEXT context = ContextSave;
    PMEMORY_DUMP MemoryDump;
    LARGE_INTEGER diskByteOffset;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + 17];
    PMDL mdl;
    PLARGE_INTEGER mcb;
    ULONG64 memoryAddress;
    ULONG byteOffset;
    ULONG byteCount;
    PFN_NUMBER ActualPages;
    ULONG dwTransferSize;
    PFN_NUMBER NumberOfPages;
#if defined (_X86_)
    ULONG_PTR DirBasePage;
#endif
    ULONG MaxDumpData;
    ULONG MaxPerCallbackDumpData;
    NTSTATUS SecondaryStatus;
    ULONG SecondarySpace;
    PPHYSICAL_MEMORY_RUN CurRun;
    ULONG64 LastRunAddr;

    KdCheckForDebugBreak();

    ASSERT (Reboot != NULL);
    
    //
    // Initialization
    //

    MemoryDump = NULL;

    //
    // Immediately fill out the reboot parameter as auto-reboot
    // may be enabled even with no other post-mortem features.
    //

    if (IopAutoReboot) {
        *Reboot = TRUE;
    } else {
        *Reboot = FALSE;
    }
    
    //
    // Begin by determining whether or not crash dumps are enabled.  If not,
    // return immediately since there is nothing to do.
    //

    dcb = IopDumpControlBlock;
    if (!dcb) {
        return FALSE;
    }

    if (dcb->Flags & DCB_DUMP_ENABLED || dcb->Flags & DCB_SUMMARY_ENABLED) {

        IopFinalCrashDumpStatus = STATUS_PENDING;

        //
        // A dump is to be written to the paging file.  Ensure that all of the
        // descriptor data for what needs to be done is valid, otherwise it
        // could be that part of the reason for the bugcheck is that this data
        // was corrupted.  Or, it could be that no paging file was found yet,
        // or any number of other situations.
        //

        //
        // We do not check the checksum if IopIgnoreDumpCheck is TRUE. Use
        // this to make debugging easier.
        //
        
        if (!IopIgnoreDumpCheck &&
            IopGetDumpControlBlockCheck(dcb) != IopDumpControlBlockChecksum) {

            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Disk dump routine returning due to DCB integrity error\n"
                        "           Computed Checksum: %d != Saved Checksum %d\n"
                        "           No dump will be created\n",
                        IopGetDumpControlBlockCheck (dcb),
                        IopDumpControlBlockChecksum
                        ));

            IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;
            return FALSE;
        }

        //
        // Message  that we are starting the crashdump
        //

        dumpStack = dcb->DumpStack;

//        sprintf( messageBuffer, "%Z\n", &dumpStack->InitMsg );
        //
        //  Disable HAL Verifier during a crash dump.
        //
        VfDisableHalVerifier();
         
        //
        // Initialize the dump stack
        //

        status = IoInitializeDumpStack (dumpStack, NULL);

        KdCheckForDebugBreak();
        
        if (!NT_SUCCESS( status )) {
            IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;
            return FALSE;
        }

        //
        // If we successfully initialized the dump stack, print out the PSS
        // message.
        //

        IopDisplayString ("%Z\r\n", &dumpStack->InitMsg);

        //
        // Record the dump driver's entry points.
        //

        write = dumpStack->Init.WriteRoutine;
        finishUp = dumpStack->Init.FinishRoutine;


        dwTransferSize = dumpStack->Init.MaximumTransferSize;

        if ( ( !dwTransferSize ) || ( dwTransferSize > IO_DUMP_MAXIMUM_TRANSFER_SIZE ) ) {
            dwTransferSize = IO_DUMP_MINIMUM_TRANSFER_SIZE;
        }

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_TRACE,
                    "CRASHDUMP: Maximum Transfer Size = %x\n",dwTransferSize
                    ));

        //
        // The boot partition was found, so put together a dump file header
        // and write it to the disk.
        //

        // Get the amount of secondary dump data while the
        // header page can still be used as scratch space.
        SecondaryStatus = IopGetSecondaryDumpDataSpace(dcb, &SecondarySpace);
        
        MemoryDump = (PMEMORY_DUMP) dcb->HeaderPage;
        header = &MemoryDump->Header;

        RtlFillMemoryUlong( header, sizeof(*header), DUMP_SIGNATURE );
        header->ValidDump = DUMP_VALID_DUMP;
        header->BugCheckCode = BugCheckCode;
        header->BugCheckParameter1 = BugCheckParameter1;
        header->BugCheckParameter2 = BugCheckParameter2;
        header->BugCheckParameter3 = BugCheckParameter3;
        header->BugCheckParameter4 = BugCheckParameter4;
        header->SecondaryDataState = (ULONG)SecondaryStatus;

#if defined (_X86_)

        //
        // Add the current page directory table page - don't use the directory
        // table base for the crashing process as we have switched cr3 on
        // stack overflow crashes, etc.
        //

        _asm {
            mov     eax, cr3
            mov     DirBasePage, eax
        }
        header->DirectoryTableBase = DirBasePage;

#elif defined (_IA64_)
        ASSERT (((MmSystemParentTablePage << PAGE_SHIFT) >> PAGE_SHIFT) ==
                MmSystemParentTablePage);
        header->DirectoryTableBase = MmSystemParentTablePage << PAGE_SHIFT;
#else
        header->DirectoryTableBase = KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
#endif
        header->PfnDataBase = (ULONG_PTR)MmPfnDatabase;
        header->PsLoadedModuleList = (ULONG_PTR) &PsLoadedModuleList;
        header->PsActiveProcessHead = (ULONG_PTR) &PsActiveProcessHead;
        header->NumberProcessors = dcb->NumberProcessors;
        header->MajorVersion = dcb->MajorVersion;
        header->MinorVersion = dcb->MinorVersion;

#if defined (i386)
        header->PaeEnabled = X86PaeEnabled ();
#endif
        header->KdDebuggerDataBlock = KdGetDataBlock();

        header->MachineImageType = CURRENT_IMAGE_TYPE ();

        if (!(dcb->Flags & DCB_DUMP_ENABLED)) {
            NumberOfPages = 1;
        } else {
            NumberOfPages = MmPhysicalMemoryBlock->NumberOfPages;
        }

        strcpy( header->VersionUser, dcb->VersionUser );

        //
        // Copy the physical memory descriptor.
        //

        RtlCopyMemory (&MemoryDump->Header.PhysicalMemoryBlock,
                       MmPhysicalMemoryBlock,
                       sizeof( PHYSICAL_MEMORY_DESCRIPTOR ) +
                       ((MmPhysicalMemoryBlock->NumberOfRuns - 1) *
                       sizeof( PHYSICAL_MEMORY_RUN )) );

        RtlCopyMemory( MemoryDump->Header.ContextRecord,
                       context,
                       sizeof( CONTEXT ) );

        MemoryDump->Header.Exception.ExceptionCode = STATUS_BREAKPOINT;
        MemoryDump->Header.Exception.ExceptionRecord = 0;
        MemoryDump->Header.Exception.NumberParameters = 0;
        MemoryDump->Header.Exception.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
        MemoryDump->Header.Exception.ExceptionAddress = PROGRAM_COUNTER (context);

        //
        // Init dump type to FULL
        //

        MemoryDump->Header.DumpType = DUMP_TYPE_FULL;

        //
        // Save the System time and uptime (This is always available)
        // It's a KSYSTEM_TIME structure, but we only store the low and
        // high 1 part
        //

        MemoryDump->Header.SystemTime.LowPart  = SharedUserData->SystemTime.LowPart;
        MemoryDump->Header.SystemTime.HighPart = SharedUserData->SystemTime.High1Time;

        MemoryDump->Header.SystemUpTime.LowPart  = SharedUserData->InterruptTime.LowPart;
        MemoryDump->Header.SystemUpTime.HighPart = SharedUserData->InterruptTime.High1Time;

        // Save product type and suite.
        MemoryDump->Header.ProductType = SharedUserData->NtProductType;
        MemoryDump->Header.SuiteMask = SharedUserData->SuiteMask;
        
        //
        // Set the Required dump size in the dump header. In the case of
        // a summary dump the file allocation size can be significantly larger
        // then the amount of used space.
        //

        MemoryDump->Header.RequiredDumpSpace.QuadPart = 0;
        
        IopGetSecondaryDumpDataLimits(dcb->Flags,
                                      &MaxDumpData, &MaxPerCallbackDumpData);
        if (MaxDumpData > SecondarySpace) {
            MaxDumpData = SecondarySpace;
            if (MaxPerCallbackDumpData > MaxDumpData) {
                MaxPerCallbackDumpData = MaxDumpData;
            }
        }

        if (dcb->Flags & DCB_DUMP_ENABLED) {

            //
            // If summary dump try to create the dump header
            //

            if ( (dcb->Flags & DCB_SUMMARY_DUMP_ENABLED) ) {

                //
                // Initialize the summary dump
                //

                status = IopInitializeSummaryDump( MemoryDump, dcb );

                if ( !NT_SUCCESS (status) ) {

                    //
                    // No summary dump header so return.
                    //

                    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                                CRASHDUMP_WARNING,
                                "CRASHDUMP: NULL summary dump header\n"
                                ));

                    IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;

                    return FALSE;
                }
            }

            IopInitializeDumpSpaceAndType ( dcb, MemoryDump, SecondarySpace );
        }

        //
        // All of the pieces of the header file have been generated.  Before
        // mapping or writing anything to the disk, the I- & D-stream caches
        // must be flushed so that page color coherency is kept.  Sweep both
        // caches now.
        //

        KeSweepCurrentDcache();
        KeSweepCurrentIcache();

        //
        // Create MDL for dump.
        //

        mdl = (PMDL) &localMdl[0];
        MmCreateMdl( mdl, NULL, sizeof(*header) );
        mdl->MdlFlags |= MDL_PAGES_LOCKED;

        mcb = dcb->FileDescriptorArray;

        //
        // All of the pieces of the header file have been generated.  Write
        // the header page to the paging file, using the appropriate drivers,
        // etc.
        //

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_TRACE,
                    "CRASHDUMP: Writing dump header to disk\n"
                    ));

        status = IopWriteToDisk(dcb->HeaderPage, sizeof(*header),
                                write, &mcb, mdl, dwTransferSize,
                                KbDumpIoHeader);
        if (!NT_SUCCESS(status)) {
            IopFinalCrashDumpStatus = status;
            return FALSE;
        }

        //
        // If only requesting a header dump, we are now done.
        //

        if (dcb->Flags & DCB_DUMP_HEADER_ENABLED) {
            goto FinishDump;
        }

        //
        // The header page has been written. If this is a triage-dump, write
        // the dump information and bail. Otherwise, fall through and do the
        // full or summary dump.
        //

        if (dcb->Flags & DCB_TRIAGE_DUMP_ENABLED) {
            status = IopWriteTriageDump (dcb->TriageDumpFlags,
                                         write,
                                         &mcb,
                                         mdl,
                                         dwTransferSize,
                                         context,
                                         Thread,
                                         dcb->TriageDumpBuffer,
                                         dcb->TriageDumpBufferSize - sizeof(DUMP_HEADER),
                                         dcb->BuildNumber,
                                         (UCHAR)dcb->Flags
                                         );

            if (!NT_SUCCESS (status)) {

                KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                            CRASHDUMP_WARNING,
                            "CRASHDUMP: Failed to write triage-dump\n"
                            ));

                IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;
                return FALSE;
            }

            goto FinishDump;
        }

        //
        // The header page has been written to the paging file.  If a full dump
        // of all of physical memory is to be written, write it now.
        //

        if (dcb->Flags & DCB_DUMP_ENABLED) {

            ULONG64 bytesDoneSoFar = 0;
            ULONG currentPercentage = 0;
            ULONG maximumPercentage = 0;


            //
            // Actual Pages is the number of pages to dump.
            //

            ActualPages = NumberOfPages;

            if (dcb->Flags & DCB_SUMMARY_DUMP_ENABLED) {

                //
                // At this point the dump header header has been sucessfully
                // written. Write the summary dump header.
                //

                status = IopWriteSummaryHeader(
                                     &MemoryDump->Summary,
                                     write,
                                     &mcb,
                                     mdl,
                                     dwTransferSize,
                                     (dcb->HeaderSize - sizeof(DUMP_HEADER))
                                     );

                if ( !NT_SUCCESS (status) ) {
                    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                                CRASHDUMP_WARNING,
                                "CRASHDUMP: Error writing summary dump header %08x\n",
                                status
                                ));

                    IopFinalCrashDumpStatus = status;
                    return FALSE;
                }

                ActualPages = MemoryDump->Summary.Pages;

            }

            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_TRACE,
                        "CRASHDUMP: Writing Memory Dump\n"
                        ));

            if ( dcb->Flags & DCB_SUMMARY_DUMP_ENABLED ) {

                status = IopWriteSummaryDump (
                                        (PRTL_BITMAP) &MemoryDump->Summary.Bitmap,
                                        write,
                                        &dumpStack->ProgMsg,
                                        NULL,
                                        &mcb,
                                        dwTransferSize
                                        );

                if (!NT_SUCCESS (status)) {
                    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                                CRASHDUMP_WARNING,
                                "CRASHDUMP: Failed to write kernel memory dump\n"
                                ));
                    IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;
                    return FALSE;
                }
                goto FinishDump;
            }

            //
            // Set the virtual file offset and initialize loop variables and
            // constants then loop, writing all of physical memory
            // to the paging file.
            //

            // Force a new run to be selected immediately.
            CurRun = MmPhysicalMemoryBlock->Run;
            memoryAddress = 0;
            LastRunAddr = 0;

            while (mcb[0].QuadPart) {

                ASSERT(memoryAddress <= LastRunAddr);
                if (memoryAddress >= LastRunAddr) {

                    ASSERT(CurRun >= MmPhysicalMemoryBlock->Run &&
                           CurRun <= MmPhysicalMemoryBlock->Run +
                           (MmPhysicalMemoryBlock->NumberOfRuns - 1));

                    memoryAddress = (ULONG64)CurRun->BasePage * PAGE_SIZE;
                    LastRunAddr = memoryAddress +
                        (ULONG64)CurRun->PageCount * PAGE_SIZE;

                    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                                CRASHDUMP_TRACE,
                                "CRASHDUMP: Run %d: %I64x - %I64x\n",
                                (ULONG)(CurRun - MmPhysicalMemoryBlock->Run),
                                memoryAddress, LastRunAddr));

                    CurRun++;
                }
                
                diskByteOffset = mcb[1];

                //
                // Calculate byte offset;
                //

                byteOffset = (ULONG)(memoryAddress & (PAGE_SIZE - 1));

                byteCount = dwTransferSize - byteOffset;
                if (byteCount > mcb[0].QuadPart) {
                    byteCount = mcb[0].LowPart;
                }
                if (LastRunAddr - memoryAddress < byteCount) {
                    byteCount = (ULONG)(LastRunAddr - memoryAddress);
                }
                bytesDoneSoFar += byteCount;

                currentPercentage = (ULONG)
                    (((bytesDoneSoFar / PAGE_SIZE) * 100) / ActualPages);

                if (currentPercentage > maximumPercentage) {

                    maximumPercentage = currentPercentage;

                    //
                    // Update message on screen.
                    //

                    IopDisplayString ( "%Z: %3d\r",
                                       &dumpStack->ProgMsg,
                                       maximumPercentage
                                       );
                }

                //
                // Map the physical memory and write it to the
                // current segment of the file.
                //

                IopMapPhysicalMemory( mdl,
                                      memoryAddress,
                                      byteCount
                                      );

                //
                // Write the next segment.
                //

                KdCheckForDebugBreak();

                IopInvokeDumpIoCallbacks((PUCHAR)mdl->MappedSystemVa +
                                         mdl->ByteOffset, byteCount,
                                         KbDumpIoBody);
        
                if (!NT_SUCCESS( write( &diskByteOffset, mdl ) )) {
                    IopFinalCrashDumpStatus = STATUS_UNSUCCESSFUL;
                    return FALSE;
                }

                //
                // Adjust pointers for next part.
                //

                memoryAddress += byteCount;
                mcb[0].QuadPart = mcb[0].QuadPart - byteCount;
                mcb[1].QuadPart = mcb[1].QuadPart + byteCount;

                if (!mcb[0].QuadPart) {
                    mcb += 2;
                }

                if ((bytesDoneSoFar / PAGE_SIZE) >= ActualPages) {
                    break;
                }
            }

            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_TRACE,
                        "CRASHDUMP: memory dump written\n"
                        ));
        }

FinishDump:

        IopDisplayString ( "\n\r%Z", &dumpStack->DoneMsg );

        IopInvokeSecondaryDumpDataCallbacks(write,
                                            &mcb,
                                            mdl,
                                            dwTransferSize,
                                            (PBYTE)dcb->HeaderPage,
                                            PAGE_SIZE,
                                            MaxDumpData,
                                            MaxPerCallbackDumpData,
                                            NULL);

        // Final I/O complete notification.
        IopInvokeDumpIoCallbacks(NULL, 0, KbDumpIoComplete);
        
        //
        // Sweep the cache so the debugger will work.
        //

        KeSweepCurrentDcache();
        KeSweepCurrentIcache();

        //
        // Have the dump flush the adapter and disk caches.
        //

        finishUp();

        //
        // Indicate to the debugger that the dump has been successfully
        // written.
        //

        IopFinalCrashDumpStatus = STATUS_SUCCESS;
    }

    KdCheckForDebugBreak();
    
    return TRUE;
}



VOID
IopMapPhysicalMemory(
    IN OUT PMDL Mdl,
    IN ULONG64 MemoryAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to fill in the specified MDL (Memory Descriptor
    List) w/the appropriate information to map the specified memory address
    range.

Arguments:

    Mdl - Address of the MDL to be filled in.

    MemoryAddress - Physical address being mapped.

    Length - Length of transfer to be mapped.

Return Value:

    None.

--*/

{
    PPFN_NUMBER page;
    PFN_NUMBER pages;
    PFN_NUMBER base;

    //
    // Begin by determining the base physical page of the start of the address
    // range and filling in the MDL appropriately.
    //
    Mdl->StartVa = PAGE_ALIGN( (PVOID)(ULONG_PTR)MemoryAddress );
    Mdl->ByteOffset = (ULONG)(MemoryAddress & (PAGE_SIZE - 1));
    Mdl->ByteCount = Length;

    //
    // Get the page frame index for the base address.
    //

    base = (PFN_NUMBER) (MemoryAddress >> PAGE_SHIFT);
    pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MemoryAddress, Length);
    page = MmGetMdlPfnArray(Mdl);

    //
    // Map all of the pages for this transfer until there are no more remaining
    // to be mapped.
    //

    while (pages) {
        *page++ = base++;
        pages--;
    }

    //
    // All of the PFNs for the address range have been filled in so map the
    // physical memory into virtual address space.
    //

    MmMapMemoryDumpMdl( Mdl );
}



BOOLEAN
IopAddPageToPageMap(
    IN ULONG MaxPage,
    IN PRTL_BITMAP BitMap,
    IN ULONG PageFrameIndex,
    IN ULONG NumberOfPages
    )
{
    //
    // Sometimes we get PFNs that are out of range. Just ignore them.
    //

    if (PageFrameIndex >= MaxPage) {
        return FALSE;
    }

    RtlSetBits (BitMap, PageFrameIndex, NumberOfPages);
    return TRUE;
}



BOOLEAN
IopRemovePageFromPageMap(
    IN ULONG MaxPage,
    IN PRTL_BITMAP BitMap,
    IN ULONG PageFrameIndex,
    IN ULONG NumberOfPages
    )
{
    //
    // Sometimes we get PFNs that are out of range. Just ignore them.
    //

    if (PageFrameIndex >= MaxPage) {
        return FALSE;
    }

    RtlClearBits (BitMap, PageFrameIndex, NumberOfPages);
    return TRUE;
}


NTSTATUS
IoSetDumpRange(
    IN PMM_KERNEL_DUMP_CONTEXT Context,
    IN PVOID StartVa,
    IN ULONG_PTR Pages,
    IN ULONG AddressFlags
    )

/*++

Routine Description:

    This routine includes this range of memory in the dump

Arguments:

    Context - Dump context.

    StartVa - Starting virtual address.

    Pages - The number of pages to include

    AddressFlags - 0 if the address is virtually mapped.
                   1 if the address is super/large page mapped.  This implies
                     the entire page range is physically contiguous.
                   2 if the address really represents a physical page frame
                     number.  This also implies the entire page range is
                     physically contiguous.

Return Value:

    STATUS_SUCCESS - On success.

    NTSTATUS - Error.

--*/
{
    PCHAR Va;
    PRTL_BITMAP BitMap;
    PHYSICAL_ADDRESS PhyAddr;
    PSUMMARY_DUMP Summary;
    BOOLEAN AllPagesSet;
    ULONG_PTR PageFrameIndex;

    //
    // Validation
    //

    ASSERT (Context != NULL &&
            Context->Context != NULL);

    //
    // Initialization
    //

    Summary = (PSUMMARY_DUMP) Context->Context;
    BitMap = (PRTL_BITMAP) &Summary->Bitmap;
    Va = StartVa;
    AllPagesSet = TRUE;

    //
    // Win64 can have really large page addresses.  This dump code does
    // not handle that yet.  Note that before this assert is removed
    // the casts of Pages to ULONG must be removed.
    //

    ASSERT(Pages <= MAXULONG);

    if (AddressFlags == 1) {

        PhyAddr = MmGetPhysicalAddress (Va);
        AllPagesSet =
            IopAddPageToPageMap ( Summary->BitmapSize,
                                  BitMap,
                                  (ULONG) (PhyAddr.QuadPart >> PAGE_SHIFT),
                                  (ULONG) Pages
                                  );

    } else if (AddressFlags == 2) {

        PageFrameIndex = (ULONG_PTR) Va;

        AllPagesSet =
            IopAddPageToPageMap ( Summary->BitmapSize,
                                  BitMap,
                                  (ULONG) PageFrameIndex,
                                  (ULONG) Pages
                                  );

    } else {

        //
        // Not physically contiguous.
        //

        while (Pages) {

            //
            // Only do a translation for valid pages.
            //

            if ( MmIsAddressValid(Va) ) {

                //
                // Get the physical mapping. Note: this does not require a lock
                //

                PhyAddr = MmGetPhysicalAddress (Va);

                if (!IopAddPageToPageMap ( Summary->BitmapSize,
                                           BitMap,
                                           (ULONG)( PhyAddr.QuadPart >> PAGE_SHIFT),
                                           1)) {
                    AllPagesSet = FALSE;
                }
            }

            Va += PAGE_SIZE;
            Pages--;
        }
    }

    if (AllPagesSet) {
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_ADDRESS;
}


NTSTATUS
IoFreeDumpRange(
    IN PMM_KERNEL_DUMP_CONTEXT Context,
    IN PVOID StartVa,
    IN ULONG_PTR Pages,
    IN ULONG AddressFlags
    )
/*++

Routine Description:

    This routine excludes this range of memory in the dump.

Arguments:

    DumpContext - dump context

    StartVa - Starting VA

    Pages - The number of pages to include

    AddressFlags - 0 if the address is virtually mapped.
                   1 if the address is super/large page mapped.  This implies
                     the entire page range is physically contiguous.
                   2 if the address really represents a physical page frame
                     number.  This also implies the entire page range is
                     physically contiguous.

Return Value:

    STATUS_SUCCESS - On success.

    NTSTATUS - Error.

--*/
{
    PCHAR Va;
    PRTL_BITMAP  BitMap;
    PHYSICAL_ADDRESS PhyAddr;
    PSUMMARY_DUMP Summary;
    ULONG_PTR PageFrameIndex;

    ASSERT (Context != NULL &&
            Context->Context != NULL);

    //
    // Round to page size.
    //

    Summary = (PSUMMARY_DUMP)Context->Context;
    BitMap = (PRTL_BITMAP) &Summary->Bitmap;
    Va = StartVa;

    //
    // Win64 can have really large page addresses.  This dump code does
    // not handle that yet.  Note that before this assert is removed
    // the casts of Pages to ULONG must be removed.
    //

    ASSERT (Pages <= MAXULONG);

    if (AddressFlags == 1) {

        PhyAddr = MmGetPhysicalAddress(Va);

        IopRemovePageFromPageMap (Summary->BitmapSize,
                                  BitMap,
                                  (ULONG)(PhyAddr.QuadPart >> PAGE_SHIFT),
                                  (ULONG) Pages
                                  );

    } else if (AddressFlags == 2) {

        PageFrameIndex = (ULONG_PTR) Va;

        IopRemovePageFromPageMap (Summary->BitmapSize,
                                  BitMap,
                                  (ULONG) PageFrameIndex,
                                  (ULONG) Pages
                                  );
    } else {

        while (Pages) {

            //
            // Only do a translation for valid pages.
            //

            if ( MmIsAddressValid (Va) ) {
                PhyAddr = MmGetPhysicalAddress (Va);

                IopRemovePageFromPageMap (Summary->BitmapSize,
                                          BitMap,
                                          (ULONG)(PhyAddr.QuadPart >> PAGE_SHIFT),
                                          1);

            }

            Va += PAGE_SIZE;
            Pages--;
        }
    }

    return STATUS_SUCCESS;
}



LARGE_INTEGER
IopCalculateRequiredDumpSpace(
    IN ULONG      dwDmpFlags,
    IN ULONG      dwHeaderSize,
    IN PFN_NUMBER dwMaxPages,
    IN PFN_NUMBER dwMaxSummaryPages,
    IN BOOLEAN    LargestPossibleSize
    )

/*++

Routine Description:

    This routine is used to calcuate required dump space

        1. Crash dump summary must be at least 1 page in length.

        2. Summary dump must be large enough for kernel memory plus header,
           plus summary header.

        3. Full dump must be large enough for header plus all physical memory.

Arguments:

    dwDmpFlags - Dump Control Block (DCB) flags.

    dwHeaderSize - The size of the dump header.

    dwMaxPages - All physical memory.

    dwMaxSummaryPages - Maximum pages in summary dump.

    LargestPossibleSize - If TRUE return the largest size a dump
                          could be, otherwise return the size of a dump
                          of the current state.  The largest possible
                          size of a dump may be larger than the current
                          size because memory may be added dynamically.
                          
Return Value:

    Size of the dump file

--*/
{
    LARGE_INTEGER maxMemorySize;

    //
    // Dump header or dump summary.
    //

    if ( (dwDmpFlags & DCB_DUMP_HEADER_ENABLED) ||
         ( !( dwDmpFlags & DCB_DUMP_ENABLED ) &&
         ( dwDmpFlags & DCB_SUMMARY_ENABLED ) ) ) {

        maxMemorySize.QuadPart = IO_DUMP_MINIMUM_FILE_SIZE;
        return maxMemorySize;
    }

    if (dwDmpFlags & DCB_TRIAGE_DUMP_ENABLED) {

        maxMemorySize.QuadPart = TRIAGE_DUMP_SIZE;
        return maxMemorySize;
    }

    if (dwDmpFlags & DCB_SUMMARY_DUMP_ENABLED) {

#ifndef _WIN64
        ULONG dwGB;
#endif

        if (LargestPossibleSize) {
            dwMaxSummaryPages = 0xffffffff;
        }
        
#ifndef _WIN64
        maxMemorySize.QuadPart  = (ULONG64)dwMaxSummaryPages * PAGE_SIZE;

        //
        // 32-bit systems can't have more than 3GB of kernel
        // memory so don't ask for more space than that.
        //

        dwGB = 1024 * 1024 * 1024;

        if (maxMemorySize.QuadPart > (3 * dwGB) ) {
            maxMemorySize.QuadPart = (3 * dwGB);
        }
#else
        maxMemorySize.QuadPart  = (ULONG64)dwMaxSummaryPages * PAGE_SIZE;
#endif

        //
        // Control block header size for summary dump
        // includes space for the base header, the summary
        // header and the page bitmap.
        //
        
        maxMemorySize.QuadPart += dwHeaderSize;

        return maxMemorySize;

    }

    //
    // Full memory dump is #pages * pagesize plus 1 page for the dump header.
    //

    if (LargestPossibleSize) {
        maxMemorySize.QuadPart = 0x1000000000000000 + dwHeaderSize;
    } else {
        maxMemorySize.QuadPart =
            ((ULONG64)dwMaxPages * PAGE_SIZE) + dwHeaderSize;
    }

    return maxMemorySize;

}



//
// Triage-dump support routines.
//


NTSTATUS
IopGetLoadedDriverInfo(
    OUT ULONG * lpDriverCount,
    OUT ULONG * lpSizeOfStringData
    )

/*++

Routine Description:

    Get information about all loaded drivers.

Arguments:

    lpDriverCount - Buffer to return the count of all the drivers that are
                    currently loaded in the system.

    lpSizeOfStringData - Buffer to return the sum of the sizes of all driver
                    name strings (FullDllName). This does not include the size
                    of the UNICODE_STRING structure or a trailing NULL byte.

Return Values:

    NTSTATUS

--*/

{
    ULONG DriverCount = 0;
    ULONG SizeOfStringData = 0;
    PLIST_ENTRY NextEntry;
    PKLDR_DATA_TABLE_ENTRY DriverEntry;


    NextEntry = PsLoadedModuleList.Flink;
    while (NextEntry != &PsLoadedModuleList) {

        DriverEntry = CONTAINING_RECORD (NextEntry,
                                         KLDR_DATA_TABLE_ENTRY,
                                         InLoadOrderLinks
                                         );

        if (!IopIsAddressRangeValid (DriverEntry, sizeof (*DriverEntry)) ||
            !IopIsAddressRangeValid (DriverEntry->BaseDllName.Buffer,
                                     DriverEntry->BaseDllName.Length)) {

            return STATUS_UNSUCCESSFUL;
        }

        DriverCount++;

        //
        // The extra two bytes is for the NULL termination. The extra 7 is
        // because we force 8-byte alignment of all strings.
        //

        SizeOfStringData += DriverEntry->BaseDllName.Length + 2 + 7;
        NextEntry = NextEntry->Flink;
    }

    *lpDriverCount = DriverCount;
    *lpSizeOfStringData = SizeOfStringData;

    return STATUS_SUCCESS;
}

#define DmpPoolStringSize(DumpString)\
        (sizeof (DUMP_STRING) + sizeof (WCHAR) * ( DumpString->Length + 1 ))

#define DmpNextPoolString(DumpString)                                       \
        (PDUMP_STRING) (                                                    \
            ALIGN_UP_POINTER(                                               \
                ((LPBYTE) DumpString) + DmpPoolStringSize (DumpString),     \
                ULONGLONG                                                   \
                )                                                           \
            )

#define ALIGN_8(_x) ALIGN_UP(_x, DWORDLONG)

#define ASSERT_ALIGNMENT(Pointer, Alignment)\
    ASSERT ((((ULONG_PTR)Pointer) & ((Alignment) - 1)) == 0)

#ifndef IndexByByte
#define IndexByByte(Pointer, Index) (&(((BYTE*) (Pointer)) [Index]))
#endif


NTSTATUS
IopWriteDriverList(
    IN ULONG_PTR BufferAddress,
    IN ULONG BufferSize,
    IN ULONG DriverListOffset,
    IN ULONG StringPoolOffset
    )

/*++

Routine Description:

    Write the triage dump driver list to the buffer.

Arguments:

    BufferAddress - The address of the buffer.

    BufferSize - The size of the buffer.

    DriverListOffset - The offset within the buffer where the driver list
        should be written.

    StringPoolOffset - The offset within the buffer where the driver list's
        string pool should start. If there are no other strings for the triage
        dump other than driver name strings, this will be the string pool
        offset.

Return Value:

    NTSTATUS

--*/

{
    ULONG i = 0;
    PLIST_ENTRY NextEntry;
    PKLDR_DATA_TABLE_ENTRY DriverEntry;
    PDUMP_DRIVER_ENTRY DumpImageArray;
    PDUMP_STRING DumpStringName = NULL;
    PIMAGE_NT_HEADERS NtHeaders;

    ASSERT (DriverListOffset != 0);
    ASSERT (StringPoolOffset != 0);

    UNREFERENCED_PARAMETER (BufferSize);

    DumpImageArray = (PDUMP_DRIVER_ENTRY) (BufferAddress + DriverListOffset);
    DumpStringName = (PDUMP_STRING) (BufferAddress + StringPoolOffset);

    NextEntry = PsLoadedModuleList.Flink;

    while (NextEntry != &PsLoadedModuleList) {

        DriverEntry = CONTAINING_RECORD (NextEntry,
                                        KLDR_DATA_TABLE_ENTRY,
                                        InLoadOrderLinks);

        //
        // Verify the memory is valid before reading anything from it.
        //

        if (!IopIsAddressRangeValid (DriverEntry, sizeof (*DriverEntry)) ||
            !IopIsAddressRangeValid (DriverEntry->BaseDllName.Buffer,
                                     DriverEntry->BaseDllName.Length)) {

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Build the entry in the string pool. We guarantee all strings are
        // NULL terminated as well as length prefixed.
        //

        DumpStringName->Length = DriverEntry->BaseDllName.Length / 2;
        RtlCopyMemory (DumpStringName->Buffer,
                       DriverEntry->BaseDllName.Buffer,
                       DumpStringName->Length * sizeof (WCHAR)
                       );

        DumpStringName->Buffer[ DumpStringName->Length ] = '\000';

        RtlCopyMemory (&DumpImageArray [i].LdrEntry,
                       DriverEntry,
                       sizeof (DumpImageArray [i].LdrEntry)
                       );

        //
        // Add the time/date stamp.
        //

        DumpImageArray[i].LdrEntry.TimeDateStamp = 0;
        DumpImageArray[i].LdrEntry.SizeOfImage = 0;

        if ( MmIsAddressValid (DriverEntry->DllBase ) &&
             (NtHeaders = RtlImageNtHeader(DriverEntry->DllBase)) ) {

            DumpImageArray[i].LdrEntry.TimeDateStamp =
                        NtHeaders->FileHeader.TimeDateStamp;
            DumpImageArray[i].LdrEntry.SizeOfImage =
                        NtHeaders->OptionalHeader.SizeOfImage;

        } else if (DriverEntry->Flags & LDRP_NON_PAGED_DEBUG_INFO) {

            DumpImageArray[i].LdrEntry.TimeDateStamp =
                        DriverEntry->NonPagedDebugInfo->TimeDateStamp;
            DumpImageArray[i].LdrEntry.SizeOfImage =
                        DriverEntry->NonPagedDebugInfo->SizeOfImage;
        }

        DumpImageArray [i].DriverNameOffset =
                (ULONG)((ULONG_PTR) DumpStringName - BufferAddress);

        i++;
        DumpStringName = DmpNextPoolString (DumpStringName);
        NextEntry = NextEntry->Flink;
    }

    return STATUS_SUCCESS;
}

ULONG
IopSizeTriageDumpDataBlocks(
    PTRIAGE_DUMP TriageDump,
    ULONG Offset,
    ULONG BufferSize
    )

/*++

Routine Description:

    Determine all triage dump data blocks that fit and
    update dump header to match.

Arguments:

    TriageDump - Dump header.

    Offset - Current offset in dump buffer.

    BufferSize - Dump buffer size.

Return Values:

    Updated offset.

--*/

{
    ULONG i;
    ULONG Size;
    PTRIAGE_PTR_DATA_BLOCK Block;

    TriageDump->DataBlocksCount = 0;
    
    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++) {
        Size = ALIGN_8(sizeof(TRIAGE_DATA_BLOCK)) +
            ALIGN_8((ULONG)(Block->MaxAddress - Block->MinAddress));
        if (Offset + Size >= BufferSize) {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
            break;
        }

        if (i == 0) {
            TriageDump->DataBlocksOffset = Offset;
        }

        Offset += Size;
        TriageDump->DataBlocksCount++;
    }

    return Offset;
}

VOID
IopWriteTriageDumpDataBlocks(
    PTRIAGE_DUMP TriageDump,
    PUCHAR BufferAddress
    )

/*++

Routine Description:

    Write triage dump data blocks given in header.

Arguments:

    TriageDump - Dump header.

    BufferAddress - Address of dump data buffer.

Return Values:

    None.

--*/

{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    PUCHAR DataBuffer;
    PTRIAGE_DATA_BLOCK DumpBlock;

    DumpBlock = (PTRIAGE_DATA_BLOCK)
        (BufferAddress + TriageDump->DataBlocksOffset);
    DataBuffer = (PUCHAR)(DumpBlock + TriageDump->DataBlocksCount);
    
    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < TriageDump->DataBlocksCount; i++, Block++) {

        DumpBlock->Address = (ULONG64)(LONG_PTR)Block->MinAddress;
        DumpBlock->Offset = (ULONG)(DataBuffer - BufferAddress);
        DumpBlock->Size = (ULONG)(Block->MaxAddress - Block->MinAddress);

        RtlCopyMemory(DataBuffer, Block->MinAddress, DumpBlock->Size);
        
        DataBuffer += DumpBlock->Size;
        DumpBlock++;
    }
}



NTSTATUS
IopWriteTriageDump(
    IN ULONG Fields,
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG DriverTransferSize,
    IN PCONTEXT Context,
    IN PKTHREAD Thread,
    IN BYTE* Buffer,
    IN ULONG BufferSize,
    IN ULONG ServicePackBuild,
    IN ULONG TriageOptions
)

/*++

Routine Description:

    Write the Triage-Dump to the MCB.

Arguments:

    Fields - The set of fields that should be written.

    DriverWriteRoutine - The write routine for the driver.

    Mcb - Message Control Block where the data is to be written.

    Mdl - A MDL descrbing the data to be written (??).

    DriverTransferSize - The maximum transfer size for the driver.

    Context - The context.

    Buffer - The buffer to use as a scratch buffer.

    BufferSize - The size of the buffer.

    ServicePackBuild - Service Pack BuildNumber.

    TriageOptions - Triage Options.

Return Values:

    STATUS_SUCCESS - On success.

    NTSTATUS - Otherwise.

Comments:

    This function assumes that exactly one header page was written.

--*/

{
    ULONG SizeOfSection;
    ULONG SizeOfStringData;
    ULONG DriverCount = 0;
    LPVOID Address = NULL;
    ULONG BytesToWrite = 0;
    ULONG_PTR BufferAddress = 0;
    NTSTATUS Status;
    ULONG Offset;
    PTRIAGE_DUMP TriageDump = NULL;

    //
    // Setup the triage-dump header.
    //

    if (BufferSize < sizeof (TRIAGE_DUMP) + sizeof (DWORD)) {
        return STATUS_NO_MEMORY;
    }

    TriageDump = (PTRIAGE_DUMP) Buffer;
    RtlZeroMemory (TriageDump, sizeof (*TriageDump));

    //
    // The normal dump header is a DUMP_HEADER.
    //

    TriageDump->SizeOfDump = BufferSize + sizeof(DUMP_HEADER);

    //
    // Adjust the BufferSize so we can write the final status DWORD at the
    // end.
    //

    BufferSize -= sizeof (DWORD);
    RtlZeroMemory (IndexByByte (Buffer, BufferSize), sizeof (DWORD));

    TriageDump->ValidOffset = ( TriageDump->SizeOfDump - sizeof (ULONG) );
    TriageDump->ContextOffset = FIELD_OFFSET (DUMP_HEADER, ContextRecord);
    TriageDump->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER, Exception);
    TriageDump->BrokenDriverOffset = 0;
    TriageDump->ServicePackBuild = ServicePackBuild;
    TriageDump->TriageOptions = TriageOptions;

    Offset = ALIGN_8 (sizeof(DUMP_HEADER) + sizeof (TRIAGE_DUMP));
    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the Mm Offset, if necessary.
    //

    SizeOfSection = ALIGN_8 (MmSizeOfTriageInformation());

    if (Offset + SizeOfSection < BufferSize) {
        TriageDump->MmOffset = Offset;
        Offset += SizeOfSection;
    } else {
        TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
    }

    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the Unloaded Drivers Offset, if necessary.
    //

    SizeOfSection = ALIGN_8 (MmSizeOfUnloadedDriverInformation());

    if (Offset + SizeOfSection < BufferSize) {
        TriageDump->UnloadedDriversOffset = Offset;
        Offset += SizeOfSection;
    } else {
        TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
    }

    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the Prcb Offset, if necessary.
    //

    if (Fields & TRIAGE_DUMP_PRCB) {
        SizeOfSection = ALIGN_8 (sizeof (KPRCB));

        if (Offset + SizeOfSection < BufferSize) {
            TriageDump->PrcbOffset = Offset;
            Offset += SizeOfSection;
        } else {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
        }
    }

    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the Process Offset, if necessary.
    //

    if (Fields & TRIAGE_DUMP_PROCESS) {
        SizeOfSection = ALIGN_8 (sizeof (EPROCESS));

        if (Offset + SizeOfSection < BufferSize) {
            TriageDump->ProcessOffset = Offset;
            Offset += SizeOfSection;
        } else {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
        }
    }

    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the Thread Offset, if necessary.
    //

    if (Fields & TRIAGE_DUMP_THREAD) {
        SizeOfSection = ALIGN_8 (sizeof (ETHREAD));

        if (Offset + SizeOfSection < BufferSize) {
            TriageDump->ThreadOffset = Offset;
            Offset += SizeOfSection;
        } else {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
        }
    }

    ASSERT_ALIGNMENT (Offset, 8);

    //
    // Set the CallStack Offset, if necessary.
    //

    if (Fields & TRIAGE_DUMP_STACK) {

        //
        // If there is a stack, calculate its size.
        //

        //
        // Remember: the callstack grows downward in memory, therefore,
        // Base >= Current = SP = Top > Limit.
        //

        if (Thread->KernelStackResident) {

            ULONG_PTR StackBase;
            ULONG_PTR StackLimit;
            ULONG_PTR StackTop;
            
            StackBase = (ULONG_PTR) Thread->StackBase;
            StackLimit = (ULONG_PTR) Thread->StackLimit;

            //
            // Don't necessarily trust that SP is valid. If it's
            // outside the reasonable range, just copy from the limit.
            //

            if (StackLimit < STACK_POINTER (Context) &&
                STACK_POINTER (Context) <= StackBase) {

                StackTop = STACK_POINTER (Context);
            } else {
                StackTop = (ULONG_PTR) Thread->StackLimit;
            }

            ASSERT (StackLimit <= StackTop && StackTop < StackBase);

            //
            // There is a valid stack. Note that we limit the size of
            // the triage dump stack to MAX_TRIAGE_STACK_SIZE (currently
            // 16 KB).
            //

            SizeOfSection = (ULONG) min (StackBase -  StackTop,
                                         MAX_TRIAGE_STACK_SIZE - 1);

            if (SizeOfSection) {
                if (Offset + SizeOfSection < BufferSize) {
                    TriageDump->CallStackOffset = Offset;
                    TriageDump->SizeOfCallStack = SizeOfSection;
                    TriageDump->TopOfStack = StackTop;
                    Offset += SizeOfSection;
                    Offset = ALIGN_8 (Offset);
                } else {
                    TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
                }
            }

        } else {

            //
            // There is not a valid stack.
            //
        }

    }
    
    ASSERT_ALIGNMENT (Offset, 8);
    
#if defined (_IA64_)

    //
    // The IA64 contains two callstacks. The first is the normal
    // callstack, and the second is a scratch region where
    // the processor can spill registers. It is this latter stack,
    // the backing-store, that we now save.
    //

    if ( Fields & TRIAGE_DUMP_STACK ) {

        ULONG_PTR BStoreBase;
        ULONG_PTR BStoreLimit;

        BStoreBase = (ULONG_PTR) Thread->InitialBStore;
        BStoreLimit = (ULONG_PTR) Thread->BStoreLimit;

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_TRACE,
                    "CRASHDUMP: IA64 BStore: base %p limit %p\n",
                    BStoreBase,
                    BStoreLimit));

        SizeOfSection = (ULONG) (BStoreLimit - BStoreBase);

        //
        // The calculated size had better be less than the maximum size
        // for a BSTORE region.
        //

        ASSERT ( SizeOfSection < KERNEL_LARGE_BSTORE_SIZE );

        if (SizeOfSection) {
            if (Offset + SizeOfSection < BufferSize) {
                TriageDump->ArchitectureSpecific.Ia64.BStoreOffset = Offset;
                TriageDump->ArchitectureSpecific.Ia64.SizeOfBStore = SizeOfSection;
                TriageDump->ArchitectureSpecific.Ia64.LimitOfBStore= BStoreLimit;
                Offset += SizeOfSection;
                Offset = ALIGN_8 (Offset);
            } else {
                TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
            }
        }
    }

#endif

    ASSERT_ALIGNMENT (Offset, 8);
    
    if (Fields & TRIAGE_DUMP_DEBUGGER_DATA) {
        if (Offset + ALIGN_8(sizeof(KdDebuggerDataBlock)) < BufferSize) {
            TriageDump->DebuggerDataOffset = Offset;
            TriageDump->DebuggerDataSize = sizeof(KdDebuggerDataBlock);
            Offset += ALIGN_8(sizeof(KdDebuggerDataBlock));
            Offset = ALIGN_8 (Offset);
        } else {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
        }
    }
    
    ASSERT_ALIGNMENT (Offset, 8);
    
    //
    // Set the Driver List Offset, if necessary.
    //

    Status = IopGetLoadedDriverInfo (&DriverCount, &SizeOfStringData);

    if (NT_SUCCESS (Status) && (Fields & TRIAGE_DUMP_DRIVER_LIST)) {
        SizeOfSection = ALIGN_8 (DriverCount * sizeof (DUMP_DRIVER_ENTRY));

        if (SizeOfSection) {
            if (Offset + SizeOfSection < BufferSize) {
                TriageDump->DriverListOffset = Offset;
                TriageDump->DriverCount = DriverCount;
                Offset += SizeOfSection;
            } else {
                TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
            }
        }

    } else {

        SizeOfSection = 0;
        SizeOfStringData = 0;
    }

    //
    // Set the String Pool offset.
    //

    SizeOfSection = ALIGN_8 (SizeOfStringData +
                        DriverCount * (sizeof (WCHAR) + sizeof (DUMP_STRING)));

    if (SizeOfSection) {
        if (Offset + SizeOfSection < BufferSize) {
            TriageDump->StringPoolOffset = (ULONG)Offset;
            TriageDump->StringPoolSize = SizeOfSection;
            Offset += SizeOfSection;
            Offset = ALIGN_8 (Offset);
        } else {
            TriageDump->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
        }
    }

    ASSERT_ALIGNMENT (Offset, 8);
    
    if (Fields & TRIAGE_DUMP_DATA_BLOCKS) {

#ifdef _IA64_
        volatile KPCR* const Pcr = KeGetPcr();

        //
        // In certain failures there is a switch from
        // the current thread's stack and store to
        // a special stack and store.  The PCR contains
        // stack and store pointers which will be different
        // from the current thread's stack and store pointers
        // so save the extra stack and store if they are.
        //
        
        if ((PVOID)Pcr->InitialBStore != Thread->InitialBStore ||
            (PVOID)Pcr->BStoreLimit != Thread->BStoreLimit) {
            ULONG64 StoreTop, StoreBase;
            ULONG FrameSize;
            ULONG StoreSize;

            StoreTop = Context->RsBSP;
            StoreBase = Pcr->InitialBStore;
            FrameSize = (ULONG)(Context->StIFS & PFS_SIZE_MASK);
            
            // Add in a ULONG64 for every register in the
            // current frame.  While doing so, check for
            // spill entries.
            while (FrameSize-- > 0) {
                StoreTop += sizeof(ULONG64);
                if ((StoreTop & 0x1f8) == 0x1f8) {
                    // Spill will be placed at this address so
                    // account for it.
                    StoreTop += sizeof(ULONG64);
                }
            }

            if (StoreTop < Pcr->InitialBStore ||
                StoreTop >= Pcr->BStoreLimit) {
                // BSP isn't in the PCR store range so
                // just save the whole thing.
                StoreTop = Pcr->BStoreLimit;
            }

            StoreSize = (ULONG)(StoreTop - Pcr->InitialBStore);
            if (StoreSize > MAX_TRIAGE_STACK_SIZE) {
                StoreSize = MAX_TRIAGE_STACK_SIZE;
                StoreBase = StoreTop - StoreSize;
            }
                
            IoAddTriageDumpDataBlock((PVOID)StoreBase, StoreSize);
        }

        if ((PVOID)Pcr->InitialStack != Thread->InitialStack ||
            (PVOID)Pcr->StackLimit != Thread->StackLimit) {
            ULONG64 StackTop;
            ULONG StackSize;
            
            StackTop = STACK_POINTER(Context);
            if (StackTop < Pcr->StackLimit ||
                StackTop >= Pcr->InitialStack) {
                // SP isn't in the PCR stack range so
                // just save the whole thing.
                StackTop = Pcr->StackLimit;
            }

            StackSize = (ULONG)(Pcr->InitialStack - StackTop);
            if (StackSize > MAX_TRIAGE_STACK_SIZE) {
                StackSize = MAX_TRIAGE_STACK_SIZE;
            }
            
            IoAddTriageDumpDataBlock((PVOID)StackTop, StackSize);
        }
#endif
        
        // Add data blocks which might be referred to by
        // the context or other runtime state.
        IopAddRunTimeTriageDataBlocks(Context,
                                      (PVOID*)TriageDump->TopOfStack,
                                      (PVOID*)((PUCHAR)TriageDump->TopOfStack +
                                               TriageDump->SizeOfCallStack),
#ifdef _IA64_
                                      (PVOID*)Thread->InitialBStore,
                                      (PVOID*)((PUCHAR)Thread->InitialBStore +
                                               TriageDump->ArchitectureSpecific.Ia64.SizeOfBStore)
#else
                                      NULL, NULL
#endif
                                      );
        
        // Check which data blocks fit.
        Offset = IopSizeTriageDumpDataBlocks(TriageDump, Offset, BufferSize);
        Offset = ALIGN_8 (Offset);
    }

    ASSERT_ALIGNMENT (Offset, 8);
    
    BytesToWrite = (ULONG)Offset;
    BufferAddress = ((ULONG_PTR) Buffer) - sizeof(DUMP_HEADER);

    //
    // Write the Mm information.
    //

    if (TriageDump->MmOffset) {

        Address = (LPVOID) (BufferAddress + TriageDump->MmOffset);
        MmWriteTriageInformation (Address);
    }

    if (TriageDump->UnloadedDriversOffset) {

        Address = (LPVOID) (BufferAddress + TriageDump->UnloadedDriversOffset);
        MmWriteUnloadedDriverInformation (Address);
    }

    //
    // Write the PRCB.
    //

    if (TriageDump->PrcbOffset) {

        Address = (LPVOID) (BufferAddress + TriageDump->PrcbOffset);
        RtlCopyMemory (Address,
                       KeGetCurrentPrcb (),
                       sizeof (KPRCB)
                       );
    }

    //
    // Write the EPROCESS.
    //

    if (TriageDump->ProcessOffset) {

        Address = (LPVOID) (BufferAddress + TriageDump->ProcessOffset);
        RtlCopyMemory (Address,
                       Thread->ApcState.Process,
                       sizeof (EPROCESS)
                       );
    }

    //
    // Write the ETHREAD.
    //

    if (TriageDump->ThreadOffset) {

        Address = (LPVOID) (BufferAddress + TriageDump->ThreadOffset);
        RtlCopyMemory (Address,
                       Thread,
                       sizeof (ETHREAD));
    }

    //
    // Write the Call Stack.
    //

    if (TriageDump->CallStackOffset) {

        PVOID StackTop;
        
        ASSERT (TriageDump->SizeOfCallStack != 0);

        StackTop = (PVOID)TriageDump->TopOfStack;

        ASSERT (IopIsAddressRangeValid (StackTop, TriageDump->SizeOfCallStack));
        Address = (LPVOID) (BufferAddress + TriageDump->CallStackOffset);
        RtlCopyMemory (Address,
                       StackTop,
                       TriageDump->SizeOfCallStack
                       );
    }

#if defined (_IA64_)

    //
    // Write the IA64 BStore.
    //

    if ( TriageDump->ArchitectureSpecific.Ia64.BStoreOffset ) {

        ASSERT (IopIsAddressRangeValid (Thread->InitialBStore,
                                        TriageDump->ArchitectureSpecific.Ia64.SizeOfBStore));
        Address = (PVOID) (BufferAddress + TriageDump->ArchitectureSpecific.Ia64.BStoreOffset);
        RtlCopyMemory (Address,
                       Thread->InitialBStore,
                       TriageDump->ArchitectureSpecific.Ia64.SizeOfBStore
                       );
    }

#endif // IA64

    //
    // Write the debugger data block.
    //
    
    if (TriageDump->DebuggerDataOffset) {
        Address = (LPVOID) (BufferAddress + TriageDump->DebuggerDataOffset);
        
        RtlCopyMemory (Address,
                       &KdDebuggerDataBlock,
                       sizeof(KdDebuggerDataBlock)
                       );
    }
    
    //
    // Write the Driver List.
    //

    if (TriageDump->DriverListOffset &&
        TriageDump->StringPoolOffset) {

        Status = IopWriteDriverList (BufferAddress,
                                     BufferSize,
                                     TriageDump->DriverListOffset,
                                     TriageDump->StringPoolOffset
                                     );

        if (!NT_SUCCESS (Status)) {
            TriageDump->DriverListOffset = 0;
        }
    }

    //
    // Write the data blocks.
    //

    IopWriteTriageDumpDataBlocks(TriageDump, (PUCHAR)BufferAddress);
    
    
    ASSERT (BytesToWrite < BufferSize);
    ASSERT (ALIGN_UP (BytesToWrite, PAGE_SIZE) < BufferSize);

    //
    // Write the valid status to the end of the dump.
    //

    *((ULONG *)IndexByByte (Buffer, BufferSize)) = TRIAGE_DUMP_VALID ;

    //
    // Re-adjust the buffer size.
    //

    BufferSize += sizeof (DWORD);

    //
    // NOTE: This routine writes the entire buffer, even if it is not
    // all required.
    //

    Status = IopWriteToDisk (Buffer,
                             BufferSize,
                             DriverWriteRoutine,
                             Mcb,
                             Mdl,
                             DriverTransferSize,
                             KbDumpIoBody
                             );

    return Status;
}



NTSTATUS
IopWritePageToDisk(
    IN PDUMP_DRIVER_WRITE DriverWrite,
    IN OUT PLARGE_INTEGER * McbBuffer,
    IN OUT ULONG DriverTransferSize,
    IN PFN_NUMBER PageFrameIndex
    )

/*++

Routine Description:

    Write the page described by PageFrameIndex to the disk/file (DriverWrite,
    McbBuffer) and update the MCB buffer to reflect the new position in the
    file.

Arguments:

    DriverWrite - The driver write routine.

    McbBuffer - A pointer to the MCB array. This array is terminated by
            a zero-length MCB entry. On success, this pointer is updated
            to reflect the new position in the MCB array.

            NB: MCB[0] is the size and MCB[1] is the offset.

    DriverTransferSize - The maximum transfer size for this driver.

    PageFrameIndex - The page to be written.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFN_NUMBER MdlHack [ (sizeof (MDL) / sizeof (PFN_NUMBER)) + 1];
    PPFN_NUMBER PfnArray;
    PLARGE_INTEGER Mcb;
    ULONG ByteCount;
    ULONG ByteOffset;
    ULONG BytesToWrite;
    PMDL TempMdl;


    ASSERT ( DriverWrite );
    ASSERT ( McbBuffer );
    ASSERT ( DriverTransferSize && DriverTransferSize >= PAGE_SIZE );

    KdCheckForDebugBreak();
    
    //
    // Initialization
    //

    TempMdl = (PMDL) &MdlHack[0];
    Mcb = *McbBuffer;
    BytesToWrite = PAGE_SIZE;


    //
    // Initialze the MDL to point to this page.
    //

    MmInitializeMdl (TempMdl, NULL, PAGE_SIZE);

//    TempMdl->StartVa = (PVOID) (PageFrameIndex << PAGE_SHIFT);
    PfnArray = MmGetMdlPfnArray ( TempMdl );
    PfnArray[0] = PageFrameIndex;

    //
    // We loop for the cases when the space remaining in this block (Mcb [0])
    // is less than one page. Generally the Mcb will be large enough to hold
    // the entire page and this loop will only be executed once. When Mcb[0]
    // is less than a page, we will write the first part of the page to this
    // Mcb then increment the Mcb and write the remaining part to the next
    // page.
    //

    ByteOffset = 0;

    while ( BytesToWrite ) {

        ASSERT ( Mcb[0].QuadPart != 0 );

        ByteCount = (ULONG) min3 ((LONGLONG) BytesToWrite,
                                  (LONGLONG) DriverTransferSize,
                                  Mcb[0].QuadPart
                                  );


        ASSERT ( ByteCount != 0 );

        //
        // Update the MDL byte count and byte offset.
        //

        TempMdl->ByteCount = ByteCount;
        TempMdl->ByteOffset = ByteOffset;

        //
        // Map the MDL. The flags are updated to show that MappedSystemVa
        // is valid (which should probably be done in MmMapMemoryDumpMdl).
        //

        MmMapMemoryDumpMdl ( TempMdl );
        TempMdl->MdlFlags |= ( MDL_PAGES_LOCKED | MDL_MAPPED_TO_SYSTEM_VA );
        TempMdl->StartVa = PAGE_ALIGN (TempMdl->MappedSystemVa);

        IopInvokeDumpIoCallbacks((PUCHAR)TempMdl->StartVa + ByteOffset,
                                 ByteCount, KbDumpIoBody);
        
        //
        // Write the bufffer.
        //

        Status = DriverWrite ( &Mcb[1], TempMdl );


        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        BytesToWrite -= ByteCount;
        ByteOffset += ByteCount;

        Mcb[0].QuadPart -= ByteCount;
        Mcb[1].QuadPart += ByteCount;

        //
        // If there is no more room for this MCB, go to the next one.
        //

        if ( Mcb[0].QuadPart == 0 ) {

            Mcb += 2;

            //
            // We have filled up all the space in the paging file.
            //

            if ( Mcb[0].QuadPart == 0) {
                KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                            CRASHDUMP_ERROR,
                            "CRASHDUMP: Pagefile is full.\n"));
                return STATUS_END_OF_FILE;
            }
        }

    }

    *McbBuffer = Mcb;

    return Status;
}


NTSTATUS
IopWriteSummaryDump(
    IN PRTL_BITMAP PageMap,
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN PANSI_STRING ProgressMessage,
    IN PUCHAR MessageBuffer,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT ULONG DriverTransferSize
    )

/*++

Routine Description:

    Write a summary dump to the disk.

Arguments:


    PageMap - A bitmap of the pages that need to be written.

    DriverWriteRoutine - The driver's write routine.

    ProgressMessage - The "Percent Complete" message.

    MessageBuffer - Not used. Must be NULL.

    Mcb - Message Control Block where the data is to be written.

    DriverTransferSize - The maximum transfer size for the driver.

Return Values:

    NTSTATUS code.

--*/

{
    PFN_NUMBER PageFrameIndex;
    NTSTATUS Status;

    ULONG WriteCount;
    ULONG MaxWriteCount;
    ULONG Step;

#if !DBG
    UNREFERENCED_PARAMETER (MessageBuffer);
#endif

    ASSERT ( DriverWriteRoutine != NULL );
    ASSERT ( Mcb != NULL );
    ASSERT ( DriverTransferSize != 0 );
    ASSERT ( MessageBuffer == NULL );


    MaxWriteCount = RtlNumberOfSetBits ( PageMap );
    ASSERT (MaxWriteCount != 0);
    Step = MaxWriteCount / 100;

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: Summary Dump\n"
                "           Writing %x pages to disk from a total of %x\n",
                  MaxWriteCount,
                  PageMap->SizeOfBitMap
                  ));
    //
    // Loop over all pages in the system and write those that are set
    // in the bitmap.
    //

    WriteCount = 0;
    for ( PageFrameIndex = 0;
          PageFrameIndex < PageMap->SizeOfBitMap;
          PageFrameIndex++) {


        //
        // If this page needs to be included in the dump file.
        //

        if ( RtlCheckBit (PageMap, PageFrameIndex) ) {

            if (++WriteCount % Step == 0) {

                //
                // Update the progress percentage.
                //

                IopDisplayString ("%Z: %3d\r",
                                  ProgressMessage,
                                  (WriteCount * 100) / MaxWriteCount
                                  );
            }

            ASSERT ( WriteCount <= MaxWriteCount );

            //
            // Write the page to disk.
            //

            KdCheckForDebugBreak();
            
            Status = IopWritePageToDisk (
                            DriverWriteRoutine,
                            Mcb,
                            DriverTransferSize,
                            PageFrameIndex
                            );

            if (!NT_SUCCESS (Status)) {

                return STATUS_UNSUCCESSFUL;
            }
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
IopInitializeSummaryDump(
    IN OUT PMEMORY_DUMP MemoryDump,
    IN PDUMP_CONTROL_BLOCK DumpControlBlock
    )
/*++

Routine Description:

    This routine creates a summary dump header. In particular it initializes
    a bitmap that contains a map of kernel memory.

Arguments:

    MemoryDump - The memory dump.

    DumpControlBlock - A pointer to the dump control block.

Return Value:

    Non-NULL - A pointer to the summary dump header

    NULL - Error

--*/
{
    ULONG ActualPages;

    ASSERT ( MemoryDump != NULL );
    ASSERT ( DumpControlBlock != NULL );

    //
    // Fill the header with signatures.
    //

    RtlFillMemoryUlong( &MemoryDump->Summary,
                        sizeof (SUMMARY_DUMP),
                        DUMP_SUMMARY_SIGNATURE);

    //
    // Set the size and valid signature.
    //

    //
    // ISSUE - 2000/02/07 - math: Review for Win64
    //
    // Computing the bitmap size is probably wrong for 64 bit.
    //

    MemoryDump->Summary.BitmapSize =
        (ULONG)( MmPhysicalMemoryBlock->Run[MmPhysicalMemoryBlock->NumberOfRuns-1].BasePage  +
        MmPhysicalMemoryBlock->Run[MmPhysicalMemoryBlock->NumberOfRuns-1].PageCount );

    MemoryDump->Summary.ValidDump = DUMP_SUMMARY_VALID;

    //
    // Construct the kernel memory bitmap.
    //

    //
    // ISSUE - 2000/02/07 - math: Review for Win64
    //
    // Actual will probably need to be a 64-bit value for Win64.
    //

    ActualPages = IopCreateSummaryDump (MemoryDump);

    KdPrintEx ((DPFLTR_CRASHDUMP_ID, CRASHDUMP_TRACE,
                "CRASHDUMP: Kernel Pages = %x\n",
                ActualPages ));

    if (ActualPages == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of physical pages in the summary dump
    //

    MemoryDump->Summary.Pages = ActualPages;
    MemoryDump->Summary.HeaderSize = DumpControlBlock->HeaderSize;

    return STATUS_SUCCESS;
}



NTSTATUS
IopWriteSummaryHeader(
    IN PSUMMARY_DUMP        SummaryHeader,
    IN PDUMP_DRIVER_WRITE   WriteRoutine,
    IN OUT PLARGE_INTEGER * McbBuffer,
    IN OUT PMDL             Mdl,
    IN ULONG                WriteSize,
    IN ULONG                Length
    )
/*++

Routine Description:

    Write the summary dump header to the dump file.

Arguments:

    SummaryHeader - pointer to the summary dump bitmap

    WriteRoutine - dump driver write function

    McbBuffer - Pointer to the dump file MCB array.

    Mdl - Pointer to an MDL

    WriteSize - the max transfer size for the dump driver

    Length - the length of this transfer

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG BytesRemaining;
    ULONG_PTR MemoryAddress;
    ULONG ByteOffset;
    ULONG ByteCount;
    PLARGE_INTEGER Mcb;

    Mcb = *McbBuffer;

    BytesRemaining = Length;
    MemoryAddress = (ULONG_PTR) SummaryHeader;

    IopInvokeDumpIoCallbacks(SummaryHeader, Length, KbDumpIoBody);
        
    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: Writing SUMMARY dump header to disk\n" ));


    while ( BytesRemaining ) {

        ByteOffset = BYTE_OFFSET ( MemoryAddress );

        //
        // See if the number of bytes to write is greator than the crash
        // drives max transfer.
        //

        if ( BytesRemaining <= WriteSize) {
            ByteCount = BytesRemaining;
        } else {
            ByteCount = WriteSize;
        }

        //
        // If the byteCount is greater than the remaining mcb then correct it.
        //

        if ( ByteCount > Mcb[0].QuadPart) {
            ByteCount = Mcb[0].LowPart;
        }

        Mdl->ByteCount      = ByteCount;
        Mdl->ByteOffset     = ByteOffset;
        Mdl->MappedSystemVa = (PVOID) MemoryAddress;

        //
        // Get the actual physical frame and create an mdl.
        //

        IopMapVirtualToPhysicalMdl ( Mdl, MemoryAddress, ByteCount );

        //
        // Write to disk.
        //

        Status =  WriteRoutine ( &Mcb[1], Mdl );

        if ( !NT_SUCCESS (Status)) {
            return Status;
        }

        //
        // Adjust bytes remaining.
        //

        BytesRemaining -= ByteCount;
        MemoryAddress += ByteCount;

        Mcb[0].QuadPart = Mcb[0].QuadPart - ByteCount;
        Mcb[1].QuadPart = Mcb[1].QuadPart + ByteCount;

        if (Mcb[0].QuadPart == 0) {
            Mcb += 2;
        }

        if (Mcb[0].QuadPart == 0) {
            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Pagefile is full.\n"));
            return STATUS_END_OF_FILE;
        }
    }

    *McbBuffer = Mcb;
    return STATUS_SUCCESS;
}



NTSTATUS
IopWriteToDisk(
    IN PVOID Buffer,
    IN ULONG WriteLength,
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN OUT PLARGE_INTEGER * McbBuffer,
    IN OUT PMDL Mdl,
    IN ULONG DriverTransferSize,
    IN KBUGCHECK_DUMP_IO_TYPE DataType
    )
/*++

Routine Description:

    Write the summary dump header to the dump file.

Arguments:

    Buffer - Pointer to the buffer to write.

    WriteLength - The length of this transfer.

    DriverWriteRoutine - Dump driver write function.

    McbBuffer - Pointer to the dump file Mapped Control Block.

    Mdl - Pointer to an MDL.

    DriverTransferSize - The max transfer size for the dump driver.

    DataType - Type of data being written, for I/O callbacks.

Return Value:


--*/
{
    ULONG BytesRemaining;
    ULONG_PTR MemoryAddress;
    ULONG ByteOffset;
    ULONG ByteCount;
    PLARGE_INTEGER Mcb;

    ASSERT (Buffer);
    ASSERT (WriteLength);
    ASSERT (DriverWriteRoutine);
    ASSERT (McbBuffer && *McbBuffer);
    ASSERT (Mdl);
    ASSERT (DriverTransferSize >= IO_DUMP_MINIMUM_TRANSFER_SIZE &&
            DriverTransferSize <= IO_DUMP_MAXIMUM_TRANSFER_SIZE);


    IopInvokeDumpIoCallbacks(Buffer, WriteLength, DataType);

    Mcb = *McbBuffer;
    BytesRemaining = WriteLength;
    MemoryAddress = (ULONG_PTR) Buffer;

    while ( BytesRemaining ) {

        ASSERT (IopDumpControlBlock->FileDescriptorArray <= Mcb &&
                (LPBYTE) Mcb < (LPBYTE) IopDumpControlBlock->FileDescriptorArray +
                               IopDumpControlBlock->FileDescriptorSize
                );

        if (Mcb[0].QuadPart == 0) {
            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Pagefile is full.\n"));
            return STATUS_END_OF_FILE;
        }

        ByteOffset = BYTE_OFFSET ( MemoryAddress );

        //
        // See if the number of bytes to write is greator than the crash
        // drives max transfer.
        //

        ByteCount = min ( BytesRemaining, DriverTransferSize );

        //
        // If the byteCount is greater than the remaining mcb then correct it.
        //

        if (ByteCount > Mcb[0].QuadPart) {
            ByteCount = Mcb[0].LowPart;
        }

        Mdl->ByteCount = ByteCount;
        Mdl->ByteOffset = ByteOffset;
        Mdl->MappedSystemVa = (PVOID) MemoryAddress;

        //
        // Get the actual physical frame and create an mdl.
        //

        IopMapVirtualToPhysicalMdl(Mdl, MemoryAddress, ByteCount);

        KdCheckForDebugBreak();

        if (!NT_SUCCESS( DriverWriteRoutine ( &Mcb[1], Mdl ) )) {

            //
            // We are in deep trouble if we failed the write.
            //

            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Failed to write Mcb = %p, Mdl = %p to disk\n",
                        &Mcb[1],
                        Mdl
                        ));

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Adjust bytes remaining.
        //

        ASSERT ( BytesRemaining >= ByteCount );
        ASSERT ( ByteCount != 0 );

        BytesRemaining -= ByteCount;
        MemoryAddress  += ByteCount;

        Mcb[0].QuadPart -= ByteCount;
        Mcb[1].QuadPart += ByteCount;

        if (Mcb[0].QuadPart == 0) {
            Mcb += 2;
        }
    }

    *McbBuffer = Mcb;
    return STATUS_SUCCESS;
}


VOID
IopMapVirtualToPhysicalMdl(
    IN OUT PMDL Mdl,
    IN ULONG_PTR MemoryAddress,
    IN ULONG Length
    )
{
    ULONG Pages;
    PPFN_NUMBER  Pfn;
    PCHAR BaseVa;
    PHYSICAL_ADDRESS PhysicalAddress;

    //
    // ISSUE - 2000/02/07 - math: Review for Win64
    //
    // This whole function needs to be revisited for Win64.
    // There are a ton of tacit assumptions here about the
    // size of a PFN.
    //

    //
    // Begin by determining the base physical page of the start of the address
    // range and filling in the MDL appropriately.
    //

    Mdl->StartVa = PAGE_ALIGN ( MemoryAddress );
    Mdl->ByteOffset = BYTE_OFFSET ( MemoryAddress );
    Mdl->ByteCount = Length;
    Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;

    //
    // Compute the number of pages spanned
    //

    Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES( MemoryAddress, Length );
    Pfn = MmGetMdlPfnArray ( Mdl );

    //
    // Map all of the pages for this transfer until there are no more remaining
    // to be mapped.
    //

    BaseVa = PAGE_ALIGN ( MemoryAddress );

    while ( Pages ) {
        PhysicalAddress = MmGetPhysicalAddress ( BaseVa );
        *Pfn++ = (PFN_NUMBER)(PhysicalAddress.QuadPart >> PAGE_SHIFT);
        BaseVa += PAGE_SIZE;
        Pages--;
    }

    //
    // All of the PFNs for the address range have been filled in so map the
    // physical memory into virtual address space using crash dump PTE.
    //

//    MmMapMemoryDumpMdl( pMdl );
}



ULONG
IopCreateSummaryDump (
    IN PMEMORY_DUMP MemoryDump
    )
/*++

Routine Description:

    This routine determines the kernel memory and data structures to include
    in the summary memory dump.

    NOTE: This function uses MmGetPhysicalAddress. MmGetPhysicalAddress does
    not acquire any locks. It uses a set of macros for translation.


Arguments:

    MemoryDump - The memory dump.

Return Value:

    Status

--*/
{
    PRTL_BITMAP BitMap;
    LARGE_INTEGER DumpFileSize;
    ULONG PagesUsed;
    PSUMMARY_DUMP Summary;
    MM_KERNEL_DUMP_CONTEXT Context;

    //
    // Validation
    //

    ASSERT (MemoryDump != NULL);

    //
    // Initialize Bit Map, set the size and buffer address.
    //

    Summary = &MemoryDump->Summary;
    BitMap = (PRTL_BITMAP) &Summary->Bitmap;
    BitMap->SizeOfBitMap = Summary->BitmapSize; // Why??
    BitMap->Buffer = Summary->Bitmap.Buffer;

    //
    // Clear all bits
    //

    RtlClearAllBits (BitMap);

    //
    // Have MM initialize the kernel memory to dump
    //

    Context.Context = Summary;
    Context.SetDumpRange = IoSetDumpRange;
    Context.FreeDumpRange = IoFreeDumpRange;

    MmGetKernelDumpRange (&Context);

    PagesUsed = RtlNumberOfSetBits ( BitMap );

    //
    // See If we have room to Include user va for the current process
    //

    DumpFileSize = MemoryDump->Header.RequiredDumpSpace;
    DumpFileSize.QuadPart -= IopDumpControlBlock->HeaderSize;

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "CRASHDUMP: Kernel Dump, Header = %p\n",
                Summary
                ));

    KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                CRASHDUMP_TRACE,
                "           BitMapSize:    %x\n"
                "           Pages:         %x\n"
                "           BitMapBuffer:  %p\n",
                Summary->BitmapSize,
                PagesUsed,
                BitMap->Buffer
                ));

    return PagesUsed;

}

NTSTATUS
IopInvokeSecondaryDumpDataCallbacks(
    IN PDUMP_DRIVER_WRITE DriverWriteRoutine,
    IN OUT PLARGE_INTEGER * Mcb,
    IN OUT PMDL Mdl,
    IN ULONG DriverTransferSize,
    IN BYTE* Buffer,
    IN ULONG BufferSize,
    IN ULONG MaxTotal,
    IN ULONG MaxPerCallback,
    OUT OPTIONAL PULONG SpaceNeeded
    )

/*++

Routine Description:

    Walk the list of dump data callbacks, invoking them
    and writing their data out.

Arguments:

    DriverWriteRoutine - The write routine for the driver.

    Mcb - Message Control Block where the data is to be written.

    Mdl - Address of the MDL to be filled in.

    DriverTransferSize - The maximum transfer size for the driver.

    Buffer - The buffer to use as a scratch buffer.

    BufferSize - Size of Buffer.

    MaxTotal - Maximum amount of data allowed overall.

    MaxPerCallback - Maximum amount of data allowed per callback.

    SpaceNeeded - Amount of data used by all callbacks.  If this
                  argument is present then no I/O is done, just
                  accumulation of data sizes.
    
Return Values:

    STATUS_SUCCESS - On success.

    NTSTATUS - Otherwise.

--*/

{
    PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    ULONG Index;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Source;
    PDUMP_BLOB_FILE_HEADER BlobFileHdr;
    PDUMP_BLOB_HEADER BlobHdr;

    // Assert that basic structures preserve 8-byte alignment.
    C_ASSERT((sizeof(DUMP_BLOB_FILE_HEADER) & 7) == 0);
    C_ASSERT((sizeof(DUMP_BLOB_HEADER) & 7) == 0);

    if (ARGUMENT_PRESENT(SpaceNeeded)) {
        *SpaceNeeded = 0;
    }
    
    //
    // If the caller isn't allowing a reasonable amount of
    // data don't even bother to look.
    //

    if (MaxPerCallback < PAGE_SIZE || MaxTotal < MaxPerCallback) {
        return STATUS_SUCCESS;
    }
    
    //
    // If the bug check callback listhead is not initialized, then the
    // bug check has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckReasonCallbackListHead;
    if (ListHead->Flink == NULL || ListHead->Blink == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // The current dump I/O routines only handle
    // page-granular I/O so everything must be
    // packed into a page for a single write.
    //
    // Start out with an overall file header followed
    // by a blob header.  After the first blob is written
    // the blob header will be moved down to the head
    // of the buffer.
    //
    
    BlobFileHdr = (PDUMP_BLOB_FILE_HEADER)Buffer;
    BlobHdr = (PDUMP_BLOB_HEADER)(BlobFileHdr + 1);
    
    //
    // Scan the bug check callback list.
    //

    LastEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {

        //
        // If no more dump data is allowed we're done.
        //

        if (!MaxTotal) {
            break;
        }
                
        //
        // The next entry address must be aligned properly, the
        // callback record must be readable, and the callback record
        // must have back link to the last entry.
        //

        if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
            return STATUS_DATATYPE_MISALIGNMENT;
        }

        CallbackRecord = CONTAINING_RECORD(NextEntry,
                                           KBUGCHECK_REASON_CALLBACK_RECORD,
                                           Entry);

        Source = (PUCHAR)CallbackRecord;
        for (Index = 0; Index < sizeof(*CallbackRecord); Index += 1) {
            if (MmIsAddressValid((PVOID)Source) == FALSE) {
                return STATUS_PARTIAL_COPY;
            }
            
            Source += 1;
        }

        if (CallbackRecord->Entry.Blink != LastEntry) {
            return STATUS_INVALID_PARAMETER;
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Flink;

        //
        // If the callback record has a state of inserted and the
        // computed checksum matches the callback record checksum,
        // then call the specified bug check callback routine.
        //

        Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
        Checksum += (ULONG_PTR)CallbackRecord->Reason;
        Checksum += (ULONG_PTR)CallbackRecord->Component;
        if ((CallbackRecord->State != BufferInserted) ||
            (CallbackRecord->Checksum != Checksum) ||
            (CallbackRecord->Reason != KbCallbackSecondaryDumpData) ||
            MmIsAddressValid((PVOID)(ULONG_PTR)CallbackRecord->
                             CallbackRoutine) == FALSE) {
            continue;
        }

        //
        // Call the specified bug check callback routine and
        // handle any exceptions that occur.
        //

        if (!ARGUMENT_PRESENT(SpaceNeeded)) {
            CallbackRecord->State = BufferStarted;
        }
            
        try {
            KBUGCHECK_SECONDARY_DUMP_DATA CbArgument;
            NTSTATUS Status;
            ULONG BufferAvail;

            // Clean the buffer before letting
            // the callback have it.
            RtlZeroMemory(Buffer, BufferSize);

            // Start the callback's buffer after the blob header.
            CbArgument.InBuffer = (PVOID)(BlobHdr + 1);
            BufferAvail = BufferSize - (ULONG)
                ((ULONG_PTR)CbArgument.InBuffer - (ULONG_PTR)Buffer);
            CbArgument.InBufferLength = BufferAvail;
            CbArgument.MaximumAllowed = MaxPerCallback;
            RtlZeroMemory(&CbArgument.Guid, sizeof(CbArgument.Guid));
            CbArgument.OutBuffer = ARGUMENT_PRESENT(SpaceNeeded) ?
                NULL : CbArgument.InBuffer;
            CbArgument.OutBufferLength = 0;
            
            (CallbackRecord->CallbackRoutine)(KbCallbackSecondaryDumpData,
                                              CallbackRecord,
                                              &CbArgument,
                                              sizeof(CbArgument));

            //
            // If no data was used there's nothing to write.
            //

            if (!CbArgument.OutBuffer || !CbArgument.OutBufferLength) {
                // Set this state even when sizing as
                // there's no need to call again.
                CallbackRecord->State = BufferFinished;
                __leave;
            }
                
            //
            // The callback may have used the buffer given or
            // it may have returned its own buffer.  If it
            // used the buffer given it must be page aligned.
            //

            if ((PBYTE)CbArgument.OutBuffer >= Buffer &&
                (PBYTE)CbArgument.OutBuffer < Buffer + BufferSize) {
                
                if (CbArgument.OutBuffer != (PVOID)(BlobHdr + 1) ||
                    CbArgument.OutBufferLength > BufferAvail) {
                    // If too much or the wrong data was used memory has
                    // been trashed.  Exit and hope the system still runs.
                    return STATUS_INVALID_PARAMETER;
                }

                // The header buffer was used so we can write
                // the data along with the header.
                BlobHdr->PrePad = 0;
                BlobHdr->PostPad = BufferAvail - CbArgument.OutBufferLength;
                
            } else {

                if (CbArgument.OutBufferLength > MaxPerCallback ||
                    BYTE_OFFSET(CbArgument.OutBuffer) ||
                    !IopIsAddressRangeValid(CbArgument.OutBuffer,
                                            CbArgument.OutBufferLength)) {
                    return STATUS_INVALID_PARAMETER;
                }

                // The header buffer is separate from the data
                // buffer so prepad and postpad to a page boundary.
                BlobHdr->PrePad = BufferAvail;
                BlobHdr->PostPad =
                    (ULONG)(ROUND_TO_PAGES(CbArgument.OutBufferLength) -
                            CbArgument.OutBufferLength);
            }
                    
            //
            // Write the page containing the headers.
            //

            if ((PBYTE)BlobHdr > Buffer) {
                BlobFileHdr->Signature1 = DUMP_BLOB_SIGNATURE1;
                BlobFileHdr->Signature2 = DUMP_BLOB_SIGNATURE2;
                BlobFileHdr->HeaderSize = sizeof(*BlobFileHdr);
                BlobFileHdr->BuildNumber = NtBuildNumber;
            }

            BlobHdr->HeaderSize = sizeof(*BlobHdr);
            BlobHdr->Tag = CbArgument.Guid;
            BlobHdr->DataSize = CbArgument.OutBufferLength;

            if (ARGUMENT_PRESENT(SpaceNeeded)) {
                (*SpaceNeeded) += BufferSize;
            } else {
                Status = IopWriteToDisk(Buffer, BufferSize,
                                        DriverWriteRoutine,
                                        Mcb, Mdl, DriverTransferSize,
                                        KbDumpIoSecondaryData);
                if (!NT_SUCCESS(Status)) {
                    return Status;
                }
            }

            //
            // Write any extra data buffer pages.
            //

            if (CbArgument.OutBuffer != (PVOID)(BlobHdr + 1)) {
                if (ARGUMENT_PRESENT(SpaceNeeded)) {
                    (*SpaceNeeded) += (ULONG)
                        ROUND_TO_PAGES(CbArgument.OutBufferLength);
                } else {
                    Status = IopWriteToDisk(CbArgument.OutBuffer,
                                            (ULONG)ROUND_TO_PAGES(CbArgument.OutBufferLength),
                                            DriverWriteRoutine,
                                            Mcb, Mdl, DriverTransferSize,
                                            KbDumpIoSecondaryData);
                    if (!NT_SUCCESS(Status)) {
                        return Status;
                    }
                }
            }

            MaxTotal -= (ULONG)ROUND_TO_PAGES(CbArgument.OutBufferLength);
            
            // We've written at least one blob so we don't
            // need the file header any more.
            BlobHdr = (PDUMP_BLOB_HEADER)Buffer;
            
            if (!ARGUMENT_PRESENT(SpaceNeeded)) {
                CallbackRecord->State = BufferFinished;
            }
            
        } except(EXCEPTION_EXECUTE_HANDLER) {
            // Set this state even when sizing as
            // we don't want to call a bad callback again.
            CallbackRecord->State = BufferIncomplete;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopInvokeDumpIoCallbacks(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN KBUGCHECK_DUMP_IO_TYPE Type
    )

/*++

Routine Description:

    Walk the list of dump I/O callbacks and invoke them.

Arguments:

    Buffer - The buffer of data being written.

    BufferLength - Size of Buffer.

    Type - Type of data being written.

Return Values:

    STATUS_SUCCESS - On success.

    NTSTATUS - Otherwise.

--*/

{
    PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    ULONG Index;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Source;

    //
    // If the bug check callback listhead is not initialized, then the
    // bug check has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckReasonCallbackListHead;
    if (ListHead->Flink == NULL || ListHead->Blink == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // Scan the bug check callback list.
    //

    LastEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {

        //
        // The next entry address must be aligned properly, the
        // callback record must be readable, and the callback record
        // must have back link to the last entry.
        //

        if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
            return STATUS_DATATYPE_MISALIGNMENT;
        }

        CallbackRecord = CONTAINING_RECORD(NextEntry,
                                           KBUGCHECK_REASON_CALLBACK_RECORD,
                                           Entry);

        Source = (PUCHAR)CallbackRecord;
        for (Index = 0; Index < sizeof(*CallbackRecord); Index += 1) {
            if (MmIsAddressValid((PVOID)Source) == FALSE) {
                return STATUS_PARTIAL_COPY;
            }
            
            Source += 1;
        }

        if (CallbackRecord->Entry.Blink != LastEntry) {
            return STATUS_INVALID_PARAMETER;
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Flink;

        //
        // If the callback record has a state of inserted and the
        // computed checksum matches the callback record checksum,
        // then call the specified bug check callback routine.
        //

        Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
        Checksum += (ULONG_PTR)CallbackRecord->Reason;
        Checksum += (ULONG_PTR)CallbackRecord->Component;
        if ((CallbackRecord->State != BufferInserted) ||
            (CallbackRecord->Checksum != Checksum) ||
            (CallbackRecord->Reason != KbCallbackDumpIo) ||
            MmIsAddressValid((PVOID)(ULONG_PTR)CallbackRecord->
                             CallbackRoutine) == FALSE) {
            continue;
        }

        //
        // Call the specified bug check callback routine and
        // handle any exceptions that occur.
        //

        try {
            KBUGCHECK_DUMP_IO CbArgument;

            // Currently we aren't allowing arbitrary I/O
            // so always use the special sequential I/O offset.
            CbArgument.Offset = (ULONG64)-1;
            CbArgument.Buffer = Buffer;
            CbArgument.BufferLength = BufferLength;
            CbArgument.Type = Type;
            
            (CallbackRecord->CallbackRoutine)(KbCallbackDumpIo,
                                              CallbackRecord,
                                              &CbArgument,
                                              sizeof(CbArgument));

            if (Type == KbDumpIoComplete) {
                CallbackRecord->State = BufferFinished;
            }
            
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CallbackRecord->State = BufferIncomplete;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
IopCompleteDumpInitialization(
    IN HANDLE     FileHandle
    )

/*++

Routine Description:

    This routine is invoked after the dump file is created.

    The purpose is to obtain the retrieval pointers so that they can then be
    used later to write the dump. The last step is to checksum the
    IopDumpControlBlock.

    Fields in the IopDumpControlBlock are updated if necessary and the
    IopDumpControlBlockChecksum is initialized.

    This is the final step in dump initialization.

Arguments:

    FileHandle - Handle to the dump file just created.

Return Value:

    STATUS_SUCCESS - Indicates success.

    Other NTSTATUS - Failure.

--*/

{
    NTSTATUS Status;
    NTSTATUS ErrorToLog;
    ULONG i;
    LARGE_INTEGER RequestedFileSize;
    PLARGE_INTEGER mcb;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardFileInfo;
    ULONG MaxSecondaryData;
    ULONG MaxSecondaryCbData;

    Status = STATUS_UNSUCCESSFUL;
    ErrorToLog = STATUS_SUCCESS;    // No error
    FileObject = NULL;
    DeviceObject = NULL;

    Status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &FileObject,
                                        NULL
                                        );

    if ( !NT_SUCCESS (Status) ) {
        ASSERT (FALSE);
        goto Cleanup;
    }


    DeviceObject = FileObject->DeviceObject;

    //
    // If this device object represents the boot partition then query
    // the retrieval pointers for the file.
    //

    if ( !(DeviceObject->Flags & DO_SYSTEM_BOOT_PARTITION) ) {

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Cannot dump to pagefile on non-system partition.\n"
                    "           DO = %p\n",
                    DeviceObject));
        goto Cleanup;
    }

    Status = ZwQueryInformationFile(
                                FileHandle,
                                &IoStatusBlock,
                                &StandardFileInfo,
                                sizeof (StandardFileInfo),
                                FileStandardInformation
                                );

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject( &FileObject->Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL
                                        );
        Status = IoStatusBlock.Status;
    }

    if ( !NT_SUCCESS (Status) ) {
        goto Cleanup;
    }

    //
    // Ask for as much space as needed for the basic dump
    // plus extra space for secondary dump data.
    //
    
    RequestedFileSize = IopDumpControlBlock->DumpFileSize;

    IopGetSecondaryDumpDataLimits(IopDumpControlBlock->Flags,
                                  &MaxSecondaryData, &MaxSecondaryCbData);

    if ((ULONG64)-1 - RequestedFileSize.QuadPart < MaxSecondaryData) {
        RequestedFileSize.QuadPart = (ULONG64)-1;
    } else {
        RequestedFileSize.QuadPart += MaxSecondaryData;
    }
    
    //
    // Do not ask for more space than is in the pagefile.
    //

    if (RequestedFileSize.QuadPart > StandardFileInfo.EndOfFile.QuadPart) {
        RequestedFileSize = StandardFileInfo.EndOfFile;
    }

    Status = ZwFsControlFile(
                        FileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_QUERY_RETRIEVAL_POINTERS,
                        &RequestedFileSize,
                        sizeof( LARGE_INTEGER ),
                        &mcb,
                        sizeof( PVOID )
                        );

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject( &FileObject->Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );
        Status = IoStatusBlock.Status;
    }


    //
    // NOTE: If you fail here, put a BP on ntfs!NtfsQueryRetrievalPointers
    // or FatQueryRetrievalPointers and see why you failed.
    //

    if ( !NT_SUCCESS (Status) ) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: ZwFsControlFile returnd %d\n"
                    "           File = %p\n",
                    FileObject,
                    Status
                    ));
        ErrorToLog = IO_DUMP_POINTER_FAILURE;
        goto Cleanup;
    }

    //
    // This paging file is on the system boot partition, and
    // the retrieval pointers for the file were just successfully
    // queried.  Walk the MCB to size it, and then checksum it.
    //

    for (i = 0; mcb [i].QuadPart; i++) {
        NOTHING;
    }

    //
    // Write back fields of the IopDumpControlBlock.
    //

    IopDumpControlBlock->FileDescriptorArray = mcb;
    IopDumpControlBlock->FileDescriptorSize = (i + 1) * sizeof (LARGE_INTEGER);
    IopDumpControlBlock->DumpFileSize = RequestedFileSize;
    IopDumpControlBlockChecksum = IopGetDumpControlBlockCheck ( IopDumpControlBlock );

    Status = STATUS_SUCCESS;

Cleanup:

    if (Status != STATUS_SUCCESS &&
        ErrorToLog != STATUS_SUCCESS ) {

        IopLogErrorEvent (0,
                          4,
                          STATUS_SUCCESS,
                          ErrorToLog,
                          0,
                          NULL,
                          0,
                          NULL
                          );
    }

    DeviceObject = NULL;

    if ( FileObject ) {
        ObDereferenceObject( FileObject );
        FileObject = NULL;
    }

    return Status;

}


VOID
IopFreeDCB(
    BOOLEAN FreeDCB
    )

/*++

Routine Description:

    Free dump control block storage.

Arguments:

    FreeDCB - Implictly free storage for the dump control block.

Return Value:

    None

--*/
{
    PDUMP_CONTROL_BLOCK dcb;

    dcb = IopDumpControlBlock;

    if (dcb) {

        if (dcb->HeaderPage) {
            ExFreePool (dcb->HeaderPage);
            dcb->HeaderPage = NULL;
        }

        if (dcb->FileDescriptorArray) {
            ExFreePool (dcb->FileDescriptorArray);
            dcb->FileDescriptorArray = NULL;
        }

        if (dcb->DumpStack) {
            IoFreeDumpStack (dcb->DumpStack);
            dcb->DumpStack = NULL;
        }

        if (dcb->TriageDumpBuffer) {
            ExFreePool (dcb->TriageDumpBuffer);
            dcb->TriageDumpBuffer = NULL;
            dcb->TriageDumpBufferSize = 0;
        }

        //
        // Disable all options that require dump file access
        //

        dcb->Flags = 0;

        if (FreeDCB) {
            IopDumpControlBlock = NULL;
            ExFreePool( dcb );
        }
    }
}



NTSTATUS
IoConfigureCrashDump(
    CRASHDUMP_CONFIGURATION Configuration
    )

/*++

Routine Description:

    Change the configuration of the crashdump for this machine.

Arguments:

    Configuration - What to change the configuration to.

        CrashDumpDisable - Disable crashdumps for this machine.

        CrashDumpReconfigure - Reread crashdump settings from the
            registry and apply them.

Return Value:

    NTSTATUS code.

--*/


{
    NTSTATUS Status;
    HANDLE FileHandle;
    PKTHREAD CurrentThread;

    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread(CurrentThread);
    switch (Configuration) {

        case CrashDumpDisable:
            if (ExAcquireResourceExclusiveLite(&IopCrashDumpLock, FALSE)) {
                IopFreeDCB (FALSE);
                ExReleaseResourceLite(&IopCrashDumpLock);
            }
            Status = STATUS_SUCCESS;
            break;

        case CrashDumpReconfigure:
            FileHandle = MmGetSystemPageFile();
            if (FileHandle == NULL) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            } else {
                ExAcquireResourceExclusiveLite(&IopCrashDumpLock,TRUE);
                if (IoInitializeCrashDump(FileHandle)) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                }
                ExReleaseResourceLite(&IopCrashDumpLock);
            }
            break;

        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
    }
    KeLeaveCriticalRegionThread(CurrentThread);

    return Status;
}



VOID
IopReadDumpRegistry(
    OUT PULONG dumpControl,
    OUT PULONG numberOfHeaderPages,
    OUT PULONG autoReboot,
    OUT PULONG dumpFileSize
    )
/*++

Routine Description:

    This routine reads the dump parameters from the registry.

Arguments:

    dumpControl - Supplies a pointer to the dumpControl flags to set.

Return Value:

    None.

--*/

{
    HANDLE                      keyHandle;
    HANDLE                      crashHandle;
    LOGICAL                     crashHandleOpened;
    UNICODE_STRING              keyName;
    NTSTATUS                    status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG                       handleValue;

    *dumpControl = 0;
    *autoReboot = 0;
    *dumpFileSize = 0;

    *numberOfHeaderPages = BYTES_TO_PAGES(sizeof(DUMP_HEADER));

    //
    // Begin by opening the path to the control for dumping memory.  Note
    // that if it does not exist, then no dumps will occur.
    //

    crashHandleOpened = FALSE;

    RtlInitUnicodeString( &keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control" );

    status = IopOpenRegistryKey( &keyHandle,
                                 (HANDLE) NULL,
                                 &keyName,
                                 KEY_READ,
                                 FALSE );

    if (!NT_SUCCESS( status )) {
        return;
    }

    RtlInitUnicodeString( &keyName, L"CrashControl" );
    status = IopOpenRegistryKey( &crashHandle,
                                 keyHandle,
                                 &keyName,
                                 KEY_READ,
                                 FALSE );


    ObCloseHandle( keyHandle , KernelMode);

    if (!NT_SUCCESS( status )) {
        return;
    }

    crashHandleOpened = TRUE;

    //
    // Now get the value of the crash control to determine whether or not
    // dumping is enabled.
    //

    status = IopGetRegistryValue( crashHandle,
                                  L"CrashDumpEnabled",
                                  &keyValueInformation );

    if (NT_SUCCESS (status)) {

        if (keyValueInformation->DataLength) {

            handleValue = * ((PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset));
            ExFreePool( keyValueInformation );

            if (handleValue) {

                *dumpControl |= DCB_DUMP_ENABLED;

                if ( handleValue == 3 ) {

                    *dumpControl |= DCB_TRIAGE_DUMP_ENABLED;

                } else if ( handleValue == 4 ) {

                    *dumpControl |= ( DCB_TRIAGE_DUMP_ENABLED | DCB_TRIAGE_DUMP_ACT_UPON_ENABLED );

                } else if ( handleValue == 2 ) {

                    PPHYSICAL_MEMORY_RUN LastRun;
                    
                    *dumpControl |= DCB_SUMMARY_DUMP_ENABLED;

                    //
                    // Allocate enough storage for the dump header, summary
                    // dump header and bitmap.
                    //

                    LastRun = MmPhysicalMemoryBlock->Run +
                        (MmPhysicalMemoryBlock->NumberOfRuns - 1);
                    *numberOfHeaderPages = (ULONG) BYTES_TO_PAGES(
                        sizeof(DUMP_HEADER) +
                        ( LastRun->BasePage + LastRun->PageCount + 7) / 8 +
                        sizeof (SUMMARY_DUMP));

                }
            }
        }
    }

    status = IopGetRegistryValue( crashHandle,
                                  L"LogEvent",
                                  &keyValueInformation );

    if (NT_SUCCESS( status )) {
         if (keyValueInformation->DataLength) {
            handleValue = * ((PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset));
            ExFreePool( keyValueInformation);
            if (handleValue) {
                *dumpControl |= DCB_SUMMARY_ENABLED;
            }
        }
    }

    status = IopGetRegistryValue( crashHandle,
                                  L"SendAlert",
                                  &keyValueInformation );

    if (NT_SUCCESS( status )) {
         if (keyValueInformation->DataLength) {
            handleValue = * ((PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset));
            ExFreePool( keyValueInformation);
            if (handleValue) {
                *dumpControl |= DCB_SUMMARY_ENABLED;
            }
        }
    }

    //
    // Now determine whether or not automatic reboot is enabled.
    //

    status = IopGetRegistryValue( crashHandle,
                                  L"AutoReboot",
                                  &keyValueInformation );


    if (NT_SUCCESS( status )) {
        if (keyValueInformation->DataLength) {
            *autoReboot = * ((PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset));
        }
        ExFreePool( keyValueInformation );
    }

    //
    // If we aren't auto rebooting or crashing then return now.
    //

    if (*dumpControl == 0 && *autoReboot == 0) {
        if (crashHandleOpened == TRUE) {
            ObCloseHandle( crashHandle , KernelMode);
        }
        return;
    }

    status = IopGetRegistryValue( crashHandle,
                                  L"DumpFileSize",
                                  &keyValueInformation );

    if (NT_SUCCESS( status )) {
        if (keyValueInformation->DataLength) {
            *dumpFileSize = * ((PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset));
        }

        ExFreePool( keyValueInformation );
    }
    ObCloseHandle(crashHandle, KernelMode);
    return;
}


BOOLEAN
IopInitializeDCB(
    )
/*++

Routine Description:

    This routine initializes the Dump Control Block (DCB). It allocates the
    DCB and reads the crashdump parameters from the registry.

Arguments:


Return Value:

    The final function value is TRUE if everything worked, else FALSE.

--*/

{
    PDUMP_CONTROL_BLOCK         dcb;
    ULONG                       dumpControl;
    ULONG                       dcbSize;
    LARGE_INTEGER               page;
    ULONG                       numberOfHeaderPages;
    ULONG                       dumpFileSize;

    //
    // Read all the registry default values first.
    //

    IopReadDumpRegistry ( &dumpControl,
                          &numberOfHeaderPages,
                          &IopAutoReboot,
                          &dumpFileSize);

    //
    // If we aren't crashing or auto rebooting then return now.
    //

    if (dumpControl == 0 && IopAutoReboot == 0) {

        //
        // At some point, we will conditionally on system size, type, etc,
        // set dump defaults like the below and skip over the return.
        //
        //    *dumpControl = (DCB_DUMP_ENABLED | DCB_TRIAGE_DUMP_ENABLED);
        //    *IopAutoReboot = 1;
        //    *dumpFileSize = ?
        //

        return TRUE;
    }

    if (dumpControl & DCB_TRIAGE_DUMP_ENABLED) {
        dumpControl &= ~DCB_SUMMARY_ENABLED;
        dumpFileSize = TRIAGE_DUMP_SIZE;
    }

    //
    // Allocate and initialize the structures necessary to describe and control
    // the post-bugcheck code.
    //

    dcbSize = sizeof( DUMP_CONTROL_BLOCK ) + sizeof( MINIPORT_NODE );
    dcb = ExAllocatePool( NonPagedPool, dcbSize );

    if (!dcb) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Not enough pool to allocate DCB %d\n",
                    __LINE__
                    ));

        IopLogErrorEvent(0,1,STATUS_SUCCESS,IO_DUMP_INITIALIZATION_FAILURE,0,NULL,0,NULL);
        return FALSE;
    }

    RtlZeroMemory( dcb, dcbSize );
    dcb->Type = IO_TYPE_DCB;
    dcb->Size = (USHORT) dcbSize;
    dcb->Flags = (UCHAR) dumpControl;
    dcb->NumberProcessors = KeNumberProcessors;
    dcb->ProcessorArchitecture = KeProcessorArchitecture;
    dcb->MinorVersion = (USHORT) NtBuildNumber;
    dcb->MajorVersion = (USHORT) ((NtBuildNumber >> 28) & 0xfffffff);
    dcb->BuildNumber = CmNtCSDVersion;
    dcb->TriageDumpFlags = TRIAGE_DUMP_BASIC_INFO | TRIAGE_DUMP_MMINFO |
                           TRIAGE_DUMP_DEBUGGER_DATA | TRIAGE_DUMP_DATA_BLOCKS;

    dcb->DumpFileSize.QuadPart = dumpFileSize;

    //
    // Allocate header page.
    //

    dcb->HeaderSize = numberOfHeaderPages * PAGE_SIZE;
    dcb->HeaderPage = ExAllocatePool( NonPagedPool, dcb->HeaderSize );

    if (!dcb->HeaderPage) {
        ExFreePool (dcb);
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Not enough pool to allocate DCB %d\n",
                    __LINE__
                    ));
        IopLogErrorEvent(0,1,STATUS_SUCCESS,IO_DUMP_INITIALIZATION_FAILURE,0,NULL,0,NULL);
        return FALSE;
    }
    page = MmGetPhysicalAddress( dcb->HeaderPage );
    dcb->HeaderPfn = (ULONG)(page.QuadPart >> PAGE_SHIFT);


    //
    // Allocate the triage-dump buffer.
    //

    if (dumpControl & DCB_TRIAGE_DUMP_ENABLED) {

        dcb->TriageDumpBuffer = ExAllocatePool  (
                                    NonPagedPool,
                                    dumpFileSize
                                    );

        if (!dcb->TriageDumpBuffer) {
            ExFreePool (dcb->HeaderPage);
            ExFreePool (dcb);

            KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                        CRASHDUMP_ERROR,
                        "CRASHDUMP: Not enough pool to allocate DCB %d\n",
                        __LINE__
                        ));
            IopLogErrorEvent(0,1,STATUS_SUCCESS,IO_DUMP_INITIALIZATION_FAILURE,0,NULL,0,NULL);
            return FALSE;
        }

        dcb->TriageDumpBufferSize = dumpFileSize;
    }

    IopDumpControlBlock = dcb;

    return TRUE;
}


BOOLEAN
IoInitializeCrashDump(
    IN HANDLE hPageFile
    )
/*++

Routine Description:

    This routine configures the system for crash dump. The following things
    are done:

        1. Initialize the dump control block and init registry crashdump
           parameters.

        2. Configure either page or fast dump.

        3. Complete dump file initialization.

    This routine is called as each page file is created. A return value of
    TRUE tells the caller (i.e., NtCreatePagingFiles, IoPageFileCreated)
    that crash dump has been configured.


Arguments:

       hPageFile - Handle to the paging file

Return Value:

    TRUE - Configuration complete (or crash dump not enabled).

    FALSE - Error, retry PageFile is not on boot partition.

--*/
{
    NTSTATUS        dwStatus;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;

    //
    // If crashdump is already enabled, free it and reinitialize with the
    // current settings.
    //
    IopFreeDCB (TRUE);
    if (!IopInitializeDCB()) {
        return TRUE;
    }

    //
    // Return crash dump not enabled
    //
    if (!IopDumpControlBlock) {
        return TRUE;
    }

    //
    //  No dump enabled?
    //

    if ( !( IopDumpControlBlock->Flags & (DCB_DUMP_ENABLED | DCB_SUMMARY_ENABLED) ) ) {
        return TRUE;
    }

    //
    // Configure the paging file for crash dump.
    //

    dwStatus = ObReferenceObjectByHandle(
                                        hPageFile,
                                        0,
                                        IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &fileObject,
                                        NULL
                                        );

    if (!NT_SUCCESS( dwStatus )) {
        goto error_return;
    }

    //
    // Get a pointer to the device object for this file.  Note that it
    // cannot go away, since there is an open handle to it, so it is
    // OK to dereference it and then use it.
    //

    deviceObject = fileObject->DeviceObject;

    ObDereferenceObject( fileObject );

    //
    // This should never be called on devices that are not the boot partition
    //
    ASSERT(deviceObject->Flags & DO_SYSTEM_BOOT_PARTITION);

    //
    // Load paging file dump stack
    //

    dwStatus = IoGetDumpStack (L"dump_",
                               &IopDumpControlBlock->DumpStack,
                               DeviceUsageTypeDumpFile,
                               FALSE);

    if (!NT_SUCCESS(dwStatus)) {
        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Could not load dump stack status = %x\n",
                    dwStatus
                    ));
        goto error_return;
    }

    IopDumpControlBlock->DumpStack->Init.CrashDump = TRUE;

    IopDumpControlBlock->DumpStack->Init.MemoryBlock = ExAllocatePool (
                                                NonPagedPool,
                                                IO_DUMP_MEMORY_BLOCK_PAGES * PAGE_SIZE
                                                );

    if (!IopDumpControlBlock->DumpStack->Init.MemoryBlock) {
        dwStatus = STATUS_NO_MEMORY;
        goto error_return;
    }


    //
    // Calculate the amount of space required for the dump
    //
    IopDumpControlBlock->DumpFileSize =
        IopCalculateRequiredDumpSpace(
            IopDumpControlBlock->Flags,
            IopDumpControlBlock->HeaderSize,
            MmPhysicalMemoryBlock->NumberOfPages,
            MmPhysicalMemoryBlock->NumberOfPages,
            TRUE
            );


    //
    // Complete dump initialization
    //

    dwStatus = IopCompleteDumpInitialization(hPageFile);

error_return:

    //
    // The BOOT partition paging file could not be configured.
    //   1. Log an error message
    //   2. Return TRUE so that MM does not try again
    //

    if (!NT_SUCCESS(dwStatus)) {

        KdPrintEx ((DPFLTR_CRASHDUMP_ID,
                    CRASHDUMP_ERROR,
                    "CRASHDUMP: Page File dump init FAILED status = %x\n",
                    dwStatus
                    ));
        IopLogErrorEvent(0, 3, STATUS_SUCCESS, IO_DUMP_PAGE_CONFIG_FAILED, 0, NULL, 0, NULL);

        //
        // ISSUE - 2000/02/07 - math: IopFreeDCB probably wrong.
        //
        // Is the call to IopFreeDCB() correct here? Doesn't this prevent
        // other dump types from working properly? Review this.
        //

        IopFreeDCB(FALSE);

    }

    return TRUE;
}


#define TRIAGE_DUMP_DATA_SIZE (TRIAGE_DUMP_SIZE - sizeof(ULONG))

static
BOOLEAN
IopValidateSectionSize(
    ULONG Offset,
    ULONG* pSectionSize
    )

/*++

Routine Description:

    Checks whether specified section size will overflow the dump buffer
    (used just for creation of live minidumps)
    
Arguments:

    Offset - Section offset
    pSectionSize - Section size (will be changed to fit the dump)
    pbOverflow - used to return the overflow status
    
Return Value:

    TRUE - if the section fits the dump, otherwise section size will decreased 
           and FALSE will be returned

--*/

{
    if ((Offset + *pSectionSize) < TRIAGE_DUMP_DATA_SIZE) return TRUE;
    
    *pSectionSize = (Offset < TRIAGE_DUMP_DATA_SIZE) ? 
                           (TRIAGE_DUMP_DATA_SIZE - Offset) : 0;
    return FALSE;
}

static
ULONG
IopGetMaxValidSectionSize(
    ULONG_PTR Base, 
    ULONG  MaxSize
    )
    
/*++

Routine Description:

    Gets maximum valid memory section size less than SectionMaxSize
    
Arguments:

    Base - beginning of the section
    MaxSize - Maximum size of the section
    
Return Value:

    Size of the continuously valid memory starting from SectionBase up to 
    SectionMaxSize

--*/
    
{
    ULONG Size = 0;

    // XXX olegk - optimize it later to iterate by page size
    while ((Size < MaxSize) && (MmIsAddressValid((PVOID)(Base + Size)))) 
        ++Size;
    
    return Size;
}

static
ULONG
IopGetMaxValidSectionSizeDown(
    ULONG_PTR Base, 
    ULONG MaxSize
    )
    
/*++

Routine Description:

    Gets maximum valid memory section size less than SectionMaxSize
    
Arguments:

    Base - End of the section
    MaxSize - Maximum size of the section
    
Return Value:

    Size of the continuously valid memory ending at SectionBase downto to 
    SectionMaxSize

--*/
    
{
    ULONG Size = 0;
    
    if ((ULONG_PTR)Base < (ULONG_PTR)MaxSize) MaxSize = (ULONG)Base;

    // XXX olegk - optimize it later to iterate by page size
    while ((Size < MaxSize) && (MmIsAddressValid((PVOID)(Base - Size))))
        ++Size;
    
    return Size;
}

ULONG
KeCapturePersistentThreadState(
    PCONTEXT pContext,
    PETHREAD pThread,
    ULONG ulBugCheckCode,
    ULONG_PTR ulpBugCheckParam1,
    ULONG_PTR ulpBugCheckParam2,
    ULONG_PTR ulpBugCheckParam3,
    ULONG_PTR ulpBugCheckParam4,
    PVOID pvDump
    )

/*++

Routine Description:

    Creates main portion of the minidump in the specified buffer
    This function can be used to crate live minidump (originaly designed to 
    work with EA recovery for video drivers)
    
Arguments:

    pContext - context of failed thread 
    pThread  - failed thread object (NULL means current thread)
    ulBugCheckCode,
    ulpBugCheckParam1,
    ulpBugCheckParam2,
    ulpBugCheckParam3, 
    ulpBugCheckParam4 - Bugcheck info
    pModules - List of te loaded modules
    pDump - Memory buffer to write dump context (Size of the buffer should 
            be at least TRIAGE_DUMP_SIZE

Return Value:

    Actual size of the dump file to save on disk (always at least TRIAGE_DUMP_SIZE)

--*/
                      
{
    PMEMORY_DUMP pDump = (PMEMORY_DUMP)pvDump;
    PDUMP_HEADER pdh = &(pDump->Header);
    PTRIAGE_DUMP ptdh = &(pDump->Triage);
    ULONG Offset = 0, SectionSize = 0;
    PKDDEBUGGER_DATA64 pKdDebuggerDataBlock = (PKDDEBUGGER_DATA64)KdGetDataBlock();
    PEPROCESS pProcess;
    
    if (!pvDump) return 0;
    
    if (!pThread) pThread = PsGetCurrentThread();
    pProcess = (PEPROCESS)pThread->Tcb.ApcState.Process;
    
    RtlZeroMemory(pDump, TRIAGE_DUMP_SIZE);
    
    //
    // Fill the dump header with signature
    //
    
    RtlFillMemoryUlong(pdh, sizeof(*pdh), DUMP_SIGNATURE);
    
    pdh->Signature = DUMP_SIGNATURE;
    pdh->ValidDump = DUMP_VALID_DUMP;
    
    pdh->MinorVersion = (USHORT) NtBuildNumber;
    pdh->MajorVersion = (USHORT) ((NtBuildNumber >> 28) & 0xfffffff);

#if defined (_IA64_)
    pdh->DirectoryTableBase = MmSystemParentTablePage << PAGE_SHIFT;
#else
    pdh->DirectoryTableBase = pThread->Tcb.ApcState.Process->DirectoryTableBase[0];
#endif
    
    pdh->PfnDataBase = (ULONG_PTR)MmPfnDatabase;
    pdh->PsLoadedModuleList = (ULONG_PTR)&PsLoadedModuleList;
    pdh->PsActiveProcessHead = (ULONG_PTR)&PsActiveProcessHead;

    pdh->MachineImageType = CURRENT_IMAGE_TYPE();
    pdh->NumberProcessors = KeNumberProcessors;
   
    pdh->BugCheckCode = ulBugCheckCode;
    pdh->BugCheckParameter1 = ulpBugCheckParam1;
    pdh->BugCheckParameter2 = ulpBugCheckParam2;
    pdh->BugCheckParameter3 = ulpBugCheckParam3;
    pdh->BugCheckParameter4 = ulpBugCheckParam4;

#if defined (_X86_)
    pdh->PaeEnabled = X86PaeEnabled ();
#endif

    pdh->Exception.ExceptionCode = STATUS_BREAKPOINT;   // XXX olegk - ???
    pdh->Exception.ExceptionRecord = 0;
    pdh->Exception.NumberParameters = 0;
    pdh->Exception.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    pdh->Exception.ExceptionAddress = PROGRAM_COUNTER (pContext);
    
    pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE;
    
    pdh->SystemTime.LowPart  = SharedUserData->SystemTime.LowPart;
    pdh->SystemTime.HighPart = SharedUserData->SystemTime.High1Time;

    pdh->SystemUpTime.LowPart  = SharedUserData->InterruptTime.LowPart;
    pdh->SystemUpTime.HighPart = SharedUserData->InterruptTime.High1Time;
    
    pdh->DumpType = DUMP_TYPE_TRIAGE;
    pdh->MiniDumpFields = TRIAGE_DUMP_EXCEPTION | 
                          TRIAGE_DUMP_BROKEN_DRIVER; // XXX olegk - debugger need it for memory mapping
    
    pdh->ProductType = SharedUserData->NtProductType;
    pdh->SuiteMask = SharedUserData->SuiteMask;
    
    //
    // TRIAGE header
    //   
    
    ptdh->TriageOptions = 0;
    ptdh->ServicePackBuild = CmNtCSDVersion;
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE;
    ptdh->ExceptionOffset = FIELD_OFFSET(DUMP_HEADER, Exception);
    
    ptdh->BrokenDriverOffset = 0;
    
    Offset = sizeof(DUMP_HEADER) + sizeof(TRIAGE_DUMP);
    
    //
    // Context
    //
    
    pdh->MiniDumpFields |= TRIAGE_DUMP_CONTEXT;
    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER, ContextRecord);
    RtlCopyMemory(pdh->ContextRecord, pContext, sizeof(CONTEXT));
    
    //
    // Save debugger data block
    //
    
    SectionSize = sizeof(KDDEBUGGER_DATA64);
    if (IopValidateSectionSize(ALIGN_8(Offset), &SectionSize)) {
        Offset = ALIGN_8(Offset);
        pdh->MiniDumpFields |= TRIAGE_DUMP_DEBUGGER_DATA;
        pdh->KdDebuggerDataBlock = (LONG_PTR)pKdDebuggerDataBlock;
        ptdh->DebuggerDataOffset = Offset;
        ptdh->DebuggerDataSize = sizeof(KDDEBUGGER_DATA64);
        RtlCopyMemory((char*)pDump + Offset, 
                      pKdDebuggerDataBlock, 
                      SectionSize);
        Offset += SectionSize;                          
    }

    //
    // Write the PRCB.
    //

    SectionSize = sizeof(KPRCB);
    if (IopValidateSectionSize(ALIGN_8(Offset), &SectionSize)) {
        Offset = ALIGN_8(Offset);
        pdh->MiniDumpFields |= TRIAGE_DUMP_PRCB;
        ptdh->PrcbOffset = Offset;
        RtlCopyMemory((char*)pDump + Offset, 
                      KeGetCurrentPrcb(), 
                      SectionSize);
        Offset += SectionSize;
    }

    //
    // Write the EPROCESS
    //

    SectionSize = sizeof(EPROCESS);
    if (IopValidateSectionSize(ALIGN_8(Offset), &SectionSize)) {
        Offset = ALIGN_8(Offset);
        pdh->MiniDumpFields |= TRIAGE_DUMP_PROCESS;
        ptdh->ProcessOffset = Offset;
        RtlCopyMemory((char*)pDump + Offset, 
                      pThread->Tcb.ApcState.Process,
                      SectionSize);
        Offset += SectionSize;
    }

    //
    // Write the ETHREAD
    //
    
    SectionSize = sizeof(ETHREAD);
    if (IopValidateSectionSize(ALIGN_8(Offset), &SectionSize)) {
        Offset = ALIGN_8(Offset);
        pdh->MiniDumpFields |= TRIAGE_DUMP_THREAD;
        ptdh->ThreadOffset = Offset;
        RtlCopyMemory((PUCHAR)pDump + Offset,
                      pThread,
                      SectionSize);
        Offset += SectionSize;
    }

    //
    // Call Stack (and backing store on ia64)
    // 
   
    if (pThread->Tcb.KernelStackResident) {
        ULONG_PTR StackBase = (ULONG_PTR)pThread->Tcb.StackBase;
        ULONG_PTR StackLimit = (ULONG_PTR)pThread->Tcb.StackLimit;
        ULONG_PTR StackTop = STACK_POINTER(pContext);
        
        if ((StackLimit > StackTop) || (StackTop >= StackBase)) 
            StackTop = (ULONG_PTR)pThread->Tcb.StackLimit;
            
        SectionSize = (StackBase > StackTop) ? (ULONG)(StackBase - StackTop) : 0;
        SectionSize = min(SectionSize, MAX_TRIAGE_STACK_SIZE - 1);
        SectionSize = IopGetMaxValidSectionSize(StackTop, SectionSize);
        
        if (SectionSize) {
            if (!IopValidateSectionSize(Offset, &SectionSize)) 
                ptdh->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
            
            pdh->MiniDumpFields |= TRIAGE_DUMP_STACK;
            ptdh->CallStackOffset = Offset;
            ptdh->SizeOfCallStack = SectionSize;
            ptdh->TopOfStack = (LONG_PTR)StackTop;
            
            RtlCopyMemory((char*)pDump + Offset, 
                          (char*)StackTop,
                          SectionSize);
            
            Offset += SectionSize;
        }

#if defined(_IA64_)         
        {
            ULONG_PTR BStoreTop = pContext->RsBSP;
            ULONG_PTR BStoreBase = (ULONG_PTR)pThread->Tcb.InitialBStore;
            ULONG_PTR BStoreLimit = (ULONG_PTR)pThread->Tcb.BStoreLimit;
            
            if ((BStoreBase >= BStoreTop) || (BStoreTop > BStoreLimit))
                BStoreTop = (ULONG_PTR)pThread->Tcb.BStoreLimit;
        
            SectionSize = (BStoreTop > BStoreBase) ? (ULONG)(BStoreTop - BStoreBase) : 0;
            SectionSize = min(SectionSize, MAX_TRIAGE_STACK_SIZE - 1);
            SectionSize = IopGetMaxValidSectionSizeDown(BStoreTop, SectionSize);
                                
            if (SectionSize) {
                if (!IopValidateSectionSize(Offset, &SectionSize))
                    ptdh->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
                
                ptdh->ArchitectureSpecific.Ia64.BStoreOffset = Offset;
                ptdh->ArchitectureSpecific.Ia64.SizeOfBStore = SectionSize;
                ptdh->ArchitectureSpecific.Ia64.LimitOfBStore = (LONG_PTR)BStoreTop;
                RtlCopyMemory((char*)pDump + Offset, 
                              (char*)BStoreTop - SectionSize + 1,
                              SectionSize);
                              
                Offset += SectionSize;
            }
        }
#endif // defined(_IA64_)        
    }

    //
    // Loaded modules list
    //
    
    {
        ULONG DrvOffset = ALIGN_8(Offset);
        ULONG DrvCount, StrDataSize;
        KIRQL OldIrql;
        
        OldIrql = KeGetCurrentIrql();
        if (OldIrql < DISPATCH_LEVEL) {
            KeRaiseIrqlToDpcLevel();
        }
        ExAcquireSpinLockAtDpcLevel(&PsLoadedModuleSpinLock);        
        
        if (NT_SUCCESS(IopGetLoadedDriverInfo(&DrvCount, &StrDataSize))) {
            SectionSize = ALIGN_8(DrvCount * sizeof(DUMP_DRIVER_ENTRY));
            if (SectionSize && 
                IopValidateSectionSize(DrvOffset, &SectionSize)) 
            {
                ULONG StrOffset = DrvOffset + SectionSize;
                SectionSize = ALIGN_8(StrDataSize + 
                                      DrvCount * (sizeof(WCHAR) + 
                                      sizeof(DUMP_STRING)));
                if (SectionSize && 
                    IopValidateSectionSize(StrOffset, &SectionSize)) 
                {
                    if (NT_SUCCESS(IopWriteDriverList((ULONG_PTR)pDump, 
                                                      TRIAGE_DUMP_DATA_SIZE,
                                                      DrvOffset,
                                                      StrOffset)))
                    {
                        pdh->MiniDumpFields |= TRIAGE_DUMP_DRIVER_LIST;
                        ptdh->DriverListOffset = DrvOffset;
                        ptdh->DriverCount = DrvCount;
                        ptdh->StringPoolOffset = (ULONG)StrOffset;
                        ptdh->StringPoolSize = SectionSize;
                        Offset = StrOffset + SectionSize;
                    }
                } else {
                    ptdh->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
                }
            } else {
                ptdh->TriageOptions |= TRIAGE_OPTION_OVERFLOWED;
            }
        } 
        
        ExReleaseSpinLock(&PsLoadedModuleSpinLock, OldIrql);
    } // Loaded modules list
    
    //
    // Save some current code
    //

    SectionSize = PAGE_SIZE + sizeof(TRIAGE_DATA_BLOCK);
    IopValidateSectionSize(ALIGN_8(Offset), &SectionSize);
    if (SectionSize > sizeof(TRIAGE_DATA_BLOCK)) {
        ULONG DataSize = SectionSize - sizeof(TRIAGE_DATA_BLOCK);
        ULONG PreIpSize = IopGetMaxValidSectionSizeDown(PROGRAM_COUNTER(pContext), 
                                                        DataSize / 2);
                                                        
        if (PreIpSize) {                                                        
            ULONG_PTR CodeStartOffset = PROGRAM_COUNTER(pContext) - PreIpSize + 1;
            DataSize = IopGetMaxValidSectionSize(CodeStartOffset, 
                                                 DataSize);

            if (DataSize) {
                PTRIAGE_DATA_BLOCK pDataBlock;
            
                Offset = ALIGN_8(Offset);
            
                pdh->MiniDumpFields |= TRIAGE_DUMP_DATA_BLOCKS;
                ptdh->DataBlocksOffset = Offset;
                ptdh->DataBlocksCount = 1;
            
                pDataBlock = (PTRIAGE_DATA_BLOCK)((char*)pDump + Offset);
                Offset += sizeof(*pDataBlock);
                Offset = ALIGN_8(Offset);
            
                pDataBlock->Address = (LONG_PTR)CodeStartOffset;
                pDataBlock->Size = DataSize;
                pDataBlock->Offset = Offset;
                RtlCopyMemory((char*)pDump + Offset, 
                              (char*)CodeStartOffset, 
                              DataSize);
                Offset += DataSize;
            }
        }
    }

    //
    // End of dump validation
    //
    
    ptdh->ValidOffset = TRIAGE_DUMP_SIZE - sizeof(ULONG);
    *(PULONG)((char*)pDump + ptdh->ValidOffset) = TRIAGE_DUMP_VALID;
    Offset = TRIAGE_DUMP_SIZE;
    return Offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\errorlog.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module contains the code for the I/O error log thread.

Author:

    Darryl E. Havens (darrylh) May 3, 1989

Environment:

    Kernel mode, system process thread

Revision History:


--*/

#include "iomgr.h"
#include "elfkrnl.h"

typedef struct _IOP_ERROR_LOG_CONTEXT {
    KDPC ErrorLogDpc;
    KTIMER ErrorLogTimer;
}IOP_ERROR_LOG_CONTEXT, *PIOP_ERROR_LOG_CONTEXT;

//
// Declare routines local to this module.
//

BOOLEAN
IopErrorLogConnectPort(
    VOID
    );

VOID
IopErrorLogDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

PLIST_ENTRY
IopErrorLogGetEntry(
    );

VOID
IopErrorLogQueueRequest(
    VOID
    );

VOID
IopErrorLogRequeueEntry(
    IN PLIST_ENTRY ListEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopErrorLogThread)
#pragma alloc_text(PAGE, IopErrorLogConnectPort)
#pragma alloc_text(PAGE, IopErrorLogQueueRequest)
#endif

//
// Define a global varibles used by the error logging code.
//

WORK_QUEUE_ITEM IopErrorLogWorkItem;
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
HANDLE ErrorLogPort;
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
BOOLEAN ErrorLogPortConnected;
BOOLEAN IopErrorLogPortPending;
BOOLEAN IopErrorLogDisabledThisBoot;

//
// Define the amount of space required for the device and driver names.
//

#define IO_ERROR_NAME_LENGTH 100

VOID
IopErrorLogThread(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This is the main loop for the I/O error log thread which executes in the
    system process context.  This routine is started when the system is
    initialized.

Arguments:

    StartContext - Startup context; not used.

Return Value:

    None.

--*/

{
    PERROR_LOG_ENTRY errorLogEntry;
    UNICODE_STRING nameString;
    PLIST_ENTRY listEntry;
    PIO_ERROR_LOG_MESSAGE errorMessage;
    NTSTATUS status;
    PELF_PORT_MSG portMessage;
    PCHAR objectName;
    SIZE_T messageLength;
    SIZE_T driverNameLength;
    SIZE_T deviceNameLength;
    ULONG objectNameLength;
    SIZE_T remainingLength;
    SIZE_T stringLength;
    CHAR nameBuffer[IO_ERROR_NAME_LENGTH+sizeof( OBJECT_NAME_INFORMATION )];
    PDRIVER_OBJECT driverObject;
    POBJECT_NAME_INFORMATION nameInformation;
    PIO_ERROR_LOG_PACKET errorData;
    PWSTR string;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( StartContext );

    //
    // Check to see whether a connection has been made to the error log
    // port.  If the port is not connected return.
    //

    if (!IopErrorLogConnectPort()) {

        //
        // The port could not be connected.  A timer was started that will
        // try again later.
        //

        return;
    }

    //
    // Allocate and zero the port message structure, include space for the
    // name of the device and driver.
    //

    messageLength = IO_ERROR_LOG_MESSAGE_LENGTH;
    portMessage = ExAllocatePool(PagedPool, messageLength);

    if (portMessage == NULL) {

        //
        // The message buffer could not be allocated. Request that
        // the error log thread routine be called again later.
        //

        IopErrorLogQueueRequest();
        return;
    }

    RtlZeroMemory( portMessage, sizeof( *portMessage ) );
    portMessage->MessageType = IO_ERROR_LOG;
    errorMessage = &portMessage->u.IoErrorLogMessage;

    nameInformation = (PVOID) &nameBuffer[0];

    //
    // Now enter the main loop for this thread.  This thread performs the
    // following operations:
    //
    //   1)  If a connection has been made to the error log port, dequeue a
    //       packet from the queue head and attempt to send it to the port.
    //
    //   2)  If the send works, loop sending packets until there are no more
    //       packets;  otherwise, indicate that the connection has been broken,
    //       cleanup, place the packet back onto the head of the queue and
    //       return.
    //
    //   3)  After all the packets are sent clear the pending variable and
    //       return.
    //

    for (;;) {

        //
        // Loop dequeueing  packets from the queue head and attempt to send
        // each to the port.
        //
        // If the send works, continue looping until there are no more packets.
        // Otherwise, indicate that the connection has been broken, cleanup,
        // place the packet back onto the head of the queue, and start from the
        // top of the loop again.
        //

        if (!(listEntry = IopErrorLogGetEntry())) {
            break;
        }

        errorLogEntry = CONTAINING_RECORD( listEntry,
                                           ERROR_LOG_ENTRY,
                                           ListEntry );

        //
        // The size of errorLogEntry is ERROR_LOG_ENTRY +
        // IO_ERROR_LOG_PACKET + (Extra Dump data).  The size of the
        // initial message length should be IO_ERROR_LOG_MESSAGE +
        // (Extra Dump data), since IO_ERROR_LOG_MESSAGE contains an
        // IO_ERROR_LOG_PACKET. Using the above calculations set the
        // message length.
        //

        messageLength = sizeof( IO_ERROR_LOG_MESSAGE ) -
            sizeof( ERROR_LOG_ENTRY ) - sizeof( IO_ERROR_LOG_PACKET ) +
            errorLogEntry->Size;

        errorData = (PIO_ERROR_LOG_PACKET) (errorLogEntry + 1);

        //
        // Copy the error log packet and the extra data to the message.
        //

        RtlCopyMemory( &errorMessage->EntryData,
                       errorData,
                       errorLogEntry->Size - sizeof( ERROR_LOG_ENTRY ) );

        errorMessage->TimeStamp = errorLogEntry->TimeStamp;
        errorMessage->Type = IO_TYPE_ERROR_MESSAGE;

        //
        // Add the driver and device name string.  These strings go
        // before the error log strings.  Just write over the current
        // strings and they will be recopied later.
        //

        if (errorData->NumberOfStrings != 0) {

            //
            // Start the driver and device strings where the current
            // strings start.
            //

            objectName = (PCHAR) (&errorMessage->EntryData) +
                                 errorData->StringOffset;

        } else {

            //
            // Put the driver and device strings at the end of the
            // data.
            //

            objectName = (PCHAR) errorMessage + messageLength;

        }

        //
        // Make sure the driver offset starts on an even bountry.
        //

        objectName = (PCHAR) ((ULONG_PTR) (objectName + sizeof(WCHAR) - 1) &
            ~(ULONG_PTR)(sizeof(WCHAR) - 1));

        errorMessage->DriverNameOffset = (ULONG)(objectName - (PCHAR) errorMessage);

        remainingLength = (ULONG)((PCHAR) portMessage + IO_ERROR_LOG_MESSAGE_LENGTH
                            - objectName);

        //
        // Calculate the length of the driver name and
        // the device name. If the driver object has a name then get
        // it from there; otherwise try to query the device object.
        //

        driverObject = errorLogEntry->DriverObject;
        driverNameLength = 0;
        nameString.Buffer = NULL;

        if (driverObject != NULL) {
            if (driverObject->DriverName.Buffer != NULL) {

                nameString.Buffer = driverObject->DriverName.Buffer;
                driverNameLength = driverObject->DriverName.Length;
            }

            if (driverNameLength == 0) {

                //
                // Try to query the driver object for a name.
                //

                status = ObQueryNameString( driverObject,
                                            nameInformation,
                                            IO_ERROR_NAME_LENGTH + sizeof( OBJECT_NAME_INFORMATION ),
                                            &objectNameLength );

                if (!NT_SUCCESS( status ) || !nameInformation->Name.Length) {

                    //
                    // No driver name was available.
                    //

                    driverNameLength = 0;

                } else {
                    nameString = nameInformation->Name;
                }

            }

        } else {

            //
            // If no driver object, this message must be from the 
            // kernel.   We need to point the eventlog service to
            // an event message file containing ntstatus messages,
            // ie, ntdll, we do this by claiming this event is an
            // application popup.
            //

            nameString.Buffer = L"Application Popup";
            driverNameLength = wcslen(nameString.Buffer) * sizeof(WCHAR);
        }

        if (driverNameLength != 0 ) {

            //
            // Pick out the module name.
            //

            string = nameString.Buffer +
                (driverNameLength / sizeof(WCHAR));

            driverNameLength = sizeof(WCHAR);
            string--;
            while (*string != L'\\' && string != nameString.Buffer) {
                string--;
                driverNameLength += sizeof(WCHAR);
            }

            if (*string == L'\\') {
                string++;
                driverNameLength -= sizeof(WCHAR);
            }

            //
            // Ensure there is enough room for the driver name.
            // Save space for 3 NULLs one for the driver name,
            // one for the device name and one for strings.
            //

            if (driverNameLength > remainingLength - (3 * sizeof(WCHAR))) {
                driverNameLength = remainingLength - (3 * sizeof(WCHAR));
            }

            RtlCopyMemory(
                objectName,
                string,
                driverNameLength
                );

        }

        //
        // Add a null after the driver name even if there is no
        // driver name.
        //

       *((PWSTR) (objectName + driverNameLength)) = L'\0';
       driverNameLength += sizeof(WCHAR);

        //
        // Determine where the next string goes.
        //

        objectName += driverNameLength;
        remainingLength -= driverNameLength;

        errorMessage->EntryData.StringOffset = (USHORT)(objectName - (PCHAR) errorMessage);

        if (errorLogEntry->DeviceObject != NULL) {

            status = ObQueryNameString( errorLogEntry->DeviceObject,
                                        nameInformation,
                                        (ULONG)(IO_ERROR_NAME_LENGTH + sizeof( OBJECT_NAME_INFORMATION ) - driverNameLength),
                                        &objectNameLength );

            if (!NT_SUCCESS( status ) || !nameInformation->Name.Length) {

                //
                // No device name was available. Add a Null string.
                //

                nameInformation->Name.Length = 0;
                nameInformation->Name.Buffer = L"\0";

            }

            //
            // No device name was available. Add a Null string.
            // Always add a device name string so that the
            // insertion string counts are correct.
            //

        } else {

                //
                // No device name was available. Add a Null string.
                // Always add a device name string so that the
                // insertion string counts are correct.
                //

                nameInformation->Name.Length = 0;
                nameInformation->Name.Buffer = L"\0";

        }

        deviceNameLength = nameInformation->Name.Length;

        //
        // Ensure there is enough room for the device name.
        // Save space for a NULL.
        //

        if (deviceNameLength > remainingLength - (2 * sizeof(WCHAR))) {

            deviceNameLength = remainingLength - (2 * sizeof(WCHAR));

        }

        RtlCopyMemory( objectName,
                       nameInformation->Name.Buffer,
                       deviceNameLength );

        //
        // Add a null after the device name even if there is no
        // device name.
        //

        *((PWSTR) (objectName + deviceNameLength)) = L'\0';
        deviceNameLength += sizeof(WCHAR);

        //
        // Update the string count for the device object.
        //

        errorMessage->EntryData.NumberOfStrings++;
        objectName += deviceNameLength;
        remainingLength -= deviceNameLength;

        if (errorData->NumberOfStrings) {

            stringLength = errorLogEntry->Size - sizeof( ERROR_LOG_ENTRY ) -
                            errorData->StringOffset;

            //
            // Align the length to an even byte boundary.
            //

            stringLength = ((stringLength + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1));

            //
            // Ensure there is enough room for the strings.
            // Save space for a NULL.
            //

            if (stringLength > remainingLength - sizeof(WCHAR)) {


                messageLength -= stringLength - remainingLength;
                stringLength = remainingLength - sizeof(WCHAR);

            }

            //
            // Copy the strings to the end of the message.
            //

            RtlCopyMemory( objectName,
                           (PCHAR) errorData + errorData->StringOffset,
                           stringLength );

            //
            // Add a null after the strings
            //
            //

           *((PWSTR) (objectName + stringLength)) = L'\0';

        }

        //
        // Update the message length.
        //

        errorMessage->DriverNameLength = (USHORT) driverNameLength;
        messageLength += deviceNameLength + driverNameLength;
        errorMessage->Size = (USHORT) messageLength;

        messageLength += FIELD_OFFSET ( ELF_PORT_MSG, u ) -
            FIELD_OFFSET (ELF_PORT_MSG, MessageType);

        portMessage->PortMessage.u1.s1.TotalLength = (USHORT)
            (sizeof( PORT_MESSAGE ) + messageLength);
        portMessage->PortMessage.u1.s1.DataLength = (USHORT) (messageLength);
        status = NtRequestPort( ErrorLogPort, (PPORT_MESSAGE) portMessage );

        if (!NT_SUCCESS( status )) {

            //
            // The send failed.  Place the packet back onto the head of
            // the error log queue, forget the current connection since
            // it no longer works, and close the handle to the port.
            // Set a timer up for another attempt later.
            // Finally, exit the loop since there is no connection
            // to do any work on.
            //

            NtClose( ErrorLogPort );

            IopErrorLogRequeueEntry( &errorLogEntry->ListEntry );

            IopErrorLogQueueRequest();

            break;

        } else {

            //
            // The send worked fine.  Free the packet and the update
            // the allocation count.
            //

            InterlockedExchangeAdd( &IopErrorLogAllocation,
                                   -((LONG) (errorLogEntry->Size )));

            //
            // Dereference the object pointers now that the name has been
            // captured.
            //


            if (errorLogEntry->DeviceObject != NULL) {
                ObDereferenceObject( errorLogEntry->DeviceObject );
            }

            if (driverObject != NULL) {
                ObDereferenceObject( errorLogEntry->DriverObject );
            }

            ExFreePool( errorLogEntry );

        } // if

    } // for

    //
    // Finally, free the message buffer and return.
    //

    ExFreePool(portMessage);

}

BOOLEAN
IopErrorLogConnectPort(
    VOID
    )
/*++

Routine Description:

    This routine attempts to connect to the error log port.  If the connection
    was made successfully and the port allows suficiently large messages, then
    the ErrorLogPort to the port handle, ErrorLogPortConnected is set to
    TRUE and TRUE is retuned.  Otherwise a timer is started to queue a
    worker thread at a later time, unless there is a pending connection.

Arguments:

    None.

Return Value:

    Returns TRUE if the port was connected.

--*/

{

    UNICODE_STRING errorPortName;
    NTSTATUS status;
    ULONG maxMessageLength;
    SECURITY_QUALITY_OF_SERVICE dynamicQos;

    PAGED_CODE();

    //
    // If the ErrorLogPort is connected then return true.
    //

    if (ErrorLogPortConnected) {

        //
        // The port is connect return.
        //

        return(TRUE);
    }

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    dynamicQos.ImpersonationLevel = SecurityImpersonation;
    dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    dynamicQos.EffectiveOnly = TRUE;

    //
    // Generate the string structure for describing the error logger's port.
    //

    RtlInitUnicodeString( &errorPortName, ELF_PORT_NAME_U );

    status = NtConnectPort( &ErrorLogPort,
                            &errorPortName,
                            &dynamicQos,
                            (PPORT_VIEW) NULL,
                            (PREMOTE_PORT_VIEW) NULL,
                            &maxMessageLength,
                            (PVOID) NULL,
                            (PULONG) NULL );

    if (NT_SUCCESS( status )) {
        if (maxMessageLength >= IO_ERROR_LOG_MESSAGE_LENGTH) {
            ErrorLogPortConnected = TRUE;
            return(TRUE);
        } else {
            NtClose(ErrorLogPort);
        }
    }

    //
    // The port was not successfully opened, or its message size was unsuitable
    // for use here.  Queue a later request to run the error log thread.
    //

    IopErrorLogQueueRequest();

    //
    // The port could not be connected at this time return false.
    //

    return(FALSE);
}

VOID
IopErrorLogDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine queues a work request to the worker thread to process logged
    errors. It is called by a timer DPC when the error log port cannot be
    connected.  The DPC structure itself is freed by this routine.

Arguments:

    Dpc - Supplies a pointer to the DPC structure.  This structure is freed by
        this routine.

    DeferredContext - Unused.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Free the DPC structure if there is one.
    //

    if (Dpc != NULL) {
        ExFreePool(Dpc);
    }

    ExInitializeWorkItem( &IopErrorLogWorkItem, IopErrorLogThread, NULL );

    ExQueueWorkItem( &IopErrorLogWorkItem, DelayedWorkQueue );
}

PLIST_ENTRY
IopErrorLogGetEntry(
    )

/*++

Routine Description:

    This routine gets the next entry from the head of the error log queue
    and returns it to the caller.

Arguments:

    None.

Return Value:

    The return value is a pointer to the packet removed, or NULL if there were
    no packets on the queue.

--*/

{
    KIRQL irql;
    PLIST_ENTRY listEntry;

    //
    // Remove the next packet from the queue, if there is one.
    //

    ExAcquireSpinLock( &IopErrorLogLock, &irql );
    if (IsListEmpty( &IopErrorLogListHead )) {

        //
        // Indicate no more work will be done in the context of this worker
        // thread and indicate to the caller that no packets were located.
        //

        IopErrorLogPortPending = FALSE;
        listEntry = (PLIST_ENTRY) NULL;
    } else {

        //
        // Remove the next packet from the head of the list.
        //

        listEntry = RemoveHeadList( &IopErrorLogListHead );
    }

    ExReleaseSpinLock( &IopErrorLogLock, irql );
    return listEntry;
}

VOID
IopErrorLogQueueRequest(
    VOID
    )

/*++

Routine Description:

    This routine sets a timer to fire after 30 seconds.  The timer queues a
    DPC which then queues a worker thread request to run the error log thread
    routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LARGE_INTEGER interval;
    PIOP_ERROR_LOG_CONTEXT context;

    PAGED_CODE();

    //
    // Allocate a context block which will contain the timer and the DPC.
    //

    context = ExAllocatePool( NonPagedPool, sizeof( IOP_ERROR_LOG_CONTEXT ) );

    if (context == NULL) {

        //
        // The context block could not be allocated. Clear the error log
        // pending bit. If there is another error then a new attempt will
        // be made.  Note the spinlock does not need to be held here since
        // new attempt should be made later not right now, so if another
        // error log packet is currently being queue, it waits with the
        // others.
        //

        IopErrorLogPortPending = FALSE;
        return;
    }

    KeInitializeDpc( &context->ErrorLogDpc,
                     IopErrorLogDpc,
                     NULL );

    KeInitializeTimer( &context->ErrorLogTimer );

    //
    // Delay for 30 seconds and try for the port again.
    //

    interval.QuadPart = - 10 * 1000 * 1000 * 30;

    //
    // Set the timer to fire a DPC in 30 seconds.
    //

    KeSetTimer( &context->ErrorLogTimer, interval, &context->ErrorLogDpc );
}

VOID
IopErrorLogRequeueEntry(
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This routine puts an error packet back at the head of the error log queue
    since it cannot be processed at the moment.

Arguments:

    ListEntry - Supplies a pointer to the packet to be placed back onto the
        error log queue.

Return Value:

    None.

--*/

{
    KIRQL irql;

    //
    // Simply insert the packet back onto the head of the queue, indicate that
    // the error log port is not connected, queue a request to check again
    // soon, and return.
    //

    ExAcquireSpinLock( &IopErrorLogLock, &irql );
    InsertHeadList( &IopErrorLogListHead, ListEntry );
    ErrorLogPortConnected = FALSE;
    ExReleaseSpinLock( &IopErrorLogLock, irql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module contains the code to implement the NtFsControlFile system
    service for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 16-Oct-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtFsControlFile)
#endif

NTSTATUS
NtFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the file system associated with the file
    handle.  It is up to the file system to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        file system.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the file system.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\iodata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iodata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    Darryl E. Havens (darrylh) April 27, 1989

Revision History:


--*/

#include "iomgr.h"

//
// Define the global read/write data for the I/O system.
//
// The following lock is used to guard access to the CancelRoutine address
// in IRPs.  It must be locked to set the address of a routine, clear the
// address of a routine, when a cancel routine is invoked, or when
// manipulating any structure that will set a cancel routine address in
// a packet.
//

// extern KSPIN_LOCK IopCancelSpinLock;

//
// The following lock is used to guard access to VPB data structures.  It
// must be held each time the reference count, mount flag, or device object
// fields of a VPB are manipulated.
//

// extern KSPIN_LOCK IopVpbSpinLock;

//
// The following lock is used to guard access to the I/O system database for
// unloading drivers.  It must be locked to increment or decrement device
// reference counts and to set the unload pending flag in a device object.
// The lock is allocated by the I/O system during phase 1 initialization.
//
// This lock is also used to decrement the count of Associated IRPs for a
// given Master IRP.
//

// extern KSPIN_LOCK IopDatabaseLock;

//
// The following resource is used to control access to the I/O system's
// database.  It allows exclusive access to the file system queue for
// registering a file system as well as shared access to the same when
// searching for a file system to mount a volume on some media.  The resource
// is initialized by the I/O system initialization code during phase 1
// initialization.
//

ERESOURCE IopDatabaseResource;

//
// The following resource is used to control access to security descriptors
// on devices.  It allows multiple readers to perform security checks and
// queries on device security, but only a single writer to modify the security
// on a device at a time.
//

ERESOURCE IopSecurityResource;

//
// The following queue header contains the list of disk file systems currently
// loaded into the system.  The list actually contains the device objects
// for each of the file systems in the system.  Access to this queue is
// protected using the IopDatabaseResource for exclusive (write) or shared
// (read) access locks.
//

LIST_ENTRY IopDiskFileSystemQueueHead;

//
// The following queue header contains the list of CD ROM file systems currently
// loaded into the system.  The list actually contains the device objects
// for each of the file systems in the system.  Access to this queue is
// protected using the IopDatabaseResource for exclusive (write) or shared
// (read) access locks.
//

LIST_ENTRY IopCdRomFileSystemQueueHead;

//
// The following queue header contains the list of network file systems
// (redirectors) currently loaded into the system.  The list actually
// contains the device objects for each of the network file systems in the
// system.  Access to this queue is protected using the IopDatabaseResource
// for exclusive (write) or shared (read) access locks.
//

LIST_ENTRY IopNetworkFileSystemQueueHead;

//
// The following queue header contains the list of tape file systems currently
// loaded into the system.  The list actually contains the device objects
// for each of the file systems in the system.  Access to this queue is
// protected using the IopDatabaseResource for exclusive (write) or shared
// (read) access locks.
//

LIST_ENTRY IopTapeFileSystemQueueHead;

//
// The following queue header contains the list of boot drivers that have
// registered for a call back once all devices have been enumerated.
//

LIST_ENTRY IopBootDriverReinitializeQueueHead;

//
// The following queue header contains the list of drivers that have
// registered reinitialization routines.
//

LIST_ENTRY IopDriverReinitializeQueueHead;

//
// The following queue headers contain the lists of the drivers that have
// registered shutdown notification routines.
//

LIST_ENTRY IopNotifyShutdownQueueHead;
LIST_ENTRY IopNotifyLastChanceShutdownQueueHead;

//
// The following queue header contains the list of the driver that have
// registered to be notified when a file system registers or unregisters itself
// as an active file system.
//

LIST_ENTRY IopFsNotifyChangeQueueHead;

//
// The following are the lookaside lists used to keep track of the two I/O
// Request Packet (IRP), the Memory Descriptor List (MDL) Lookaside list, and
// the I/O Completion List (ICP) Lookaside list.
//
// The "large" IRP contains 4 stack locations, the maximum in the SDK, and the
// "small" IRP contains a single entry, the most common case for devices other
// than disks and network devices.
//

GENERAL_LOOKASIDE IopCompletionLookasideList;
GENERAL_LOOKASIDE IopLargeIrpLookasideList;
GENERAL_LOOKASIDE IopSmallIrpLookasideList;
GENERAL_LOOKASIDE IopMdlLookasideList;
ULONG IopLargeIrpStackLocations;

//
// The following spinlock is used to control access to the I/O system's error
// log database.  It is initialized by the I/O system initialization code when
// the system is being initialized.  This lock must be owned in order to insert
// or remove entries from either the free or entry queue.
//

// extern KSPIN_LOCK IopErrorLogLock;

//
// The following is the list head for all error log entries in the system which
// have not yet been sent to the error log process.  Entries are written placed
// onto the list by the IoWriteElEntry procedure.
//

LIST_ENTRY IopErrorLogListHead;

//
// The following is used to track how much memory is allocated to I/O error log
// packets.  The spinlock is used to protect this variable.
//

LONG IopErrorLogAllocation;
// extern KSPIN_LOCK IopErrorLogAllocationLock;

//
// The following spinlock is used by the I/O system to synchronize examining
// the thread field of an I/O Request Packet so that the request can be
// queued as a special kernel APC to the thread.  The reason that the
// spinlock must be used is for cases when the request times out, and so
// the thread has been permitted to possibly exit.
//

// extern KSPIN_LOCK IopCompletionLock;

//
// The following global contains the queue of informational hard error
// pop-ups.
//

IOP_HARD_ERROR_QUEUE IopHardError;

//
// The following global is non-null when there is a pop-up on the screen
// waiting for user action.  It points to that packet.
//

PIOP_HARD_ERROR_PACKET IopCurrentHardError;

//
// The following are used to implement the I/O system's one second timer.
// The lock protects access to the queue, the queue contains an entry for
// each driver that needs to be invoked, and the timer and DPC data
// structures are used to actually get the internal timer routine invoked
// once every second.  The count is used to maintain the number of timer
// entries that actually indicate that the driver is to be invoked.
//

// extern KSPIN_LOCK IopTimerLock;
LIST_ENTRY IopTimerQueueHead;
KDPC IopTimerDpc;
KTIMER IopTimer;
ULONG IopTimerCount;

//
// The following are the global pointers for the Object Type Descriptors that
// are created when each of the I/O specific object types are created.
//

POBJECT_TYPE IoAdapterObjectType;
POBJECT_TYPE IoControllerObjectType;
POBJECT_TYPE IoCompletionObjectType;
POBJECT_TYPE IoDeviceObjectType;
POBJECT_TYPE IoDriverObjectType;
POBJECT_TYPE IoDeviceHandlerObjectType;
POBJECT_TYPE IoFileObjectType;
ULONG        IoDeviceHandlerObjectSize;

//
// The following is a global lock and counters for I/O operations requested
// on a system-wide basis.  The first three counters simply track the number
// of read, write, and other types of operations that have been requested.
// The latter three counters track the actual number of bytes that have been
// transferred throughout the system.
//

// extern KSPIN_LOCK IoStatisticsLock;
ULONG IoReadOperationCount;
ULONG IoWriteOperationCount;
ULONG IoOtherOperationCount;
LARGE_INTEGER IoReadTransferCount;
LARGE_INTEGER IoWriteTransferCount;
LARGE_INTEGER IoOtherTransferCount;

//
// The following is the base pointer for the crash dump control block that is
// used to control dumping all of physical memory to the paging file after a
// system crash.  And, the checksum for the dump control block is also declared.
//

PDUMP_CONTROL_BLOCK IopDumpControlBlock;
ULONG IopDumpControlBlockChecksum;

//
// The following are the spin lock and event that allow the I/O system to
// implement fast file object locks.
//

KEVENT IopFastLockEvent;

//
// The following is a monotonically increasing number (retrieved via
// InterlockedIncrement) that is used by IoCreateDevice to automatically
// generate a device object name when the FILE_AUTOGENERATED_DEVICE_NAME
// device characteristic is specified.
//

LONG IopUniqueDeviceObjectNumber;

//
// IoRemoteBootClient indicates whether the system was booted as a remote
// boot client.
//

BOOLEAN IoRemoteBootClient;

//
// Counts number of Fs registration/unregistrations
//
ULONG   IopFsRegistrationOps;

//
// Storage for the registry Key.
// By default this value is true.
//

ULONG   IopFailZeroAccessCreate = TRUE;

//
// Reserve IRP allocator for paging reads.
//
IOP_RESERVE_IRP_ALLOCATOR  IopReserveIrpAllocator;

#if defined(REMOTE_BOOT)
//
// The following indicates whether or not the Client Side Caching subsystem
// was successfully initialized.
//

BOOLEAN IoCscInitializationFailed;
#endif

//
// The following are used to synchronize with the link tracking service while establishing a connection.
//

KEVENT IopLinkTrackingPortObject;
LINK_TRACKING_PACKET IopLinkTrackingPacket;

IOP_IRP_STACK_PROFILER  IopIrpStackProfiler;

//
// Function pointers of key IO routines.
// The functions need to be in their own cache lines as they are readonly and
// never modified after boot.
//

#define CACHE_SIZE      128
UCHAR                   IopPrePadding[CACHE_SIZE] = {0};
PIO_CALL_DRIVER         pIofCallDriver = 0;
PIO_COMPLETE_REQUEST    pIofCompleteRequest = 0;
PIO_ALLOCATE_IRP        pIoAllocateIrp = 0;
PIO_FREE_IRP            pIoFreeIrp = 0;
UCHAR                   IopPostPadding[CACHE_SIZE] = {0};

//*********
//
// Note:  All of the following data is potentially pageable, depending on the
//        target platform.
//
//*********

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// The following are used to store the handle and a pointer to the referenced

// whenever a file is moved across systems.
//

PVOID IopLinkTrackingServiceObject;
PKEVENT IopLinkTrackingServiceEvent;
HANDLE IopLinkTrackingServiceEventHandle;

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtQueryInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryOperationLength[] =
          {
            0,
            0,                                         //  1 FileDirectoryInformation
            0,                                         //  2 FileFullDirectoryInformation
            0,                                         //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),          //  4 FileBasicInformation
            sizeof( FILE_STANDARD_INFORMATION ),       //  5 FileStandardInformation
            sizeof( FILE_INTERNAL_INFORMATION ),       //  6 FileInternalInformation
            sizeof( FILE_EA_INFORMATION ),             //  7 FileEaInformation
            sizeof( FILE_ACCESS_INFORMATION ),         //  8 FileAccessInformation
            sizeof( FILE_NAME_INFORMATION ),           //  9 FileNameInformation
            0,                                         // 10 FileRenameInformation
            0,                                         // 11 FileLinkInformation
            0,                                         // 12 FileNamesInformation
            0,                                         // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),       // 14 FilePositionInformation
            0,                                         // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),           // 16 FileModeInformation
            sizeof( FILE_ALIGNMENT_INFORMATION ),      // 17 FileAlignmentInformation
            sizeof( FILE_ALL_INFORMATION ),            // 18 FileAllInformation
            0,                                         // 19 FileAllocationInformation
            0,                                         // 20 FileEndOfFileInformation
            sizeof( FILE_NAME_INFORMATION ),           // 21 FileAlternateNameInformation
            sizeof( FILE_STREAM_INFORMATION ),         // 22 FileStreamInformation
            sizeof( FILE_PIPE_INFORMATION ),           // 23 FilePipeInformation
            sizeof( FILE_PIPE_LOCAL_INFORMATION ),     // 24 FilePipeLocalInformation
            sizeof( FILE_PIPE_REMOTE_INFORMATION ),    // 25 FilePipeRemoteInformation
            sizeof( FILE_MAILSLOT_QUERY_INFORMATION ), // 26 FileMailslotQueryInformation
            0,                                         // 27 FileMailslotSetInformation
            sizeof( FILE_COMPRESSION_INFORMATION ),    // 28 FileCompressionInformation
            sizeof( FILE_OBJECTID_INFORMATION ),       // 29 FileObjectIdInformation
            0,                                         // 30 FileCompletionInformation
            0,                                         // 31 FileMoveClusterInformation
            sizeof( FILE_QUOTA_INFORMATION ),          // 32 FileQuotaInformation
            sizeof( FILE_REPARSE_POINT_INFORMATION ),  // 33 FileReparsePointInformation
            sizeof( FILE_NETWORK_OPEN_INFORMATION),    // 34 FileNetworkOpenInformation
            sizeof( FILE_ATTRIBUTE_TAG_INFORMATION),   // 35 FileAttributeTagInformation
            0,                                         // 36 FileTrackingInformation
            0,                                         // 37 FileIdBothDiretoryInformation
            0,                                         // 38 FileIdFullDiretoryInformation
            0,                                         // 39 FileValidDataLengthInformation
            0,                                         // 40 FileShortNameInformation
            0xff                                       //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtSetInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopSetOperationLength[] =
          {
            0,
            0,                                            //  1 FileDirectoryInformation
            0,                                            //  2 FileFullDirectoryInformation
            0,                                            //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),             //  4 FileBasicInformation
            0,                                            //  5 FileStandardInformation
            0,                                            //  6 FileInternalInformation
            0,                                            //  7 FileEaInformation
            0,                                            //  8 FileAccessInformation
            0,                                            //  9 FileNameInformation
            sizeof( FILE_RENAME_INFORMATION ),            // 10 FileRenameInformation
            sizeof( FILE_LINK_INFORMATION ),              // 11 FileLinkInformation
            0,                                            // 12 FileNamesInformation
            sizeof( FILE_DISPOSITION_INFORMATION ),       // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),          // 14 FilePositionInformation
            0,                                            // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),              // 16 FileModeInformation
            0,                                            // 17 FileAlignmentInformation
            0,                                            // 18 FileAllInformation
            sizeof( FILE_ALLOCATION_INFORMATION ),        // 19 FileAllocationInformation
            sizeof( FILE_END_OF_FILE_INFORMATION ),       // 20 FileEndOfFileInformation
            0,                                            // 21 FileAlternateNameInformation
            0,                                            // 22 FileStreamInformation
            sizeof( FILE_PIPE_INFORMATION ),              // 23 FilePipeInformation
            0,                                            // 24 FilePipeLocalInformation
            sizeof( FILE_PIPE_REMOTE_INFORMATION ),       // 25 FilePipeRemoteInformation
            0,                                            // 26 FileMailslotQueryInformation
            sizeof( FILE_MAILSLOT_SET_INFORMATION ),      // 27 FileMailslotSetInformation
            0,                                            // 28 FileCompressionInformation
            sizeof( FILE_OBJECTID_INFORMATION ),          // 29 FileObjectIdInformation
            sizeof( FILE_COMPLETION_INFORMATION ),        // 30 FileCompletionInformation
            sizeof( FILE_MOVE_CLUSTER_INFORMATION ),      // 31 FileMoveClusterInformation
            sizeof( FILE_QUOTA_INFORMATION ),             // 32 FileQuotaInformation
            0,                                            // 33 FileReparsePointInformation
            0,                                            // 34 FileNetworkOpenInformation
            0,                                            // 35 FileAttributeTagInformation
            sizeof( FILE_TRACKING_INFORMATION ),          // 36 FileTrackingInformation
            0,                                            // 37 FileIdBothDiretoryInformation
            0,                                            // 38 FileIdFullDiretoryInformation
            sizeof( FILE_VALID_DATA_LENGTH_INFORMATION ), // 39 FileValidDataLengthInformation
            sizeof( FILE_NAME_INFORMATION ),              // 40 FileShortNameInformation
            0xff                                          //    FileMaximumInformation
          };

//
// The following array specifies the alignment requirement of both all query
// and set operations, including directory operations, but not FS operations.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQuerySetAlignmentRequirement[] =
          {
            0,
            sizeof( LONGLONG ), //  1 FileDirectoryInformation
            sizeof( LONGLONG ), //  2 FileFullDirectoryInformation
            sizeof( LONGLONG ), //  3 FileBothDirectoryInformation
            sizeof( LONGLONG ), //  4 FileBasicInformation
            sizeof( LONGLONG ), //  5 FileStandardInformation
            sizeof( LONGLONG ), //  6 FileInternalInformation
            sizeof( LONG ),     //  7 FileEaInformation
            sizeof( LONG ),     //  8 FileAccessInformation
            sizeof( LONG ),     //  9 FileNameInformation
            sizeof( LONG ),     // 10 FileRenameInformation
            sizeof( LONG ),     // 11 FileLinkInformation
            sizeof( LONG ),     // 12 FileNamesInformation
            sizeof( CHAR ),     // 13 FileDispositionInformation
            sizeof( LONGLONG ), // 14 FilePositionInformation
            sizeof( LONG ),     // 15 FileFullEaInformation
            sizeof( LONG ),     // 16 FileModeInformation
            sizeof( LONG ),     // 17 FileAlignmentInformation
            sizeof( LONGLONG ), // 18 FileAllInformation
            sizeof( LONGLONG ), // 19 FileAllocationInformation
            sizeof( LONGLONG ), // 20 FileEndOfFileInformation
            sizeof( LONG ),     // 21 FileAlternateNameInformation
            sizeof( LONGLONG ), // 22 FileStreamInformation
            sizeof( LONG ),     // 23 FilePipeInformation
            sizeof( LONG ),     // 24 FilePipeLocalInformation
            sizeof( LONG ),     // 25 FilePipeRemoteInformation
            sizeof( LONGLONG ), // 26 FileMailslotQueryInformation
            sizeof( LONG ),     // 27 FileMailslotSetInformation
            sizeof( LONGLONG ), // 28 FileCompressionInformation
            sizeof( LONG ),     // 29 FileObjectIdInformation
            sizeof( LONG ),     // 30 FileCompletionInformation
            sizeof( LONG ),     // 31 FileMoveClusterInformation
            sizeof( LONG ),     // 32 FileQuotaInformation
            sizeof( LONG ),     // 33 FileReparsePointInformation
            sizeof( LONGLONG ), // 34 FileNetworkOpenInformation
            sizeof( LONG ),     // 35 FileAttributeTagInformation
            sizeof( LONG ),     // 36 FileTrackingInformation
            sizeof( LONGLONG ), // 37 FileIdBothDiretoryInformation
            sizeof( LONGLONG ), // 38 FileIdFullDiretoryInformation
            sizeof( LONGLONG ), // 39 FileValidDataLengthInformation
            sizeof( LONG ),     // 40 FileShortNameInformation
            0xff                //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryOperationAccess[] =
         {
            0,
            0,                    //  1 FileDirectoryInformation
            0,                    //  2 FileFullDirectoryInformation
            0,                    //  3 FileBothDirectoryInformation
            FILE_READ_ATTRIBUTES, //  4 FileBasicInformation
            0,                    //  5 FileStandardInformation
            0,                    //  6 FileInternalInformation
            0,                    //  7 FileEaInformation
            0,                    //  8 FileAccessInformation
            0,                    //  9 FileNameInformation
            0,                    // 10 FileRenameInformation
            0,                    // 11 FileLinkInformation
            0,                    // 12 FileNamesInformation
            0,                    // 13 FileDispositionInformation
            0,                    // 14 FilePositionInformation
            FILE_READ_EA,         // 15 FileFullEaInformation
            0,                    // 16 FileModeInformation
            0,                    // 17 FileAlignmentInformation
            FILE_READ_ATTRIBUTES, // 18 FileAllInformation
            0,                    // 19 FileAllocationInformation
            0,                    // 20 FileEndOfFileInformation
            0,                    // 21 FileAlternateNameInformation
            0,                    // 22 FileStreamInformation
            FILE_READ_ATTRIBUTES, // 23 FilePipeInformation
            FILE_READ_ATTRIBUTES, // 24 FilePipeLocalInformation
            FILE_READ_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                    // 26 FileMailslotQueryInformation
            0,                    // 27 FileMailslotSetInformation
            0,                    // 28 FileCompressionInformation
            0,                    // 29 FileObjectIdInformation
            0,                    // 30 FileCompletionInformation
            0,                    // 31 FileMoveClusterInformation
            0,                    // 32 FileQuotaInformation
            0,                    // 33 FileReparsePointInformation
            FILE_READ_ATTRIBUTES, // 34 FileNetworkOpenInformation
            FILE_READ_ATTRIBUTES, // 35 FileAttributeTagInformation
            0,                    // 36 FileTrackingInformation
            0,                    // 37 FileIdBothDiretoryInformation
            0,                    // 38 FileIdFullDiretoryInformation
            0,                    // 39 FileValidDataLengthInformation
            0,                    // 40 FileShortNameInformation
            0xffffffff            //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtSetXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FILE_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopSetOperationAccess[] =
         {
            0,
            0,                     //  1 FileDirectoryInformation
            0,                     //  2 FileFullDirectoryInformation
            0,                     //  3 FileBothDirectoryInformation
            FILE_WRITE_ATTRIBUTES, //  4 FileBasicInformation
            0,                     //  5 FileStandardInformation
            0,                     //  6 FileInternalInformation
            0,                     //  7 FileEaInformation
            0,                     //  8 FileAccessInformation
            0,                     //  9 FileNameInformation
            DELETE,                // 10 FileRenameInformation
            0,                     // 11 FileLinkInformation
            0,                     // 12 FileNamesInformation
            DELETE,                // 13 FileDispositionInformation
            0,                     // 14 FilePositionInformation
            FILE_WRITE_EA,         // 15 FileFullEaInformation
            0,                     // 16 FileModeInformation
            0,                     // 17 FileAlignmentInformation
            0,                     // 18 FileAllInformation
            FILE_WRITE_DATA,       // 19 FileAllocationInformation
            FILE_WRITE_DATA,       // 20 FileEndOfFileInformation
            0,                     // 21 FileAlternateNameInformation
            0,                     // 22 FileStreamInformation
            FILE_WRITE_ATTRIBUTES, // 23 FilePipeInformation
            0,                     // 24 FilePipeLocalInformation
            FILE_WRITE_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                     // 26 FileMailslotQueryInformation
            0,                     // 27 FileMailslotSetInformation
            0,                     // 28 FileCompressionInformation
            0,                     // 29 FileObjectIdInformation
            0,                     // 30 FileCompletionInformation
            FILE_WRITE_DATA,       // 31 FileMoveClusterInformation
            0,                     // 32 FileQuotaInformation
            0,                     // 33 FileReparsePointInformation
            0,                     // 34 FileNetworkOpenInformation
            0,                     // 35 FileAttributeTagInformation
            FILE_WRITE_DATA,       // 36 FileTrackingInformation
            0,                     // 37 FileIdBothDiretoryInformation
            0,                     // 38 FileIdFullDiretoryInformation
            FILE_WRITE_DATA,       // 39 FileValidDataLengthInformation
            DELETE,                // 40 FileShortNameInformation
            0xffffffff             //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FsInformation
// buffer for an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryFsOperationLength[] =
          {
            0,
            sizeof( FILE_FS_VOLUME_INFORMATION ),    // 1 FileFsVolumeInformation
            0,                                       // 2 FileFsLabelInformation
            sizeof( FILE_FS_SIZE_INFORMATION ),      // 3 FileFsSizeInformation
            sizeof( FILE_FS_DEVICE_INFORMATION ),    // 4 FileFsDeviceInformation
            sizeof( FILE_FS_ATTRIBUTE_INFORMATION ), // 5 FileFsAttributeInformation
            sizeof( FILE_FS_CONTROL_INFORMATION ),   // 6 FileFsControlInformation
            sizeof( FILE_FS_FULL_SIZE_INFORMATION ), // 7 FileFsFullSizeInformation
            sizeof( FILE_FS_OBJECTID_INFORMATION ),  // 8 FileFsObjectIdInformation
            sizeof( FILE_FS_DRIVER_PATH_INFORMATION),// 9 FileFsDriverPathInformation
            0xff                                     //   FileFsMaximumInformation
          };

//
// The following array specifies the minimum length of the FsInformation
// buffer for an NtSetVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopSetFsOperationLength[] =
          {
            0,
            0,                                     // 1 FileFsVolumeInformation
            sizeof( FILE_FS_LABEL_INFORMATION ),   // 2 FileFsLabelInformation
            0,                                     // 3 FileFsSizeInformation
            0,                                     // 4 FileFsDeviceInformation
            0,                                     // 5 FileFsAttributeInformation
            sizeof( FILE_FS_CONTROL_INFORMATION ), // 6 FileFsControlInformation
            0,                                     // 7 FileFsFullSizeInformation
            sizeof( FILE_FS_OBJECTID_INFORMATION ),// 8 FileFsObjectIdInformation
            0,                                     // 9 FileFsDriverPathInformation
            0xff                                   //   FileFsMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryFsOperationAccess[] =
         {
            0,
            0,              // 1 FileFsVolumeInformation [any access to file or volume]
            0,              // 2 FileFsLabelInformation [query is invalid]
            0,              // 3 FileFsSizeInformation [any access to file or volume]
            0,              // 4 FileFsDeviceInformation [any access to file or volume]
            0,              // 5 FileFsAttributeInformation [any access to file or vol]
            FILE_READ_DATA, // 6 FileFsControlInformation [vol read access]
            0,              // 7 FileFsFullSizeInformation [any access to file or volume]
            0,              // 8 FileFsObjectIdInformation [any access to file or volume]
            0,              // 9 FileFsDriverPathInformation [any access to file or volume]
            0xffffffff      //   FileFsMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtSetVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopSetFsOperationAccess[] =
         {
            0,
            0,               // 1 FileFsVolumeInformation [set is invalid]
            FILE_WRITE_DATA, // 2 FileFsLabelInformation [write access to volume]
            0,               // 3 FileFsSizeInformation [set is invalid]
            0,               // 4 FileFsDeviceInformation [set is invalid]
            0,               // 5 FileFsAttributeInformation [set is invalid]
            FILE_WRITE_DATA, // 6 FileFsControlInformation [vol write access]
            0,               // 7 FileFsFullSizeInformation [set is invalid]
            FILE_WRITE_DATA, // 8 FileFsObjectIdInformation [write access to volume]
            0,               // 9 FileFsDriverPathInformation [set is invalid]
            0xffffffff       //   FileFsMaximumInformation
          };

//
// The following array specifies the alignment requirements for all FS query
// and set information services.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQuerySetFsAlignmentRequirement[] =
         {
            0,
            sizeof( LONGLONG ), // 1 FileFsVolumeInformation
            sizeof( LONG ),     // 2 FileFsLabelInformation
            sizeof( LONGLONG ), // 3 FileFsSizeInformation
            sizeof( LONG ),     // 4 FileFsDeviceInformation
            sizeof( LONG ),     // 5 FileFsAttributeInformation
            sizeof( LONGLONG ), // 6 FileFsControlInformation
            sizeof( LONGLONG ), // 7 FileFsFullSizeInformation
            sizeof( LONGLONG ), // 8 FileFsObjectIdInformation
            sizeof( LONGLONG ), // 9 FileFsDriverPathInformation
            0xff                //   FileFsMaximumInformation
          };

PVOID IopLoaderBlock = NULL;

const WCHAR IopWstrRaw[]                  = L".Raw";
const WCHAR IopWstrTranslated[]           = L".Translated";
const WCHAR IopWstrBusRaw[]               = L".Bus.Raw";
const WCHAR IopWstrBusTranslated[]        = L".Bus.Translated";
const WCHAR IopWstrOtherDrivers[]         = L"OtherDrivers";

const WCHAR IopWstrAssignedResources[]    = L"AssignedSystemResources";
const WCHAR IopWstrRequestedResources[]   = L"RequestedSystemResources";
const WCHAR IopWstrSystemResources[]      = L"Control\\SystemResources";
const WCHAR IopWstrReservedResources[]    = L"ReservedResources";
const WCHAR IopWstrAssignmentOrdering[]   = L"AssignmentOrdering";
const WCHAR IopWstrBusValues[]            = L"BusValues";
UNICODE_STRING IoArcBootDeviceName  = { 0 };
UNICODE_STRING IoArcHalDeviceName  = { 0 };
PUCHAR IoLoaderArcBootDeviceName = NULL;

//
// Initialization time data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const WCHAR IopWstrHal[]                  = L"Hardware Abstraction Layer";
const WCHAR IopWstrSystem[]               = L"System Resources";
const WCHAR IopWstrPhysicalMemory[]       = L"Physical Memory";
const WCHAR IopWstrSpecialMemory[]        = L"Reserved";
const WCHAR IopWstrLoaderReservedMemory[] = L"Loader Reserved";

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\internal.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This module contains the internal subroutines used by the I/O system.

Author:

    Darryl E. Havens (darrylh) 18-Apr-1989
    Nar Ganapathy (narg) 1/1/1999

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "iomgr.h"
#pragma hdrstop
#include <ioevent.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#pragma warning(disable:4221)   // cannot be initialized using address of automatic variable
#pragma warning(disable:4204)   // non-constant aggreate initializer

//PLJTMP
#if defined(_X86_)
VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );
#endif
//PLJTMPend

#define IsFileLocal( FileObject ) ( !((FileObject)->DeviceObject->Characteristics & FILE_REMOTE_DEVICE) )

#define IO_MAX_ALLOCATE_IRP_TRIES   30*60    // Try for 7 minutes
#define IO_INFINITE_RETRIES         -1       // Try for ever

typedef LINK_TRACKING_INFORMATION FILE_VOLUMEID_WITH_TYPE, *PFILE_VOLUMEID_WITH_TYPE;

typedef struct _TRACKING_BUFFER {
    FILE_TRACKING_INFORMATION TrackingInformation;
    UCHAR Buffer[256];
} TRACKING_BUFFER, *PTRACKING_BUFFER;

typedef struct _REMOTE_LINK_BUFFER {
    REMOTE_LINK_TRACKING_INFORMATION TrackingInformation;
    UCHAR Buffer[256];
} REMOTE_LINK_BUFFER, *PREMOTE_LINK_BUFFER;

PIRP IopDeadIrp;

NTSTATUS
IopResurrectDriver(
    PDRIVER_OBJECT DriverObject
    );

VOID
IopUserRundown(
    IN PKAPC Apc
    );

VOID
IopMarshalIds(
    OUT PTRACKING_BUFFER TrackingBuffer,
    IN  PFILE_VOLUMEID_WITH_TYPE  TargetVolumeId,
    IN  PFILE_OBJECTID_BUFFER  TargetObjectId,
    IN  PFILE_TRACKING_INFORMATION TrackingInfo
    );

VOID
IopUnMarshalIds(
    IN  FILE_TRACKING_INFORMATION * TrackingInformation,
    OUT FILE_VOLUMEID_WITH_TYPE * TargetVolumeId,
    OUT GUID * TargetObjectId,
    OUT GUID * TargetMachineId
    );

NTSTATUS
IopBootLogToFile(
    PUNICODE_STRING String
    );

VOID
IopCopyBootLogRegistryToFile(
    VOID
    );

#ifdef ALLOC_PRAGMA

VOID
IopRaiseHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );
VOID
IopApcHardError(
    IN PVOID StartContext
    );

PVPB
IopMountInitializeVpb(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PDEVICE_OBJECT  AttachedDevice,
    IN  ULONG           RawMountOnly
    );

#pragma alloc_text(PAGE, IopAbortRequest)
#pragma alloc_text(PAGE, IopAcquireFileObjectLock)
#pragma alloc_text(PAGE, IopAllocateIrpCleanup)
#pragma alloc_text(PAGE, IopCallDriverReinitializationRoutines)
#pragma alloc_text(PAGE, IopCancelAlertedRequest)
#pragma alloc_text(PAGE, IopCheckGetQuotaBufferValidity)
#pragma alloc_text(PAGE, IopConnectLinkTrackingPort)
#pragma alloc_text(PAGE, IopDeallocateApc)
#pragma alloc_text(PAGE, IopExceptionCleanup)
#pragma alloc_text(PAGE, IopGetDriverNameFromKeyNode)
#pragma alloc_text(PAGE, IopGetFileInformation)
#pragma alloc_text(PAGE, IopGetRegistryKeyInformation)
#pragma alloc_text(PAGE, IopGetRegistryValue)
#pragma alloc_text(PAGE, IopGetRegistryValues)
#pragma alloc_text(PAGE, IopGetSetObjectId)
#pragma alloc_text(PAGE, IopGetVolumeId)
#pragma alloc_text(PAGE, IopInvalidateVolumesForDevice)
#pragma alloc_text(PAGE, IopIsSameMachine)
#pragma alloc_text(PAGE, IopLoadDriver)
#pragma alloc_text(PAGE, IopLoadFileSystemDriver)
#pragma alloc_text(PAGE, IopLoadUnloadDriver)
#pragma alloc_text(PAGE, IopMountVolume)
#pragma alloc_text(PAGE, IopMarshalIds)
#pragma alloc_text(PAGE, IopOpenLinkOrRenameTarget)
#pragma alloc_text(PAGE, IopOpenRegistryKey)
#pragma alloc_text(PAGE, IopQueryXxxInformation)
#pragma alloc_text(PAGE, IopRaiseHardError)
#pragma alloc_text(PAGE, IopApcHardError)
#pragma alloc_text(PAGE, IopRaiseInformationalHardError)
#pragma alloc_text(PAGE, IopReadyDeviceObjects)
#pragma alloc_text(PAGE, IopReferenceDriverObjectByName)
#pragma alloc_text(PAGE, IopUnMarshalIds)
#pragma alloc_text(PAGE, IopSendMessageToTrackService)
#pragma alloc_text(PAGE, IopSetEaOrQuotaInformationFile)
#pragma alloc_text(PAGE, IopSetRemoteLink)
#pragma alloc_text(PAGE, IopStartApcHardError)
#pragma alloc_text(PAGE, IopSynchronousApiServiceTail)
#pragma alloc_text(PAGE, IopSynchronousServiceTail)
#pragma alloc_text(PAGE, IopTrackLink)
#pragma alloc_text(PAGE, IopUserCompletion)
#pragma alloc_text(PAGE, IopUserRundown)
#pragma alloc_text(PAGE, IopXxxControlFile)
#pragma alloc_text(PAGE, IopLookupBusStringFromID)
#pragma alloc_text(PAGE, IopSafebootDriverLoad)
#pragma alloc_text(PAGE, IopInitializeBootLogging)
#pragma alloc_text(PAGE, IopBootLog)
#pragma alloc_text(PAGE, IopCopyBootLogRegistryToFile)
#pragma alloc_text(PAGE, IopBootLogToFile)
#pragma alloc_text(PAGE, IopHardErrorThread)
#pragma alloc_text(PAGE, IopGetBasicInformationFile)
#pragma alloc_text(PAGE, IopBuildFullDriverPath)
#pragma alloc_text(PAGE, IopInitializeIrpStackProfiler)
#endif






VOID
IopAbortRequest(
    IN PKAPC Apc
    )

/*++

Routine Description:

    This routine is invoked to abort an I/O request.  It is invoked during the
    rundown of a thread.

Arguments:

    Apc - Pointer to the kernel APC structure.  This structure is contained
        within the I/O Request Packet (IRP) itself.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Invoke the normal special kernel APC routine.
    //

    IopCompleteRequest( Apc,
                        &Apc->NormalRoutine,
                        &Apc->NormalContext,
                        &Apc->SystemArgument1,
                        &Apc->SystemArgument2 );
}

NTSTATUS
IopAcquireFileObjectLock(
    IN PFILE_OBJECT FileObject,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN Alertable,
    OUT PBOOLEAN Interrupted
    )

/*++

Routine Description:

    This routine is invoked to acquire the lock for a file object whenever
    there is contention and obtaining the fast lock for the file failed.

Arguments:

    FileObject - Pointer to the file object whose lock is to be acquired.

    RequestorMode - Processor access mode of the caller.

    Alertable - Indicates whether or not the lock should be obtained in an
        alertable manner.

    Interrupted - A variable to receive a BOOLEAN that indicates whether or
        not the attempt to acquire the lock was interrupted by an alert or
        an APC.

Return Value:

    The function status is the final status of the operation.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Assume that the function will not be interrupted by an alert or an
    // APC while attempting to acquire the lock.
    //

    *Interrupted = FALSE;

    //
    // Loop attempting to acquire the lock for the file object.
    //

    InterlockedIncrement ((PLONG) &FileObject->Waiters);

    for (;;) {
        if (!FileObject->Busy) {

            //
            // The file object appears to be un-owned, try to acquire it
            //

            if ( InterlockedExchange( (PLONG) &FileObject->Busy, (ULONG) TRUE ) == FALSE ) {

                //
                // Object was acquired. Remove our count and return success
                //

                ObReferenceObject(FileObject);
                InterlockedDecrement ((PLONG) &FileObject->Waiters);
                return STATUS_SUCCESS;
            }
        }

        //
        // Wait for the event that indicates that the thread that currently
        // owns the file object has released it.
        //

        status = KeWaitForSingleObject( &FileObject->Lock,
                                        Executive,
                                        RequestorMode,
                                        Alertable,
                                        (PLARGE_INTEGER) NULL );

        //
        // If the above wait was interrupted, then indicate so and return.
        // Before returning, however, check the state of the ownership of
        // the file object itself.  If it is not currently owned (the busy
        // flag is clear), then check to see whether or not there are any
        // other waiters.  If so, then set the event to the signaled state
        // again so that they wake up and check the state of the busy flag.
        //

        if (status == STATUS_USER_APC || status == STATUS_ALERTED) {
            InterlockedDecrement ((PLONG) &FileObject->Waiters);

            if (!FileObject->Busy  &&  FileObject->Waiters) {
                KeSetEvent( &FileObject->Lock, 0, FALSE );

            }
            *Interrupted = TRUE;
            return status;
        }
    }
}


VOID
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked internally by those system services that attempt
    to allocate an IRP and fail.  This routine cleans up the file object
    and any event object that has been references and releases any locks
    that were taken out.

Arguments:

    FileObject - Pointer to the file object being worked on.

    EventObject - Optional pointer to a referenced event to be dereferenced.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Begin by dereferencing the event, if one was specified.
    //

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    //
    // Release the synchronization semaphore if it is currently held and
    // dereference the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    ObDereferenceObject( FileObject );

    return;
}

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine is invoked to allocate an IRP when there are no appropriate
    packets remaining on the look-aside list, and no memory was available
    from the general non-paged pool, and yet, the code path requiring the
    packet has no way of backing out and simply returning an error.  There-
    fore, it must allocate an IRP.  Hence, this routine is called to allocate
    that packet.

Arguments:

    StackSize - Supplies the number of IRP I/O stack locations that the
        packet must have when allocated.

Return Value:

    A pointer to the allocated I/O Request Packet.

--*/

{
    PIRP irp;
    LONG  numTries;
    LARGE_INTEGER interval;

    //
    // Attempt to allocate the IRP normally and failing that,
    // wait a second and try again. 
    //

    numTries = IO_INFINITE_RETRIES;

    irp = IoAllocateIrp(StackSize, FALSE);

    while (!irp && numTries)  {

        interval.QuadPart = -1000 * 1000 * 10; // 10 Msec.
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
        irp = IoAllocateIrp(StackSize, FALSE);
        if (numTries != IO_INFINITE_RETRIES) {
            numTries--;
        }
    }


    return irp;
}

VOID
IopApcHardError(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is invoked when we need to do a hard error pop-up, but the
    Irp's originating thread is at APC level, ie. IoPageRead.  We in a special
    purpose thread that will go away when the user responds to the pop-up.

Arguments:

    StartContext - Startup context, contains a IOP_APC_HARD_ERROR_PACKET.

Return Value:

    None.

--*/

{
    PIOP_APC_HARD_ERROR_PACKET packet;

    packet = StartContext;

    IopRaiseHardError( packet->Irp, packet->Vpb, packet->RealDeviceObject );

    ExFreePool( packet );
}


VOID
IopCancelAlertedRequest(
    IN PKEVENT Event,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked when a synchronous I/O operation that is blocked in
    the I/O system needs to be canceled because the thread making the request has
    either been alerted because it is going away or because of a CTRL/C.  This
    routine carefully attempts to work its way out of the current operation so
    that local events or other local data will not be accessed once the service
    being interrupted returns.

Arguments:

    Event - The address of a kernel event that will be set to the Signaled state
        by I/O completion when the request is complete.

    Irp - Pointer to the I/O Request Packet (IRP) representing the current request.

Return Value:

    None.

--*/

{
    KIRQL irql;
    LARGE_INTEGER deltaTime;
    BOOLEAN canceled;

    PAGED_CODE();

    //
    // Begin by blocking special kernel APCs so that the request cannot
    // complete.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    //
    // Check the state of the event to determine whether or not the
    // packet has already been completed.
    //

    if (KeReadStateEvent( Event ) == 0) {

        //
        // The packet has not been completed, so attempt to cancel it.
        //

        canceled = IoCancelIrp( Irp );

        KeLowerIrql( irql );

        if (canceled) {

            //
            // The packet had a cancel routine, so it was canceled.  Loop,
            // waiting for the packet to complete.  This should occur almost
            // immediately.
            //

            deltaTime.QuadPart = - 10 * 1000 * 10;

            while (KeReadStateEvent( Event ) == 0) {

                KeDelayExecutionThread( KernelMode, FALSE, &deltaTime );

            }

        } else {

            //
            // The packet did not have a cancel routine, so simply wait for
            // the event to be set to the Signaled state.  This will save
            // CPU time by not looping, since it is not known when the packet
            // will actually complete.  Note, however, that the cancel flag
            // is set in the packet, so should a driver examine the flag
            // at some point in the future, it will immediately stop
            // processing the request.
            //

            (VOID) KeWaitForSingleObject( Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );

        }

    } else {

        //
        // The packet has already been completed, so simply lower the
        // IRQL back to its original value and exit.
        //

        KeLowerIrql( irql );

    }
}

NTSTATUS
IopCheckGetQuotaBufferValidity(
    IN PFILE_GET_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG_PTR ErrorOffset
    )

/*++

Routine Description:

    This routine checks the validity of the specified get quota buffer to
    guarantee that its format is proper, no fields hang over, that it is
    not recursive, etc.

Arguments:

    QuotaBuffer - Pointer to the buffer containing the get quota structure
        array to be checked.

    QuotaLength - Specifies the length of the quota buffer.

    ErrorOffset - A variable to receive the offset of the offending entry
        in the quota buffer if an error is incurred.  This variable is only
        valid if an error occurs.

Return Value:

    The function value is STATUS_SUCCESS if the get quota buffer contains a
    valid, properly formed list, otherwise STATUS_QUOTA_LIST_INCONSISTENT.

--*/

{

#define GET_OFFSET_LENGTH( CurrentSid, SidBase ) ( (ULONG) ((PCHAR) CurrentSid - (PCHAR) SidBase) )

    LONG tempLength;
    LONG entrySize;
    PFILE_GET_QUOTA_INFORMATION sids;

    PAGED_CODE();

    //
    // Walk the buffer and ensure that its format is valid.  That is, ensure
    // that it does not walk off the end of the buffer, is not recursive, etc.
    //

    sids = QuotaBuffer;
    tempLength = QuotaLength;

    for (;;) {

        //
        // Ensure that the current entry is valid.
        //

        if ((tempLength < (LONG) (FIELD_OFFSET(FILE_GET_QUOTA_INFORMATION, Sid.SubAuthority) +
                                  sizeof (sids->Sid.SubAuthority))) ||
            !RtlValidSid( &sids->Sid)) {

            *ErrorOffset = GET_OFFSET_LENGTH( sids, QuotaBuffer );
            return STATUS_QUOTA_LIST_INCONSISTENT;
        }

        //
        // Get the size of the current entry in the buffer.
        //

        entrySize = FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) + RtlLengthSid( (&sids->Sid) );

        if (sids->NextEntryOffset) {

            //
            // There is another entry in the buffer and it must be longword
            // aligned.  Ensure that the offset indicates that it is.  If it
            // isn't, return an invalid parameter status.
            //

            if (entrySize > (LONG) sids->NextEntryOffset ||
                sids->NextEntryOffset & (sizeof( ULONG ) - 1)) {
                *ErrorOffset = GET_OFFSET_LENGTH( sids, QuotaBuffer );
                return STATUS_QUOTA_LIST_INCONSISTENT;

            } else {

                //
                // There is another entry in the buffer, so account for the
                // size of the current entry in the length and get a pointer
                // to the next entry.
                //

                tempLength -= sids->NextEntryOffset;
                if (tempLength < 0) {
                    *ErrorOffset = GET_OFFSET_LENGTH( sids, QuotaBuffer );
                    return STATUS_QUOTA_LIST_INCONSISTENT;
                }
                sids = (PFILE_GET_QUOTA_INFORMATION) ((PCHAR) sids + sids->NextEntryOffset);
            }

        } else {

            //
            // There are no other entries in the buffer.  Simply account for
            // the overall buffer length according to the size of the current
            // entry and exit the loop.
            //

            tempLength -= entrySize;
            break;
        }
    }

    //
    // All of the entries in the buffer have been processed.  Check to see
    // whether the overall buffer length went negative.  If so, return an
    // error.
    //

    if (tempLength < 0) {
        *ErrorOffset = GET_OFFSET_LENGTH( sids, QuotaBuffer );
        return STATUS_QUOTA_LIST_INCONSISTENT;
    }

    //
    // The format of the get quota buffer was correct, so simply return a
    // success status code.
    //

    return STATUS_SUCCESS;
}


VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN OnCleanStack,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked when the reference count on a device object
    transitions to a zero and the driver is mark for unload or device has
    been marked for delete. This means that it may be possible to actually
    unload the driver or delete the device object.  If all
    of the devices have a reference count of zero, then the driver is
    actually unloaded.  Note that in order to ensure that this routine is
    not invoked twice, at the same time, on two different processors, the
    I/O database spin lock is still held at this point.

Arguments:

    DeviceObject - Supplies a pointer to one of the driver's device objects,
        namely the one whose reference count just went to zero.

    OnCleanStack - Indicates whether the current thread is in the middle a
                   driver operation.

    Irql - Specifies the IRQL of the processor at the time that the I/O
        database lock was acquired.

Return Value:

    None.

--*/

{
    PDRIVER_OBJECT driverObject;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT baseDeviceObject;
    PDEVICE_OBJECT attachedDeviceObject;
    PDEVOBJ_EXTENSION deviceExtension;

    BOOLEAN unload = TRUE;

    driverObject = DeviceObject->DriverObject;

    if (DeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_REMOVE_PENDING) {

        //
        // Run some tests to determine if it is an appropriate time to notify
        // PnP that all file objects in the attachment chain have gone away.
        //

        baseDeviceObject = IopGetDeviceAttachmentBase( DeviceObject );
        deviceExtension = baseDeviceObject->DeviceObjectExtension;

        ASSERT(deviceExtension->DeviceNode != NULL);

        //
        // baseDeviceObject is a PDO, this is a PnP stack.  See if
        // an IRP_MN_REMOVE_DEVICE is pending.
        //

        // ASSERT(deviceNode->Flags & DNF_REMOVE_PENDING_CLOSES);

        //
        // PnP wants to be notified as soon as all refcounts on all devices in
        // this attachment chain go away.
        //

        attachedDeviceObject = baseDeviceObject;
        while (attachedDeviceObject != NULL) {

            if (attachedDeviceObject->ReferenceCount != 0) {

                //
                // At least one device object in the attachment chain has
                // an outstanding open.
                //

                KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );

                return;
            }
            attachedDeviceObject = attachedDeviceObject->AttachedDevice;
        }

        //
        // Now one more time changing DOE_REMOVE_PENDING to
        // DOE_REMOVE_PROCESSED.
        //

        attachedDeviceObject = baseDeviceObject;
        while (attachedDeviceObject != NULL) {

            deviceExtension = attachedDeviceObject->DeviceObjectExtension;

            deviceExtension->ExtensionFlags &= ~DOE_REMOVE_PENDING;
            deviceExtension->ExtensionFlags |= DOE_REMOVE_PROCESSED;

            attachedDeviceObject = attachedDeviceObject->AttachedDevice;
        }

        //
        // It is time to give PnP the notification it was waiting for.  We have
        // to release the spinlock before doing so.
        //

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );

        IopChainDereferenceComplete( baseDeviceObject, OnCleanStack );

        return;
    }

    if (DeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_DELETE_PENDING) {

        if ((DeviceObject->DeviceObjectExtension->ExtensionFlags &
            DOE_UNLOAD_PENDING) == 0 ||
            driverObject->Flags & DRVO_UNLOAD_INVOKED) {

            unload = FALSE;
        }

        //
        // If another device is attached to this device, inform the former's
        // driver that the device is being deleted.
        //

        if (DeviceObject->AttachedDevice) {
            PFAST_IO_DISPATCH fastIoDispatch = DeviceObject->AttachedDevice->DriverObject->FastIoDispatch;
            PDEVICE_OBJECT attachedDevice = DeviceObject->AttachedDevice;

            //
            // Increment the device reference count so the detach routine
            // does not recurse back to here.
            //

            DeviceObject->ReferenceCount++;

            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );

            if (fastIoDispatch &&
                fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoDetachDevice ) &&
                fastIoDispatch->FastIoDetachDevice) {
                (fastIoDispatch->FastIoDetachDevice)( attachedDevice, DeviceObject );
            }

            Irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

            //
            // Restore the reference count value.
            //

            DeviceObject->ReferenceCount--;

            if (DeviceObject->AttachedDevice ||
                DeviceObject->ReferenceCount != 0) {


                KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );
                return;
            }
        }

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );

        //
        // Deallocate the memory for the security descriptor that was allocated
        // for this device object.
        //

        if (DeviceObject->SecurityDescriptor != (PSECURITY_DESCRIPTOR) NULL) {
            ObDereferenceSecurityDescriptor( DeviceObject->SecurityDescriptor, 1 );
        }

        //
        // Remove this device object from the driver object's list.
        //

        IopInsertRemoveDevice( DeviceObject->DriverObject, DeviceObject, FALSE );

        //
        // Finally, dereference the object so it is deleted.
        //

        ObDereferenceObject( DeviceObject );

        //
        // Return if the unload does not need to be done.
        //

        if (!unload) {
            return;
        }

        //
        // Reacquire the spin lock make sure the unload routine does has
        // not been called.
        //

        Irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

        if (driverObject->Flags & DRVO_UNLOAD_INVOKED) {

            //
            // Some other thread is doing the unload, release the lock and return.
            //

            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );
            return;
        }
    }

    //
    // Scan the list of device objects for this driver, looking for a
    // non-zero reference count.  If any reference count is non-zero, then
    // the driver may not be unloaded.
    //

    deviceObject = driverObject->DeviceObject;

    while (deviceObject) {
        if (deviceObject->ReferenceCount || deviceObject->AttachedDevice ||
            deviceObject->DeviceObjectExtension->ExtensionFlags & (DOE_DELETE_PENDING | DOE_REMOVE_PENDING)) {
            unload = FALSE;
            break;
        }
        deviceObject = deviceObject->NextDevice;
    }

    //
    // If this is a base filesystem driver and we still have device objects
    // skip the unload.
    //

    if (driverObject->Flags & DRVO_BASE_FILESYSTEM_DRIVER && driverObject->DeviceObject) {
        unload = FALSE;
    }

    if (unload) {
        driverObject->Flags |= DRVO_UNLOAD_INVOKED;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, Irql );

    //
    // If the reference counts for all of the devices is zero, then this
    // driver can now be unloaded.
    //

    if (unload) {
        LOAD_PACKET loadPacket;

        KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
        loadPacket.DriverObject = driverObject;

        if (OnCleanStack) {

             IopLoadUnloadDriver(&loadPacket);

        } else {

            ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                                  IopLoadUnloadDriver,
                                  &loadPacket );
            ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );
            (VOID) KeWaitForSingleObject( &loadPacket.Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }
}

VOID
IopCompletePageWrite(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine executes as a special kernel APC routine in the context of
    the Modified Page Writer (MPW) system thread when an out-page operation
    has completed.

    This routine performs the following tasks:

        o   The I/O status is copied.

        o   The Modified Page Writer's APC routine is invoked.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1 - Supplies a pointer to an argument that contains an
        argument that is unused by this routine.

    SystemArgument2 - Supplies a pointer to an argument that contains an
        argument that is unused by this routine.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_APC_ROUTINE apcRoutine;
    PVOID apcContext;
    PIO_STATUS_BLOCK ioStatus;

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // Begin by getting the address of the I/O Request Packet from the APC.
    //

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );

    //
    // If this I/O operation did not complete successfully through the
    // dispatch routine of the driver, then drop everything on the floor
    // now and return to the original call point in the MPW.
    //

    if (!irp->PendingReturned && NT_ERROR( irp->IoStatus.Status )) {
        IoFreeIrp( irp );
        return;
    }

    //
    // Copy the I/O status from the IRP into the caller's I/O status block.
    //

    *irp->UserIosb = irp->IoStatus;

    //
    // Copy the pertinent information from the I/O Request Packet into locals
    // and free it.
    //

    apcRoutine = irp->Overlay.AsynchronousParameters.UserApcRoutine;
    apcContext = irp->Overlay.AsynchronousParameters.UserApcContext;
    ioStatus = irp->UserIosb;

    IoFreeIrp( irp );

    //
    // Finally, invoke the MPW's APC routine.
    //

    apcRoutine( apcContext, ioStatus, 0 );

    return;
}


VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine executes as a special kernel APC routine in the context of
    the thread which originally requested the I/O operation which is now
    being completed.

    This routine performs the following tasks:

        o   A check is made to determine whether the specified request ended
            with an error status.  If so, and the error code qualifies as one
            which should be reported to an error port, then an error port is
            looked for in the thread/process.   If one exists, then this routine
            will attempt to set up an LPC to it.  Otherwise, it will attempt to
            set up an LPC to the system error port.

        o   Copy buffers.

        o   Free MDLs.

        o   Copy I/O status.

        o   Set event, if any and dereference if appropriate.

        o   Dequeue the IRP from the thread queue as pending I/O request.

        o   Queue APC to thread, if any.

        o   If no APC is to be queued, then free the packet now.


Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1 - Supplies a pointer to an argument that contains the
        address of the original file object for this I/O operation.

    SystemArgument2 - Supplies a pointer to an argument that contains an
        argument that is used by this routine only in the case of STATUS_REPARSE.

Return Value:

    None.

--*/
{
#define SynchronousIo( Irp, FileObject ) (  \
    (Irp->Flags & IRP_SYNCHRONOUS_API) ||   \
    (FileObject == NULL ? 0 : FileObject->Flags & FO_SYNCHRONOUS_IO) )

    PIRP irp;
    PMDL mdl, nextMdl;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );

    //
    // Begin by getting the address of the I/O Request Packet.  Also, get
    // the address of the current thread and the address of the original file
    // object for this I/O operation.
    //

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );
    thread = PsGetCurrentThread();
    fileObject = (PFILE_OBJECT) *SystemArgument1;

    IOVP_COMPLETE_REQUEST(Apc, SystemArgument1, SystemArgument2);

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( irp->IoStatus.Status != 0xffffffff );

    //
    // See if we need to do the name transmogrify work.
    //

    if ( *SystemArgument2 != NULL ) {

        PREPARSE_DATA_BUFFER reparseBuffer = NULL;

        //
        // The IO_REPARSE_TAG_MOUNT_POINT tag needs attention.
        //

        if ( irp->IoStatus.Status == STATUS_REPARSE &&
             irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT ) {

            reparseBuffer = (PREPARSE_DATA_BUFFER) *SystemArgument2;

            ASSERT( reparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
            ASSERT( reparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
            ASSERT( reparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );

            IopDoNameTransmogrify( irp,
                                   fileObject,
                                   reparseBuffer );
        }
    }

    //
    // Check to see whether there is any data in a system buffer which needs
    // to be copied to the caller's buffer.  If so, copy the data and then
    // free the system buffer if necessary.
    //

    if (irp->Flags & IRP_BUFFERED_IO) {

        //
        // Copy the data if this was an input operation.  Note that no copy
        // is performed if the status indicates that a verify operation is
        // required, or if the final status was an error-level severity.
        //

        if (irp->Flags & IRP_INPUT_OPERATION  &&
            irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
            !NT_ERROR( irp->IoStatus.Status )) {

            //
            // Copy the information from the system buffer to the caller's
            // buffer.  This is done with an exception handler in case
            // the operation fails because the caller's address space
            // has gone away, or it's protection has been changed while
            // the service was executing.
            //

            status = STATUS_SUCCESS;

            try {
                RtlCopyMemory( irp->UserBuffer,
                               irp->AssociatedIrp.SystemBuffer,
                               irp->IoStatus.Information );
            } except(IopExceptionFilter(GetExceptionInformation(), &status)) {

                //
                // An exception occurred while attempting to copy the
                // system buffer contents to the caller's buffer.  Set
                // a new I/O completion status.
                // If the status is a special one set by Mm then we need to
                // return here and the operation will be retried in
                // IoRetryIrpCompletions.
                //

                if (status == STATUS_MULTIPLE_FAULT_VIOLATION) {
                    irp->Tail.Overlay.OriginalFileObject = fileObject;  /* Wiped out by APC  overlay */
                    irp->Flags |= IRP_RETRY_IO_COMPLETION;
                    return;
                }
                irp->IoStatus.Status = GetExceptionCode();
            }
        }

        //
        // Free the buffer if needed.
        //

        if (irp->Flags & IRP_DEALLOCATE_BUFFER) {
            ExFreePool( irp->AssociatedIrp.SystemBuffer );
        }
    }

    irp->Flags &= ~(IRP_DEALLOCATE_BUFFER|IRP_BUFFERED_IO);

    //
    // If there is an MDL (or MDLs) associated with this I/O request,
    // Free it (them) here.  This is accomplished by walking the MDL list
    // hanging off of the IRP and deallocating each MDL encountered.
    //

    if (irp->MdlAddress) {
        for (mdl = irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
            nextMdl = mdl->Next;
            IoFreeMdl( mdl );
        }
    }

    irp->MdlAddress = NULL;

    //
    // Check to see whether or not the I/O operation actually completed.  If
    // it did, then proceed normally.  Otherwise, cleanup everything and get
    // out of here.
    //

    if (!NT_ERROR( irp->IoStatus.Status ) ||
        (NT_ERROR( irp->IoStatus.Status ) &&
        irp->PendingReturned &&
        !SynchronousIo( irp, fileObject ))) {

        PVOID port = NULL;
        PVOID key = NULL;
        BOOLEAN createOperation = FALSE;

        //
        // If there is an I/O completion port object associated w/this request,
        // save it here so that the file object can be dereferenced.
        //

        if (fileObject && fileObject->CompletionContext) {
            port = fileObject->CompletionContext->Port;
            key = fileObject->CompletionContext->Key;
        }

        //
        // Copy the I/O status from the IRP into the caller's I/O status
        // block. This is done using an exception handler in case the caller's
        // virtual address space for the I/O status block was deleted or
        // its protection was changed to readonly.  Note that if the I/O
        // status block cannot be written, the error is simply ignored since
        // there is no way to tell the caller that something went wrong.
        // This is, of course, by definition, since the I/O status block
        // is where the caller will attempt to look for errors in the first
        // place!
        //

        status = STATUS_SUCCESS;

        try {

            //
            // Since HasOverlappedIoCompleted and GetOverlappedResult only
            // look at the Status field of the UserIosb to determine if the
            // IRP has completed, the Information field must be written
            // before the Status field.
            //

#if defined(_WIN64)
            PIO_STATUS_BLOCK32    UserIosb32;

            //
            // If the caller passes a 32 bit IOSB the ApcRoutine has the LSB set to 1
            //
            if (IopIsIosb32(irp->Overlay.AsynchronousParameters.UserApcRoutine)) {
                UserIosb32 = (PIO_STATUS_BLOCK32)irp->UserIosb;

                UserIosb32->Information = (ULONG)irp->IoStatus.Information;
                KeMemoryBarrierWithoutFence ();
                *((volatile NTSTATUS *) &UserIosb32->Status) = irp->IoStatus.Status;
            } else {
                irp->UserIosb->Information = irp->IoStatus.Information;
                KeMemoryBarrierWithoutFence ();
                *((volatile NTSTATUS *) &irp->UserIosb->Status) = irp->IoStatus.Status;
            }
#else
            irp->UserIosb->Information = irp->IoStatus.Information;
            KeMemoryBarrierWithoutFence ();
            *((volatile NTSTATUS *) &irp->UserIosb->Status) = irp->IoStatus.Status;
#endif  /*_WIN64 */

        } except(IopExceptionFilter(GetExceptionInformation(), &status)) {

            //
            // An exception was incurred attempting to write the caller's
            // I/O status block.  Simply continue executing as if nothing
            // ever happened since nothing can be done about it anyway.
            // If the status is a multiple fault status, this is a special
            // status sent by the Memory manager. Mark the IRP and return from
            // this routine. Mm will call us back later and we will retry this
            // operation (IoRetryIrpCompletions)
            //
            if (status == STATUS_MULTIPLE_FAULT_VIOLATION) {
                irp->Tail.Overlay.OriginalFileObject = fileObject;  /* Wiped out by APC  overlay */
                irp->Flags |= IRP_RETRY_IO_COMPLETION;
                return;
            }
        }


        //
        // Determine whether the caller supplied an event that needs to be set
        // to the Signaled state.  If so, then set it; otherwise, set the event
        // in the file object to the Signaled state.
        //
        // It is possible for the event to have been specified as a PKEVENT if
        // this was an I/O operation hand-built for an FSP or an FSD, or
        // some other types of operations such as synchronous I/O APIs.  In
        // any of these cases, the event was not referenced since it is not an
        // object manager event, so it should not be dereferenced.
        //
        // Also, it is possible for there not to be a file object for this IRP.
        // This occurs when an FSP is doing I/O operations to a device driver on
        // behalf of a process doing I/O to a file.  The file object cannot be
        // dereferenced if this is the case.  If this operation was a create
        // operation then the object should not be dereferenced either.  This
        // is because the reference count must be one or it will go away for
        // the caller (not much point in making an object that just got created
        // go away).
        //

        if (irp->UserEvent) {
            (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
            if (fileObject) {
                if (!(irp->Flags & IRP_SYNCHRONOUS_API)) {
                    ObDereferenceObject( irp->UserEvent );
                }
                if (fileObject->Flags & FO_SYNCHRONOUS_IO && !(irp->Flags & IRP_OB_QUERY_NAME)) {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                    fileObject->FinalStatus = irp->IoStatus.Status;
                }
                if (irp->Flags & IRP_CREATE_OPERATION) {
                    createOperation = TRUE;
                    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
                }
            }
        } else if (fileObject) {
            (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            fileObject->FinalStatus = irp->IoStatus.Status;
            if (irp->Flags & IRP_CREATE_OPERATION) {
                createOperation = TRUE;
                irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
            }
        }

        //
        // If this is normal I/O, update the transfer count for this process.
        //

        if (!(irp->Flags & IRP_CREATE_OPERATION)) {
            if (irp->Flags & IRP_READ_OPERATION) {
                IopUpdateReadTransferCount( (ULONG) irp->IoStatus.Information );
            } else if (irp->Flags & IRP_WRITE_OPERATION) {
                IopUpdateWriteTransferCount( (ULONG) irp->IoStatus.Information );
            } else {
                //
                // If the information field contains a pointer then skip the update.
                // Some PNP IRPs contain this.
                //
                if (!((ULONG) irp->IoStatus.Information & 0x80000000)) {
                    IopUpdateOtherTransferCount( (ULONG) irp->IoStatus.Information );
                }
            }
        }

        //
        // Dequeue the packet from the thread's pending I/O request list.
        //

        IopDequeueThreadIrp( irp );

        //
        // If the caller requested an APC, queue it to the thread.  If not, then
        // simply free the packet now.
        //

#ifdef  _WIN64
        //
        // For 64 bit systems clear the LSB field of the ApcRoutine that indicates whether
        // the IOSB is a 32 bit IOSB or a 64 bit IOSB.
        //
        irp->Overlay.AsynchronousParameters.UserApcRoutine =
          (PIO_APC_ROUTINE)((LONG_PTR)(irp->Overlay.AsynchronousParameters.UserApcRoutine) & ~1);
#endif

        if (irp->Overlay.AsynchronousParameters.UserApcRoutine) {
            KeInitializeApc( &irp->Tail.Apc,
                             &thread->Tcb,
                             CurrentApcEnvironment,
                             IopUserCompletion,
                             (PKRUNDOWN_ROUTINE) IopUserRundown,
                             (PKNORMAL_ROUTINE) irp->Overlay.AsynchronousParameters.UserApcRoutine,
                             irp->RequestorMode,
                             irp->Overlay.AsynchronousParameters.UserApcContext );

            KeInsertQueueApc( &irp->Tail.Apc,
                              irp->UserIosb,
                              NULL,
                              2 );

        } else if (port && irp->Overlay.AsynchronousParameters.UserApcContext) {

            //
            // If there is a completion context associated w/this I/O operation,
            // send the message to the port. Tag completion packet as an Irp.
            //

            irp->Tail.CompletionKey = key;
            irp->Tail.Overlay.PacketType = IopCompletionPacketIrp;

            KeInsertQueue( (PKQUEUE) port,
                           &irp->Tail.Overlay.ListEntry );

        } else {

            //
            // Free the IRP now since it is no longer needed.
            //

            IoFreeIrp( irp );
        }

        if (fileObject && !createOperation) {

            //
            // Dereference the file object now.
            //

            ObDereferenceObjectDeferDelete( fileObject );
        }

    } else {

        if (irp->PendingReturned && fileObject) {

            //
            // This is an I/O operation that completed as an error for
            // which a pending status was returned and the I/O operation
            // is synchronous.  For this case, the I/O system is waiting
            // on behalf of the caller.  If the reason that the I/O was
            // synchronous is that the file object was opened for synchronous
            // I/O, then the event associated with the file object is set
            // to the signaled state.  If the I/O operation was synchronous
            // because this is a synchronous API, then the event is set to
            // the signaled state.
            //
            // Note also that the status must be returned for both types
            // of synchronous I/O.  If this is a synchronous API, then the
            // I/O system supplies its own status block so it can simply
            // be written;  otherwise, the I/O system will obtain the final
            // status from the file object itself.
            //

            if (irp->Flags & IRP_SYNCHRONOUS_API) {
                *irp->UserIosb = irp->IoStatus;
                if (irp->UserEvent) {
                    (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
                } else {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                }
            } else {
                fileObject->FinalStatus = irp->IoStatus.Status;
                (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            }
        }

        //
        // The operation was incomplete.  Perform the general cleanup.  Note
        // that everything is basically dropped on the floor without doing
        // anything.  That is:
        //
        //     IoStatusBlock - Do nothing.
        //     Event - Dereference without setting to Signaled state.
        //     FileObject - Dereference without setting to Signaled state.
        //     ApcRoutine - Do nothing.
        //

        if (fileObject) {
            if (!(irp->Flags & IRP_CREATE_OPERATION)) {
                ObDereferenceObjectDeferDelete( fileObject );
            }
        }

        if (irp->UserEvent &&
            fileObject &&
            !(irp->Flags & IRP_SYNCHRONOUS_API)) {
            ObDereferenceObject( irp->UserEvent );
        }

        IopDequeueThreadIrp( irp );
        IoFreeIrp( irp );
    }
}

VOID
IopConnectLinkTrackingPort(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine is invoked to connect to the user-mode link tracking service's
    LPC port.  It makes a connection which establishes a handle to the port,
    and then creates a referenced object pointer to the port.

Arguments:

    Parameter - Pointer to the link tracking packet.

Return Value:

    None.


--*/

{
    #define MESSAGE_SIZE    ( (2 * sizeof( FILE_VOLUMEID_WITH_TYPE )) + \
                            sizeof( FILE_OBJECTID_BUFFER ) +              \
                            sizeof( GUID ) + \
                            sizeof( NTSTATUS ) + \
                            sizeof( ULONG ) )

    PLINK_TRACKING_PACKET ltp;
    HANDLE serviceHandle;
    NTSTATUS status;

    PAGED_CODE();
    //
    // Begin by getting a pointer to the link tracking packet.
    //

    ltp = (PLINK_TRACKING_PACKET) Parameter;


    //
    // Ensure that the port has not already been opened.
    //

    status = STATUS_SUCCESS;
    if (!IopLinkTrackingServiceObject) {

        UNICODE_STRING portName;
        ULONG maxMessageLength;
        SECURITY_QUALITY_OF_SERVICE dynamicQos;

        if (KeReadStateEvent( IopLinkTrackingServiceEvent )) {

            //
            // Attempt to open a handle to the port.
            //

            //
            // Set up the security quality of service parameters to use over the
            // port.  Use the most efficient (least overhead) which is dynamic
            // rather than static tracking.
            //

            dynamicQos.ImpersonationLevel = SecurityImpersonation;
            dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
            dynamicQos.EffectiveOnly = TRUE;

            //
            // Generate the string structure for describing the port.
            //

            RtlInitUnicodeString( &portName, L"\\Security\\TRKWKS_PORT" );

            status = NtConnectPort( &serviceHandle,
                                    &portName,
                                    &dynamicQos,
                                    (PPORT_VIEW) NULL,
                                    (PREMOTE_PORT_VIEW) NULL,
                                    &maxMessageLength,
                                    (PVOID) NULL,
                                    (PULONG) NULL );
            if (NT_SUCCESS( status )) {
                if (maxMessageLength >= MESSAGE_SIZE) {
                    status = ObReferenceObjectByHandle( serviceHandle,
                                                        0,
                                                        LpcPortObjectType,
                                                        KernelMode,
                                                        &IopLinkTrackingServiceObject,
                                                        NULL );
                    NtClose( serviceHandle );
                } else {
                    NtClose( serviceHandle );
                    status = STATUS_INVALID_PARAMETER;
                }
            }

        } else {

            //
            // The service has not been started so the port does not exist.
            //

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }


    //
    // Return final status and wake the caller up.
    //
    ltp->FinalStatus = status;
    KeSetEvent( &ltp->Event, 0, FALSE );
}

VOID
IopDisassociateThreadIrp(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the I/O requests for a thread are being
    cancelled, but there is a packet at the end of the thread's queue that
    has not been completed for such a long period of time that it has timed
    out.  It is this routine's responsibility to try to disassociate that
    IRP with this thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL irql;
    KIRQL spIrql;
    PIRP irp;
    PETHREAD thread;
    PLIST_ENTRY entry;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    //
    // Begin by ensuring that the packet has not already been removed from
    // the thread's queue.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    thread = PsGetCurrentThread();

    //
    // If there are no packets on the IRP list, then simply return now.
    // All of the packets have been fully completed, so the caller will also
    // simply return to its caller.
    //

    if (IsListEmpty( &thread->IrpList )) {
        KeLowerIrql( irql );
        return;
    }

    //
    // Get a pointer to the first packet on the queue, and begin examining
    // it.  Note that because the processor is at raised IRQL, and because
    // the packet can only be removed in the context of the currently
    // executing thread, that it is not possible for the packet to be removed
    // from the list.  On the other hand, it IS possible for the packet to
    // be queued to the thread's APC list at this point, and this must be
    // blocked/synchronized in order to examine the request.
    //
    // Begin, therefore, by acquiring the I/O completion spinlock, so that
    // the packet can be safely examined.
    //

    spIrql = KeAcquireQueuedSpinLock( LockQueueIoCompletionLock );

    //
    // Check to see whether or not the packet has been completed (that is,
    // queued to the current thread).  If not, change threads.
    //

    entry = thread->IrpList.Flink;
    irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );

    if (irp->CurrentLocation == irp->StackCount + 2) {

        //
        // The request has just gone through enough of completion that
        // queueing it to the thread is inevitable.  Simply release the
        // lock and return.
        //

        KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, spIrql );
        KeLowerIrql( irql );
        return;
    }

    //
    // The packet has been located, and it is not going through completion
    // at this point.  Switch threads, so that it will not complete through
    // this thread, remove the request from this thread's queue, and release
    // the spinlock.  Final processing of the IRP will occur when I/O
    // completion notices that there is no thread associated with the
    // request.  It will essentially drop the I/O on the floor.
    //
    // Also, while the request is still held, attempt to determine on which
    // device object the operation is being performed.
    //

////
////DbgPrint( "Disassociating Irp:  %x\n", irp );
////DbgBreakPoint();
////

    IopDeadIrp = irp;

    irp->Tail.Overlay.Thread = (PETHREAD) NULL;
    entry = RemoveHeadList( &thread->IrpList );

    // Initialize the thread entry. Otherwise the assertion in IoFreeIrp
    // called via IopDeadIrp will fail.
    InitializeListHead (&(irp)->ThreadListEntry);

    irpSp = IoGetCurrentIrpStackLocation( irp );
    if (irp->CurrentLocation <= irp->StackCount) {
        deviceObject = irpSp->DeviceObject;
    } else {
        deviceObject = (PDEVICE_OBJECT) NULL;
    }
    KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, spIrql );
    KeLowerIrql( irql );

    //
    // If a device object could be identified then try to write to the event log about this
    // device object.
    //

    if (deviceObject) {
        errorLogEntry = IoAllocateErrorLogEntry(deviceObject, sizeof(IO_ERROR_LOG_PACKET));
        if (errorLogEntry) {
            errorLogEntry->ErrorCode = IO_DRIVER_CANCEL_TIMEOUT;
            IoWriteErrorLogEntry(errorLogEntry);
        }
    }

    return;
}

VOID
IopDeallocateApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked to deallocate an APC that was used to queue a
    request to a target thread.  It simple deallocates the APC.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PAGED_CODE();

    //
    // Free the APC.
    //

    ExFreePool( Apc );
}

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine attempts to drop everything about the specified IRP on the
    floor.

Arguments:

    Irp - Supplies the I/O Request Packet to be completed to the bit bucket.

    FileObject - Supplies the file object for which the I/O Request Packet was
        bound.

Return Value:

    None.

--*/

{
    PMDL mdl;
    PMDL nextMdl;

    //
    // Free the resources associated with the IRP.
    //

    if (Irp->Flags & IRP_DEALLOCATE_BUFFER) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    if (Irp->MdlAddress) {
        for (mdl = Irp->MdlAddress; mdl; mdl = nextMdl) {
            nextMdl = mdl->Next;
            IoFreeMdl( mdl );
        }
    }

    if (Irp->UserEvent &&
        FileObject &&
        !(Irp->Flags & IRP_SYNCHRONOUS_API)) {
        ObDereferenceObject( Irp->UserEvent );
    }

    if (FileObject && !(Irp->Flags & IRP_CREATE_OPERATION)) {
        ObDereferenceObjectEx( FileObject, 1 );
    }

    //
    // Finally, free the IRP itself.
    //

    IoFreeIrp( Irp );
}

LONG
IopExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointer,
    OUT PNTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine is invoked when an exception occurs to determine whether or
    not the exception was due to an error that caused an in-page error status
    code exception to be raised.  If so, then this routine changes the code
    in the exception record to the actual error code that was originally
    raised.

Arguments:

    ExceptionPointer - Pointer to the exception record.

    ExceptionCode - Variable to receive actual exception code.

Return Value:

    The function value indicates that the exception handler is to be executed.

--*/

{
    //
    // Simply check for an in-page error status code and, if the conditions
    // are right, replace it with the actual status code.
    //

    *ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    if (*ExceptionCode == STATUS_IN_PAGE_ERROR &&
        ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
        *ExceptionCode = (LONG) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    //
    // Translate alignment warnings into alignment errors.
    //

    if (*ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {
        *ExceptionCode = STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL,
    IN PKEVENT KernelEvent OPTIONAL
    )

/*++

Routine Description:

    This routine performs generalized cleanup for the I/O system services when
    an exception occurs during caller parameter processing.  This routine
    performs the following steps:

        o   If a system buffer was allocated it is freed.

        o   If an MDL was allocated it is freed.

        o   The IRP is freed.

        o   If the file object is opened for synchronous I/O, the semaphore
            is released.

        o   If an event object was referenced it is dereferenced.

        o   If a kernel event was allocated, free it.

        o   The file object is dereferenced.

Arguments:

    FileObject - Pointer to the file object currently being worked on.

    Irp - Pointer to the IRP allocated to handle the I/O request.

    EventObject - Optional pointer to a referenced event object.

    KernelEvent - Optional pointer to an allocated kernel event.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If a system buffer was allocated from nonpaged pool, free it.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    //
    // If an MDL was allocated, free it.
    //

    if (Irp->MdlAddress != NULL) {
        IoFreeMdl( Irp->MdlAddress );
    }

    //
    // Free the I/O Request Packet.
    //

    IoFreeIrp( Irp );

    //
    // Finally, release the synchronization semaphore if it is currently
    // held, dereference the event if one was specified, free the kernel
    // event if one was allocated, and dereference the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    if (ARGUMENT_PRESENT( KernelEvent )) {
        ExFreePool( KernelEvent );
    }

    ObDereferenceObject( FileObject );

    return;
}

VOID
IopFreeIrpAndMdls(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine frees the specified I/O Request Packet and all of its Memory
    Descriptor Lists.

Arguments:

    Irp - Pointer to the I/O Request Packet to be freed.

Return Value:

    None.

--*/

{
    PMDL mdl;
    PMDL nextMdl;

    //
    // If there are any MDLs that need to be freed, free them now.
    //

    for (mdl = Irp->MdlAddress; mdl != (PMDL) NULL; mdl = nextMdl) {
        nextMdl = mdl->Next;
        IoFreeMdl( mdl );
    }

    //
    // Free the IRP.
    //

    IoFreeIrp( Irp );
    return;
}

NTSTATUS
IopGetDriverNameFromKeyNode(
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING DriverName
    )

/*++

Routine Description:

    Given a handle to a driver service list key in the registry, return the
    name that represents the Object Manager name space string that should
    be used to locate/create the driver object.

Arguments:

    KeyHandle - Supplies a handle to driver service entry in the registry.

    DriverName - Supplies a Unicode string descriptor variable in which the
        name of the driver is returned.

Return Value:

    The function value is the final status of the operation.

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PKEY_BASIC_INFORMATION keyBasicInformation;
    ULONG keyBasicLength;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the optional object name for this driver from the value for this
    // key.  If one exists, then its name overrides the default name of the
    // driver.
    //

    status = IopGetRegistryValue( KeyHandle,
                                  L"ObjectName",
                                  &keyValueInformation );

    if (NT_SUCCESS( status )) {

        PWSTR src, dst;
        ULONG i;

        //
        // The driver entry specifies an object name.  This overrides the
        // default name for the driver.  Use this name to open the driver
        // object.
        //

        if (!keyValueInformation->DataLength) {
            ExFreePool( keyValueInformation );
            return STATUS_ILL_FORMED_SERVICE_ENTRY;
        }

        DriverName->Length = (USHORT) (keyValueInformation->DataLength - sizeof( WCHAR ));
        DriverName->MaximumLength = (USHORT) keyValueInformation->DataLength;

        src = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
        dst = (PWSTR) keyValueInformation;
        for (i = DriverName->Length; i; i--) {
            *dst++ = *src++;
        }

        DriverName->Buffer = (PWSTR) keyValueInformation;

    } else {

        PULONG driverType;
        PWSTR baseObjectName;
        UNICODE_STRING remainderName;

        //
        // The driver node does not specify an object name, so determine
        // what the default name for the driver object should be based on
        // the information in the key.
        //

        status = IopGetRegistryValue( KeyHandle,
                                      L"Type",
                                      &keyValueInformation );
        if (!NT_SUCCESS( status ) || !keyValueInformation->DataLength) {

            //
            // There must be some type of "Type" associated with this driver,
            // either DRIVER or FILE_SYSTEM.  Otherwise, this node is ill-
            // formed.
            //

            if (NT_SUCCESS( status )) {
                ExFreePool( keyValueInformation );
            }

            return STATUS_ILL_FORMED_SERVICE_ENTRY;
        }

        //
        // Now determine whether the type of this entry is a driver or a
        // file system.  Begin by assuming that it is a device driver.
        //

        baseObjectName = L"\\Driver\\";
        DriverName->Length = 8*2;

        driverType = (PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);

        if (*driverType == FileSystemType ||
            *driverType == RecognizerType) {
            baseObjectName = L"\\FileSystem\\";
            DriverName->Length = 12*2;
        }

        //
        // Get the name of the key that is being used to describe this
        // driver.  This will return just the last component of the name
        // string, which can be used to formulate the name of the driver.
        //

        status = ZwQueryKey( KeyHandle,
                             KeyBasicInformation,
                             (PVOID) NULL,
                             0,
                             &keyBasicLength );

        keyBasicInformation = ExAllocatePool( NonPagedPool, keyBasicLength );
        if (!keyBasicInformation) {
            ExFreePool( keyValueInformation );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwQueryKey( KeyHandle,
                             KeyBasicInformation,
                             keyBasicInformation,
                             keyBasicLength,
                             &keyBasicLength );
        if (!NT_SUCCESS( status )) {
            ExFreePool( keyBasicInformation );
            ExFreePool( keyValueInformation );
            return status;
        }

        //
        // Allocate a buffer from pool that is large enough to contain the
        // entire name string of the driver object.
        //

        DriverName->MaximumLength = (USHORT) (DriverName->Length + keyBasicInformation->NameLength);
        DriverName->Buffer = ExAllocatePool( NonPagedPool,
                                            DriverName->MaximumLength );
        if (!DriverName->Buffer) {
            ExFreePool( keyBasicInformation );
            ExFreePool( keyValueInformation );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Now form the name of the object to be opened.
        //

        DriverName->Length = 0;
        RtlAppendUnicodeToString( DriverName, baseObjectName );
        remainderName.Length = (USHORT) keyBasicInformation->NameLength;
        remainderName.MaximumLength = remainderName.Length;
        remainderName.Buffer = &keyBasicInformation->Name[0];
        RtlAppendUnicodeStringToString( DriverName, &remainderName );
        ExFreePool( keyBasicInformation );
        ExFreePool( keyValueInformation );
    }

    //
    // Finally, simply return to the caller with the name filled in.  Note
    // that the caller must free the buffer pointed to by the Buffer field
    // of the Unicode string descriptor.
    //

    return STATUS_SUCCESS;
}



NTSTATUS
IopGetFileInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine is invoked to asynchronously obtain the name or other information
    of a file object when the file was opened for synchronous I/O, and the previous mode of the
    caller was kernel mode, and the query was done through the Object Manager.
    In this case, the situation is likely that the Lazy Writer has incurred a
    write error, and it is attempting to obtain the name of the file so that it
    can output a popup.  In doing so, a deadlock can occur because another
    thread has locked the file object synchronous I/O lock.  Hence, this routine
    obtains the name of the file w/o acquiring that lock.

Arguments:

    FileObject - A pointer to the file object whose name is to be queried.

    Length - Supplies the length of the buffer to receive the name.

    FileInformation - A pointer to the buffer to receive the name.

    ReturnedLength - A variable to receive the length of the name returned.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{

    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Initialize an event that will be used to synchronize the completion of
    // the query operation.  Note that this is the only way to synchronize this
    // since the file object itself cannot be used since it was opened for
    // synchronous I/O and may be busy.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        ObDereferenceObject( FileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.  Note that the
    // setting of the special query name flag in the packet guarantees that the
    // standard completion for a synchronous file object will not occur because
    // this flag communicates to the I/O completion that it should not do so.
    //

    irp->UserEvent = &event;
    irp->Flags = IRP_SYNCHRONOUS_API | IRP_OB_QUERY_NAME;
    irp->UserIosb = &localIoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;
    irp->Flags |= IRP_BUFFERED_IO;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // Now get the final status of the operation once the request completes
    // and return the length of the buffer written.
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = localIoStatus.Status;
    }

    *ReturnedLength = (ULONG) localIoStatus.Information;
    return status;
}

BOOLEAN
IopGetMountFlag(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not the specified device
    is mounted.

Arguments:

    DeviceObject - Supplies a pointer to the device object for which the mount
        flag is tested.

Return Value:

    The function value is TRUE if the specified device is mounted, otherwise
    FALSE.


--*/

{
    KIRQL irql;
    BOOLEAN deviceMounted = FALSE;

    //
    // Check to see whether or not the device is mounted.  Note that the caller
    // has probably already looked to see whether or not the device has a VPB
    // outside of owning the lock, so simply get the lock and check it again
    // to start with, rather than checking to see whether or not the device
    // still has a VPB without holding the lock.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    if (DeviceObject->Vpb) {
        if (DeviceObject->Vpb->Flags & VPB_MOUNTED) {
            deviceMounted = TRUE;
        }
    }
    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

    return deviceMounted;
}

NTSTATUS
IopGetRegistryKeyInformation(
    IN HANDLE KeyHandle,
    OUT PKEY_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the full key information for a
    registry key.  This is done by querying the full key information
    of the key with a zero-length buffer to determine the size of the data,
    and then allocating a buffer and actually querying the data into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose full key information is to
        be queried

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    NTSTATUS status;
    PKEY_FULL_INFORMATION infoBuffer;
    ULONG keyInfoLength;

    PAGED_CODE();

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryKey( KeyHandle,
                         KeyFullInformation,
                         (PVOID) NULL,
                         0,
                         &keyInfoLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyInfoLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the full key data for the key.
    //

    status = ZwQueryKey( KeyHandle,
                         KeyFullInformation,
                         infoBuffer,
                         keyInfoLength,
                         &keyInfoLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS
IopGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength, guessSize;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Set an initial size to try when loading a key. Note that
    // KeyValueFullInformation already comes with a single WCHAR of data.
    //
    guessSize = (ULONG)(sizeof(KEY_VALUE_FULL_INFORMATION) +
                wcslen(ValueName)*sizeof(WCHAR));

    //
    // Now round up to a natural alignment. This needs to be done because our
    // data member will naturally aligned as well.
    //
    guessSize = (ULONG) ALIGN_POINTER_OFFSET(guessSize);

    //
    // Set the data cache length to a ULONG's worth of data, because most data
    // we read via this function is type REG_DWORD.
    //
    guessSize += sizeof(ULONG);

    infoBuffer = ExAllocatePool(NonPagedPool, guessSize);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) infoBuffer,
                              guessSize,
                              &keyValueLength );
    if (NT_SUCCESS(status)) {

        //
        // First guess worked, bail!
        //
        *Information = infoBuffer;
        return STATUS_SUCCESS;
    }

    ExFreePool(infoBuffer);
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(!NT_SUCCESS(status));
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS
IopGetRegistryValues(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_FULL_INFORMATION *ValueList
    )

/*++

Routine Description:

    This routine is invoked to retrieve the *three* types of data for a
    registry key's.  This is done by calling the IopGetRegistryValue function
    with the three valid key names.

    It is the responsibility of the caller to free the three buffers.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueList - Pointer to a buffer in which the three pointers to the value
        entries will be stored.

Return Value:

    The function value is the final status of the query operation.

Note:

    The values are stored in the order represented by the I/O query device
    data format.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Zero out all entries initially.
    //

    *ValueList = NULL;
    *(ValueList + 1) = NULL;
    *(ValueList + 2) = NULL;

    //
    // Get the information for each of the three types of entries available.
    // Each time, check if an internal error occurred; If the object name was
    // not found, it only means not data was present, and this does not
    // constitute an error.
    //

    status = IopGetRegistryValue( KeyHandle,
                                  L"Identifier",
                                  ValueList );

    if (!NT_SUCCESS( status ) && (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
        return status;
    }

    status = IopGetRegistryValue( KeyHandle,
                                  L"Configuration Data",
                                  ++ValueList );

    if (!NT_SUCCESS( status ) && (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
        return status;
    }

    status = IopGetRegistryValue( KeyHandle,
                                  L"Component Information",
                                  ++ValueList );

    if (!NT_SUCCESS( status ) && (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopGetSetObjectId(
    IN PFILE_OBJECT FileObject,
    IN OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG Function
    )

/*++

Routine Description:

    This routine is invoked to obtain or set the object ID for a file.  If
    one does not exist for the file, then one is created, provided that the
    underlying file system supports object IDs in the first place (query).

Arguments:

    FileObject - Supplies a pointer to the referenced file object whose ID is
        to be returned or set.

    Buffer - A variable to receive the object ID of the file (query) or that
        contains the object ID that is to be set on the file.

    Length - The length of the Buffer.

    Function - The FSCTL to send.
        FSCTL_LMR_GET_LINK_TRACKING_INFORMATION;
        FSCTL_CREATE_OR_GET_OBJECT_ID;
        FSCTL_GET_OBJECT_ID;
        FSCTL_SET_OBJECT_ID_EXTENDED;
        FSCTL_LMR_SET_LINK_TRACKING_INFORMATION;
        FSCTL_SET_OBJECT_ID_EXTENDED;
        FSCTL_SET_OBJECT_ID;
        FSCTL_DELETE_OBJECT_ID;

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Initialize the event structure to synchronize completion of the I/O
    // request.
    //

    KeInitializeEvent( &event,
                       NotificationEvent,
                       FALSE );

    //
    // Build an I/O Request Packet to be sent to the file system driver to get
    // the object ID.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    irp = IoBuildDeviceIoControlRequest( Function,
                                         deviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the remainder of the IRP to retrieve the object ID for the
    // file.
    //

    irp->Flags |= IRP_SYNCHRONOUS_API;
    irp->UserBuffer = Buffer;
    irp->AssociatedIrp.SystemBuffer = Buffer;
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = IRP_MN_KERNEL_CALL;

    if (Function == FSCTL_LMR_GET_LINK_TRACKING_INFORMATION ||
        Function == FSCTL_CREATE_OR_GET_OBJECT_ID ||
        Function == FSCTL_GET_OBJECT_ID ) {
        irpSp->Parameters.FileSystemControl.OutputBufferLength = Length;
    } else {
        irpSp->Parameters.FileSystemControl.InputBufferLength = Length;
    }

    //
    // Take out another reference to the file object to guarantee that it does
    // not get deleted.
    //

    ObReferenceObject( FileObject );

    //
    // Call the driver to get the request.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // Synchronize completion of the request.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( &event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    return status;
}

NTSTATUS
IopGetVolumeId(
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_VOLUMEID_WITH_TYPE ObjectId,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is invoked by the I/O System link tracking code to obtain the
    volume ID for a file that has been moved or is being moved between volumes
    and potentially between systems.

Arguments:

    FileObject - Supplies the file object for the file.

    ObjectId - A buffer to receive the volume object ID.

    Length - Length of the buffer.

Return Value:

    The final function value is the final completion status of the operation.

--*/

{
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    FILE_FS_OBJECTID_INFORMATION volumeId;

    PAGED_CODE();

#if !DBG
    UNREFERENCED_PARAMETER (Length);
#endif

    ASSERT (Length >= sizeof(GUID));

    //
    // Initialize the event structure to synchronize completion of the I/O
    // request.
    //

    KeInitializeEvent( &event,
                       NotificationEvent,
                       FALSE );

    //
    // Build an I/O Request Packet to be sent to the file system driver to get
    // the volume ID.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    irp = IoBuildDeviceIoControlRequest( 0,
                                         deviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the remainder of the IRP to retrieve the volume ID for the
    // file.
    //

    irp->Flags |= IRP_SYNCHRONOUS_API;
    irp->UserBuffer = &volumeId;
    irp->AssociatedIrp.SystemBuffer = &volumeId;
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->Parameters.QueryVolume.Length = sizeof( volumeId );
    irpSp->Parameters.QueryVolume.FsInformationClass = FileFsObjectIdInformation;

    //
    // Take out another reference to the file object to guarantee that it does
    // not get deleted.
    //

    ObReferenceObject( FileObject );

    //
    // Call the driver to get the request.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // Synchronize completion of the request.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( &event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    //
    // If the file system returned the volume ID, copy it to the caller's
    // buffer and set the file system tracking type.
    //

    if (NT_SUCCESS( status )) {
        ObjectId->Type = NtfsLinkTrackingInformation;
        RtlCopyMemory( ObjectId->VolumeId,
                       &volumeId.ObjectId,
                       sizeof( GUID ) );
    }

    return status;
}

PIOP_HARD_ERROR_PACKET
IopRemoveHardErrorPacket(
    VOID
    )
{
    PIOP_HARD_ERROR_PACKET  hardErrorPacket;
    KIRQL oldIrql;
    PVOID entry;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (oldIrql);
#endif

    ExAcquireFastLock( &IopHardError.WorkQueueSpinLock, &oldIrql );

    //
    // The work queue structures are now exclusively owned, so remove the
    // first packet from the head of the list.
    //

    entry = RemoveHeadList( &IopHardError.WorkQueue );

    hardErrorPacket = CONTAINING_RECORD( entry,
                                         IOP_HARD_ERROR_PACKET,
                                         WorkQueueLinks );

    IopCurrentHardError = hardErrorPacket;

    ExReleaseFastLock( &IopHardError.WorkQueueSpinLock, oldIrql );

    return hardErrorPacket;
}

BOOLEAN
IopCheckHardErrorEmpty(
    VOID
    )
{
    BOOLEAN MoreEntries;
    KIRQL   oldIrql;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (oldIrql);
#endif

    MoreEntries = TRUE;

    ExAcquireFastLock( &IopHardError.WorkQueueSpinLock, &oldIrql );

    IopCurrentHardError = NULL;

    if ( IsListEmpty( &IopHardError.WorkQueue ) ) {
        IopHardError.ThreadStarted = FALSE;
        MoreEntries = FALSE;
    }

    ExReleaseFastLock( &IopHardError.WorkQueueSpinLock, oldIrql );

    return MoreEntries;
}

VOID
IopHardErrorThread(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function waits for work on the IopHardErrorQueue, and all calls
    IopRaiseInformationalHardError to actually perform the pop-ups.

Arguments:

    StartContext - Startup context; not used.

Return Value:

    None.

--*/

{
    ULONG parameterPresent;
    ULONG_PTR errorParameter;
    ULONG errorResponse;
    BOOLEAN MoreEntries;
    PIOP_HARD_ERROR_PACKET hardErrorPacket;

    UNREFERENCED_PARAMETER( StartContext );

    PAGED_CODE();
    //
    // Loop, waiting forever for a hard error packet to be sent to this thread.
    // When one is placed onto the queue, wake up, process it, and continue
    // the loop.
    //

    MoreEntries = TRUE;

    do {

        (VOID) KeWaitForSingleObject( &IopHardError.WorkQueueSemaphore,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );

        hardErrorPacket = IopRemoveHardErrorPacket();


        //
        // Simply raise the hard error if the system is ready to accept one.
        //

        errorParameter = (ULONG_PTR) &hardErrorPacket->String;
        parameterPresent = (hardErrorPacket->String.Buffer != NULL);

        if (ExReadyForErrors) {
            (VOID) ExRaiseHardError( hardErrorPacket->ErrorStatus,
                                     parameterPresent,
                                     parameterPresent,
                                     parameterPresent ? &errorParameter : NULL,
                                     OptionOkNoWait,
                                     &errorResponse );
        }

        //
        //  If this was the last entry, exit the thread and mark it as so.
        //

        MoreEntries = IopCheckHardErrorEmpty();

        //
        // Now free the packet and the buffer, if one was specified.
        //

        if (hardErrorPacket->String.Buffer) {
            ExFreePool( hardErrorPacket->String.Buffer );
        }

        ExFreePool( hardErrorPacket );

    } while ( MoreEntries );
}


NTSTATUS
IopInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is the default dispatch routine for all driver entries
    not implemented by drivers that have been loaded into the system.  Its
    responsibility is simply to set the status in the packet to indicate
    that the operation requested is invalid for this device type, and then
    complete the packet.

Arguments:

    DeviceObject - Specifies the device object for which this request is
        bound.  Ignored by this routine.

    Irp - Specifies the address of the I/O Request Packet (IRP) for this
        request.

Return Value:

    The final status is always STATUS_INVALID_DEVICE_REQUEST.


--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Simply store the appropriate status, complete the request, and return
    // the same status stored in the packet.
    //

    if ((IoGetCurrentIrpStackLocation(Irp))->MajorFunction == IRP_MJ_POWER) {
        PoStartNextPowerIrp(Irp);
    }
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_INVALID_DEVICE_REQUEST;
}

LOGICAL
IopIsSameMachine(
    IN PFILE_OBJECT SourceFile,
    IN HANDLE TargetFile
    )

/*++

Routine Description:

    This routine is invoked to determine whether two file objects that represent
    files on remote machines actually reside on the same physical system.

Arguments:

    SourceFile - Supplies the file object for the first file.

    TargetFile - Supplies the file object for the second file.

Return Value:

    The final function value is TRUE if the files reside on the same machine,
    otherwise FALSE is returned.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status = STATUS_NOT_SAME_DEVICE;
    IO_STATUS_BLOCK ioStatus;
    HANDLE target = TargetFile;

    PAGED_CODE();

    //
    // Simply invoke the device I/O control function to determine whether or
    // not the two files are on the same server.  If the fast I/O path does
    // not exist, or the function fails for any reason, then the two files are
    // assumed to not be on the same machine.  Note that this simply means
    // that there will be a performance penalty on open of the target, but
    // the above will only fail if the two files really aren't on the same
    // machine in the first place, or if there's a filter that doesn't under-
    // stand what is being done here.
    //

    deviceObject = IoGetRelatedDeviceObject( SourceFile );

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;
    if (fastIoDispatch && fastIoDispatch->FastIoDeviceControl) {
        if (fastIoDispatch->FastIoDeviceControl( SourceFile,
                                                 TRUE,
                                                 (PVOID) &target,
                                                 sizeof( target ),
                                                 (PVOID) NULL,
                                                 0,
                                                 IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER,
                                                 &ioStatus,
                                                 deviceObject )) {
            status = ioStatus.Status;
        }
    }

    return status == STATUS_SUCCESS;
}

NTSTATUS
IopBuildFullDriverPath(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING FullPath
    )
/*++

Routine Description:

    This routine builds up the full path for the driver. If ImagePath is
    specified, use it or else prepend the standard drivers path.

Arguments:

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

    CheckForSafeBoot - If TRUE, the driver will be loaded only if it belongs
                       to the list of safe mode OK binaries.

    FullPath - Full driver path is returned in this.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS                    status;
    PWCHAR                      path, name, ext;
    ULONG                       pathLength, nameLength, extLength;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    FullPath->Length = FullPath->MaximumLength = 0;
    FullPath->Buffer = NULL;
    extLength = nameLength = pathLength = 0;
    keyValueInformation = NULL;
    status = IopGetRegistryValue( KeyHandle,
                                  L"ImagePath",
                                  &keyValueInformation);
    if (NT_SUCCESS(status) && keyValueInformation->DataLength) {

        nameLength = keyValueInformation->DataLength - sizeof(WCHAR);
        name = (PWCHAR)KEY_VALUE_DATA(keyValueInformation);
        if (name[0] != L'\\') {

            path = L"\\SystemRoot\\";
            pathLength = sizeof(L"\\SystemRoot\\") - sizeof(UNICODE_NULL);
        }
        else {
            path = NULL;
        }
        ext = NULL;
    } else {

        nameLength = KeyName->Length;
        name = KeyName->Buffer;
        pathLength = sizeof(L"\\SystemRoot\\System32\\Drivers\\") - sizeof(UNICODE_NULL);
        path = L"\\SystemRoot\\System32\\Drivers\\";
        extLength = sizeof(L".SYS") - sizeof(UNICODE_NULL);
        ext = L".SYS";
    }
    //
    // Allocate storage for the full path.
    //
    FullPath->MaximumLength = (USHORT)(pathLength + nameLength + extLength + sizeof(UNICODE_NULL));
    FullPath->Buffer = ExAllocatePool(PagedPool, FullPath->MaximumLength);
    if (FullPath->Buffer) {

        FullPath->Length = FullPath->MaximumLength - sizeof(UNICODE_NULL);
        //
        // Create the full path by combining path, name and ext.
        //
        if (path) {

            RtlCopyMemory(FullPath->Buffer, path, pathLength);
        }
        if (nameLength) {

            RtlCopyMemory((PUCHAR)FullPath->Buffer + pathLength, name, nameLength);
        }
        if (extLength) {

            RtlCopyMemory((PUCHAR)FullPath->Buffer + pathLength + nameLength, ext, extLength);
        }
        //
        // NULL terminate the full path.
        //
        FullPath->Buffer[FullPath->Length / sizeof(WCHAR)] = UNICODE_NULL;
        status = STATUS_SUCCESS;

    } else {

        FullPath->MaximumLength = 0;
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Clean up on the way out.
    //
    if (keyValueInformation) {

        ExFreePool(keyValueInformation);
    }

    return status;
}

NTSTATUS
IopLoadDriver(
    IN  HANDLE      KeyHandle,
    IN  BOOLEAN     CheckForSafeBoot,
    IN  BOOLEAN     IsFilter,
    OUT NTSTATUS   *DriverEntryStatus
    )
/*++

Routine Description:

    This routine is invoked to load a device or file system driver, either
    during system initialization, or dynamically while the system is running.

Arguments:

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

    IsFilter - TRUE if the driver is a WDM filter, FALSE otherwise.

    CheckForSafeBoot - If TRUE, the driver will be loaded only if it belongs
                       to the list of safe mode OK binaries.

    DriverEntryStatus - Receives status returned by DriverEntry(...)

Return Value:

    The function value is the final status of the load operation. If
    STATUS_FAILED_DRIVER_ENTRY is returned, the driver's return value
    is stored in DriverEntryStatus.

Notes:

    Note that this routine closes the KeyHandle before returning.


--*/
{
    NTSTATUS status;
    PLIST_ENTRY nextEntry;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    PKEY_BASIC_INFORMATION keyBasicInformation = NULL;
    ULONG keyBasicLength;
    UNICODE_STRING baseName;
    UNICODE_STRING serviceName = {0, 0, NULL};
    OBJECT_ATTRIBUTES objectAttributes;
    PVOID sectionPointer;
    UNICODE_STRING driverName;
    PDRIVER_OBJECT driverObject;
    PIMAGE_NT_HEADERS ntHeaders;
    PVOID imageBaseAddress;
    ULONG_PTR entryPoint;
    HANDLE driverHandle;
    ULONG i;
    POBJECT_NAME_INFORMATION registryPath;
#if DBG
    LARGE_INTEGER stime, etime;
    ULONG dtime;
#endif

    PAGED_CODE();

    driverName.Buffer = (PWSTR) NULL;
    *DriverEntryStatus = STATUS_SUCCESS;
    baseName.Buffer = NULL;

    //
    // Begin by formulating the name of the driver image file to be loaded.
    // Note that this is used to determine whether or not the driver has
    // already been loaded by the OS loader, not necessarily in actually
    // loading the driver image, since the node can override that name.
    //

    status = NtQueryKey( KeyHandle,
                         KeyBasicInformation,
                         (PVOID) NULL,
                         0,
                         &keyBasicLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        //
        // FUTURE - 2002/02/04 - ADRIAO: Improve return codes in low memory
        //                               scenarios.
        //
        status = STATUS_ILL_FORMED_SERVICE_ENTRY;
        goto IopLoadExit;
    }

    keyBasicInformation = ExAllocatePool( NonPagedPool,
                                          keyBasicLength + (4 * 2) );
    if (!keyBasicInformation) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto IopLoadExit;
    }

    status = NtQueryKey( KeyHandle,
                         KeyBasicInformation,
                         keyBasicInformation,
                         keyBasicLength,
                         &keyBasicLength );
    if (!NT_SUCCESS( status )) {
        goto IopLoadExit;
    }

    //
    // Create a Unicode string descriptor which forms the name of the
    // driver.
    //

    baseName.Length = (USHORT) keyBasicInformation->NameLength;
    baseName.MaximumLength = (USHORT) (baseName.Length + (4 * 2));
    baseName.Buffer = &keyBasicInformation->Name[0];

    serviceName.Buffer = ExAllocatePool(PagedPool, baseName.Length + sizeof(UNICODE_NULL));
    if (serviceName.Buffer) {
        serviceName.Length = baseName.Length;
        serviceName.MaximumLength = serviceName.Length + sizeof(UNICODE_NULL);
        RtlCopyMemory(serviceName.Buffer, baseName.Buffer, baseName.Length);
        serviceName.Buffer[serviceName.Length / sizeof(WCHAR)] = UNICODE_NULL;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto IopLoadExit;
    }

    RtlAppendUnicodeToString( &baseName, L".SYS" );

    //
    // Log the file name
    //
    HeadlessKernelAddLogEntry(HEADLESS_LOG_LOADING_FILENAME, &baseName);

    if (CheckForSafeBoot && InitSafeBootMode) {

        BOOLEAN GroupIsGood = FALSE;
        UNICODE_STRING string;
        PKEY_VALUE_PARTIAL_INFORMATION keyValue;
        UCHAR nameBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + 64];
        ULONG length;

        RtlInitUnicodeString( &string, L"Group" );
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)nameBuffer;
        RtlZeroMemory(nameBuffer, sizeof(nameBuffer));

        status = NtQueryValueKey(
            KeyHandle,
            &string,
            KeyValuePartialInformation,
            keyValue,
            sizeof(nameBuffer),
            &length
            );
        if (NT_SUCCESS(status)) {

            string.Length = (USHORT)(keyValue->DataLength - sizeof(WCHAR));
            string.MaximumLength = string.Length;
            string.Buffer = (PWSTR)keyValue->Data;

            if (IopSafebootDriverLoad(&string)) {
                GroupIsGood = TRUE;
            }
        }

        if (!GroupIsGood && !IopSafebootDriverLoad(&baseName)) {
            //
            // don't load the driver
            //

            IopBootLog(&baseName, FALSE);

            DbgPrint("SAFEBOOT: skipping device = %wZ(%wZ)\n",&baseName,&string);
            HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_SUCCESSFUL, NULL);
            return STATUS_SUCCESS;
        }

    }

    //
    // See if this driver has already been loaded by the boot loader.
    //

    //
    // No need to do KeEnterCriticalRegion as this is called
    // from system process only.
    //
    ExAcquireResourceSharedLite( &PsLoadedModuleResource, TRUE );
    nextEntry = PsLoadedModuleList.Flink;
    while (nextEntry != &PsLoadedModuleList) {

        //
        // Look at the next boot driver in the list.
        //

        driverEntry = CONTAINING_RECORD( nextEntry,
                                         KLDR_DATA_TABLE_ENTRY,
                                         InLoadOrderLinks );

        //
        // If this is not the kernel image (ntoskrnl) and not the HAL (hal),
        // then this is a driver, so initialize it.
        //

        if (RtlEqualUnicodeString(  &baseName,
                             &driverEntry->FullDllName,
                            TRUE )) {
            status = STATUS_IMAGE_ALREADY_LOADED;
            ExReleaseResourceLite( &PsLoadedModuleResource );

            IopBootLog(&baseName, TRUE);
            baseName.Buffer = NULL;
            goto IopLoadExit;
        }

        nextEntry = nextEntry->Flink;
    }
    ExReleaseResourceLite( &PsLoadedModuleResource );

    //
    // This driver has not already been loaded by the OS loader.  Form the
    // full path name for this driver.
    //

    status = IopBuildFullDriverPath(&serviceName, KeyHandle, &baseName);
    if (!NT_SUCCESS(status)) {

        baseName.Buffer = NULL;
        goto IopLoadExit;
    }

    //
    // Now get the name of the driver object.
    //

    status = IopGetDriverNameFromKeyNode( KeyHandle,
                                          &driverName );
    if (!NT_SUCCESS( status )) {
        goto IopLoadExit;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_PERMANENT,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Load the driver image into memory.  If this fails partway through
    // the operation, then it will automatically be unloaded.
    //

    status = MmLoadSystemImage( &baseName,
                                NULL,
                                NULL,
                                0,
                                &sectionPointer,
                                (PVOID *) &imageBaseAddress );

    if (!NT_SUCCESS( status )) {

        //
        // If the image was not already loaded then exit.
        //

        if (status != STATUS_IMAGE_ALREADY_LOADED) {

            IopBootLog(&baseName, FALSE);

            goto IopLoadExit;
        }

        //
        // Open the driver object.
        //

        status = ObOpenObjectByName( &objectAttributes,
                                     IoDriverObjectType,
                                     KernelMode,
                                     NULL,
                                     0,
                                     NULL,
                                     &driverHandle );


        if (!NT_SUCCESS( status )) {

            IopBootLog(&baseName, FALSE);

            if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

                //
                // Adjust the exit code so that we can distinguish drivers that
                // aren't present from drivers that are present but have had
                // their driver objects made temporary.
                //
                status = STATUS_DRIVER_FAILED_PRIOR_UNLOAD;
            }

            goto IopLoadExit;
        }

        //
        // Reference the handle and obtain a pointer to the driver object so that
        // the handle can be deleted without the object going away.
        //

        status = ObReferenceObjectByHandle( driverHandle,
                                            0,
                                            IoDriverObjectType,
                                            KeGetPreviousMode(),
                                            (PVOID *) &driverObject,
                                            (POBJECT_HANDLE_INFORMATION) NULL );
        NtClose( driverHandle );

        if (!NT_SUCCESS( status )) {
            IopBootLog(&baseName, FALSE);
            goto IopLoadExit;
        }


        status = IopResurrectDriver( driverObject );

        //
        // Regardless of the status the driver object should be dereferenced.
        // if the unload has already run then driver is almost gone. If
        // the driver has been resurrected then the I/O system still has its
        // original reference.
        //

        ObDereferenceObject( driverObject );
        IopBootLog(&baseName, FALSE);
        goto IopLoadExit;
    } else {

        ntHeaders = RtlImageNtHeader( imageBaseAddress );

        //
        // Check should this driver be loaded.  If yes, the enum subkey
        // of the service will be prepared.
        //

        status = IopPrepareDriverLoading (&serviceName, KeyHandle, imageBaseAddress, IsFilter);
        if (!NT_SUCCESS(status)) {
            MmUnloadSystemImage(sectionPointer);
            IopBootLog(&baseName, FALSE);
            goto IopLoadExit;
        }

    }

    //
    // The driver image has now been loaded into memory.  Create the driver
    // object that represents this image.
    //

    status = ObCreateObject( KeGetPreviousMode(),
                             IoDriverObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) (sizeof( DRIVER_OBJECT ) + sizeof ( DRIVER_EXTENSION )),
                             0,
                             0,
                             (PVOID *) &driverObject );

    if (!NT_SUCCESS( status )) {
        MmUnloadSystemImage(sectionPointer); 
        IopBootLog(&baseName, FALSE);
        goto IopLoadExit;
    }

    //
    // Initialize this driver object and insert it into the object table.
    //

    RtlZeroMemory( driverObject, sizeof( DRIVER_OBJECT ) + sizeof ( DRIVER_EXTENSION) );
    driverObject->DriverExtension = (PDRIVER_EXTENSION) (driverObject + 1);
    driverObject->DriverExtension->DriverObject = driverObject;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        driverObject->MajorFunction[i] = IopInvalidDeviceRequest;
    }

    driverObject->Type = IO_TYPE_DRIVER;
    driverObject->Size = sizeof( DRIVER_OBJECT );
    ntHeaders = RtlImageNtHeader( imageBaseAddress );
    entryPoint = ntHeaders->OptionalHeader.AddressOfEntryPoint;
    entryPoint += (ULONG_PTR) imageBaseAddress;
    if (!(ntHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)) {
        driverObject->Flags |= DRVO_LEGACY_DRIVER;
    }
    driverObject->DriverInit = (PDRIVER_INITIALIZE) entryPoint;
    driverObject->DriverSection = sectionPointer;
    driverObject->DriverStart = imageBaseAddress;
    driverObject->DriverSize = ntHeaders->OptionalHeader.SizeOfImage;

    status = ObInsertObject( driverObject,
                             (PACCESS_STATE) NULL,
                             FILE_READ_DATA,
                             0,
                             (PVOID *) NULL,
                             &driverHandle );
    if (!NT_SUCCESS( status )) {
        IopBootLog(&baseName, FALSE);
        goto IopLoadExit;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KeGetPreviousMode(),
                                        (PVOID *) &driverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );

    ASSERT(status == STATUS_SUCCESS);

    NtClose( driverHandle );

    //
    // Load the Registry information in the appropriate fields of the device
    // object.
    //

    driverObject->HardwareDatabase =
        &CmRegistryMachineHardwareDescriptionSystemName;

    //
    // Store the name of the device driver in the driver object so that it
    // can be easily found by the error log thread.
    //

    driverObject->DriverName.Buffer = ExAllocatePool( PagedPool,
                                                      driverName.MaximumLength );
    if (driverObject->DriverName.Buffer) {
        driverObject->DriverName.MaximumLength = driverName.MaximumLength;
        driverObject->DriverName.Length = driverName.Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       driverName.Buffer,
                       driverName.MaximumLength );
    }

    //
    // Query the name of the registry path for this driver so that it can
    // be passed to the driver.
    //

    registryPath = ExAllocatePool( NonPagedPool, PAGE_SIZE );
    if (!registryPath) {
        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto IopLoadExit;
    }

    status = NtQueryObject( KeyHandle,
                            ObjectNameInformation,
                            registryPath,
                            PAGE_SIZE,
                            &i );
    if (!NT_SUCCESS( status )) {
        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
        ExFreePool( registryPath );
        goto IopLoadExit;
    }

#if DBG
    KeQuerySystemTime (&stime);
#endif

    //
    // Store the service key name of the device driver in the driver object
    //

    if (serviceName.Buffer) {
        driverObject->DriverExtension->ServiceKeyName.Buffer =
            ExAllocatePool( NonPagedPool, serviceName.MaximumLength );
        if (driverObject->DriverExtension->ServiceKeyName.Buffer) {
            driverObject->DriverExtension->ServiceKeyName.MaximumLength = serviceName.MaximumLength;
            driverObject->DriverExtension->ServiceKeyName.Length = serviceName.Length;

            RtlCopyMemory( driverObject->DriverExtension->ServiceKeyName.Buffer,
                           serviceName.Buffer,
                           serviceName.MaximumLength );
        }
    }

    //
    // Now invoke the driver's initialization routine to initialize itself.
    //

    status = driverObject->DriverInit( driverObject, &registryPath->Name );

    *DriverEntryStatus = status;
    if (!NT_SUCCESS(status)) {

        status = STATUS_FAILED_DRIVER_ENTRY;
    }

#if DBG

    //
    // If DriverInit took longer than 5 seconds, print a message.
    //

    KeQuerySystemTime (&etime);
    dtime  = (ULONG) ((etime.QuadPart - stime.QuadPart) / 1000000);

    if (dtime > 50) {
        DbgPrint( "IOLOAD: Driver %wZ took %d.%ds to %s\n",
            &driverName,
            dtime/10,
            dtime%10,
            NT_SUCCESS(status) ? "initialize" : "fail initialization"
            );

    }
#endif

    //
    // Workaround for broken NT 4.0 3D labs driver
    // They zero out some function table entries by mistake.

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        if (driverObject->MajorFunction[i] == NULL) {
            ASSERT(driverObject->MajorFunction[i] != NULL);
            driverObject->MajorFunction[i] = IopInvalidDeviceRequest;
        }
    }

    //
    // If DriverInit doesn't work, then simply unload the image and mark the driver
    // object as temporary.  This will cause everything to be deleted.
    //

    ExFreePool( registryPath );

    //
    // If we load the driver because we think it is a legacy driver and
    // it does not create any device object in its DriverEntry.  We will
    // unload this driver.
    //

    if (NT_SUCCESS(status) && !IopIsLegacyDriver(driverObject)) {

        status = IopPnpDriverStarted(driverObject, KeyHandle, &serviceName);

        if (!NT_SUCCESS(status)) {
            if (driverObject->DriverUnload) {
                driverObject->Flags |= DRVO_UNLOAD_INVOKED;
                driverObject->DriverUnload(driverObject);
                IopBootLog(&baseName, FALSE);
            } else {
#if DBG
                DbgPrint("IopLoadDriver: A PnP driver %wZ does not support DriverUnload routine.\n", &driverName);
                // ASSERT(0);
#endif
            }
        }
    }

    if (!NT_SUCCESS( status )) {
        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    } else {

        //
        // Free the memory occupied by the driver's initialization routines.
        //

        IopBootLog(&baseName, TRUE);
        MmFreeDriverInitialization( driverObject->DriverSection );
        IopReadyDeviceObjects( driverObject );
    }

IopLoadExit:

    if (NT_SUCCESS(status) || (status == STATUS_IMAGE_ALREADY_LOADED)) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_SUCCESSFUL, NULL);
    } else {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
    }

    //
    // Free any pool that was allocated by this routine that has not yet
    // been freed.
    //

    if (driverName.Buffer != NULL) {
        ExFreePool( driverName.Buffer );
    }

    if (keyBasicInformation != NULL) {
        ExFreePool( keyBasicInformation );
    }

    if (serviceName.Buffer != NULL) {
        ExFreePool(serviceName.Buffer);
    }

    if (baseName.Buffer != NULL) {
        ExFreePool(baseName.Buffer);
    }

    //
    // If this routine is about to return a failure, then let the Configuration
    // Manager know about it.  But, if STATUS_PLUGPLAY_NO_DEVICE, the device was
    // disabled by hardware profile.  In this case we don't need to report it.
    //

    if (!NT_SUCCESS( status ) && (status != STATUS_PLUGPLAY_NO_DEVICE)) {

        NTSTATUS lStatus;
        PULONG errorControl;
        PKEY_VALUE_FULL_INFORMATION keyValueInformation;

        if (status != STATUS_IMAGE_ALREADY_LOADED) {

            //
            // If driver was loaded, do not call IopDriverLoadingFailed to change
            // the driver loading status.  Because, obviously, the driver is
            // running.
            //

            IopDriverLoadingFailed(KeyHandle, NULL);
            lStatus = IopGetRegistryValue( KeyHandle,
                                           L"ErrorControl",
                                           &keyValueInformation );
            if (!NT_SUCCESS( lStatus ) || !keyValueInformation->DataLength) {
                if (NT_SUCCESS( lStatus )) {
                    ExFreePool( keyValueInformation );
                }
            } else {
                errorControl = (PULONG) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                CmBootLastKnownGood( *errorControl );
                ExFreePool( keyValueInformation );
            }
        }
    }

    //
    // Close the caller's handle and return the final status from the load
    // operation.
    //

    ObCloseHandle( KeyHandle , KernelMode);
    return status;
}


PDEVICE_OBJECT
IopGetDeviceAttachmentBase(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the lowest level device object associated with
    the specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.

Return Value:

    The function value is a reference to the lowest level device attached
    to the specified device.  If the supplied device object is that device
    object, then a pointer to it is returned.

    N.B. Caller must own the IopDatabaseLock.

--*/

{
    PDEVICE_OBJECT baseDeviceObject;
    PDEVOBJ_EXTENSION deviceExtension;

    //
    // Descend down the attachment chain until we find a device object
    // that isn't attached to anything else.
    //

    baseDeviceObject = DeviceObject;
    deviceExtension = baseDeviceObject->DeviceObjectExtension;
    while (deviceExtension->AttachedTo != NULL) {

        baseDeviceObject = deviceExtension->AttachedTo;
        deviceExtension = baseDeviceObject->DeviceObjectExtension;
    }

    return baseDeviceObject;
}



VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AlwaysUnload,
    IN BOOLEAN OnCleanStack
    )

/*++

Routine Description:

    The routine decrements the reference count on a device object.  If the
    reference count goes to zero and the device object is a candidate for deletion
    then IopCompleteUnloadOrDelete is called.  A device object is subject for
    deletion if the AlwaysUnload flag is true, or the device object is pending
    deletion or the driver is pending unload.

Arguments:

    DeviceObject - Supplies the device object whose reference count is to be
                   decremented.

    AlwaysUnload - Indicates if the driver should be unloaded regardless of the
                   state of the unload flag.

    OnCleanStack - Indicates whether the current thread is in the middle a
                   driver operation.

Return Value:

    None.

--*/
{
    KIRQL irql;

    //
    // Decrement the reference count on the device object.  If this is the last
    // last reason that this mini-file system recognizer needs to stay around,
    // then unload it.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    ASSERT( DeviceObject->ReferenceCount > 0 );

    DeviceObject->ReferenceCount--;

    if (!DeviceObject->ReferenceCount && (AlwaysUnload ||
         DeviceObject->DeviceObjectExtension->ExtensionFlags &
         (DOE_DELETE_PENDING | DOE_UNLOAD_PENDING | DOE_REMOVE_PENDING))) {

        IopCompleteUnloadOrDelete( DeviceObject, OnCleanStack, irql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }

}

VOID
IopLoadFileSystemDriver(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked when a mini-file system recognizer driver recognizes
    a volume as being a particular file system, but the driver for that file
    system has not yet been loaded.  This function allows the mini-driver to
    load the real file system, and remove itself from the system, so that the
    real file system can mount the device in question.

Arguments:

    DeviceObject - Registered file system device object for the mini-driver.

Return Value:

    None.

--*/

{
    KEVENT event;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT attachedDevice;

    PAGED_CODE();

    attachedDevice = DeviceObject;
    while (attachedDevice->AttachedDevice) {
        attachedDevice = attachedDevice->AttachedDevice;
    }

    //
    // Begin by building an I/O Request Packet to have the mini-file system
    // driver load the real file system.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildDeviceIoControlRequest( IRP_MJ_DEVICE_CONTROL,
                                         attachedDevice,
                                         (PVOID) NULL,
                                         0,
                                         (PVOID) NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (irp) {

        //
        // Change the actual major and minor function codes to be a file system
        // control with a minor function code of load FS driver.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_LOAD_FILE_SYSTEM;

        //
        // Now issue the request.
        //

        status = IoCallDriver( attachedDevice, irp );
        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
    }

    //
    // Decrement the reference count on the device object.  If this is the last
    // last reason that this mini-file system recognizer needs to stay around,
    // then unload it.
    //

    IopDecrementDeviceObjectRef(DeviceObject, TRUE, TRUE);

    return;
}

VOID
IopLoadUnloadDriver(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine is executed as an EX worker thread routine when a driver is
    to be loaded or unloaded dynamically.  It is used because some drivers
    need to create system threads in the context of the system process, which
    cannot be done in the context of the caller of the system service that
    was invoked to load or unload the specified driver.

Arguments:

    Parameter - Pointer to the load packet describing what work is to be
        done.

Return Value:

    None.

--*/

{
    PLOAD_PACKET loadPacket;
    NTSTATUS status, driverEntryStatus;
    HANDLE keyHandle;

    PAGED_CODE();

    //
    // Begin by getting a pointer to the load packet.
    //

    loadPacket = (PLOAD_PACKET) Parameter;

    //
    // If the driver object field of the packet is non-NULL, then this is
    // a request to complete the unload of a driver.  Simply invoke the
    // driver's unload routine.  Note that the final status of the unload
    // is ignored, so it is not set here.
    //

    if (loadPacket->DriverObject) {

        loadPacket->DriverObject->DriverUnload( loadPacket->DriverObject );
        status = STATUS_SUCCESS;

    } else {

        //
        // The driver specified by the DriverServiceName is to be loaded.
        // Begin by opening the registry node for this driver.  Note
        // that if this is successful, then the load driver routine is
        // responsible for closing the handle.
        //

        status = IopOpenRegistryKey( &keyHandle,
                                     (HANDLE) NULL,
                                     loadPacket->DriverServiceName,
                                     KEY_READ,
                                     FALSE );
        if (NT_SUCCESS( status )) {

            //
            // Invoke the internal common routine to perform the work.
            // This is the same routine that is used by the I/O system
            // initialization code to load drivers.
            //

            status = IopLoadDriver( keyHandle, TRUE, FALSE, &driverEntryStatus );

            if (status == STATUS_FAILED_DRIVER_ENTRY) {

                status = driverEntryStatus;

            } else if (status == STATUS_DRIVER_FAILED_PRIOR_UNLOAD) {

                //
                // Keep legacy behavior (don't change status code)
                //
                status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

            IopCallDriverReinitializationRoutines();
        }
    }

    //
    // Set the final status of the load or unload operation, and indicate to
    // the caller that the operation is now complete.
    //

    loadPacket->FinalStatus = status;
    (VOID) KeSetEvent( &loadPacket->Event, 0, FALSE );
}

NTSTATUS
IopMountVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount,
    IN BOOLEAN DeviceLockAlreadyHeld,
    IN BOOLEAN Alertable,
    OUT PVPB    *Vpb
    )

/*++

Routine Description:

    This routine is used to mount a volume on the specified device.  The Volume
    Parameter Block (VPB) for the specified device is a "clean" VPB.  That is,
    it indicates that the volume has never been mounted.  It is up to the file
    system that eventually mounts the volume to determine whether the volume is,
    or has been, mounted elsewhere.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - This parameter tells us if we should continue our
        filesystem search to include the Raw file system.  This flag will
        only be passed in as TRUE as a result of a DASD open.

    DeviceLockAlreadyHeld - If TRUE, then the caller has already acquired
        the device lock and we should not attempt to acquire it.  This is
        currently passed in as TRUE when called from IoVerifyVolume.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.


--*/

{
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT fsDeviceObject;
    PDEVICE_OBJECT attachedDevice;
    PLIST_ENTRY entry;
    PLIST_ENTRY queueHeader;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION irpSp;
    ULONG extraStack;
    LIST_ENTRY dummy;
    ULONG rawMountOnly;
    ULONG numRegOps;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    //
    // Obtain the lock for the device to be mounted.  This guarantees that
    // only one thread is attempting to mount (or verify) this particular
    // device at a time.
    //

    if (!DeviceLockAlreadyHeld) {

        status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                        Executive,
                                        KeGetPreviousModeByThread(&CurrentThread->Tcb),
                                        Alertable,
                                        (PLARGE_INTEGER) NULL );

        //
        // If the wait ended because of an alert or an APC, return now
        // without mounting the device.  Note that as the wait for the
        // event was unsuccessful, we do not set it on exit.
        //

        if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

            return status;
        }
    }

    //
    // Now acquire the resource database lock for the I/O system to perform this
    // operation.  This resource protects access to the file system queue.
    //

    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
    (VOID) ExAcquireResourceSharedLite( &IopDatabaseResource, TRUE );

    //
    // Check the 'mounted' flag of the VPB to ensure that it is still clear.
    // If it is, then no one has gotten in before this to mount the volume.
    // Attempt to mount the volume in this case.
    //

    if ((DeviceObject->Vpb->Flags & (VPB_MOUNTED | VPB_REMOVE_PENDING)) == 0) {

        //
        // This volume has never been mounted.  Initialize the event and set the
        // status to unsuccessful to set up for the loop.  Also if the device
        // has the verify bit set, clear it.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );
        status = STATUS_UNSUCCESSFUL;
        DeviceObject->Flags &= ~DO_VERIFY_VOLUME;

        //
        // Get the actual device that this volume is to be mounted on.  This
        // device is the final device in the list of devices which are attached
        // to the specified real device.
        //

        attachedDevice = DeviceObject;
        while (attachedDevice->AttachedDevice) {
            attachedDevice = attachedDevice->AttachedDevice;
        }

        //
        // Reference the device object so it cannot go away.
        //

        ObReferenceObject( attachedDevice );

        //
        // Determine which type of file system should be invoked based on
        // the device type of the device being mounted.
        //

        if (DeviceObject->DeviceType == FILE_DEVICE_DISK ||
            DeviceObject->DeviceType == FILE_DEVICE_VIRTUAL_DISK) {
            queueHeader = &IopDiskFileSystemQueueHead;
        } else if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM) {
            queueHeader = &IopCdRomFileSystemQueueHead;
        } else {
            queueHeader = &IopTapeFileSystemQueueHead;
        }

        rawMountOnly = (DeviceObject->Vpb->Flags & VPB_RAW_MOUNT);

        //
        // Now loop through each of the file systems which have been loaded in
        // the system to see whether anyone understands the media in the device.
        //

        for (entry = queueHeader->Flink;
             entry != queueHeader && !NT_SUCCESS( status );
             entry = entry->Flink) {

            PDEVICE_OBJECT savedFsDeviceObject;

            //
            // If this is the final entry (Raw file system), and it is also
            // not the first entry, and a raw mount is not permitted, then
            // break out of the loop at this point, as this volume cannot
            // be mounted for the caller's purposes.
            //

            if (!AllowRawMount && entry->Flink == queueHeader && entry != queueHeader->Flink) {
                break;
            }

            //
            // If raw mount is the only one requested and this is not the last entry on the list
            // then skip.
            //
            if (rawMountOnly && (entry->Flink != queueHeader)) {
                continue;
            }

            fsDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );
            savedFsDeviceObject = fsDeviceObject;

            //
            // It is possible that the file system has been attached to, so
            // walk the attached list for the file system.  The number of stack
            // locations that must be allocated in the IRP must include one for
            // the file system itself, and then one for each driver that is
            // attached to it.  Account for all of the stack locations required
            // to get through the mount process.
            //

            extraStack = 1;

            while (fsDeviceObject->AttachedDevice) {
                fsDeviceObject = fsDeviceObject->AttachedDevice;
                extraStack++;
            }

            //
            // Another file system has been found and the volume has still not
            // been mounted.  Attempt to mount the volume using this file
            // system.
            //
            // Begin by resetting the event being used for synchronization with
            // the I/O operation.
            //

            KeClearEvent( &event );

            //
            // Allocate and initialize an IRP for this mount operation.  Notice
            // that the flags for this operation appear the same as a page read
            // operation.  This is because the completion code for both of the
            // operations is exactly the same logic.
            //

            irp = IoAllocateIrp ((CCHAR) (attachedDevice->StackSize + extraStack), FALSE);

            if ( !irp ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            irp->Flags = IRP_MOUNT_COMPLETION | IRP_SYNCHRONOUS_PAGING_IO;
            irp->RequestorMode = KernelMode;
            irp->UserEvent = &event;
            irp->UserIosb = &ioStatus;
            irp->Tail.Overlay.Thread = CurrentThread;
            irpSp = IoGetNextIrpStackLocation( irp );
            irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
            irpSp->MinorFunction = IRP_MN_MOUNT_VOLUME;
            irpSp->Flags = AllowRawMount;
            irpSp->Parameters.MountVolume.Vpb = DeviceObject->Vpb;
            irpSp->Parameters.MountVolume.DeviceObject = attachedDevice;

            numRegOps = IopFsRegistrationOps;

            //
            // Increment the number of reasons that this driver cannot
            // be unloaded.  Note that this must be done while still
            // holding the database resource.
            //

            IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                          &savedFsDeviceObject->ReferenceCount );

            ExReleaseResourceLite( &IopDatabaseResource );
            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            status = IoCallDriver( fsDeviceObject, irp );

            //
            // Wait for the I/O operation to complete.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            } else {

                //
                // Ensure that the proper status value gets picked up.
                //

                ioStatus.Status = status;
                ioStatus.Information = 0;
            }

            KeEnterCriticalRegionThread(&CurrentThread->Tcb);
            (VOID) ExAcquireResourceSharedLite( &IopDatabaseResource, TRUE );


            //
            // Decrement the number of reasons that this driver cannot be unloaded.
            // If the device object is for FSREC it could not have gotten de-registered
            // here. It should get de-registered only at the time of loading the driver
            // which should happen later.
            //

            IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                          &savedFsDeviceObject->ReferenceCount );

            //
            // If the operation was successful then set the VPB as mounted.
            //

            if (NT_SUCCESS( ioStatus.Status )) {

                status = ioStatus.Status;

                *Vpb = IopMountInitializeVpb(DeviceObject, attachedDevice, rawMountOnly);

            } else {

                //
                // The mount operation failed.  Make a special check here to
                // determine whether or not a popup was enabled, and if so,
                // check to see whether or not the operation was to be aborted.
                // If so, bail out now and return the error to the caller.
                //

                status = ioStatus.Status;
                if (IoIsErrorUserInduced(status) &&
                    ioStatus.Information == IOP_ABORT) {
                    break;
                }

                //
                // If there were any registrations or unregistrations during the period
                // we unlocked the database resource bail out and start all over again.
                //

                if (numRegOps != IopFsRegistrationOps) {

                    //
                    // Reset the list back to the beginning and start over
                    // again.
                    //

                    dummy.Flink = queueHeader->Flink;
                    entry = &dummy;
                    status = STATUS_UNRECOGNIZED_VOLUME;
                }

                //
                // Also check to see whether or not this is a volume that has
                // been recognized, but the file system for it needs to be
                // loaded.  If so, drop the locks held at this point, tell the
                // mini-file system recognizer to load the driver, and then
                // reacquire the locks.
                //

                if (status == STATUS_FS_DRIVER_REQUIRED) {

                    //
                    // Increment the number of reasons that this driver cannot
                    // be unloaded.  Note that this must be done while still
                    // holding the database resource.
                    //

                    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                                  &savedFsDeviceObject->ReferenceCount );

                    ExReleaseResourceLite( &IopDatabaseResource );
                    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

                    if (!DeviceLockAlreadyHeld) {
                        KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );
                    }
                    IopLoadFileSystemDriver( savedFsDeviceObject );

                    //
                    // Now reacquire the locks, in the correct order, and check
                    // to see if the volume has been mounted before we could
                    // get back.  If so, exit; otherwise, restart the file
                    // file system queue scan from the beginning.
                    //

                    if (!DeviceLockAlreadyHeld) {
                        status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                                        Executive,
                                                        KeGetPreviousModeByThread(&CurrentThread->Tcb),
                                                        Alertable,
                                                        (PLARGE_INTEGER) NULL );
                        if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                            //
                            // The device was not mounted by us so
                            // drop the reference before returning.
                            //

                            ObDereferenceObject( attachedDevice );

                            return status;
                        }
                    }

                    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
                    (VOID) ExAcquireResourceSharedLite( &IopDatabaseResource, TRUE );

                    if (DeviceObject->Vpb->Flags & VPB_MOUNTED) {

                        //
                        //  This volume was mounted before we got back.
                        //  Hence deref the attachedDevice as the other thread
                        //  that got the reference is the one that's going to be
                        //  used by the filesystem.
                        //

                        ObDereferenceObject( attachedDevice );
                        status = STATUS_SUCCESS;
                        break;
                    }

                    //
                    // Reset the list back to the beginning and start over
                    // again.
                    //

                    dummy.Flink = queueHeader->Flink;
                    entry = &dummy;
                    status = STATUS_UNRECOGNIZED_VOLUME;
                }

                //
                // If the error wasn't STATUS_UNRECOGNIZED_VOLUME, and this
                // request is not going to the Raw file system, then there
                // is no reason to continue looping.
                //

                if (!AllowRawMount && (status != STATUS_UNRECOGNIZED_VOLUME) &&
                    FsRtlIsTotalDeviceFailure(status)) {
                    break;
                }

            }
        }

        if (!NT_SUCCESS(status)) {

            //
            // The device was not mounted by us so
            // drop the reference.
            // On success this reference is used by the filesystem 
            // Its usually Vcb->TargetDeviceObject.
            // On a dismount the filesystem deref (Vcb->TargetDeviceObject)
            //

            ObDereferenceObject( attachedDevice );

        }

    } else if((DeviceObject->Vpb->Flags & VPB_REMOVE_PENDING) != 0) {

        //
        // Pnp is attempting to remove this volume.  Don't allow the mount.
        //

        status = STATUS_DEVICE_DOES_NOT_EXIST;

    } else {

        //
        // The volume for this device has already been mounted.  Return a
        // success code.
        //

        status = STATUS_SUCCESS;
    }

    ExReleaseResourceLite( &IopDatabaseResource );
    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

    //
    // Release the I/O database resource lock and the synchronization event for
    // the device.
    //

    if (!DeviceLockAlreadyHeld) {
        KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );
    }

    //
    // Finally, if the mount operation failed, and the target device is the
    // boot partition, then bugcheck the system.  It is not possible for the
    // system to run properly if the system's boot partition cannot be mounted.
    //
    // Note: Don't bugcheck if the system is already booted.
    //

    if (!NT_SUCCESS( status ) &&
        DeviceObject->Flags & DO_SYSTEM_BOOT_PARTITION &&
        InitializationPhase < 2) {
        KeBugCheckEx( UNMOUNTABLE_BOOT_VOLUME, (ULONG_PTR) DeviceObject, status, 0, 0 );
    }

    return status;
}


NTSTATUS
IopInvalidateVolumesForDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is used to force filesystems to, as completely as possible, throw
    out volumes which remain referenced for a given device.

Arguments:

    DeviceObject - Pointer to device object for which volumes are to be
        invalidated.

Return Value:

    The function value is a successful status code if all filesystems accepted the
    operation.  Otherwise, an error code is returned.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS finalStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT fsDeviceObject;
    PDEVICE_OBJECT attachedDevice;
    PFILE_OBJECT storageFileObject;
    HANDLE storageHandle;
    PLIST_ENTRY entry;
    PLIST_ENTRY queueHeader;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION irpSp;
    PKTHREAD CurrentThread;

    PAGED_CODE();


    //
    // Get the actual device that could be mounted on.
    // Note that there could be multiple device objects on the stack that has a
    // VPB and could be potentially mounted on by FS. So we call the FS with every
    // device object that has a VPB. This is really a stupid brute force approach but
    // this is not a high performance path and is backwards compatible.
    //

    for (attachedDevice = DeviceObject ;attachedDevice; attachedDevice = attachedDevice->AttachedDevice) {

        //
        // If the device object has no VPB skip.
        //

        if (!attachedDevice->Vpb) {
            continue;
        }

        //
        // Synchronize against mounts.
        //

        KeWaitForSingleObject(&(attachedDevice->DeviceLock),
                      Executive,
                      KernelMode,
                      FALSE,
                      NULL);
        //
        // Get a handle to this device for use in the fsctl.  The way we have to do
        // this is kind of loopy: note we wind up with two references to clean up.
        //
        // The only use of this fileobject/handle is to communicate the device to
        // invalidate volumes on.  It isn't used for anything else, and must not be.
        //

        storageHandle = NULL;
        storageFileObject = NULL;

        try {

            storageFileObject = IoCreateStreamFileObjectLite( NULL, attachedDevice );
            storageFileObject->Vpb = attachedDevice->Vpb;

            status = ObOpenObjectByPointer( storageFileObject,
                                            OBJ_KERNEL_HANDLE,
                                            NULL,
                                            0,
                                            IoFileObjectType,
                                            KernelMode,
                                            &storageHandle );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            status = GetExceptionCode();
        }

        if (NT_SUCCESS( status )) {

            //
            // Now acquire the resource database lock for the I/O system to perform this
            // operation.  This resource protects access to the file system queue.
            //

            CurrentThread = KeGetCurrentThread ();
            KeEnterCriticalRegionThread(CurrentThread);
            (VOID) ExAcquireResourceSharedLite( &IopDatabaseResource, TRUE );

            //
            // Determine which type of file system should be invoked based on
            // the device type of the device being invalidated.
            //

            if (DeviceObject->DeviceType == FILE_DEVICE_DISK ||
                DeviceObject->DeviceType == FILE_DEVICE_VIRTUAL_DISK) {
                queueHeader = &IopDiskFileSystemQueueHead;
            } else if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM) {
                queueHeader = &IopCdRomFileSystemQueueHead;
            } else {
                queueHeader = &IopTapeFileSystemQueueHead;
            }

            //
            // Initialize the event and set the status to set up
            // for the loop.
            //

            KeInitializeEvent( &event, NotificationEvent, FALSE );
            finalStatus = STATUS_SUCCESS;

            //
            // Now loop through each of the file systems which have been loaded in
            // the system and ask them to invalidate volumes they have had mounted
            // on it.
            //

            for (entry = queueHeader->Flink;
                 entry != queueHeader;
                 entry = entry->Flink) {

                //
                // If this is the final entry (Raw file system), then break out of the
                // loop at this point, as volumes cannot be invalidated for the caller's
                // purposes in Raw.
                //

                if (entry->Flink == queueHeader) {
                    break;
                }

                fsDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );

                //
                // It is possible that the file system has been attached to, so
                // walk the attached list for the file system.
                //

                while (fsDeviceObject->AttachedDevice) {
                    fsDeviceObject = fsDeviceObject->AttachedDevice;
                }

                //
                // Another file system has been found.  Attempt to invalidate volumes
                // using this file system.
                //
                // Begin by resetting the event being used for synchronization with
                // the I/O operation.
                //

                KeClearEvent( &event );

                //
                // Build an IRP for this operation.
                //

                irp = IoBuildDeviceIoControlRequest( FSCTL_INVALIDATE_VOLUMES,
                                                     fsDeviceObject,
                                                     &storageHandle,
                                                     sizeof(HANDLE),
                                                     NULL,
                                                     0,
                                                     FALSE,
                                                     &event,
                                                     &ioStatus );

                if (irp == NULL) {

                    finalStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                irpSp = IoGetNextIrpStackLocation( irp );
                irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

                status = IoCallDriver( fsDeviceObject, irp );

                //
                // Wait for the I/O operation to complete.
                //

                if (status == STATUS_PENDING) {
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );

                    status = ioStatus.Status;

                } else {

                    //
                    // Ensure that the proper status value gets picked up.
                    //

                    ioStatus.Status = status;
                    ioStatus.Information = 0;
                }

                //
                // Commute status' indicating the operation is not implemented
                // to success.  If a filesystem does not implement, it must not
                // hold volumes that are not mounted.
                //

                if (status == STATUS_INVALID_DEVICE_REQUEST ||
                    status == STATUS_NOT_IMPLEMENTED) {

                    status = STATUS_SUCCESS;
                }

                //
                //  Hand back the first failure we get, but plow on anyway.
                //

                if (NT_SUCCESS( finalStatus ) && !NT_SUCCESS( status )) {
                    finalStatus = status;
                }
            }

            ExReleaseResourceLite( &IopDatabaseResource );
            KeLeaveCriticalRegionThread(CurrentThread);

            if (storageFileObject) {
                ObDereferenceObject( storageFileObject );
                if (storageHandle) {
                    ZwClose( storageHandle ); // Note that this is a close for which the FS has not
                                              // gotten the corresponding open.
                }
            }

            status = finalStatus;
        }

        //
        // Unlock the device lock to let mounts go
        //

        KeSetEvent(&(attachedDevice->DeviceLock), IO_NO_INCREMENT, FALSE);
    }


    return status;
}


LOGICAL
IopNotifyPnpWhenChainDereferenced(
    IN PDEVICE_OBJECT *PhysicalDeviceObjects,
    IN ULONG DeviceObjectCount,
    IN BOOLEAN Query,
    OUT PDEVICE_OBJECT *VetoingDevice
    )

/*++

Routine Description:

    Called by PnP when processing a Surprise Removal or a Query Remove.

    In the case of Surprise Removal this function will set DOE_REMOVE_PENDING
    in the device extension flags of the each PDO and all its attached devices.
    For each PDO (and its attachment chain) which currently has a zero
    ReferenceCount DOE_REMOVE_PENDING is reset and DOE_REMOVE_PROCESSED is
    set.  IopChainDereferenceComplete is then called to notify PnP that
    this PDO is ready for removal.

    Then as each remaining PDO and its attachment chain's ReferenceCount drops
    to zero IopCheckUnloadOrDelete will call IopChainDereferenceComplete
    (supplied by PnP).

    In the case of Query Remove this function set DOE_REMOVE_PROCESSED on the
    PDO and all its attached devices to prevent further opens.  It also checks
    to see if the ReferenceCount for all the PDOs and their attached devices is
    zero.  If so it leaves the DOE_REMOVE_PROCESSED set and returns FALSE.  If
    not, it resets the DOE_REMOVE_PROCESSED on all the PDOs and their attached
    devices and returns TRUE.

Arguments:

    PhysicalDeviceObjects   List of PDEVICE_OBJECTs for all of the PDOs to be
                            checked.

    DeviceObjectCount       Count of PDEVICE_OBJECTs in PhysicalDeviceObjects.

    Query                   TRUE if this is for a Query Remove.

    VetoingDevice           Only used for Query Remove, Set to first PDO with a
                            ReferenceCount not equal to zero.  This is used to
                            provide feedback to the user as to why the query
                            may have failed.


Return Value:

    If Query is set then the return value is TRUE if there are outstanding
    opens on any of the PDOs or the attached devices, otherwise FALSE is
    returned.

    If Query is NOT set then the return value is always TRUE.

--*/

{
    PDEVOBJ_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_OBJECT attachedDeviceObject;
    ULONG referenced = 0;
    ULONG pass1SetFlag;
    ULONG pass1ClearFlag;
    LONG i;
    KIRQL irql;

    if (Query) {
        pass1SetFlag = DOE_REMOVE_PROCESSED;
        pass1ClearFlag = 0;
    } else {
        pass1SetFlag = DOE_REMOVE_PENDING;
        pass1ClearFlag = DOE_REMOVE_PROCESSED;
    }

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (i = 0; i < (LONG)DeviceObjectCount; i++) {
        deviceObject = PhysicalDeviceObjects[i];
        deviceExtension = deviceObject->DeviceObjectExtension;

        ASSERT( deviceExtension->DeviceNode != NULL );

        //
        // Assume that at least one device object has a reference.  Walk the
        // entire chain marking them with DOE_REMOVE_PENDING.
        //

        //
        // We don't actually care how many aggregate references there actually
        // are.  All we're interested in is whether there are any.  So we'll OR
        // them together rather than adding them.  That way we don't have to do
        // testing or branching and we don't have to worry about overflow in the
        // highly unlikely event that there are a total of more references than
        // will fit in a ULONG.
        //

        referenced = 0;
        attachedDeviceObject = deviceObject;
        do {
            deviceExtension = attachedDeviceObject->DeviceObjectExtension;

            ASSERT(deviceExtension != NULL);
            ASSERT(!(deviceExtension->ExtensionFlags & pass1SetFlag));


            deviceExtension->ExtensionFlags &= ~pass1ClearFlag;
            deviceExtension->ExtensionFlags |= pass1SetFlag;
            referenced |= attachedDeviceObject->ReferenceCount;

            attachedDeviceObject = attachedDeviceObject->AttachedDevice;

        } while (attachedDeviceObject != NULL);

        if (!Query && referenced == 0) {

            //
            // There aren't any outstanding references, retraverse the chain and
            // mark them all DOE_REMOVE_PROCESSED.  This will still prevent any
            // opens or attaches from occuring but we won't call
            // IopChainDereferenceComplete in IopCompleteUnloadOrDelete.
            //

            attachedDeviceObject = deviceObject;
            do {
                deviceExtension = attachedDeviceObject->DeviceObjectExtension;

                deviceExtension->ExtensionFlags &= ~DOE_REMOVE_PENDING;
                deviceExtension->ExtensionFlags |= DOE_REMOVE_PROCESSED;

                attachedDeviceObject = attachedDeviceObject->AttachedDevice;

            } while (attachedDeviceObject != NULL);

            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

            IopChainDereferenceComplete( deviceObject, TRUE );

            irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
        } else if (Query && referenced != 0) {
            break;
        }
    }

    if (Query && referenced != 0) {

        if (VetoingDevice != NULL) {
            *VetoingDevice = deviceObject;
        }

        for (; i >= 0; i--) {
            deviceObject = PhysicalDeviceObjects[i];
            deviceExtension = deviceObject->DeviceObjectExtension;

            //
            // There are outstanding references, retraverse the chain and
            // unset DOE_REMOVE_PROCESSED.
            //

            attachedDeviceObject = deviceObject;
            do {
                deviceExtension = attachedDeviceObject->DeviceObjectExtension;

                deviceExtension->ExtensionFlags &= ~DOE_REMOVE_PROCESSED;

                attachedDeviceObject = attachedDeviceObject->AttachedDevice;

            } while (attachedDeviceObject != NULL);
        }
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return !Query || referenced != 0;
}

NTSTATUS
IopOpenLinkOrRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PVOID RenameBuffer,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked by the rename, set link and set copy-on-write code
    in the I/O system's NtSetInformationFile system service when the caller has
    specified a fully qualified file name as the target of a rename, set link,
    or set copy-on-write operation.  This routine attempts to open the parent
    of the specified file and checks the following:

        o   If the file itself exists, then the caller must have specified that
            the target is to be replaced, otherwise an error is returned.

        o   Ensures that the target file specification refers to the same volume
            upon which the source file exists.

Arguments:

    TargetHandle - Supplies the address of a variable to return the handle to
        the opened target file if no errors have occurred.

    Irp - Supplies a pointer to the IRP that represents the current rename
        request.

    RenameBuffer - Supplies a pointer to the system intermediate buffer that
        contains the caller's rename parameters.

    FileObject - Supplies a pointer to the file object representing the file
        being renamed.

Return Value:

    The function value is the final status of the operation.

Note:

    This function assumes that the layout of a rename, set link and set
    copy-on-write information structure are exactly the same.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING newFileName;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT targetFileObject;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PFILE_RENAME_INFORMATION renameBuffer = RenameBuffer;
    FILE_BASIC_INFORMATION  basicInformation;
    ACCESS_MASK accessMask;

    PAGED_CODE();

    ASSERT( sizeof( FILE_RENAME_INFORMATION ) ==
            sizeof( FILE_LINK_INFORMATION ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, ReplaceIfExists ) ==
            FIELD_OFFSET( FILE_LINK_INFORMATION, ReplaceIfExists ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, RootDirectory ) ==
            FIELD_OFFSET( FILE_LINK_INFORMATION, RootDirectory ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileNameLength ) ==
            FIELD_OFFSET( FILE_LINK_INFORMATION, FileNameLength ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName ) ==
            FIELD_OFFSET( FILE_LINK_INFORMATION, FileName ) );

    ASSERT( sizeof( FILE_RENAME_INFORMATION ) ==
            sizeof( FILE_MOVE_CLUSTER_INFORMATION ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, ReplaceIfExists ) ==
            FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, ClusterCount ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, RootDirectory ) ==
            FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, RootDirectory ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileNameLength ) ==
            FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, FileNameLength ) );
    ASSERT( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName ) ==
            FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, FileName ) );

    //
    // Check if the fileobject is a directory or a regular file.
    // The access mask is different based on that behaviour.
    //

    accessMask = FILE_WRITE_DATA;

    if (!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        status = IopGetBasicInformationFile(FileObject, &basicInformation);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (basicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            accessMask = FILE_ADD_SUBDIRECTORY;
        }
    }

    //
    // A fully qualified file name was specified.  Begin by attempting to open
    // the parent directory of the specified target file.
    //

    newFileName.Length = (USHORT) renameBuffer->FileNameLength;
    newFileName.MaximumLength = (USHORT) renameBuffer->FileNameLength;
    newFileName.Buffer = renameBuffer->FileName;

    InitializeObjectAttributes( &objectAttributes,
                                &newFileName,
                                (FileObject->Flags & FO_OPENED_CASE_SENSITIVE ? 0 : OBJ_CASE_INSENSITIVE)|OBJ_KERNEL_HANDLE,
                                renameBuffer->RootDirectory,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Check if the fileobject is not to the top of the stack.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {

        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =
            (PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        ASSERT(!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN));

        status = IoCreateFileSpecifyDeviceObjectHint( &handle,
                                                      accessMask | SYNCHRONIZE,
                                                      &objectAttributes,
                                                      &ioStatus,
                                                      (PLARGE_INTEGER) NULL,
                                                      0,
                                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                      FILE_OPEN,
                                                      FILE_OPEN_FOR_BACKUP_INTENT,
                                                      (PVOID) NULL,
                                                      0L,
                                                      CreateFileTypeNone,
                                                      (PVOID) NULL,
                                                      IO_NO_PARAMETER_CHECKING |
                                                      IO_OPEN_TARGET_DIRECTORY |
                                                      IO_FORCE_ACCESS_CHECK |
                                                      IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT,
                                                      fileObjectExtension->TopDeviceObjectHint );

    } else {

        status = IoCreateFile( &handle,
                               accessMask | SYNCHRONIZE,
                               &objectAttributes,
                               &ioStatus,
                               (PLARGE_INTEGER) NULL,
                               0,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_OPEN_FOR_BACKUP_INTENT,
                               (PVOID) NULL,
                               0L,
                               CreateFileTypeNone,
                               (PVOID) NULL,
                               IO_NO_PARAMETER_CHECKING |
                               IO_OPEN_TARGET_DIRECTORY |
                               IO_FORCE_ACCESS_CHECK );
    }

    if (NT_SUCCESS( status )) {
        //
        // The open operation for the target file's parent directory was
        // successful.  Check to see whether or not the file exists.
        //

        irpSp = IoGetNextIrpStackLocation( Irp );
        if (irpSp->Parameters.SetFile.FileInformationClass == FileLinkInformation &&
            !renameBuffer->ReplaceIfExists &&
            ioStatus.Information == FILE_EXISTS) {

            //
            // The target file exists, and the caller does not want to replace
            // it.  This is a name collision error so cleanup and return.
            //

            ObCloseHandle( handle , KernelMode);
            status = STATUS_OBJECT_NAME_COLLISION;

        } else {

            //
            // Everything up to this point is fine, so dereference the handle
            // to a pointer to the file object and ensure that the two file
            // specifications refer to the same device.
            //

            status = ObReferenceObjectByHandle( handle,
                                              accessMask,
                                              IoFileObjectType,
                                              KernelMode,
                                              (PVOID *) &targetFileObject,
                                              &handleInformation );
            if (NT_SUCCESS( status )) {

                ObDereferenceObject( targetFileObject );

                if (IoGetRelatedDeviceObject( targetFileObject) !=
                    IoGetRelatedDeviceObject( FileObject )) {

                    //
                    // The two files refer to different devices.  Clean everything
                    // up and return an appropriate error.
                    //

                    ObCloseHandle( handle, KernelMode );
                    status = STATUS_NOT_SAME_DEVICE;

                } else {

                    //
                    // Otherwise, everything worked, so allow the rename operation
                    // to continue.
                    //

                    irpSp->Parameters.SetFile.FileObject = targetFileObject;
                    *TargetHandle = handle;
                    status = STATUS_SUCCESS;

                }

            } else {

                //
                // There was an error referencing the handle to what should
                // have been the target directory.  This generally means that
                // there was a resource problem or the handle was invalid, etc.
                // Simply attempt to close the handle and return the error.
                //

                ObCloseHandle( handle , KernelMode);

            }

        }
    }

    //
    // Return the final status of the operation.
    //

    return status;
}

NTSTATUS
IopOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    IN KPROCESSOR_MODE Mode,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

    Mode - Previous mode of the caller to this API.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( FileObject )) {
            status = IopAcquireFileObjectLock( FileObject,
                                               Mode,
                                               (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( FileObject );
                return status;
            }
        }
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = Mode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
    } else {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = FileInformation ?
                           IRP_MJ_QUERY_INFORMATION :
                           IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = Information;
    irp->Flags |= IRP_BUFFERED_IO;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    if (FileInformation) {
        irpSp->Parameters.QueryFile.Length = Length;
        irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;
    } else {
        irpSp->Parameters.QueryVolume.Length = Length;
        irpSp->Parameters.QueryVolume.FsInformationClass = InformationClass;
    }

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject( &FileObject->Event,
                                            Executive,
                                            Mode,
                                            (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );
            if (status == STATUS_ALERTED) {
                IopCancelAlertedRequest( &FileObject->Event, irp );
            }
            status = FileObject->FinalStatus;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait
        // for the local event and copy the final status information
        // back to the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    *ReturnedLength = (ULONG) localIoStatus.Information;
    return status;
}

VOID
IopRaiseHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine raises a hard error popup in the context of the current
    thread.  The APC was used to get into the context of this thread so that
    the popup would be sent to the appropriate port.

Arguments:

    NormalContext - Supplies a pointer to the I/O Request Packet (IRP) that
        was initially used to request the operation that has failed.

    SystemArgument1 - Supplies a pointer to the media's volume parameter block.
        See IoRaiseHardError documentation for more information.

    SystemArgument2 - Supplies a pointer to the real device object.  See
        IoRaiseHardError documentation for more information.

Return Value:

    None.

--*/

{
    ULONG_PTR parameters[2];
    ULONG numberOfParameters;
    ULONG parameterMask;
    ULONG response;
    NTSTATUS status;
    PIRP irp = (PIRP) NormalContext;
    PVPB vpb = (PVPB) SystemArgument1;
    PDEVICE_OBJECT realDeviceObject = (PDEVICE_OBJECT) SystemArgument2;

    ULONG length = 0;
    POBJECT_NAME_INFORMATION objectName;

    UNICODE_STRING labelName;

    //
    // Determine the name of the device and the volume label of the offending
    // media.  Start by determining the size of the DeviceName, and allocate
    // enough storage for both the ObjectName structure and the string
    // because "that's the ways Steve's routine works".
    //

    ObQueryNameString( realDeviceObject, NULL, 0, &length );

    if ((objectName = ExAllocatePool(PagedPool, length)) == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS( status ) ||
        !NT_SUCCESS( status = ObQueryNameString( realDeviceObject,
                                                 objectName,
                                                 length,
                                                 &response ) )) {

        //
        // Allocation of the pool to put up this popup did not work or
        // something else failed, so there isn't really much that can be
        // done here.  Simply return an error back to the user.
        //

        if (objectName) {
            ExFreePool( objectName );
        }

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

        IoCompleteRequest( irp, IO_DISK_INCREMENT );

        return;
    }

    //
    // The volume label has a max size of 32 characters (Unicode).  Convert
    // it to a Unicode string for output in the popup message.
    //

    if (vpb != NULL && vpb->Flags & VPB_MOUNTED) {

        labelName.Buffer = &vpb->VolumeLabel[0];
        labelName.Length = vpb->VolumeLabelLength;
        labelName.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;

    } else {

        RtlInitUnicodeString( &labelName, NULL );
    }

    //
    // Different pop-ups have different printf formats.  Depending on the
    // specific error value, adjust the parameters.
    //

    switch( irp->IoStatus.Status ) {

    case STATUS_MEDIA_WRITE_PROTECTED:
    case STATUS_WRONG_VOLUME:

        numberOfParameters = 2;
        parameterMask = 3;

        parameters[0] = (ULONG_PTR) &labelName;
        parameters[1] = (ULONG_PTR) &objectName->Name;

        break;

    case STATUS_DEVICE_NOT_READY:
    case STATUS_IO_TIMEOUT:
    case STATUS_NO_MEDIA_IN_DEVICE:
    case STATUS_UNRECOGNIZED_MEDIA:

        numberOfParameters = 1;
        parameterMask = 1;

        parameters[0] = (ULONG_PTR) &objectName->Name;
        parameters[1] = 0;

        break;

    default:

        numberOfParameters = 0;
        parameterMask = 0;

    }

    //
    // Simply raise the hard error.
    //

    if (ExReadyForErrors) {
        status = ExRaiseHardError( irp->IoStatus.Status,
                                   numberOfParameters,
                                   parameterMask,
                                   parameters,
                                   OptionCancelTryContinue,
                                   &response );

    } else {

        status = STATUS_UNSUCCESSFUL;
        response = ResponseReturnToCaller;
    }

    //
    // Free any pool or other resources that were allocated to output the
    // popup.
    //

    ExFreePool( objectName );

    //
    // If there was a problem, or the user didn't want to retry, just
    // complete the request.  Otherwise simply call the driver entry
    // point and retry the IRP as if it had never been tried before.
    //

    if (!NT_SUCCESS( status ) || response != ResponseTryAgain) {

        //
        // Before completing the request, make one last check.  If this was
        // a mount request, and the reason for the failure was t/o, no media,
        // or unrecognized media, then set the Information field of the status
        // block to indicate whether or not an abort was performed.
        //

        if (response == ResponseCancel) {
            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( irp );
            if (irpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {
                irp->IoStatus.Information = IOP_ABORT;
            } else {
                irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
            }
        }

        //
        // An error was incurred, so zero out the information field before
        // completing the request if this was an input operation.  Otherwise,
        // IopCompleteRequest will try to copy to the user's buffer.
        //

        if (irp->Flags & IRP_INPUT_OPERATION) {
            irp->IoStatus.Information = 0;
        }

        IoCompleteRequest( irp, IO_DISK_INCREMENT );

    } else {

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( irp );
        PDEVICE_OBJECT fsDeviceObject = irpSp->DeviceObject;
        PDRIVER_OBJECT driverObject = fsDeviceObject->DriverObject;

        //
        // Retry the request from the top.
        //

        driverObject->MajorFunction[irpSp->MajorFunction]( fsDeviceObject,
                                                           irp );

    }
}

VOID
IopRaiseInformationalHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine performs the actual pop-up.  It will called from either the
    hard-error thread, or a APC routine in a user thread after exiting the
    file system.

Arguments:

    NormalContext - Contains the information for the pop-up

    SystemArgument1 - not used.

    SystemArgument1 - not used.

Return Value:

    None.

--*/

{
    ULONG parameterPresent;
    ULONG_PTR errorParameter;
    ULONG errorResponse;
    PIOP_HARD_ERROR_PACKET hardErrorPacket;

    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    hardErrorPacket = (PIOP_HARD_ERROR_PACKET) NormalContext;

    //
    // Simply raise the hard error if the system is ready to accept one.
    //

    errorParameter = (ULONG_PTR) &hardErrorPacket->String;

    parameterPresent = (hardErrorPacket->String.Buffer != NULL);

    if (ExReadyForErrors) {
        (VOID) ExRaiseHardError( hardErrorPacket->ErrorStatus,
                                 parameterPresent,
                                 parameterPresent,
                                 parameterPresent ? &errorParameter : NULL,
                                 OptionOkNoWait,
                                 &errorResponse );
    }

    //
    // Now free the packet and the buffer, if one was specified.
    //

    if (hardErrorPacket->String.Buffer) {
        ExFreePool( hardErrorPacket->String.Buffer );
    }

    ExFreePool( hardErrorPacket );
    InterlockedDecrement(&IopHardError.NumPendingApcPopups);
}

VOID
IopReadyDeviceObjects(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is invoked to mark all of the device objects owned by the
    specified driver as having been fully initialized and therefore ready
    for access by other drivers/clients.

Arguments:

    DriverObject - Supplies a pointer to the driver object for the driver
        whose devices are to be marked as being "ready".

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;

    PAGED_CODE();

    //
    // Loop through all of the driver's device objects, clearing the
    // DO_DEVICE_INITIALIZING flag.
    //

    DriverObject->Flags |= DRVO_INITIALIZED;
    while (deviceObject) {
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        deviceObject = deviceObject->NextDevice;
    }
}

NTSTATUS
IopResurrectDriver(
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is invoked to clear unload pending flag on all of the device
    objects owned by the specified driver, if the unload routine has not run.
    This allows the driver to come back to life after a pending unload.


Arguments:

    DriverObject - Supplies a pointer to the driver object for the driver
        whose devices are to be cleared.

Return Value:

    Status - Returns success if the driver's unload routine has not run;
        otherwise STATUS_IMAGE_ALREADY_LOADED is returned.

--*/

{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    KIRQL irql;

    //
    // Acquire the I/O spinlock that protects the device list and
    // driver flags.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if (DriverObject->Flags & DRVO_UNLOAD_INVOKED || !deviceObject ||
        !(deviceObject->DeviceObjectExtension->ExtensionFlags & DOE_UNLOAD_PENDING)) {

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return STATUS_IMAGE_ALREADY_LOADED;
    }

    //
    // Loop through all of the driver's device objects, clearing the
    // DOE_UNLOAD_PENDING flag.
    //

    while (deviceObject) {
        deviceObject->DeviceObjectExtension->ExtensionFlags &= ~DOE_UNLOAD_PENDING;
        deviceObject = deviceObject->NextDevice;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return STATUS_SUCCESS;

}

VOID
IopMarshalIds(
    OUT PTRACKING_BUFFER TrackingBuffer,
    IN  PFILE_VOLUMEID_WITH_TYPE  TargetVolumeId,
    IN  PFILE_OBJECTID_BUFFER  TargetObjectId,
    IN  PFILE_TRACKING_INFORMATION TrackingInfo
    )

/*++

Routine Description:

    This routine marshals the TargetVolumeId and TargetObjectId
    into the supplied TrackingBuffer in a standard remotable format.

    It also clears the DestinationFile handle to NULL, and sets the
    ObjectInformationLength to the size of the marshalled data.

Arguments:

    TrackingBuffer - The buffer to receive the marshalled parameters.

    TargetVolumeId - The volume id to marshal.

    TargetObjectId - The object id to marshal.

    TrackingInfo   - The additional tracking information to marshal.

--*/

{
    ULONG ObjectInformationLength = 0;

    TrackingBuffer->TrackingInformation.DestinationFile = (HANDLE) NULL;

    RtlZeroMemory( &TrackingBuffer->TrackingInformation.ObjectInformation[ ObjectInformationLength ],
                   sizeof(TargetVolumeId->Type) );

    RtlCopyMemory( &TrackingBuffer->TrackingInformation.ObjectInformation[ ObjectInformationLength ],
                   &TargetVolumeId->Type,
                   sizeof(TargetVolumeId->Type) );
    ObjectInformationLength += sizeof(TargetVolumeId->Type);

    RtlCopyMemory( &TrackingBuffer->TrackingInformation.ObjectInformation[ ObjectInformationLength ],
                   &TargetVolumeId->VolumeId[0],
                   sizeof(TargetVolumeId->VolumeId) );
    ObjectInformationLength += sizeof(TargetVolumeId->VolumeId);

    RtlCopyMemory( &TrackingBuffer->TrackingInformation.ObjectInformation[ ObjectInformationLength ],
                   &TargetObjectId->ObjectId[0],
                   sizeof(TargetObjectId->ObjectId) );
    ObjectInformationLength += sizeof(TargetObjectId->ObjectId);

    RtlCopyMemory( &TrackingBuffer->TrackingInformation.ObjectInformation[ ObjectInformationLength ],
                   &TrackingInfo->ObjectInformation[0],
                   TrackingInfo->ObjectInformationLength );
    ObjectInformationLength += TrackingInfo->ObjectInformationLength;

    TrackingBuffer->TrackingInformation.ObjectInformationLength = ObjectInformationLength;

}

VOID
IopUnMarshalIds(
    IN  FILE_TRACKING_INFORMATION * TrackingInformation,
    OUT FILE_VOLUMEID_WITH_TYPE * TargetVolumeId,
    OUT GUID * TargetObjectId,
    OUT GUID * TargetMachineId
    )

/*++

Routine Description:

    This routine unmarshals the TargetVolumeId and TargetObjectId
    from the supplied TrackingInformation from a standard remotable format.

Arguments:

    TrackingInformation - The buffer containing the marshalled parameters.

    TargetVolumeId - Buffer to receive the volume id.

    TargetObjectId - Buffer to receive the object id.

    TargetMachineId - Buffer to receieve the machine id.

--*/

{
    ULONG ObjectInformationLength = 0;

    RtlCopyMemory( &TargetVolumeId->Type,
                   &TrackingInformation->ObjectInformation[ ObjectInformationLength ],
                   sizeof(TargetVolumeId->Type) );
    ObjectInformationLength += sizeof(TargetVolumeId->Type);


    RtlCopyMemory( &TargetVolumeId->VolumeId[0],
                   &TrackingInformation->ObjectInformation[ ObjectInformationLength ],
                   sizeof(TargetVolumeId->VolumeId) );
    ObjectInformationLength += sizeof(TargetVolumeId->VolumeId);

    RtlCopyMemory( TargetObjectId,
                   &TrackingInformation->ObjectInformation[ ObjectInformationLength ],
                   sizeof(*TargetObjectId) );
    ObjectInformationLength += sizeof(*TargetObjectId);

    if( TrackingInformation->ObjectInformationLength > ObjectInformationLength ) {
        RtlCopyMemory( TargetMachineId,
                       &TrackingInformation->ObjectInformation[ ObjectInformationLength ],
                       min( sizeof(*TargetMachineId), TrackingInformation->ObjectInformationLength - ObjectInformationLength) );
        // ObjectInformationLength += sizeof(GUID);
    }
}


NTSTATUS
IopSendMessageToTrackService(
    IN PFILE_VOLUMEID_WITH_TYPE SourceVolumeId,
    IN PFILE_OBJECTID_BUFFER SourceObjectId,
    IN PFILE_TRACKING_INFORMATION TargetObjectInformation
    )

/*++

Routine Description:

    This routine is invoked to send a message to the user-mode link tracking
    service to inform it that a file has been moved so that it can track it
    by its object ID.

Arguments:

    SourceVolumeId - Volume ID of the source file.

    SourceObjectId - Object ID of the source file.

    TargetObjectInformation - Volume ID, object ID of the target file.

Return Value:

    The final function value is the final completion status of the operation.


--*/

{
    typedef struct _LINK_TRACKING_MESSAGE {
        NTSTATUS Status;
        ULONG Request;
        FILE_VOLUMEID_WITH_TYPE SourceVolumeId;    // src vol type & id
        FILE_OBJECTID_BUFFER     SourceObjectId;    // src obj id & birth info
        FILE_VOLUMEID_WITH_TYPE TargetVolumeId;    // tgt vol type & id
        GUID TargetObjectId;                        // tgt obj id
        GUID TargetMachineId;
    } LINK_TRACKING_MESSAGE, *PLINK_TRACKING_MESSAGE;

    typedef struct _LINK_TRACKING_RESPONSE {
        NTSTATUS Status;
    } LINK_TRACKING_RESPONSE, *PLINK_TRACKING_RESPONSE;

    PPORT_MESSAGE portMessage;
    PPORT_MESSAGE portReplyMessage;
    CHAR portReply[ 256 ];
    PLINK_TRACKING_MESSAGE requestMessage;
    PLINK_TRACKING_RESPONSE replyMessage;
    NTSTATUS status;
    ULONG loopCount = 0;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();
    //
    // Begin by determining whether or not the LPC port to the link tracking
    // service has been opened.  If not, then attempt to open it now.
    //

retry:

    if (!IopLinkTrackingServiceObject) {

        //
        // The port has not yet been opened.  Check to see whether or not
        // the service has been started.  If not, then get out now as there
        // will be no port if the service is not running.
        //

        if (!KeReadStateEvent( IopLinkTrackingServiceEvent )) {
            return STATUS_NO_TRACKING_SERVICE;
        }

                for (;; ) {
                        status = KeWaitForSingleObject(&IopLinkTrackingPortObject,
                                                                                  Executive,
                                                                                  PreviousMode,
                                                                                  FALSE,
                                                                                  (PLARGE_INTEGER) NULL );

                        if ((status == STATUS_USER_APC) || (status == STATUS_ALERTED)) {
                                return status;
                        }

                        //
                        // There is no referenced object pointer to the
                        // link tracking port so open it.
                        //
                        if (!IopLinkTrackingServiceObject)  {
                                ExInitializeWorkItem(
                                        &IopLinkTrackingPacket.WorkQueueItem,
                                        IopConnectLinkTrackingPort,
                                        &IopLinkTrackingPacket);
                                (VOID)KeResetEvent(&IopLinkTrackingPacket.Event);
                                ExQueueWorkItem( &IopLinkTrackingPacket.WorkQueueItem,
                                                                        DelayedWorkQueue );
                                status = KeWaitForSingleObject(
                                                        &IopLinkTrackingPacket.Event,
                                                        Executive,
                                                        PreviousMode,
                                                        FALSE,
                                                        (PLARGE_INTEGER) NULL );

                                if ((status == STATUS_USER_APC) || (status == STATUS_ALERTED)) {
                                        NOTHING;
                                } else if (!NT_SUCCESS( IopLinkTrackingPacket.FinalStatus )) {
                                        status = IopLinkTrackingPacket.FinalStatus;
                                }

                                KeSetEvent(&IopLinkTrackingPortObject,
                                                0,
                                                FALSE);
                                if (status == STATUS_SUCCESS) {
                                                break;
                                } else {
                                        return status;
                                }

                        } else {
                                //
                                // The connection is established.
                                //

                                KeSetEvent(&IopLinkTrackingPortObject,
                                                0,
                                                FALSE);
                                break;
                        }
        }
    }

    //
    // Form a message from the input parameters and send it to the caller.
    //

    portMessage = ExAllocatePool( PagedPool,
                                  sizeof( LINK_TRACKING_MESSAGE ) +
                                  sizeof( PORT_MESSAGE ) );
    if (!portMessage) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    requestMessage = (PLINK_TRACKING_MESSAGE) (portMessage + 1);
    RtlZeroMemory( requestMessage, sizeof(*requestMessage) );

    requestMessage->Status = STATUS_SUCCESS;
    requestMessage->Request = 0;

    RtlCopyMemory( &requestMessage->SourceVolumeId,
                   SourceVolumeId,
                   sizeof( FILE_VOLUMEID_WITH_TYPE ) );

    RtlCopyMemory( &requestMessage->SourceObjectId,
                   SourceObjectId,
                   sizeof( FILE_OBJECTID_BUFFER ) );

    IopUnMarshalIds(  TargetObjectInformation,
                   &requestMessage->TargetVolumeId,
                   &requestMessage->TargetObjectId,
                   &requestMessage->TargetMachineId);

    portMessage->u1.s1.TotalLength = (USHORT) (sizeof( PORT_MESSAGE ) +
                                              sizeof( LINK_TRACKING_MESSAGE ));
    portMessage->u1.s1.DataLength = (USHORT) sizeof( LINK_TRACKING_MESSAGE );
    portMessage->u2.ZeroInit = 0;

    status = LpcRequestWaitReplyPort( IopLinkTrackingServiceObject,
                                      portMessage,
                                      (PPORT_MESSAGE) &portReply[0] );
    if (!NT_SUCCESS( status )) {
        if (status == STATUS_PORT_DISCONNECTED) {
                        status = KeWaitForSingleObject(&IopLinkTrackingPortObject,
                                                                                                Executive,
                                                                                                PreviousMode,
                                                                                                FALSE,
                                                                                                (PLARGE_INTEGER) NULL );
            ObDereferenceObject( IopLinkTrackingServiceObject );
                        IopLinkTrackingServiceObject = NULL;
                        KeSetEvent(&IopLinkTrackingPortObject,
                                0,
                                FALSE);
            if (!loopCount) {
                loopCount += 1;
                goto retry;
            }
        }
    }

    if (NT_SUCCESS( status )) {
        portReplyMessage = (PPORT_MESSAGE) &portReply[0];
        replyMessage = (PLINK_TRACKING_RESPONSE) (portReplyMessage + 1);
        status = replyMessage->Status;
    }

    return status;
}

NTSTATUS
IopSetEaOrQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN SetEa
    )

/*++

Routine Description:

    This routine is invoked by the NtSetEa[Quota]InformationFile system services
    to either modify the EAs on a file or the quota entries on a volume.  All of
    the specified entries in the buffer are made to the file or volume.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the entries are
        to be applied.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer containing the entries to be added/modified.

    Length - Supplies the length, in bytes, of the buffer.

    SetEa - A BOOLEAN that indicates whether to change the EAs on a file or
        the quota entries on the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock);

            //
            // The Buffer parameter must be readable by the caller.
            //

            ProbeForRead( Buffer, Length, sizeof( ULONG ) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Cleanup and return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        SetEa ? FILE_WRITE_EA : FILE_WRITE_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (!event) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = SetEa ? IRP_MJ_SET_EA : IRP_MJ_SET_QUOTA;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  if the flag is set, then a system buffer is
    // allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag
    // is set in the device object, then a Memory Descriptor List (MDL) is
    // allocated and the caller's buffer is locked down using it.  Finally, if
    // the driver specifies neither of the flags, then simply pass the address
    // and length of the buffer and allow the driver to perform all of the
    // checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        PVOID systemBuffer;
        ULONG errorOffset;

        if (Length) {
            //
            // The driver wishes the caller's buffer to be copied into an
            // intermediary buffer.  Allocate the system buffer and specify
            // that it should be deallocated on completion.  Also check to
            // ensure that the caller's EA list or quota list is valid.  All
            // of this is performed within an exception handler that will perform
            // cleanup if the operation fails.
            //

            try {

                //
                // Allocate the intermediary system buffer and charge the caller
                // quota for its allocation.  Copy the caller's buffer into the
                // system buffer and check to ensure that it is valid.
                //

                systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

                irp->AssociatedIrp.SystemBuffer = systemBuffer;

                RtlCopyMemory( systemBuffer, Buffer, Length );

                if (SetEa) {
                    status = IoCheckEaBufferValidity( systemBuffer,
                                                      Length,
                                                      &errorOffset );
                } else {
                    status = IoCheckQuotaBufferValidity( systemBuffer,
                                                         Length,
                                                         &errorOffset );
                }

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while allocating the buffer, copying
                // the caller's data into it, or walking the buffer.  Determine
                // what happened, cleanup, and return an appropriate error status
                // code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }

            //
            // Set the flags so that the completion code knows to deallocate the
            // buffer.
            //

            irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->UserBuffer = Buffer;
        }


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        if (Length) {
            //
            // This is a direct I/O operation.  Allocate an MDL and invoke the
            // memory management routine to lock the buffer into memory.  This is
            // done using an exception handler that will perform cleanup if the
            // operation fails.
            //

            mdl = (PMDL) NULL;

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of the
                // IRP.  Probe and lock the pages associated with the caller's
                // buffer for read access and fill in the MDL with the PFNs of those
                // pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (!mdl) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                IopProbeAndLockPages( mdl, requestorMode, IoReadAccess, deviceObject, irpSp->MajorFunction);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually happened,
                // clean everything up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    if (SetEa) {
        irpSp->Parameters.SetEa.Length = Length;
    } else {
        irpSp->Parameters.SetQuota.Length = Length;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
IopSetRemoteLink(
    IN PFILE_OBJECT FileObject,
    IN PFILE_OBJECT DestinationFileObject OPTIONAL,
    IN PFILE_TRACKING_INFORMATION FileInformation OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to remote an NtSetInformationFile API call via an
    FSCTL to the Redirector.  The call will cause the remote system to perform
    the service call to track the link for a file which was just moved.

Arguments:

    FileObject - Supplies the file object for the file that was moved.

    DestinationFileObject - Optionally supplies the file object for the new
        destination location for the file.

    FileInformation - Optionally supplies the volume and file object IDs of
        the target file.

Return Value:

    The final function value is the final completion status of the operation.

--*/

{
    REMOTE_LINK_BUFFER remoteBuffer;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    ULONG length = 0;

    PAGED_CODE();

    //
    // Initialize the event structure to synchronize completion of the I/O
    // request.
    //

    KeInitializeEvent( &event,
                       NotificationEvent,
                       FALSE );

    //
    // Build an I/O Request Packet to be sent to the file system driver to get
    // the volume ID.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    irp = IoBuildDeviceIoControlRequest( FSCTL_LMR_SET_LINK_TRACKING_INFORMATION,
                                         deviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the remote link buffer according to the input information.
    //

    if (DestinationFileObject) {

        // The FileObject and DestinationFileObject are on the same machine
        remoteBuffer.TrackingInformation.TargetFileObject = DestinationFileObject;

        if (FileInformation) {
            // Copy the ObjectInformation from the FileInformation buffer into
            // the TargetLinkTrackingInformationBuffer.  Set 'length' to include
            // this buffer.

            remoteBuffer.TrackingInformation.TargetLinkTrackingInformationLength
                = length = FileInformation->ObjectInformationLength;
            RtlCopyMemory( &remoteBuffer.TrackingInformation.TargetLinkTrackingInformationBuffer,
                           FileInformation->ObjectInformation,
                           length );
        } else {
            // We don't have any extra FileInformation.
            remoteBuffer.TrackingInformation.TargetLinkTrackingInformationLength = 0;
        }

        // Increment the length to include the size of the non-optional fields in
        // REMOTE_LINK_TRACKING_INFORMATION.
        length += sizeof( PFILE_OBJECT ) + sizeof( ULONG );

    } else {
        // There's no DestinationFileObject, so all the necessary information is in the
        // FileInformation structure.
        length = FileInformation->ObjectInformationLength + sizeof( HANDLE ) + sizeof( ULONG );
        RtlCopyMemory( &remoteBuffer.TrackingInformation,
                       FileInformation,
                       length );
        remoteBuffer.TrackingInformation.TargetFileObject = NULL;
    }

    //
    // Fill in the remainder of the IRP to retrieve the object ID for the
    // file.
    //

    irp->Flags |= IRP_SYNCHRONOUS_API;
    irp->AssociatedIrp.SystemBuffer = &remoteBuffer;
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = IRP_MN_KERNEL_CALL;
    irpSp->Parameters.FileSystemControl.InputBufferLength = length;

    //
    // Take out another reference to the file object to guarantee that it does
    // not get deleted.
    //

    ObReferenceObject( FileObject );

    //
    // Call the driver to get the request.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // Synchronize completion of the request.
    //

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( &event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    return status;
}

VOID
IopStartApcHardError(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is invoked in an ExWorker thread when we need to do a
    hard error pop-up, but the Irp's originating thread is at APC level,
    ie. IoPageRead.  It starts a thread to hold the pop-up.

Arguments:

    StartContext - Startup context, contains a IOP_APC_HARD_ERROR_PACKET.

Return Value:

    None.

--*/

{
    HANDLE thread;
    NTSTATUS status;

    //
    //  Create the hard error pop-up thread.  If for whatever reason we
    //  can't do this then just complete the Irp with the error.
    //

    status = PsCreateSystemThread( &thread,
                                   0,
                                   (POBJECT_ATTRIBUTES)NULL,
                                   (HANDLE)0,
                                   (PCLIENT_ID)NULL,
                                   IopApcHardError,
                                   StartContext );

    if ( !NT_SUCCESS( status ) ) {


        IoCompleteRequest( ((PIOP_APC_HARD_ERROR_PACKET)StartContext)->Irp,
                           IO_DISK_INCREMENT );
        ExFreePool( StartContext );
        return;
    }

    //
    //  Close thread handle
    //

    ZwClose(thread);
}

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN KPROCESSOR_MODE RequestorMode,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine is invoked when a synchronous API is invoked for a file
    that has been opened for asynchronous I/O.  This function synchronizes
    the completion of the I/O operation on the file.

Arguments:

    ReturnedStatus - Supplies the status that was returned from the call to
        IoCallDriver.

    Event - Address of the allocated kernel event to be used for synchronization
        of the I/O operation.

    Irp - Address of the I/O Request Packet submitted to the driver.

    RequestorMode - Processor mode of the caller when the operation was
        requested.

    LocalIoStatus - Address of the I/O status block used to capture the final
        status by the service itself.

    IoStatusBlock - Address of the I/O status block supplied by the caller of
        the system service.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // This is a normal synchronous I/O operation, as opposed to a
    // serialized synchronous I/O operation.  For this case, wait for
    // the local event and copy the final status information back to
    // the caller.
    //

    status = ReturnedStatus;

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject( Event,
                                        Executive,
                                        RequestorMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );

        if (status == STATUS_USER_APC) {

            //
            // The wait request has ended either because the thread was
            // alerted or an APC was queued to this thread, because of
            // thread rundown or CTRL/C processing.  In either case, try
            // to bail out of this I/O request carefully so that the IRP
            // completes before this routine exists or the event will not
            // be around to set to the Signaled state.
            //

            IopCancelAlertedRequest( Event, Irp );

        }

        status = LocalIoStatus->Status;
    }

    try {

        *IoStatusBlock = *LocalIoStatus;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception occurred attempting to write the caller's I/O
        // status block.  Simply change the final status of the operation
        // to the exception code.
        //

        status = GetExceptionCode();
    }

    ExFreePool( Event );

    return status;
}

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN SynchronousIo,
    IN TRANSFER_TYPE TransferType
    )

/*++

Routine Description:

    This routine is invoked to complete the operation of a system service.
    It queues the IRP to the thread's queue, updates the transfer count,
    calls the driver, and finally synchronizes completion of the I/O.

Arguments:

    DeviceObject - Device on which the I/O is to occur.

    Irp - I/O Request Packet representing the I/O operation.

    FileObject - File object for this open instantiation.

    DeferredIoCompletion - Indicates whether deferred completion is possible.

    RequestorMode - Mode in which request was made.

    SynchronousIo - Indicates whether the operation is to be synchronous.

    TransferType - Type of transfer being performed: read, write, or other.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    if (!SynchronousIo) {
        IopQueueThreadIrp( Irp );
    }

    //
    // Update the operation count statistic for the current process.
    //

    switch( TransferType ) {

    case ReadTransfer:
        IopUpdateReadOperationCount();
        break;

    case WriteTransfer:
        IopUpdateWriteOperationCount();
        break;

    case OtherTransfer:
        IopUpdateOtherOperationCount();
        break;
    }

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, Irp );

    //
    // If deferred I/O completion is possible, check for pending returned
    // from the driver.  If the driver did not return pending, then the
    // packet has not actually been completed yet, so complete it here.
    //

    if (DeferredIoCompletion) {

        if (status != STATUS_PENDING) {

            //
            // The I/O operation was completed without returning a status of
            // pending.  This means that at this point, the IRP has not been
            // fully completed.  Complete it now.
            //

            PKNORMAL_ROUTINE normalRoutine;
            PVOID normalContext;
            KIRQL irql = PASSIVE_LEVEL; // Just to shut up the compiler

            ASSERT( !Irp->PendingReturned );

            if (!SynchronousIo) {
                KeRaiseIrql( APC_LEVEL, &irql );
            }
            IopCompleteRequest( &Irp->Tail.Apc,
                                &normalRoutine,
                                &normalContext,
                                (PVOID *) &FileObject,
                                &normalContext );

            if (!SynchronousIo) {
                KeLowerIrql( irql );
            }
        }
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (SynchronousIo) {

        if (status == STATUS_PENDING) {

            status = KeWaitForSingleObject( &FileObject->Event,
                                            Executive,
                                            RequestorMode,
                                            (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was alerted
                // or an APC was queued to this thread, because of thread rundown or
                // CTRL/C processing.  In either case, try to bail out of this I/O
                // request carefully so that the IRP completes before this routine
                // exists so that synchronization with the file object will remain
                // intact.
                //

                IopCancelAlertedRequest( &FileObject->Event, Irp );

            }

            status = FileObject->FinalStatus;

        }

        IopReleaseFileObjectLock( FileObject );

    }

    return status;
}

VOID
IopTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine scans the I/O system timer database and invokes each driver
    that has enabled a timer in the list, once every second.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

--*/

{
    PLIST_ENTRY timerEntry;
    PIO_TIMER timer;
    KIRQL irql;
    ULONG i;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // Check to see whether or not there are any timers in the queue that
    // have been enabled.  If so, then walk the list and invoke all of the
    // drivers' routines.  Note that if the counter changes, which it can
    // because the spin lock is not owned, then a timer routine may be
    // missed.  However, this is acceptable, since the driver inserting the
    // entry could be context switched away from, etc.  Therefore, this is
    // not a critical resource for the most part.
    //

    if (IopTimerCount) {

        //
        // There is at least one timer entry in the queue that is enabled.
        // Walk the queue and invoke each specified timer routine.
        //

        ExAcquireSpinLock( &IopTimerLock, &irql );
        i = IopTimerCount;
        timerEntry = IopTimerQueueHead.Flink;

        //
        // For each entry found that is enabled, invoke the driver's routine
        // with its specified context parameter.  The local count is used
        // to abort the queue traversal when there are more entries in the
        // queue, but they are not enabled.
        //

        for (timerEntry = IopTimerQueueHead.Flink;
             (timerEntry != &IopTimerQueueHead) && i;
             timerEntry = timerEntry->Flink ) {

            timer = CONTAINING_RECORD( timerEntry, IO_TIMER, TimerList );

            if (timer->TimerFlag) {
                timer->TimerRoutine( timer->DeviceObject, timer->Context );
                i--;
            }
        }
        ExReleaseSpinLock( &IopTimerLock, irql );
    }
}





NTSTATUS
IopTrackLink(
    IN PFILE_OBJECT FileObject,
    IN OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_TRACKING_INFORMATION FileInformation,
    IN ULONG Length,
    IN PKEVENT Event,
    IN KPROCESSOR_MODE RequestorMode
    )

/*++

Routine Description:

    This routine is invoked to track a link.  It tracks the source file's Object
    ID to the target file so that links to the source will follow to the new
    location of the target.

Arguments:

    FileObject - Supplies a pointer to the referenced source file object.

    IoStatusBlock - Pointer to the caller's I/O status block.

    FileInformation - A buffer containing the parameters for the move that was
        performed.

    Length - Specifies the length of the FileInformation buffer.

    Event - An event to be set to the Signaled state once the operation has been
        performed, provided it was successful.

    RequestorMode - Requestor mode of the caller.

N.B. - Note that the presence of an event indicates that the source file was
    opened for asynchronous I/O, otherwise it was opened for synchronous I/O.

Return Value:

    The status returned is the final completion status of the operation.


--*/

{
    PFILE_TRACKING_INFORMATION trackingInfo = NULL;
    PFILE_OBJECT dstFileObject = NULL;
    FILE_VOLUMEID_WITH_TYPE SourceVolumeId;
    FILE_OBJECTID_BUFFER SourceObjectId;
    FILE_OBJECTID_BUFFER NormalizedObjectId;
    FILE_OBJECTID_BUFFER CrossVolumeObjectId;
    FILE_VOLUMEID_WITH_TYPE TargetVolumeId;
    FILE_OBJECTID_BUFFER TargetObjectId;
    TRACKING_BUFFER trackingBuffer;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Begin by capturing the caller's buffer, if required.
    //

    if (RequestorMode != KernelMode) {

        try {
            trackingInfo = ExAllocatePoolWithQuota( PagedPool,
                                                    Length );
            RtlCopyMemory( trackingInfo, FileInformation, Length );

            if (!trackingInfo->DestinationFile ||
               ((Length - FIELD_OFFSET( FILE_TRACKING_INFORMATION, ObjectInformation ))
                < trackingInfo->ObjectInformationLength)) {
                ExFreePool( trackingInfo );
                return STATUS_INVALID_PARAMETER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while allocating the intermediary
            // system buffer or while copying the caller's data into the
            // buffer.  Cleanup and return an appropriate error status code.
            //

            if (trackingInfo) {
                ExFreePool( trackingInfo );
            }

            return GetExceptionCode();
        }
    } else {
        trackingInfo = FileInformation;
    }

    //
    // If a destination file handle was specified, convert it to a pointer to
    // a file object.
    //

    if (trackingInfo->DestinationFile) {
        status = ObReferenceObjectByHandle( trackingInfo->DestinationFile,
                                            FILE_WRITE_DATA,
                                            IoFileObjectType,
                                            RequestorMode,
                                            (PVOID *) &dstFileObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            if (RequestorMode != KernelMode) {
                ExFreePool( trackingInfo );
            }
            return status;
        }
    }

    try {

        //
        // Determine whether this is a local or a remote link tracking
        // operation.
        //

        if (IsFileLocal( FileObject )) {

            //
            // The source file, i.e., the one being moved, is a file local to
            // this system.  Determine the form of the target file and track
            // it accordingly.
            //

            if (trackingInfo->DestinationFile) {

                if (IsFileLocal( dstFileObject )) {

                    BOOLEAN IdSetOnTarget = FALSE;

                    //
                    // The target file is specified as a handle and it is local.
                    // Simply perform the query and set locally.  Note that if
                    // the source file does not have an object ID, then no
                    // tracking will be performed, but it will appear as if the
                    // operation worked.
                    //

                    status = IopGetSetObjectId( FileObject,
                                                &SourceObjectId,
                                                sizeof( SourceObjectId ),
                                                FSCTL_GET_OBJECT_ID );

                    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                        status = STATUS_SUCCESS;
                        leave;
                    }

                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // If the extended info field is zero then this file
                    // has no interesting tracking information.
                    //
                    if (RtlCompareMemoryUlong(SourceObjectId.BirthObjectId,
                                       sizeof(SourceObjectId.BirthObjectId),
                                       0) == sizeof(SourceObjectId.BirthObjectId)) {
                        status = STATUS_SUCCESS;
                        leave;
                    }

                    //
                    // Get the volume ID of the source and destination
                    //

                    status = IopGetVolumeId( dstFileObject,
                                             &TargetVolumeId,
                                             sizeof( TargetVolumeId ) );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    status = IopGetVolumeId( FileObject,
                                             &SourceVolumeId,
                                             sizeof( SourceVolumeId ) );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Delete the ID from the source now, since the
                    // target may be on the same volume.  If there's a
                    // subsequent error, we'll try to restore it.
                    //

                    status = IopGetSetObjectId( FileObject,
                                                NULL,
                                                0,
                                                FSCTL_DELETE_OBJECT_ID );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Set the ID on the target.  If it's a cross-volume
                    // move, set the bit that indicates same.
                    //

                    CrossVolumeObjectId = TargetObjectId = SourceObjectId;
                    if( !RtlEqualMemory( &TargetVolumeId.VolumeId[0],
                                         &SourceVolumeId.VolumeId[0],
                                         sizeof(SourceVolumeId.VolumeId) )) {
                        CrossVolumeObjectId.BirthVolumeId[0] |= 1;
                    }

                    status = IopGetSetObjectId( dstFileObject,
                                                &CrossVolumeObjectId,
                                                sizeof( CrossVolumeObjectId ),
                                                FSCTL_SET_OBJECT_ID );

                    if( status == STATUS_DUPLICATE_NAME ||
                        status == STATUS_OBJECT_NAME_COLLISION ) {

                        // This object ID is already in use on the target volume,
                        // or the dest file already has an object ID.
                        // Get the file's ID (or have NTFS generate a new one).

                        status = IopGetSetObjectId( dstFileObject,
                                                    &TargetObjectId,
                                                    sizeof(TargetObjectId),
                                                    FSCTL_CREATE_OR_GET_OBJECT_ID );
                        if( NT_SUCCESS(status) ) {

                            // Write the birth ID

                            status = IopGetSetObjectId( dstFileObject,
                                                        &CrossVolumeObjectId.ExtendedInfo[0],
                                                        sizeof( CrossVolumeObjectId.ExtendedInfo ),
                                                        FSCTL_SET_OBJECT_ID_EXTENDED );
                        }
                    }

                    if( NT_SUCCESS(status) ) {

                        IdSetOnTarget = TRUE;

                        // If this was a cross-volume move, notify the tracking service.

                        if( !RtlEqualMemory( &TargetVolumeId.VolumeId[0],
                                             &SourceVolumeId.VolumeId[0],
                                             sizeof(SourceVolumeId.VolumeId) )) {

                            IopMarshalIds( &trackingBuffer, &TargetVolumeId, &TargetObjectId, trackingInfo );

                            // Bit 0 must be reset before notifying tracking service
                            NormalizedObjectId = SourceObjectId;
                            NormalizedObjectId.BirthVolumeId[0] &= 0xfe;

                            status = IopSendMessageToTrackService( &SourceVolumeId,
                                                                   &NormalizedObjectId,
                                                                   &trackingBuffer.TrackingInformation );
                        }
                    }

                    //
                    // If there was an error after the ObjectID was deleted
                    // from the source.  Try to restore it before returning.
                    //

                    if( !NT_SUCCESS(status) ) {
                        NTSTATUS statusT = STATUS_SUCCESS;

                        if( IdSetOnTarget ) {

                            if( RtlEqualMemory( &TargetObjectId.ObjectId,
                                                &SourceObjectId.ObjectId,
                                                sizeof(TargetObjectId.ObjectId) )) {

                                // This ID was set with FSCTL_SET_OBJECT_ID
                                statusT = IopGetSetObjectId( dstFileObject,
                                                             NULL,
                                                             0,
                                                             FSCTL_DELETE_OBJECT_ID );

                            } else {

                                // Restore the target's extended data.

                                statusT = IopGetSetObjectId( dstFileObject,
                                                             &TargetObjectId.ExtendedInfo[0],
                                                             sizeof(TargetObjectId.ExtendedInfo),
                                                             FSCTL_SET_OBJECT_ID_EXTENDED );
                            }
                        }

                        if( NT_SUCCESS( statusT )) {

                            IopGetSetObjectId( FileObject,
                                               &SourceObjectId,
                                               sizeof(SourceObjectId),
                                               FSCTL_SET_OBJECT_ID );
                        }

                        leave;
                    }


                } else {    // if (IsFileLocal( dstFileObject ))

                    //
                    // The source file is local, but the destination file object
                    // is remote.  For this case query the target file's object
                    // ID and notify the link tracking system that the file has
                    // been moved across systems.
                    //

                    //
                    // Begin by ensuring that the source file has an object ID
                    // already.  If not, then just make it appear as if the
                    // operation worked.
                    //

                    status = IopGetSetObjectId( FileObject,
                                                &SourceObjectId,
                                                sizeof( SourceObjectId ),
                                                FSCTL_GET_OBJECT_ID );
                    if (!NT_SUCCESS( status )) {
                        status = STATUS_SUCCESS;
                        leave;
                    }


                    //
                    // If the extended info field is zero then this file
                    // has no interesting tracking information.
                    //
                    if (RtlCompareMemoryUlong(&SourceObjectId.BirthObjectId,
                                       sizeof(SourceObjectId.Birth