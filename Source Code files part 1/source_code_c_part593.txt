 }
        if( g_pRGBDriver.get()!= NULL)
            return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
        else
            return E_OUTOFMEMORY;
    }
}
}

CRGBDriver* CRGBDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

void* D3D8RGBRasterizer= reinterpret_cast<void*>(RGB_RAST_LIB_NAMESPACE::GetSWInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\main\context.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Streaming SIMD2 Extensions (aka Willamete) CPU
#define D3DCPU_WLMT         0x000000040L

//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            return FALSE;
        }
        else
        {
            // is Win95
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        return FALSE;
    }
    return TRUE;
}

#if defined(_X86_)
// --------------------------------------------------------------------------
// Detect 3D extensions
// --------------------------------------------------------------------------
static BOOL _asm_isX3D()
{
    DWORD retval = 0;
    _asm
        {
            pushad                      ; CPUID trashes lots - save everything
            mov     eax,80000000h       ; Check for extended CPUID support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            cmp     eax,80000001h       ; Jump if no extended CPUID
            jb      short done          ;

            mov     eax,80000001h       ; Check for feature
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            xor     eax,eax             ;
            test    edx,80000000h       ;
            setnz   al                  ;
            mov     retval,eax          ;

done:
            popad               ; Restore everything
        };
    return retval;
}

static BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}

static BOOL isX3Dprocessor(void)
{
    __try
    {
            if( _asm_isX3D() )
            {
            return TRUE;
            }
    }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return FALSE;
}
//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

static BOOL isMMXprocessor(void)
{
    __try
        {
            if( _asm_isMMX() )
            {

                // Emit an emms instruction.
                // This file needs to compile for non-Pentium
                // processors
                // so we can't use use inline asm since we're in the
                // wrong
                // processor mode.
                __asm __emit 0xf;
                __asm __emit 0x77;
                return TRUE;
            }
        }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
        {
        }
    return FALSE;
}

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}
#pragma optimize("", on)

#ifndef PF_XMMI_INSTRUCTIONS_AVAILABLE
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6
#endif

#ifndef PF_3DNOW_INSTRUCTIONS_AVAILABLE
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7
#endif

#ifndef PF_XMMI64_INSTRUCTIONS_AVAILABLE
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10
#endif

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    case PF_MMX_INSTRUCTIONS_AVAILABLE:
        {
            return isMMXprocessor();
        }
    case PF_XMMI_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_SSE;
        }
    case PF_3DNOW_INSTRUCTIONS_AVAILABLE: return isX3Dprocessor();
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return FALSE;
    }
}
#endif // _X86_

const UINT CRGBContext::c_uiBegan( 1);

DWORD CRGBContext::DetectBeadSet( void) throw()
{
#if defined(_X86_)
    if( D3DIsProcessorFeaturePresent( PF_MMX_INSTRUCTIONS_AVAILABLE))
        return D3DIBS_MMXASRGB;
#endif
    return D3DIBS_C;
}

// TConstDP2Bindings type MUST be updated with size of this array,
// unfortunately.
const CRGBContext::TDP2Bindings CRGBContext::c_DP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          DP2ViewportInfo,
    D3DDP2OP_WINFO,                 DP2WInfo,
    D3DDP2OP_RENDERSTATE,           DP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     DP2TextureStageState,
    D3DDP2OP_CLEAR,                 DP2Clear,
    D3DDP2OP_SETRENDERTARGET,       DP2SetRenderTarget,
    D3DDP2OP_SETVERTEXSHADER,       DP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       DP2SetStreamSource,
    D3DDP2OP_SETSTREAMSOURCEUM,     DP2SetStreamSourceUM,
    D3DDP2OP_SETINDICES,            DP2SetIndices,
    D3DDP2OP_DRAWPRIMITIVE,         DP2DrawPrimitive,
    D3DDP2OP_DRAWPRIMITIVE2,        DP2DrawPrimitive2,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE,  DP2DrawIndexedPrimitive,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2, DP2DrawIndexedPrimitive2,
    D3DDP2OP_CLIPPEDTRIANGLEFAN,    DP2ClippedTriangleFan,
    D3DDP2OP_SETPALETTE,            DP2SetPalette,
    D3DDP2OP_UPDATEPALETTE,         DP2UpdatePalette
};

// TConstRecDP2Bindings type MUST be updated with size of this array,
// unfortunately.
const CRGBContext::TRecDP2Bindings CRGBContext::c_RecDP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          RecDP2ViewportInfo,
    D3DDP2OP_WINFO,                 RecDP2WInfo,
    D3DDP2OP_RENDERSTATE,           RecDP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     RecDP2TextureStageState,
    D3DDP2OP_SETVERTEXSHADER,       RecDP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       RecDP2SetStreamSource,
    D3DDP2OP_SETINDICES,            RecDP2SetIndices
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\main\assert.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{

#if DBG
bool Assert(LPCSTR szFile, int nLine, LPCSTR szCondition)
{
    typedef BOOL (*PFNBV)(VOID);

    static bool bInit( false);
    static PFNBV pIsDebuggerPresent= NULL;

    LONG err;
    char str[256];

    // Initialize stuff
    if(!bInit)
    {
        HINSTANCE hinst;
        bInit= true;

        // Get IsDebuggerPresent entry point
        if((hinst = (HINSTANCE) GetModuleHandle("kernel32.dll")) ||
           (hinst = (HINSTANCE) LoadLibrary("kernel32.dll")))
        {
            pIsDebuggerPresent = (PFNBV) GetProcAddress(hinst, "IsDebuggerPresent");
        }
    }

    // Display a message box if no debugger is present
    if(pIsDebuggerPresent && !pIsDebuggerPresent())
    {
        _snprintf(str, sizeof(str), "File:\t %s\nLine:\t %d\nAssertion:\t%s\n\nDo you want to invoke the debugger?", szFile, nLine, szCondition);
	    err = MessageBox(NULL, str, "RGBRast Assertion Failure", MB_SYSTEMMODAL | MB_YESNOCANCEL);

        switch(err)
        {
        case IDYES:     return true;
        case IDNO:      return false;
        case IDCANCEL:  FatalAppExit(0, "RGBRast Assertion Failure.. Application terminated"); return true;
        }
    }

	return true;
}
#endif // DBG

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\main\driver.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace D3D8RGBRast
{

const D3DCAPS8 CRGBDriver::c_D3DCaps=
{
    // Indicates this is software rasterizer.
    /*D3DDEVTYPE_HAL|| D3DDEVTYPE_REF||*/ D3DDEVTYPE_SW,

    // Adapter ordinal (isn't used to report anything).
    0,

    // Caps (See ddraw.h & d3d8caps.h for details of each CAP).
    /*DDCAPS_3D| DDCAPS_ALIGNBOUNDARYDEST| DDCAPS_ALIGNSIZEDEST|
    DDCAPS_ALIGNBOUNDARYSRC| DDCAPS_ALIGNSIZESRC| DDCAPS_ALIGNSTRIDE|
    DDCAPS_BLT| DDCAPS_BLTQUEUE| DDCAPS_BLTFOURCC| DDCAPS_BLTSTRETCH|
    DDCAPS_GDI| DDCAPS_OVERLAY| DDCAPS_OVERLAYCANTCLIP| DDCAPS_OVERLAYFOURCC|
    DDCAPS_OVERLAYSTRETCH|*/ DDCAPS_PALETTE| /*DDCAPS_PALETTEVSYNC| 
    DDCAPS_READSCANLINE| DDCAPS_VBI| DDCAPS_ZBLTS| DDCAPS_ZOVERLAYS|
    DDCAPS_COLORKEY| DDCAPS_ALPHA| DDCAPS_COLORKEYHWASSIST| DDCAPS_NOHARDWARE|
    DDCAPS_BLTCOLORFILL| DDCAPS_BANKSWITCHED| DDCAPS_BLTDEPTHFILL|
    DDCAPS_CANCLIP| DDCAPS_CANCLIPSTRETCHED| DDCAPS_CANBLTSYSMEM|
    D3DCAPS_READ_SCANLINE|*/ 0,

    // Caps2
    /*DDCAPS2_CERTIFIED| DDCAPS2_NO2DDURING3DSCENE| DDCAPS2_VIDEOPORT|
    DDCAPS2_AUTOFLIPOVERLAY| DDCAPS2_CANBOBINTERLEAVED| 
    DDCAPS2_CANBOBNONINTERLEAVED| DDCAPS2_COLORCONTROLOVERLAY| 
    DDCAPS2_COLORCONTROLPRIMARY|*/ DDCAPS2_CANDROPZ16BIT| 
    /*DDCAPS2_NONLOCALVIDMEM| DDCAPS2_NONLOCALVIDMEMCAPS| 
    DDCAPS2_NOPAGELOCKREQUIRED|*/ DDCAPS2_WIDESURFACES|
    /*DDCAPS2_CANFLIPODDEVEN| DDCAPS2_CANBOBHARDWARE| DDCAPS2_COPYFOURCC|
    DDCAPS2_PRIMARYGAMMA|*/ DDCAPS2_CANRENDERWINDOWED| 
    /*DDCAPS2_CANCALIBRATEGAMMA| DDCAPS2_FLIPINTERVAL|
    DDCAPS2_FLIPNOVSYNC| DDCAPS2_CANMANAGETEXTURE|
    DDCAPS2_TEXMANINNONLOCALVIDMEM| DDCAPS2_STEREO|
    DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL| D3DCAPS2_NO2DDURING3DSCENE| 
    D3DCAPS2_FULLSCREENGAMMA|*/ D3DCAPS2_CANRENDERWINDOWED|
    /*D3DCAPS2_CANCALIBRATEGAMMA|*/ 0,

    // Caps3
    0,
    // Presentation Intervals
    0,
    // Cursor Caps
    0,

    // DevCaps (See d3d8caps.h & d3dhal.h)
    // The SDDI driver should keep D3DDEVCAPS_TEXTUREVIDEOMEMORY enabled. The
    // runtime does not behave correctly if the driver does not enable and
    // support this cap. In other words, all textures must be able to be
    // vid mem (driver allocated) textures, at least.
    D3DDEVCAPS_EXECUTESYSTEMMEMORY| /*D3DDEVCAPS_EXECUTEVIDEOMEMORY|*/
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY| /*D3DDEVCAPS_TLVERTEXVIDEOMEMORY|*/
    D3DDEVCAPS_TEXTURESYSTEMMEMORY| D3DDEVCAPS_TEXTUREVIDEOMEMORY|
    D3DDEVCAPS_DRAWPRIMTLVERTEX| /*D3DDEVCAPS_CANRENDERAFTERFLIP|
    D3DDEVCAPS_TEXTURENONLOCALVIDMEM|*/ D3DDEVCAPS_DRAWPRIMITIVES2|
    /*D3DDEVCAPS_SEPARATETEXTUREMEMORIES|*/ D3DDEVCAPS_DRAWPRIMITIVES2EX|
    /*D3DDEVCAPS_HWTRANSFORMANDLIGHT| D3DDEVCAPS_CANBLTSYSTONONLOCAL|
    D3DDEVCAPS_HWRASTERIZATION| D3DDEVCAPS_PUREDEVICE| 
    D3DDEVCAPS_QUINTICRTPATCHES| D3DDEVCAPS_RTPATCHES|
    D3DDEVCAPS_RTPATCHHANDLEZERO| D3DDEVCAPS_NPATCHES|
	D3DDEVCAPS_HWVERTEXBUFFER| D3DDEVCAPS_HWINDEXBUFFER|*/ 0,

    // Primitive Misc Caps
    /*D3DPMISCCAPS_MASKZ| D3DPMISCCAPS_LINEPATTERNREP|*/ D3DPMISCCAPS_CULLNONE|
    D3DPMISCCAPS_CULLCW| D3DPMISCCAPS_CULLCCW| /*D3DPMISCCAPS_COLORWRITEENABLE|
    D3DPMISCCAPS_CLIPPLANESCALEDPOINTS| D3DPMISCCAPS_CLIPTLVERTS|
    D3DPMISCCAPS_TSSARGTEMP| D3DPMISCCAPS_BLENDOP|*/ 0,

    // Raster Caps
    D3DPRASTERCAPS_DITHER| D3DPRASTERCAPS_ROP2| D3DPRASTERCAPS_XOR| 
    /*D3DPRASTERCAPS_PAT|*/ D3DPRASTERCAPS_ZTEST| D3DPRASTERCAPS_FOGVERTEX|
    D3DPRASTERCAPS_FOGTABLE| /*D3DPRASTERCAPS_ANTIALIASEDGES|*/
    D3DPRASTERCAPS_MIPMAPLODBIAS| /*D3DPRASTERCAPS_ZBIAS|
    D3DPRASTERCAPS_ZBUFFERLESSHSR|*/ D3DPRASTERCAPS_FOGRANGE|
    /*D3DPRASTERCAPS_ANISOTROPY| D3DPRASTERCAPS_WBUFFER| 
    D3DPRASTERCAPS_WFOG| D3DPRASTERCAPS_ZFOG| 
    D3DPRASTERCAPS_COLORPERSPECTIVE| D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE|
    */ 0,

    // Z Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Src Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 
    D3DPBLENDCAPS_BOTHINVSRCALPHA| 0,

    // Dest Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 0,

    // Alpha Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Shade Caps 
    D3DPSHADECAPS_COLORGOURAUDRGB| D3DPSHADECAPS_SPECULARGOURAUDRGB| 
    D3DPSHADECAPS_ALPHAGOURAUDBLEND| D3DPSHADECAPS_FOGGOURAUD| 0,

    // Texture Caps
    D3DPTEXTURECAPS_PERSPECTIVE| D3DPTEXTURECAPS_POW2|
    D3DPTEXTURECAPS_ALPHA| /*D3DPTEXTURECAPS_SQUAREONLY|*/
    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE| D3DPTEXTURECAPS_ALPHAPALETTE|
    /*D3DPTEXTURECAPS_NONPOW2CONDITIONAL| D3DPTEXTURECAPS_PROJECTED| 
    D3DPTEXTURECAPS_CUBEMAP| D3DPTEXTURECAPS_VOLUMEMAP|*/ 
    D3DPTEXTURECAPS_MIPMAP| /*D3DPTEXTURECAPS_MIPVOLUMEMAP| 
    D3DPTEXTURECAPS_MIPCUBEMAP| D3DPTEXTURECAPS_CUBEMAP_POW2| 
    D3DPTEXTURECAPS_VOLUMEMAP_POW2|*/ 0,

    // Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    /*D3DPTFILTERCAPS_MINFANISOTROPIC|*/ D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| /*D3DPTFILTERCAPS_MAGFANISOTROPIC|*/
    /*D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Cube Texture Filter Caps
    /*D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Volume Texture Filter Caps
    /*D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| /*D3DPTADDRESSCAPS_MIRRORONCE|*/ 0,

    // Volume Texture Address Caps
    /*D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE|*/ 0,

    // Line Caps
    D3DLINECAPS_TEXTURE| D3DLINECAPS_ZTEST| D3DLINECAPS_BLEND| 
    D3DLINECAPS_ALPHACMP| D3DLINECAPS_FOG| 0,

    // Max Texture Width, Height, Volume Extent
    1024, 1024, 0,
    
    // Max Texture Repeat, Texture Aspect Ratio, Anisotropy
    256, 0, 1,

    // Max VertexW
    10000.0,

    // Guard Band left, top, right, bottom
    -4096.0f, -4096.0f, 4095.0f, 4095.0f,

    // Extents Adjust
    0.0f,

    // Stencil Caps
    D3DSTENCILCAPS_KEEP| D3DSTENCILCAPS_ZERO| D3DSTENCILCAPS_REPLACE|
    D3DSTENCILCAPS_INCRSAT| D3DSTENCILCAPS_DECRSAT| D3DSTENCILCAPS_INVERT|
    D3DSTENCILCAPS_INCR| D3DSTENCILCAPS_DECR| 0,

    // FVF Caps
    (8& D3DFVFCAPS_TEXCOORDCOUNTMASK)| D3DFVFCAPS_DONOTSTRIPELEMENTS|
    D3DFVFCAPS_PSIZE| 0,

    // TextureOpCaps
    D3DTEXOPCAPS_DISABLE| D3DTEXOPCAPS_SELECTARG1| D3DTEXOPCAPS_SELECTARG2|
    D3DTEXOPCAPS_MODULATE| D3DTEXOPCAPS_MODULATE2X| 
    D3DTEXOPCAPS_MODULATE4X| D3DTEXOPCAPS_ADD| D3DTEXOPCAPS_ADDSIGNED| 
    /*D3DTEXOPCAPS_ADDSIGNED2X| D3DTEXOPCAPS_SUBTRACT|
    D3DTEXOPCAPS_ADDSMOOTH|*/ D3DTEXOPCAPS_BLENDDIFFUSEALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHA| D3DTEXOPCAPS_BLENDFACTORALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHAPM| /*D3DTEXOPCAPS_BLENDCURRENTALPHA|
    D3DTEXOPCAPS_PREMODULATE| D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA|
    D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA| D3DTEXOPCAPS_BUMPENVMAP|
    D3DTEXOPCAPS_BUMPENVMAPLUMINANCE| D3DTEXOPCAPS_DOTPRODUCT3|
    D3DTEXOPCAPS_MULTIPLYADD| D3DTEXOPCAPS_LERP|*/ 0,
    
    // Max Texture Blend Stages, Simulatenous Textures
    D3DHAL_TSS_MAXSTAGES, D3DHAL_TSS_MAXSTAGES,

    // Vertex Processing Caps
    /*D3DVTXPCAPS_TEXGEN| D3DVTXPCAPS_MATERIALSOURCE7|
    D3DVTXPCAPS_DIRECTIONALLIGHTS| D3DVTXPCAPS_POSITIONALLIGHTS|
    D3DVTXPCAPS_LOCALVIEWER| D3DVTXPCAPS_TWEENING|*/ 0,

    // Max Active Lights, User Clip Planes, Vertex Blend Matrices
    0, 0, 0, 

    // Max Vertex Blend Matrix Index, Point Size, Primitive Count
    0, 128.0f, 0x0000FFFF,

    // Max Vertex Index, Streams, Stream Stride,
    0x0000FFFF, 1, 256,

    // Vertex Shader version, Max Vertex Shader Const
    D3DVS_VERSION(0,0), 0,

    // Pixel Shader version, Max Pixel Shader Value
    D3DPS_VERSION(0,0), 16.0f,
};

CSupportedSurface CRGBDriver::c_aSurfaces[11];

void InitSupportedSurface( CSupportedSurface& SS, const D3DFORMAT D3DFmt,
    CRGBSurfAllocator::TCreateSurfFn CFn,
    const bool bTexture, const bool bVolTexture, const bool bCubeTexture,
    const bool bOffScreenTarget, const bool bSameFmtTarget,
    const bool bZStencil, const bool bZStencilWithColor,
    const bool bSameFmtUpToAlpha, const bool b3DAccel,
    const DWORD dwPrivateFmtBitCount= 0, const WORD wFlipMSTypes= 0,
    const WORD wBltMSTypes= 0) 
{
    DDSURFACEDESC SDesc;
    ZeroMemory( &SDesc, sizeof( SDesc));
    SDesc.dwSize= sizeof( SDesc);

    DWORD dwOps( 0);
    if( bTexture) dwOps|= D3DFORMAT_OP_TEXTURE;
    if( bVolTexture) dwOps|= D3DFORMAT_OP_VOLUMETEXTURE;
    if( bCubeTexture) dwOps|= D3DFORMAT_OP_CUBETEXTURE;
    if( bOffScreenTarget) dwOps|= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    if( bSameFmtTarget) dwOps|= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
    if( bZStencil) dwOps|= D3DFORMAT_OP_ZSTENCIL;
    if( bZStencilWithColor) dwOps|= D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
    if( bSameFmtUpToAlpha) dwOps|= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
    if( b3DAccel) dwOps|= D3DFORMAT_OP_3DACCELERATION;

    SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
    SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
    SDesc.ddpfPixelFormat.dwOperations= dwOps;
    SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
    SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
    SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;

    SS= CSupportedSurface( SDesc, CFn);
}

void CRGBDriver::InitSupportedSurfaceArray( void)
{
    // Tex, VTex, CTex, OffSTarg, SameFmtTarg, Z/S, Z/SWColor, SameFmtToA, 3D
    InitSupportedSurface( c_aSurfaces[ 0], D3DFMT_X1R5G5B5, CX1R5G5B5Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 1], D3DFMT_A1R5G5B5, CA1R5G5B5Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 2], D3DFMT_P8, CP8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 3], D3DFMT_L8, CL8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 4], D3DFMT_A8L8, CA8L8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 5], D3DFMT_A4R4G4B4, CA4R4G4B4Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 6], D3DFMT_R5G6B5, CR5G6B5Surface::Create,
        true, false, false, true, true, false, false, false, true);
    InitSupportedSurface( c_aSurfaces[ 7], D3DFMT_A8R8G8B8, CA8R8G8B8Surface::Create,
        true, false, false, true, true, false, false, true, true);
    InitSupportedSurface( c_aSurfaces[ 8], D3DFMT_X8R8G8B8, CX8R8G8B8Surface::Create,
        true, false, false, true, true, false, false, false, true);
    InitSupportedSurface( c_aSurfaces[ 9], D3DFMT_D16_LOCKABLE, CD16Surface::Create,
        false, false, false, false, false, true, true, false, false);
    InitSupportedSurface( c_aSurfaces[10], D3DFMT_D24S8, CD24S8Surface::Create,
        false, false, false, false, false, true, true, false, false);
};

CRGBDriver::CRGBDriver() throw()
    :TSubDriver( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0]),
        TSurfAlloc( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0])) )
{ }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\main\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch_mlspan.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\main\surfaces.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{

void CR5G6B5Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CR5G6B5Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        UINT32 uiRColor( DP2Clear.dwFillColor& 0xF80000);
        UINT32 uiGColor( DP2Clear.dwFillColor& 0xFC00);
        UINT32 uiBColor( DP2Clear.dwFillColor& 0xF8);
        uiRColor>>= 8;
        uiGColor>>= 5;
        uiBColor>>= 3;

        UINT32 uiColor= uiRColor| uiGColor| uiBColor;
        uiColor|= (uiColor<< 16);
        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( uiColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( uiColor, pSData, iCols* sizeof(UINT16));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CA8R8G8B8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CA8R8G8B8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( DP2Clear.dwFillColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( DP2Clear.dwFillColor, pSData, iCols* sizeof(UINT32));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CX8R8G8B8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CX8R8G8B8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( DP2Clear.dwFillColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( DP2Clear.dwFillColor, pSData, iCols* sizeof(UINT32));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CD16Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CD16Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        // Warning, this operation is happening with the FPU mode set to
        // single precision, which is acceptable for 16 bit.
        D3DVALUE Z( DP2Clear.dvFillDepth);
		clamp( Z, 0.0f, 1.0f);
		Z= Z* 0xFFFF+ 0.5f;
        UINT32 uiZVal= static_cast<UINT32>( Z);
        uiZVal|= (uiZVal<< 16);

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( uiZVal, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( uiZVal, pSData, iCols* sizeof(UINT16));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CD24S8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& (D3DCLEAR_ZBUFFER| D3DCLEAR_STENCIL))== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    {
        CSurfaceLocker< CD24S8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        UINT32 uiMask( 0);
        UINT32 uiVal( 0);
        if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)!= 0)
        {
            // Need C compatable FPU Mode here.
            CEnsureFPUModeForC FPUMode;

            double Z( DP2Clear.dvFillDepth);
			clamp( Z, 0.0, 1.0);
			Z= Z* 0xFFFFFF+ 0.5;
            uiVal= static_cast<UINT32>( Z);
			uiVal<<= 8;
            uiMask= 0xFFFFFF00;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_STENCIL)!= 0)
        {
            uiVal|= (DP2Clear.dwFillStencil& 0xFF);
            uiMask|= 0xFF;
        }


        if( 0xFFFFFFFF== uiMask)
        {
            if( RC.left== 0 && RC.right== m_wWidth)
                MemFill( uiVal, pSData, iRow* m_lPitch);
            else do
            {
                MemFill( uiVal, pSData, iCols* sizeof(UINT32));
                pSData+= m_lPitch;
            } while( --iRow);
        }
        else
        {
            if( RC.left== 0 && RC.right== m_wWidth)
                MemMask( uiVal, uiMask, pSData, iRow* m_lPitch);
            else do
            {
                MemMask( uiVal, uiMask, pSData, iCols* sizeof(UINT32));
                pSData+= m_lPitch;
            } while( --iRow);
        }
    }
}

void MemFill( UINT32 uiData, void* pData, UINT32 uiBytes) throw()
{
    unsigned int uiBytesLeft( uiBytes);
    UINT32* p32Data= reinterpret_cast<UINT32*>(pData);

    // Unroll.
    unsigned int uiSpans( uiBytesLeft>> 6);
    uiBytesLeft= uiBytesLeft& 0x3F;
    if( uiSpans!= 0) do
    {
        p32Data[ 0]= uiData;
        p32Data[ 1]= uiData;
        p32Data[ 2]= uiData;
        p32Data[ 3]= uiData;
        p32Data[ 4]= uiData;
        p32Data[ 5]= uiData;
        p32Data[ 6]= uiData;
        p32Data[ 7]= uiData;
        p32Data[ 8]= uiData;
        p32Data[ 9]= uiData;
        p32Data[10]= uiData;
        p32Data[11]= uiData;
        p32Data[12]= uiData;
        p32Data[13]= uiData;
        p32Data[14]= uiData;
        p32Data[15]= uiData;
        p32Data+= 16;
    } while( --uiSpans!= 0);

    uiSpans= uiBytesLeft>> 2;
    uiBytesLeft= uiBytesLeft& 0x3;
    if( uiSpans!= 0) do
    {
        p32Data[0]= uiData;
        p32Data++;
    } while( --uiSpans!= 0);

    if( uiBytesLeft!= 0)
    {
        assert( 2== uiBytesLeft);
        UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
        p16Data[0]= static_cast<UINT16>( uiData& 0xFFFF);
    }
}

void MemMask( UINT32 uiData, UINT32 uiMask, void* pData, UINT32 uiBytes) throw()
{
	uiMask= ~uiMask;
    unsigned int uiBytesLeft( uiBytes);
    UINT32* p32Data= reinterpret_cast<UINT32*>(pData);

    // Unroll.
    unsigned int uiSpans( uiBytesLeft>> 6);
    uiBytesLeft= uiBytesLeft& 0x3F;
    if( uiSpans!= 0) do
    {
        p32Data[ 0]= (p32Data[ 0]& uiMask)| uiData;
        p32Data[ 1]= (p32Data[ 1]& uiMask)| uiData;
        p32Data[ 2]= (p32Data[ 2]& uiMask)| uiData;
        p32Data[ 3]= (p32Data[ 3]& uiMask)| uiData;
        p32Data[ 4]= (p32Data[ 4]& uiMask)| uiData;
        p32Data[ 5]= (p32Data[ 5]& uiMask)| uiData;
        p32Data[ 6]= (p32Data[ 6]& uiMask)| uiData;
        p32Data[ 7]= (p32Data[ 7]& uiMask)| uiData;
        p32Data[ 8]= (p32Data[ 8]& uiMask)| uiData;
        p32Data[ 9]= (p32Data[ 9]& uiMask)| uiData;
        p32Data[10]= (p32Data[10]& uiMask)| uiData;
        p32Data[11]= (p32Data[11]& uiMask)| uiData;
        p32Data[12]= (p32Data[12]& uiMask)| uiData;
        p32Data[13]= (p32Data[13]& uiMask)| uiData;
        p32Data[14]= (p32Data[14]& uiMask)| uiData;
        p32Data[15]= (p32Data[15]& uiMask)| uiData;
        p32Data+= 16;
    } while( --uiSpans!= 0);

    uiSpans= uiBytesLeft>> 2;
    uiBytesLeft= uiBytesLeft& 0x3;
    if( uiSpans!= 0) do
    {
        p32Data[0]= (p32Data[0]& uiMask)| uiData;
        p32Data++;
    } while( --uiSpans!= 0);

    if( uiBytesLeft!= 0)
    {
        assert( 2== uiBytesLeft);
        UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
        p16Data[0]= (p16Data[0]& static_cast<UINT16>( uiMask& 0xFFFF))|
            static_cast<UINT16>( uiData& 0xFFFF);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        spanutil.cpp\
        $O\test.asm\
        $O\texaddr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRS_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRS_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return DD_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRS_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRS_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\clrbd_mh.h: clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: test_mh.mh $(RAST_STD_M4)

$(GENTGT)\texa_mh.h: texa_mh.mh texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): offs_acp.acp $(RGBRASTROOT)\pch\span.h $(RGBRASTROOT)\pch\stp_base.h

$(GENTGT)\beadtbl.cpp: beadtbl.mcp $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: atest.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: bldfuncs.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: bufread.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: bufwrite.mas bufwrite.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: colorbld.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: colorgen.mas colorgen.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: test.mas test.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\texaddr.asm: texaddr.mas cvars.mh texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: texblend.mas texblend.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: texread.mas texread.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: tstfail.mas tstfail.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: spanpars.mas cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\context.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
// TODO: Clean-up
inline D3DI_SPANTEX_FORMAT ConvPixelFormat( const DDPIXELFORMAT& DDPixFmt)
{
    if((DDPixFmt.dwFlags& DDPF_ZBUFFER)!= 0)
    {
        switch(DDPixFmt.dwZBitMask)
        {
        case( 0x0000FFFF): return D3DI_SPTFMT_Z16S0;
        case( 0xFFFFFF00): return D3DI_SPTFMT_Z24S8;
        case( 0x0000FFFE): return D3DI_SPTFMT_Z15S1;
        case( 0xFFFFFFFF): return D3DI_SPTFMT_Z32S0;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    else if((DDPixFmt.dwFlags& DDPF_BUMPDUDV)!= 0)
    {
        switch( DDPixFmt.dwBumpDvBitMask)
        {
        case( 0x0000ff00):
            switch( DDPixFmt.dwRGBBitCount)
            {
            case( 24): return D3DI_SPTFMT_U8V8L8;
            case( 16): return D3DI_SPTFMT_U8V8;
            default: return D3DI_SPTFMT_NULL;
            }
            break;

        case( 0x000003e0): return D3DI_SPTFMT_U5V5L6;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    else if((DDPixFmt.dwFlags& DDPF_PALETTEINDEXED8)!= 0)
        return D3DI_SPTFMT_PALETTE8;
    else if((DDPixFmt.dwFlags& DDPF_PALETTEINDEXED4)!= 0)
        return D3DI_SPTFMT_PALETTE4;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('U', 'Y', 'V', 'Y'))
        return D3DI_SPTFMT_UYVY;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('Y', 'U', 'Y', '2'))
        return D3DI_SPTFMT_YUY2;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '1'))
        return D3DI_SPTFMT_DXT1;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '2'))
        return D3DI_SPTFMT_DXT2;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '3'))
        return D3DI_SPTFMT_DXT3;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '4'))
        return D3DI_SPTFMT_DXT4;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '5'))
        return D3DI_SPTFMT_DXT5;
    else
    {
        UINT uFmt = DDPixFmt.dwGBitMask | DDPixFmt.dwRBitMask;

        if (DDPixFmt.dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= DDPixFmt.dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (DDPixFmt.dwRGBBitCount)
            {
            case 32: return D3DI_SPTFMT_B8G8R8X8;
            case 24: return D3DI_SPTFMT_B8G8R8;
            default: return D3DI_SPTFMT_NULL;
            }
            break;
        case 0xffffff00:
            return D3DI_SPTFMT_B8G8R8A8;
        case 0xffe0:
            if (DDPixFmt.dwFlags & DDPF_ALPHAPIXELS)
                return D3DI_SPTFMT_B5G5R5A1;
            else
                return D3DI_SPTFMT_B5G6R5;
        case 0x07fe0: return D3DI_SPTFMT_B5G5R5;
        case 0xff0: return D3DI_SPTFMT_B4G4R4;
        case 0xfff0: return D3DI_SPTFMT_B4G4R4A4;
        case 0xff: return D3DI_SPTFMT_L8;
        case 0xffff: return D3DI_SPTFMT_L8A8;
        case 0xfc: return D3DI_SPTFMT_B2G3R3;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    return D3DI_SPTFMT_NULL;
}

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetPSize;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex[D3DHAL_TSS_MAXSTAGES];

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[D3DHAL_TSS_MAXSTAGES];
    UINT cActTex;
}FVFDATA;

class CRGBStateSet:
    public CSubStateSet< CRGBStateSet, CRGBContext>
{
public:
    CRGBStateSet( CRGBContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS): CSubStateSet< CRGBStateSet, CRGBContext>(
            C, pBeginSS, pEndSS)
    { }
    ~CRGBStateSet()
    { }
};

typedef CStdDrawPrimitives2< CRGBContext, CRGBStateSet,
    static_hash_map< DWORD, CRGBStateSet, 32> > TDrawPrimitives2;
typedef CSubContext< CRGBContext, CRGBDriver::TPerDDrawData,
    CRTarget< CRGBDriver::TSurface*, CRGBDriver::TPerDDrawData::TSurfDBEntry*> >
    TSubContext;

class CRGBContext:
    public TSubContext,
    public TDrawPrimitives2,
    public CStdDP2SetVertexShaderStore< CRGBContext>,
    public CStdDP2WInfoStore< CRGBContext>,
    public CStdDP2RenderStateStore< CRGBContext>,
    public CStdDP2TextureStageStateStore< CRGBContext>,
    public CStdDP2VStreamManager< CRGBContext, CVStream< CRGBDriver::TSurface*,
        CRGBDriver::TPerDDrawData::TSurfDBEntry*> >,
    public CStdDP2IStreamManager< CRGBContext, CIStream< CRGBDriver::TSurface*,
        CRGBDriver::TPerDDrawData::TSurfDBEntry*> >,
    public CStdDP2PaletteManager< CRGBContext, CPalDBEntry,
        static_hash_map< DWORD, CPalDBEntry, 4> >
{
public: // Types
    typedef TPerDDrawData::TDriver::TSurface TSurface;

protected: // Types
    typedef block< TDP2CmdBind, 17> TDP2Bindings;
    typedef block< TRecDP2CmdBind, 7> TRecDP2Bindings;
    struct SHandleHasCaps: public unary_function< DWORD, bool>
    {
        const TPerDDrawData& m_PDDD;
        DWORD m_dwCaps;

        explicit SHandleHasCaps( const TPerDDrawData& PDDD, const DWORD dwCaps)
            throw(): m_PDDD( PDDD), m_dwCaps( dwCaps) { }
        result_type operator()( const argument_type Arg) const
        {
            const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                m_PDDD.GetSurfDBEntry( Arg);
            assert( pSurfDBEntry!= NULL);
            return((pSurfDBEntry->GetLCLddsCaps().dwCaps& m_dwCaps)== m_dwCaps);
        }
    };

protected:
    static const TDP2Bindings c_DP2Bindings;
    static const TRecDP2Bindings c_RecDP2Bindings;
    D3DI_RASTCTX m_RastCtx;
    PrimProcessor m_PrimProc;
    D3DI_SPANTEX m_aSpanTex[8];

    // FVF stuff
    FVFDATA m_fvfData;

    // Used to store the old last pixel setting when drawing line strips.
    UINT m_uFlags;

    static DWORD DetectBeadSet( void) throw();
    static const UINT c_uiBegan;

public:
    CRGBContext( TPerDDrawData& PDDD, PORTABLE_CONTEXTCREATEDATA& ccd):
        TSubContext( PDDD, ccd),
        TDrawPrimitives2( c_DP2Bindings.begin(), c_DP2Bindings.end(),
            c_RecDP2Bindings.begin(), c_RecDP2Bindings.end()),
        m_uFlags( 0)
    { 
        HRESULT hr= m_PrimProc.Initialize();
        assert( SUCCEEDED( hr)); // TODO: Can fail?

        // TODO: Remove this unextendable stuff?
        memset(&m_RastCtx, 0, sizeof(m_RastCtx));
        m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

        m_RastCtx.pdwRenderState[ D3DRENDERSTATE_SCENECAPTURE]= FALSE;

        // Hit our notification scheme here.
        NewColorBuffer();
        NewDepthBuffer();

        m_PrimProc.SetCtx(&m_RastCtx);

        // Initialize bead table enum
        m_RastCtx.BeadSet = (D3DI_BEADSET)DetectBeadSet();
        m_RastCtx.uDevVer = 0;

        // All render and texture stage state is initialized by
        // DIRECT3DDEVICEI::stateInitialize

        // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
        m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    }
    ~CRGBContext() throw() { }

    void NewColorBuffer()
    {
        End();

        TRTarget& ColorBuffer= GetColorBuffer();
        if( ColorBuffer.GetMemLocation()!= TRTarget::EMemLocation::None)
        {
            IRGBSurface* pVMSurface= ColorBuffer.GetVidMemRepresentation();
            m_RastCtx.iSurfaceStride= pVMSurface->GetGBLlPitch();
            m_RastCtx.iSurfaceStep= pVMSurface->GetBytesPerPixel();
            m_RastCtx.iSurfaceBitCount= m_RastCtx.iSurfaceStep* 8;
            m_RastCtx.iSurfaceType= pVMSurface->GetSpanTexFormat();

            m_RastCtx.Clip.left= m_RastCtx.Clip.top= 0;
            m_RastCtx.Clip.bottom= pVMSurface->GetGBLwHeight();
            m_RastCtx.Clip.right= pVMSurface->GetGBLwWidth();
            m_RastCtx.pDDS= reinterpret_cast<LPDIRECTDRAWSURFACE>(pVMSurface);
        }
        else
        {
            m_RastCtx.iSurfaceStride= 0;
            m_RastCtx.iSurfaceStep= 0;
            m_RastCtx.iSurfaceBitCount= 0;
            m_RastCtx.iSurfaceType= D3DI_SPTFMT_NULL;

            m_RastCtx.Clip.left= m_RastCtx.Clip.top= 0;
            m_RastCtx.Clip.right= m_RastCtx.Clip.bottom= 0;
            m_RastCtx.pDDS= NULL;
        }

        TSubContext::NewColorBuffer();
    }
    void NewDepthBuffer()
    {
        End();

        TRTarget& DepthBuffer= GetDepthBuffer();
        if( DepthBuffer.GetMemLocation()!= TRTarget::EMemLocation::None)
        {
            IRGBSurface* pVMSurface= DepthBuffer.GetVidMemRepresentation();
            m_RastCtx.pZBits= NULL;
            m_RastCtx.iZStride= pVMSurface->GetGBLlPitch();
            m_RastCtx.iZStep= pVMSurface->GetBytesPerPixel();
            m_RastCtx.iZBitCount= m_RastCtx.iZStep* 8;
            m_RastCtx.pDDSZ= reinterpret_cast<LPDIRECTDRAWSURFACE>(pVMSurface);
        }
        else
        {
            m_RastCtx.pZBits= NULL;
            m_RastCtx.iZStride= 0;
            m_RastCtx.iZBitCount= 0;
            m_RastCtx.iZStep= 0;
            m_RastCtx.pDDSZ= NULL;
        }

        TSubContext::NewDepthBuffer();
    }

    HRESULT DP2ViewportInfo( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) throw()
    {
        const D3DHAL_DP2VIEWPORTINFO* pParam= reinterpret_cast<
            const D3DHAL_DP2VIEWPORTINFO*>(pP);
        // TODO: Roll into RGBContext (This particularly into DX8SDDIFW).
        m_RastCtx.Clip.left = pParam->dwX;
        m_RastCtx.Clip.top = pParam->dwY;
        m_RastCtx.Clip.bottom = pParam->dwY + pParam->dwHeight;
        m_RastCtx.Clip.right = pParam->dwX + pParam->dwWidth;
        return DD_OK;
    }
    operator D3DHAL_DP2VIEWPORTINFO() const throw()
    {
        D3DHAL_DP2VIEWPORTINFO Ret;
        Ret.dwX= m_RastCtx.Clip.left;
        Ret.dwY= m_RastCtx.Clip.top;
        Ret.dwWidth= m_RastCtx.Clip.right- Ret.dwX;
        Ret.dwHeight= m_RastCtx.Clip.bottom- Ret.dwY;
        return Ret;
    }
    void GetDP2ViewportInfo( D3DHAL_DP2VIEWPORTINFO& Param) const throw()
    { Param= (*this); }
    HRESULT RecDP2ViewportInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP) throw()
    {
        D3DHAL_DP2VIEWPORTINFO* pParam= reinterpret_cast<
            D3DHAL_DP2VIEWPORTINFO*>(pP);
        pParam->dwX= m_RastCtx.Clip.left;
        pParam->dwY= m_RastCtx.Clip.top;
        pParam->dwWidth= m_RastCtx.Clip.right- m_RastCtx.Clip.left;
        pParam->dwHeight= m_RastCtx.Clip.bottom- m_RastCtx.Clip.top;
        return DD_OK;
    }

    HRESULT SetRenderState( UINT32 uState, UINT32 uStateVal)
    {
        m_RastCtx.pdwRenderState[uState] = uStateVal;

        switch(uState)
        {
        case D3DRS_CULLMODE:
            // Set face culling sign from state.
            switch(uStateVal)
            {
            case D3DCULL_CCW:
                m_RastCtx.uCullFaceSign= 1;
                break;
            case D3DCULL_CW:
                m_RastCtx.uCullFaceSign= 0;
                break;
            case D3DCULL_NONE:
                m_RastCtx.uCullFaceSign= 2;
                break;
            }
            break;

        case D3DRS_LASTPIXEL:
            // Set last-pixel flag from state.
            if (uStateVal)
            {
                m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
            }
            else
            {
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
            }
            break;

        default:
            break;
        }

        return DD_OK;
    }
    HRESULT DP2RenderState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP)
    {
        const D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2RENDERSTATE*>(pP);

        WORD wStateCount( pCmd->wStateCount);

        HRESULT hr( DD_OK);

        End();

        D3DHAL_DP2RENDERSTATE SCap;
        SCap.RenderState= static_cast< D3DRENDERSTATETYPE>(
            D3DRENDERSTATE_SCENECAPTURE);
        GetDP2RenderState( SCap);
        const DWORD dwOldSC( SCap.dwState);

        if((DP2Data.dwFlags()& D3DHALDP2_EXECUTEBUFFER)!= 0)
        {
            // dp2d.lpdwRStates should be valid.

            if( wStateCount) do
            {
                assert( pParam->RenderState< D3DHAL_MAX_RSTATES);

                hr= SetRenderState( pParam->RenderState, pParam->dwState);
                if( SUCCEEDED(hr))
                    DP2Data.lpdwRStates()[ pParam->RenderState]= pParam->dwState;
                ++pParam;
            } while( SUCCEEDED(hr)&& --wStateCount);
            
        }
        else
        {
            if( wStateCount) do
            {
                assert( pParam->RenderState< D3DHAL_MAX_RSTATES);

                hr= SetRenderState( pParam->RenderState, pParam->dwState);
                ++pParam;
            } while( SUCCEEDED(hr)&& --wStateCount);
        }

        GetDP2RenderState( SCap);
        if( FALSE== dwOldSC && TRUE== SCap.dwState)
            OnSceneCaptureStart();
        else if( TRUE== dwOldSC && FALSE== SCap.dwState)
            OnSceneCaptureEnd();

        return hr;
    }
    DWORD GetRenderStateDW( D3DRENDERSTATETYPE RS) const throw()
    { assert( RS< D3DHAL_MAX_RSTATES); return m_RastCtx.pdwRenderState[ RS]; }
    D3DVALUE GetRenderStateDV( D3DRENDERSTATETYPE RS) const throw()
    {
        assert( RS< D3DHAL_MAX_RSTATES);
        return *(reinterpret_cast< const D3DVALUE*>( &m_RastCtx.pfRenderState[ RS]));
    }
    void GetDP2RenderState( D3DHAL_DP2RENDERSTATE& GetParam) const throw()
    { GetParam.dwState= GetRenderStateDW( GetParam.RenderState); }

    void OnSceneCaptureStart( void) throw()
    {
#if defined(USE_ICECAP4)
        static bool bStarted( true);
        if( bStarted)
            StopProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        else
            StartProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        bStarted= !bStarted;
        CommentMarkProfile( 1, "SceneCaptureStart");
#endif
    }
    void OnSceneCaptureEnd( void) throw()
    {
#if defined(USE_ICECAP4)
        CommentMarkProfile( 2, "SceneCaptureEnd");
//        StopProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
        End();
    }

    void OnEndDrawPrimitives2( TDP2Data& )
    {
        End();
    }

    HRESULT SetTextureStageState( DWORD dwStage, DWORD dwState, DWORD uStateVal)
    {
        UINT cNewActTex = 0;

        m_RastCtx.pdwTextureStageState[dwStage][dwState] = uStateVal;
        switch (dwState)
        {
        case D3DTSS_TEXTUREMAP:
            {
            const TPerDDrawData::TSurfDBEntry* pTexDBEntry=
                GetPerDDrawData().GetSurfDBEntry( uStateVal);

            if( pTexDBEntry!= NULL)
            {
                assert((pTexDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_TEXTURE)!= 0);

                memset( &m_aSpanTex[ dwStage], 0, sizeof(m_aSpanTex[0]));
                m_aSpanTex[ dwStage].dwSize= sizeof(m_aSpanTex[0]);
                m_RastCtx.pTexture[ dwStage]= &m_aSpanTex[ dwStage];

                // Appears that a unique num is needed, but looks like
                // field isn't used anywhere. Using handle...
                m_aSpanTex[ dwStage].iGeneration= uStateVal;

                assert((pTexDBEntry->GetLCLdwFlags()& DDRAWISURF_HASCKEYSRCBLT)== 0);
                m_aSpanTex[ dwStage].uFlags&= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                m_aSpanTex[ dwStage].Format= ConvPixelFormat( pTexDBEntry->GetGBLddpfSurface());
                if( m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE8 ||
                    m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE4)
                {
                    TPalDBEntry* pPalDBEntry= pTexDBEntry->GetPalette();
                    assert( pPalDBEntry!= NULL);

                    if((pPalDBEntry->GetFlags()& DDRAWIPAL_ALPHA)!= 0)
                        m_aSpanTex[ dwStage].uFlags|= D3DI_SPANTEX_ALPHAPALETTE;
                    
                    m_aSpanTex[ dwStage].pPalette= reinterpret_cast<PUINT32>(
                        pPalDBEntry->GetEntries());

                    if( m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE8)
                        m_aSpanTex[ dwStage].iPaletteSize = 256;
                    else
                    {
                        // PALETTE4
                        m_aSpanTex[ dwStage].iPaletteSize = 16;
                    }
                }
                m_aSpanTex[ dwStage].TexAddrU= D3DTADDRESS_WRAP;
                m_aSpanTex[ dwStage].TexAddrV= D3DTADDRESS_WRAP;
                m_aSpanTex[ dwStage].BorderColor= RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

                // assign first pSurf here (mipmap chain gets assigned below)
                m_aSpanTex[ dwStage].pSurf[0]= (LPDIRECTDRAWSURFACE)(pTexDBEntry);

                // Check for mipmap if any.
                const TPerDDrawData::TSurfDBEntry* pLcl= pTexDBEntry;

                // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
                // mipmap. They are init'ed with the first texture size.
                INT16 iPreSizeU = m_aSpanTex[ dwStage].iSizeU, iPreSizeV = m_aSpanTex[ dwStage].iSizeV;
                for (;;)
                {
                    TPerDDrawData::TSurfDBEntry::THandleVector::const_iterator
                        itNextTexHandle;
                    
                    itNextTexHandle= find_if( pLcl->GetAttachedTo().begin(),
                        pLcl->GetAttachedTo().end(),
                        SHandleHasCaps( GetPerDDrawData(), DDSCAPS_TEXTURE));
                    if( pLcl->GetAttachedTo().end()== itNextTexHandle)
                        break;

                    pLcl= GetPerDDrawData().GetSurfDBEntry( *itNextTexHandle);
                    assert( pLcl!= NULL);

                    m_aSpanTex[ dwStage].cLODTex++;
                    m_aSpanTex[ dwStage].pSurf[m_aSpanTex[ dwStage].cLODTex]= (LPDIRECTDRAWSURFACE)pLcl;
                }

                SetSizesSpanTexture( &m_aSpanTex[ dwStage]);
            }
            else
                m_RastCtx.pTexture[ dwStage]= NULL;

            if( m_RastCtx.pTexture[dwStage]!= NULL)
            {
                m_RastCtx.pTexture[dwStage]->TexAddrU=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
                m_RastCtx.pTexture[dwStage]->TexAddrV=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
                m_RastCtx.pTexture[dwStage]->BorderColor=
                    (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
                m_RastCtx.pTexture[dwStage]->uMagFilter=
                    (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
                m_RastCtx.pTexture[dwStage]->uMinFilter=
                    (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
                m_RastCtx.pTexture[dwStage]->uMipFilter=
                    (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
                m_RastCtx.pTexture[dwStage]->fLODBias=
                    m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

                if( m_RastCtx.pTexture[dwStage]->iMaxMipLevel!=
                    (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
                {
                    m_RastCtx.pTexture[dwStage]->iMaxMipLevel=
                        (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
                    m_RastCtx.pTexture[dwStage]->uFlags|= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
                }
            }

            // conservative but correct
            D3DHAL_VALIDATETEXTURESTAGESTATEDATA FakeVTSSD;
            FakeVTSSD.dwhContext= reinterpret_cast< ULONG_PTR>(this);
            FakeVTSSD.dwFlags= 0;
            FakeVTSSD.dwReserved= 0;
            FakeVTSSD.dwNumPasses= 0;
            FakeVTSSD.ddrval= DD_OK;
            if((FakeVTSSD.ddrval= ValidateTextureStageState( FakeVTSSD))== DD_OK)
            {
                // count number of contiguous-from-zero active texture blend stages
                for( INT iStage=0; iStage< D3DHAL_TSS_MAXSTAGES; iStage++)
                {
                    // check for disabled stage (subsequent are thus inactive)
                    // also conservatively checks for incorrectly enabled stage (might be legacy)
                    if((m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP]==
                        D3DTOP_DISABLE) || (m_RastCtx.pTexture[iStage]== NULL))
                    {
                        break;
                    }

                    // stage is active
                    cNewActTex++;
                }
            }
            if( m_RastCtx.cActTex!= cNewActTex)
            {
                m_RastCtx.StatesDirtyBits[D3DRENDERSTATE_TEXTUREHANDLE>>3]|=
                    (1<<(D3DRENDERSTATE_TEXTUREHANDLE& 7));
                m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3]|=
                    (1<<(D3DHAL_MAX_RSTATES_AND_STAGES& 7));
                m_RastCtx.cActTex= cNewActTex;
            }
            break;
            }

        case D3DTSS_ADDRESSU:
        case D3DTSS_ADDRESSV:
        case D3DTSS_MIPMAPLODBIAS:
        case D3DTSS_MAXMIPLEVEL:
        case D3DTSS_BORDERCOLOR:
        case D3DTSS_MAGFILTER:
        case D3DTSS_MINFILTER:
        case D3DTSS_MIPFILTER:
            if( m_RastCtx.pTexture[dwStage]!= NULL)
            {
                m_RastCtx.pTexture[dwStage]->TexAddrU=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
                m_RastCtx.pTexture[dwStage]->TexAddrV=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
                m_RastCtx.pTexture[dwStage]->BorderColor=
                    (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
                m_RastCtx.pTexture[dwStage]->uMagFilter=
                    (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
                m_RastCtx.pTexture[dwStage]->uMinFilter=
                    (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
                m_RastCtx.pTexture[dwStage]->uMipFilter=
                    (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
                m_RastCtx.pTexture[dwStage]->fLODBias=
                    m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

                if( m_RastCtx.pTexture[dwStage]->iMaxMipLevel!=
                    (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
                {
                    m_RastCtx.pTexture[dwStage]->iMaxMipLevel=
                        (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
                    m_RastCtx.pTexture[dwStage]->uFlags|= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
                }
            }
            break;

        case D3DTSS_COLOROP:
        case D3DTSS_COLORARG1:
        case D3DTSS_COLORARG2:
        case D3DTSS_ALPHAOP:
        case D3DTSS_ALPHAARG1:
        case D3DTSS_ALPHAARG2:
            {
            // anything that effects the validity of the texture blending
            // could change the number of active texture stages

            // conservative but correct
            D3DHAL_VALIDATETEXTURESTAGESTATEDATA FakeVTSSD;
            FakeVTSSD.dwhContext= reinterpret_cast< ULONG_PTR>(this);
            FakeVTSSD.dwFlags= 0;
            FakeVTSSD.dwReserved= 0;
            FakeVTSSD.dwNumPasses= 0;
            FakeVTSSD.ddrval= DD_OK;
            if((FakeVTSSD.ddrval= ValidateTextureStageState( FakeVTSSD))== DD_OK)
            {
                // count number of contiguous-from-zero active texture blend stages
                for( INT iStage=0; iStage< D3DHAL_TSS_MAXSTAGES; iStage++)
                {
                    // check for disabled stage (subsequent are thus inactive)
                    // also conservatively checks for incorrectly enabled stage (might be legacy)
                    if((m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP]==
                        D3DTOP_DISABLE) || (m_RastCtx.pTexture[iStage]== NULL))
                    {
                        break;
                    }

                    // stage is active
                    cNewActTex++;
                }
            }
            m_RastCtx.cActTex= cNewActTex;
            break;
            }
        }

        return DD_OK;
    }
    HRESULT DP2TextureStageState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        HRESULT hr( DD_OK);

        End();

        if( wStateCount) do
        {
            assert( pParam->TSState< D3DTSS_MAX);

            hr= SetTextureStageState( pParam->wStage, pParam->TSState, pParam->dwValue);
            ++pParam;
        } while( SUCCEEDED(hr)&& --wStateCount);

        return hr;
    }
    DWORD GetTextureStageStateDW( WORD wStage, WORD wTSState) const throw()
    { return m_RastCtx.pdwTextureStageState[ wStage][ wTSState]; }
    D3DVALUE GetTextureStageStateDV( WORD wStage, WORD wTSState) const throw()
    {
        return *(reinterpret_cast< const D3DVALUE*>(
            &m_RastCtx.pdwTextureStageState[ wStage][ wTSState]));
    }
    void GetDP2TextureStageState( D3DHAL_DP2TEXTURESTAGESTATE& GetParam) const
        throw()
    { GetParam.dwValue= GetTextureStageStateDW( GetParam.wStage, GetParam.TSState); }

    HRESULT ValidateTextureStageState( D3DHAL_VALIDATETEXTURESTAGESTATEDATA&
        vtssd) const throw()
    {
        vtssd.dwNumPasses= 1;
        if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
            (m_RastCtx.pTexture[0] != NULL) )
        {
            // except under very special circumstances, this will not work in RGB/MMX
            // since we keep a lot of stage state in the D3DI_SPANTEX structure
            return D3DERR_TOOMANYOPERATIONS;
        }
        for (INT i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLOROP])
            {
            default:
                return D3DERR_UNSUPPORTEDCOLOROPERATION;
            case D3DTOP_DISABLE:
                return DD_OK;  // don't have to validate further if the stage is disabled
            case D3DTOP_SELECTARG1:
            case D3DTOP_SELECTARG2:
            case D3DTOP_MODULATE:
            case D3DTOP_MODULATE2X:
            case D3DTOP_MODULATE4X:
            case D3DTOP_ADD:
            case D3DTOP_ADDSIGNED:
            case D3DTOP_BLENDDIFFUSEALPHA:
            case D3DTOP_BLENDTEXTUREALPHA:
            case D3DTOP_BLENDFACTORALPHA:
            case D3DTOP_BLENDTEXTUREALPHAPM:
            case D3DTOP_ADDSIGNED2X:
            case D3DTOP_SUBTRACT:
            case D3DTOP_ADDSMOOTH:
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG1] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDCOLORARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG2] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDCOLORARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
            case (D3DTA_SPECULAR):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAOP])
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAOPERATION;
            case D3DTOP_DISABLE:
                break;
            case D3DTOP_SELECTARG1:
            case D3DTOP_SELECTARG2:
            case D3DTOP_MODULATE:
            case D3DTOP_MODULATE2X:
            case D3DTOP_MODULATE4X:
            case D3DTOP_ADD:
            case D3DTOP_ADDSIGNED:
            case D3DTOP_BLENDDIFFUSEALPHA:
            case D3DTOP_BLENDTEXTUREALPHA:
            case D3DTOP_BLENDFACTORALPHA:
            case D3DTOP_BLENDTEXTUREALPHAPM:
            case D3DTOP_ADDSIGNED2X:
            case D3DTOP_SUBTRACT:
            case D3DTOP_ADDSMOOTH:
                // only validate alpha args if alpha op is not disable
                switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG1] &
                        ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
                {
                default:
                    return D3DERR_UNSUPPORTEDALPHAARG;
                case (D3DTA_TEXTURE):
                    break;
                }

                switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG2] &
                        ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
                {
                default:
                    return D3DERR_UNSUPPORTEDALPHAARG;
                case (D3DTA_TFACTOR):
                case (D3DTA_CURRENT):
                case (D3DTA_DIFFUSE):
                case (D3DTA_SPECULAR):
                    break;
                }
                break;
            }
        }
        return DD_OK;
    }

    HRESULT DP2Clear( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        End();
        return TSubContext::DP2Clear( DP2Data, pCmd, pP);
    }
    HRESULT CheckFVF(DWORD dwFVF)
    {
        // check if FVF controls have changed
        if ( (m_fvfData.preFVF == dwFVF) &&
             (m_fvfData.TexIdx[0] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[1] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[1][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[2] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[2][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[3] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[3][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[4] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[4][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[5] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[5][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[6] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[6][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[7] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[7][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.cActTex == m_RastCtx.cActTex) )
        {
            return D3D_OK;
        }

        memset(&m_fvfData, 0, sizeof(FVFDATA));
        m_fvfData.preFVF = dwFVF;
        INT32 i;
        for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            m_fvfData.TexIdx[i] = 0xffff&m_RastCtx.pdwTextureStageState[i][D3DTSS_TEXCOORDINDEX];
        }
        m_fvfData.cActTex = m_RastCtx.cActTex;

        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            m_fvfData.offsetPSize = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[i]);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }

        if( D3DFVF_TLVERTEX== dwFVF)
            m_fvfData.vtxType = RAST_TLVERTEX;
        else
            m_fvfData.vtxType = RAST_GENVERTEX;

        return D3D_OK;
    }
    void PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
    {
        pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
        pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
        pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
        if (m_fvfData.offsetRHW)
        {
            pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
        }
        else
        {
            pGenVtx->rhw = 1.0f;
        }
        if (m_fvfData.offsetDiff)
        {
            pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
        }
        else
        {
            pGenVtx->color = 0xFFFFFFFF; //__DEFAULT_DIFFUSE;
        }
        if (m_fvfData.offsetSpec)
        {
            pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
        }
        else
        {
            pGenVtx->specular = 0; //__DEFAULT_SPECULAR;
        }
        for (INT32 i = 0; i < (INT32)m_fvfData.cActTex; i++)
        {
           if (m_fvfData.offsetTex[i])
           {
               pGenVtx->texCoord[i].tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]));
               pGenVtx->texCoord[i].tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]) + 1);
           }
           else
           {
               pGenVtx->texCoord[i].tu = 0.0f;
               pGenVtx->texCoord[i].tv = 0.0f;
           }
        }
    }
    HRESULT DP2DrawPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE*>(pP);
        HRESULT hr( DD_OK);
		
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->VStart* dwVStride;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
		            DoDrawOneGenPrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
                else                
		            DoDrawOnePrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);
        HRESULT hr( DD_OK);

        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenPrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
                else
    		        DoDrawOnePrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawIndexedPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE*>(pP);
        HRESULT hr( DD_OK);
			
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data for rasterization.
        UINT8* pStartVData= NULL;
        UINT8* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        const TIStream& IStream= GetIStream( 0);
        if( IStream.GetMemLocation()== TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TIStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT8*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

        if( pStartVData!= NULL&& pStartIData!= NULL&& sizeof(WORD)== dwIStride)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->BaseVertexIndex* dwVStride;
                UINT8* pIData= pStartIData+ pParam->StartIndex* dwIStride;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
                else
    		        DoDrawOneIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawIndexedPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*>(pP);
        HRESULT hr( DD_OK);

        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data for rasterization.
        UINT8* pStartVData= NULL;
        UINT8* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        const TIStream& IStream= GetIStream( 0);
        if( IStream.GetMemLocation()== TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TIStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT8*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

        if( pStartVData!= NULL&& pStartIData!= NULL&& sizeof(WORD)== dwIStride)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->BaseVertexOffset;
                UINT8* pIData= pStartIData+ pParam->StartIndexOffset;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
                else
    		        DoDrawOneIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2ClippedTriangleFan( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= reinterpret_cast<
            const D3DHAL_CLIPPEDTRIANGLEFAN*>(pP);
        HRESULT hr( DD_OK);
		
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                m_PrimProc.BeginPrimSet( D3DPT_TRIANGLEFAN, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
		            DoDrawOneGenEdgeFlagTriangleFan( dwVStride, pVData,
                    pParam->PrimitiveCount, pParam->dwEdgeFlags);
                else
		            DoDrawOneEdgeFlagTriangleFan( dwVStride, pVData,
                    pParam->PrimitiveCount, pParam->dwEdgeFlags);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    void Begin()
    {
        HRESULT hr( DD_OK);

        if((m_uFlags& c_uiBegan)!= 0)
            return;

        // TODO: call this less often?
        UpdateColorKeyAndPalette();

        // Check for state changes
        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }
        RastLockSpanTexture();

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        hr= SpanInit(&m_RastCtx);

        // Lock rendering target (must be VM Surfaces).
        m_RastCtx.pSurfaceBits= reinterpret_cast<UINT8*>(
            reinterpret_cast< TSurface*>(m_RastCtx.pDDS)->Lock( 0, NULL));
        if( m_RastCtx.pDDSZ!= NULL)
        {
            m_RastCtx.pZBits= reinterpret_cast<UINT8*>(
                reinterpret_cast< TSurface*>(m_RastCtx.pDDSZ)->Lock( 0, NULL));
        }
        else
        {
            m_RastCtx.pZBits = NULL;
        }

        // Prepare the primitive processor
        m_PrimProc.Begin();
        m_uFlags|= c_uiBegan;
    }
    void End( void)
    {
        if((m_uFlags& c_uiBegan)!= 0)
        {
            HRESULT hr = m_PrimProc.End();
            assert( SUCCEEDED( hr));

            // Unlock texture if this is not called in the middle of drawPrims to
            // flush for possible state changes. In the 2nd case, let
            // SetRenderState to handle it.
            RastUnlockSpanTexture();

            // Unlock surfaces
            reinterpret_cast<TSurface*>(m_RastCtx.pDDS)->Unlock();
            if( m_RastCtx.pDDSZ!= NULL)
                reinterpret_cast<TSurface*>(m_RastCtx.pDDSZ)->Unlock();

            m_uFlags&= ~c_uiBegan;
        }
    }
    bool IsTextureOff(void)
    {
        return
            (m_RastCtx.cActTex == 0 ||
            (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
            (m_RastCtx.cActTex == 2 &&
             (m_RastCtx.pTexture[0] == NULL ||
              m_RastCtx.pTexture[1] == NULL)));
    }
    void RastUnlockSpanTexture(void)
    {
        INT i, j;
        PD3DI_SPANTEX pSpanTex;;

        if (IsTextureOff())
        {
            return;
        }

        for (j = 0;
            j < (INT)m_RastCtx.cActTex;
            j++)
        {
            pSpanTex = m_RastCtx.pTexture[j];

            INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
            // RastUnlock is used for cleanup in RastLock so it needs to
            // be able to handle partially locked mipmap chains.
            if((pSpanTex->uFlags& D3DI_SPANTEX_SURFACES_LOCKED)!= 0)
            {
                for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
                {
                    const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                        reinterpret_cast<const TPerDDrawData::TSurfDBEntry*>(
                        pSpanTex->pSurf[i]);

                    if((pSurfDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0)
                    {
                        TSurface* pSurf= GetPerDDrawData().GetDriver().GetSurface( *pSurfDBEntry);
                        pSurf->Unlock();
                        pSpanTex->pBits[i-iFirstSurf]= NULL;
                    }
                }

                pSpanTex->uFlags&= ~D3DI_SPANTEX_SURFACES_LOCKED;
            }
        }
    }
    UINT32 static IntLog2(UINT32 x)
    {
        UINT32 y = 0;

        x >>= 1;
        while(x != 0)
        {
            x >>= 1;
            y++;
        }

        return y;
    }
    static HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
    {
        const TPerDDrawData::TSurfDBEntry* pLcl;
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
        INT i;

        // Init
        pLcl = (const TPerDDrawData::TSurfDBEntry*)pDDS;

        pSpanTex->iSizeU = (INT16)pLcl->GetGBLwWidth();
        pSpanTex->iSizeV = (INT16)pLcl->GetGBLwHeight();
        pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
        pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
        pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
        if (0 != pLcl->GetGBLddpfSurface().dwRGBBitCount)
        {
            pSpanTex->iShiftPitch[0] =
                    (INT16)IntLog2((UINT32)(pLcl->GetGBLlPitch()* 8)/
                    pLcl->GetGBLddpfSurface().dwRGBBitCount);
        }
        else
        {
            pSpanTex->iShiftPitch[0] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLwWidth()* 8));
        }
        pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
        pSpanTex->uMaskV = pSpanTex->uMaskV;

        // Check if the texture size is power of 2
/*        if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                              pSpanTex->iSizeV, pSpanTex->iShiftV))
        {
            return DDERR_INVALIDPARAMS;
        }*/

        // Check for mipmap if any.
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
        // mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
        for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
        {
            pDDS = pSpanTex->pSurf[i];
            // Check for invalid mipmap texture size
            pLcl = (const TPerDDrawData::TSurfDBEntry*)pDDS;
/*            if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
            {
                return DDERR_INVALIDPARAMS;
            }*/
            if (0 != pLcl->GetGBLddpfSurface().dwRGBBitCount)
            {
                pSpanTex->iShiftPitch[i - iFirstSurf] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLlPitch()* 8)/
                    pLcl->GetGBLddpfSurface().dwRGBBitCount);
            }
            else
            {
                pSpanTex->iShiftPitch[i - iFirstSurf] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLwWidth()*8));
            }
            iPreSizeU = (INT16)pLcl->GetGBLwWidth();
            iPreSizeV = (INT16)pLcl->GetGBLwHeight();
        }
        pSpanTex->cLOD = pSpanTex->cLODTex - iFirstSurf;
        pSpanTex->iMaxScaledLOD = ((pSpanTex->cLOD + 1) << LOD_SHIFT) - 1;
        pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

        return DD_OK;
    }
    void RastLockSpanTexture(void)
    {
        INT i, j;
        PD3DI_SPANTEX pSpanTex;
        HRESULT hr;

        if (IsTextureOff())
            return;

        for( j= 0; j< (INT)m_RastCtx.cActTex; j++)
        {
            pSpanTex= m_RastCtx.pTexture[j];
            if((pSpanTex->uFlags& D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)!= 0)
            {
                hr= SetSizesSpanTexture(pSpanTex);
                if( hr!= D3D_OK)
                {
                    RastUnlockSpanTexture();
                    return;
                }
            }
            INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                    reinterpret_cast<const TPerDDrawData::TSurfDBEntry*>(
                    pSpanTex->pSurf[i]);

                if((pSurfDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0)
                {
                    TSurface* pSurf= GetPerDDrawData().GetDriver().GetSurface( *pSurfDBEntry);
                    pSpanTex->pBits[i-iFirstSurf]= reinterpret_cast<UINT8*>(
                        pSurf->Lock( 0, NULL));
                }
            }

            pSpanTex->uFlags|= D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    void UpdateColorKeyAndPalette()
    {
        // TODO: Palette
        INT j;
        PD3DI_SPANTEX pSpanTex;

        // Set the transparent bit and the transparent color with pSurf[0]
        const TPerDDrawData::TSurfDBEntry* pLcl;
        for (j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            pSpanTex = m_RastCtx.pTexture[j];
            if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
            {
                pLcl= (const TPerDDrawData::TSurfDBEntry*)(pSpanTex->pSurf[0]);

                // Palette might be changed
                if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
                {
                    TPalDBEntry* pPalDBEntry= pLcl->GetPalette();
                    assert( pPalDBEntry!= NULL);

                    if((pPalDBEntry->GetFlags()& DDRAWIPAL_ALPHA)!= 0)
                        pSpanTex->uFlags|= D3DI_SPANTEX_ALPHAPALETTE;
                    pSpanTex->pPalette= reinterpret_cast< PUINT32>(
                        pPalDBEntry->GetEntries());
                }

                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // TODO:
                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    // StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
    bool NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
    {
        if (m_RastCtx.pdwRenderState[D3DRS_CULLMODE] == D3DCULL_NONE)
            return true;

        FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;
        x1 = pV0->sx;
        y1 = pV0->sy;
        x2x1 = pV1->sx - x1;
        y2y1 = pV1->sy - y1;
        x3x1 = pV2->sx - x1;
        y3y1 = pV2->sy - y1;

        fDet = x2x1 * y3y1 - x3x1 * y2y1;

        if (0. == fDet)
            return false;
        switch ( m_RastCtx.pdwRenderState[D3DRS_CULLMODE] )
        {
        case D3DCULL_CW:
            if ( fDet > 0.f )
            {
                return false;
            }
            break;
        case D3DCULL_CCW:
            if ( fDet < 0.f )
            {
                return false;
            }
            break;
        }
        return true;
    }
    void DoDrawOnePrimitive( UINT16 FvfStride, PUINT8 pVtx,
        D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch (PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {                    
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV0, GV1, GV2, GV3;

                        PackGenVertex( pVtx, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(pVtx),
                            reinterpret_cast<D3DTLVERTEX*>(pVtx));
                        pVtx += FvfStride;
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(pV0),
                    reinterpret_cast<D3DTLVERTEX*>(pV1),
                    reinterpret_cast<D3DTLVERTEX*>(pV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                pV1 = pVtx;

                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV0.
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    pVtx += FvfStride;
                    pV1 = pVtx;
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0));
                }

                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride;
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                for (i = (INT)cPrims; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx;
                pVtx += FvfStride;
                // Preload initial pV0.
                pV1 = pVtx;
                pVtx += FvfStride;
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        default:
            assert( false);
        }
    }
    void DoDrawOneGenPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch (PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV3;

                        PackGenVertex( pVtx, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        PackGenVertex( pVtx, &GV0);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV0));
                       pVtx += FvfStride;
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                PackGenVertex( pV0, &GV0);
                PackGenVertex( pV1, &GV1);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(&GV0),
                    reinterpret_cast<D3DTLVERTEX*>(&GV1),
                    reinterpret_cast<D3DTLVERTEX*>(&GV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                pV1 = pVtx;
                PackGenVertex( pV1, &GV1);

                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV0.
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    GV0= GV1;
                    pVtx += FvfStride;
                    pV1 = pVtx;
                    PackGenVertex( pV1, &GV1);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0));
                }

                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride;
                    PackGenVertex( pV0, &GV0);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                PackGenVertex( pV0, &GV0);
                PackGenVertex( pV1, &GV1);
                PackGenVertex( pV2, &GV2);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                PackGenVertex( pV1, &GV1);
                PackGenVertex( pV2, &GV2);

                for (i = (INT)cPrims; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }

                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx;
                PackGenVertex( pV2, &GV2);

                pVtx += FvfStride;
                // Preload initial pV0.
                pV1 = pVtx;
                PackGenVertex( pV1, &GV1);
                pVtx += FvfStride;

                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx;
                    PackGenVertex( pV1, &GV1);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        default:
            assert( false);
        }
    }

    void DoDrawOneIndexedPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        LPWORD puIndices, D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch(PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV0, GV1, GV2, GV3;

                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        pV0 = pVtx + FvfStride * (*puIndices++);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(pV0),
                            reinterpret_cast<D3DTLVERTEX*>(pV0));
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                pV1 = pVtx + FvfStride * (*puIndices++);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(pV0),
                    reinterpret_cast<D3DTLVERTEX*>(pV1),
                    reinterpret_cast<D3DTLVERTEX*>(pV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV1.
                pV1 = pVtx + FvfStride * (*puIndices++);
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0));
                }
                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride * (*puIndices);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                pV1 = pVtx + FvfStride * (*puIndices++);
                pV2 = pVtx + FvfStride * (*puIndices++);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx + FvfStride * (*puIndices++);
                pV2 = pVtx + FvfStride * (*puIndices++);

                for (i = (INT)cPrims; i > 1; i-= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx + FvfStride * (*puIndices++);
                // Preload initial pV0.
                pV1 = pVtx + FvfStride * (*puIndices++);
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;
        }
    }
    void DoDrawOneGenIndexedPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        LPWORD puIndices, D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch(PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV3;

                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV0));
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV0, &GV0);
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(&GV0),
                    reinterpret_cast<D3DTLVERTEX*>(&GV1),
                    reinterpret_cast<D3DTLVERTEX*>(&GV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV1.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV1, &GV1);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0));
                }
                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride * (*puIndices);
                    PackGenVertex( pV0, &GV0);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV0, &GV0);
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);

                for (i = (INT)cPrims; i > 1; i-= 2)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }

                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);
                // Preload initial pV0.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV1, &GV1);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;
        }
    }

    void DoDrawOneEdgeFlagTriangleFan( UINT16 FvfStride, PUINT8 pVtx,
        UINT cPrims, UINT32 dwEdgeFlags)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        pV2 = pVtx;
        pVtx += FvfStride;
        pV0 = pVtx;
        pVtx += FvfStride;
        pV1 = pVtx;
        pVtx += FvfStride;
        WORD wFlags = 0;
        if(dwEdgeFlags & 0x2)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        if(dwEdgeFlags & 0x1)
            wFlags |= D3DTRIFLAG_EDGEENABLE3;
        if(cPrims == 1) {
            if(dwEdgeFlags & 0x4)
                wFlags |= D3DTRIFLAG_EDGEENABLE2;

            // TODO: Move into PrimProc.
            switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
            {
            case D3DFILL_POINT:
               m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
               m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
               m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
               break;
            case D3DFILL_WIREFRAME:
                if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                {
                    if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                }
                break;
            case D3DFILL_SOLID:
                m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                break;
            }
            return;
        }

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
            break;
        }
        UINT32 dwMask = 0x4;
        for (i = (INT)cPrims - 2; i > 0; i--)
        {
            pV0 = pV1;
            pV1 = pVtx;
            pVtx += FvfStride;
            if(true|| (dwEdgeFlags & dwMask)!= 0)
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            else
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            dwMask <<= 1;
        }
        pV0 = pV1;
        pV1 = pVtx;
        wFlags = 0;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        dwMask <<= 1;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
            break;
        }
    }
    void DoDrawOneGenEdgeFlagTriangleFan( UINT16 FvfStride, PUINT8 pVtx,
        UINT cPrims, UINT32 dwEdgeFlags)
    {
        INT i;
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        pV2 = pVtx;
        PackGenVertex( pV2, &GV2);
        pVtx += FvfStride;
        pV0 = pVtx;
        PackGenVertex( pV0, &GV0);
        pVtx += FvfStride;
        pV1 = pVtx;
        PackGenVertex( pV1, &GV1);
        pVtx += FvfStride;
        WORD wFlags = 0;
        if(dwEdgeFlags & 0x2)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        if(dwEdgeFlags & 0x1)
            wFlags |= D3DTRIFLAG_EDGEENABLE3;
        if(cPrims == 1) {
            if(dwEdgeFlags & 0x4)
                wFlags |= D3DTRIFLAG_EDGEENABLE2;

            // TODO: Move into PrimProc.
            switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
            {
            case D3DFILL_POINT:
               m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
               m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
               m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
               break;
            case D3DFILL_WIREFRAME:
                if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                {
                    if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                }
                break;
            case D3DFILL_SOLID:
                m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                break;
            }
            return;
        }

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
            break;
        }
        UINT32 dwMask = 0x4;
        for (i = (INT)cPrims - 2; i > 0; i--)
        {
            pV0 = pV1;
            GV0 = GV1;
            pV1 = pVtx;
            PackGenVertex( pV1, &GV1);
            pVtx += FvfStride;
            if(true || (dwEdgeFlags & dwMask)!= 0)
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            else
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            dwMask <<= 1;
        }
        pV0 = pV1;
        GV0 = GV1;
        pV1 = pVtx;
        PackGenVertex( pV1, &GV1);
        wFlags = 0;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        dwMask <<= 1;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
            break;
        }
    }
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\makefile.inc ===
!include ..\rgbrule.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern double g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if 0 || DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\rgb_pch_cpp.cpp ===
#include "rgb_pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\driver.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
class _multiple_inheritance CRGBContext;
class _single_inheritance CRGBDriver;
class _single_inheritance CRGBPerDDrawData;

typedef CSurfDBEntryWPal<> TSurfDBEntry;
typedef CSubPerDDrawData< CRGBPerDDrawData, CRGBDriver, TSurfDBEntry,
    static_hash_map< DWORD, TSurfDBEntry, 64> >
    TSubPerDDrawData;

class CRGBPerDDrawData:
    public TSubPerDDrawData
{
public:
    CRGBPerDDrawData( TDriver& Driver, DDRAWI_DIRECTDRAW_LCL& DDLcl) throw()
        :TSubPerDDrawData( Driver, DDLcl)
    { }
    ~CRGBPerDDrawData() throw() { }
};

typedef CSubDriver< CRGBDriver, CRGBContext, CRGBSurfAllocator, CRGBPerDDrawData>
    TSubDriver;

class CSupportedSurface
{
protected:
    DDSURFACEDESC m_SDesc;
    CRGBSurfAllocator::TCreateSurfFn m_CreateFn;

public:
    CSupportedSurface() { }
    CSupportedSurface( DDSURFACEDESC SDesc, CRGBSurfAllocator::TCreateSurfFn CFn)
        : m_SDesc( SDesc), m_CreateFn( CFn)
    { }
    operator DDSURFACEDESC() const
    { return m_SDesc; }
    DDSURFACEDESC GetMatch() const
    {
        SPixelFormat PFmt(
            static_cast< D3DFORMAT>(m_SDesc.ddpfPixelFormat.dwFourCC));

        DDSURFACEDESC RetSDesc;
        ZeroMemory( &RetSDesc, sizeof(RetSDesc));
        RetSDesc.dwFlags= DDSD_PIXELFORMAT;
        RetSDesc.ddpfPixelFormat= PFmt;
        return RetSDesc;
    }
    operator CRGBSurfAllocator::TCreateSurfFn() const
    { return m_CreateFn; }
};

class CRGBDriver:
    public TSubDriver
{
private:
    static CSupportedSurface c_aSurfaces[];
    static const D3DCAPS8 c_D3DCaps;

public:
    CRGBDriver();
    ~CRGBDriver()
    { }

    static const D3DCAPS8& GetCaps()
    { return c_D3DCaps; }
    static void InitSupportedSurfaceArray();
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

//#include <d3ditype.h>
#include <d3dflt.h>
#include <span.h>

typedef enum _RASTSurfaceType
{
    RAST_STYPE_NULL     = 0,
    RAST_STYPE_B8G8R8   = 1,
    RAST_STYPE_B8G8R8A8 = 2,
    RAST_STYPE_B8G8R8X8 = 3,
    RAST_STYPE_B5G6R5   = 4,
    RAST_STYPE_B5G5R5   = 5,
    RAST_STYPE_PALETTE4 = 6,
    RAST_STYPE_PALETTE8 = 7,
    RAST_STYPE_B5G5R5A1 = 8,
    RAST_STYPE_B4G4R4   = 9,
    RAST_STYPE_B4G4R4A4 =10,
    RAST_STYPE_L8       =11,          // 8 bit luminance-only
    RAST_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RAST_STYPE_U8V8     =13,          // 16 bit bump map format
    RAST_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RAST_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RAST_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RAST_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RAST_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RAST_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RAST_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RAST_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RAST_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RAST_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RAST_STYPE_Z16S0    =32,
    RAST_STYPE_Z24S8    =33,
    RAST_STYPE_Z15S1    =34,
    RAST_STYPE_Z32S0    =35,

} RASTSurfaceType;


#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhalp.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };


    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTexEnd;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\surfaces.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
void MemFill( UINT32 uiData, void* pData, UINT32 uiBytes) throw();
void MemMask( UINT32 uiData, UINT32 uiMask, void* pData, UINT32 uiBytes) throw();

class IRGBSurface: public IVidMemSurface
{
protected:
    LONG m_lPitch;
    WORD m_wWidth;
    WORD m_wHeight;
    unsigned char m_ucBPP;

    IRGBSurface( DWORD dwHandle, LONG P, WORD W, WORD H, unsigned char BPP)
        throw(): IVidMemSurface( dwHandle), m_lPitch( P), m_wWidth( W),
        m_wHeight( H), m_ucBPP( BPP)
    { }

public:
    LONG GetGBLlPitch( void) const throw()
    { return m_lPitch; }
    WORD GetGBLwWidth( void) const throw()
    { return m_wWidth; }
    WORD GetGBLwHeight( void) const throw()
    { return m_wHeight; }
    unsigned char GetBytesPerPixel( void) const throw()
    { return m_ucBPP; }
    virtual ~IRGBSurface() throw()
    { }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()= 0;
};

class CRGBSurfAllocator
{
public: // Types
    typedef IRGBSurface TSurface;
    typedef TSurface* (*TCreateSurfFn)( const DDSURFACEDESC&,
        PORTABLE_DDRAWSURFACE_LCL&);

protected: // Types
    typedef vector< std::pair< DDSURFACEDESC, TCreateSurfFn> > TCreateSurfFns;
    TCreateSurfFns m_CreateSurfFns;
    struct SAdaptedMatchFn: public SMatchSDesc
    {
        typedef TCreateSurfFns::value_type argument_type;
        using SMatchSDesc::result_type;

        SAdaptedMatchFn( const DDSURFACEDESC& SDesc) throw(): SMatchSDesc( SDesc) {}

        result_type operator()( argument_type Arg) const throw()
        { return (*static_cast< const SMatchSDesc*>(this))( Arg.first); }
    };

public:
    template< class TIter>
    CRGBSurfAllocator( TIter itStart, const TIter itEnd) throw(bad_alloc)
    {
        while( itStart!= itEnd)
        {
            m_CreateSurfFns.push_back(
                TCreateSurfFns::value_type( itStart->GetMatch(), *itStart));
            ++itStart;
        }
    }

    TSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& Surf) const
    {
        TCreateSurfFns::const_iterator itFound( 
            find_if( m_CreateSurfFns.begin(), m_CreateSurfFns.end(),
            SAdaptedMatchFn( SDesc) ) );

        // Hey, if we don't support a VM of this surface type,
        // but how did we get asked to allocate one, then?
        if( itFound== m_CreateSurfFns.end())
            throw HRESULT( DDERR_UNSUPPORTED);

        return (itFound->second)( SDesc, Surf);
    }
};

class CRGBSurface: public IRGBSurface
{
public: // Types
    typedef unsigned int TLocks;

protected: // Variables
    void* m_pData;
    size_t m_uiBytes;
    TLocks m_uiLocks;

public: // Functions
    CRGBSurface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf)
        throw(bad_alloc): IRGBSurface( DDSurf.lpSurfMore()->dwSurfaceHandle(), 
        0, DDSurf.lpGbl()->wWidth, DDSurf.lpGbl()->wHeight, 0),
        m_pData( NULL), m_uiBytes( 0), m_uiLocks( 0)
    {
        // We must allocate this surface. Since we are specified as a SW driver,
        // DDraw will not allocate for us.
        assert((SDesc.dwFlags& DDSD_PIXELFORMAT)!= 0);

        m_ucBPP= static_cast< unsigned char>(
            SDesc.ddpfPixelFormat.dwRGBBitCount>> 3);

        // TODO: Align pitch to 128-bit bit boundary, instead?
        DDSurf.lpGbl()->lPitch= m_lPitch= ((m_ucBPP* m_wWidth+ 7)& ~7);

        m_uiBytes= m_lPitch* m_wHeight;

        // It would've been nice to have the initial proctection NOACCESS, but
        // it seems the HAL needs to read to the region, initially.
        m_pData= VirtualAlloc( NULL, m_uiBytes, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if( m_pData== NULL)
            throw bad_alloc( "Not enough memory to allocate Surface data");
        DDSurf.lpGbl()->fpVidMem= reinterpret_cast<FLATPTR>( m_pData);
    }
    virtual ~CRGBSurface() throw()
    {
        // Warning: m_uiLocks doesn't have to be 0. The run-time will destroy
        // a surface without un-locking it.
        assert( m_pData!= NULL);
        VirtualFree( m_pData, 0, MEM_DECOMMIT| MEM_RELEASE);
    }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect) throw()
    {
        numeric_limits< TLocks> Dummy;
        assert( Dummy.max()!= m_uiLocks);
#if 0   // defined(DBG) || defined(_DEBUG)
        // This code can't be enabled. Currently, run-time knows that this is
        // really a system memory surface, and thus doesn't tell us to lock it
        // into memory before using the bits. Known areas that could be fixed:
        // (surface creation needs valid pointer & Present uses pointer).
        if( 0== m_uiLocks)
        {
            DWORD dwProtect( PAGE_EXECUTE_READWRITE);
            if( dwFlags& DDLOCK_READONLY)
                dwProtect= PAGE_READONLY;
            else if( dwFlags& DDLOCK_WRITEONLY)
                dwProtect= PAGE_READWRITE;

            DWORD dwOldP;
            VirtualProtect( m_pData, m_uiBytes, dwProtect, &dwOldP);
        }
#endif
        ++m_uiLocks;

        if( pRect!= NULL)
        {
            return static_cast<void*>( reinterpret_cast<UINT8*>(
                m_pData)+ pRect->top* m_lPitch+ pRect->left* m_ucBPP);
        }
        else
            return m_pData;
    }
    virtual void Unlock( void) throw()
    {
        assert( 0!= m_uiLocks);
#if 0 // defined(DBG) || defined(_DEBUG)
        if( 0== --m_uiLocks)
        {
            DWORD dwOldP;
            VirtualProtect( m_pData, m_uiBytes, PAGE_NOACCESS, &dwOldP);
        }
#else
        --m_uiLocks;
#endif
    }
};

class CR5G6B5Surface: public CRGBSurface
{
public:
    CR5G6B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G6R5; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CR5G6B5Surface( SDesc, DDSurf);
    }
};

class CA8R8G8B8Surface: public CRGBSurface
{
public:
    CA8R8G8B8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B8G8R8A8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA8R8G8B8Surface( SDesc, DDSurf);
    }
};

class CX8R8G8B8Surface: public CRGBSurface
{
public:
    CX8R8G8B8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B8G8R8X8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CX8R8G8B8Surface( SDesc, DDSurf);
    }
};

class CD16Surface: public CRGBSurface
{
public:
    CD16Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_Z16S0; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CD16Surface( SDesc, DDSurf);
    }
};

class CD24S8Surface: public CRGBSurface
{
public:
    CD24S8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_Z24S8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CD24S8Surface( SDesc, DDSurf);
    }
};

class CX1R5G5B5Surface: public CRGBSurface
{
public:
    CX1R5G5B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CX1R5G5B5Surface_being_asked_to_Clear( false);
        assert( CX1R5G5B5Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G5R5; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CX1R5G5B5Surface( SDesc, DDSurf);
    }
};

class CA1R5G5B5Surface: public CRGBSurface
{
public:
    CA1R5G5B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA1R5G5B5Surface_being_asked_to_Clear( false);
        assert( CA1R5G5B5Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G5R5A1; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA1R5G5B5Surface( SDesc, DDSurf);
    }
};

class CP8Surface: public CRGBSurface
{
public:
    CP8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CP8Surface_being_asked_to_Clear( false);
        assert( CP8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_PALETTE8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CP8Surface( SDesc, DDSurf);
    }
};

class CA8L8Surface: public CRGBSurface
{
public:
    CA8L8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA8L8Surface_being_asked_to_Clear( false);
        assert( CA8L8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_L8A8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA8L8Surface( SDesc, DDSurf);
    }
};

class CL8Surface: public CRGBSurface
{
public:
    CL8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CL8Surface_being_asked_to_Clear( false);
        assert( CL8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_L8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CL8Surface( SDesc, DDSurf);
    }
};

class CA4R4G4B4Surface: public CRGBSurface
{
public:
    CA4R4G4B4Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA4R4G4B4Surface_being_asked_to_Clear( false);
        assert( CA4R4G4B4Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B4G4R4A4; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA4R4G4B4Surface( SDesc, DDSurf);
    }
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;
    
        pAttr->fUoW[0] += pDelta->fUoW[0];
        pAttr->fVoW[0] += pDelta->fVoW[0];
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i];
            pAttr->fVoW[i] += pDelta->fVoW[i];
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW[0] = pStpCtx->fNextUoW1;
            pAttr->fVoW[0] = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW[0] += pDelta->fUoW[0] * fScale;
            pAttr->fVoW[0] += pDelta->fVoW[0] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i] * fScale;
            pAttr->fVoW[i] += pDelta->fVoW[i] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
    
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }
        
        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW[0] * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW[0] * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }
        
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;
            
                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }
                
            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW[0] + pStpCtx->DAttrDX.fUoW[0] * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW[0] + pStpCtx->DAttrDX.fVoW[0] * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;
                
            pSpan->iDLOD =
                (INT16)(FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix));
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }
            
        pSpan->iOoW = FTOI(pAttr->fOoW);
    
        pSpan->UVoW[0].iUoW = FTOI(pAttr->fUoW[0]);
        pSpan->UVoW[0].iVoW = FTOI(pAttr->fVoW[0]);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pSpan->UVoW[i].iUoW = FTOI(pAttr->fUoW[i]);
            pSpan->UVoW[i].iVoW = FTOI(pAttr->fVoW[i]);
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT16)(FTOI(pAttr->fB));
        pSpan->uG = (UINT16)(FTOI(pAttr->fG));
        pSpan->uR = (UINT16)(FTOI(pAttr->fR));
        pSpan->uA = (UINT16)(FTOI(pAttr->fA));
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT16)(FTOI(pAttr->fBS));
        pSpan->uGS = (UINT16)(FTOI(pAttr->fGS));
        pSpan->uRS = (UINT16)(FTOI(pAttr->fRS));
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (UINT16)(FTOI(pAttr->fFog));
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;
        
        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.
        
        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }
        
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;
                
            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\pch\rgb_pch.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define RGB_RAST_LIB_NAMESPACE D3D8RGBRast

#if defined(DBG) || defined(_DEBUG)
#define assert(condition) \
    do { if(!(condition) && RGB_RAST_LIB_NAMESPACE::Assert(__FILE__, __LINE__, #condition)) DebugBreak(); } while( false)
#else
#define assert(condition) (0)
#endif

// #include <ddrawpr.h>

// Windows
#include <windows.h>

#if !defined(DBG) && !defined(_DEBUG)
#pragma inline_depth( 255)
#endif

#if defined(USE_ICECAP4)
#include <icecap.h>
#endif

#undef max
#undef min

// STL & standard headers.
#include <functional>
#include <algorithm>
#include <iterator>
#include <memory>
#include <limits>
#include <new>

// D3DRGBRast namespace provides shelter from clashing with any customer's
// symbols in their .libs, including any CRT stuff they include. Here, CRT
// pieces can be brought in one by one, assuring there isn't a problem. The
// primary problem found is with bad_alloc. If you look at this CRT header,
// it currently has the class either an inline or a dllimport based on a
// #define. This PCH will pick it up as inline.
// In Debug, or if the compiler chooses not to inline the function, a
// symbol will become present for std::bad_alloc::bad_alloc() in
// d3d8rgb.lib. If someone else links with us and a CRT .lib, which has
// std::bad_alloc::bad_alloc() also as a dllimport, then a conflict occurs.
// Here we can isolate each CRT/ STL piece and provide name mangling
// as neccessary by providing our own namespace.
// We also have to provide private map and set implementations, as CRT has
// a dllimport dependency on _lock. We don't want a thread-safe version
// anyway.
namespace RGB_RAST_LIB_NAMESPACE
{
    using std::numeric_limits;
    using std::unary_function;
    using std::binary_function;
    using std::input_iterator_tag;
    using std::output_iterator_tag;
    using std::forward_iterator_tag;
    using std::bidirectional_iterator_tag;
    using std::random_access_iterator_tag;
    using std::pair;
    using std::fill;
    using std::copy;
    using std::find_if;
    using std::auto_ptr;
    using std::fill;
    using std::less;
    using std::bind2nd;
    using std::not_equal_to;
    using std::equal;
    using std::logical_not;
    using std::equal_to;
    using std::next_permutation;
    template< class T>
    const T& min( const T& x, const T& y)
    { return ( x< y? x: y); }
    template< class T>
    const T& max( const T& x, const T& y)
    { return ( x> y? x: y); }
    template< class T>
    struct identity:
        unary_function< T, T>
    {
        const result_type& operator()( const argument_type& Arg) const
        { return Arg; }
    };
    template< class Pair>
    struct select1st:
        unary_function< Pair, typename Pair::first_type>
    {
        const result_type& operator()( const Pair& p) const
        { return p.first; }
    };
    class exception
    {
    private:
        const char* m_szWhat;
    public:
        exception() throw()
        { m_szWhat= "exception"; }
        exception(const char* const& szWhat) throw()
        { m_szWhat= szWhat; }
        exception(const exception& ex) throw()
        { (*this)= ex; }
        exception& operator= (const exception& ex) throw()
        { m_szWhat= ex.m_szWhat; return *this; }
        virtual ~exception() throw()
        { }
        virtual const char* what() const throw()
        { return m_szWhat; }
    };
    class bad_alloc: public exception
    {
    public:
    	bad_alloc(const char *_S = "bad allocation") throw()
            : exception(_S) {}
    	virtual ~bad_alloc() throw()
        { }
    };
    bool Assert(LPCSTR szFile, int nLine, LPCSTR szCondition);
#include "block.h"
#include "allocator.h"
}
using namespace RGB_RAST_LIB_NAMESPACE;

#include <vector>
namespace RGB_RAST_LIB_NAMESPACE
{
    // Override the standard vector, in order to provide a change in default
    // allocator. std::vector defaults to std::allocator. Should've been able
    // to name this "vector", but MSVC seems to have another bug. Keep getting
    // errors about std::vector not being defined. So, name it vector2 (which
    // compiles fine) and #define vector vector2.
    template< class T, class Allocator= allocator< T> >
    class vector2:
        public std::vector< T, Allocator>
    {
    public:
        typedef std::vector< T, Allocator> std_vector;
        explicit vector2( const Allocator& A= Allocator()): std_vector( A)
        { }
        explicit vector2( typename std_vector::size_type n, const T& x= T(),
            const Allocator& A= Allocator()): std_vector( n, x, A)
        { }
        vector2( const vector2< T, Allocator>& v): std_vector( v)
        { }
        template< class InputIterator>
        vector2( InputIterator f, InputIterator l, const Allocator& A=
            Allocator()): std_vector( f, l, A)
        { }
        ~vector2()
        { }
    };
#define vector vector2
#include "tree.h"
#include "map.h"
#include "set.h"
#include "list.h"
#include "hash_table.h"
#include "hash_map.h"
}

// DX
// Including d3d8ddi & d3d8sddi makes the pluggable software rasterizer
// a "private" feature as these headers aren't publically available.

#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include <d3d8p.h>

#include <d3d8ddi.h>
#include <d3d8sddi.h>
#include <DX8SDDIFW.h>

namespace RGB_RAST_LIB_NAMESPACE
{
    using namespace DX8SDDIFW;
}

#include "rast.h"
#include "span.h"
#include "setup.hpp"

#include "Surfaces.h"
#include "Driver.h"
#include "Context.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor)); // TODO: Fix this unextendable stuff.

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

// TODO: Move into constructor? How many places called?
HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    INT32 uSize = sizeof(D3DI_RASTPRIM);

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((uSize & (CACHE_LINE - 1)) == 0 &&
             (uSize & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE,
                            ((FLOAT)pSpan->UVoW[0].iUoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->UVoW[0].iVoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = DD_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = DD_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = DD_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != DD_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

extern "C" {
//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    DebugBreak();
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    return 0;
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return DD_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef D3DVECTOR* LPD3DVECTOR;

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
//  4 by 4 matrix product
//
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = DD_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != DD_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != DD_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != DD_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRS_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\attrs_mh.h: attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): offs_acp.acp $(RGBRASTROOT)\pch\span.h $(RGBRASTROOT)\pch\stp_base.h

$(GENTGT)\attrsx86.asm: attrsx86.mas attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: walkx86.mas attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW, fVoW;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW,
                                    pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW,
                                    pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW[0] =
                TextureDiff(pV1->dvTU, fUoW,
                            pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                TextureDiff(pV1->dvTV, fVoW,
                            pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW[0] = TEX_SCALE * fUoW +
            pStpCtx->DAttrDMajor.fUoW[0] * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW[0] = TEX_SCALE * fVoW +
            pStpCtx->DAttrDMajor.fVoW[0] * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW, fVoW;

        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                fUoW = pVM0->texCoord[i].dvTU * pVM0->dvRHW;
                fVoW = pVM0->texCoord[i].dvTV * pVM0->dvRHW;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTU, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTU, fUoW,
                                        pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_U) *
                                        TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTV, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTV, fVoW,
                                        pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_V) *
                                        TEX_SCALE * pStpCtx->fOoLen;
            }
            else
            {
                fUoW = pVM0->texCoord[i].dvTU;
                fVoW = pVM0->texCoord[i].dvTV;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTU, fUoW,
                                pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_U) *
                                TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTV, fVoW,
                                pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_V) *
                                TEX_SCALE * pStpCtx->fOoLen;
            }

            pStpCtx->Attr.fUoW[i] = TEX_SCALE * fUoW +
                pStpCtx->DAttrDMajor.fUoW[i] * pStpCtx->fDMajor;
            pStpCtx->Attr.fVoW[i] = TEX_SCALE * fVoW +
                pStpCtx->DAttrDMajor.fVoW[i] * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
    else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRS_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#if 0 && DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->UVoW[0].iUoW = FTOI(fUoW * TEX_SCALE);
        pSpan->UVoW[0].iVoW = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)m_StpCtx.pCtx->cActTex; i++)
        {
            if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU *
                         pV0->dvRHW * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV *
                         pV0->dvRHW * TEX_SCALE);
            }
            else
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV * TEX_SCALE);
            }
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (UINT16)(
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE));
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return DD_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != DD_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != DD_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup, if flat shaded.
    if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
    {
        m_StpCtx.pFlatVtx = pFlatVtx;
    }
    else
    {
        m_StpCtx.pFlatVtx = pV0;
    }


    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    /*if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else */
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRS_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (true || m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]))
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRS_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRS_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRS_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTexEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != DD_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != DD_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (true ||m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->texCoord[1].tu > 256.0F) || (pGV->texCoord[1].tu < -256.0F) ||
                (pGV->texCoord[1].tv > 256.0F) || (pGV->texCoord[1].tv < -256.0F))
            {
                RSDPF(("ValidateVertex: texCoord[1].tu,texCoord[1].tv out of range (%f,%f)\n",pGV->texCoord[1].tu,pGV->texCoord[1].tv));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return DD_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

// #include <cppdbg.hpp>

// DBG_DECLARE_HEADER(RS);

#if 0
#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)
#else
#define RSDPF(Args)
#define RSDPFM(Args)
#define RSASSERT(Exp)
#define RSASSERTMSG(Exp, Args)
#define RSVERIFY(Exp)           (Exp)
#define RSVERIFYMSG(Exp)        (Exp)
#define RSPROMPT(Args)
#define RSGETFLAGS(Idx)         (0)
#define RSSETFLAGS(Idx, Value)
#define RSHRCHK(Exp)            (hr= (Exp))
#define RSHRGO(Exp, Label)      if(RSHRCHK(Exp)!= S_OK) { goto Label; } else hr
#define RSHRERR(Exp)            RSHGO(Exp, HR_Err)
#define RSHRRET(Exp)            if(RSHRCHK(Exp)!= S_OK) { return hr; } else hr
#endif

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#include "walk_mh.h"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = DD_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min< UINT>(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != DD_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = DD_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != DD_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\bdstr_mh.h: bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: beadstr.mcp bdstr_mh.mh $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: spaninit.mcp bdstr_mh.mh $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#if 0 && DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "rgb_pch.h"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            // DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            // DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

// #include <cppdbg.hpp>

// DBG_DECLARE_HEADER(SPI);

#if 0
#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)
#else
#define SPIDPF(Args)
#define SPIDPFM(Args)
#define SPIASSERT(Exp)
#define SPIASSERTMSG(Exp, Args)
#define SPIVERIFY(Exp)           (Exp)
#define SPIVERIFYMSG(Exp)        (Exp)
#define SPIPROMPT(Args)
#define SPIGETFLAGS(Idx)         (0)
#define SPISETFLAGS(Idx, Value)
#define SPIHRCHK(Exp)            (hr= (Exp))
#define SPIHRGO(Exp, Label)      if(SPIHRCHK(Exp)!= S_OK) { goto Label; } else hr
#define SPIHRERR(Exp)            SPIHGO(Exp, HR_Err)
#define SPIHRRET(Exp)            if(SPIHRCHK(Exp)!= S_OK) { return hr; } else hr
#endif


#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\sample\main.cpp ===
#include "pch.h"
#include "SampleSW.h"
#pragma hdrstop

// Needed as MSVC doesn't throw bad_alloc upon failed new(), unless
// we specifically make it do.
_PNH g_OldNewHandler= NULL;

int _cdecl NewHandlerThatThrows( size_t size )
{
    throw std::bad_alloc();

    // Tell new to stop allocation attempts.
    return 0;
}

CMyDriver* CMyDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_OldNewHandler = _set_new_handler( NewHandlerThatThrows);
            CMyDriver::sm_pGlobalDriver= new CMyDriver;
            break;

        // DLL_PROCESS_DETACH will be called if ATTACH returned FALSE.
        case DLL_PROCESS_DETACH:
            delete CMyDriver::sm_pGlobalDriver;
            CMyDriver::sm_pGlobalDriver= NULL;
            _set_new_handler( g_OldNewHandler);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

HRESULT APIENTRY
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    return CMyDriver::sm_pGlobalDriver->GetSWInfo( *pCaps, *pCallbacks,
        *pNumTextures, *ppTexList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\sample\pch.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Windows
#include <windows.h>

#undef min
#undef max

// STL & standard headers.
#include <functional>
#include <algorithm>
#include <iterator>
#include <assert.h>
#include <memory>
#include <vector>
#include <limits>
#include <map>
#include <set>
#include <new.h>

using namespace std;

// DX (as should be included if on Win9x)
// Instead of these 4, just <ddrawpr.h> before <windows.h> could be used,
// as it includes D3DERRs. But, this is even more internal (depends on more).
#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include <d3d8.h>

// Including d3d8ddi & d3d8sddi makes the pluggable software rasterizer
// a "private" feature as these headers aren't publically available.
#include <d3d8ddi.h>
#include <d3d8sddi.h>

// This header contains the framework to get rasterizers up and running ASAP.
#include <DX8SDDIFW.h>

// Local project
using namespace DX8SDDIFW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\sample\samplesw.cpp ===
#include "pch.h"
#include "SampleSW.h"
#pragma hdrstop

const D3DCAPS8 CMyDriver::c_D3DCaps=
{
    // Indicates this is software rasterizer.
    /*D3DDEVTYPE_HAL|| D3DDEVTYPE_REF||*/ D3DDEVTYPE_SW,

    // Adapter ordinal (isn't used to report anything).
    0,

    // Caps (See ddraw.h & d3d8caps.h for details of each CAP).
    /*DDCAPS_3D| DDCAPS_ALIGNBOUNDARYDEST| DDCAPS_ALIGNSIZEDEST|
    DDCAPS_ALIGNBOUNDARYSRC| DDCAPS_ALIGNSIZESRC| DDCAPS_ALIGNSTRIDE|
    DDCAPS_BLT| DDCAPS_BLTQUEUE| DDCAPS_BLTFOURCC| DDCAPS_BLTSTRETCH|
    DDCAPS_GDI| DDCAPS_OVERLAY| DDCAPS_OVERLAYCANTCLIP| DDCAPS_OVERLAYFOURCC|
    DDCAPS_OVERLAYSTRETCH| DDCAPS_PALETTE| DDCAPS_PALETTEVSYNC| 
    DDCAPS_READSCANLINE| DDCAPS_VBI| DDCAPS_ZBLTS| DDCAPS_ZOVERLAYS|
    DDCAPS_COLORKEY| DDCAPS_ALPHA| DDCAPS_COLORKEYHWASSIST| DDCAPS_NOHARDWARE|
    DDCAPS_BLTCOLORFILL| DDCAPS_BANKSWITCHED| DDCAPS_BLTDEPTHFILL|
    DDCAPS_CANCLIP| DDCAPS_CANCLIPSTRETCHED| DDCAPS_CANBLTSYSMEM|
    D3DCAPS_READ_SCANLINE|*/ 0,

    // Caps2
    /*DDCAPS2_CERTIFIED| DDCAPS2_NO2DDURING3DSCENE| DDCAPS2_VIDEOPORT|
    DDCAPS2_AUTOFLIPOVERLAY| DDCAPS2_CANBOBINTERLEAVED| 
    DDCAPS2_CANBOBNONINTERLEAVED| DDCAPS2_COLORCONTROLOVERLAY| 
    DDCAPS2_COLORCONTROLPRIMARY|*/ DDCAPS2_CANDROPZ16BIT| 
    /*DDCAPS2_NONLOCALVIDMEM| DDCAPS2_NONLOCALVIDMEMCAPS| 
    DDCAPS2_NOPAGELOCKREQUIRED|*/ DDCAPS2_WIDESURFACES|
    /*DDCAPS2_CANFLIPODDEVEN| DDCAPS2_CANBOBHARDWARE| DDCAPS2_COPYFOURCC|
    DDCAPS2_PRIMARYGAMMA|*/ DDCAPS2_CANRENDERWINDOWED| 
    /*DDCAPS2_CANCALIBRATEGAMMA| DDCAPS2_FLIPINTERVAL|
    DDCAPS2_FLIPNOVSYNC| DDCAPS2_CANMANAGETEXTURE|
    DDCAPS2_TEXMANINNONLOCALVIDMEM| DDCAPS2_STEREO|
    DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL| D3DCAPS2_NO2DDURING3DSCENE| 
    D3DCAPS2_FULLSCREENGAMMA|*/ D3DCAPS2_CANRENDERWINDOWED|
    /*D3DCAPS2_CANCALIBRATEGAMMA|*/ 0,

    // Caps3
    0,
    // Presentation Intervals
    0,
    // Cursor Caps
    0,

    // DevCaps (See d3d8caps.h & d3dhal.h)
    // The SDDI driver should keep D3DDEVCAPS_TEXTUREVIDEOMEMORY enabled. The
    // runtime does not behave correctly if the driver does not enable and
    // support this cap. In other words, all textures must be able to be
    // vid mem (driver allocated) textures, at least.
    D3DDEVCAPS_EXECUTESYSTEMMEMORY| /*D3DDEVCAPS_EXECUTEVIDEOMEMORY|*/
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY| /*D3DDEVCAPS_TLVERTEXVIDEOMEMORY|*/
    D3DDEVCAPS_TEXTURESYSTEMMEMORY| D3DDEVCAPS_TEXTUREVIDEOMEMORY|
    D3DDEVCAPS_DRAWPRIMTLVERTEX| /*D3DDEVCAPS_CANRENDERAFTERFLIP|
    D3DDEVCAPS_TEXTURENONLOCALVIDMEM| D3DDEVCAPS_DRAWPRIMITIVES2|*/
    /*D3DDEVCAPS_SEPARATETEXTUREMEMORIES|*/ D3DDEVCAPS_DRAWPRIMITIVES2EX|
    /*D3DDEVCAPS_HWTRANSFORMANDLIGHT| D3DDEVCAPS_CANBLTSYSTONONLOCAL|*/
    D3DDEVCAPS_HWRASTERIZATION| /*D3DDEVCAPS_PUREDEVICE| 
    D3DDEVCAPS_QUINTICRTPATCHES| D3DDEVCAPS_RTPATCHES|
    D3DDEVCAPS_RTPATCHHANDLEZERO| D3DDEVCAPS_NPATCHES|
	D3DDEVCAPS_HWVERTEXBUFFER| D3DDEVCAPS_HWINDEXBUFFER|*/ 0,

    // Primitive Misc Caps
    D3DPMISCCAPS_MASKZ| D3DPMISCCAPS_LINEPATTERNREP| D3DPMISCCAPS_CULLNONE|
    D3DPMISCCAPS_CULLCW| D3DPMISCCAPS_CULLCCW| D3DPMISCCAPS_COLORWRITEENABLE|
    /*D3DPMISCCAPS_CLIPPLANESCALEDPOINTS| D3DPMISCCAPS_CLIPTLVERTS|*/
    D3DPMISCCAPS_TSSARGTEMP| D3DPMISCCAPS_BLENDOP| 0,

    // Raster Caps
    /*D3DPRASTERCAPS_DITHER| D3DPRASTERCAPS_ROP2| D3DPRASTERCAPS_XOR| 
    D3DPRASTERCAPS_PAT|*/ D3DPRASTERCAPS_ZTEST| /*D3DPRASTERCAPS_FOGVERTEX|
    D3DPRASTERCAPS_FOGTABLE| D3DPRASTERCAPS_ANTIALIASEDGES|
    D3DPRASTERCAPS_MIPMAPLODBIAS| D3DPRASTERCAPS_ZBIAS|
    D3DPRASTERCAPS_ZBUFFERLESSHSR| D3DPRASTERCAPS_FOGRANGE|
    D3DPRASTERCAPS_ANISOTROPY| D3DPRASTERCAPS_WBUFFER| 
    D3DPRASTERCAPS_WFOG| D3DPRASTERCAPS_ZFOG| 
    D3DPRASTERCAPS_COLORPERSPECTIVE| D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE|
    */ 0,

    // Z Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Src Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 
    D3DPBLENDCAPS_BOTHSRCALPHA| D3DPBLENDCAPS_BOTHINVSRCALPHA| 0,

    // Dest Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 0,

    // Alpha Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Shade Caps 
    D3DPSHADECAPS_COLORGOURAUDRGB| D3DPSHADECAPS_SPECULARGOURAUDRGB| 
    D3DPSHADECAPS_ALPHAGOURAUDBLEND| D3DPSHADECAPS_FOGGOURAUD| 0,

    // Texture Caps
    D3DPTEXTURECAPS_PERSPECTIVE| /*D3DPTEXTURECAPS_POW2|*/ 
    D3DPTEXTURECAPS_ALPHA| /*D3DPTEXTURECAPS_SQUAREONLY|*/
    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE| D3DPTEXTURECAPS_ALPHAPALETTE|
    /*D3DPTEXTURECAPS_NONPOW2CONDITIONAL|*/ D3DPTEXTURECAPS_PROJECTED| 
    D3DPTEXTURECAPS_CUBEMAP| D3DPTEXTURECAPS_VOLUMEMAP| 
    D3DPTEXTURECAPS_MIPMAP| D3DPTEXTURECAPS_MIPVOLUMEMAP| 
    D3DPTEXTURECAPS_MIPCUBEMAP| /*D3DPTEXTURECAPS_CUBEMAP_POW2| 
    D3DPTEXTURECAPS_VOLUMEMAP_POW2|*/ 0,

    // Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Cube Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Volume Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE| 0,

    // Volume Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE| 0,

    // Line Caps
    D3DLINECAPS_TEXTURE| D3DLINECAPS_ZTEST| D3DLINECAPS_BLEND| 
    D3DLINECAPS_ALPHACMP| D3DLINECAPS_FOG| 0,

    // Max Texture Width, Height, Volume Extent
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFF,
    
    // Max Texture Repeat, Texture Aspect Ratio, Anisotropy
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFF,

    // Max VertexW
    1.0e10f,

    // Guard Band left, top, right, bottom
    -32768.0f, -32768.0f, 32767.0f, 32767.0f,

    // Extents Adjust
    0.0f,

    // Stencil Caps
    D3DSTENCILCAPS_KEEP| D3DSTENCILCAPS_ZERO| D3DSTENCILCAPS_REPLACE|
    D3DSTENCILCAPS_INCRSAT| D3DSTENCILCAPS_DECRSAT| D3DSTENCILCAPS_INVERT|
    D3DSTENCILCAPS_INCR| D3DSTENCILCAPS_DECR| 0,

    // FVF Caps
    (8& D3DFVFCAPS_TEXCOORDCOUNTMASK)| D3DFVFCAPS_DONOTSTRIPELEMENTS|
    D3DFVFCAPS_PSIZE| 0,

    // TextureOpCaps
    D3DTEXOPCAPS_DISABLE| D3DTEXOPCAPS_SELECTARG1| D3DTEXOPCAPS_SELECTARG2|
    D3DTEXOPCAPS_MODULATE| D3DTEXOPCAPS_MODULATE2X| 
    D3DTEXOPCAPS_MODULATE4X| D3DTEXOPCAPS_ADD| D3DTEXOPCAPS_ADDSIGNED| 
    D3DTEXOPCAPS_ADDSIGNED2X| D3DTEXOPCAPS_SUBTRACT|
    D3DTEXOPCAPS_ADDSMOOTH| D3DTEXOPCAPS_BLENDDIFFUSEALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHA| D3DTEXOPCAPS_BLENDFACTORALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHAPM| D3DTEXOPCAPS_BLENDCURRENTALPHA|
    D3DTEXOPCAPS_PREMODULATE| D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA|
    D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA| D3DTEXOPCAPS_BUMPENVMAP|
    D3DTEXOPCAPS_BUMPENVMAPLUMINANCE| D3DTEXOPCAPS_DOTPRODUCT3|
    D3DTEXOPCAPS_MULTIPLYADD| D3DTEXOPCAPS_LERP| 0,
    
    // Max Texture Blend Stages, Simulatenous Textures
    D3DHAL_TSS_MAXSTAGES, D3DHAL_TSS_MAXSTAGES,

    // Vertex Processing Caps
    /*D3DVTXPCAPS_TEXGEN| D3DVTXPCAPS_MATERIALSOURCE7|
    D3DVTXPCAPS_DIRECTIONALLIGHTS| D3DVTXPCAPS_POSITIONALLIGHTS|
    D3DVTXPCAPS_LOCALVIEWER| D3DVTXPCAPS_TWEENING|*/ 0,

    // Max Active Lights, User Clip Planes, Vertex Blend Matrices
    0, 0, 0, 

    // Max Vertex Blend Matrix Index, Point Size, Primitive Count
    0, 1.0f, 0xFFFFFFFF,

    // Max Vertex Index, Streams, Stream Stride,
    0xFFFFFFFF, 1, 256,

    // Vertex Shader version, Max Vertex Shader Const
    D3DVS_VERSION(0,0), 0,

    // Pixel Shader version, Max Pixel Shader Value
    D3DPS_VERSION(1,0), 16.0f,
};

const CMyDriver::CSurfaceCapWrap CMyDriver::c_aSurfaces[]=
{
    // Tex, VTex, CTex, OffSTarg, SameFmtTarg, Z/S, Z/SWColor, SameFmtToA, 3D
    CSurfaceCapWrap( D3DFMT_A4R4G4B4,
        true, false, false, false, false, false, false, false, false),
    CSurfaceCapWrap( D3DFMT_R5G6B5,
        true, false, false, false, false, false, false, false, false),
    CSurfaceCapWrap( D3DFMT_A8R8G8B8,
        true, false, false, true, true, false, false, false, true),
    CSurfaceCapWrap( D3DFMT_X8R8G8B8,
        true, false, false, true, true, false, false, false, true),
    CSurfaceCapWrap( D3DFMT_D16_LOCKABLE,
        false, false, false, false, false, true, true, false, false),
/*    CSurfaceCapWrap( D3DFMT_D32,
        false, false, false, false, false, true, true, false, false),*/
};

CMyDriver::CMyDriver():
    CMinimalDriver< CMyDriver, CMyRasterizer>( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0]))
{
}
/*
const CMyContext::TDP2CmdBind CMyContext::c_aDP2Bindings[]=
{
    TDP2CmdBind( D3DDP2OP_VIEWPORTINFO,      DP2ViewportInfo),
    TDP2CmdBind( D3DDP2OP_WINFO,             DP2WInfo),
    TDP2CmdBind( D3DDP2OP_RENDERSTATE,       DP2RenderState),
    TDP2CmdBind( D3DDP2OP_TEXTURESTAGESTATE, DP2TextureStageState),
    TDP2CmdBind( D3DDP2OP_CLEAR,             DP2Clear),
    TDP2CmdBind( D3DDP2OP_SETVERTEXSHADER,   DP2SetVertexShader),
    TDP2CmdBind( D3DDP2OP_SETSTREAMSOURCE,   DP2SetStreamSource),
    TDP2CmdBind( D3DDP2OP_SETINDICES,        DP2SetIndices),
    TDP2CmdBind( D3DDP2OP_DRAWPRIMITIVE2,    DP2DrawPrimitive2),
    TDP2CmdBind( D3DDP2OP_DRAWPRIMITIVE,     DP2DrawPrimitive),
    TDP2CmdBind( D3DDP2OP_SETRENDERTARGET,   DP2SetRenderTarget)
};

const CMyContext::TDP2CmdBind* CMyContext::GetDP2Bindings( unsigned int& iBindings)
{
    iBindings= sizeof(c_aDP2Bindings)/ sizeof(c_aDP2Bindings[0]);
    return c_aDP2Bindings;
}

HRESULT CMyContext::DP2DrawPrimitive( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
    const void* pP)
{
    const D3DHAL_DP2DRAWPRIMITIVE* pParam=
        reinterpret_cast< const D3DHAL_DP2DRAWPRIMITIVE*>(pP);

    const D3DHAL_DP2VIEWPORTINFO& ViewportInfo= (*this);
    const D3DHAL_DP2VERTEXSHADER& VertexShader= (*this);
    const D3DHAL_DP2SETSTREAMSOURCE& StreamSource= (*this);
    const D3DHAL_DP2SETINDICES& Indices= (*this);

    LPDDRAWI_DDRAWSURFACE_LCL pVBuffer= m_pGblDriver->SurfaceDBFind(
        m_pAssociatedDDraw, StreamSource.dwVBHandle);
    assert( pVBuffer!= NULL);

    if((VertexShader.dwHandle& D3DFVF_POSITION_MASK)!= D3DFVF_XYZRHW)
        return D3DERR_COMMAND_UNPARSED;

    const UINT8* pData= reinterpret_cast< const UINT8*>(
        pVBuffer->lpGbl->fpVidMem);
    pData+= pParam->VStart* StreamSource.dwStride;

    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
    if( wPrimitiveCount) do
    {
        assert( pParam->primType== D3DPT_TRIANGLELIST);

        DWORD dwPrimCount( pParam->PrimitiveCount);
        if( dwPrimCount) do
        {
            const float* pfXYZ= reinterpret_cast<const float*>(pData);
            int iX( pfXYZ[0]);
            int iY( pfXYZ[1]);

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

        } while( --dwPrimCount);

        pParam++;
    } while( --wPrimitiveCount);

    return DD_OK;
}

HRESULT CMyContext::DP2DrawPrimitive2( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
    const void* pP)
{
    const D3DHAL_DP2DRAWPRIMITIVE2* pParam=
        reinterpret_cast< const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);

    const D3DHAL_DP2VIEWPORTINFO& ViewportInfo= (*this);
    const D3DHAL_DP2VERTEXSHADER& VertexShader= (*this);
    const D3DHAL_DP2SETSTREAMSOURCE& StreamSource= (*this);
    const D3DHAL_DP2SETINDICES& Indices= (*this);

    LPDDRAWI_DDRAWSURFACE_LCL pVBuffer= m_pGblDriver->SurfaceDBFind(
        m_pAssociatedDDraw, StreamSource.dwVBHandle);
    assert( pVBuffer!= NULL);

    assert((VertexShader.dwHandle& D3DFVF_POSITION_MASK)== D3DFVF_XYZRHW);

    const UINT8* pData= reinterpret_cast< const UINT8*>(
        pVBuffer->lpGbl->fpVidMem);
    pData+= pParam->FirstVertexOffset;

    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
    if( wPrimitiveCount) do
    {
        assert( pParam->primType== D3DPT_TRIANGLELIST);

        DWORD dwPrimCount( pParam->PrimitiveCount);
        if( dwPrimCount) do
        {
            const float* pfXYZ= reinterpret_cast<const float*>(pData);
            int iX( pfXYZ[0]);
            int iY( pfXYZ[1]);

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

        } while( --dwPrimCount);

        pParam++;
    } while( --wPrimitiveCount);

    return DD_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\sample\sources.inc ===
!INCLUDE ..\..\swrast.inc

# Standard sources.inc stuff
MAJORCOMP=d3d
MINORCOMP=d3d8
TARGETNAME=samplesw
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup

# .def (Exports) file built from .src file
DLLDEF=$O\samplesw.def

# Do we need this? On for Multi-processor build safety.
# SYNCHRONIZE_DRAIN=1

# Use C++ exception handling for now, so we can rapidly build with STL
USE_NATIVE_EH=1

# Shell Team indicates MSVCRT should be used.
USE_MSVCRT=1

!IF "$(NTDEBUG)" == "ntsd"
DEBUG_CRTS=1
!ENDIF

# We need notably <ddraw.h>, <ddrawi.h>, <d3dhal.h>, & <d3d8ddi.h>
# This could be cleaned up. The interface is not available to the public,
# so the files needed shouldn't be in public, but some directories seem too "private".
# See the precompiled header for concrete listing of files.
INCLUDES = ..\;$(INCLUDES)

PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_CXX=1

TARGETLIBS = \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\winmm.lib \
	$(SDK_LIB_PATH)\msvcprt.lib \
	$(SDK_LIB_PATH)\kernel32.lib


SOURCES = \
	..\SampleSW.cpp \
	..\Main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\choosecolorobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       choosecolorobj.h
//
//--------------------------------------------------------------------------

// ChooseColorObj.h : Declaration of the CChooseColorObject


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CChooseColorObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IChooseColor, &IID_IChooseColor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IChooseColor,
#endif
	public CComObjectBase<&CLSID_ChooseColor>
{
public:
	CChooseColorObject() ;
BEGIN_COM_MAP(CChooseColorObject)
	COM_INTERFACE_ENTRY(IChooseColor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CChooseColorObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CChooseColorObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// IChooseColor
public:
	STDMETHOD(setOwner)(long hwnd);
	STDMETHOD(setInitialColor)(COLORREF c);
	STDMETHOD(setFlags)(long flags);
	STDMETHOD(show)(int *selected);
	STDMETHOD(getColor)(COLORREF *c);
private:
	HWND m_hwnd;
	COLORREF m_color;
	DWORD m_flags;
	BOOL m_completed;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3d7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.cpp
//
//--------------------------------------------------------------------------

// d3dObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "d3dEnumDevices7Obj.h"
#include "ddSurface7Obj.h"
#include "D3DEnumPixelFormats7Obj.h"
#include "d3dVertexBuffer7Obj.h"
#include "dDraw7Obj.h"

typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID);


C_dxj_Direct3d7Object::C_dxj_Direct3d7Object(){
	m__dxj_Direct3d7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3d3[%d] \n ",g_creationcount);
	
	nextobj =  g_dxj_Direct3d7;
	g_dxj_Direct3d7 = (void *)this;
}


C_dxj_Direct3d7Object::~C_dxj_Direct3d7Object()
{
    C_dxj_Direct3d7Object *prev=NULL; 
	for(C_dxj_Direct3d7Object *ptr=(C_dxj_Direct3d7Object *)g_dxj_Direct3d7; ptr; ptr=(C_dxj_Direct3d7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3d7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3d7){
		int count = IUNK(m__dxj_Direct3d7)->Release();
		
		DPF1(1,"DirectX IDirect3d7 Ref count [%d] \n",count);
		

		if(count==0) m__dxj_Direct3d7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}



DWORD C_dxj_Direct3d7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3d3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3d7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3d7 [%d] Release %d \n",creationid,i);
	return i;
}


GETSET_OBJECT(_dxj_Direct3d7);

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::findDevice(D3dFindDeviceSearch *ds, D3dFindDeviceResult7 *dr )
{
	HRESULT hr;
	
	


	//Fixup FindDeviceSearch
	ds->lSize  = sizeof(D3DFINDDEVICESEARCH);
	ds->dpcPrimCaps.lSize =sizeof(D3DPRIMCAPS);		
	ZeroMemory((LPGUID)&(ds->guidStruct),sizeof(GUID));
	hr=BSTRtoGUID((LPGUID)&(ds->guidStruct), ds->strGuid);

	//if FAILED(hr) return E_INVALIDARG;
	
	//Fixup FindDeviceResult
	memset(dr,0,sizeof(D3DFINDDEVICERESULT7));
	dr->lSize = sizeof(D3DFINDDEVICERESULT7);
	dr->ddHwDesc.lSize=sizeof(D3DDEVICEDESC7);
	dr->ddSwDesc.lSize=sizeof(D3DDEVICEDESC7);
	


	// NOTE THE TOP PORTIONS OF D3dFindDeviceSearch and D3dFindDeviceResult
	// are the same As D3DFINDEVICSEARCH and D3DFINDRESULT
	// 
	hr = m__dxj_Direct3d7->FindDevice((D3DFINDDEVICESEARCH*)ds, (D3DFINDDEVICERESULT7*)dr);

	dr->strGuid=D3DGUIDtoBSTR((LPGUID) &(dr->guidStruct));
		
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDevicesEnum(I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr=E_FAIL;
	hr=C_dxj_Direct3DEnumDevices7Object::create(m__dxj_Direct3d7,ppRet);

	return hr;
}

//TODO tighter code produced if made into an inline function
//and use a for loop to compare byte by byte
#define GUIDISEQUAL(a,b) \
	((((DxGuid *)a)->data1==((DxGuid *)b)->data1) && \
	(((DxGuid *)a)->data2==((DxGuid *)b)->data2) && \
	(((DxGuid *)a)->data3==((DxGuid *)b)->data3) && \
	(((DxGuid *)a)->data4[0]==((DxGuid *)b)->data4[0]) && \
	(((DxGuid *)a)->data4[1]==((DxGuid *)b)->data4[1]) && \
	(((DxGuid *)a)->data4[2]==((DxGuid *)b)->data4[2]) && \
	(((DxGuid *)a)->data4[3]==((DxGuid *)b)->data4[3]) && \
	(((DxGuid *)a)->data4[4]==((DxGuid *)b)->data4[4]) && \
	(((DxGuid *)a)->data4[5]==((DxGuid *)b)->data4[5]) && \
	(((DxGuid *)a)->data4[6]==((DxGuid *)b)->data4[6]) && \
	(((DxGuid *)a)->data4[7]==((DxGuid *)b)->data4[7])) 




		
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::createDevice(BSTR strClsid, I_dxj_DirectDrawSurface7 *surf,I_dxj_Direct3dDevice7 **retv)
{
	LPDIRECT3DDEVICE7 lpNew=NULL;
	HRESULT hr;

	GUID clsid;

	hr=D3DBSTRtoGUID(&clsid,strClsid);
	if FAILED(hr) return E_INVALIDARG;

	
	//CreateDevice wants a DirectDrawSurface as opposed to 
	//a DirectDrawSurface3 . we implement as cast
	//cause DX allows us to.
	//Consider - Is the cost of a QI call really to much?
	//AK

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpSurf, surf);
	

	hr=m__dxj_Direct3d7->CreateDevice(clsid,  lpSurf,  &lpNew);

	if FAILED(hr) return hr;
 
	//INTERNAL_CREATE(_dxj_Direct3dDevice3, lpNew, retv);
	INTERNAL_CREATE_2REFS(_dxj_Direct3dDevice7,_dxj_DirectDrawSurface7,surf, lpNew,retv) 
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDirectDraw(I_dxj_DirectDraw7 **retv)
{
	IDirectDraw7 *pdd7;
	HRESULT hr;
	hr=m__dxj_Direct3d7->QueryInterface(IID_IDirectDraw7,(void**)&pdd7);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectDraw7, pdd7, retv);
        
	return hr; 
}


STDMETHODIMP C_dxj_Direct3d7Object::createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f)
{
 
	LPDIRECT3DVERTEXBUFFER7 pBuff=NULL;
	HRESULT hr;
	
	if (!desc) return E_INVALIDARG;
	desc->lSize=sizeof(D3DVERTEXBUFFERDESC);

	hr=m__dxj_Direct3d7->CreateVertexBuffer((LPD3DVERTEXBUFFERDESC) desc,
				&pBuff,
				(DWORD)flags
				);

	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dVertexBuffer7, pBuff, f);


	DWORD fvf=(DWORD)desc->lFVF;
	long  n=0;

	if (fvf == D3DFVF_VERTEX)  n=sizeof(D3DVERTEX);
	else if (fvf == D3DFVF_LVERTEX)  n=sizeof(D3DLVERTEX);
	else if (fvf == D3DFVF_TLVERTEX)  n=sizeof(D3DLVERTEX);
	else 
	{
	 	if (fvf & D3DFVF_DIFFUSE ) n=n+sizeof(DWORD);
		if (fvf & D3DFVF_SPECULAR ) n=n+sizeof(DWORD);	
		if (fvf & D3DFVF_NORMAL  ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZ   ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZRHW    ) n=n+sizeof(float)*4;
		if (fvf & D3DFVF_TEX0 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX1 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX2 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX3 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX4 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX5 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX6 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX7 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX8 	    ) n=n+sizeof(float)*2;
	}

	(*f)->setVertexSize(n);

	return S_OK;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval)
{
		
	HRESULT  hr=C_dxj_Direct3DEnumPixelFormats7Object::create2(m__dxj_Direct3d7, guid, retval);
	return hr;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::evictManagedTextures( void)
{
	HRESULT hr;
	hr=m__dxj_Direct3d7->EvictManagedTextures();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3d7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.h
//
//--------------------------------------------------------------------------

// d3dObj.h : Declaration of the C_dxj_Direct3dObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3d7 LPDIRECT3D7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3d7Object : 
	public I_dxj_Direct3d7,
	//public CComCoClass<C_dxj_Direct3d7Object, &CLSID__dxj_Direct3d7>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3d7Object() ;
	virtual ~C_dxj_Direct3d7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3d7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3d7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3d7,				"DIRECT.Direct3d.3",                "DIRECT.Direct3d7.3",				IDS_D3D_DESC,				THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3d7Object)

// I_dxj_Direct3d
public:
		 //UPDATED
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            I_dxj_DirectDrawSurface7 __RPC_FAR *surf,
            /* [retval][out] */ I_dxj_Direct3dDevice7 __RPC_FAR *__RPC_FAR *ret);
        
     //   HRESULT STDMETHODCALLTYPE createTexture( 
     //       /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
     //       /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE evictManagedTextures( void);
        
       // HRESULT STDMETHODCALLTYPE findDevice( 
       //     /* [in] */ D3dFindDeviceSearch __RPC_FAR *ds,
       //     /* [out][in] */ D3dFindDeviceResult7 __RPC_FAR *findresult);
        
        HRESULT STDMETHODCALLTYPE getDevicesEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumDevices __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retv);       
			

private:
    DECL_VARIABLE(_dxj_Direct3d7);


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3d7 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\sample\samplesw.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// forward declaration
class CMyRasterizer;

////////////////////////////////////////////////////////////////////////////////
//
// CMyDriver
//
////////////////////////////////////////////////////////////////////////////////
class CMyDriver:
    public CMinimalDriver< CMyDriver, CMyRasterizer>
{
private:
    static const CSurfaceCapWrap c_aSurfaces[];
    static const D3DCAPS8 c_D3DCaps;

protected:

public:
    CMyDriver();
    ~CMyDriver()
    { }

    static const D3DCAPS8 GetCaps( void)
    { return c_D3DCaps; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CMyRasterizer
//
////////////////////////////////////////////////////////////////////////////////
class CMyRasterizer
{
public: // Types
    typedef CMyDriver::TContext TContext;

protected:
    int m_iVal;

public:
    CMyRasterizer() { }
    ~CMyRasterizer() { }

    HRESULT DrawPrimitive( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWPRIMITIVE* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_DP2DRAWPRIMITIVE* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->VStart* dwVStride;

                DrawOnePrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawPrimitive2( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWPRIMITIVE2* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_DP2DRAWPRIMITIVE2* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                DrawOnePrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawIndexedPrimitive( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* aDP2Param)
    {
        // Context can be converted to these structures.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        UINT16* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0= Context.GetVStream( 0);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        TContext::TIStream& IStream= Context.GetIStream( 0);
        if( IStream.GetMemLocation()== TContext::TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TContext::TIStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT16*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

		if( pStartVData!= NULL&& pStartIData!= NULL)
        {
            // Sample should've marked caps as only supporting 16-bit indices.
            assert( sizeof(UINT16)== dwIStride);

            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->BaseVertexIndex* dwVStride;
                const UINT16* pIData= pStartIData+ pParam->StartIndex; //* dwIStride;

                DrawOneIPrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF, pIData);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawIndexedPrimitive2( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* aDP2Param)
    {
        // Context can be converted to these structures.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        UINT16* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        TContext::TIStream& IStream= Context.GetIStream( 0);
        if( IStream.GetMemLocation()== TContext::TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TContext::TIStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT16*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

		if( pStartVData!= NULL&& pStartIData!= NULL)
        {
            // Sample should've marked caps as only supporting 16-bit indices.
            assert( sizeof(UINT16)== dwIStride);

            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->BaseVertexOffset;
                const UINT16* pIData= reinterpret_cast< const UINT16*>(
                    pStartIData+ pParam->StartIndexOffset);

                DrawOneIPrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF, pIData);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT ClippedTriangleFan( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_CLIPPEDTRIANGLEFAN* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                // Must use pParam->dwEdgeFlags for correct drawing of wireframe.
                if( Context.GetRenderStateDW( D3DRS_FILLMODE)!= D3DFILL_WIREFRAME)
                    DrawOnePrimitive( Context, D3DPT_TRIANGLEFAN,
                        pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                else
                    assert( false); // NYI

                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }

    void DrawOnePrimitive( TContext& Context, D3DPRIMITIVETYPE primType,
        WORD wPrims, const UINT8* pVData, DWORD dwVStride, DWORD dwFVF)
    { }
    void DrawOneIPrimitive( TContext& Context, D3DPRIMITIVETYPE primType,
        WORD wPrims, const UINT8* pVData, DWORD dwVStride, DWORD dwFVF,
        const UINT16* pIData)
    { }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3ddevice7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "ddSurface7Obj.h"
#include "d3dEnumPixelFormats7Obj.h"

extern BSTR D3DGUIDtoBSTR(LPGUID);


//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::C_dxj_Direct3dDevice7Object(){
	m__dxj_Direct3dDevice7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;
	DPF1(1,"Constructor Creation  Direct3dDevice7[%d] \n",g_creationcount);
	

	nextobj =  g_dxj_Direct3dDevice7;
	g_dxj_Direct3dDevice7 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::~C_dxj_Direct3dDevice7Object()
{
    C_dxj_Direct3dDevice7Object *prev=NULL; 
	for(C_dxj_Direct3dDevice7Object *ptr=(C_dxj_Direct3dDevice7Object *)g_dxj_Direct3dDevice7; ptr; ptr=(C_dxj_Direct3dDevice7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice7){
		int count = IUNK(m__dxj_Direct3dDevice7)->Release();
		
		DPF1(1, "DirectX IDirect3dDevice7 Ref count [%d] \n",count);

		if(count==0) m__dxj_Direct3dDevice7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
	
	parent=NULL;
	parent2=NULL;
}


///////////////// /////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dDevice7[%d] AddRef %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(szBuf,"Direct3dDevice7 [%d] Release %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice7);

//////////////////////////////////////////////////////////////////
// beginScene
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getLightState
// getRenderState
//////////////////////////////////////////////////////////////////
PASS_THROUGH_R(_dxj_Direct3dDevice7, beginScene, BeginScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));

//////////////////////////////////////////////////////////////////
// endScene
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::endScene()
{

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->EndScene();


	#ifdef _X86_
		_asm FINIT
	#endif
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderTarget(I_dxj_DirectDrawSurface7 **ppsurf)
{	

	LPDIRECTDRAWSURFACE7	lpSurf=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetRenderTarget(&lpSurf);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice7->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}


//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderTarget(I_dxj_DirectDrawSurface7 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpref, surf);
	hr= m__dxj_Direct3dDevice7->SetRenderTarget(lpref,0);
	return hr;
}
		




//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureFormatsEnum(I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_Direct3DEnumPixelFormats7Object::create1(m__dxj_Direct3dDevice7,ppRet);
	return hr;
}





//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice7->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECTDRAWSURFACE7 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice7->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTexture( 
             long stage,
             I_dxj_DirectDrawSurface7  *tex)
{
	
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpTex, tex);	
	hr=m__dxj_Direct3dDevice7->SetTexture((DWORD)stage,lpTex);

	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getCaps( 
            D3dDeviceDesc7 *a)
{
	//if (a) a->lSize=sizeof(D3DDEVICEDESC7);
	

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetCaps((D3DDEVICEDESC7*)a);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDirect3D( I_dxj_Direct3d7 **ret)
{

	HRESULT hr;
	LPDIRECT3D7 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice7->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d7,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// setMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}



//////////////////////////////////////////////////////////////////
// setLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}


//////////////////////////////////////////////////////////////////
// beginStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::beginStateBlock()
{

	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->BeginStateBlock();		
	return hr;

}

//////////////////////////////////////////////////////////////////
// endStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::endStateBlock( long *retv)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->EndStateBlock((DWORD*)retv);		
	return hr;
}


//////////////////////////////////////////////////////////////////
// deleteStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::deleteStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->DeleteStateBlock((DWORD)m);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// ApplyStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::applyStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->ApplyStateBlock((DWORD)m);		
	return hr;
}

//////////////////////////////////////////////////////////////////
// createStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::createStateBlock(long type, long *retval)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CreateStateBlock((D3DSTATEBLOCKTYPE)type,(DWORD*)retval);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// captureStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::captureStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CaptureStateBlock((DWORD)m);		
	return hr;
}
    


//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::lightEnable( long index,  VARIANT_BOOL b){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->LightEnable((DWORD)index,(b!=VARIANT_FALSE));
	return hr;
}

//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLightEnable( long index,  VARIANT_BOOL *bOut){
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_Direct3dDevice7->GetLightEnable((DWORD)index,&b);
	if (b){
		*bOut=VARIANT_TRUE;
	}
	else {
		*bOut=VARIANT_FALSE;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice7->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear(long count,SAFEARRAY **psa, long flags, long color, float z, long stencil )
{		 	
	if (!ISSAFEARRAY1D(psa,(DWORD)count)) return E_INVALIDARG;		
	return m__dxj_Direct3dDevice7->Clear( (DWORD)count,(D3DRECT*)((SAFEARRAY*)*psa)->pvData, flags ,color,z,stencil); 
}


//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice7->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
					   long startIndex,
					   long numIndex,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startIndex,
			(DWORD) numIndex,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}


STDMETHODIMP C_dxj_Direct3dDevice7Object::preLoad( I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(  LPDIRECTDRAWSURFACE7 , lpSurf, surf);
	hr= m__dxj_Direct3dDevice7->PreLoad(lpSurf);
	return hr;
}



//////////////////////////////////////////////////////////////////
// load
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex1,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex2,
            /* [in] */ Rect __RPC_FAR *rc,
            /* [in] */ long flags)
{
	HRESULT hr;	
	
	if (!tex1) return E_INVALIDARG;
	if (!tex2) return E_INVALIDARG;
	if (!rc) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex1,tex1);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex2,tex2);

	//dont allow this as it gpfs some drivers and is invalid anyway
	if (lpTex1==lpTex2) return E_INVALIDARG;

	POINT p;
	p.x=x;
	p.y=y;

	hr=m__dxj_Direct3dDevice7->Load(lpTex1,&p,lpTex2,(LPRECT)rc,(DWORD)flags);

	return hr;
}


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));


//////////////////////////////////////////////////////////////////
// setRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->SetRenderState((D3DRENDERSTATETYPE) renderstate, *((DWORD*)&val));
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float *val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->GetRenderState((D3DRENDERSTATETYPE) renderstate, (DWORD*)val);
	return hr;
}



//////////////////////////////////////////////////////////////////
// setTextureStageStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float val)
{
	HRESULT hr;
	 
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, *((DWORD*)&val));
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getInfo
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getInfo( 
            /* [in] */ long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */ long lSize)
{
	HRESULT hr;
	__try 
	{
		hr=m__dxj_Direct3dDevice7->GetInfo((DWORD)lDevInfoID,DevInfoType, (DWORD)lSize);
	}
	__except(1,1)
	{
		return E_FAIL;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDeviceGuid
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDeviceGuid( BSTR *ret)
{
	HRESULT hr;
	D3DDEVICEDESC7 desc;
	
	if (!ret) return E_INVALIDARG;

	//desc.dwSize=sizeof(D3DDEVICEDESC7);
		
	hr=m__dxj_Direct3dDevice7->GetCaps(&desc);
	if FAILED(hr) return hr;


	*ret=D3DGUIDtoBSTR(&desc.deviceGUID);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::setClipPlane(long index,float A, float B, float C, float D)
{
    HRESULT hr;		
    float floats[4];
    
    floats[0]=A;
    floats[1]=B;
    floats[2]=C;
    floats[3]=D;

	hr=m__dxj_Direct3dDevice7->SetClipPlane((DWORD)index, floats);

	return hr;

}

//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getClipPlane(long index,float *A, float *B, float *C, float *D)
{
    HRESULT hr;		
    float floats[4];
    
	hr=m__dxj_Direct3dDevice7->GetClipPlane((DWORD)index, floats);
    if FAILED(hr) return hr;
    
    *A=floats[0];
    *B=floats[1];
    *C=floats[2];
    *D=floats[3];

	return hr;

}


        
#if 0 
//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear( 
            /* [in] */ long l1,
            /* [in] */ D3dRect __RPC_FAR *rc,
            /* [in] */ long l2,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long l3)
{
	HRESULT hr;
	if (!rc) return E_INVALIDARG;
	__try{
		hr=m__dxj_Direct3dDevice7->Clear((DWORD)l1,(D3DRECT*)rc,(DWORD)l2,(DWORD)color,(float)z,(DWORD)l3);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////////////
// setVertexComponent
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setVertexComponent(  
  		    /* [in] */ long __RPC_FAR component,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vb,
            /* [in] */ long l1,
            /* [in] */ long l2)
{
	HRESULT hr;
	if (!vb) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVERTEXBUFFER7,pVB,vb);

	hr=m__dxj_Direct3dDevice7->SetVertexComponent((D3DVERTEXCOMPONENT)component, pVB,(DWORD)l1,(DWORD)l2);
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3ddevice7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice7 LPDIRECT3DDEVICE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice7Object : 
        public I_dxj_Direct3dDevice7,
		//public CComCoClass<C_dxj_Direct3dDevice7Object, &CLSID__dxj_Direct3dDevice7>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice7Object();
        virtual ~C_dxj_Direct3dDevice7Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice7Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice7,			"DIRECT.Direct3dDevice7.3",          "DIRECT.Direct3dDevice7.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice7Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
          HRESULT STDMETHODCALLTYPE applyStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE beginScene( void);
        
          HRESULT STDMETHODCALLTYPE beginStateBlock( void);
        
          HRESULT STDMETHODCALLTYPE captureStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *recs,
            /* [in] */ long flags,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long stencil);
        
          HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radius,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
          HRESULT STDMETHODCALLTYPE deleteStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
                  
          HRESULT STDMETHODCALLTYPE endScene( void);
        
          HRESULT STDMETHODCALLTYPE endStateBlock( 
            /* [in] */ long __RPC_FAR *blockHandle);
        
          HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *desc);
        
          HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *dev);
        
          HRESULT STDMETHODCALLTYPE getLight( 
            /* [in] */ long LightIndex,
            /* [out][in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE getLightEnable( 
            /* [in] */ long LightIndex,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
          HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [out][in] */ D3dMaterial7 __RPC_FAR *Material);
        
          HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
          HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppval);
        
          HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
          HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
          HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *val);
        
          HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE getViewport( 
            /* [out][in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE lightEnable( 
            /* [in] */ long LightIndex,
            /* [in] */ VARIANT_BOOL b);
        
          HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *DestTex,
            /* [in] */ long xDest,
            /* [in] */ long yDest,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *SrcTex,
            /* [in] */ Rect __RPC_FAR *rcSrcRect,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
        
          HRESULT STDMETHODCALLTYPE preLoad( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surf);
        
          HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE setLight( 
            /* [in] */ long LightIndex,
            /* [in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ D3dMaterial7 __RPC_FAR *mat);
        
          HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ long renderstate);
        
          HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surface);
        
          HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *texture);
        
          HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);
        
          HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE setViewport( 
            /* [in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
   

          HRESULT STDMETHODCALLTYPE setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float value);
        
          HRESULT STDMETHODCALLTYPE getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *value);



		HRESULT STDMETHODCALLTYPE getInfo (             
            /* [in] */		long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */		long lSize);


        HRESULT STDMETHODCALLTYPE setRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float renderstate);

        HRESULT STDMETHODCALLTYPE getRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float *renderstate);



		HRESULT STDMETHODCALLTYPE	getDeviceGuid( 
			/* [out,retval] */	BSTR *ret);


		HRESULT STDMETHODCALLTYPE createStateBlock( long flags, long *retv);

        HRESULT STDMETHODCALLTYPE setClipPlane( long index, float A, float B, float C, float D);

        HRESULT STDMETHODCALLTYPE getClipPlane( long index, float *A, float *B, float *C, float *D);


////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice7)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumdevices7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.cpp
//
//--------------------------------------------------------------------------

 
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumDevices7Obj.h"

extern  BSTR D3DGUIDtoBSTR(LPGUID pGuid);




/////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumDevices7Callback(
						LPSTR DevDesc,
						LPSTR DevName, 
						LPD3DDEVICEDESC7 lpD3DDevDesc,
						void *lpArg)
{

	C_dxj_Direct3DEnumDevices7Object *pObj=(C_dxj_Direct3DEnumDevices7Object*)lpArg;
	if (pObj==NULL) return D3DENUMRET_OK;
	

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
			if (tmp != NULL)
				pObj->m_pList = (DxDriverInfo*)tmp;
			else
				return D3DENUMRET_CANCEL;
		}
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);


		if (pObj->m_pListHW)
		{
			void* tmpHw = realloc(pObj->m_pListHW,sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
			if (tmpHw)
				pObj->m_pListHW = (D3DDEVICEDESC7*)tmpHw;
			else
				return D3DENUMRET_CANCEL;
		}
		else
			pObj->m_pListHW=(D3DDEVICEDESC7*)malloc(sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		

	}

	//Fix for Whistler 45161
	//NOTE no way to get out of memory error back to user.
	//so we just return what we can.
	if (!pObj->m_pList) 	return D3DENUMRET_CANCEL;
	if (!pObj->m_pListHW)
	{
		free(pObj->m_pList);
		return D3DENUMRET_CANCEL;
	}
	
	
	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=D3DGUIDtoBSTR(&(lpD3DDevDesc->deviceGUID));
	
	if (DevDesc!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(DevDesc);
	}
	if (DevName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(DevName);
	}

	ZeroMemory(&(pObj->m_pListHW[pObj->m_nCount]),sizeof(D3DDEVICEDESC7));
	
	
	if (lpD3DDevDesc){
		memcpy(&(pObj->m_pListHW[pObj->m_nCount]),lpD3DDevDesc,sizeof(D3DDEVICEDESC7));
	}
	

	pObj->m_nCount++;
	
	return D3DENUMRET_OK;
}


C_dxj_Direct3DEnumDevices7Object::C_dxj_Direct3DEnumDevices7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pListHW=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumDevices7Object::~C_dxj_Direct3DEnumDevices7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString((BSTR)m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString((BSTR)m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString((BSTR)m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D,I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumDevices7Object *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_Direct3DEnumDevices7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pD3D->EnumDevices(objEnumDevices7Callback, (void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		if (pNew->m_pListHW) free(pNew->m_pListHW);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumDevices,(void**)ppRet);
	return hr;
}


        
HRESULT C_dxj_Direct3DEnumDevices7Object::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_Direct3DEnumDevices7Object::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_Direct3DEnumDevices7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getDesc(long index, D3dDeviceDesc7 *desc)
{
	if (m_pListHW==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(desc,&(m_pListHW[index-1]),sizeof(D3dDeviceDesc7));
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumdevices7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_Direct3DEnumDevices7Object : 
	public I_dxj_Direct3DEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumDevices7Object() ;
	virtual ~C_dxj_Direct3DEnumDevices7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumDevices7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumDevices7Object)

public:
	    HRESULT STDMETHODCALLTYPE getDesc( 
            /* [in] */ long index,
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *hwDesc);
        
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

		static HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D7,I_dxj_Direct3DEnumDevices **ppRet);
		
	
public:
		DxDriverInfo	*m_pList;
		D3DDEVICEDESC7	*m_pListHW;
		
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformats7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_Direct3DEnumPixelFormats7Object : 
	public I_dxj_Direct3DEnumPixelFormats,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumPixelFormats7Object() ;
	virtual ~C_dxj_Direct3DEnumPixelFormats7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumPixelFormats7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumPixelFormats7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformatsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormatsobj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");

	
	C_dxj_D3DEnumPixelFormatsObject *pObj=(C_dxj_D3DEnumPixelFormatsObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_D3DEnumPixelFormatsObject::C_dxj_D3DEnumPixelFormatsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_D3DEnumPixelFormatsObject::~C_dxj_D3DEnumPixelFormatsObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}



#if 0
HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}
#endif


HRESULT C_dxj_D3DEnumPixelFormatsObject::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_D3DEnumPixelFormatsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformats7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormats7obj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");



	
	C_dxj_Direct3DEnumPixelFormats7Object *pObj=(C_dxj_Direct3DEnumPixelFormats7Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DDPIXELFORMAT*)tmp;
			else
				return DDENUMRET_CANCEL;
		}
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_Direct3DEnumPixelFormats7Object::C_dxj_Direct3DEnumPixelFormats7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumPixelFormats7Object::~C_dxj_Direct3DEnumPixelFormats7Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drm3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drm3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drm3Obj.h"

#include "d3drmDeviceArrayObj.h"
#include "d3drmLightObj.h"
#include "d3drmMeshObj.h"
#include "d3drmWrapObj.h"
#include "d3drmVisualObj.h"
#include "d3drmUserVisualObj.h"
#include "d3drmClippedVisualObj.h"
#include "d3drmDevice3Obj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmViewport2Obj.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmFace2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmProgressiveMeshObj.h"

#include "d3drmFrameInterObj.h"
#include "d3drmLightInterObj.h"
#include "d3drmViewportInterObj.h"
#include "d3drmTextureInterObj.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmMeshInterObj.h"

#include "ddSurface7Obj.h"

extern void *g_dxj_Direct3dRMMeshInterpolator;
extern void *g_dxj_Direct3dRMViewportInterpolator;
extern void *g_dxj_Direct3dRMLightInterpolator;
extern void *g_dxj_Direct3dRMFrameInterpolator;
extern void *g_dxj_Direct3dRMMaterialInterpolator;
extern void *g_dxj_Direct3dRMTextureInterpolator;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

#define DO_GETOBJECT_NOTNULL_VISUAL_ADDREF(v,i) LPDIRECT3DRMVISUAL v=NULL; \
	{ IUnknown *pIUnk=NULL; \
	if(i) i->InternalGetObject((IUnknown **)&pIUnk); \
	if (pIUnk) pIUnk->QueryInterface(IID_IDirect3DRMVisual,(void**)&v); \
	}

extern BOOL is4Bit;
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR); 
extern HRESULT BSTRtoGUID(LPGUID,BSTR); 
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR); 
			

C_dxj_Direct3dRM3Object::C_dxj_Direct3dRM3Object(){
	m__dxj_Direct3dRM3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRM2[%d] \n ",g_creationcount);
	nextobj =  g_dxj_Direct3dRM3;
	g_dxj_Direct3dRM3 = (void *)this;
}




C_dxj_Direct3dRM3Object::~C_dxj_Direct3dRM3Object(){

	DPF1(1,"Destructor  Direct3dRM2 [%d] \n",creationid); 
	
	C_dxj_Direct3dRM3Object *prev=NULL; 

	for(C_dxj_Direct3dRM3Object *ptr=(C_dxj_Direct3dRM3Object *)g_dxj_Direct3dRM3;
		ptr;
		ptr=(C_dxj_Direct3dRM3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRM3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRM3){ 
		int count = IUNK(m__dxj_Direct3dRM3)->Release(); 
		DPF1(1,"DirectX real IDirect3dRM2 Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRM3 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
}


#if 0

DWORD C_dxj_Direct3dRM3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"D3DRM3 [%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRM3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();

	DPF1(1,"D3DRM2 [%d] Release %d \n",creationid,i);
	return i;
}

#endif

	GETSET_OBJECT(_dxj_Direct3dRM3);

	PASS_THROUGH1_R(_dxj_Direct3dRM3, setDefaultTextureColors, SetDefaultTextureColors, long)
	PASS_THROUGH1_R(_dxj_Direct3dRM3, setDefaultTextureShades, SetDefaultTextureShades, long)
	PASS_THROUGH1_R(_dxj_Direct3dRM3, tick, Tick, d3dvalue);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createAnimationSet, CreateAnimationSet, _dxj_Direct3dRMAnimationSet2) ;
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createMesh, CreateMesh, _dxj_Direct3dRMMesh);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createFace, CreateFace, _dxj_Direct3dRMFace2);

	//TODO - do we need a new type of device array
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createAnimation, CreateAnimation, _dxj_Direct3dRMAnimation2);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createMeshBuilder, CreateMeshBuilder, _dxj_Direct3dRMMeshBuilder3);
	RETURN_NEW_ITEM1_R(_dxj_Direct3dRM3,createMaterial,CreateMaterial,_dxj_Direct3dRMMaterial2,d3dvalue);
	RETURN_NEW_ITEM_CAST_2_R(_dxj_Direct3dRM3, createLight,CreateLight,_dxj_Direct3dRMLight, d3drmLightType, (enum _D3DRMLIGHTTYPE), d3dcolor, (d3dcolor));




	//TOEXPAND
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, getDevices, GetDevices, _dxj_Direct3dRMDeviceArray);	



STDMETHODIMP C_dxj_Direct3dRM3Object::createTextureFromSurface(I_dxj_DirectDrawSurface4 *dds, I_dxj_Direct3dRMTexture3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMTEXTURE3 lpTex;
	LPDIRECTDRAWSURFACE lpDDS=NULL;
	if ( is4Bit )
		return E_FAIL;

	if ( dds == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpDDS4, dds);
	hretval= lpDDS4->QueryInterface(IID_IDirectDrawSurface,(void**)&lpDDS);
	if FAILED(hretval) return hretval;
	

	hretval = m__dxj_Direct3dRM3->CreateTextureFromSurface(lpDDS, &lpTex);
	if (lpDDS) lpDDS->Release();
	if FAILED(hretval) 	return hretval;
	

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpTex, retval);
	return S_OK;
}

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromD3D(I_dxj_Direct3d3 *d3d, I_dxj_Direct3dDevice3* d3dDev, I_dxj_Direct3dRMDevice3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMDEVICE3 lpDev;
	LPDIRECT3D2 lpD3D2;
	LPDIRECT3DDEVICE2 lpD3DDev2;

	if ( is4Bit )
		return E_FAIL;

	if ( d3d == NULL || d3dDev == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3D3, lpD3D3, d3d);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DDEVICE3, lpD3DDev3, d3dDev);
	
	hretval=lpD3D3->QueryInterface(IID_IDirect3D2,(void**)&lpD3D2);
	if FAILED(hretval) return hretval;

	hretval=lpD3DDev3->QueryInterface(IID_IDirect3DDevice2,(void**)&lpD3DDev2);
	if FAILED(hretval) return hretval;


	hretval = m__dxj_Direct3dRM3->CreateDeviceFromD3D(lpD3D2, lpD3DDev2, &lpDev);
	
	lpD3DDev2->Release();
	lpD3D2->Release();

	if FAILED(hretval)	return hretval;			
		

	//we need to parent the dev to the d3ddevice object.

	//INTERNAL_CREATE(_dxj_Direct3dRMDevice3, lpDev, retval);
	INTERNAL_CREATE_1REFS(_dxj_Direct3dRMDevice3, _dxj_Direct3dDevice3, d3dDev,lpDev, retval);
	
	return S_OK;
}

#endif 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromSurface(BSTR guid, I_dxj_DirectDraw4 *dd,  I_dxj_DirectDrawSurface4 *dds,long flags,I_dxj_Direct3dRMDevice3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMDEVICE3 lpDev=NULL;
	
	LPDIRECTDRAW lpDD=NULL;
	LPDIRECTDRAWSURFACE lpDDS=NULL;
	GUID	g;
	LPGUID pg=&g;
	
	#pragma message ("need new device to be parented to the surface?")

	ZeroMemory(&g,sizeof(GUID));
	
	if ((!guid)||(guid[0]==0)){
		pg=NULL;
	}
	else {
		hretval=D3DBSTRtoGUID(&g,guid);
		if FAILED(hretval) return E_INVALIDARG;
	}

	
	if ( dd == NULL || dds == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAW4, lpDD4, dd);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpDDS4, dds);

	if (!lpDD4) return E_INVALIDARG;
	if (!lpDDS4) return E_INVALIDARG;


	hretval = lpDD4->QueryInterface(IID_IDirectDraw,(void**)&lpDD);
	if FAILED(hretval)	return hretval;

	hretval = lpDDS4->QueryInterface(IID_IDirectDrawSurface,(void**)&lpDDS);
	if FAILED(hretval)	return hretval;

	hretval = m__dxj_Direct3dRM3->CreateDeviceFromSurface( pg, lpDD, lpDDS, (DWORD) flags, &lpDev);

	lpDD->Release();
	lpDDS->Release();

	if FAILED(hretval)	return hretval;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice3, lpDev, retval);
	return S_OK;
}




//////////////////////////////////////////////////////////////////////////
// A call to EnumerateObjects envokes the user's callback for each 
// d3drmObject object in the list. In addition all enumerate calls will
// generate their full complement of enumerations. Hence there are 2 
// lists: a) the list of objects, b) the list of enumeration calls.
STDMETHODIMP C_dxj_Direct3dRM3Object::enumerateObjects( 
					  I_dxj_Direct3dRMEnumerateObjectsCallback *enumC, IUnknown *args)
{
	EnumerateObjectsCallback *enumcb; 

	if ( is4Bit )
		return E_FAIL;

	enumcb = (EnumerateObjectsCallback*)AddCallbackLink((void**)&EnumCallbacks,
										(I_dxj_Direct3dRMCallback*)enumC, (void*) args);
	if( !enumcb )	{

		DPF(1,"Callback EnumerateObjects creation failed!\r\n");

		return E_FAIL;
	} 
	m__dxj_Direct3dRM3->EnumerateObjects(myEnumerateObjectsCallback, enumcb);

	// Remove ourselves in a thread-safe manner.
	UndoCallbackLink((GeneralCallback*)enumcb, 
										(GeneralCallback**)&EnumCallbacks);
	return S_OK;
}
	
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::loadFromFile(BSTR filename, VARIANT  id, 
	SAFEARRAY **psa, long cnt, d3drmLoadFlags options, I_dxj_Direct3dRMLoadCallback *fn1, 
		IUnknown *arg1, I_dxj_Direct3dRMLoadTextureCallback3 *fn2, IUnknown *arg2, I_dxj_Direct3dRMFrame3 *f)
{
	HRESULT	hr;	
	GUID aGuids[100];
	int i=0;

	ZeroMemory(&(aGuids[0]),sizeof(GUID)*100);

	//check args
	if (cnt>100) return E_INVALIDARG;
	if (cnt<0) return E_INVALIDARG;
	if (!ISSAFEARRAY1D(psa,(DWORD)cnt)) return E_FAIL;
	
	
	for (i =0;i<cnt;i++)
	{
		hr=BSTRtoGUID(&(aGuids[i]),((BSTR*)((SAFEARRAY *)*psa)->pvData)[i]);
		if FAILED(hr) return hr;
	}


	TextureCallback3 *tcb = NULL;
	LoadCallback    *lcb = NULL;
	

	if ( is4Bit )
		return E_FAIL;


	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	D3DRMLOADCALLBACK		 d3dlcb = NULL;
	LPVOID pArgs1 = NULL;
	LPVOID pArgs2 = NULL;

	if (arg1) arg1->AddRef();
	if (arg2) arg2->AddRef();

	if( fn2 ) {
		if ((tcb = (TextureCallback3*)AddCallbackLink((void**)&TextureCallbacks3,
											(I_dxj_Direct3dRMCallback*)fn2, (void*) arg2)) == NULL) {
			
			DPF(1,"Callback object creation failed!\r\n");


			if (arg1) arg1->Release();
			if (arg2) arg2->Release();

			return E_FAIL;
		}
		d3dtcb = myLoadTextureCallback3;
		pArgs1 = (void *)tcb;
	}
	if( fn1 ) {
		if ((lcb = (LoadCallback*)AddCallbackLink((void**)&LoadCallbacks,
											(I_dxj_Direct3dRMCallback*)fn1, (void*) arg1)) == NULL) {
			DPF(1,"Callback object creation failed!\r\n");


			if (arg1) arg1->Release();
			if (arg2) arg2->Release();

			return E_FAIL;
		}
		d3dlcb = myd3drmLoadCallback;
		pArgs2 = (void *)lcb;
	}
	USES_CONVERSION;
	LPSTR pszNam = NULL;
	__try { pszNam = W2T(filename); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	LPDIRECT3DRMFRAME3 lpff = NULL;
	if(f)
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, f);
		lpff = lpF;
	}


	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((options & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & options)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		__try { args=(void*)W2T(V_BSTR(&id)); } __except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}
	else if(options & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(options & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (options &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszNam;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRM3->Load(&res,(void*) args, (LPGUID*)aGuids, (DWORD)cnt, (DWORD)options, 
									d3dlcb, pArgs2, d3dtcb, pArgs1, lpff);

	}
	else {
		hr = m__dxj_Direct3dRM3->Load(pszNam,(void*) args, (LPGUID*)aGuids, (DWORD)cnt, (DWORD)options, 
									d3dlcb, pArgs2, d3dtcb, pArgs1, lpff);
	}

	// Remove ourselves in a thread-safe manner.
	if (tcb)	UndoCallbackLink((GeneralCallback*)tcb, (GeneralCallback**)&TextureCallbacks3);
	if (lcb)	UndoCallbackLink((GeneralCallback*)lcb, (GeneralCallback**)&LoadCallbacks);

	if (arg1) arg1->Release();
	if (arg2) arg2->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::getSearchPath(BSTR *Name)
{	
	DWORD cnt = 0;

	if ( is4Bit )
		return E_FAIL;

	if((m__dxj_Direct3dRM3->GetSearchPath(&cnt,(char*)NULL)) != D3DRM_OK) // size
		return E_FAIL;

	LPSTR str = NULL;
	__try { str = (LPSTR)alloca(cnt); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	if((m__dxj_Direct3dRM3->GetSearchPath(&cnt, str)) != D3DRM_OK)	return E_FAIL;

	PassBackUnicode(str, Name, cnt);
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::getNamedObject(BSTR Name, I_dxj_Direct3dRMObject **f)
{
	LPDIRECT3DRMOBJECT lp;				// DirectX object pointer
    HRESULT             hr;
	
    if (!f) return E_INVALIDARG;

	*f=NULL;
	
	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(Name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	hr=m__dxj_Direct3dRM3->GetNamedObject(pszName,&lp);
    if FAILED(hr) return hr;		
	if (lp==NULL) return S_OK;	
    
    hr=CreateCoverObject(lp,f);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::setSearchPath(BSTR Name)
{


	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(Name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	if((m__dxj_Direct3dRM3->SetSearchPath(pszName)) != D3DRM_OK)	return E_FAIL;
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::addSearchPath(BSTR Name)
{

	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(Name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	if((m__dxj_Direct3dRM3->AddSearchPath(pszName)) != D3DRM_OK) 	return E_FAIL;
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createWrap(d3drmWrapType type, I_dxj_Direct3dRMFrame3 *fr, 
										d3dvalue ox, d3dvalue oy, d3dvalue oz, 
										d3dvalue dx, d3dvalue dy, d3dvalue dz,
										d3dvalue ux, d3dvalue uy, d3dvalue uz, 
										d3dvalue ou, d3dvalue ov, 
										d3dvalue su, d3dvalue sv,I_dxj_Direct3dRMWrap **retv)
{
	LPDIRECT3DRMWRAP lp;

	if ( is4Bit )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, fr);

	if ((m__dxj_Direct3dRM3->CreateWrap((enum _D3DRMWRAPTYPE)type, lpF, ox, oy, oz,
					dx, dy, dz, ux, uy, uz,ou, ov, su, sv, &lp)) != S_OK)
	{
		*retv = NULL;
		return E_FAIL;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMWrap, lp, retv);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createShadow(I_dxj_Direct3dRMVisual *visual, 
			I_dxj_Direct3dRMLight *light,
			d3dvalue px, d3dvalue py, d3dvalue pz, 
			d3dvalue nx, d3dvalue ny, d3dvalue nz,
			I_dxj_Direct3dRMShadow2 **retv)
{
	LPDIRECT3DRMSHADOW2 lp;
	HRESULT hr;


	DO_GETOBJECT_NOTNULL_VISUAL_ADDREF(lpV, visual);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMLIGHT, lpL, light);

	

	hr=m__dxj_Direct3dRM3->CreateShadow(lpV, lpL,
		px, py, pz,	nx, ny, nz,&lp);
	if (lpV) IUNK(lpV)->Release();
	
	if (FAILED(hr))
	{
		*retv = NULL;		
		return hr;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMShadow2, lp, retv);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createViewport(I_dxj_Direct3dRMDevice3 *dev, I_dxj_Direct3dRMFrame3 *fr,
						long l,long t,long w,long h,I_dxj_Direct3dRMViewport2 **retval)
{
	LPDIRECT3DRMVIEWPORT2 lp;
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMDEVICE3, lpD, dev);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, fr);

	hr = m__dxj_Direct3dRM3->CreateViewport(lpD, lpF, l, t, w, h, &lp);
	if( hr != S_OK )
		return hr;

	//INTERNAL_CREATE(_dxj_Direct3dRMViewport2, lp, retval);
	C_dxj_Direct3dRMViewport2Object *c=new CComObject<C_dxj_Direct3dRMViewport2Object>;
	if( c == NULL ) 
	{ 
		lp->Release(); 
		return E_FAIL;
	} 
	c->parent = dev;
	dev->AddRef(); 
	c->InternalSetObject(lp);
	if (FAILED(IUNK(c)->QueryInterface(IID_I_dxj_Direct3dRMViewport2, (void **)retval))) 
		return E_FAIL; 
	c->pinterface = *retval; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// real important that the return value is set correctly regardless, callbacks
// use this!
//
STDMETHODIMP C_dxj_Direct3dRM3Object::loadTexture(BSTR name, I_dxj_Direct3dRMTexture3 **retval)
{
	LPDIRECT3DRMTEXTURE3 lpT;

	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	if( m__dxj_Direct3dRM3->LoadTexture(pszName, &lpT ) != S_OK )
	{
		*retval = NULL;
		return S_OK;	// Reture ok so that we don't thro execeptionn if it fails 
	}

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpT, retval);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromClipper(I_dxj_DirectDrawClipper *lpDDClipper, BSTR strGuid, int width, int height, I_dxj_Direct3dRMDevice3 **retv)
{
	LPDIRECT3DRMDEVICE3 lpd3drmDev;
	GUID g;
	LPGUID pguid=NULL;
	HRESULT hr;

	//hr =BSTRtoPPGUID(&pguid,strGuid);
	if ((strGuid) && (strGuid[0]!=0)){
		hr=D3DBSTRtoGUID(&g,strGuid);
		if FAILED(hr) return hr;
		pguid=&g;
	}

	if ( is4Bit )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpddc, lpDDClipper);


	if( m__dxj_Direct3dRM3->CreateDeviceFromClipper(lpddc, (LPGUID)pguid, width, height, &lpd3drmDev) != DD_OK)
		return E_FAIL;

	INTERNAL_CREATE_2REFS(_dxj_Direct3dRMDevice3, _dxj_DirectDrawClipper, lpDDClipper, lpd3drmDev, retv);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createFrame(I_dxj_Direct3dRMFrame3 *parent,I_dxj_Direct3dRMFrame3 **retv)
{
	LPDIRECT3DRMFRAME3 lpFrame;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpFrameParent, parent)

	if( m__dxj_Direct3dRM3->CreateFrame(lpFrameParent, &lpFrame) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame, retv);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createLightRGB(d3drmLightType lt, d3dvalue vred,
								d3dvalue vgreen,d3dvalue vblue,I_dxj_Direct3dRMLight **retv)
{
	LPDIRECT3DRMLIGHT lpNew;

	if ( is4Bit )
		return E_FAIL;

	if( m__dxj_Direct3dRM3->CreateLightRGB((enum _D3DRMLIGHTTYPE)lt, vred, vgreen, vblue, &lpNew) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMLight, lpNew, retv);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::setOptions(long opt){
	return m__dxj_Direct3dRM3->SetOptions((DWORD)opt);

}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRM3Object::getOptions(long *opt){
	return m__dxj_Direct3dRM3->GetOptions((DWORD*)opt);

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createClippedVisual(I_dxj_Direct3dRMVisual *vis, I_dxj_Direct3dRMClippedVisual**clipvis)
{
	//LPDIRECT3DRMVISUAL lpVisual=NULL;
	LPDIRECT3DRMCLIPPEDVISUAL lpClippedVisual=NULL;
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMVISUAL, lpVisual, vis)

	hr=m__dxj_Direct3dRM3->CreateClippedVisual(lpVisual,&lpClippedVisual);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMClippedVisual, lpClippedVisual, clipvis);

	return hr;
}
 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createProgressiveMesh( I_dxj_Direct3dRMProgressiveMesh **retv)
{
	LPDIRECT3DRMPROGRESSIVEMESH lpPMesh=NULL;


	if( m__dxj_Direct3dRM3->CreateProgressiveMesh(&lpPMesh) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMProgressiveMesh, lpPMesh, retv);

	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolator( 
//            /* [retval][out] */ I_dxj_Direct3dRMInterpolator __RPC_FAR *__RPC_FAR *retv)
//{
//	return E_NOTIMPL;
//}

STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMMeshInterpolator, 0, IID_IDirect3DRMInterpolator,(void**) &lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMeshInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTextureInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMTextureInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMTextureInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterialInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMMaterialInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMaterialInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorFrame( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMFrameInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrameInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorViewport( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMViewportInterpolator, 0, IID_IDirect3DRMInterpolator,(void**) &lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMViewportInterpolator, lpInterpolator, retv);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorLight( 
            /* [retval][out] */ I_dxj_Direct3dRMLightInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMLightInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMLightInterpolator, lpInterpolator, retv);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformatsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_D3DEnumPixelFormatsObject : 
	public I_dxj_Direct3DEnumPixelFormats7,
	public CComObjectRoot
{
public:
	C_dxj_D3DEnumPixelFormatsObject() ;
	virtual ~C_dxj_D3DEnumPixelFormatsObject() ;

BEGIN_COM_MAP(C_dxj_D3DEnumPixelFormatsObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_D3DEnumPixelFormatsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimation2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimation2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmFrame3Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMAnimation2, {});
DESTRUCTOR(_dxj_Direct3dRMAnimation2, {});
GETSET_OBJECT(_dxj_Direct3dRMAnimation2);

CLONE_R(_dxj_Direct3dRMAnimation2,Direct3DRMAnimation2);
SETNAME_R(_dxj_Direct3dRMAnimation2);
GETNAME_R(_dxj_Direct3dRMAnimation2);
GETCLASSNAME_R(_dxj_Direct3dRMAnimation2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMAnimation2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMAnimation2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimation2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimation2, setOptions, SetOptions, d3drmAnimationOptions,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMAnimation2, deleteKey, DeleteKey,  d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMAnimation2, setTime, SetTime, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMAnimation2, addPositionKey, AddPositionKey, d3dvalue, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMAnimation2, addScaleKey, AddScaleKey, d3dvalue, d3dvalue, d3dvalue, d3dvalue);

GET_DIRECT_R(_dxj_Direct3dRMAnimation2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMAnimation2, getOptions, GetOptions, long);



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::addRotateKey(D3DVALUE rvtime, D3dRMQuaternion *rqQuat)
{
	return m__dxj_Direct3dRMAnimation2->AddRotateKey(rvtime,(_D3DRMQUATERNION*) rqQuat);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::setFrame(I_dxj_Direct3dRMFrame3 *frame)
{
	IDirect3DRMFrame3 *realframe=NULL;

	frame->InternalGetObject((IUnknown**) &realframe);
	
	return m__dxj_Direct3dRMAnimation2->SetFrame(realframe);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getFrame(I_dxj_Direct3dRMFrame3 **frame)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
    *frame=NULL;		
	hr=m__dxj_Direct3dRMAnimation2->GetFrame((IDirect3DRMFrame3**)&realframe);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,realframe,frame);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::addKey(D3DRMANIMATIONKEY_CDESC *key)
{
	HRESULT hr;
	LPD3DRMANIMATIONKEY pKey=(LPD3DRMANIMATIONKEY)key;
	D3DRMANIMATIONKEY realkey;
	pKey->dwSize=sizeof(D3DRMANIMATIONKEY);
	if (!key) return E_INVALIDARG;

	if (pKey->dwKeyType==D3DRMANIMATION_ROTATEKEY )
	{
		realkey.dwSize=sizeof(D3DRMANIMATIONKEY);
		realkey.dwKeyType=D3DRMANIMATION_ROTATEKEY;
		realkey.dvTime=pKey->dvTime;
		realkey.dqRotateKey.v.x=key->dvX;
		realkey.dqRotateKey.v.y=key->dvY;
		realkey.dqRotateKey.v.z=key->dvZ;
		realkey.dqRotateKey.s=key->dvS;
		hr= m__dxj_Direct3dRMAnimation2->AddKey(&realkey);
		key->lID = realkey.dwID;
	}
	else {
		hr= m__dxj_Direct3dRMAnimation2->AddKey((LPD3DRMANIMATIONKEY)key);
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::deleteKeyById(long id)
{		
	return m__dxj_Direct3dRMAnimation2->DeleteKeyByID((DWORD)id);
}

STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getKeys( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *keyArray) 
{
	
	
	DWORD nKeys;
	HRESULT hr;

	//if (!ISSAFEARRAY1D(keyArray,count)) return E_INVALIDARG;
	if (!keyArray) return E_INVALIDARG;

	nKeys= (*keyArray)->cbElements;

	hr=m__dxj_Direct3dRMAnimation2->GetKeys(timeMin,timeMax,&nKeys,(D3DRMANIMATIONKEY*)((SAFEARRAY*)*keyArray)->pvData);
	if FAILED(hr) return hr;

	for (DWORD i=0;i<nKeys;i++)
	{
		D3DRMANIMATIONKEY_CDESC *pKey=&((D3DRMANIMATIONKEY_CDESC*)((SAFEARRAY*)*keyArray)->pvData)[i];
		if (pKey->lKeyType==D3DRMANIMATION_ROTATEKEY)
		{
			D3DRMANIMATIONKEY realkey;
			memcpy(&realkey,pKey,sizeof(D3DRMANIMATIONKEY));
						
			pKey->dvX=realkey.dqRotateKey.v.x;
			pKey->dvY=realkey.dqRotateKey.v.y;
			pKey->dvZ=realkey.dqRotateKey.v.z;
			pKey->dvS=realkey.dqRotateKey.s;		
		}
	}

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getKeysCount( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            /* [out,retval]*/ long *count)            
{
	
	HRESULT hr;
	hr=m__dxj_Direct3dRMAnimation2->GetKeys(timeMin,timeMax,(DWORD*)count,NULL);
	return hr;
}
        



STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::modifyKey(D3DRMANIMATIONKEY_CDESC *key)
{
		
	return m__dxj_Direct3dRMAnimation2->ModifyKey((LPD3DRMANIMATIONKEY)key);
}
        
        



DWORD C_dxj_Direct3dRMAnimation2Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3dRMAnimation2[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMAnimation2Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMAnimation2 [%d] Release %d \n",creationid,i);
	return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drm3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drm3obj.h
//
//--------------------------------------------------------------------------

// d3drmObj.h : Declaration of the C_dxj_Direct3dRMObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRM3 LPDIRECT3DRM3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRM3Object : 
	public I_dxj_Direct3dRM3,
	public CComObjectRoot
//	public CComCoClass<C_dxj_Direct3dRM3Object, &CLSID__dxj_Direct3dRM3>, public CComObjectRoot
{
public:
	void doCreateObj();
	void doDeleteObj();

	C_dxj_Direct3dRM3Object();
	virtual ~C_dxj_Direct3dRM3Object();

BEGIN_COM_MAP(C_dxj_Direct3dRM3Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRM3)
END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRM3Object)

// I_dxj_Direct3dRM
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createDeviceFromClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *lpDDClipper,
            /* [in] */ BSTR guid,
            /* [in] */ int width,
            /* [in] */ int height,
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *parent,
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createLightRGB( 
            /* [in] */ d3drmLightType lt,
            /* [in] */ float vred,
            /* [in] */ float vgreen,
            /* [in] */ float vblue,
            /* [retval][out] */ I_dxj_Direct3dRMLight __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createLight( 
            /* [in] */ d3drmLightType lt,
            /* [in] */ long color,
            /* [retval][out] */ I_dxj_Direct3dRMLight __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createMeshBuilder( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createMaterial( 
            /* [in] */ float d,
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE loadTexture( 
            /* [in] */ BSTR name,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE createViewport( 
            /* [in] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *dev,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *fr,
            /* [in] */ long l,
            /* [in] */ long t,
            /* [in] */ long w,
            /* [in] */ long h,
            /* [retval][out] */ I_dxj_Direct3dRMViewport2 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE setDefaultTextureColors( 
            /* [in] */ long ds);
        
         HRESULT STDMETHODCALLTYPE setDefaultTextureShades( 
            /* [in] */ long ds);
        
         HRESULT STDMETHODCALLTYPE createAnimationSet( 
            /* [retval][out] */ I_dxj_Direct3dRMAnimationSet2 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createFace( 
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createAnimation( 
            /* [retval][out] */ I_dxj_Direct3dRMAnimation2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE tick( 
            /* [in] */ float tic);
        
         
       //  HRESULT STDMETHODCALLTYPE createDevice( 
       //     /* [in] */ long v1,
       //     /* [in] */ long v2,
       //     /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createDeviceFromSurface( 
            /* [in] */ BSTR g,
            /* [in] */ I_dxj_DirectDraw4 __RPC_FAR *dd,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
			/* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retval);
        
        //HRESULT STDMETHODCALLTYPE createDeviceFromD3D( 
        //    /* [in] */ I_dxj_Direct3d3 __RPC_FAR *D3D,
        //    /* [in] */ I_dxj_Direct3dDevice3 __RPC_FAR *dev,
        //    /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createTextureFromSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createWrap( 
            /* [in] */ d3drmWrapType t,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f,
            /* [in] */ float ox,
            /* [in] */ float oy,
            /* [in] */ float oz,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz,
            /* [in] */ float ou,
            /* [in] */ float ov,
            /* [in] */ float su,
            /* [in] */ float sv,
            /* [retval][out] */ I_dxj_Direct3dRMWrap __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSearchPath( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getDevices( 
            /* [retval][out] */ I_dxj_Direct3dRMDeviceArray __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getNamedObject( 
            /* [in] */ BSTR name,
            /* [retval][out] */ I_dxj_Direct3dRMObject __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE setSearchPath( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE addSearchPath( 
            /* [in] */ BSTR name);
        
//         HRESULT STDMETHODCALLTYPE createUserVisual( 
//            /* [in] */ I_dxj_Direct3dRMUserVisualCallback __RPC_FAR *fn,
//            /* [in] */ IUnknown __RPC_FAR *arg,
//            /* [retval][out] */ I_dxj_Direct3dRMUserVisual __RPC_FAR *__RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE enumerateObjects( 
            /* [in] */ I_dxj_Direct3dRMEnumerateObjectsCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *pargs);
        

         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *guidArray,
            /* [in] */ long cnt,
            /* [in] */ d3drmLoadFlags options,
            /* [in] */ I_dxj_Direct3dRMLoadCallback __RPC_FAR *fn1,
            /* [in] */ IUnknown __RPC_FAR *arg1,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *fn2,
            /* [in] */ IUnknown __RPC_FAR *arg2,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE createShadow( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *visual,
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *light,
            /* [in] */ float px,
            /* [in] */ float py,
            /* [in] */ float pz,
            /* [in] */ float nx,
            /* [in] */ float ny,
            /* [in] */ float nz,
            /* [retval][out] */ I_dxj_Direct3dRMShadow2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createProgressiveMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createClippedVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *vis,
            /* [retval][out] */ I_dxj_Direct3dRMClippedVisual __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getOptions( 
            /* [retval][out] */ long __RPC_FAR *options);
        
         HRESULT STDMETHODCALLTYPE setOptions( 
            /* [in] */ long options);

//         HRESULT STDMETHODCALLTYPE createInterpolator( 
//            /* [retval][out] */ I_dxj_Direct3dRMInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTextureInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterialInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorFrame( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorViewport( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorLight( 
            /* [retval][out] */ I_dxj_Direct3dRMLightInterpolator __RPC_FAR *__RPC_FAR *retv);

////////////////////////////////////////////////////////////////////////////////////


	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRM3);

private:
	HINSTANCE hinstLib;


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRM3)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmanimationarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimationArrayObj.h"
#include "d3drmAnimation2Obj.h"

extern void *g_dxj_Direct3dRMAnimationArray;

CONSTRUCTOR(_dxj_Direct3dRMAnimationArray, {});
DESTRUCTOR(_dxj_Direct3dRMAnimationArray, {});
GETSET_OBJECT(_dxj_Direct3dRMAnimationArray);

GET_DIRECT_R(_dxj_Direct3dRMAnimationArray,getSize, GetSize, long)


HRESULT C_dxj_Direct3dRMAnimationArrayObject::getElement(long i, I_dxj_Direct3dRMAnimation2 **Animation){
	HRESULT hr;
	IDirect3DRMAnimation2 *realAnimation2=NULL;

	hr=m__dxj_Direct3dRMAnimationArray->GetElement((DWORD)i,&realAnimation2);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMAnimation2,(IDirect3DRMAnimation2*)realAnimation2,Animation);


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmanimationarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationArrayObj.h : Declaration of the C_dxj_Direct3dRMAnimationArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMAnimationArray LPDIRECT3DRMANIMATIONARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimationArrayObject : 
	
	//public CComDualImpl<I_dxj_Direct3dRMAnimationArray, &IID_I_dxj_Direct3dRMAnimationArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMAnimationArray,
	//public CComCoClass<C_dxj_Direct3dRMAnimationArrayObject, &CLSID__dxj_Direct3dRMAnimationArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimationArrayObject() ;
	virtual ~C_dxj_Direct3dRMAnimationArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimationArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimationArray)
		//COM_INTERFACE_ENTRY(IDispatch)
		//COM_INTERFACE_ENTRY(ISupportErrorInfo)

	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMAnimationArray,	"DIRECT.Direct3dRMAnimationArray.3",	"DIRECT.Direct3dRMAnimationArray.3",   IDS_D3DRMAnimationARRAY_DESC,   THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMAnimationArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimationArrayObject)
	

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// I_dxj_Direct3dRMAnimationArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMAnimation2 **lplpD3DRMAnimation);

private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimationArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimationArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimation2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimation2obj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationObj.h : Declaration of the C_dxj_Direct3dRMAnimationObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMAnimation2 LPDIRECT3DRMANIMATION2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimation2Object : 
	public I_dxj_Direct3dRMAnimation2,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimation2Object() ;
	~C_dxj_Direct3dRMAnimation2Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimation2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimation2)
	END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimation2Object)

// I_dxj_Direct3dRMAnimation
public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg) ;
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args) ;
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data) ;
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data) ;
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE setOptions( 
            /* [in] */ d3drmAnimationOptions flags) ;
        
        HRESULT STDMETHODCALLTYPE addRotateKey( 
            /* [in] */ float time,
            /* [in] */ D3dRMQuaternion __RPC_FAR *q) ;
        
        HRESULT STDMETHODCALLTYPE addPositionKey( 
            /* [in] */ float time,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE addScaleKey( 
            /* [in] */ float time,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ float time) ;
        
        HRESULT STDMETHODCALLTYPE setFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *frame) ;

        HRESULT STDMETHODCALLTYPE getFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR **frame) ;

        HRESULT STDMETHODCALLTYPE setTime( 
            /* [in] */ float time) ;
        
        HRESULT STDMETHODCALLTYPE getOptions( 
            /* [retval][out] */ d3drmAnimationOptions __RPC_FAR *options) ;
        
        HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ D3DRMANIMATIONKEY_CDESC __RPC_FAR *key) ;
        
        HRESULT STDMETHODCALLTYPE deleteKeyById( 
            /* [in] */ long id) ;
        
        HRESULT STDMETHODCALLTYPE getKeys( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            ///* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *keyArray) ;
        
        HRESULT STDMETHODCALLTYPE getKeysCount( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            /* [retval][out] */ long __RPC_FAR *count) ;
        
        
        HRESULT STDMETHODCALLTYPE modifyKey( 
            /* [in] */ D3DRMANIMATIONKEY_CDESC __RPC_FAR *key) ;
        
////////////////////////////////////////////////////////////////////////////////////
//

private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimation2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimation2)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationset2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimationset2obj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationSet2Obj.h : Declaration of the C_dxj_Direct3dRMAnimationSet2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMAnimationSet2 LPDIRECT3DRMANIMATIONSET2
/////////////////////////////////////////////////////////////////////////////
// Direct
//
//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimationSet2Object : 
	public I_dxj_Direct3dRMAnimationSet2,
	//public CComCoClass<C_dxj_Direct3dRMAnimationSet2Object, &CLSID__dxj_Direct3dRMAnimationSet2>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimationSet2Object() ;
	virtual ~C_dxj_Direct3dRMAnimationSet2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimationSet2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimationSet2)
	END_COM_MAP()

	// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMAnimationSet2, "DIRECT.Direct3dRMAnimationSet2.3",	"DIRECT.Direct3dRMAnimationSet2.3", IDS_D3DRMAnimationSet2_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimationSet2Object)

// I_dxj_Direct3dRMAnimationSet2
public:
	// MUST BE FIRST TWO!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(loadFromFile)(BSTR filename, VARIANT id,long flags,
			I_dxj_Direct3dRMLoadTextureCallback3 *c,IUnknown *pUser, I_dxj_Direct3dRMFrame3 *frame);
	STDMETHOD(setTime)(d3dvalue time);

	STDMETHOD(addAnimation)(I_dxj_Direct3dRMAnimation2 *aid);
	STDMETHOD(deleteAnimation)(I_dxj_Direct3dRMAnimation2 *aid);
	STDMETHOD(getAnimations)(I_dxj_Direct3dRMAnimationArray **ppret);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimationSet2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimationSet2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmArrayObj.h"

CONSTRUCTOR( _dxj_Direct3dRMObjectArray, {} );
DESTRUCTOR ( _dxj_Direct3dRMObjectArray, {} );
GETSET_OBJECT ( _dxj_Direct3dRMObjectArray );
	
GET_DIRECT_R(_dxj_Direct3dRMObjectArray, getSize, GetSize, long);


#pragma message ("TODO D3DRMObjectArray")


HRESULT C_dxj_Direct3dRMObjectArrayObject::getElement(long i, I_dxj_Direct3dRMObject **obj){
	//HRESULT hr;		
	//hr=m__dxj_Direct3dRMObjectArray->GetElement((DWORD)i,&realobj);
	//if FAILED(hr) return hr;
	//INTERNAL_CREATE(_dxj_Direct3dRMObject,(IDirect3DRMObject)realobj,obj);
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmarrayobj.h
//
//--------------------------------------------------------------------------

// d3dRMObjectArrayObj.h : Declaration of the C_dxj_Direct3dRMObjectArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMObjectArray LPDIRECT3DRMOBJECTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

class C_dxj_Direct3dRMObjectArrayObject : 
	public I_dxj_Direct3dRMObjectArray,
	//public CComCoClass<C_dxj_Direct3dRMObjectArrayObject, &CLSID__dxj_Direct3dRMObjectArray>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMObjectArrayObject();
	virtual ~C_dxj_Direct3dRMObjectArrayObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMObjectArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObjectArray)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMObjectArrayObject)

// I_dxj_Direct3dRMObjectArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
	STDMETHOD(getElement)( long index, I_dxj_Direct3dRMObject **ret);
	
private:
    DECL_VARIABLE(_dxj_Direct3dRMObjectArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMObjectArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationset2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimationset2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationSet2Obj.cpp : Implementation of CDirectApp and DLL registration.


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmAnimationArrayObj.h"

extern void *g_dxj_Direct3dRMAnimationArray;
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR( _dxj_Direct3dRMAnimationSet2,{});
DESTRUCTOR( _dxj_Direct3dRMAnimationSet2,{});
GETSET_OBJECT(_dxj_Direct3dRMAnimationSet2);

CLONE_R(_dxj_Direct3dRMAnimationSet2,Direct3DRMAnimationSet2);
SETNAME_R(_dxj_Direct3dRMAnimationSet2);
GETNAME_R(_dxj_Direct3dRMAnimationSet2);
GETCLASSNAME_R(_dxj_Direct3dRMAnimationSet2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMAnimationSet2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMAnimationSet2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimationSet2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R( _dxj_Direct3dRMAnimationSet2, setTime, SetTime, d3dvalue);

GET_DIRECT_R(_dxj_Direct3dRMAnimationSet2, getAppData, GetAppData, long);

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMAnimationSet2, addAnimation,    AddAnimation,    _dxj_Direct3dRMAnimation2); 
//DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMAnimationSet2, deleteAnimation, DeleteAnimation, _dxj_Direct3dRMAnimation2);


STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::deleteAnimation(I_dxj_Direct3dRMAnimation2 *anim)
{
	HRESULT hr;
	UINT i;

	if (!anim) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMANIMATION2,pRealAnim,anim);
	
	i=pRealAnim->AddRef();
	i=pRealAnim->Release();

	hr=m__dxj_Direct3dRMAnimationSet2->DeleteAnimation(pRealAnim);

	i=pRealAnim->AddRef();
	i=pRealAnim->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::loadFromFile(BSTR filename, 
				VARIANT id, long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, 
										IUnknown *useMe, I_dxj_Direct3dRMFrame3 *frame)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;

	HRESULT hr;

	if( callme )  {
		tcb = (TextureCallback3*)AddCallbackLink((void**)&TextureCallbacks3,
										(I_dxj_Direct3dRMCallback*)callme, (void*)useMe);
		if( tcb ) 	{
			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;

		} else 	{
			DPF(1,"Callback object creation failed!\r\n");
			return E_FAIL;
		}
	}
	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(filename); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, frame);


	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		__try { args=(void*)W2T(V_BSTR(&id)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);



	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMAnimationSet2->Load((void *)&res, (DWORD*)args, (DWORD)flags, 
															d3dtcb, pArgs, (IDirect3DRMFrame3*)f);

	}
	else {
		hr = m__dxj_Direct3dRMAnimationSet2->Load((void *)pszName, (DWORD*)args, (DWORD)flags, 
															d3dtcb, pArgs, (IDirect3DRMFrame3*)f);
	}

	//We are done with the callback so remove the linked entry
	if (tcb)
		UndoCallbackLink( (GeneralCallback*)tcb,
									(GeneralCallback**)&TextureCallbacks3 );
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::getAnimations(I_dxj_Direct3dRMAnimationArray **ppret)
{	
	HRESULT hr;
	LPDIRECT3DRMANIMATIONARRAY lpArray=NULL;

	hr=m__dxj_Direct3dRMAnimationSet2->GetAnimations(&lpArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMAnimationArray, lpArray, ppret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmclippedvisualobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippedvisualobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dRMClippedVisualObj.h"

CONSTRUCTOR(_dxj_Direct3dRMClippedVisual, {});
DESTRUCTOR(_dxj_Direct3dRMClippedVisual, {});
GETSET_OBJECT(_dxj_Direct3dRMClippedVisual);

CLONE_R(_dxj_Direct3dRMClippedVisual,Direct3DRMClippedVisual);
GETNAME_R(_dxj_Direct3dRMClippedVisual);
SETNAME_R(_dxj_Direct3dRMClippedVisual);
GETCLASSNAME_R(_dxj_Direct3dRMClippedVisual);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMClippedVisual);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMClippedVisual);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMClippedVisual, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMClippedVisual, getAppData, GetAppData, long);


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMClippedVisual, deletePlane, DeletePlane, long,(DWORD),long,(DWORD));



STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::deletePlane( long id) {
	HRESULT hr;
	hr = m__dxj_Direct3dRMClippedVisual->DeletePlane(id,0);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::addPlane( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal,
            ///* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->AddPlane(
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0,
			(DWORD*)ret);

	return hr;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlane( 
			/* [in] */ long id,											
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
            ///* [in] */ long flags
			)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->GetPlane(
			(DWORD)id,
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0);	

	return hr;			
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::setPlane( 
			/* [in] */ long id,											
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
            ///* [in] */ long flags
			)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->SetPlane(
			(DWORD)id,
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0);	

	return hr;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlaneIdsCount( 
			/* [in] */ long *count)	
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMClippedVisual->GetPlaneIDs((DWORD*)count,NULL,0);

	return hr;			
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlaneIds( 
            /* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *arrayOfIds) \
{
	HRESULT hr;
	if (!ISSAFEARRAY1D(arrayOfIds,(DWORD)count)) return E_INVALIDARG;

	hr = m__dxj_Direct3dRMClippedVisual->GetPlaneIDs((DWORD*)&count,
			(DWORD*)(((SAFEARRAY *)*arrayOfIds)->pvData),0);

	return hr;			
	//getDibits
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmclippedvisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippedvisualobj.h
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.h : Declaration of the C_dxj_Direct3dRMClippedVisualObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMClippedVisual LPDIRECT3DRMCLIPPEDVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_Direct3dRMClippedVisualObject : 
	public I_dxj_Direct3dRMClippedVisual,
	public I_dxj_Direct3dRMVisual,
	public I_dxj_Direct3dRMObject,
	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMClippedVisualObject() ;
	virtual ~C_dxj_Direct3dRMClippedVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMClippedVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMClippedVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMClippedVisualObject)

// I_dxj_Direct3dRMClippedVisual
public:
	
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addPlane( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal,
//            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE deletePlane( 
            /* [in] */ long id
//            /* [in] */ long flags
);
        
         HRESULT STDMETHODCALLTYPE getPlane( 
            /* [in] */ long id,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
//            /* [in] */ long flags
);
        
         HRESULT STDMETHODCALLTYPE getPlaneIds( 
            /* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *arrayOfIds);
        
         HRESULT STDMETHODCALLTYPE getPlaneIdsCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ long id,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
//            /* [in] */ long flags
);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMClippedVisual);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMClippedVisual )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmclippervisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippervisualobj.h
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.h : Declaration of the C_dxj_Direct3dRMClippedVisualObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMClippedVisual LPDIRECT3DRMCLIPPEDVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMClippedVisualObject : 
	public I_dxj_Direct3dRMClippedVisual,
	public I_dxj_Direct3dRMVisual,
	public I_dxj_Direct3dRMObject,
	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMClippedVisualObject() ;
	virtual ~C_dxj_Direct3dRMClippedVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMClippedVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMClippedVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMClippedVisualObject)

// I_dxj_Direct3dRMClippedVisual
public:
	// MUST BE FIRST
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_D3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_D3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(setPower)(d3dvalue power);
	STDMETHOD(setSpecular)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(setEmissive)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(getPower)(d3dvalue *power);
	STDMETHOD(getSpecular)(d3dvalue *r, d3dvalue *g, d3dvalue *b);
	STDMETHOD(getEmissive)(d3dvalue *r, d3dvalue *g, d3dvalue *b);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMClippedVisual);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMClippedVisual )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmdevicearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevicearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmDeviceArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmDeviceArrayObj.h"
#include "d3drmDevice3Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMDeviceArray, {} );
DESTRUCTOR ( _dxj_Direct3dRMDeviceArray, {} );
GETSET_OBJECT ( _dxj_Direct3dRMDeviceArray );

GET_DIRECT_R(_dxj_Direct3dRMDeviceArray, getSize, GetSize,  long);

#ifdef DX5
HRESULT C_dxj_Direct3dRMDeviceArrayObject::getElement(long id, I_dxj_Direct3dRMDevice2 **ret){
	IDirect3DRMDevice  *realdevice=NULL;	
	IDirect3DRMDevice2  *realdevice2=NULL;	
	HRESULT hr;
	hr=m__dxj_Direct3dRMDeviceArray->GetElement((DWORD)id,&realdevice);
	if FAILED(hr) return hr;

	hr = realdevice->QueryInterface(IID_IDirect3DRMDevice2,(void**)&realdevice2);
	realdevice->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice2,(IDirect3DRMDevice2*)realdevice2,ret);

	return hr;
}
#else
HRESULT C_dxj_Direct3dRMDeviceArrayObject::getElement(long id, I_dxj_Direct3dRMDevice3 **ret){
	IDirect3DRMDevice  *realdevice=NULL;	
	IDirect3DRMDevice3  *realdevice3=NULL;	
	HRESULT hr;
	hr=m__dxj_Direct3dRMDeviceArray->GetElement((DWORD)id,&realdevice);
	if FAILED(hr) return hr;

	hr = realdevice->QueryInterface(IID_IDirect3DRMDevice3,(void**)&realdevice3);
	realdevice->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice3,realdevice3,ret);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmdevice3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevice3obj.h
//
//--------------------------------------------------------------------------

// d3drmDevice3Obj.h : Declaration of the C_dxj_Direct3dRMDeviceObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMDevice3 LPDIRECT3DRMDEVICE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMDevice3Object : 
	public I_dxj_Direct3dRMDevice3,
	public I_dxj_Direct3dRMObject,
	//public CComCoClass<C_dxj_Direct3dRMDevice3Object, &CLSID__dxj_Direct3dRMDevice3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMDevice3Object();
	virtual ~C_dxj_Direct3dRMDevice3Object();
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMDevice3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMDevice3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMDevice3,		"DIRECT.Direct3dRMDevice3.5",		"DIRECT.Direct3dRMDevice3.5", IDS_D3DRMDEVICE_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMDevice3Object)

// I_dxj_Direct3dRMDevice3
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addUpdateCallback( 
            /* [in] */ I_dxj_Direct3dRMDeviceUpdateCallback3 __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE deleteUpdateCallback( 
            /* [in] */ I_dxj_Direct3dRMDeviceUpdateCallback3 __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE findPreferredTextureFormat( 
            /* [in] */ long bitDepth,
            /* [in] */ long flags,
            /* [out][in] */ DDPixelFormat __RPC_FAR *ddpf);
        
         HRESULT STDMETHODCALLTYPE getBufferCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getColorModel( 
            /* [retval][out] */ d3dColorModel __RPC_FAR *retv);
        
        // HRESULT STDMETHODCALLTYPE getDirect3DDevice3( 
        //    /* [retval][out] */ I_dxj_Direct3dDevice3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getDither( 
            /* [retval][out] */ long __RPC_FAR *d);
        
         HRESULT STDMETHODCALLTYPE getHeight( 
            /* [retval][out] */ int __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getRenderMode( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getShades( 
            /* [retval][out] */ long __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getTextureQuality( 
            /* [retval][out] */ d3drmTextureQuality __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTrianglesDrawn( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getViewports( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportArray __RPC_FAR *__RPC_FAR *views);
        
         HRESULT STDMETHODCALLTYPE getWireframeOptions( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getWidth( 
            /* [retval][out] */ int __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE setBufferCount( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE setDither( 
            /* [in] */ long dith);
        
         HRESULT STDMETHODCALLTYPE setQuality( 
            /* [in] */ d3drmRenderQuality q);
        
         HRESULT STDMETHODCALLTYPE setRenderMode( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setShades( 
            /* [in] */ int shades);
        
         HRESULT STDMETHODCALLTYPE setTextureQuality( 
            /* [in] */ d3drmTextureQuality d);
        
         HRESULT STDMETHODCALLTYPE update( void);
        
		 HRESULT STDMETHODCALLTYPE handleActivate(long wParam) ;
		 
		 HRESULT STDMETHODCALLTYPE handlePaint(long hdcThing) ;
	
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMDevice3);

private:
	

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMDevice3 )
	IUnknown *parent2;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmface2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmface2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmFace22Obj.cpp : Implementation of CDirectApp and DLL registration.

//#define LPDIRECT3DRMFACE2 I_dxj_Direct3dRMFace2*

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFace2Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmMaterial2Obj.h"



CONSTRUCTOR( _dxj_Direct3dRMFace2,{});
DESTRUCTOR( _dxj_Direct3dRMFace2,{});
GETSET_OBJECT(_dxj_Direct3dRMFace2);

CLONE_R(_dxj_Direct3dRMFace2,Direct3DRMFace2);
GETNAME_R(_dxj_Direct3dRMFace2);
SETNAME_R(_dxj_Direct3dRMFace2);
GETCLASSNAME_R(_dxj_Direct3dRMFace2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMFace2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMFace2);

GET_DIRECT_R(_dxj_Direct3dRMFace2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMFace2, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFace2, getVertexCount, GetVertexCount, int);
GET_DIRECT1_R(_dxj_Direct3dRMFace2, getVertexIndex, GetVertexIndex, int, long);
GET_DIRECT1_R(_dxj_Direct3dRMFace2, getTextureCoordinateIndex, GetTextureCoordinateIndex, int, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFace2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFace2, setColor, SetColor, d3dcolor,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMFace2, setTextureTopology, SetTextureTopology, long, long);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMFace2, addVertexAndNormalIndexed, AddVertexAndNormalIndexed, long,(DWORD),long,(DWORD));
//PASS_THROUGH2_R(_dxj_Direct3dRMFace2, getTextureTopology, GetTextureTopology, int*, int*); //2 BOOL ptrs?
PASS_THROUGH3_R(_dxj_Direct3dRMFace2, addVertex, AddVertex, d3dvalue, d3dvalue,d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFace2, setColorRGB, SetColorRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, getTextureCoordinates, GetTextureCoordinates, long,(DWORD), d3dvalue*,(float*), d3dvalue*,(float*));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, setTextureCoordinates, SetTextureCoordinates, long,(DWORD), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, getVertex, GetVertex, long, (DWORD), D3dVector*, (_D3DVECTOR*),D3dVector*, (_D3DVECTOR*));

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFace2, setMaterial, SetMaterial, _dxj_Direct3dRMMaterial2);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMFace2, getMaterial, GetMaterial, _dxj_Direct3dRMMaterial2);



STDMETHODIMP C_dxj_Direct3dRMFace2Object::getTextureTopology(long *u, long *v)
{		

	HRESULT hr;
	hr= m__dxj_Direct3dRMFace2->GetTextureTopology((BOOL*)u,(BOOL*)v);	
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMFace2Object::getTexture(I_dxj_Direct3dRMTexture3 **tex)
{
		
	IDirect3DRMTexture3 *realtext3=NULL;	
	HRESULT hr;
	hr= m__dxj_Direct3dRMFace2->GetTexture(&realtext3);
	if FAILED(hr) return hr;
	
	INTERNAL_CREATE(_dxj_Direct3dRMTexture3,realtext3,tex);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFace2Object::setTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	if (tex==NULL) return E_INVALIDARG;
	IDirect3DRMTexture3 *realtext3=NULL;	
	tex->InternalGetObject((IUnknown**)&realtext3);		
	return m__dxj_Direct3dRMFace2->SetTexture( realtext3);
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFace2Object::getNormal(D3dVector *norm)
{
	return m__dxj_Direct3dRMFace2->GetNormal( (D3DVECTOR*) norm);
}


/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFace2Object::getVerticesJava(long cnt, float *v, float* n )
{
  HRESULT hr;
  __try {
	hr=m__dxj_Direct3dRMFace2->GetVertices((unsigned long *)&cnt, (D3DVECTOR *)v, (D3DVECTOR *)n);
  }
  __except(1,1){
	return E_INVALIDARG;
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFace2Object::getVertices(long cnt, SAFEARRAY **ppsv, SAFEARRAY **ppsn )
{
  if ((*ppsv==NULL)||(*ppsn==NULL)) return E_INVALIDARG;	
  if (!ISSAFEARRAY1D(ppsv,(DWORD)cnt)) return E_INVALIDARG;
  if (!ISSAFEARRAY1D(ppsn,(DWORD)cnt)) return E_INVALIDARG;

  D3DVECTOR *v= (D3DVECTOR*)((SAFEARRAY*)*ppsv)->pvData;
  D3DVECTOR *n= (D3DVECTOR*)((SAFEARRAY*)*ppsn)->pvData;
  return m__dxj_Direct3dRMFace2->GetVertices((unsigned long *)&cnt, (D3DVECTOR *)v, (D3DVECTOR *)n);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmdevicearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmdevicearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmDeviceArrayObj.h : Declaration of the C_dxj_Direct3dRMDeviceArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMDeviceArray LPDIRECT3DRMDEVICEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMDeviceArrayObject : 
	public I_dxj_Direct3dRMDeviceArray,
	//public CComCoClass<C_dxj_Direct3dRMDeviceArrayObject, &CLSID__dxj_Direct3dRMDeviceArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMDeviceArrayObject() ;
	virtual ~C_dxj_Direct3dRMDeviceArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMDeviceArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMDeviceArray)
	END_COM_MAP()

	//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMDeviceArray,	"DIRECT.Direct3dRMDeviceArray.3",	"DIRECT.Direct3dRMDeviceArray.3",  IDS_D3DRMDEVICEARRAY_DESC,  THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMDeviceArrayObject)

// I_dxj_Direct3dRMDeviceArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);

#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMDevice2 **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMDevice3 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMDeviceArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMDeviceArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmface2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmface2obj.h
//
//--------------------------------------------------------------------------

// d3drmFace2Obj.h : Declaration of the C_dxj_Direct3dRMFace2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMFace2 LPDIRECT3DRMFACE2


/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFace2Object : 
	public I_dxj_Direct3dRMFace2,
	public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFace2Object() ;
	virtual ~C_dxj_Direct3dRMFace2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMFace2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFace2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFace2Object)

// I_dxj_Direct3dRMFace2
public:
	//updated
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg) ;
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args) ;
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data) ;
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data) ;
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE addVertex( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE addVertexAndNormalIndexed( 
            /* [in] */ long vertex,
            /* [in] */ long normal) ;
        
        HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b) ;
        
        HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c) ;
        
        HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE setTextureCoordinates( 
            /* [in] */ long vertex,
            /* [in] */ float u,
            /* [in] */ float v) ;
        
        HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE setTextureTopology( 
            /* [in] */ long wrap_u,
            /* [in] */ long wrap_v) ;
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ long idx,
            /* [out][in] */ D3dVector __RPC_FAR *vert,
            /* [out][in] */ D3dVector __RPC_FAR *norm) ;
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long vertex_cnt,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *coord,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normals) ;
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinates( 
            /* [in] */ long vertex,
            /* [out][in] */ float __RPC_FAR *u,
            /* [out][in] */ float __RPC_FAR *v) ;
        
        
        HRESULT STDMETHODCALLTYPE getNormal( 
            /* [out][in] */ D3dVector __RPC_FAR *val) ;
        
        HRESULT STDMETHODCALLTYPE getTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVertexIndex( 
            /* [in] */ long which,
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinateIndex( 
            /* [in] */ long which,
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVerticesJava( 
            /* [in] */ long vertex_cnt,
            /* [out][in] */ float __RPC_FAR *coord,
            /* [out][in] */ float __RPC_FAR *normals) ;


		HRESULT STDMETHODCALLTYPE getTextureTopology(long *u, long *v);
        
private:
    DECL_VARIABLE(_dxj_Direct3dRMFace2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFace2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmdevice3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevice3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmDevice3Obj.h"
#include "d3drmViewportArrayObj.h"


C_dxj_Direct3dRMDevice3Object::C_dxj_Direct3dRMDevice3Object(){
	m__dxj_Direct3dRMDevice3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;	

	parent2 =NULL;

	DPF1(1,"Constructor Creation  Direct3dRMDevice3[%d] \n",g_creationcount);

	nextobj =  g_dxj_Direct3dRMDevice3;
	g_dxj_Direct3dRMDevice3 = (void *)this;
}


C_dxj_Direct3dRMDevice3Object::~C_dxj_Direct3dRMDevice3Object(){

	DPF1(1,"Destructor  Direct3dRMDevice3 [%d] \n",creationid); 
	
	C_dxj_Direct3dRMDevice3Object *prev=NULL; 

	for(C_dxj_Direct3dRMDevice3Object *ptr=(C_dxj_Direct3dRMDevice3Object *)g_dxj_Direct3dRMDevice3;
		ptr;
		ptr=(C_dxj_Direct3dRMDevice3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMDevice3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMDevice3){ 
		int count = IUNK(m__dxj_Direct3dRMDevice3)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMDevice3 Ref count %d \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMDevice3 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	if (parent2)
		IUNK(parent2)->Release();
}


DWORD C_dxj_Direct3dRMDevice3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMDevice3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMDevice3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMDevice3 [%d] Release %d \n",creationid,i);
	return i;
}



GETSET_OBJECT(_dxj_Direct3dRMDevice3);

CLONE_R(_dxj_Direct3dRMDevice3,Direct3DRMDevice3);
SETNAME_R(_dxj_Direct3dRMDevice3);
GETNAME_R(_dxj_Direct3dRMDevice3);
GETCLASSNAME_R(_dxj_Direct3dRMDevice3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMDevice3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMDevice3);

//CLONETO_RX(_dxj_Direct3dRMDevice3, WinDevice, IID_IDirect3DRMWinDevice);

PASS_THROUGH_R(_dxj_Direct3dRMDevice3,  update,     Update)
PASS_THROUGH1_R(_dxj_Direct3dRMDevice3, setDither,  SetDither, long)
PASS_THROUGH1_R(_dxj_Direct3dRMDevice3, setShades,  SetShades, int)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setBufferCount, SetBufferCount,long,(DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMDevice3, init, Init, long,(DWORD),long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setQuality, SetQuality, d3drmRenderQuality, (enum D3DRMRENDERQUALITY));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setTextureQuality,  SetTextureQuality, d3drmTextureQuality, (enum _D3DRMTEXTUREQUALITY));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setRenderMode, SetRenderMode,long,(DWORD));

GET_DIRECT_R(_dxj_Direct3dRMDevice3, getHeight,  GetHeight, int)
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getWidth,   GetWidth,  int)
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getDither,  GetDither, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getShades,  GetShades, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getQuality, GetQuality,long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getAppData, GetAppData,long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getColorModel,       GetColorModel, d3dColorModel);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getBufferCount,      GetBufferCount, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getTextureQuality,   GetTextureQuality, d3drmTextureQuality);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getTrianglesDrawn,   GetTrianglesDrawn, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getWireframeOptions, GetWireframeOptions, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getRenderMode,  GetRenderMode, long);


RETURN_NEW_ITEM_R(_dxj_Direct3dRMDevice3, getViewports, GetViewports, _dxj_Direct3dRMViewportArray);

															    
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::addUpdateCallback( I_dxj_Direct3dRMDeviceUpdateCallback3 *devC, IUnknown *args)
{
	// killed by companion DeleteUpdate
	DeviceUpdateCallback3 *ucb;

	ucb = (DeviceUpdateCallback3*)AddCallbackLink(
		(void**)&DeviceUpdateCallbacks3, (I_dxj_Direct3dRMCallback*)devC, (void*) args);
	if( !ucb )	{
		DPF(1,"AddUpdateCallback failed!\r\n");
		return E_FAIL;
	}
	if( FAILED(m__dxj_Direct3dRMDevice3->AddUpdateCallback((D3DRMDEVICE3UPDATECALLBACK)myAddUpdateCallback3, ucb)) )
		return E_FAIL;

	devC->AddRef();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::deleteUpdateCallback( I_dxj_Direct3dRMDeviceUpdateCallback3 *devC, IUnknown *args)
{
	DeviceUpdateCallback3 *ucb = DeviceUpdateCallbacks3;

	// look for our own specific entry
	for ( ;  ucb;  ucb = ucb->next )   {

		if( (ucb->c == devC) && (ucb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			m__dxj_Direct3dRMDevice3->DeleteUpdateCallback(
							(D3DRMDEVICE3UPDATECALLBACK)myAddUpdateCallback3, ucb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)ucb, 
								(GeneralCallback**)&DeviceUpdateCallbacks3);
			devC->Release();
			return S_OK;
		}
	}
	return E_FAIL;
}

#if 0

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::getDirect3dRMWinDevice(  I_dxj_Direct3dRMWinDevice __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMWINDEVICE pWinDev=NULL;
	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDev);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMWinDevice,pWinDev,retv);
	return hr;
}

#endif

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::getDirect3DDevice3(  I_dxj_Direct3dDevice3 __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DDEVICE2 pDev2=NULL;
	LPDIRECT3DDEVICE3 pDev3=NULL;
	hr=m__dxj_Direct3dRMDevice3->GetDirect3DDevice2(&pDev2); 

	if FAILED(hr) return hr;
	if (!retv) return E_INVALIDARG;
	*retv=NULL;

	if (!pDev2) return S_OK;

	hr=pDev2->QueryInterface(IID_IDirect3DDevice3,(void**)&pDev3);
	pDev2->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dDevice3,pDev3,retv);
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::findPreferredTextureFormat(       
			/* [in] */ long bitDepth,
            /* [in] */ long flags,
            /* [out][in] */ DDPixelFormat __RPC_FAR *ddpf) 
{
	HRESULT hr;
	
	DDPIXELFORMAT realDDPF;
	realDDPF.dwSize=sizeof(DDPIXELFORMAT);

	hr=m__dxj_Direct3dRMDevice3->FindPreferredTextureFormat((DWORD)bitDepth,(DWORD) flags,&realDDPF);
	if FAILED(hr) return hr;

	hr=CopyOutDDPixelFormat(ddpf,&realDDPF);
	if FAILED(hr) return hr;

	return hr;
}


//PASS_THROUGH_CAST_1_R(C_dxj_Direct3dRMDevice3Object, handleActivate, HandleActivate, int, (unsigned short))



/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP C_dxj_Direct3dRMDevice3Object::handlePaint(long hdcThing) 
{
	LPDIRECT3DRMWINDEVICE pWinDevice=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDevice);
	if FAILED(hr) return hr;

	hr=pWinDevice->HandlePaint((HDC)hdcThing);
	
	pWinDevice->Release();
	return hr;

	
}

STDMETHODIMP C_dxj_Direct3dRMDevice3Object::handleActivate(long wParam) 
{
	LPDIRECT3DRMWINDEVICE pWinDevice=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDevice);
	if FAILED(hr) return hr;

	hr=pWinDevice->HandleActivate((WORD)wParam);
	
	pWinDevice->Release();
	return hr;

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmfacearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmfacearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmFaceArrayObj.h : Declaration of the C_dxj_Direct3dRMFaceArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMFaceArray LPDIRECT3DRMFACEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFaceArrayObject : 
	public I_dxj_Direct3dRMFaceArray,
	//public CComCoClass<C_dxj_Direct3dRMFaceArrayObject, &CLSID__dxj_Direct3dRMFaceArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFaceArrayObject();
	virtual ~C_dxj_Direct3dRMFaceArrayObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMFaceArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFaceArray)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMFaceArray,	"DIRECT.Direct3dRMFaceArray.3",		"DIRECT.Direct3dRMFaceArray.3",    IDS_D3DRMFACEARRAY_DESC,    THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMFaceArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFaceArrayObject)

// I_dxj_Direct3dRMFaceArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFace **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFace2 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMFaceArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFaceArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmfacearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmfacearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFaceArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFaceArrayObj.h"
#include "d3drmFace2Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMFaceArray,{});
DESTRUCTOR( _dxj_Direct3dRMFaceArray,{});
GETSET_OBJECT(_dxj_Direct3dRMFaceArray);


GET_DIRECT_R(_dxj_Direct3dRMFaceArray, getSize, GetSize,  long);
#ifdef DX5
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMFaceArray, getElement, GetElement, _dxj_Direct3dRMFace, long,(DWORD));
#else


HRESULT C_dxj_Direct3dRMFaceArrayObject::getElement(long i, I_dxj_Direct3dRMFace2 **face2){
	HRESULT hr;
	IDirect3DRMFace  *realface=NULL;
	IDirect3DRMFace2 *realface2=NULL;

	hr=m__dxj_Direct3dRMFaceArray->GetElement((DWORD)i,&realface);
	if FAILED(hr) return hr;

	hr=realface->QueryInterface(IID_IDirect3DRMFace2,(void**)&realface2);
	realface->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFace2,(IDirect3DRMFace2*)realface2,face2);
	return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmframearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.h : Declaration of the C_dxj_Direct3dRMFrameArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMFrameArray LPDIRECT3DRMFRAMEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFrameArrayObject : 
	
	//public CComDualImpl<I_dxj_Direct3dRMFrameArray, &IID_I_dxj_Direct3dRMFrameArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMFrameArray,
	//public CComCoClass<C_dxj_Direct3dRMFrameArrayObject, &CLSID__dxj_Direct3dRMFrameArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFrameArrayObject() ;
	virtual ~C_dxj_Direct3dRMFrameArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMFrameArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrameArray)
		//COM_INTERFACE_ENTRY(IDispatch)
		//COM_INTERFACE_ENTRY(ISupportErrorInfo)

	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMFrameArray,	"DIRECT.Direct3dRMFrameArray.3",	"DIRECT.Direct3dRMFrameArray.3",   IDS_D3DRMFRAMEARRAY_DESC,   THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMFrameArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrameArrayObject)
	

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// I_dxj_Direct3dRMFrameArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);

#if DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFrame2 **lplpD3DRMFrame);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFrame3 **lplpD3DRMFrame);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMFrameArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrameArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframeinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframeinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrameInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMFrameInterpolator;


//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMFrameInterpolatorObject::C_dxj_Direct3dRMFrameInterpolatorObject(){
	m__dxj_Direct3dRMFrameInterpolator=NULL;
	m__dxj_Direct3dRMFrame3=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMFrameInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMFrameInterpolator;
	g_dxj_Direct3dRMFrameInterpolator = (void *)this;
}


C_dxj_Direct3dRMFrameInterpolatorObject::~C_dxj_Direct3dRMFrameInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMFrameInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMFrameInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMFrameInterpolatorObject *ptr=(C_dxj_Direct3dRMFrameInterpolatorObject *)g_dxj_Direct3dRMFrameInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMFrameInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMFrameInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMFrameInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMFrameInterpolator)->Release(); 
		
		DPF1(1,"DirectX real IDirect3dRMFrameInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMFrameInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMFrame3)
			m__dxj_Direct3dRMFrame3->Release();

}


DWORD C_dxj_Direct3dRMFrameInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMFrameInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMFrameInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMFrameInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMFrameInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMFrameInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMFrame3,(void**)&m__dxj_Direct3dRMFrame3);	
	return hr;
}



HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMFrameInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMFrameInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMFrameInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	
	return S_OK;
}
        

HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMFrameInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMFrameInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;
	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	




	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

 	hr= m__dxj_Direct3dRMFrameInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();			
		

	

	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setVelocity( I_dxj_Direct3dRMFrame3 *reference, d3dvalue x, d3dvalue y, 
									d3dvalue z, long with_rotation)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->SetVelocity((LPDIRECT3DRMFRAME3)lpf, x, y, z, with_rotation);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setOrientation( I_dxj_Direct3dRMFrame3 *reference, d3dvalue dx,d3dvalue dy,d3dvalue dz, d3dvalue ux,d3dvalue uy,d3dvalue uz)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetOrientation((LPDIRECT3DRMFRAME3)f, dx, dy, dz, ux, uy, uz);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setPosition(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,d3dvalue z)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetPosition((LPDIRECT3DRMFRAME3)f, x, y, z);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setRotation(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,
											d3dvalue z,d3dvalue theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetRotation((LPDIRECT3DRMFRAME3)f, x, y, z, theta);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setQuaternion(I_dxj_Direct3dRMFrame3 *refer,D3dRMQuaternion *quat)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetQuaternion(f,(D3DRMQUATERNION*)quat);
	return hr;

}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setColor(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetColor((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setColorRGB(float r, float g, float b)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetColorRGB(r,g,b);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneBackground(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackground((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneBackgroundRGB(float r, float g, float b)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundRGB(r,g,b);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneFogColor(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneFogColor((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneFogParams(float start, float end, float density)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneFogParams(start,end,density);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframe3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframe3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameObj.cpp : Implementation of CDirectApp and DLL registration.



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmLightObj.h"
#include "d3drmLightArrayObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmVisualObj.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmMeshObj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "ddSurface7Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmUserVisualObj.h"
#include "d3drmObjectObj.h"


extern HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags);
extern HRESULT BSTRtoGUID(LPGUID pGuid,BSTR bstr);

C_dxj_Direct3dRMFrame3Object::C_dxj_Direct3dRMFrame3Object(){
	m__dxj_Direct3dRMFrame3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMFrame3[%d] \n ",g_creationcount);

	nextobj =  g_dxj_Direct3dRMFrame3;
	g_dxj_Direct3dRMFrame3 = (void *)this;
}


C_dxj_Direct3dRMFrame3Object::~C_dxj_Direct3dRMFrame3Object()
{
    C_dxj_Direct3dRMFrame3Object *prev=NULL; 
	for(C_dxj_Direct3dRMFrame3Object *ptr=(C_dxj_Direct3dRMFrame3Object *)g_dxj_Direct3dRMFrame3; ptr; ptr=(C_dxj_Direct3dRMFrame3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMFrame3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMFrame3){
		int count = IUNK(m__dxj_Direct3dRMFrame3)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirect3DRMFrame3 Ref count %d \n",count);
		#endif

		if(count==0) m__dxj_Direct3dRMFrame3 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}


GETSET_OBJECT(_dxj_Direct3dRMFrame3);

CLONE_R(_dxj_Direct3dRMFrame3, Direct3DRMFrame3);
GETNAME_R(_dxj_Direct3dRMFrame3);
SETNAME_R(_dxj_Direct3dRMFrame3);
GETCLASSNAME_R(_dxj_Direct3dRMFrame3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMFrame3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMFrame3);



RETURN_NEW_ITEM_R(_dxj_Direct3dRMFrame3, getChildren, GetChildren, _dxj_Direct3dRMFrameArray);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMFrame3, getLights,GetLights,_dxj_Direct3dRMLightArray);


GET_DIRECT_R(_dxj_Direct3dRMFrame3, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getMaterialMode, GetMaterialMode, d3drmMaterialMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSortMode, GetSortMode, d3drmSortMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneBackground, GetSceneBackground, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogColor, GetSceneFogColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogEnable, GetSceneFogEnable, long);  //BOOL
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogMode, GetSceneFogMode, d3drmFogMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getZBufferMode, GetZbufferMode, d3drmZbufferMode);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFrame3, addLight, AddLight, _dxj_Direct3dRMLight);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFrame3, deleteLight, DeleteLight, _dxj_Direct3dRMLight);


PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneBackground, SetSceneBackground, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneFogEnable, SetSceneFogEnable, long);  //BOOL
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneFogColor, SetSceneFogColor, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setColor, SetColor, d3dcolor);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, move, Move, d3dvalue);
//PASS_THROUGH2_R(_dxj_Direct3dRMFrame3, getTextureTopology, GetTextureTopology, int*, int*);
//PASS_THROUGH2_R(_dxj_Direct3dRMFrame3, setTextureTopology, SetTextureTopology, int, int);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, getSceneFogParams, GetSceneFogParams, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setSceneBackgroundRGB, SetSceneBackgroundRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setSceneFogParams, SetSceneFogParams, d3dvalue,d3dvalue,d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setColorRGB, SetColorRGB, d3dvalue,d3dvalue,d3dvalue);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setSceneFogMode, SetSceneFogMode, d3drmFogMode, (D3DRMFOGMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setMaterialMode, SetMaterialMode, d3drmMaterialMode, (enum _D3DRMMATERIALMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setSortMode, SetSortMode, d3drmSortMode,(enum _D3DRMSORTMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setZbufferMode, SetZbufferMode, d3drmZbufferMode, (enum _D3DRMZBUFFERMODE) );
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMFrame3, addScale, AddScale, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMFrame3, addTranslation, AddTranslation, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));
PASS_THROUGH_CAST_5_R(_dxj_Direct3dRMFrame3, addRotation, AddRotation, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addVisual(I_dxj_Direct3dRMVisual *f){
	IDirect3DRMVisual	 *vis=NULL;
	IUnknown			 *unk=NULL;
	HRESULT				 hr;

	if (f==NULL) return E_INVALIDARG;

	((I_dxj_Direct3dRMVisual*)f)->InternalGetObject(&unk);
	if FAILED(unk->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis))
		return E_INVALIDARG;
	
	hr= m__dxj_Direct3dRMFrame3->AddVisual(vis); 

	if (vis) vis->Release();
	
	return hr;

}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteVisual(I_dxj_Direct3dRMVisual *f){
	IDirect3DRMVisual	 *vis=NULL;
	IUnknown			 *unk=NULL;
	HRESULT hr;

	if (f==NULL) return E_INVALIDARG;
	f->InternalGetObject(&unk);
	if FAILED(unk->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis))
		return E_INVALIDARG;
	
	hr= m__dxj_Direct3dRMFrame3->DeleteVisual(vis); 

	if (vis) vis->Release ();
	return hr;

}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisuals(I_dxj_Direct3dRMVisualArray **retv)
{
	LPDIRECT3DRMVISUALARRAY lpv;
	HRESULT hr;
	LPDIRECT3DRMFRAME2 frame2;
	hr=m__dxj_Direct3dRMFrame3->QueryInterface(IID_IDirect3DRMFrame2,(void**)&frame2);
	if FAILED(hr) return hr;
	frame2->GetVisuals(&lpv);
	frame2->Release();
	INTERNAL_CREATE(_dxj_Direct3dRMVisualArray, lpv, retv);
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVelocity(I_dxj_Direct3dRMFrame3 *ref, D3dVector *vel, long flags)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetVelocity((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)vel, (DWORD)flags);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getRotation(I_dxj_Direct3dRMFrame3 *ref, 
											D3dVector *axis, d3dvalue *theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetRotation((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)axis, (D3DVALUE*)theta);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getPosition(I_dxj_Direct3dRMFrame3 *ref, D3dVector *position)
{

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetPosition((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)position);
}

/////////////////////////////////////////////////////////////////////////////
//	PASS_THROUGH_CAST_3(_dxj_Direct3dRMFrame, LookAt, I_dxj_Direct3dRMFrame*, (LPDIRECT3DRMFRAME3),
//		I_dxj_Direct3dRMFrame*, (LPDIRECT3DRMFRAME3), d3drmFrameConstraint, (_D3DRMFRAMECONSTRAINT));
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::lookAt(I_dxj_Direct3dRMFrame3 *tgt, 
							   I_dxj_Direct3dRMFrame3 *ref,d3drmFrameConstraint axis)
{
//	if(! (tgt && ref) )
//		return E_POINTER;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpr, ref);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpt, tgt);

	return m__dxj_Direct3dRMFrame3->LookAt((LPDIRECT3DRMFRAME3)lpt,(LPDIRECT3DRMFRAME3) lpr, (enum _D3DRMFRAMECONSTRAINT)axis);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addTransform(d3drmCombineType typ, SAFEARRAY **ppmat)
{
	
	D3DVALUE rmMatrix[4][4];
	CopyFloats((d3dvalue*)rmMatrix, (float*)((SAFEARRAY*)*ppmat)->pvData, 16 );

	m__dxj_Direct3dRMFrame3->AddTransform((enum _D3DRMCOMBINETYPE)typ, rmMatrix );
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTransform(I_dxj_Direct3dRMFrame3 *ref,SAFEARRAY **ppmat)
{
	D3DVALUE rmMatrix[4][4];	// Get info to here
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,f3,ref);
	hr=m__dxj_Direct3dRMFrame3->GetTransform(f3,rmMatrix);
	if FAILED(hr) return hr;

	CopyFloats((float*)((SAFEARRAY*)*ppmat)->pvData, (d3dvalue*)rmMatrix, 16 );
	return(S_OK);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addMoveCallback( I_dxj_Direct3dRMFrameMoveCallback3 *fmC, IUnknown *args, long flags)
{
	// killed by companion DeleteMove
	FrameMoveCallback3 *fmcb;
	if (!fmC) return E_INVALIDARG;

	fmcb = (FrameMoveCallback3*)AddCallbackLink(
			(void**)&FrameMoveCallbacks3, (I_dxj_Direct3dRMCallback*)fmC, (void*) args);
	if( !fmcb )
	{
		DPF(1,"Callback AddMove creation failed!\r\n");
		return E_FAIL;
	}

	fmC->AddRef();

	return m__dxj_Direct3dRMFrame3->AddMoveCallback(myFrameMoveCallback3, fmcb, (DWORD) flags);
}

///////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteMoveCallback(I_dxj_Direct3dRMFrameMoveCallback3 *fmC, IUnknown *args)
{
	DPF(1,"DeleteMoveCallback entered!\r\n");


	FrameMoveCallback3 *fmcb = FrameMoveCallbacks3;

	// look for our own specific entry
	for ( ;  fmcb;  fmcb = fmcb->next )   {

		if( (fmcb->c == fmC) && (fmcb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			m__dxj_Direct3dRMFrame3->DeleteMoveCallback(myFrameMoveCallback3, fmcb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)fmcb, 
									(GeneralCallback**)&FrameMoveCallbacks3);
			return S_OK;
		}
	}
	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setVelocity( I_dxj_Direct3dRMFrame3 *reference, d3dvalue x, d3dvalue y, 
									d3dvalue z, long with_rotation)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->SetVelocity((LPDIRECT3DRMFRAME3)lpf, x, y, z, with_rotation);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getOrientation( I_dxj_Direct3dRMFrame3 *reference, D3dVector *dir, D3dVector *up)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->GetOrientation(lpf, (struct _D3DVECTOR *)dir, (struct _D3DVECTOR *)up);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::loadFromFile(BSTR filename, VARIANT id,long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, IUnknown *useMe)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;
	HRESULT hr;

	if( callme )
	{
		tcb = new TextureCallback3;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= NULL;   // TextureCallbacks3;
			tcb->prev			= NULL;   //(TextureCallback3*)NULL;
			TextureCallbacks3	= tcb;

			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");

			return E_FAIL;
		}
	}

	USES_CONVERSION;
	LPSTR pszName = NULL;
	__try { pszName = W2T(filename); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	
	
	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		__try { args=(void*)W2T(V_BSTR(&id)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMFrame3->Load((void *)&res,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);
	}
	else {
		hr = m__dxj_Direct3dRMFrame3->Load((void *)pszName,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);
	}


	if (tcb)
	{
		delete tcb;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setOrientation( I_dxj_Direct3dRMFrame3 *reference, d3dvalue dx,d3dvalue dy,d3dvalue dz, d3dvalue ux,d3dvalue uy,d3dvalue uz)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetOrientation((LPDIRECT3DRMFRAME3)f, dx, dy, dz, ux, uy, uz);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setPosition(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,d3dvalue z)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetPosition((LPDIRECT3DRMFRAME3)f, x, y, z);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setRotation(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,
											d3dvalue z,d3dvalue theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetRotation((LPDIRECT3DRMFRAME3)f, x, y, z, theta);
}

/////////////////////////////////////////////////////////////////////////////
// remove this frame from the callback list. (After debugging, put this into
// the destructor macro at the tof).
//

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::transform(D3dVector* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMFrame3->Transform( (D3DVECTOR *)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::inverseTransform(D3dVector* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMFrame3->InverseTransform( (D3DVECTOR *)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getParent(I_dxj_Direct3dRMFrame3 **ret)
{
	HRESULT hr;

	IDirect3DRMFrame3 *lpFrame3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetParent(&lpFrame3);

	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpFrame3==NULL) return S_OK;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame3, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getScene(I_dxj_Direct3dRMFrame3 **ret)
{
	HRESULT hr;	
	IDirect3DRMFrame3 *lpFrame3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetScene(&lpFrame3);	
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpFrame3==NULL) return S_OK;


	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame3, ret);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTexture(I_dxj_Direct3dRMTexture3 **ret)
{
	HRESULT hr;
	IDirect3DRMTexture *tex=NULL;
	IDirect3DRMTexture3 *lpTex3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetTexture(&lpTex3);
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpTex3==NULL) return S_OK;
	
	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpTex3, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getSceneBackgroundDepth(I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	IDirectDrawSurface7 *lpSurf7=NULL;
	IDirectDrawSurface *lpSurf=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetSceneBackgroundDepth(&lpSurf);
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpSurf==NULL) return S_OK;

	if FAILED(lpSurf->QueryInterface(IID_IDirectDrawSurface7,(void**)&lpSurf7)){
		lpSurf->Release();
		return E_NOINTERFACE;
	}
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf7, ret);
	lpSurf->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneBackgroundDepth(I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	if (!surf) return E_INVALIDARG;
	LPDIRECTDRAWSURFACE s=NULL;

	//Get our real surface s7 becomes NULL if surf is NULL
	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, s7, surf);
	if (s7){
		hr=s7->QueryInterface(IID_IDirectDrawSurface,(void**)&s);
		if FAILED(hr) return hr;		
	}	
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundDepth(s);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneBackgroundImage(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMTEXTURE3, t, tex);
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundImage(t);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMTexture3*, t, tex);
	hr= m__dxj_Direct3dRMFrame3->SetTexture(t);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addChild(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, frame);
	hr= m__dxj_Direct3dRMFrame3->AddChild(f);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteChild(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, frame);
	hr= m__dxj_Direct3dRMFrame3->DeleteChild(f);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getAxes(D3dVector *dir,D3dVector *up)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetAxes((D3DVECTOR*)dir,(D3DVECTOR*)up);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetBox((D3DRMBOX*)box);
	return S_OK;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getBoxEnable(long *box)
{
	HRESULT hr=S_OK;	
	
	*box= m__dxj_Direct3dRMFrame3->GetBoxEnable();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getHierarchyBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetHierarchyBox((D3DRMBOX*)box);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getInheritAxes(long *box)
{
	HRESULT hr=S_OK;	
	
	*box= m__dxj_Direct3dRMFrame3->GetInheritAxes();
	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setAxes(float dx,float dy,float dz, float ux,float uy,float uz)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->SetAxes(dx,dy,dz,ux,uy,uz);
	return hr;
}
	

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->SetBox((D3DRMBOX*)box);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setInheritAxes(long bl)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetInheritAxes(bl);
	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setBoxEnable(long bl)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetBoxEnable(bl);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setQuaternion(I_dxj_Direct3dRMFrame3 *refer,D3dRMQuaternion *quat)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetQuaternion(f,(D3DRMQUATERNION*)quat);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::rayPick(I_dxj_Direct3dRMFrame3 *refer,D3dRMRay *ray,long flags,I_dxj_Direct3dRMPick2Array **retv)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	LPDIRECT3DRMPICKED2ARRAY lpArray=NULL;
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->RayPick(f,(D3DRMRAY*)ray,(DWORD)flags,&lpArray);		
	INTERNAL_CREATE(_dxj_Direct3dRMPick2Array, lpArray, retv);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::save(BSTR name,long format,long flags)
{
	//RM FAILED TO IMPLEMENT FRAME SAVE SO
	//IT ALWAYS RETURNS E_NOTIMPL
	//CONGPA PROVIDED A LIBRARY FOR SAVING
	//return E_NOTIMPL;

	USES_CONVERSION;
	LPSTR pszNam = NULL;
	__try { pszNam = W2T(name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	HRESULT hr;
	//hr= m__dxj_Direct3dRMFrame3->Save(pszNam,(D3DRMXOFFORMAT)format,(DWORD)flags);

	hr=FrameToXFile(m__dxj_Direct3dRMFrame3,
                     pszNam,
                     (D3DRMXOFFORMAT)format,
                     (D3DRMSAVEOPTIONS) flags);


	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setTraversalOptions(long flags)
{
	HRESULT hr;
	hr= m__dxj_Direct3dRMFrame3->SetTraversalOptions((DWORD)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTraversalOptions(long *flags)
{
	HRESULT hr;
	hr= m__dxj_Direct3dRMFrame3->GetTraversalOptions((DWORD*)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::transformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,ref,reference);
	if (!reference) ref=NULL;

	__try{
		hr= m__dxj_Direct3dRMFrame3->TransformVectors(ref,(DWORD)num,
						(D3DVECTOR*)((SAFEARRAY*)*DstVectors)->pvData,
						(D3DVECTOR*)((SAFEARRAY*)*SrcVectors)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::inverseTransformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,ref,reference);	

	__try{
		hr= m__dxj_Direct3dRMFrame3->InverseTransformVectors(ref,(DWORD)num,
						(D3DVECTOR*)((SAFEARRAY*)*DstVectors)->pvData,
						(D3DVECTOR*)((SAFEARRAY*)*SrcVectors)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

         


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterial(I_dxj_Direct3dRMMaterial2 **ret)
{
	HRESULT hr;

	IDirect3DRMMaterial2 *lpMat2=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetMaterial(&lpMat2);
	*ret=NULL;
	if FAILED(hr) return hr;	
	INTERNAL_CREATE(_dxj_Direct3dRMMaterial2, lpMat2, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterial(I_dxj_Direct3dRMMaterial2 *mat)
{
	HRESULT hr;
	if (mat==NULL) 
		return m__dxj_Direct3dRMFrame3->SetMaterial(NULL);

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMATERIAL2,lpMat2,mat);	
	hr= m__dxj_Direct3dRMFrame3->SetMaterial(lpMat2);	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterialOverride(D3dMaterialOverride *override)
{
	HRESULT hr;

	if (!override) return E_INVALIDARG;	
	override->lSize=sizeof(D3DRMMATERIALOVERRIDE);

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride((D3DRMMATERIALOVERRIDE*)override);	
	if FAILED(hr) return hr;	
	if (((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex)
		(((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex)->Release();
		
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterialOverride(D3dMaterialOverride *override)
{
	HRESULT hr;
	
	if (!override) return E_INVALIDARG;		
	D3DRMMATERIALOVERRIDE override2;
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override->lSize=sizeof(D3DRMMATERIALOVERRIDE);
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	
	((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex=override2.lpD3DRMTex;
	hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride((D3DRMMATERIALOVERRIDE*)override);		
	if (override2.lpD3DRMTex) override2.lpD3DRMTex->Release();
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterialOverrideTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	
	
	D3DRMMATERIALOVERRIDE override2;	
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);
	

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	if (override2.lpD3DRMTex) override2.lpD3DRMTex->Release();
	override2.lpD3DRMTex=NULL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,t,tex);
	
	if (!tex) {
		hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride(&override2);	
	}
	else {
		
		override2.lpD3DRMTex=t;
		override2.lpD3DRMTex->AddRef();
		hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride(&override2);			
		override2.lpD3DRMTex->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterialOverrideTexture(I_dxj_Direct3dRMTexture3 **tex)
{
	HRESULT hr;
	
	
	D3DRMMATERIALOVERRIDE override2;	
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);
	

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	if (override2.lpD3DRMTex){
		INTERNAL_CREATE(_dxj_Direct3dRMTexture3,override2.lpD3DRMTex,tex);
		return hr;
	}
	
	*tex=NULL;
	return S_OK;;
}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisual(long index,I_dxj_Direct3dRMVisual **ret)
{
	HRESULT hr;
	DWORD count=0;
	IUnknown **ppUnk=NULL;
	IDirect3DRMVisual *vis=NULL;

	*ret=NULL;

	hr=m__dxj_Direct3dRMFrame3->GetVisuals(&count,NULL);
	if FAILED(hr) return hr;

	if (count==0) return E_INVALIDARG;

	ppUnk=(IUnknown**)malloc(sizeof(IUnknown*)*count);
	if (!ppUnk) return E_OUTOFMEMORY;

	hr=m__dxj_Direct3dRMFrame3->GetVisuals(&count,ppUnk);
	if FAILED(hr) goto exitOut;
	
	hr= ppUnk[index]->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis);
	if FAILED(hr) goto exitOut;

	hr=CreateCoverVisual(vis,ret);
	if FAILED(hr) goto exitOut;

	
exitOut:

	for (DWORD i=0;i<count;i++){
		if (ppUnk[index]) ppUnk[index]->Release();
	}

	free(ppUnk);	

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisualCount (long *count)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->GetVisuals((DWORD*)count,NULL);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneFogMethod (long meth)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->SetSceneFogMethod(meth);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getSceneFogMethod (long *meth)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->GetSceneFogMethod((DWORD*)meth);
	return hr;
}

			

/////////////////////////////////////////////////////////////////////////////
extern "C" void __cdecl myFrameMoveCallback3( LPDIRECT3DRMFRAME3 lpf, void *lpArg, D3DVALUE delta)
{

	DPF(1,"Entered myFrameMoveCallback3\r\n");


	FrameMoveCallback3 *fmcb = (FrameMoveCallback3 *)lpArg;

	// note: need to get OUR frame object from the direct frame object, if
	//         one exists. If not, we have a crisis!
	for( C_dxj_Direct3dRMFrame3Object *that = (C_dxj_Direct3dRMFrame3Object *)g_dxj_Direct3dRMFrame3; that ; that = (C_dxj_Direct3dRMFrame3Object *)that->nextobj )
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, f, that)
		if( f == lpf )
		{
			if (fmcb->pUser) fmcb->pUser->AddRef();
			
			IUNK(that)->AddRef();
		
			fmcb->c->callbackRMFrameMove(that,fmcb->pUser, delta);

			IUNK(that)->Release();

			if (fmcb->pUser) fmcb->pUser->Release();


			return;
		}
	}

	//
	// I didn't create this frame, create a new one 
	//
	C_dxj_Direct3dRMFrame3Object *c=new CComObject<C_dxj_Direct3dRMFrame3Object>;
	I_dxj_Direct3dRMFrame3 *Iframe=NULL;
	if( c == NULL )
	{ 
		lpf->Release(); 
		return;
	} 
	c->InternalSetObject((LPDIRECT3DRMFRAME3)lpf);
	
	if ( fmcb->pParent )
	{
		c->parent = fmcb->pParent;
		fmcb->pParent->AddRef();
	}
	if (FAILED(((I_dxj_Direct3dRMFrame3*)c)->QueryInterface(IID_I_dxj_Direct3dRMFrame3, (void **)&Iframe))) 
	{
		delete c;
		return;
	}

	c->pinterface = Iframe; 
	
	if (fmcb->pUser) fmcb->pUser->AddRef();

	IUNK(Iframe)->AddRef();
	
	fmcb->c->callbackRMFrameMove(Iframe, fmcb->pUser, delta);
	
	IUNK(Iframe)->Release();
	
	if (fmcb->pUser) fmcb->pUser->Release();


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframe3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframe3obj.h
//
//--------------------------------------------------------------------------

// d3drmFrameObj.h : Declaration of the C_dxj_Direct3dRMFrame3Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"
#include "d3drmPick2ArrayObj.h"
#define typedef__dxj_Direct3dRMFrame3 LPDIRECT3DRMFRAME3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

//		public CComCoClass<Cproj3, &CLSID_proj3>,
	

class C_dxj_Direct3dRMFrame3Object : 
    public CComObjectRoot,
	public I_dxj_Direct3dRMFrame3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual
	
{
public:

BEGIN_COM_MAP(C_dxj_Direct3dRMFrame3Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrame3)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)

END_COM_MAP()


	C_dxj_Direct3dRMFrame3Object();
	virtual ~C_dxj_Direct3dRMFrame3Object();


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrame3Object)

// I_dxj_Direct3dRMFrame3
public:

	
	         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *v);
        
         HRESULT STDMETHODCALLTYPE deleteVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *v);
        
         HRESULT STDMETHODCALLTYPE addLight( 
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE deleteLight( 
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *l);
        
         HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *child);
        
         HRESULT STDMETHODCALLTYPE deleteChild( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *referenceFrame,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE addTransform( 
            /* [in] */ d3drmCombineType t,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE addTranslation( 
            /* [in] */ d3drmCombineType t,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE addScale( 
            /* [in] */ d3drmCombineType combineType,
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
         HRESULT STDMETHODCALLTYPE addRotation( 
            /* [in] */ d3drmCombineType combineType,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE addMoveCallback( 
            /* [in] */ I_dxj_Direct3dRMFrameMoveCallback3 __RPC_FAR *frameMoveImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE deleteMoveCallback( 
            /* [in] */ I_dxj_Direct3dRMFrameMoveCallback3 __RPC_FAR *frameMoveImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument);
        
         HRESULT STDMETHODCALLTYPE transform( 
            /* [out][in] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE transformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors);
        
         HRESULT STDMETHODCALLTYPE inverseTransform( 
            /* [out][in] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE inverseTransformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors);
        
         HRESULT STDMETHODCALLTYPE getAxes( 
            /* [out][in] */ D3dVector __RPC_FAR *dir,
            /* [out][in] */ D3dVector __RPC_FAR *up);
        
         HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE getBoxEnable( 
            /* [retval][out] */ long __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getChildren( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameArray __RPC_FAR *__RPC_FAR *children);
        
         HRESULT STDMETHODCALLTYPE getColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getHierarchyBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE getInheritAxes( 
            /* [retval][out] */ long __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getLights( 
            /* [retval][out] */ I_dxj_Direct3dRMLightArray __RPC_FAR *__RPC_FAR *lights);
        
         HRESULT STDMETHODCALLTYPE getMaterial( 
            I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getMaterialMode( 
            /* [retval][out] */ d3drmMaterialMode __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *dir,
            /* [out][in] */ D3dVector __RPC_FAR *up);
        
         HRESULT STDMETHODCALLTYPE getMaterialOverride( 
            /* [out][in] */ D3dMaterialOverride __RPC_FAR *override);
        
         HRESULT STDMETHODCALLTYPE getMaterialOverrideTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getParent( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *axis,
            /* [out] */ float __RPC_FAR *theta);
        
         HRESULT STDMETHODCALLTYPE getScene( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneBackground( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneBackgroundDepth( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogEnable( 
            /* [retval][out] */ long __RPC_FAR *enable);
        
         HRESULT STDMETHODCALLTYPE getSceneFogMode( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogMethod( 
            /* [retval][out] */ long __RPC_FAR *method);
        
         HRESULT STDMETHODCALLTYPE getSceneFogParams( 
            /* [out][in] */ float __RPC_FAR *start,
            /* [out][in] */ float __RPC_FAR *end,
            /* [out][in] */ float __RPC_FAR *density);
        
         HRESULT STDMETHODCALLTYPE getSortMode( 
            /* [retval][out] */ d3drmSortMode __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ref);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *vel,
            /* [in] */ long includeRotationalVelocity);
        
         HRESULT STDMETHODCALLTYPE getVisuals( 
            /* [retval][out] */ I_dxj_Direct3dRMVisualArray __RPC_FAR *__RPC_FAR *visuals);
        
         HRESULT STDMETHODCALLTYPE getVisual( 
            /* [in] */ long index,
            /* [retval][out] */ I_dxj_Direct3dRMVisual __RPC_FAR *__RPC_FAR *visualArray);
        
         HRESULT STDMETHODCALLTYPE getVisualCount( 
            /* [retval][out] */ long __RPC_FAR *vis);
        
         HRESULT STDMETHODCALLTYPE getTraversalOptions( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getZBufferMode( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *loadTextureImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument);
        
         HRESULT STDMETHODCALLTYPE lookAt( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *tgt,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ d3drmFrameConstraint contraint);
        
         HRESULT STDMETHODCALLTYPE move( 
            /* [in] */ float delta);
        
         HRESULT STDMETHODCALLTYPE rayPick( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *refer,
            /* [in] */ D3dRMRay __RPC_FAR *ray,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMPick2Array __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ BSTR name,
            /* [in] */ d3drmXofFormat format,
            /* [in] */ d3drmSaveFlags flags);
        
         HRESULT STDMETHODCALLTYPE setAxes( 
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setBox( 
            /* [in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE setBoxEnable( 
            /* [in] */ long boxEnable);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setInheritAxes( 
            /* [in] */ long inheritFromParent);
        
         HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *mat);
        
         HRESULT STDMETHODCALLTYPE setMaterialMode( 
            /* [in] */ d3drmMaterialMode val);
        
         HRESULT STDMETHODCALLTYPE setMaterialOverride( 
            /* [out][in] */ D3dMaterialOverride __RPC_FAR *override);
        
         HRESULT STDMETHODCALLTYPE setMaterialOverrideTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *tex);
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE setQuaternion( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            D3dRMQuaternion __RPC_FAR *quat);
        
         HRESULT STDMETHODCALLTYPE setRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE setSceneBackground( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundDepth( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundImage( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *i);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setSceneFogColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogEnable( 
            /* [in] */ long enable);
        
         HRESULT STDMETHODCALLTYPE setSceneFogMethod( 
            /* [in] */ long method);
        
         HRESULT STDMETHODCALLTYPE setSceneFogMode( 
            /* [in] */ long c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogParams( 
            /* [in] */ float start,
            /* [in] */ float end,
            /* [in] */ float density);
        
         HRESULT STDMETHODCALLTYPE setSortMode( 
            /* [in] */ d3drmSortMode val);
        
         HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE setTraversalOptions( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long with_rotation);
        
         HRESULT STDMETHODCALLTYPE setZbufferMode( 
            /* [in] */ d3drmZbufferMode val);
        	
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMFrame3);

private:

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrame3 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframeinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframeinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMFrameInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMFrameInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMFrameInterpolatorObject : 
	public I_dxj_Direct3dRMFrameInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFrameInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMFrameInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMFrameInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrameInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrameInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        

         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE setQuaternion( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            D3dRMQuaternion __RPC_FAR *quat);
        
         HRESULT STDMETHODCALLTYPE setRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long with_rotation);
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setSceneBackground( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setSceneFogParams( 
            /* [in] */ float start,
            /* [in] */ float end,
            /* [in] */ float density);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);

    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMFrameInterpolator);
	LPDIRECT3DRMFRAME3	m__dxj_Direct3dRMFrame3;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrameInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmframearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmFrame3Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMFrameArray, {});
DESTRUCTOR(_dxj_Direct3dRMFrameArray, {});
GETSET_OBJECT(_dxj_Direct3dRMFrameArray);

GET_DIRECT_R(_dxj_Direct3dRMFrameArray,getSize, GetSize, long)



HRESULT C_dxj_Direct3dRMFrameArrayObject::getElement(long i, I_dxj_Direct3dRMFrame3 **frame){
	HRESULT hr;
	IDirect3DRMFrame  *realframe=NULL;
	IDirect3DRMFrame3 *realframe3=NULL;

	hr=m__dxj_Direct3dRMFrameArray->GetElement((DWORD)i,&realframe);
	if FAILED(hr) return hr;

	hr=realframe->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realframe3);
	realframe->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe3,frame);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightarrayobj.cpp
//
//--------------------------------------------------------------------------

// _dxj_Direct3dRMLightArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmLightArrayObj.h"
#include "d3drmLightObj.h"

CONSTRUCTOR(_dxj_Direct3dRMLightArray, {});
DESTRUCTOR(_dxj_Direct3dRMLightArray, {});
GETSET_OBJECT(_dxj_Direct3dRMLightArray);

GET_DIRECT_R(_dxj_Direct3dRMLightArray,getSize,GetSize, long)
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMLightArray,getElement,GetElement,_dxj_Direct3dRMLight,long,(DWORD))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmLightArrayObj.h : Declaration of the C_dxj_Direct3dRMLightArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMLightArray LPDIRECT3DRMLIGHTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMLightArrayObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_Direct3dRMLightArray, &IID_I_dxj_Direct3dRMLightArray, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_Direct3dRMLightArray,
#endif
	//public CComCoClass<C_dxj_Direct3dRMLightArrayObject, &CLSID__dxj_Direct3dRMLightArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightArrayObject() ;
	virtual ~C_dxj_Direct3dRMLightArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMLightArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLightArray)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMLightArray,	"DIRECT.Direct3dRMLightArray.3",	"DIRECT.Direct3dRMLightArray.3",   IDS_D3DRMLIGHTARRAY_DESC,   THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMLightArrayObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightArrayObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// I_dxj_Direct3dRMLightArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)(long *retval);
    STDMETHOD(getElement)(long index, I_dxj_Direct3dRMLight **retval);

private:
    DECL_VARIABLE(_dxj_Direct3dRMLightArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLightArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMLightInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMLightInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMLightInterpolatorObject : 
	public I_dxj_Direct3dRMLightInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMLightInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMLightInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLightInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        
         //HRESULT STDMETHODCALLTYPE setType( 
         //   /* [in] */ d3drmLightType t);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setRange( 
            /* [in] */ float rng);
        
         HRESULT STDMETHODCALLTYPE setUmbra( 
            /* [in] */ float u);
        
         HRESULT STDMETHODCALLTYPE setPenumbra( 
            /* [in] */ float p);
        
         HRESULT STDMETHODCALLTYPE setConstantAttenuation( 
            /* [in] */ float atn);
        
         HRESULT STDMETHODCALLTYPE setLinearAttenuation( 
            /* [in] */ float atn);
        
         HRESULT STDMETHODCALLTYPE setQuadraticAttenuation( 
            /* [in] */ float atn);


////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMLightInterpolator);
	LPDIRECT3DRMLIGHT	m__dxj_Direct3dRMLight;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLightInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightobj.cpp
//
//--------------------------------------------------------------------------

// d3drmLightObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrame3Obj.h"
#include "d3drmLightObj.h"

CONSTRUCTOR(_dxj_Direct3dRMLight, {});
DESTRUCTOR(_dxj_Direct3dRMLight, {});
GETSET_OBJECT(_dxj_Direct3dRMLight);

CLONE_R(_dxj_Direct3dRMLight,Direct3DRMLight);
GETNAME_R(_dxj_Direct3dRMLight);
SETNAME_R(_dxj_Direct3dRMLight);
GETCLASSNAME_R(_dxj_Direct3dRMLight);

ADDDESTROYCALLBACK_R(_dxj_Direct3dRMLight);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMLight);

GET_DIRECT_R(_dxj_Direct3dRMLight, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMLight, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMLight, getRange, GetRange, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getUmbra, GetUmbra, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getPenumbra, GetPenumbra, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getConstantAttenuation, GetConstantAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getLinearAttenuation, GetLinearAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getQuadraticAttenuation, GetQuadraticAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getType, GetType, d3drmLightType);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMLight, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setColor, SetColor, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setRange, SetRange, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setUmbra, SetUmbra, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setPenumbra, SetPenumbra, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setConstantAttenuation, SetConstantAttenuation, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setLinearAttenuation, SetLinearAttenuation, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setQuadraticAttenuation, SetQuadraticAttenuation, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMLight, setColorRGB, SetColorRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMLight, setType,  SetType, d3drmLightType, (enum _D3DRMLIGHTTYPE));

//RETURN_NEW_ITEM_R(_dxj_Direct3dRMLight, getEnableFrame, GetEnableFrame, _dxj_Direct3dRMFrame);
HRESULT C_dxj_Direct3dRMLightObject::getEnableFrame(I_dxj_Direct3dRMFrame3 **frame){
	HRESULT hr;
	IDirect3DRMFrame *realframe1=NULL;
	IDirect3DRMFrame3 *realframe=NULL;
	hr=m__dxj_Direct3dRMLight->GetEnableFrame(&realframe1);
	*frame=NULL;
	if FAILED(hr) return hr;

	if (realframe1){
		hr=realframe1->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realframe);
		if FAILED(hr) return hr;
		INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe,frame);
	}
	return S_OK;

}

HRESULT C_dxj_Direct3dRMLightObject::setEnableFrame(I_dxj_Direct3dRMFrame3 *frame){
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	IDirect3DRMFrame *realframe1=NULL;
	if (frame){
		frame->InternalGetObject((IUnknown**)&realframe);
		hr=realframe->QueryInterface(IID_IDirect3DRMFrame,(void**)&realframe1);
		if FAILED(hr) return hr;
	}
	
	hr=m__dxj_Direct3dRMLight->SetEnableFrame(realframe1);	

	if (realframe1) realframe1->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmLightInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMLightInterpolator;


C_dxj_Direct3dRMLightInterpolatorObject::C_dxj_Direct3dRMLightInterpolatorObject(){
	m__dxj_Direct3dRMLightInterpolator=NULL;
	m__dxj_Direct3dRMLight=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMLightInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMLightInterpolator;
	g_dxj_Direct3dRMLightInterpolator = (void *)this;
}


C_dxj_Direct3dRMLightInterpolatorObject::~C_dxj_Direct3dRMLightInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMLightInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMLightInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMLightInterpolatorObject *ptr=(C_dxj_Direct3dRMLightInterpolatorObject *)g_dxj_Direct3dRMLightInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMLightInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMLightInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMLightInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMLightInterpolator)->Release(); 
		
		DPF1(1,"DirectX real IDirect3dRMLightInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMLightInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMLight)
			m__dxj_Direct3dRMLight->Release();

}


DWORD C_dxj_Direct3dRMLightInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMLightInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMLightInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMLightInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMLightInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMLightInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMLightInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMLightInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMLight,(void**)&m__dxj_Direct3dRMLight);	
	return hr;
}



HRESULT C_dxj_Direct3dRMLightInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMLightInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMLightInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMLightInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMLightInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMLightInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMLightInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMLightInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMLightInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setType( long t)									
//{	
//	return m__dxj_Direct3dRMLight->SetType((D3DRMLIGHTTYPE)t);
//}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setColor( long c)									
{	
	return m__dxj_Direct3dRMLight->SetColor((DWORD)c);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setColorRGB( float r, float g, float b)
{	
	return m__dxj_Direct3dRMLight->SetColorRGB(r,g,b);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setRange(float r)
{	
	return m__dxj_Direct3dRMLight->SetRange(r);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setUmbra(float u)
{	
	return m__dxj_Direct3dRMLight->SetUmbra(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setPenumbra(float u)
{	
	return m__dxj_Direct3dRMLight->SetPenumbra(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setConstantAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetConstantAttenuation(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setLinearAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetLinearAttenuation(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setQuadraticAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetQuadraticAttenuation(u);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmlightobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_Direct3dRMLightObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMLight LPDIRECT3DRMLIGHT

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMLightObject : 
	public I_dxj_Direct3dRMLight,
	public I_dxj_Direct3dRMObject,
	//public CComCoClass<C_dxj_Direct3dRMLightObject, &CLSID__dxj_Direct3dRMLight>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightObject();
	virtual ~C_dxj_Direct3dRMLightObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMLightObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLight)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

	//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMLight,		"DIRECT.Direct3dRMLight.3",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);
	STDMETHOD(getColor)( d3dcolor *value);

// methods added
	STDMETHOD(setType)(d3drmLightType t);
	STDMETHOD(setColor)(d3dcolor c);
	STDMETHOD(setColorRGB)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(setRange)(d3dvalue rng);
	STDMETHOD(setUmbra)(d3dvalue u);
	STDMETHOD(setPenumbra)(d3dvalue p);
	STDMETHOD(setConstantAttenuation)(d3dvalue atn);
	STDMETHOD(setLinearAttenuation)(d3dvalue atn);
	STDMETHOD(setQuadraticAttenuation)(d3dvalue atn);
	STDMETHOD(getRange)(d3dvalue *retval);
	STDMETHOD(getUmbra)(d3dvalue *retval);
	STDMETHOD(getPenumbra)(d3dvalue *retval);
	STDMETHOD(getConstantAttenuation)( d3dvalue *retval);
	STDMETHOD(getLinearAttenuation)( d3dvalue *retval);
	STDMETHOD(getQuadraticAttenuation)( d3dvalue *retval);
	STDMETHOD(getType)( d3drmLightType *retval);
	STDMETHOD(setEnableFrame)( I_dxj_Direct3dRMFrame3 *f);
	STDMETHOD(getEnableFrame)( I_dxj_Direct3dRMFrame3 **retval);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMLight);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLight )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterial2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmmaterial2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmMaterial2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMaterial2Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMMaterial2, {});
DESTRUCTOR(_dxj_Direct3dRMMaterial2, {});
GETSET_OBJECT(_dxj_Direct3dRMMaterial2);

CLONE_R(_dxj_Direct3dRMMaterial2,Direct3DRMMaterial2);
GETNAME_R(_dxj_Direct3dRMMaterial2);
SETNAME_R(_dxj_Direct3dRMMaterial2);
GETCLASSNAME_R(_dxj_Direct3dRMMaterial2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMaterial2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMaterial2);

GET_DIRECT_R(_dxj_Direct3dRMMaterial2, getAppData, GetAppData, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMaterial2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMMaterial2, setPower, SetPower, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setSpecular, SetSpecular, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setAmbient,  SetAmbient, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setEmissive, SetEmissive, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getSpecular, GetSpecular, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getEmissive, GetEmissive, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getAmbient,  GetAmbient, d3dvalue*, d3dvalue*, d3dvalue*);
GET_DIRECT_R(_dxj_Direct3dRMMaterial2,	  getPower, GetPower, d3dvalue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterial2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmmaterial2obj.h
//
//--------------------------------------------------------------------------

// d3drmMaterial2Obj.h : Declaration of the C_dxj_Direct3dRMMaterial2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMaterial2 LPDIRECT3DRMMATERIAL2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMaterial2Object : 
	public I_dxj_Direct3dRMMaterial2,
	public I_dxj_Direct3dRMObject,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMaterial2Object() ;
	virtual ~C_dxj_Direct3dRMMaterial2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMMaterial2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMaterial2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()
	

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMaterial2Object)

// I_dxj_Direct3dRMMaterial2
public:
         HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE setPower( 
            /* [in] */ float power);
        
         HRESULT STDMETHODCALLTYPE setSpecular( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setEmissive( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setAmbient( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE getPower( 
            /* [retval][out] */ float __RPC_FAR *power);
        
         HRESULT STDMETHODCALLTYPE getSpecular( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getEmissive( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getAmbient( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMMaterial2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMaterial2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMMeshInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMeshInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMMeshInterpolatorObject : 
	public I_dxj_Direct3dRMMeshInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMMeshInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMeshInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        

         HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz) ;
        
         HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
         HRESULT STDMETHODCALLTYPE setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val);
        
         HRESULT STDMETHODCALLTYPE setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b) ;

////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMMeshInterpolator);
	LPDIRECT3DRMMESH	m__dxj_Direct3dRMMesh;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMeshInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterialinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmaterialinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMMaterialInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMaterialInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMMaterialInterpolatorObject : 
	public I_dxj_Direct3dRMMaterialInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMaterialInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMMaterialInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMaterialInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMaterialInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMaterialInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        

         HRESULT STDMETHODCALLTYPE setPower( 
            /* [in] */ float power);
        
         HRESULT STDMETHODCALLTYPE setSpecular( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        
         HRESULT STDMETHODCALLTYPE setEmissive( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        

////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMMaterialInterpolator);
	LPDIRECT3DRMMATERIAL2	m__dxj_Direct3dRMMaterial2;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMaterialInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshbuilder3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshbuilder3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmMeshBuilderObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmMeshObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmFace2Obj.h"
#include "d3drmFaceArrayObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmVisualObj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_Direct3dRMMeshBuilder3, {});
DESTRUCTOR(_dxj_Direct3dRMMeshBuilder3, {});
GETSET_OBJECT(_dxj_Direct3dRMMeshBuilder3);

CLONE_R(_dxj_Direct3dRMMeshBuilder3,Direct3DRMMeshBuilder3);
GETNAME_R(_dxj_Direct3dRMMeshBuilder3);
SETNAME_R(_dxj_Direct3dRMMeshBuilder3);
GETCLASSNAME_R(_dxj_Direct3dRMMeshBuilder3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMeshBuilder3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMeshBuilder3);

//CLONETO_RX(_dxj_Direct3dRMMeshBuilder3, MeshBuilder3, IID_IDirect3DRMMeshBuilder3);

PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMMeshBuilder3, generateNormals, GenerateNormals, float,(float),long,(DWORD));

PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setQuality, SetQuality, d3drmRenderQuality)
PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setColor, SetColor, d3dcolor)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setPerspective, SetPerspective, long); //BOOL
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMMeshBuilder3, setVertexColor, SetVertexColor, long,(DWORD),d3dcolor,(DWORD));
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, setColorRGB,SetColorRGB,d3dvalue,d3dvalue,d3dvalue)
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, scaleMesh, Scale, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, translate, Translate, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH2_R(_dxj_Direct3dRMMeshBuilder3, setTextureTopology, SetTextureTopology, long, long); //BOOL
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMMeshBuilder3, setTextureCoordinates, SetTextureCoordinates, long,(DWORD), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMMeshBuilder3, getTextureCoordinates, GetTextureCoordinates, long,(DWORD), d3dvalue*,(float*), d3dvalue*,(float*));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setVertexColorRGB, SetVertexColorRGB, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, setColorSource, SetColorSource, d3drmColorSource, (enum _D3DRMCOLORSOURCE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, getBox, GetBox, D3dRMBox *,(D3DRMBOX *))
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getQuality, GetQuality, d3drmRenderQuality);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getPerspective, GetPerspective, long);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getVertexCount, GetVertexCount, int);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getColorSource, GetColorSource, d3drmColorSource);
GET_DIRECT1_R(_dxj_Direct3dRMMeshBuilder3, getVertexColor, GetVertexColor, d3dcolor, long);


PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setVertex, SetVertex, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setNormal, SetNormal, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));

GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getFaceCount, GetFaceCount, int );

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, addMesh, AddMesh, _dxj_Direct3dRMMesh);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, addFace, AddFace, _dxj_Direct3dRMFace2);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, setMaterial, SetMaterial, _dxj_Direct3dRMMaterial2)


RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, getFaces, GetFaces, _dxj_Direct3dRMFaceArray);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, createMesh,CreateMesh,_dxj_Direct3dRMMesh)
RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, createFace, CreateFace, _dxj_Direct3dRMFace2);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addVertex(d3dvalue x, d3dvalue y, d3dvalue z, int *index)
{
	*index = m__dxj_Direct3dRMMeshBuilder3->AddVertex(x,y,z);
	return S_OK;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addNormal(d3dvalue x, d3dvalue y, d3dvalue z, int *index)
{
	*index = m__dxj_Direct3dRMMeshBuilder3->AddNormal(x,y,z);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//FOR JAVA
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFacesJava(long vcount, float *vertices, 
							long ncount, float *normals, long *data, I_dxj_Direct3dRMFaceArray **array)
{
	HRESULT hr;
	LPDIRECT3DRMFACEARRAY lpArray;
	__try{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFaces((DWORD)vcount/3, (struct _D3DVECTOR *)vertices, ncount/3, (struct _D3DVECTOR *)normals, (unsigned long *)data, &lpArray);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMFaceArray, lpArray, array);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//STDMETHOD(Save)(BSTR fname, d3drmXofFormat format, d3dSaveOptions save);
//
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::save(BSTR Name, d3drmXofFormat ft, d3drmSaveFlags op) 
{


	USES_CONVERSION;
	LPCTSTR pszName = NULL;
	__try { pszName = W2T(Name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	return m__dxj_Direct3dRMMeshBuilder3->Save(pszName, (enum _D3DRMXOFFORMAT)ft, (DWORD) op );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::loadFromFile(BSTR filename, VARIANT id, long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, IUnknown *useMe)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;
	HRESULT hr;


	if( callme )
	{
		tcb = new TextureCallback3;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= TextureCallbacks3;
			tcb->prev			= (TextureCallback3*)NULL;
			TextureCallbacks3	= tcb;

			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");

			return E_FAIL;
		}
	}
	USES_CONVERSION;
	LPCTSTR pszName = NULL;
	__try { pszName = W2T(filename); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		__try { args=(void*)W2T(V_BSTR(&id)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMMeshBuilder3->Load((void *)&res, (DWORD*)args,(DWORD) flags,d3dtcb, pArgs);
	}
	else {
		hr = m__dxj_Direct3dRMMeshBuilder3->Load((void *)pszName, (DWORD*)args,(DWORD) flags,d3dtcb, pArgs);
	}
	// Remove ourselves in a thread-safe manner.
	if (tcb)
		UndoCallbackLink((GeneralCallback*)tcb, 
							(GeneralCallback**)&TextureCallbacks3);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getNormalCount(long *retval)
{
	DWORD vc=0, nc=0, fsize=0;

	//Get facedata size only. The other tqo sizes are ignored.
	*retval= m__dxj_Direct3dRMMeshBuilder3->GetNormalCount();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getFaceDataSize(long *retval)
{
	DWORD vc=0, nc=0, fsize=0;

	//Get facedata size only. The other tqo sizes are ignored.
	return m__dxj_Direct3dRMMeshBuilder3->GetGeometry(&vc, (struct _D3DVECTOR *)NULL, 
					  &nc, (struct _D3DVECTOR *)NULL, (DWORD*)retval, (DWORD*)NULL);	
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFrame(I_dxj_Direct3dRMFrame3 *frame){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,frame);
	return m__dxj_Direct3dRMMeshBuilder3->AddFrame(lpFrame); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::setTexture(I_dxj_Direct3dRMTexture3 *tex){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lpTex,tex);
	return m__dxj_Direct3dRMMeshBuilder3->SetTexture(lpTex); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addMeshBuilder(I_dxj_Direct3dRMMeshBuilder3 *mb, long flags){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMESHBUILDER3,lpMb,mb);
	return m__dxj_Direct3dRMMeshBuilder3->AddMeshBuilder(lpMb,(DWORD)flags); 
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getGeometry( SAFEARRAY **ppv, 
					 SAFEARRAY **ppn,  SAFEARRAY **ppfdata)
{
	DWORD vc,nc,fsize;

	if (!ppv) return E_INVALIDARG;
	if (!ppn) return E_INVALIDARG;
	if (!ppfdata) return E_INVALIDARG;
	
	vc= (*ppv)->cbElements;
	nc= (*ppn)->cbElements;
	fsize= (*ppfdata)->cbElements;

	//if (!ISSAFEARRAY1D(ppv,(DWORD)vc)) return E_INVALIDARG;
	//if (!ISSAFEARRAY1D(ppn,(DWORD)nc)) return E_INVALIDARG;
	//if (!ISSAFEARRAY1D(ppfdata,(DWORD)fsize)) return E_INVALIDARG;

	return m__dxj_Direct3dRMMeshBuilder3->GetGeometry((DWORD*)&vc, (struct _D3DVECTOR *)((SAFEARRAY*)*ppv)->pvData, (DWORD*)&nc, 
		(struct _D3DVECTOR *)((SAFEARRAY*)*ppn)->pvData, (unsigned long *)fsize, (unsigned long *) ((SAFEARRAY*)*ppfdata)->pvData);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFaces(long vcount, SAFEARRAY **ppv, 
					long ncount, SAFEARRAY **ppn,  SAFEARRAY **ppfdata, I_dxj_Direct3dRMFaceArray **array)
{
	HRESULT hr;
	LPDIRECT3DRMFACEARRAY lpArray;
	
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFaces(
			(DWORD)vcount,	(struct _D3DVECTOR *)((SAFEARRAY*)*ppv)->pvData, 
			(DWORD)ncount, (struct _D3DVECTOR *)((SAFEARRAY*)*ppn)->pvData,
			(unsigned long *)((SAFEARRAY*)*ppfdata)->pvData, &lpArray);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFaceArray, lpArray, array);

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFacesIndexed( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [retval][out] */ long __RPC_FAR *newFaceIndex)
{
	HRESULT hr;
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFacesIndexed(
			(DWORD)flags,	(DWORD *)((SAFEARRAY*)*indexArray)->pvData, 
			(DWORD*)newFaceIndex, NULL);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;

	
}



STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addTriangles(             
			/* [in] */ long format,
			/* [in] */ long vertexCount,
            /* [in] */ void *data)
{
	HRESULT hr;
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddTriangles(
			(DWORD)0,	(DWORD) format, (DWORD) vertexCount,
			data);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;
	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::createSubMesh( 
            I_dxj_Direct3dRMMeshBuilder3 **ret)
{
	HRESULT hr;
	LPUNKNOWN pUnk=NULL;
	LPDIRECT3DRMMESHBUILDER3 pMesh3=NULL;

	*ret =NULL;

	hr = m__dxj_Direct3dRMMeshBuilder3->CreateSubMesh(&pUnk);
	if FAILED(hr) return hr;

	if (!pUnk) return E_FAIL;

	hr = pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&pMesh3);
	pUnk->Release();
	if FAILED(hr) return hr;		
	

	INTERNAL_CREATE(_dxj_Direct3dRMMeshBuilder3,pMesh3,ret);

	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteFace( I_dxj_Direct3dRMFace2 *face)

{
		HRESULT hr;				
		if (!face) return E_INVALIDARG;

		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFACE2,pFace,face);
		__try {
			hr = m__dxj_Direct3dRMMeshBuilder3->DeleteFace(pFace);
		}
		__except(1,1){
			return E_FAIL;
		}
		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteNormals( long id, long count)
{
	HRESULT hr;

	hr = m__dxj_Direct3dRMMeshBuilder3->DeleteNormals((DWORD)id,(DWORD)count);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteVertices(long id, long count)
{
	HRESULT hr;
	__try {
		hr = m__dxj_Direct3dRMMeshBuilder3->DeleteVertices((DWORD)id,(DWORD) count);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::empty()
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->Empty((DWORD)0);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::enableMesh(long flags)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->Enable((DWORD)flags);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getEnable(long *flags)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetEnable((DWORD*)flags);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getFace(long index, I_dxj_Direct3dRMFace2 **face)
{
	HRESULT hr;
	LPDIRECT3DRMFACE2 pFace=NULL;
	*face=NULL;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetFace((DWORD)index,&pFace);
	if FAILED(hr) return hr;
	if (!pFace) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3dRMFace2,pFace,face);
	return hr;	
}




STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getNormal(long index, D3dVector *vec)
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->GetNormal((DWORD)index,(D3DVECTOR*)vec);
	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getVertex(long index, D3dVector *vec)
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->GetVertex((DWORD)index,(D3DVECTOR*)vec);
	return hr;	
}
        
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::optimize()
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->Optimize((DWORD)0);
	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteSubMesh( 
            I_dxj_Direct3dRMMeshBuilder3 *mesh)

{
		HRESULT hr;				
		if (!mesh) return E_INVALIDARG;

		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMESHBUILDER3,pMesh,mesh);
		hr = m__dxj_Direct3dRMMeshBuilder3->DeleteSubMesh(pMesh);
		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getParentMesh(long flags, 
            I_dxj_Direct3dRMMeshBuilder3 **mesh)
{
		HRESULT hr;						
		
		LPUNKNOWN pUnk=NULL;
		LPDIRECT3DRMMESHBUILDER3 pMesh=NULL;

		hr = m__dxj_Direct3dRMMeshBuilder3->GetParentMesh((DWORD)flags,&pUnk);
		if FAILED(hr) return hr;

		if (pUnk==NULL){
			*mesh=NULL;
			return S_OK;
		}

		hr= pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&pMesh);
		pUnk->Release();
		if FAILED(hr) return hr;
			
		INTERNAL_CREATE(_dxj_Direct3dRMMeshBuilder3,pMesh,mesh);

		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getSubMeshCount(long *count)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetSubMeshes((DWORD*)count,NULL);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getSubMeshes(long count,SAFEARRAY **psa)
{
	HRESULT hr;
	__try{
		hr = m__dxj_Direct3dRMMeshBuilder3->GetSubMeshes((DWORD*)&count,(IUnknown**)((SAFEARRAY*)*psa)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshbuilder3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshbuilder3obj.h
//
//--------------------------------------------------------------------------

// d3drmMeshBuilderObj.h : Declaration of the C_dxj_Direct3dRMMeshBuilderObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMeshBuilder3 LPDIRECT3DRMMESHBUILDER3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMeshBuilder3Object : 
	public I_dxj_Direct3dRMMeshBuilder3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMMeshBuilder3Object, &CLSID__dxj_Direct3dRMMeshBuilder3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshBuilder3Object();
	virtual ~C_dxj_Direct3dRMMeshBuilder3Object();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshBuilder3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMeshBuilder3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshBuilder3Object)

// I_dxj_Direct3dRMMeshBuilder
public:


        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE addFace( 
            /* [in] */ I_dxj_Direct3dRMFace2 __RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE addFaces( 
            /* [in] */ long vc,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *verexArray,
            /* [in] */ long nc,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normalArray,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *array);
        
        HRESULT STDMETHODCALLTYPE addFacesIndexed( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [retval][out] */ long __RPC_FAR *newFaceIndex);
        
        HRESULT STDMETHODCALLTYPE addFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE addMesh( 
            /* [in] */ I_dxj_Direct3dRMMesh __RPC_FAR *m);
        
        HRESULT STDMETHODCALLTYPE addMeshBuilder( 
            /* [in] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *mb, long flags);
        
        HRESULT STDMETHODCALLTYPE addNormal( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [retval][out] */ int __RPC_FAR *index);
        
        HRESULT STDMETHODCALLTYPE addTriangles(             
            /* [in] */ long format,
            /* [in] */ long vertexcount,
            /* [in] */ void __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE addVertex( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [retval][out] */ int __RPC_FAR *index);
        
        HRESULT STDMETHODCALLTYPE createFace( 
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE createSubMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE deleteFace( 
            /* [in] */ I_dxj_Direct3dRMFace2 __RPC_FAR *face);
        
        HRESULT STDMETHODCALLTYPE deleteNormals( 
            /* [in] */ long id, long count);
        
        HRESULT STDMETHODCALLTYPE deleteSubMesh( 
            /* [in] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *mesh);
        
        HRESULT STDMETHODCALLTYPE deleteVertices( 
            /* [in] */ long id, long count);
        
        HRESULT STDMETHODCALLTYPE empty();
        
        HRESULT STDMETHODCALLTYPE enableMesh( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE generateNormals( 
            float angle,
            long flags);
        
        HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getColorSource( 
            /* [retval][out] */ d3drmColorSource __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE getEnable( 
            /* [retval][out] */ long __RPC_FAR *flags);
        
        HRESULT STDMETHODCALLTYPE getFace( 
            /* [in] */ long id,
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaceCount( 
            /* [retval][out] */ int __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaces( 
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGeometry(             
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *verexArray,
            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normalArray,
            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *faceData);
        
        HRESULT STDMETHODCALLTYPE getNormal( 
            /* [in] */ long __MIDL_0016,
            /* [out][in] */ D3dVector __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE getNormalCount( 
            /* [retval][out] */ long __RPC_FAR *n_cnt);
        
        HRESULT STDMETHODCALLTYPE getParentMesh( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR **vis);
        
        HRESULT STDMETHODCALLTYPE getPerspective( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getSubMeshes( 
            /* [in] */ long count,
            /* [retval][out] */ SAFEARRAY **ppsa);
        
        HRESULT STDMETHODCALLTYPE getSubMeshCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinates( 
            /* [in] */ long idx,
            /* [out][in] */ float __RPC_FAR *u,
            /* [out][in] */ float __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ long id,
            /* [out][in] */ D3dVector __RPC_FAR *vec);
        
        HRESULT STDMETHODCALLTYPE getVertexColor( 
            /* [in] */ long index,
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [retval][out] */ int __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaceDataSize( 
            /* [retval][out] */ long __RPC_FAR *f_cnt);
        
        HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *c,
            /* [in] */ IUnknown __RPC_FAR *pUser);
        
        HRESULT STDMETHODCALLTYPE optimize();
        
        HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ BSTR fname,
            /* [in] */ d3drmXofFormat xFormat,
            /* [in] */ d3drmSaveFlags save);
        
        HRESULT STDMETHODCALLTYPE scaleMesh( 
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
        HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor col);
        
        HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        
        HRESULT STDMETHODCALLTYPE setColorSource( 
            /* [in] */ d3drmColorSource val);
        
        HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *mat);
        
        HRESULT STDMETHODCALLTYPE setNormal( 
            /* [in] */ long idx,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
        HRESULT STDMETHODCALLTYPE setPerspective( 
            /* [in] */ long persp);
        
        HRESULT STDMETHODCALLTYPE setQuality( 
            /* [in] */ d3drmRenderQuality q);
        
        HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setTextureCoordinates( 
            /* [in] */ long idx,
            /* [in] */ float u,
            /* [in] */ float v);
        
        HRESULT STDMETHODCALLTYPE setTextureTopology( 
            /* [in] */ long wrap_u,
            /* [in] */ long wrap_v);
        
        HRESULT STDMETHODCALLTYPE setVertex( 
            /* [in] */ long idx,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
        HRESULT STDMETHODCALLTYPE setVertexColor( 
            /* [in] */ long idx,
            /* [in] */ d3dcolor c);
        
        HRESULT STDMETHODCALLTYPE setVertexColorRGB( 
            /* [in] */ long idx,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
        HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE addFacesJava( 
            /* [in] */ long vc,
            /* [in] */ float __RPC_FAR *ver,
            /* [in] */ long nc,
            /* [in] */ float __RPC_FAR *norm,
            /* [in] */ long __RPC_FAR *data,
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *array);
        
////////////////////////////////////////////////////////////////////////////////////

private:
    DECL_VARIABLE(_dxj_Direct3dRMMeshBuilder3);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMeshBuilder3 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterialinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmaterialinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMMaterialInterpolator;


C_dxj_Direct3dRMMaterialInterpolatorObject::C_dxj_Direct3dRMMaterialInterpolatorObject(){
	m__dxj_Direct3dRMMaterialInterpolator=NULL;
	m__dxj_Direct3dRMMaterial2=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	
	
	DPF1(1,"Constructor Creation  Direct3dRMMaterialInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMMaterialInterpolator;
	g_dxj_Direct3dRMMaterialInterpolator = (void *)this;
}


C_dxj_Direct3dRMMaterialInterpolatorObject::~C_dxj_Direct3dRMMaterialInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMMaterialInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMMaterialInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMMaterialInterpolatorObject *ptr=(C_dxj_Direct3dRMMaterialInterpolatorObject *)g_dxj_Direct3dRMMaterialInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMMaterialInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMMaterialInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMMaterialInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMMaterialInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMMaterialInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMMaterialInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMMaterial2)
			m__dxj_Direct3dRMMaterial2->Release();

}


DWORD C_dxj_Direct3dRMMaterialInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMMaterialInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMMaterialInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMMaterialInterpolator [%d] Release %d \n",creationid,i);

	return i;
}



HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMMaterialInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMMaterialInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&m__dxj_Direct3dRMMaterial2);	
	return hr;
}



HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMaterialInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMaterialInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
        

HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMMaterialInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMMaterialInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

		//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	

	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMMaterialInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}


HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setPower( float p)
{
	return m__dxj_Direct3dRMMaterial2->SetPower(p);
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setSpecular( float r,float g, float b)
{
	return m__dxj_Direct3dRMMaterial2->SetSpecular(r,g,b);
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setEmissive( float r,float g, float b)
{
	return m__dxj_Direct3dRMMaterial2->SetEmissive(r,g,b);
}


HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMMaterialInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMMeshInterpolator;


C_dxj_Direct3dRMMeshInterpolatorObject::C_dxj_Direct3dRMMeshInterpolatorObject(){
	m__dxj_Direct3dRMMeshInterpolator=NULL;
	m__dxj_Direct3dRMMesh=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMMeshInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMMeshInterpolator;
	g_dxj_Direct3dRMMeshInterpolator = (void *)this;
}


C_dxj_Direct3dRMMeshInterpolatorObject::~C_dxj_Direct3dRMMeshInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMMeshInterpolator [%d] \n",creationid); 

	
	C_dxj_Direct3dRMMeshInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMMeshInterpolatorObject *ptr=(C_dxj_Direct3dRMMeshInterpolatorObject *)g_dxj_Direct3dRMMeshInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMMeshInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMMeshInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMMeshInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMMeshInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMMeshInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMMeshInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMMesh)
			m__dxj_Direct3dRMMesh->Release();

}


DWORD C_dxj_Direct3dRMMeshInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMMeshInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMMeshInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMMeshInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMMeshInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMMeshInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMMesh,(void**)&m__dxj_Direct3dRMMesh);	
	return hr;
}



HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMeshInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMeshInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMMeshInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMMeshInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMMeshInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMMeshInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4= pObj->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setVertices( d3drmGroupIndex id, long idx, long cnt, SAFEARRAY **ppsa)
{
	HRESULT hr;
	//
	// Go through and reformat all the float color values back
	// to long, so the array of floats now looks like an array 
	// D3DRMVERTEXES
	//
	if (!ISSAFEARRAY1D(ppsa,(DWORD)cnt))
		return E_INVALIDARG;

	
	D3DRMVERTEX *values= (D3DRMVERTEX*)((SAFEARRAY*)*ppsa)->pvData;
	__try{
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)values);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz) {

	return m__dxj_Direct3dRMMesh->Translate(tx,ty,tz);
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val) {

	return m__dxj_Direct3dRMMesh->SetGroupColor((DWORD)id,(D3DCOLOR)val);
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
					   float g,
					   float b) {

	return m__dxj_Direct3dRMMesh->SetGroupColorRGB((DWORD)id,r,g,b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshobj.cpp
//
//--------------------------------------------------------------------------

// d3drmMeshObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshObj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmTexture3Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMMesh, {});
DESTRUCTOR(_dxj_Direct3dRMMesh, {});
GETSET_OBJECT(_dxj_Direct3dRMMesh);

CLONE_R(_dxj_Direct3dRMMesh,Direct3DRMMesh);
GETNAME_R(_dxj_Direct3dRMMesh);
SETNAME_R(_dxj_Direct3dRMMesh);
GETCLASSNAME_R(_dxj_Direct3dRMMesh);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMesh);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMesh);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMesh, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupColor,SetGroupColor,d3drmGroupIndex, d3dcolor);
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupMapping,SetGroupMapping,d3drmGroupIndex,d3drmMappingFlags);
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupQuality,SetGroupQuality,d3drmGroupIndex,d3drmRenderQuality);
PASS_THROUGH3_R(_dxj_Direct3dRMMesh, scaleMesh, Scale, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMesh, translate, Translate, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMMesh, setGroupColorRGB,SetGroupColorRGB,d3drmGroupIndex,d3dvalue,d3dvalue,d3dvalue);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMesh, getBox,GetBox, D3dRMBox*, (_D3DRMBOX*));


GET_DIRECT_R(_dxj_Direct3dRMMesh,  getAppData,		GetAppData,		long);
GET_DIRECT_R(_dxj_Direct3dRMMesh,  getGroupCount,	GetGroupCount,	long);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupColor,	GetGroupColor,	d3dcolor, d3drmGroupIndex);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupMapping, GetGroupMapping, d3drmMappingFlags, d3drmGroupIndex);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupQuality, GetGroupQuality, d3drmRenderQuality, d3drmGroupIndex);



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVertex( d3drmGroupIndex id, long idx, D3dRMVertex *value)
{
	return m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx, 1, (struct _D3DRMVERTEX *)value);
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVertices( d3drmGroupIndex id, long idx, long cnt, SAFEARRAY **ppsa)
{
	HRESULT hr;
	//
	// Go through and reformat all the float color values back
	// to long, so the array of floats now looks like an array 
	// D3DRMVERTEXES
	//
	if (!ISSAFEARRAY1D(ppsa,(DWORD)cnt))
		return E_INVALIDARG;

	
	D3DRMVERTEX *values= (D3DRMVERTEX*)((SAFEARRAY*)*ppsa)->pvData;
	__try{
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)values);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVerticesJava( d3drmGroupIndex id, long idx, long cnt, float *vertData)
{
	HRESULT hr;
	
	__try {
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)vertData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupDataSize( d3drmGroupIndex id, long *cnt)
{
	unsigned int *cnt1=0, *cnt2=0, *cnt3=0;

	return m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, cnt1, cnt2,
										cnt3, (DWORD*)cnt, (unsigned int *)NULL);
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertexCount( d3drmGroupIndex id, long *cnt)
{
	unsigned int *cnt1=0, *cnt2=0;
	DWORD *cnt3=0;	
	return m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, (unsigned int*)cnt, (unsigned int*) cnt1,
										cnt2, cnt3, (unsigned int *)NULL);
}

        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertices(d3drmGroupIndex id, long idx, long count, SAFEARRAY **ppsa )
{	
	HRESULT	hr;
	
	if (!ISSAFEARRAY1D(ppsa,(DWORD)count)) return E_INVALIDARG;
	D3DRMVERTEX *v=(D3DRMVERTEX *)((SAFEARRAY*)*ppsa)->pvData;

	__try {
		hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)v);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVerticesJava(d3drmGroupIndex id, long idx, long count, float *vertData)
{	
	HRESULT	hr;
		
	__try {
		hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)vertData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertex(d3drmGroupIndex id, long idx, D3dRMVertex *v )
{
	DWORD count = 1;
	HRESULT	hr;
	
	hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)v);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupTexture( d3drmGroupIndex id, I_dxj_Direct3dRMTexture3 **tex){
	HRESULT hr;
	IDirect3DRMTexture *realtex1=NULL;
	IDirect3DRMTexture3 *realtex3=NULL;
	
	*tex=NULL;

	hr=m__dxj_Direct3dRMMesh->GetGroupTexture((D3DRMGROUPINDEX)id,&realtex1);
	if FAILED(hr) return hr;

	if (!realtex1) return hr;

	hr=realtex1->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realtex3);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realtex3,tex);

	realtex1->Release();

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setGroupTexture( d3drmGroupIndex id, I_dxj_Direct3dRMTexture3 *tex){
	HRESULT hr;
	IDirect3DRMTexture3 *realtex=NULL;
	IDirect3DRMTexture *realtex1=NULL;
	if (tex){
		tex->InternalGetObject((IUnknown**)&realtex);	//does not addref
		hr=realtex->QueryInterface(IID_IDirect3DRMTexture,(void**)&realtex1);
		if FAILED(hr) return hr;
	}

	hr=m__dxj_Direct3dRMMesh->SetGroupTexture((D3DRMGROUPINDEX)id,realtex1);
	
	if (realtex1)
		realtex1->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getSizes( d3drmGroupIndex id, long *cnt1,long *cnt2, long *cnt3, long *cnt4)
{

	//were in 32 bits so we can do this
	HRESULT hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, (unsigned*)cnt1, (unsigned*)cnt2,
										(unsigned*)cnt3, (DWORD*)cnt4, (unsigned int *)NULL);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupData( d3drmGroupIndex id, SAFEARRAY **ppsa)
{
	DWORD s;

	//if (!ISSAFEARRAY1D(ppsa,(DWORD)size)) return E_INVALIDARG;
	if (!ppsa) return E_INVALIDARG;
	s= (*ppsa)->rgsabound->cElements;
 
	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, NULL, NULL, NULL,
										(DWORD*)&s, (unsigned*)((SAFEARRAY*)*ppsa)->pvData);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupDataJava( d3drmGroupIndex id, long size, long *pFaceData)
{

	DWORD s=size;
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, NULL, NULL, NULL,
										(DWORD*)&s, (unsigned*)pFaceData);
	}
	__except(1,1){
		return E_FAIL;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_Direct3dRMMeshObject::addGroup( 
             /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *pretId)

{
	
	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->AddGroup( 
			 (unsigned)vcnt,(unsigned)fcnt,(unsigned)vPerFace, (unsigned*)((SAFEARRAY*)*ppsa)->pvData, pretId);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::addGroupJava( 
             /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ long *pFaceData,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *pretId)

{

	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->AddGroup( 
			 (unsigned)vcnt,(unsigned)fcnt,(unsigned)vPerFace, (unsigned*)pFaceData, pretId);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupMaterial( d3drmGroupIndex id, I_dxj_Direct3dRMMaterial2 **mat){
	HRESULT hr;
	IDirect3DRMMaterial  *realmat1=NULL;
	IDirect3DRMMaterial2 *realmat2=NULL;
	
	*mat=NULL;

	hr=m__dxj_Direct3dRMMesh->GetGroupMaterial((D3DRMGROUPINDEX)id,&realmat1);
	if FAILED(hr) return hr;	
	if (!realmat1) return S_OK;

	hr=realmat1->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&realmat2);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMMaterial2,realmat2,mat);

	realmat1->Release();

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setGroupMaterial( d3drmGroupIndex id, I_dxj_Direct3dRMMaterial2 *mat){
	HRESULT hr;
	IDirect3DRMMaterial2 *realmat=NULL;
	IDirect3DRMMaterial  *realmat1=NULL;

	if (mat){
		mat->InternalGetObject((IUnknown**)&realmat);	//does not addref
		hr=realmat->QueryInterface(IID_IDirect3DRMMaterial,(void**)&realmat1);
		if FAILED(hr) return hr;
	}

	hr=m__dxj_Direct3dRMMesh->SetGroupMaterial((D3DRMGROUPINDEX)id,realmat1);
	
	if (realmat1) realmat1->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshobj.h
//
//--------------------------------------------------------------------------

// d3drmMeshObj.h : Declaration of the C_dxj_Direct3dRMMeshObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMesh LPDIRECT3DRMMESH

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMeshObject : 
	public I_dxj_Direct3dRMMesh,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMMeshObject, &CLSID__dxj_Direct3dRMMesh>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshObject() ;
	virtual ~C_dxj_Direct3dRMMeshObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMesh)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMMesh,			"DIRECT.Direct3dRMMesh.3",			"DIRECT.Direct3dRMMesh.3", IDS_D3DRMMESH_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshObject)

// I_dxj_Direct3dRMMesh
public:
	// updated
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val);
        
        HRESULT STDMETHODCALLTYPE setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
        HRESULT STDMETHODCALLTYPE setGroupMapping( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3drmMappingFlags value);
        
        HRESULT STDMETHODCALLTYPE setGroupQuality( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3drmRenderQuality value);
        
        HRESULT STDMETHODCALLTYPE setGroupMaterial( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setGroupTexture( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getGroupCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupMapping( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3drmMappingFlags __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupQuality( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupMaterial( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupTexture( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE scaleMesh( 
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
        HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz);
        
        HRESULT STDMETHODCALLTYPE getBox( 
            /* [in] */ D3dRMBox __RPC_FAR *vector);
        
        HRESULT STDMETHODCALLTYPE getSizes( 
            /* [in] */ d3drmGroupIndex id,
            /* [out] */ long __RPC_FAR *cnt1,
            /* [out] */ long __RPC_FAR *cnt2,
            /* [out] */ long __RPC_FAR *cnt3,
            /* [out] */ long __RPC_FAR *cnt4);
        
        HRESULT STDMETHODCALLTYPE setVertex( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ D3dRMVertex __RPC_FAR *values);
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [out][in] */ D3dRMVertex __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ long __RPC_FAR *cnt);
        
        HRESULT STDMETHODCALLTYPE addGroup( 
            /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *fdata,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *retId);
        
        HRESULT STDMETHODCALLTYPE getGroupData( 
            /* [in] */ d3drmGroupIndex id,            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psa);
        
        HRESULT STDMETHODCALLTYPE getGroupDataSize( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long cnt,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            long cnt,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE addGroupJava( 
            /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in,out] */ long *fdata,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *retId);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE getGroupDataJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long size,
            /* [out][in] */ long *fdata);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE setVerticesJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long cnt,
            /* [in,out] */ float __RPC_FAR *vertexArray);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE getVerticesJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
						long cnt,
            /* [out][in] */ float __RPC_FAR *vertexArray);
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMMesh);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMesh )
		

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmobjectarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmObjectArrayObj.h"



CONSTRUCTOR(_dxj_Direct3dRMObjectArray, {});
DESTRUCTOR(_dxj_Direct3dRMObjectArray, {});
GETSET_OBJECT(_dxj_Direct3dRMObjectArray);

GET_DIRECT_R(_dxj_Direct3dRMObjectArray,getSize, GetSize, long)



HRESULT C_dxj_Direct3dRMObjectArrayObject::getElement(long i, I_dxj_Direct3dRMObject **obj){
	HRESULT hr;
	IDirect3DRMObject  *realObject=NULL;	

	hr=m__dxj_Direct3dRMObjectArray->GetElement((DWORD)i,&realObject);
	if FAILED(hr) return hr;



	//realObjects refcount is taken care of by CreateCoverObject
	hr=CreateCoverObject(realObject, obj);

	realObject->Release();

	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmobjectarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmObjectArrayObj.h : Declaration of the C_dxj_Direct3dRMObjectArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMObjectArray LPDIRECT3DRMOBJECTARRAY



class C_dxj_Direct3dRMObjectArrayObject : 
	
	public I_dxj_Direct3dRMObjectArray,

	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMObjectArrayObject() ;
	virtual ~C_dxj_Direct3dRMObjectArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMObjectArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObjectArray)

	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMObjectArrayObject)
	


// I_dxj_Direct3dRMObjectArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);

	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMObject **lplpD3DRMObject);

private:
    DECL_VARIABLE(_dxj_Direct3dRMObjectArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMObjectArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmpicked2arrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpicked2arrayobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMPick2edArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmPick2ArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualObj.h"



CONSTRUCTOR( _dxj_Direct3dRMPick2Array, {});
DESTRUCTOR( _dxj_Direct3dRMPick2Array, {});
GETSET_OBJECT(_dxj_Direct3dRMPick2Array);

GET_DIRECT_R(_dxj_Direct3dRMPick2Array, getSize, GetSize,  long)

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPick2ArrayObject::getPickVisual(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMVisual **visual)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dRMPick2Array->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(D3DRMPICKDESC2 *)Desc);
	if FAILED(hr)	 return hr;
	if (!lpVisual) return S_OK;

	hr=CreateCoverVisual(lpVisual, visual);
	if (lpFrameArray) lpFrameArray->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPick2ArrayObject::getPickFrame(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMFrameArray **frameArray)
{
	LPDIRECT3DRMVISUAL lpVisual;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray;
	HRESULT hr;
	hr=m__dxj_Direct3dRMPick2Array->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(D3DRMPICKDESC2 *)Desc);
	if( hr != S_OK)	return hr;
	if (!lpFrameArray) return S_OK;
	INTERNAL_CREATE(_dxj_Direct3dRMFrameArray, lpFrameArray, frameArray);
	if (lpVisual) lpVisual->Release();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmpickedarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpickedarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmPickedArrayObj.h : Declaration of the C_dxj_Direct3dRMPickArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMPickArray LPDIRECT3DRMPICKEDARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMPickArrayObject : 
	public I_dxj_Direct3dRMPickArray,
//	public CComCoClass<C_dxj_Direct3dRMPickArrayObject, &CLSID__dxj_Direct3dRMPickArray>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMPickArrayObject() ;
	virtual ~C_dxj_Direct3dRMPickArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMPickArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMPickArray)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMPickArray,	"DIRECT.Direct3dRMPickedArray.3",	"DIRECT.Direct3dRMPickedArray.3",  IDS_D3DRMPICKEDARRAY_DESC,  THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMPickArrayObject)

// I_dxj_Direct3dRMPickArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)( long *retval);
	STDMETHOD(getPickVisual)(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMVisual **visual);
	STDMETHOD(getPickFrame)(long index,  D3dRMPickDesc *Desc, I_dxj_Direct3dRMFrameArray **frameArray);

private:
    DECL_VARIABLE(_dxj_Direct3dRMPickArray);   

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMPickArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmobjectobj.h
//
//--------------------------------------------------------------------------

#if 0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmpick2arrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpick2arrayobj.h
//
//--------------------------------------------------------------------------

// d3dRMPick2edArrayObj.h : Declaration of the C_dxj_Direct3dRMPick2ArrayObject
#ifndef _H_D3DRMPICK2ARRAYOBJ
#define _H_D3DRMPICK2ARRAYOBJ

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMPick2Array IDirect3DRMPicked2Array*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMPick2ArrayObject : 
	public I_dxj_Direct3dRMPick2Array,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMPick2ArrayObject() ;
	virtual ~C_dxj_Direct3dRMPick2ArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMPick2ArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMPick2Array)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dRMPick2ArrayObject)

// I_dxj_Direct3dRMPick2Array
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)( long *retval);
	STDMETHOD(getPickVisual)(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMVisual **visual);
	STDMETHOD(getPickFrame)(long index,  D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMFrameArray **frameArray);

private:
    DECL_VARIABLE(_dxj_Direct3dRMPick2Array);   

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMPick2Array )
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmpickedarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpickedarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmPickedArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualObj.h"



CONSTRUCTOR( _dxj_Direct3dRMPickArray, {});
DESTRUCTOR( _dxj_Direct3dRMPickArray, {});
GETSET_OBJECT(_dxj_Direct3dRMPickArray);

GET_DIRECT_R(_dxj_Direct3dRMPickArray, getSize, GetSize,  long)

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPickArrayObject::getPickVisual(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMVisual **visual)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;

	*visual=NULL;

	hr=m__dxj_Direct3dRMPickArray->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(struct _D3DRMPICKDESC *)Desc);
	if(hr != S_OK)	return hr;
	
	if (!lpVisual) return S_OK;

	hr=CreateCoverVisual(lpVisual, visual);
	if (lpFrameArray) lpFrameArray->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPickArrayObject::getPickFrame(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMFrameArray **frameArray)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMPickArray->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(struct _D3DRMPICKDESC *)Desc);
	if( hr != S_OK)
		return hr;

	if (!lpFrameArray) return S_OK;

	INTERNAL_CREATE(_dxj_Direct3dRMFrameArray, lpFrameArray, frameArray);
	if (lpVisual) lpVisual->Release();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmprogressivemeshobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmprogressivemeshobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMProgressiveMeshObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dRMProgressiveMeshObj.h"
#include "d3dRMMeshObj.h"
#include "d3drmTexture3Obj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR( _dxj_Direct3dRMProgressiveMesh, {});
DESTRUCTOR(_dxj_Direct3dRMProgressiveMesh, {});
GETSET_OBJECT(_dxj_Direct3dRMProgressiveMesh);

CLONE_R(_dxj_Direct3dRMProgressiveMesh,Direct3DRMProgressiveMesh);
GETNAME_R(_dxj_Direct3dRMProgressiveMesh);
SETNAME_R(_dxj_Direct3dRMProgressiveMesh);
GETCLASSNAME_R(_dxj_Direct3dRMProgressiveMesh);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMProgressiveMesh);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMProgressiveMesh);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMProgressiveMesh,  getAppData,		GetAppData,		long);


PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getBox,GetBox, D3dRMBox*, (_D3DRMBOX*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getFaceDetail,GetFaceDetail, long*, (DWORD*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getVertexDetail,GetVertexDetail, long*, (DWORD*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setFaceDetail,SetFaceDetail, long, (DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setVertexDetail,SetVertexDetail, long, (DWORD));

PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMProgressiveMesh, getFaceDetailRange,GetFaceDetailRange, long*, (DWORD*),long*, (DWORD*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMProgressiveMesh, getVertexDetailRange,GetVertexDetailRange, long*, (DWORD*),long*, (DWORD*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getQuality, GetQuality, d3drmRenderQuality*, (D3DRMRENDERQUALITY*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setQuality, SetQuality, d3drmRenderQuality, (D3DRMRENDERQUALITY));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setDetail,SetDetail, float, (float));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getDetail,GetDetail, float*, (float*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setMinRenderDetail,SetMinRenderDetail, float, (float));

//PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, abort,Abort, long, (DWORD));
//PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getLoadStatus,GetLoadStatus, long*, (D3DRMPMESHLOADSTATUS*));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMProgressiveMesh, registerEvents,RegisterEvents, long,(void*),long,(DWORD),long,(DWORD));

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::abort( ){
	HRESULT hr=m__dxj_Direct3dRMProgressiveMesh->Abort(0);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::getLoadStatus( D3DRMPMESHLOADSTATUS_CDESC *status){
	
	D3DRMPMESHLOADSTATUS *pstatus=(D3DRMPMESHLOADSTATUS*)status;
	HRESULT hr;
	pstatus->dwSize=sizeof(D3DRMPMESHLOADSTATUS);
	hr=m__dxj_Direct3dRMProgressiveMesh->GetLoadStatus(pstatus);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::loadFromFile(        
			/* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *callme,
            /* [in] */ IUnknown __RPC_FAR *useMe)
{
	
	D3DRMLOADTEXTURECALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback *tcb = NULL;
	HRESULT hr;

	if( callme )
	{
		tcb = new TextureCallback;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= TextureCallbacks;
			tcb->prev			= (TextureCallback*)NULL;
			TextureCallbacks	= tcb;

			d3dtcb = myLoadTextureCallback;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");
			return E_FAIL;
		}
	}
	
	USES_CONVERSION;
	LPCTSTR pszName = NULL;
	__try { pszName = W2T(filename); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		__try { args=(void*)W2T(V_BSTR(&id)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);


	hr = m__dxj_Direct3dRMProgressiveMesh->Load((void *)pszName,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);

	// Remove ourselves in a thread-safe manner. Need unlock here
	if (tcb)
		UndoCallbackLink((GeneralCallback*)tcb, 
							(GeneralCallback**)&TextureCallbacks);

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *mesh)
{
	HRESULT hr;
	LPDIRECT3DRMMESH pMesh=NULL;

	hr = m__dxj_Direct3dRMProgressiveMesh->CreateMesh(&pMesh);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMesh,pMesh,mesh);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::duplicate( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *mesh)
{
	HRESULT hr;
	LPDIRECT3DRMPROGRESSIVEMESH pMesh=NULL;

	hr = m__dxj_Direct3dRMProgressiveMesh->Duplicate(&pMesh);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMProgressiveMesh,pMesh,mesh);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmprogressivemeshobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmprogressivemeshobj.h
//
//--------------------------------------------------------------------------

// d3dRMProgressiveMeshObj.h : Declaration of the C_dxj_Direct3dRMProgressiveMeshObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMProgressiveMesh LPDIRECT3DRMPROGRESSIVEMESH

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMProgressiveMeshObject : 
	public I_dxj_Direct3dRMProgressiveMesh,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMProgressiveMeshObject() ;
	virtual ~C_dxj_Direct3dRMProgressiveMeshObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMProgressiveMeshObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMProgressiveMesh)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMProgressiveMeshObject)

// I_dxj_Direct3dRMProgressiveMesh
public:
		// updated
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR sFile,
            /* [in] */ VARIANT id,
            /* [in] */ long options,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *cb,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE getLoadStatus( D3DRMPMESHLOADSTATUS_CDESC *status);
        
         HRESULT STDMETHODCALLTYPE setMinRenderDetail( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE abort( 
            ///* [in] */ long flags
			);
        
         HRESULT STDMETHODCALLTYPE getFaceDetail( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE getVertexDetail( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE setFaceDetail( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE setVertexDetail( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE getFaceDetailRange( 
            /* [out][in] */ long __RPC_FAR *min,
            /* [out][in] */ long __RPC_FAR *max);
        
         HRESULT STDMETHODCALLTYPE getVertexDetailRange( 
            /* [out][in] */ long __RPC_FAR *min,
            /* [out][in] */ long __RPC_FAR *max);
        
         HRESULT STDMETHODCALLTYPE getDetail( 
            /* [retval][out] */ float __RPC_FAR *detail);
        
         HRESULT STDMETHODCALLTYPE setDetail( 
            /* [in] */ float detail);
        
         HRESULT STDMETHODCALLTYPE registerEvents( 
            /* [in] */ long hEvent,
            /* [in] */ long flags,
            /* [in] */ long reserved);
        
         HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *mesh);
        
         HRESULT STDMETHODCALLTYPE duplicate( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *mesh);
        
         HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE setQuality( 
            d3drmRenderQuality quality);
        
         HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */  d3drmRenderQuality *quality);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMProgressiveMesh);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMProgressiveMesh )
		

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmshadow2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmshadow2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmShadowObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmShadow2Obj.h"
#include "d3drmLightObj.h"


CONSTRUCTOR(_dxj_Direct3dRMShadow2, {});
DESTRUCTOR(_dxj_Direct3dRMShadow2, {});
GETSET_OBJECT(_dxj_Direct3dRMShadow2);

GETNAME_R(_dxj_Direct3dRMShadow2);
SETNAME_R(_dxj_Direct3dRMShadow2);
GETCLASSNAME_R(_dxj_Direct3dRMShadow2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMShadow2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMShadow2);

CLONE_R(_dxj_Direct3dRMShadow2,Direct3DRMShadow2);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMShadow2, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMShadow2, getAppData, GetAppData, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMShadow2, setOptions, SetOptions, long,(DWORD));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmshadow2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmshadow2obj.h
//
//--------------------------------------------------------------------------

// d3drmShadow2Obj.h : Declaration of the C_dxj_Direct3dRMShadow2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMShadow2 LPDIRECT3DRMSHADOW2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMShadow2Object : 
	public I_dxj_Direct3dRMShadow2,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMShadow2Object() ;
	virtual ~C_dxj_Direct3dRMShadow2Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMShadow2Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMShadow2)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMShadow2Object)

// I_dxj_Direct3dRMShadow2
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
		HRESULT STDMETHODCALLTYPE setOptions(long flags);
		 
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMShadow2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMShadow2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmtexture3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtexture3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmTextureObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmTexture3Obj.h"
#include "ddSurface4Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMTexture3, {
	m_buffer1 = NULL;
	m_buffer1size = 0;
	m_buffer2 = NULL;
	m_buffer2size = 0;
	m_pallette = NULL;
	m_palettesize = 0;

})

DESTRUCTOR(_dxj_Direct3dRMTexture3, {
	if ( m_buffer1 ) 
		free(m_buffer1);
	if ( m_buffer2 ) 
		free(m_buffer2);
	if ( m_pallette )
		free(m_pallette);
})

GETSET_OBJECT(_dxj_Direct3dRMTexture3)

CLONE_R(_dxj_Direct3dRMTexture3,Direct3DRMTexture3);
GETNAME_R(_dxj_Direct3dRMTexture3);
SETNAME_R(_dxj_Direct3dRMTexture3);
GETCLASSNAME_R(_dxj_Direct3dRMTexture3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMTexture3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMTexture3);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setColors, SetColors, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setShades, SetShades, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalScale, SetDecalScale, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalTransparency, SetDecalTransparency, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalTransparentColor, SetDecalTransparentColor, d3dcolor,(DWORD));

PASS_THROUGH2_R(_dxj_Direct3dRMTexture3, setDecalSize, SetDecalSize, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMTexture3, setDecalOrigin, SetDecalOrigin, long,(DWORD),long,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMTexture3, getDecalSize, GetDecalSize, D3DVALUE*, D3DVALUE*);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMTexture3, getDecalOrigin, GetDecalOrigin, long*, (long*), long*,(long*));


       

GET_DIRECT_R(_dxj_Direct3dRMTexture3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getShades, GetShades, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getColors, GetColors, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalScale, GetDecalScale, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalTransparency, GetDecalTransparency, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalTransparentColor, GetDecalTransparentColor, d3dcolor);




/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMTexture3Object::generateMIPMap() 
{
	return m__dxj_Direct3dRMTexture3->GenerateMIPMap(0);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMTexture3Object::changed(long flags, long nRects, SAFEARRAY **psa) 
{
	if ((nRects)&&(!ISSAFEARRAY1D(psa,(DWORD)nRects)))
		return E_INVALIDARG;		
	
	return m__dxj_Direct3dRMTexture3->Changed((DWORD)flags,(DWORD)nRects,(RECT*)((SAFEARRAY*)*psa)->pvData);
}


STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getCacheFlags(long *flags) 
{
	long temp;
	return m__dxj_Direct3dRMTexture3->GetCacheOptions(&temp,(DWORD*)flags);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getCacheImportance(long *import) 
{
	DWORD temp;
	return m__dxj_Direct3dRMTexture3->GetCacheOptions(import,&temp);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::setCacheOptions(long import, long flags) 
{	
	return m__dxj_Direct3dRMTexture3->SetCacheOptions(import,(DWORD)flags);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getSurface(long flags, I_dxj_DirectDrawSurface4 **ppret) 
{
	

	HRESULT hr;
	LPDIRECTDRAWSURFACE lpSurf1=NULL;
	LPDIRECTDRAWSURFACE4 lpSurf4=NULL;

	*ppret=NULL;

	hr=m__dxj_Direct3dRMTexture3->GetSurface((DWORD)flags,&lpSurf1);
	if FAILED(hr) return hr;

	hr=lpSurf1->QueryInterface(IID_IDirectDrawSurface4,(void**)&lpSurf4);
    lpSurf1->Release();
	if FAILED(hr) 	return hr;
	

	INTERNAL_CREATE(_dxj_DirectDrawSurface4,lpSurf4,ppret);
	if (*ppret==NULL) {
		lpSurf4->Release();
		return hr;
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmtexture3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtexture3obj.h
//
//--------------------------------------------------------------------------

// d3drmTextureObj.h : Declaration of the C_dxj_Direct3dRMTextureObject

#ifndef _D3DRMTexture3_H_
#define _D3DRMTexture3_H_

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMTexture3 LPDIRECT3DRMTEXTURE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMTexture3Object : 
	public I_dxj_Direct3dRMTexture3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMTexture3Object, &CLSID__dxj_Direct3dRMTexture3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMTexture3Object() ;
	virtual ~C_dxj_Direct3dRMTexture3Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMTexture3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMTexture3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMTexture3,		"DIRECT.Direct3dRMTexture.3",		"DIRECT.Direct3dRMTexture3.5", IDS_D3DRMTEXTURE_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMTexture3Object)

// I_dxj_Direct3dRMTexture
public:

         HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE changed( 
            /* [in] */ long flags,
            /* [in] */ long nRects,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *rects);
        
         HRESULT STDMETHODCALLTYPE generateMIPMap();
        
         HRESULT STDMETHODCALLTYPE getCacheFlags( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getCacheImportance( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getColors( 
            /* [retval][out] */ long __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getDecalOrigin( 
            /* [out] */ long __RPC_FAR *x,
            /* [out] */ long __RPC_FAR *y);
        
         HRESULT STDMETHODCALLTYPE getDecalScale( 
            /* [retval][out] */ long __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getDecalSize( 
            /* [out] */ float __RPC_FAR *w,
            /* [out] */ float __RPC_FAR *h);
        
         HRESULT STDMETHODCALLTYPE getDecalTransparency( 
            /* [retval][out] */ long __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE getDecalTransparentColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *tc);
        
         HRESULT STDMETHODCALLTYPE getShades( 
            /* [retval][out] */ long __RPC_FAR *shades);
        
         HRESULT STDMETHODCALLTYPE getSurface( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE setCacheOptions(long importance, long flags); 
        
         HRESULT STDMETHODCALLTYPE setColors( 
            /* [in] */ long c);
        
         HRESULT STDMETHODCALLTYPE setDecalOrigin( 
            /* [in] */ long x,
            /* [in] */ long y);
        
         HRESULT STDMETHODCALLTYPE setDecalScale( 
            /* [in] */ long s);
        
         HRESULT STDMETHODCALLTYPE setDecalSize( 
            /* [in] */ float width,
            /* [in] */ float height);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparency( 
            /* [in] */ long trans);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparentColor( 
            /* [in] */ d3dcolor tcolor);
        
         HRESULT STDMETHODCALLTYPE setShades( 
            /* [in] */ long s);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMTexture3);

public:

	//mod:dp additions for D3dRMImage 
	byte *m_buffer1;
	byte *m_buffer2;
	byte *m_pallette;
	int m_buffer1size;
	int	m_buffer2size;
	int	m_palettesize;

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMTexture3 )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmtextureinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtextureinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmTextureInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMTextureInterpolator;


C_dxj_Direct3dRMTextureInterpolatorObject::C_dxj_Direct3dRMTextureInterpolatorObject(){
	m__dxj_Direct3dRMTextureInterpolator=NULL;
	m__dxj_Direct3dRMTexture3=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	
	DPF1(1,"Constructor Creation  Direct3dRMTextureInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMTextureInterpolator;
	g_dxj_Direct3dRMTextureInterpolator = (void *)this;
}


C_dxj_Direct3dRMTextureInterpolatorObject::~C_dxj_Direct3dRMTextureInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMTextureInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMTextureInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMTextureInterpolatorObject *ptr=(C_dxj_Direct3dRMTextureInterpolatorObject *)g_dxj_Direct3dRMTextureInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMTextureInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMTextureInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMTextureInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMTextureInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMTextureInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMTextureInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMTexture3)
			m__dxj_Direct3dRMTexture3->Release();

}


DWORD C_dxj_Direct3dRMTextureInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMTextureInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMTextureInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMTextureInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMTextureInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMTextureInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMTexture3,(void**)&m__dxj_Direct3dRMTexture3);	
	return hr;
}



HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMTextureInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMTextureInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMTextureInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMTextureInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMTextureInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;

	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMTextureInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalOrigin( long x, long y)
{
	return m__dxj_Direct3dRMTexture3->SetDecalOrigin((DWORD)x,(DWORD)y);
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalSize( float x, float y)
{
	return m__dxj_Direct3dRMTexture3->SetDecalSize(x,y);
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalTransparentColor( long c)
{
	return m__dxj_Direct3dRMTexture3->SetDecalTransparentColor((DWORD)c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmtextureinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtextureinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMTextureInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMTextureInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMTextureInterpolatorObject : 
	public I_dxj_Direct3dRMTextureInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMTextureInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMTextureInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMTextureInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMTextureInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMTextureInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        
			
         HRESULT STDMETHODCALLTYPE setDecalOrigin( 
            /* [in] */ long x,
            /* [in] */ long y);
        
         HRESULT STDMETHODCALLTYPE setDecalSize( 
            /* [in] */ float width,
            /* [in] */ float height);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparentColor( 
            /* [in] */ d3dcolor tcolor);
        
   
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMTextureInterpolator);
	LPDIRECT3DRMTEXTURE3 m__dxj_Direct3dRMTexture3;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMTextureInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmuservisualobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmuservisualobj.cpp
//
//--------------------------------------------------------------------------

// d3drmUserVisualObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmUserVisualObj.h"

CONSTRUCTOR(_dxj_Direct3dRMUserVisual, {m_enumcb=NULL;});
DESTRUCTOR(_dxj_Direct3dRMUserVisual, {cleanup();});
GETSET_OBJECT(_dxj_Direct3dRMUserVisual);


CLONE_R(_dxj_Direct3dRMUserVisual,Direct3DRMUserVisual);
GETNAME_R(_dxj_Direct3dRMUserVisual);
SETNAME_R(_dxj_Direct3dRMUserVisual);
GETCLASSNAME_R(_dxj_Direct3dRMUserVisual);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMUserVisual);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMUserVisual);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMUserVisual, setAppData, SetAppData,long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMUserVisual, getAppData, GetAppData, long);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMUserVisualObject::init(I_dxj_Direct3dRMUserVisualCallback *uvC, IUnknown *args)
{
	return E_NOINTERFACE;
}

void C_dxj_Direct3dRMUserVisualObject::cleanup(){

	if (!m_enumcb) return;
	if (m_enumcb->c) m_enumcb->c->Release();
	if (m_enumcb->pUser) m_enumcb->pUser->Release();
	delete m_enumcb;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmuservisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmuservisualobj.h
//
//--------------------------------------------------------------------------

// d3drmUserVisualObj.h : Declaration of the C_dxj_Direct3dRMUserVisualObject
#if 0

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMUserVisual LPDIRECT3DRMUSERVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMUserVisualObject : 
	public I_dxj_Direct3dRMUserVisual,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMUserVisualObject, &CLSID__dxj_Direct3dRMUserVisual>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMUserVisualObject() ;
	virtual ~C_dxj_Direct3dRMUserVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMUserVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMUserVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMUserVisual,	"DIRECT.Direct3dRMUserVisual.3",	"DIRECT.Direct3dRMUserVisual.3", IDS_D3DRMUSERVISUAL_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMUserVisualObject)

	//I_dxj_Direct3dRMUserVisual

public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);
	STDMETHOD(init)(I_dxj_Direct3dRMUserVisualCallback *fn, IUnknown *arg);

	////////////////////////////////////////////////////////////////////////////////////
	//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMUserVisual);	
	d3drmCallback *m_enumcb;

	void cleanup();

private:
	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMUserVisual )
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewport2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewport2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewport2Obj.h"
//#include "d3dViewport3Obj.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmDevice3Obj.h"



//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMViewport2Object::C_dxj_Direct3dRMViewport2Object(){
	m__dxj_Direct3dRMViewport2=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMViewport2[%d] \n",g_creationcount);

	nextobj =  g_dxj_Direct3dRMViewport2;
	g_dxj_Direct3dRMViewport2 = (void *)this;
}


C_dxj_Direct3dRMViewport2Object::~C_dxj_Direct3dRMViewport2Object(){

	DPF1(1,"Destructor  Direct3dRMViewport2 [%d] \n",creationid); 
	
	C_dxj_Direct3dRMViewport2Object *prev=NULL; 

	for(C_dxj_Direct3dRMViewport2Object *ptr=(C_dxj_Direct3dRMViewport2Object *)g_dxj_Direct3dRMViewport2;
		ptr;
		ptr=(C_dxj_Direct3dRMViewport2Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMViewport2 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMViewport2){ 
		int count = IUNK(m__dxj_Direct3dRMViewport2)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMViewport2 Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMViewport2 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
}


DWORD C_dxj_Direct3dRMViewport2Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMViewport2[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMViewport2Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMViewport2 [%d] Release %d \n",creationid,i);
	return i;
}




GETSET_OBJECT(_dxj_Direct3dRMViewport2);
CLONE_R(_dxj_Direct3dRMViewport2,Direct3DRMViewport2);


GETNAME_R(_dxj_Direct3dRMViewport2);
SETNAME_R(_dxj_Direct3dRMViewport2);
GETCLASSNAME_R(_dxj_Direct3dRMViewport2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMViewport2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMViewport2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, clear, Clear,long,(DWORD))
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setBack, SetBack, d3dvalue)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setFront, SetFront, d3dvalue)
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setField, SetField, d3dvalue)
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setUniformScaling, SetUniformScaling, long);
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMViewport2, configure, Configure, long,(long),long,(long),long,(DWORD),long,(DWORD));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMViewport2, forceUpdate, ForceUpdate, long,(DWORD),long,(DWORD),long,(DWORD),long,(DWORD));
PASS_THROUGH4_R(_dxj_Direct3dRMViewport2, setPlane, SetPlane, d3dvalue, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMViewport2, getPlane, GetPlane, D3DVALUE*, D3DVALUE*, D3DVALUE*, D3DVALUE*);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, setProjection, SetProjection, d3drmProjectionType, (enum _D3DRMPROJECTIONTYPE));

GET_DIRECT_R(_dxj_Direct3dRMViewport2, getHeight, GetHeight, long)
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getWidth,  GetWidth,  long)
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getUniformScaling, GetUniformScaling, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getX, GetX, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getY, GetY, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getField, GetField, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getBack, GetBack, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getFront, GetFront, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getProjection, GetProjection, d3drmProjectionType);

//RETURN_NEW_ITEM2_R(_dxj_Direct3dRMViewport2,pick,Pick,_dxj_Direct3dRMPickArray,long,long)
//#define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
//	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
//	return S_OK;}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::pick(long x, long y, I_dxj_Direct3dRMPickArray **rv)
{
	HRESULT hr;
	LPDIRECT3DRMPICKEDARRAY pArray=NULL;
	
	//MANBUGS 18014 pick can GPF is mesbuilder.enable is set to renderable (as opposed to pickable)
	//
	__try{
		hr= m__dxj_Direct3dRMViewport2->Pick(x,y,&pArray);
	}
	__except(0,0){
		return E_FAIL;
	}
	if FAILED(hr) return  hr;
	INTERNAL_CREATE(_dxj_Direct3dRMPickArray,pArray,rv);
	return hr; 
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::transform(D3dRMVector4d* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMViewport2->Transform( (D3DRMVECTOR4D*)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::inverseTransform(D3dVector* dst, D3dRMVector4d* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMViewport2->InverseTransform( (D3DVECTOR *)dst,  (D3DRMVECTOR4D*)src );
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getCamera(I_dxj_Direct3dRMFrame3 **cam)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetCamera(&realframe);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe,cam);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::setCamera(I_dxj_Direct3dRMFrame3 *cam)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	cam->InternalGetObject((IUnknown**)&realframe);
	hr= m__dxj_Direct3dRMViewport2->SetCamera((IDirect3DRMFrame3*)realframe);	
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getDevice(I_dxj_Direct3dRMDevice3 **dev)
{
	HRESULT hr;
	IDirect3DRMDevice3 *realdev=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetDevice(&realdev);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMDevice3,(IDirect3DRMDevice3*)realdev,dev);
	return hr;
}

#if 0
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getDirect3DViewport(I_dxj_Direct3dViewport3 **vp)
{
	HRESULT hr;
	IDirect3DViewport *realvp=NULL;
	IDirect3DViewport *realvp3=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetDirect3DViewport(&realvp);
	if FAILED(hr) return hr;

	hr = realvp->QueryInterface(IID_IDirect3DViewport3,(void**)&realvp3);
	INTERNAL_CREATE(_dxj_Direct3dViewport3,realvp3,vp);
	return hr;
}
#endif



STDMETHODIMP C_dxj_Direct3dRMViewport2Object::render(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	if (frame==NULL) return E_INVALIDARG;

	IDirect3DRMFrame3 *realframe= NULL;
	frame->InternalGetObject((IUnknown**)&realframe);

	hr= m__dxj_Direct3dRMViewport2->Render(realframe);
	
#ifdef _X86_
	_asm FINIT
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewportArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewportArrayObj.h"
#include "d3drmViewport2Obj.h"





CONSTRUCTOR(_dxj_Direct3dRMViewportArray, {});
DESTRUCTOR(_dxj_Direct3dRMViewportArray, {});
GETSET_OBJECT(_dxj_Direct3dRMViewportArray);

GET_DIRECT_R(_dxj_Direct3dRMViewportArray, getSize, GetSize, long);


#ifdef DX5
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMViewportArray, getElement, GetElement, _dxj_Direct3dRMViewport, long,(DWORD));
#else

STDMETHODIMP C_dxj_Direct3dRMViewportArrayObject::getElement(long index,I_dxj_Direct3dRMViewport2 **vp)
{
	HRESULT hr;
	LPDIRECT3DRMVIEWPORT pRealVP=NULL;
	LPDIRECT3DRMVIEWPORT2 pRealVP2=NULL;

	hr=m__dxj_Direct3dRMViewportArray->GetElement((DWORD)index,&pRealVP);
	if FAILED(hr) return hr;
	hr=pRealVP->QueryInterface(IID_IDirect3DRMViewport2,(void**)&pRealVP2);
	pRealVP->Release();
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMViewport2,pRealVP2,vp);
	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewport2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewport2obj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMViewport2Object

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewport2 LPDIRECT3DRMVIEWPORT2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewport2Object : 
	public I_dxj_Direct3dRMViewport2,
	public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewport2Object() ;
	virtual ~C_dxj_Direct3dRMViewport2Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewport2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewport2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewport2Object)

// I_dxj_Direct3dRMViewport2
public:

		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE render( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE getCamera( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE getDevice( 
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE setFront( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setBack( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setField( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setUniformScaling( 
            /* [in] */ long flag);
        
         HRESULT STDMETHODCALLTYPE setCamera( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE setProjection( 
            /* [in] */ d3drmProjectionType val);
        
         HRESULT STDMETHODCALLTYPE transform( 
            /* [out] */ D3dRMVector4d __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE inverseTransform( 
            /* [out] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dRMVector4d __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE configure( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long width,
            /* [in] */ long height);
        
         HRESULT STDMETHODCALLTYPE forceUpdate( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ float left,
            /* [in] */ float right,
            /* [in] */ float bottom,
            /* [in] */ float top);
        
         HRESULT STDMETHODCALLTYPE getPlane( 
            /* [out][in] */ float __RPC_FAR *l,
            /* [out][in] */ float __RPC_FAR *r,
            /* [out][in] */ float __RPC_FAR *b,
            /* [out][in] */ float __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE pick( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ I_dxj_Direct3dRMPickArray __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getUniformScaling( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getX( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getY( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getHeight( 
            /* [retval][out] */ long __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getWidth( 
            /* [retval][out] */ long __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getField( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getBack( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getFront( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getProjection( 
            /* [retval][out] */ d3drmProjectionType __RPC_FAR *retv);
        
        // HRESULT STDMETHODCALLTYPE getDirect3DViewport( 
        //    /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *val);
    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMViewport2);



public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewport2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmviewportarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmViewportArrayObj.h : Declaration of the C_dxj_Direct3dRMViewportArrayObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewportArray LPDIRECT3DRMVIEWPORTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewportArrayObject : 
	//public CComDualImpl<I_dxj_Direct3dRMViewportArray, &IID_I_dxj_Direct3dRMViewportArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMViewportArray,
	//public CComCoClass<C_dxj_Direct3dRMViewportArrayObject, &CLSID__dxj_Direct3dRMViewportArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewportArrayObject() ;
	virtual ~C_dxj_Direct3dRMViewportArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewportArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewportArray)
	//	COM_INTERFACE_ENTRY(IDispatch)
	//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMViewportArray, "DIRECT.Direct3dRMViewportArray.3",	"DIRECT.Direct3dRMViewportArray.3",IDS_D3DRMVIEWPORTARRAY_DESC,THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMViewportArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewportArrayObject)

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


// I_dxj_Direct3dRMViewportArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMViewport **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMViewport2 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMViewportArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewportArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewportInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMViewportInterpolator;


//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMViewportInterpolatorObject::C_dxj_Direct3dRMViewportInterpolatorObject(){
	m__dxj_Direct3dRMViewportInterpolator=NULL;
	m__dxj_Direct3dRMViewport2=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMViewportInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMViewportInterpolator;
	g_dxj_Direct3dRMViewportInterpolator = (void *)this;
}


C_dxj_Direct3dRMViewportInterpolatorObject::~C_dxj_Direct3dRMViewportInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMViewportInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMViewportInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMViewportInterpolatorObject *ptr=(C_dxj_Direct3dRMViewportInterpolatorObject *)g_dxj_Direct3dRMViewportInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMViewportInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMViewportInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMViewportInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMViewportInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMViewportInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMViewportInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMViewport2)
			m__dxj_Direct3dRMViewport2->Release();

}


DWORD C_dxj_Direct3dRMViewportInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMViewportInterpolator[%d] AddRef %d \n",creationid,i);

	return i;
}

DWORD C_dxj_Direct3dRMViewportInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMViewportInterpolator [%d] Release %d \n",creationid,i);
	
	return i;
}



HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMViewportInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMViewportInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMViewport2,(void**)&m__dxj_Direct3dRMViewport2);	
	return hr;
}



HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMViewportInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMViewportInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMViewportInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMViewportInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMViewportInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;

	LPDIRECT3DRMOBJECT pObj=NULL;
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMViewportInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}
        
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setFront(  float val){
	return m__dxj_Direct3dRMViewport2->SetFront(val);
}

HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setBack(  float val){
	return m__dxj_Direct3dRMViewport2->SetBack(val);
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setField(  float val){
	return m__dxj_Direct3dRMViewport2->SetField(val);
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setPlane(  float left, float right, float bottom, float top){
	return m__dxj_Direct3dRMViewport2->SetPlane(left,right,bottom,top);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmvisualarrayobj.cpp
//
//--------------------------------------------------------------------------

// _dxj_Direct3dRMVisualArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmMeshbuilder3Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmMeshObj.h"
#include "d3drmUserVisualObj.h"



CONSTRUCTOR(_dxj_Direct3dRMVisualArray, {});
DESTRUCTOR(_dxj_Direct3dRMVisualArray, {});
GETSET_OBJECT(_dxj_Direct3dRMVisualArray);

GET_DIRECT_R(_dxj_Direct3dRMVisualArray, getSize, GetSize, long);



STDMETHODIMP C_dxj_Direct3dRMVisualArrayObject::getElement(long i,I_dxj_Direct3dRMVisual **ret){
	HRESULT hr;
	LPDIRECT3DRMVISUAL lp=NULL;
	hr=m__dxj_Direct3dRMVisualArray->GetElement((DWORD)i,&lp);
	if FAILED(hr) return hr;

    hr=CreateCoverVisual(lp,ret);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmvisualarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmVisualArrayObj.h : Declaration of the C_dxj_Direct3dRMVisualArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMVisualArray LPDIRECT3DRMVISUALARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMVisualArrayObject : 
	public I_dxj_Direct3dRMVisualArray,
	//public CComCoClass<C_dxj_Direct3dRMVisualArrayObject, &CLSID__dxj_Direct3dRMVisualArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMVisualArrayObject() ;
	virtual ~C_dxj_Direct3dRMVisualArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMVisualArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisualArray)
END_COM_MAP()

// DECLARE_REGISTRY(CLSID__dxj_Direct3dRMVisualArray,	"DIRECT.Direct3dRMVisualArray.3",	"DIRECT.Direct3dRMVisualArray.3",  IDS_D3DRMVISUALARRAY_DESC,  THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMVisualArrayObject)

// I_dxj_Direct3dRMVisualArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMVisual **retv);		
	
private:
    DECL_VARIABLE(_dxj_Direct3dRMVisualArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMVisualArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMViewportInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewportInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewportInterpolatorObject : 	
	public I_dxj_Direct3dRMViewportInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewportInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMViewportInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewportInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewportInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewportInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
         HRESULT STDMETHODCALLTYPE setFront( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE setBack( 
            /* [in] */ float val);

         HRESULT STDMETHODCALLTYPE setField( 
            /* [in] */ float val);

         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ float left,
            /* [in] */ float right,
            /* [in] */ float bottom,
            /* [in] */ float top);
        
    
    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMViewportInterpolator);
	LPDIRECT3DRMVIEWPORT2	m__dxj_Direct3dRMViewport2;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewportInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmvisualobj.h
//
//--------------------------------------------------------------------------





// d3drmVisualObj.h : Declaration of the C_dxj_Direct3dRMVisualObject

#ifndef _D3DRMVISUAL_H_
#define _D3DRMVISUAL_H_

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMVisual LPDIRECT3DRMVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMVisualObject : 
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMVisualObject, &CLSID__dxj_Direct3dRMVisual>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMVisualObject() ;
	virtual ~C_dxj_Direct3dRMVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMVisual,		"DIRECT.Direct3dRMVisual.3",		"DIRECT.Direct3dRMVisual.3", IDS_D3DRMVISUAL_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMVisualObject)

// I_dxj_Direct3dRMVisual
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(I_dxj_Direct3dRMVisual **retval);

	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);

	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);

	STDMETHOD(getd3drmMeshBuilder)(I_dxj_Direct3dRMMeshBuilder3 **retval);
	STDMETHOD(getObjectType)(IUnknown **obj);	
	STDMETHOD(getd3drmMesh)(I_dxj_Direct3dRMMesh **retv);
	STDMETHOD(getd3drmTexture)(I_dxj_Direct3dRMTexture3 **retv);
	STDMETHOD(getd3drmFrame)(I_dxj_Direct3dRMFrame3 **retv);
	STDMETHOD(getd3drmShadow)( I_dxj_Direct3dRMShadow2 **retobj);
	
////////////////////////////////////////////////////////////////////////////////////
//
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMVisual);
	IUnknown *m_obj;

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMVisual )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmwrapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmwrapobj.cpp
//
//--------------------------------------------------------------------------

// d3drmWrapObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmWrapObj.h"


CONSTRUCTOR(_dxj_Direct3dRMWrap, {});
DESTRUCTOR(_dxj_Direct3dRMWrap,  {});
GETSET_OBJECT(_dxj_Direct3dRMWrap );

CLONE_R(_dxj_Direct3dRMWrap,Direct3DRMWrap);
GETNAME_R(_dxj_Direct3dRMWrap);
SETNAME_R(_dxj_Direct3dRMWrap);
GETCLASSNAME_R(_dxj_Direct3dRMWrap);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMWrap)
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMWrap)

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMWrap, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMWrap, getAppData, GetAppData, long);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::applyRelative(I_dxj_Direct3dRMFrame3 *ref, I_dxj_Direct3dRMObject *mesh)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	DO_GETOBJECT_NOTNULL( IUnknown*, lpU, mesh);
	IDirect3DRMFrame *realf=NULL;

	HRESULT hr = S_OK;
	LPDIRECT3DRMOBJECT lpObject=NULL;

	if (lpf) lpf->QueryInterface(IID_IDirect3DRMFrame,(void**)&realf);

	if (lpU) hr=lpU->QueryInterface(IID_IDirect3DRMObject,(void**)&lpObject);
	if FAILED(hr) return E_FAIL;

	hr= m__dxj_Direct3dRMWrap->ApplyRelative(realf, (LPDIRECT3DRMOBJECT)lpObject);
	if(lpObject) lpObject->Release();
	if (realf) realf->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::apply(I_dxj_Direct3dRMObject *mesh)
{
	DO_GETOBJECT_NOTNULL( IUnknown*, lpU, mesh);

	HRESULT hr = S_OK;
	LPDIRECT3DRMOBJECT lpObject=NULL;

	if (lpU) hr=lpU->QueryInterface(IID_IDirect3DRMObject,(void**)&lpObject);
	if FAILED(hr) return E_FAIL;

	hr= m__dxj_Direct3dRMWrap->Apply((LPDIRECT3DRMOBJECT)lpObject);
	if(lpObject) lpObject->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::init( d3drmWrapType t, I_dxj_Direct3dRMFrame3 *ref, 
						d3dvalue ox, d3dvalue oy, d3dvalue oz,
							d3dvalue dx, d3dvalue dy, d3dvalue dz,
								d3dvalue ux, d3dvalue uy, d3dvalue uz,
					d3dvalue ou , d3dvalue ov, d3dvalue su, d3dvalue sv)
{
	_D3DRMWRAPTYPE value = (enum _D3DRMWRAPTYPE)t;
	HRESULT hr;
	LPDIRECT3DRMFRAME lpf2=NULL;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);

	if (lpf) 
	{
		hr=lpf->QueryInterface(IID_IDirect3DRMFrame,(void**)&lpf2);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMWrap->Init(value,lpf2, 
					ox, oy, oz,	dx, dy, dz,	ux, uy, uz,	ou , ov, su, sv);

	if (lpf2) lpf2->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3drmwrapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmwrapobj.h
//
//--------------------------------------------------------------------------

// d3drmWrapObj.h : Declaration of the C_dxj_Direct3dRMWrapObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMWrap LPDIRECT3DRMWRAP

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMWrapObject : 
	public I_dxj_Direct3dRMWrap,
	public I_dxj_Direct3dRMObject,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMWrapObject() ;
	virtual ~C_dxj_Direct3dRMWrapObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMWrapObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMWrap)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMWrap,			"DIRECT.Direct3dRMWrap.3",			"DIRECT.Direct3dRMWrap.3", IDS_D3DRMWRAP_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMWrapObject)

// I_dxj_Direct3dRMWrap
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(init)( d3drmWrapType, I_dxj_Direct3dRMFrame3 *ref,
							d3dvalue ox, d3dvalue oy, d3dvalue oz,
							d3dvalue dx, d3dvalue dy, d3dvalue dz,
							d3dvalue ux, d3dvalue uy, d3dvalue uz,
							d3dvalue ou, d3dvalue ov, d3dvalue su, d3dvalue sv);

	STDMETHOD(apply)( I_dxj_Direct3dRMObject *mesh);
	STDMETHOD(applyRelative)( I_dxj_Direct3dRMFrame3 *f, I_dxj_Direct3dRMObject *mesh);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMWrap);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMWrap )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3dvertexbuffer7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.h
//
//--------------------------------------------------------------------------

// d3dMaterialObj.h : Declaration of the C_dxj_Direct3dMaterialObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dVertexBuffer7 LPDIRECT3DVERTEXBUFFER7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dVertexBuffer7Object : 
	public I_dxj_Direct3dVertexBuffer7,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dVertexBuffer7Object() ;
	virtual ~C_dxj_Direct3dVertexBuffer7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dVertexBuffer7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dVertexBuffer7)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dVertexBuffer7Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE unlock( void);
        
        HRESULT STDMETHODCALLTYPE optimize( 
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
            );
        
        HRESULT STDMETHODCALLTYPE processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);

		HRESULT STDMETHODCALLTYPE setVertexSize( /* [in] */ long n);

private:
    DECL_VARIABLE(_dxj_Direct3dVertexBuffer7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dVertexBuffer7)
	void	*m_pData;
	DWORD	m_vertSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\d3dvertexbuffer7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.cpp
//
//--------------------------------------------------------------------------

// d3dMaterialObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dVertexBuffer7Obj.h"

CONSTRUCTOR(_dxj_Direct3dVertexBuffer7,  {m_pData=NULL;m_vertSize=0;});
DESTRUCTOR(_dxj_Direct3dVertexBuffer7,  {});
GETSET_OBJECT(_dxj_Direct3dVertexBuffer7);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc)
{
	HRESULT hr;
	((D3DVERTEXBUFFERDESC*)desc)->dwSize=sizeof(D3DVERTEXBUFFERDESC);
	hr=m__dxj_Direct3dVertexBuffer7->GetVertexBufferDesc((D3DVERTEXBUFFERDESC*)desc);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
			long flags
            )
{
	HRESULT hr;

	if (!srcBuffer) return E_INVALIDARG;
	if (!dev) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DVERTEXBUFFER7, realBuffer, srcBuffer);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realDev, dev);

	hr=m__dxj_Direct3dVertexBuffer7->ProcessVertices(
		(DWORD) vertexOp,
		(DWORD) destIndex,
		(DWORD) count,
		realBuffer,
		(DWORD) srcIndex,
		realDev,
		(DWORD) flags);


	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::lock( 
            /* [in] */ long flags)
{
	HRESULT hr;
	

	hr=m__dxj_Direct3dVertexBuffer7->Lock((DWORD) flags, &m_pData,NULL);
		
	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertexSize( /* [in] */ long n)
{
	m_vertSize=(DWORD)n;
		
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::unlock()
{
	HRESULT hr;
	hr=m__dxj_Direct3dVertexBuffer7->Unlock();
	m_pData=NULL;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::optimize(
		    /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
             )
        
{
	HRESULT hr;
	if (!dev) return E_INVALIDARG;
	
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realdev, dev);
	
	hr=m__dxj_Direct3dVertexBuffer7->Optimize(realdev,(DWORD) 0);
	
	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
		
	if (!m_vertSize) return E_FAIL;
	if (!m_pData) return E_FAIL;
	if (!verts) return E_INVALIDARG;

	__try {
		memcpy(&(((char*)m_pData) [startIndex*m_vertSize]),verts,count*m_vertSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////        

STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
	
	if (!m_vertSize) {				
		return E_FAIL;
	}
	if (!m_pData) {		
		return E_FAIL;
	}
	if (!verts) return E_INVALIDARG;

	__try {
		memcpy(verts,&( ((char*)m_pData) [startIndex*m_vertSize]),count*m_vertSize);
	}
	__except(1,1){		
		return E_FAIL;
	}
	

	
	return S_OK;
}
           


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddclipperobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddclipperobj.h
//
//--------------------------------------------------------------------------

// ddClipperObj.h : Declaration of the C_dxj_DirectDrawClipperObject


#include "resource.h"       // main symbols
#include "wingdi.h" 

#define DDCOOPERATIVE_CLIPTOCOMPONENT   0x30000000
#define DDCOOPERATIVE_OFFSETTOCOMPONENT 0x20000000

#define typedef__dxj_DirectDrawClipper LPDIRECTDRAWCLIPPER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawClipperObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawClipper, &IID_I_dxj_DirectDrawClipper, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawClipper,
#endif
//	public CComCoClass<C_dxj_DirectDrawClipperObject, &CLSID__dxj_DirectDrawClipper>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawClipperObject() ;
	virtual ~C_dxj_DirectDrawClipperObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawClipperObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawClipper)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawClipperObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// I_dxj_DirectDrawClipper
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpddc);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpddc);
        
         HRESULT STDMETHODCALLTYPE getClipListSize( 
            /* [retval][out] */ int __RPC_FAR *count);


         HRESULT STDMETHODCALLTYPE getClipList( 
				SAFEARRAY **list);
        
         HRESULT STDMETHODCALLTYPE setClipList( 
            /* [in] */ long count, SAFEARRAY **list);
        
         HRESULT STDMETHODCALLTYPE getHWnd( 
            /* [retval][out] */ HWnd __RPC_FAR *hdl);
        
         HRESULT STDMETHODCALLTYPE setHWnd( 
           // /* [in] */ long flags,
            /* [in] */ HWnd hdl);
        
        
         HRESULT STDMETHODCALLTYPE isClipListChanged( 
            /* [retval][out] */ int __RPC_FAR *status);
        

private:
	DECL_VARIABLE(_dxj_DirectDrawClipper);



public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawClipper );
	int m_flags;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddclipperobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddclipperobj.cpp
//
//--------------------------------------------------------------------------

// ddClipperObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include <stdio.h>
#include "Direct.h"
#include "dms.h"
#include "ddClipperObj.h"


			 
typedef HRESULT (__stdcall *DDCREATECLIPPER)( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );


C_dxj_DirectDrawClipperObject::C_dxj_DirectDrawClipperObject(){ 
	 m__dxj_DirectDrawClipper= NULL;
	 parent = NULL;
	 pinterface = NULL; 
	 nextobj =  g_dxj_DirectDrawClipper;
	 creationid = ++g_creationcount;
	 
	 DPF1(1,"Clipper Creation Id [%d] \n",g_creationcount);

	 g_dxj_DirectDrawClipper = (void *)this; 

 }



C_dxj_DirectDrawClipperObject::~C_dxj_DirectDrawClipperObject()
{


    C_dxj_DirectDrawClipperObject *prev=NULL; 
	for(C_dxj_DirectDrawClipperObject *ptr=(C_dxj_DirectDrawClipperObject *)g_dxj_DirectDrawClipper; ptr; ptr=(C_dxj_DirectDrawClipperObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDrawClipper = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDrawClipper){

		int count = IUNK(m__dxj_DirectDrawClipper)->Release();
		
		DPF1(1,"Clipper Real Ref count [%d] \n",count);
		
		if(count==0) m__dxj_DirectDrawClipper = NULL;
			
	} 

	if(parent) IUNK(parent)->Release();

}

DWORD C_dxj_DirectDrawClipperObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();		
	DPF2(1,"Clipper [%d] AddRef %d \n",creationid,i);		
	return i;
}

DWORD C_dxj_DirectDrawClipperObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();		
	DPF2(1,"Clipper [%d] Release %d \n",creationid,i);	
	return i;
}


GETSET_OBJECT(_dxj_DirectDrawClipper);

PASS_THROUGH1_R(_dxj_DirectDrawClipper, isClipListChanged, IsClipListChanged, int *);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getClipListSize(int *count) 
{

	HRESULT retval;
	unsigned long  buffsize;

	
	//a NULL RGNDATA pointer returns size!!!
	retval = m__dxj_DirectDrawClipper->GetClipList((LPRECT)NULL, (LPRGNDATA)NULL, &buffsize);

	// return size as number of longs in the rect array  
	if ( retval != DD_OK )
		*count = 0;		// this case probably means no cliplist is avaible 
	else
		*count = (buffsize - sizeof(RGNDATAHEADER))/sizeof(LONG);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getClipList( SAFEARRAY **list)
{
	HRESULT retval;
	LPRGNDATA tmprgn=NULL;
	DWORD  buffsize;

	
	

	// allocate a private copy of the cliplist 
	retval = m__dxj_DirectDrawClipper->GetClipList((LPRECT)NULL, (LPRGNDATA)NULL, &buffsize);
	if FAILED(retval) return retval;

	tmprgn = (LPRGNDATA)malloc(buffsize); 
	if ( !tmprgn )	return E_OUTOFMEMORY;
	
	ZeroMemory(tmprgn,buffsize);
	tmprgn->rdh.dwSize   = sizeof(RGNDATAHEADER); 
	tmprgn->rdh.iType    = RDH_RECTANGLES;
	tmprgn->rdh.nCount;	 

	// get the actual clip list 	
	retval = m__dxj_DirectDrawClipper->GetClipList(NULL,tmprgn,&buffsize);
	if ( retval != DD_OK )	return retval;
	
	
	__try{
		memcpy ( (((SAFEARRAY*)*list))->pvData,tmprgn->Buffer,tmprgn->rdh.nRgnSize);
	}
	__except(1,1){
		if (tmprgn) free(tmprgn);
		return E_FAIL;
	}

	free(tmprgn);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::setClipList( long count, SAFEARRAY **list)
{
	HRESULT retval;
	LPRGNDATA tmprgn;


	// allocate a private copy of the cliplist 
	tmprgn = (LPRGNDATA)malloc(sizeof(RGNDATAHEADER)+(count*sizeof(RECT))); 
	if ( !tmprgn )	return E_OUTOFMEMORY;

	ZeroMemory(tmprgn,sizeof(RGNDATAHEADER)+(count*sizeof(RECT)));
	tmprgn->rdh.dwSize   = sizeof(RGNDATAHEADER); 
    	tmprgn->rdh.iType    = RDH_RECTANGLES;
    	tmprgn->rdh.nCount   = count;
    	tmprgn->rdh.nRgnSize = count*sizeof(RECT);

	__try{
		memcpy ( tmprgn->Buffer,(((SAFEARRAY*)*list))->pvData,tmprgn->rdh.nRgnSize);
	}
	__except(1,1){
		if (tmprgn) free(tmprgn);
		return E_FAIL;
	}


	retval = m__dxj_DirectDrawClipper->SetClipList(tmprgn,0);

	free(tmprgn);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getHWnd( HWnd *hwn)
{
	if (!hwn) return E_FAIL;
	return m__dxj_DirectDrawClipper->GetHWnd( (HWND*)hwn );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::setHWnd(  HWnd hwn)
{
	return m__dxj_DirectDrawClipper->SetHWnd(0, (HWND)hwn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddcolorcontrol.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawColorControl LPDIRECTDRAWCOLORCONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawColorControlObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawColorControl, &IID_I_dxj_DirectDrawColorControl, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawColorControl
#endif

//	public CComCoClass<C_dxj_DirectDrawColorControlObject, &CLSID__dxj_DirectDrawColorControl>, public CComObjectRoot
{
public:
	C_dxj_DirectDrawColorControlObject() ;
	virtual ~C_dxj_DirectDrawColorControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawColorControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawColorControl)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

	DECLARE_REGISTRY(CLSID__dxj_DirectDrawColorControl,	"DIRECT.DirectDrawColorControl.5",		"DIRECT.DirectDrawColorControl.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawColorControlObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawColorControlObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawColorControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);


private:
    DECL_VARIABLE(_dxj_DirectDrawColorControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawColorControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrolobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddcolorcontrolobj.cpp
//
//--------------------------------------------------------------------------

// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddColorControlObj.h"


CONSTRUCTOR(_dxj_DirectDrawColorControl, {});
DESTRUCTOR(_dxj_DirectDrawColorControl, {});
GETSET_OBJECT(_dxj_DirectDrawColorControl);


   
STDMETHODIMP C_dxj_DirectDrawColorControlObject::getColorControls(DDColorControl *col)
{    
	HRESULT hr = DD_OK;
	if (!col) return E_INVALIDARG;
	((DDCOLORCONTROL*)col)->dwSize=sizeof(DDCOLORCONTROL);
    hr=m__dxj_DirectDrawColorControl->GetColorControls((DDCOLORCONTROL*)col);	
	return hr;
}

STDMETHODIMP C_dxj_DirectDrawColorControlObject::setColorControls(DDColorControl *col)
{    
	HRESULT hr = DD_OK;
	if (!col) return E_INVALIDARG;
	((DDCOLORCONTROL*)col)->dwSize=sizeof(DDCOLORCONTROL);
    hr=m__dxj_DirectDrawColorControl->SetColorControls((DDCOLORCONTROL*)col);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrolobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddcolorcontrolobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawColorControl LPDIRECTDRAWCOLORCONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawColorControlObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawColorControl, &IID_I_dxj_DirectDrawColorControl, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawColorControl,
#endif
//	public CComCoClass<C_dxj_DirectDrawColorControlObject, &CLSID__dxj_DirectDrawColorControl>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawColorControlObject() ;
	virtual ~C_dxj_DirectDrawColorControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawColorControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawColorControl)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawColorControl,   "DIRECT.ddPalette.3",	"DIRECT.DirectDrawColorControl.3",	IDS_DDPALETTE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawColorControlObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawColorControlObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawColorControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);
	STDMETHOD(getColorControls)( DDColorControl *colorcontrol);
	STDMETHOD(setColorControls)( DDColorControl *colorcontrol);
        

private:
    DECL_VARIABLE(_dxj_DirectDrawColorControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawColorControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumexobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumexobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDEnumExObject : 
	public I_dxj_DDEnumEx,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumExObject() ;
	virtual ~C_dxj_DDEnumExObject() ;

BEGIN_COM_MAP(C_dxj_DDEnumExObject)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumEx)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumExObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DriverInfoEx *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DDEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DDEnumEx **ppRet);
		

public:
		DriverInfoEx	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumexobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumexobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglobobj.h"
#include "DDEnumExObj.h"

extern "C" BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumExCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg,
  HANDLE hMon
)
{

	DPF(1,"Entered objDirectDrawEnumExCallback \r\n");
	
	C_dxj_DDEnumExObject *pObj=(C_dxj_DDEnumExObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		pObj->m_pList=(DriverInfoEx*)realloc(pObj->m_pList,sizeof(DriverInfoEx)* pObj->m_nMax);
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DriverInfoEx));
	
	pObj->m_pList[pObj->m_nCount].guid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].description=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].name=T2BSTR(lpDriverName);
	}

	pObj->m_pList[pObj->m_nCount].hMon=hMon

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].guid) SysFreeString(m_pList[i].guid);
			if (m_pList[i].description) SysFreeString(m_pList[i].description);
			if (m_pList[i].name) SysFreeString(m_pList[i].name);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DDEnumObject::getItem( long index, DriverInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DriverInfo));

	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenummodes2obj.h ===
#include "resource.h"       

class C_dxj_DDEnumModes2Object : 
	public I_dxj_DDEnumModes2,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumModes2Object() ;
	virtual ~C_dxj_DDEnumModes2Object() ;

BEGIN_COM_MAP(C_dxj_DDEnumModes2Object)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumModes2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumModes2Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDSurfaceDesc2 *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DDEnumModes2Object::create(LPDIRECTDRAW4 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DDEnumModes2 **ppRet);			   
		//static HRESULT C_dxj_DDEnumModes2Object::create7(LPDIRECTDRAW7 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DDEnumModes2 **ppRet);			   

public:
		DDSurfaceDesc2	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenummodes2obj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDEnumModes2Obj.h"


extern		BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumModes2Callback(LPDDSURFACEDESC2 lpDesc, void *lpArg)
{
	#ifdef _DEBUG
	OutputDebugString("Entered objEnumModes2Callback\r\n");
	#endif


	
	C_dxj_DDEnumModes2Object *pObj=(C_dxj_DDEnumModes2Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DDSurfaceDesc2*)realloc(pObj->m_pList,sizeof(DDSurfaceDesc2)* pObj->m_nMax);
		else
			pObj->m_pList=(DDSurfaceDesc2*)malloc(sizeof(DDSurfaceDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	if (lpDesc==NULL) {
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
	
	
	HRESULT hr=CopyOutDDSurfaceDesc2(&(pObj->m_pList[pObj->m_nCount]),lpDesc);
	if (FAILED(hr)){
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
		
	
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumModes2Object::C_dxj_DDEnumModes2Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumModes2Object::~C_dxj_DDEnumModes2Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumModes2Object::create(LPDIRECTDRAW4 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DDEnumModes2 **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumModes2Object *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DDEnumModes2Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumModes2,(void**)ppRet);
	return hr;
}

#if 0
HRESULT C_dxj_DDEnumModes2Object::create7(LPDIRECTDRAW7 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DDEnumModes2 **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumModes2Object *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DDEnumModes2Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumModes2,(void**)ppRet);
	return hr;
}
#endif

HRESULT C_dxj_DDEnumModes2Object::getItem( long index, DDSurfaceDesc2 *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index-1]),sizeof(DDSurfaceDesc2));

	return S_OK;
}

HRESULT C_dxj_DDEnumModes2Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenum.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxGlob7Obj.h"
#include "DDEnumObj.h"

extern  BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg            
)
{


	DPF(1,"Entered objDirectDrawEnumCallback \r\n");
	
	C_dxj_DDEnumObject *pObj=(C_dxj_DDEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if  (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

/*
HRESULT C_dxj_DDEnumObject::getItem( long index, DxDriverInfo *inf)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;
	if (!inf) return E_FAIL;
	
	//C2819
	(*inf).strGuid=SysAllocString(m_pList[index].strGuid);
	(*inf).strDescription=SysAllocString(m_pList[index].strDescription);
	(*inf).strName=SysAllocString(m_pList[index].strName);

	return S_OK;
}
*/

HRESULT C_dxj_DDEnumObject::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_DDEnumObject::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        


HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenummodesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenummodesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumModesObject : 
	public I_dxj_DirectDrawEnumModes,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumModesObject() ;
	virtual ~C_dxj_DirectDrawEnumModesObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumModesObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnumModes)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumModesObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDSurfaceDesc2 *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW7 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DirectDrawEnumModes **ppRet);			   
		
		static HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW4 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DirectDrawEnumModes **ppRet);			   

public:
		DDSurfaceDesc2	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenummodesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenummodesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDEnumModesObj.h"


extern		BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumModes2Callback(LPDDSURFACEDESC2 lpDesc, void *lpArg)
{
	DPF(1,"Entered objEnumModes2Callback\r\n");



	
	C_dxj_DirectDrawEnumModesObject *pObj=(C_dxj_DirectDrawEnumModesObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DDSurfaceDesc2)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DDSurfaceDesc2*)tmp;
			else
				return DDENUMRET_CANCEL;
		}
		else
			pObj->m_pList=(DDSurfaceDesc2*)malloc(sizeof(DDSurfaceDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	if (lpDesc==NULL) {
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
	
	
	HRESULT hr=CopyOutDDSurfaceDesc2(&(pObj->m_pList[pObj->m_nCount]),lpDesc);
	if (FAILED(hr)){
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
		
	
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectDrawEnumModesObject::C_dxj_DirectDrawEnumModesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectDrawEnumModesObject::~C_dxj_DirectDrawEnumModesObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW7 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DirectDrawEnumModes **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumModesObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DirectDrawEnumModesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumModes,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW4 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DirectDrawEnumModes **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumModesObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DirectDrawEnumModesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumModes,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumModesObject::getItem( long index, DDSurfaceDesc2 *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index-1]),sizeof(DDSurfaceDesc2));

	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumModesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumObject : 
	public I_dxj_DirectDrawEnum,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumObject() ;
	virtual ~C_dxj_DirectDrawEnumObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
		
		HRESULT STDMETHODCALLTYPE getMonitorHandle( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret);
			
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
		static HRESULT C_dxj_DirectDrawEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DirectDrawEnum **ppRet);
		

public:
		DxDriverInfoEx *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumplayersobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumplayersobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglobobj.h"
#include "DDEnumObj.h"

extern "C" BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg            
)
{

	#ifdef _DEBUG
	OutputDebugString("Entered objDirectDrawEnumCallback \r\n");
	#endif
	
	C_dxj_DDEnumObject *pObj=(C_dxj_DDEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].guid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].description) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].name) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DDEnumObject::getItem( long index, DxDriverInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DxDriverInfo));

	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfaces7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumsurfaces7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDEnumSurfaces7Object : 
	public I_dxj_DDEnumSurfaces7,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumSurfaces7Object() ;
	virtual ~C_dxj_DDEnumSurfaces7Object() ;

BEGIN_COM_MAP(C_dxj_DDEnumSurfaces7Object)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumSurfaces7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumSurfaces7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectDrawSurface7 **retVal);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(LPDIRECTDRAW7 dd,long flags, DDSurfaceDesc2 *desc,I_dxj_DDEnumSurfaces7 **ppRet);		
		static HRESULT createAttachedEnum(LPDIRECTDRAWSURFACE7  dds,  I_dxj_DDEnumSurfaces7 **ppRet);
		static HRESULT createZEnum(LPDIRECTDRAWSURFACE7  dds, long flags, I_dxj_DDEnumSurfaces7 **ppRet);

public:
		I_dxj_DirectDrawSurface7	**m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;
private:
		LPDIRECTDRAW7	m_pDD;
		LPDIRECTDRAWSURFACE7	m_pDDS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfacesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenumsurfacesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDSurface7Obj.h"
#include "DDEnumSurfacesObj.h"
#include "DDraw7obj.h"

extern BOOL IsAllZeros(void*,DWORD size);



extern "C" HRESULT PASCAL objEnumSurfaces7Callback(LPDIRECTDRAWSURFACE7 lpddSurf,
								LPDDSURFACEDESC2 lpDDSurfaceDesc, void *lpArg)
{
	
	DPF(1,"Entered objEnumSurfaces7Callback \r\n");
	
	if (!lpddSurf) return DDENUMRET_CANCEL;

 	C_dxj_DirectDrawEnumSurfacesObject  *pObj=(C_dxj_DirectDrawEnumSurfacesObject  *)lpArg;
	I_dxj_DirectDrawSurface7	*lpddSNew=NULL;

	if (pObj==NULL) {
		return DDENUMRET_CANCEL;
	}
	
	

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(IDirectDrawSurface7**)tmp;
			else
				return DDENUMRET_CANCEL;
		}
		else
			pObj->m_pList=(IDirectDrawSurface7**)malloc(sizeof(void*) * pObj->m_nMax);


		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return DDENUMRET_OK;
		}
	}


	pObj->m_pList[pObj->m_nCount]=lpddSurf;
	pObj->m_nCount++;

	//no need to release the surface we do that on tear down

	return DDENUMRET_OK;
}



    
DWORD C_dxj_DirectDrawEnumSurfacesObject::InternalAddRef(){
    DWORD i;
    i=CComObjectRoot::InternalAddRef();        	
    DPF2(1,"EnumSurf7 [%d] AddRef %d \n",creationid,i);
    return i;
}

DWORD C_dxj_DirectDrawEnumSurfacesObject::InternalRelease(){
    DWORD i;
    i=CComObjectRoot::InternalRelease();
    DPF2(1,"EnumSurf7 [%d] Release %d \n",creationid,i);
    return i;
}


C_dxj_DirectDrawEnumSurfacesObject::C_dxj_DirectDrawEnumSurfacesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
	parent=NULL;
}

C_dxj_DirectDrawEnumSurfacesObject::~C_dxj_DirectDrawEnumSurfacesObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i]) m_pList[i]->Release();
		}
		free(m_pList);
	}
	//if (m_pDDS)	m_pDDS->Release();
	//if (m_pDD)	m_pDD->Release();
	
	if (parent)		IUNK(parent)->Release();

}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::create(I_dxj_DirectDraw7  *dd7, long flags, DDSurfaceDesc2 *desc,I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	if (!dd7) return E_INVALIDARG;
	LPDIRECTDRAW7 dd=NULL;
	dd7->InternalGetObject((IUnknown**)&dd);
	
	//For the sake of making sure that all Surface7 are destroyed before
	//ddraw is
	

	HRESULT hr;
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

		
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	pNew->parent=dd7;
	IUNK(pNew->parent)->AddRef();

	
	
	//if FAILED(hr) return hr;

	if ((desc==NULL)||(IsAllZeros(desc,sizeof(DDSurfaceDesc2))))
	{
		hr=dd->EnumSurfaces((DWORD)flags,NULL,(void*)pNew,objEnumSurfaces7Callback);		
	}
	else 
	{		
		DDSURFACEDESC2 realdesc;
		hr=CopyInDDSurfaceDesc2(&realdesc,desc);
		if (hr==S_OK){			
			hr=dd->EnumSurfaces((DWORD)flags,(DDSURFACEDESC2*)&realdesc,(void*)pNew,objEnumSurfaces7Callback);
			
		}
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);
	
	return hr;
}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::createZEnum( I_dxj_DirectDrawSurface7 *ddS, long flags, I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	HRESULT hr;
	LPDIRECTDRAWSURFACE7 dd=NULL;
	
	if (!ddS) return E_INVALIDARG;
	ddS->InternalGetObject((IUnknown**)&dd);

	
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	pNew->parent=ddS;
	IUNK(pNew->parent)->AddRef();
	
	hr=dd->EnumOverlayZOrders((DWORD)flags,(void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);
	
	return hr;
}

HRESULT C_dxj_DirectDrawEnumSurfacesObject::createAttachedEnum(I_dxj_DirectDrawSurface7 *ddS,  I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	

	HRESULT hr;
	LPDIRECTDRAWSURFACE7  dd=NULL;
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

	if (!ddS) return E_INVALIDARG;

	ddS->InternalGetObject((IUnknown**)&dd);
	
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	
	pNew->m_bProblem=FALSE;	
	pNew->parent=ddS;
	IUNK(pNew->parent)->AddRef();
	
	hr=dd->EnumAttachedSurfaces((void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}


	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);


	return hr;
}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::getItem( long index, I_dxj_DirectDrawSurface7 **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	IDirectDrawSurface7 *pRealSurf=m_pList[index-1];
	
	if (!pRealSurf) return E_FAIL;	
	pRealSurf->AddRef();
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, pRealSurf, info);	
	

	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumSurfacesObject::getCount(long *retVal)
{

	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxGlob7Obj.h"
#include "DDEnumObj.h"

extern  BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg,
  HMONITOR hm
)
{

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");	
	
	C_dxj_DirectDrawEnumObject *pObj=(C_dxj_DirectDrawEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if  (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DxDriverInfoEx)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DxDriverInfoEx*)tmp;
			else
				return DDENUMRET_CANCEL;
		}
		else
			pObj->m_pList=(DxDriverInfoEx*)malloc(sizeof(DxDriverInfoEx)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfoEx));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_pList[pObj->m_nCount].hMonitor=(long)PtrToLong(hm);	//bugbug SUNDOWN	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectDrawEnumObject::C_dxj_DirectDrawEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectDrawEnumObject::~C_dxj_DirectDrawEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString((BSTR)m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString((BSTR)m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString((BSTR)m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DirectDrawEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DirectDrawEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DirectDrawEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	  hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew,DDENUM_ATTACHEDSECONDARYDEVICES |   DDENUM_NONDISPLAYDEVICES);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnum,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumObject::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumObject::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_DirectDrawEnumObject::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_DirectDrawEnumObject::getMonitorHandle( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!ret) return E_INVALIDARG;

	*ret=m_pList[index-1].hMonitor;
	
	return S_OK;
}
        


HRESULT C_dxj_DirectDrawEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfaces7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumsurfaces7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDSurface7Obj.h"
#include "DDEnumSurfaces7Obj.h"

extern BOOL IsAllZeros(void*,DWORD size);
//extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2*,DDSurfaceDesc2*);
//extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2*);


//////////////////////////////////////////////////////////////////////
// objEnumSurfaces7Callback
//////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumSurfaces7Callback(LPDIRECTDRAWSURFACE7 lpddSurf,
								LPDDSURFACEDESC2 lpDDSurfaceDesc, void *lpArg)
{
	DPF1(1,"Entered objEnumSurfaces7Callback \r\n");


	C_dxj_DDEnumSurfaces7Object  *pObj=(C_dxj_DDEnumSurfaces7Object  *)lpArg;
	I_dxj_DirectDrawSurface7	*lpddSNew=NULL;

	if (pObj==NULL) {
		pObj->m_bProblem=TRUE;
		return DDENUMRET_CANCEL;
	}

	//create a surface7 object but dont have a back reference to this object!!!
	INTERNAL_CREATE_NOADDREF(_dxj_DirectDrawSurface7, lpddSurf, &lpddSNew);
	if (lpddSNew==NULL) {
		pObj->m_bProblem=TRUE;
		return DDENUMRET_CANCEL;
	}
		
	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(I_dxj_DirectDrawSurface7**)realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
		else
			pObj->m_pList=(I_dxj_DirectDrawSurface7**)malloc(sizeof(void*) * pObj->m_nMax);


		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return DDENUMRET_OK;
		}
	}


	pObj->m_pList[pObj->m_nCount]=lpddSNew;

	return DDENUMRET_OK;
}

//////////////////////////////////////////////////////////////////////
// C_dxj_DDEnumSurfaces7Object
//////////////////////////////////////////////////////////////////////
C_dxj_DDEnumSurfaces7Object::C_dxj_DDEnumSurfaces7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
	m_pDD=NULL;
	m_pDDS=NULL;
}

//////////////////////////////////////////////////////////////////////
// ~C_dxj_DDEnumSurfaces7Object
//////////////////////////////////////////////////////////////////////
C_dxj_DDEnumSurfaces7Object::~C_dxj_DDEnumSurfaces7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i]) m_pList[i]->Release();
		}
		free(m_pList);
	}
	if (m_pDDS)	m_pDDS->Release();
	if (m_pDD)	m_pDD->Release();
}


//////////////////////////////////////////////////////////////////////
// create  ddraw->enum
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::create(LPDIRECTDRAW7  dd, long flags, DDSurfaceDesc2 *desc,I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	return E_NOTIMPL;

	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDD=dd;
	pNew->m_pDD->AddRef();
	

	//if the description is all zeros allow use to pass in NULL
	if ((desc==NULL)||(IsAllZeros(desc,sizeof(DDSurfaceDesc2)))){
		//d3dcore bug
		//hr=dd->EnumSurfaces((DWORD)flags,NULL,(void*)pNew,objEnumSurfaces7Callback);
	}
	//otherwise use the surface description to enumerate
	else {		
		DDSURFACEDESC2 realdesc;
		hr=CopyInDDSurfaceDesc2(&realdesc,desc);
		if (hr==S_OK){
			//d3dcore bug
		//	hr=dd->EnumSurfaces((DWORD)flags,(DDSURFACEDESC2*)&realdesc,(void*)pNew,objEnumSurfaces7Callback);
		}
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// createZEnum  ddrawsurface->enumZ
//////////////////////////////////////////////////////////////////////
			
HRESULT C_dxj_DDEnumSurfaces7Object::createZEnum(LPDIRECTDRAWSURFACE7  dd, long flags, I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	
	//return E_NOTIMPL;

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDDS=dd;
	pNew->m_pDDS->AddRef();
	
	//d3d core bug
	hr=dd->EnumOverlayZOrders((DWORD)flags,(void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}


//////////////////////////////////////////////////////////////////////
// createAttachedEnum  ddrawsurface->enum
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::createAttachedEnum(LPDIRECTDRAWSURFACE7  dd,  I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	
	//return E_NOTIMPL;

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDDS=dd;
	pNew->m_pDDS->AddRef();
	
	hr=dd->EnumAttachedSurfaces((void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// getItem
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::getItem( long index, I_dxj_DirectDrawSurface7 **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*info=m_pList[index];
	if (m_pList[index-1]) (m_pList[index-1])->AddRef();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// getCount
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfacesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenumsurfacesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumSurfacesObject : 
	public I_dxj_DirectDrawEnumSurfaces,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumSurfacesObject() ;
	virtual ~C_dxj_DirectDrawEnumSurfacesObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumSurfacesObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnumSurfaces)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumSurfacesObject)

public:
		DWORD InternalAddRef();
		DWORD InternalRelease();
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectDrawSurface7 **retVal);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(I_dxj_DirectDraw7 *ddS,long flags, DDSurfaceDesc2 *desc,I_dxj_DirectDrawEnumSurfaces **ppRet);		
		static HRESULT createAttachedEnum(I_dxj_DirectDrawSurface7  *dds,  I_dxj_DirectDrawEnumSurfaces **ppRet);
		static HRESULT createZEnum(I_dxj_DirectDrawSurface7  *dds, long flags, I_dxj_DirectDrawEnumSurfaces **ppRet);

public:
		IDirectDrawSurface7	**m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;
		
	
		DX3J_GLOBAL_LINKS( _dxj_DirectDrawEnumSurfaces )


private:
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddgammacontrolobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddgammacontrolobj.cpp
//
//--------------------------------------------------------------------------

// dDrawGammaControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddGammaControlObj.h"

extern void *g_dxj_DirectDrawGammaControl;

CONSTRUCTOR(_dxj_DirectDrawGammaControl, {});
DESTRUCTOR(_dxj_DirectDrawGammaControl, {});
GETSET_OBJECT(_dxj_DirectDrawGammaControl);
	
   
STDMETHODIMP C_dxj_DirectDrawGammaControlObject::getGammaRamp(long flags, DDGammaRamp *gammaRamp)
{    
	HRESULT hr = DD_OK;
    hr=m__dxj_DirectDrawGammaControl->GetGammaRamp((DWORD) flags,(DDGAMMARAMP*)gammaRamp);	
	return hr;
}

STDMETHODIMP C_dxj_DirectDrawGammaControlObject::setGammaRamp(long flags, DDGammaRamp *gammaRamp)
{    
	HRESULT hr = DD_OK;	
    hr=m__dxj_DirectDrawGammaControl->SetGammaRamp((DWORD) flags,(DDGAMMARAMP*)gammaRamp);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddidentifierobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddidentifierobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ddIdentifierObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);




STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriver( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{	
	USES_CONVERSION;
	*ret=T2BSTR(m_id.szDriver);		
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDescription( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{
	USES_CONVERSION;
	*ret=T2BSTR(m_id.szDescription);		
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriverVersion( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.liDriverVersion.HighPart;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriverSubVersion( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.liDriverVersion.LowPart;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getVendorId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwVendorId;
	return S_OK;
}
		

STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDeviceId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwDeviceId;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getSubSysId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwSubSysId;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getRevision( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwRevision;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDeviceIndentifier( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{
	*ret=GUIDtoBSTR(&m_id.guidDeviceIdentifier);	
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getWHQLLevel( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwWHQLLevel;
	return S_OK;
}


HRESULT C_dxj_DirectDrawIdentifierObject::Create(
	LPDIRECTDRAW7		  lpdd,	
	DWORD dwFlags, 
	I_dxj_DirectDrawIdentifier **ppret)
{
	HRESULT hr;
	C_dxj_DirectDrawIdentifierObject *c= new CComObject<C_dxj_DirectDrawIdentifierObject>;

	if (!c) return E_OUTOFMEMORY;

	hr=lpdd->GetDeviceIdentifier(&(c->m_id),dwFlags);			
	
	
	c->QueryInterface(IID_I_dxj_DirectDrawIdentifier,(void**)ppret);

	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddgammacontrolobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddgammacontrolobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawGammaControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawGammaControl LPDIRECTDRAWGAMMACONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawGammaControlObject : 
	public I_dxj_DirectDrawGammaControl,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawGammaControlObject() ;
	virtual ~C_dxj_DirectDrawGammaControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawGammaControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawGammaControl)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawGammaControlObject)

// I_dxj_DirectDrawGammaControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);
	STDMETHOD(getGammaRamp)( long flags, DDGammaRamp *GammaControl);
	STDMETHOD(setGammaRamp)( long flags, DDGammaRamp *GammaControl);
        

private:
    DECL_VARIABLE(_dxj_DirectDrawGammaControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawGammaControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddpaletteobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddpaletteobj.cpp
//
//--------------------------------------------------------------------------

// ddPaletteObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ddPaletteObj.h"

CONSTRUCTOR(_dxj_DirectDrawPalette, {m_dd=NULL;});
DESTRUCTOR(_dxj_DirectDrawPalette, {m_dd=NULL;});
GETSET_OBJECT(_dxj_DirectDrawPalette);

PASS_THROUGH_CAST_1_R(_dxj_DirectDrawPalette, getCaps, GetCaps, long*,(DWORD *))

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDrawPaletteObject::getEntries( //long flags, 
								long base, long numEntries, SAFEARRAY **ppEntries){
	HRESULT hr;
	if (!ISSAFEARRAY1D(ppEntries,(DWORD)numEntries)) return E_INVALIDARG;
	LPPALETTEENTRY pe=(LPPALETTEENTRY)((SAFEARRAY*)*ppEntries)->pvData;
	hr=m__dxj_DirectDrawPalette->GetEntries((DWORD) 0,(DWORD) base, (DWORD) numEntries, pe);
	return hr;

}
STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntries(// long flags,
		long base, long numEntries, SAFEARRAY **ppEntries){
	HRESULT hr;
	if (!ISSAFEARRAY1D(ppEntries,(DWORD)numEntries)) return E_INVALIDARG;
	LPPALETTEENTRY pe=(LPPALETTEENTRY)((SAFEARRAY*)*ppEntries)->pvData;
	hr=m__dxj_DirectDrawPalette->SetEntries((DWORD) 0,(DWORD) base, (DWORD) numEntries, pe);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

#if 0
STDMETHODIMP C_dxj_DirectDrawPaletteObject::initialize( I_dxj_DirectDraw2 *val)
{
	DO_GETOBJECT_NOTNULL( LPDIRECTDRAW2, lpdd, val)
	return m__dxj_DirectDrawPalette->Initialize((LPDIRECTDRAW)lpdd, 0, NULL);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP C_dxj_DirectDrawPaletteObject::internalAttachDD(I_dxj_DirectDraw2 *dd)
{
	m_dd = dd;
	return S_OK;
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntriesHalftone(long start, long count)
{
	PALETTEENTRY pe[256];

	HDC hdc = GetDC(NULL);
	if (!hdc) return E_OUTOFMEMORY;

	HPALETTE hpal = CreateHalftonePalette(hdc);
	if (!hpal) return E_OUTOFMEMORY;
	

	GetPaletteEntries(hpal, 0, 256, pe );  

	for ( long i = start; i < start+count; i++ )
		pe[i].peFlags  |= PC_NOCOLLAPSE | D3DPAL_READONLY;  

	m__dxj_DirectDrawPalette->SetEntries(0,(DWORD)start,(DWORD)count,pe);

	ReleaseDC(NULL,hdc);
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntriesSystemPalette(long start, long count)
{
	PALETTEENTRY pe[256];
	UINT uiRet;
	HRESULT hr;
	HDC hdc = GetDC(NULL);
	if (!hdc) return E_OUTOFMEMORY;

	uiRet=GetSystemPaletteEntries(hdc,start,count,pe);
        if (uiRet<=0) return E_FAIL; 


	for ( long i = start; i < start+count; i++ )
		pe[i].peFlags  |= /*PC_NOCOLLAPSE |*/ D3DPAL_READONLY;  

	hr=m__dxj_DirectDrawPalette->SetEntries(0,(DWORD)start,(DWORD)count,pe);

	ReleaseDC(NULL,hdc);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddpaletteobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddpaletteobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawPaletteObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawPalette LPDIRECTDRAWPALETTE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawPaletteObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawPalette, &IID_I_dxj_DirectDrawPalette, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawPalette,
#endif
//	public CComCoClass<C_dxj_DirectDrawPaletteObject, &CLSID__dxj_DirectDrawPalette>,
	 public CComObjectRoot
{
public:
	C_dxj_DirectDrawPaletteObject() ;
	virtual ~C_dxj_DirectDrawPaletteObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawPaletteObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawPalette)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawPalette,   "DIRECT.ddPalette.3",	"DIRECT.DirectDrawPalette.3",	IDS_DDPALETTE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawPaletteObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawPaletteObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawPalette
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);

    //STDMETHOD(initialize)( I_dxj_DirectDraw2 *val);
	STDMETHOD(getCaps)( long *caps);
	STDMETHOD(setEntries)(/*long,*/ long, long, SAFEARRAY **pe);
	STDMETHOD(getEntries)(/*long,*/ long, long, SAFEARRAY **pe);

	//STDMETHOD(internalAttachDD)(I_dxj_DirectDraw2 *dd);

	STDMETHOD(setEntriesHalftone)(long start, long count);
	STDMETHOD(setEntriesSystemPalette)(long start, long count);

private:
    DECL_VARIABLE(_dxj_DirectDrawPalette);
	IUnknown *m_dd;				// circular def's, use IUnknown to compile

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawPalette )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddraw4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw4obj.h
//
//--------------------------------------------------------------------------


// dDrawObj.h : Declaration of the CdDrawObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDraw4 LPDIRECTDRAW4

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDraw4Object : 
	public I_dxj_DirectDraw4,
	public CComObjectRoot
{
public:
	C_dxj_DirectDraw4Object() ;
	virtual ~C_dxj_DirectDraw4Object() ;

BEGIN_COM_MAP(C_dxj_DirectDraw4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDraw4)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDraw4, "DIRECT.DirectDraw4.3", "DIRECT.DirectDraw4.3", IDS_DDRAW_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDraw4Object)


// I_dxj_DirectDraw
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
 
        
         HRESULT STDMETHODCALLTYPE createClipper( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createPalette( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pe,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createSurface( 
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromFile( 
            /* [in] */ BSTR file,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromResource( 
            /* [in] */ BSTR file,
            /* [in] */ BSTR resName,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE duplicateSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddIn,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *ddOut);
        
         HRESULT STDMETHODCALLTYPE flipToGDISurface( void);
        
         HRESULT STDMETHODCALLTYPE getAvailableTotalMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDCaps __RPC_FAR *hwCaps,
            /* [out][in] */ DDCaps __RPC_FAR *helCaps);
        
        
         HRESULT STDMETHODCALLTYPE getDisplayMode( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getFourCCCodes( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ccCodes);
        
         HRESULT STDMETHODCALLTYPE getFreeMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getGDISurface( 
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getMonitorFrequency( 
            /* [retval][out] */ long __RPC_FAR *freq);
        
         HRESULT STDMETHODCALLTYPE getNumFourCCCodes( 
            /* [retval][out] */ long __RPC_FAR *nCodes);
        
         HRESULT STDMETHODCALLTYPE getScanLine( 
            /* [out][in] */ long __RPC_FAR *lines,
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE getSurfaceFromDC( 
            /* [in] */ long hdc,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
        
         HRESULT STDMETHODCALLTYPE getVerticalBlankStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE loadPaletteFromBitmap( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE restoreAllSurfaces( void);
        
         HRESULT STDMETHODCALLTYPE restoreDisplayMode( void);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hdl,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setDisplayMode( 
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ long bpp,
            /* [in] */ long ref,
            /* [in] */ long mode);
        
         HRESULT STDMETHODCALLTYPE testCooperativeLevel( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE waitForVerticalBlank( 
            /* [in] */ long flags,
            /* [in] */ long handle,
            /* [retval][out] */ long __RPC_FAR *status);

              	

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDraw4);

private:
	HWND m_hwnd;

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDraw4);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddidentifierobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddidentifierobj.h
//
//--------------------------------------------------------------------------

class C_dxj_DirectDrawIdentifierObject : 
	public I_dxj_DirectDrawIdentifier,	
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawIdentifierObject(){};
	~C_dxj_DirectDrawIdentifierObject(){};

	BEGIN_COM_MAP(C_dxj_DirectDrawIdentifierObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectDrawIdentifier)		
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_DirectDrawIdentifierObject)


public:


	
	HRESULT STDMETHODCALLTYPE getDriver( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDescription( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDriverVersion( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDriverSubVersion( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getVendorId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDeviceId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getSubSysId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getRevision( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDeviceIndentifier( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getWHQLLevel( 
		/* [retval][out] */ long __RPC_FAR *ret);



	static  HRESULT C_dxj_DirectDrawIdentifierObject::Create(LPDIRECTDRAW7 lpdddi,  DWORD dwFlags, I_dxj_DirectDrawIdentifier **ppret);	

	DDDEVICEIDENTIFIER2 m_id;	

private:


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddsurface4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface4obj.cpp
//
//--------------------------------------------------------------------------

    // ddSurfaceObj.cpp : Implementation of CDirectApp and DLL registration.
    #include "stdafx.h"
    #include "stdio.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dDraw4Obj.h"
    #include "ddClipperObj.h"    
    #include "ddSurface4Obj.h"
    #include "ddPaletteObj.h"
    
    
	

    
    
    
    C_dxj_DirectDrawSurface4Object::C_dxj_DirectDrawSurface4Object(){ 
    	m__dxj_DirectDrawSurface4= NULL;
    	parent = NULL;
    	pinterface = NULL; 
    	nextobj =  g_dxj_DirectDrawSurface4;
    	creationid = ++g_creationcount;
    
    	DPF1(1,"Constructor Creation Surface7 [%d] \n",g_creationcount);
    
    	g_dxj_DirectDrawSurface4 = (void *)this; 
    	_dxj_DirectDrawSurface4Lock=NULL; 
    
    	m_bLocked=FALSE;
    
    	m_drawStyle = 0;	//solid lines are default for DDraw
    	m_fillStyle = 1;	//transparent fill is default since DDRaw has no selected Brush
    	m_fFontTransparent = TRUE;
    	m_fFillTransparent = TRUE;
    	m_fFillSolid=TRUE;
    	m_foreColor = 0;	//black is the default color.
		m_fontBackColor=-1;	//white
    	m_drawWidth = 1;
    	m_hPen = NULL; 
    	m_hBrush = NULL;
    	m_hFont=NULL;
	  	m_pIFont=NULL;
		m_bLockedArray=FALSE;
		m_ppSA=NULL;
		
		setFillStyle(1);	//transparent

     }
    
    
    DWORD C_dxj_DirectDrawSurface4Object::InternalAddRef(){
    	DWORD i;
    	i=CComObjectRoot::InternalAddRef();        	
    	DPF2(1,"Surf7 [%d] AddRef %d \n",creationid,i);
    	return i;
    }
    
    DWORD C_dxj_DirectDrawSurface4Object::InternalRelease(){
    	DWORD i;
    	i=CComObjectRoot::InternalRelease();
    	DPF2(1,"Surf4 [%d] Release %d \n",creationid,i);
    	return i;
    }
    
    
    C_dxj_DirectDrawSurface4Object::~C_dxj_DirectDrawSurface4Object()
    {

		
        C_dxj_DirectDrawSurface4Object *prev=NULL; 
    	for(C_dxj_DirectDrawSurface4Object *ptr=(C_dxj_DirectDrawSurface4Object *)g_dxj_DirectDrawSurface4; ptr; ptr=(C_dxj_DirectDrawSurface4Object *)ptr->nextobj) 
    	{
    		if(ptr == this) 
    		{ 
    			if(prev) 
    				prev->nextobj = ptr->nextobj; 
    			else 
     				g_dxj_DirectDrawSurface4 = (void*)ptr->nextobj; 
    			break; 
    		} 
    		prev = ptr; 
    	} 
    	if(m__dxj_DirectDrawSurface4){
    		int count = IUNK(m__dxj_DirectDrawSurface4)->Release();
    		
    		DPF1(1,"DirectX IDirectDrawSurface4 Ref count [%d]",count);
    
    		if(count==0) m__dxj_DirectDrawSurface4 = NULL;
    	} 
    	if(parent) IUNK(parent)->Release();
    
    
    	 
        if (m_hFont)  DeleteObject (m_hFont);
        if (m_hPen)   DeleteObject (m_hPen);
        if (m_hBrush) DeleteObject (m_hBrush);
	  	if (m_pIFont) m_pIFont->Release();
    
    }
    
    
    
    GETSET_OBJECT(_dxj_DirectDrawSurface4);
    
    RETURN_NEW_ITEM_R(_dxj_DirectDrawSurface4, getPalette, GetPalette, _dxj_DirectDrawPalette)
    
    GET_DIRECT_R(_dxj_DirectDrawSurface4,  isLost, IsLost, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface4, getBltStatus,  GetBltStatus,  long, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface4, getFlipStatus, GetFlipStatus, long, long)
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::addAttachedSurface(I_dxj_DirectDrawSurface4 *s3)
    {
    	HRESULT hr;	
    
    	IDirectDrawSurface4 *realsurf=NULL;
    	if (s3) s3->InternalGetObject((IUnknown**)&realsurf);
    
    	if (m__dxj_DirectDrawSurface4 == NULL) return E_FAIL;
    	hr=m__dxj_DirectDrawSurface4->AddAttachedSurface(realsurf);
    	
    	return hr;
    }
    
    
    
    

    
    
    
    
    PASS_THROUGH_CAST_1_R(_dxj_DirectDrawSurface4,releaseDC,ReleaseDC,long,(HDC ))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface4,setColorKey,SetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface4,getColorKey,GetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getDC(long *hdc)
    {	
          return m__dxj_DirectDrawSurface4->GetDC((HDC*)hdc);
    }
    
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::lock(  Rect *r,  DDSurfaceDesc2 *desc,  long flags,  Handle hnd)
    {
    	if (m_bLocked) return E_FAIL;
    	
    	HRESULT hr;
    
    	CopyInDDSurfaceDesc2(&m_ddsd,desc);
    
   		
		hr = m__dxj_DirectDrawSurface4->Lock(NULL,&m_ddsd,(DWORD)flags,(void*)hnd);
        if FAILED(hr) return hr;

     	CopyOutDDSurfaceDesc2(desc,&m_ddsd);
    
    	
    	m_bLocked=TRUE;
    	m_nPixelBytes=m_ddsd.ddpfPixelFormat.dwRGBBitCount/8; 
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::unlock(  Rect *r)
    {
    	HRESULT hr;
    	//__try {
		if (m_bLockedArray) {				
			*m_ppSA=NULL;
			m_bLockedArray=FALSE;			
		}
		

    	//hr = m__dxj_DirectDrawSurface4->Unlock((RECT*)r);
		hr = m__dxj_DirectDrawSurface4->Unlock(NULL);
    
    	if FAILED(hr) return hr	;
    	m_bLocked=FALSE;
    
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setLockedPixel( int x,  int y,  long col)
    {
    	if (!m_bLocked) return E_FAIL;
    
    	//__try {
    
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*((WORD*)pByte)=(WORD)col;	
    		}
    		else if (m_nPixelBytes==4){
    			*((DWORD*)pByte)=(DWORD)col;	
    		}
    		else if (m_nPixelBytes==1){
    			*pByte=(Byte)col;
    		}
    		else if (m_nPixelBytes==3){
				*(pByte)= (char)(col & 0xFF);
				pByte++;
				*(pByte)= (char)((col & 0xFF00)>>8);
				pByte++;
    			*(pByte)= (char)((col & 0xFF0000)>>16);
		}

    		else{
    			return E_FAIL;
    		}
       	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getLockedPixel( int x,  int y,  long *col)
    {
    	//__try {
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*col=(long) *((WORD*)pByte);	
    		}
    		else if (m_nPixelBytes==4){
    			*col=(long) *((DWORD*)pByte);	
    		}
	   		else if (m_nPixelBytes==3){
    			*col=(long) (*((DWORD*)pByte))& 0x00FFFFFF;	
    		}
    		else if (m_nPixelBytes==1){
    			*col=(long) *((long*)pByte);
    		}
    		else{
    			return E_FAIL;
     		}

    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getClipper( I_dxj_DirectDrawClipper **val)
    {
    	LPDIRECTDRAWCLIPPER		ddc;
    	HRESULT hr=DD_OK;
    	if( (hr=m__dxj_DirectDrawSurface4->GetClipper( &ddc)) != DD_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);
    
    	return S_OK;
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // this is NOT the normal Blt, that is BltFx in our interface
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::blt( Rect *pDest, I_dxj_DirectDrawSurface4 *ddS, Rect *pSrc, long flags, long *status)
    {
    	
    	LPDIRECTDRAWSURFACE4 lpdds = NULL;
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc =(LPRECT)pSrc;
    	
    	if (!ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    	
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, lpdds, prcSrc, flags, NULL);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    											
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltFx(Rect *pDest, I_dxj_DirectDrawSurface4 *ddS, Rect *pSrc, long flags, DDBltFx *bltfx, long *status )
    {
    
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc= (LPRECT)pSrc;
    	LPDIRECTDRAWSURFACE4 lpdds = NULL;
    
    	if ( !ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    
    	if(bltfx)	bltfx->lSize = sizeof(DDBLTFX);
    
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, lpdds, prcSrc, flags, (struct _DDBLTFX *)bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltColorFill( Rect *pDest, long fillvalue, long *status )
    {
    	HWnd hWnd = NULL;
    
    	DDBLTFX bltfx;
    
    	memset(&bltfx,0,sizeof(DDBLTFX));
    	bltfx.dwSize = sizeof(DDBLTFX);
    	bltfx.dwFillColor = (DWORD)fillvalue;
    
    
    	LPRECT prcDest=(LPRECT)pDest;
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltFast( long dx, long dy, I_dxj_DirectDrawSurface4 *dds, Rect *src, long trans, long *status)
    {
    
		if (!dds) return E_INVALIDARG;

    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4,lpdds,dds)
    	
    	LPRECT prcSrc=(LPRECT)src;
    
		if (!src) return E_INVALIDARG;

    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->BltFast(dx, dy, lpdds, prcSrc, trans);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::deleteAttachedSurface( I_dxj_DirectDrawSurface4 *dds)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpdds, dds)
    
    	return m__dxj_DirectDrawSurface4->DeleteAttachedSurface(0, lpdds);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::flip( I_dxj_DirectDrawSurface4 *dds, long flags)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4,lpdds,dds)
    
    	return m__dxj_DirectDrawSurface4->Flip(lpdds, flags);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getAttachedSurface( DDSCaps2  *caps, I_dxj_DirectDrawSurface4 **dds)
    {
    	LPDIRECTDRAWSURFACE4 lpdds;	
    	HRESULT hr=DD_OK;
    	
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetAttachedSurface( (DDSCAPS2*)caps, &lpdds)) != S_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lpdds, dds);
    
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getCaps( DDSCaps2 *caps)
    {
    	
    	HRESULT hr=DD_OK;
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetCaps((DDSCAPS2*)caps)) != S_OK)
    		return hr;
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getPixelFormat( DDPixelFormat *pf)
    {
    	
    	HRESULT hr=DD_OK;
    
    	DDPIXELFORMAT ddpf;
    	ddpf.dwSize = sizeof(DDPIXELFORMAT);
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetPixelFormat(&ddpf)) != S_OK)
    		return hr;
    
    	CopyOutDDPixelFormat(pf,&ddpf);
    
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getSurfaceDesc( DDSurfaceDesc2 *desc)
    {
    	desc->lpSurface = NULL;
    	HRESULT hr=DD_OK;
    
    	DDSURFACEDESC2 ddsd;
    	ddsd.dwSize=sizeof(DDSURFACEDESC2);
    	ddsd.ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
    	ddsd.lpSurface=NULL;
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetSurfaceDesc( &ddsd )) != S_OK )
    		return hr;
    
    	CopyOutDDSurfaceDesc2(desc,&ddsd);
    		
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::restore()
    {
    	return m__dxj_DirectDrawSurface4->Restore();
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setPalette( I_dxj_DirectDrawPalette *ddp)
    {
    	//
    	// ignore the return value here. Will only work on 256 colours anyway!
    	//
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWPALETTE,lpddp,ddp)
    
    	return m__dxj_DirectDrawSurface4->SetPalette(lpddp);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getDirectDraw( I_dxj_DirectDraw4 **val)
    {
    
    	IUnknown *pUnk=NULL;
    	LPDIRECTDRAW4 lpdd;
    	HRESULT hr=DD_OK;
    
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetDDInterface((void **)&pUnk)) != S_OK)
    		return hr;
    	
    	hr=pUnk->QueryInterface(IID_IDirectDraw4,(void**)&lpdd);
    	if FAILED(hr) {
    		if (pUnk) pUnk->Release();
    		return hr;
    	}
    
    	INTERNAL_CREATE(_dxj_DirectDraw4, lpdd, val);
    
    	return S_OK;
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setClipper(I_dxj_DirectDrawClipper *val)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpc, val);
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->SetClipper( lpc);
    	return hr;	
    }

    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::changeUniquenessValue()
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->ChangeUniquenessValue();	
    	return hr;
    }
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getUniquenessValue(long *ret)
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->GetUniquenessValue((DWORD*)ret);	
    	return hr;
    }
    	 	 			
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setFont( 
                /* [in] */ IFont __RPC_FAR *font)
    {
    
  	HRESULT hr;
    	if (!font) return E_INVALIDARG;
  	if (m_pIFont) m_pIFont->Release();
  	m_pIFont=NULL;
  	hr=font->Clone(&m_pIFont);
  	return hr;
  	   	
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFontTransparency(VARIANT_BOOL b)
    {
    	m_fFontTransparent=(b!=VARIANT_FALSE);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFontTransparency(VARIANT_BOOL *b)
    {
    	if (m_fFontTransparent) 
    		*b= VARIANT_TRUE;
    	else 
    		*b= VARIANT_FALSE;
    	return S_OK;
    }
    
    
          
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setDrawWidth(  long drawWidth)
    {	
                HPEN hNewPen=NULL;
    		if (drawWidth < 1) return E_INVALIDARG;
    		m_drawWidth=drawWidth;		
    		hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    		if (!hNewPen) return E_INVALIDARG;
    		DeleteObject(m_hPen);    
    		m_hPen=hNewPen;
    		return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getDrawWidth(long *val)
    {
    	*val=m_drawWidth;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setDrawStyle(long drawStyle)
    {
    
        HPEN hNewPen=NULL;     
    	m_drawStyle=drawStyle;		
    	hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
    	DeleteObject(m_hPen);    
    	m_hPen=hNewPen;
    	return S_OK;
    }	
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getDrawStyle(long __RPC_FAR *val)
    {
    	*val=m_drawStyle;
    	return S_OK;
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFillStyle(long fillStyle)
    {
    	
        HBRUSH hNewBrush=NULL;
    
    	
		BOOL fillTransparent =m_fFillTransparent;
		BOOL fillSolid=m_fFillSolid;
		long fillStyle2=fillStyle;

		m_fillStyle = fillStyle;    
    	m_fFillTransparent = FALSE;
    	m_fFillSolid = FALSE;

    	switch(fillStyle){
    		case 6:	//vbCross:
    			m_fillStyleHS = HS_CROSS;
    			break;
    		case 7:	//vbDiagonalCross:
    			m_fillStyleHS = HS_DIAGCROSS;
    			break;
    		case 5: //vbxDownwardDiagonal:
    			m_fillStyleHS = HS_BDIAGONAL;
    			break;
    		case 2: //vbHorizontalLine:
    			m_fillStyleHS = HS_HORIZONTAL;
    			break;
    		case 4: //vbUpwardDiagonal:
    			m_fillStyleHS = HS_FDIAGONAL;
    			break;
    		case 3: //vbVerticalLine:
    			m_fillStyleHS = HS_VERTICAL;
    			break;
    		case 0: ///vbFSSolid:
    			m_fFillSolid = TRUE;
    			break;
    		case 1: //vbFSTransparent:
    			m_fFillTransparent = TRUE;
    			m_fFillSolid = TRUE;
				break;
    		default:
				m_fFillTransparent = fillTransparent;
    			m_fFillSolid = fillSolid;
				m_fillStyle=fillStyle2;
    			return E_INVALIDARG;
    	}
    
    
    	if (m_fFillTransparent) {
    		LOGBRUSH logb;
    		logb.lbStyle = BS_NULL;
    		hNewBrush = CreateBrushIndirect(&logb);
    	}
    	else if (m_fFillSolid) {
    		hNewBrush = CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush = CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
    	if (!hNewBrush) return E_FAIL;
    
    	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFillStyle(long *val)
    {
    	*val=m_fillStyle;
    	return S_OK;
    }
    
    	
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFillColor(long c)
    {   
    	m_fillColor = c;
        HBRUSH  hNewBrush;
    
    	if (m_fFillSolid){
    		hNewBrush= CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush= CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
        
    	if (!hNewBrush) return E_INVALIDARG;
  	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFillColor(long *val)
    {
    	*val=m_fillColor;
    	return S_OK;
    }
    
            
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setForeColor(  long color)
    {
    	m_foreColor=color;
        HPEN hNewPen=NULL;
                    
        
        hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
        if (m_hPen)  DeleteObject (m_hPen);
    	m_hPen=hNewPen;
    	return S_OK;
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getForeColor(long *val)
    {
    	*val=m_foreColor;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawLine( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	POINT points[2];
        HRESULT hr;
    
        hr =m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        points[0].x = x1;
        points[0].y = y1;
        
        
        points[1].x = x2;
        points[1].y = y2;
        
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        
        Polyline(hdc, points, 2);
        
    	//why do this..
        //if (oldpen)   SelectObject(hdc, oldpen);
        //if (oldbrush) SelectObject(hdc, oldbrush);
            
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
        
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
        HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
           
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }

     
        Rectangle(hdc, x1,y1,x2,y2);
        
            
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawRoundedBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2,
                /* [in] */ long rw,
                /* [in] */ long rh)
    
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }

        
        RoundRect(hdc, x1,y1,x2,y2,rw,rh);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }        
        
        
        
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawEllipse( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    
        hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
    	Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }        
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawCircle( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ long r)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    	long x1,y1,x2,y2;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);        
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
            
        x1 = x - r;
        x2 = x + r;
        y1 = y - r;
        y2 = y + r;
    
        Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawText( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ BSTR str,
                /* [in] */ VARIANT_BOOL b)
    {
        HDC hdc=NULL;
    	HRESULT hr;	
    	DWORD len=0;
    	UINT txtA;
    
    	if (!str) return E_INVALIDARG;

	  	len = ((DWORD*)str)[-1]/2;
    
        hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	    	
    
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
        SetTextColor(hdc, m_foreColor);
        

        
    	txtA=GetTextAlign(hdc);
    	if (b!=VARIANT_FALSE){				
    		if (!(txtA & TA_UPDATECP)) SetTextAlign(hdc,txtA | TA_UPDATECP);
    	}
    	else {		
    		if (txtA & TA_UPDATECP)	SetTextAlign(hdc,txtA-TA_UPDATECP);			
    	}
    	
  	if (m_pIFont) {
  		HFONT hFont=NULL;
  		m_pIFont->SetHdc(hdc);
  	    m_pIFont->get_hFont(&hFont);
  		SelectObject (hdc, hFont);
  	}
  
        ExtTextOutW(hdc, (int)x, (int)y, 0, 0, str, len, 0);
    
    	m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::bltToDC( 
                /* [in] */ long hdcDest,
                /* [in] */ Rect __RPC_FAR *srcRect,
                /* [in] */ Rect __RPC_FAR *destRect)
    {
    	HRESULT hr;
    	BOOL b;
    	HDC		hdc=NULL;
    	
    	if (!srcRect) return E_INVALIDARG;
    	if (!destRect) return E_INVALIDARG;
    
    	hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	
    	int nWidthDest= destRect->right-destRect->left;
    	int nHeightDest=destRect->bottom-destRect->top;
    	int nWidthSrc= srcRect->right-srcRect->left;
    	int nHeightSrc=srcRect->bottom-srcRect->top;
    
				
		
		if ((0==srcRect->top) && (0==srcRect->left ) && (0==srcRect->top) &&(0==srcRect->bottom ))
		{
			DDSURFACEDESC2 desc;
			desc.dwSize=sizeof(DDSURFACEDESC2);
			m__dxj_DirectDrawSurface4->GetSurfaceDesc(&desc);
			nWidthSrc=desc.dwWidth;
			nHeightSrc=desc.dwHeight;
		}


    	b=StretchBlt((HDC)hdcDest,
    		destRect->left,destRect->top,
    		nWidthDest, nHeightDest,
    		hdc,
    		srcRect->left,srcRect->top,
    		nWidthSrc, nHeightSrc, SRCCOPY);
      
    
    	m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	
    	//CONSIDER: are we being presumptious that if blt fails its due to arg probs?
    	if (!b) return E_INVALIDARG;
    
    	return S_OK;
    
    }


	STDMETHODIMP C_dxj_DirectDrawSurface4Object::getLockedArray(SAFEARRAY **pArray)
	{
		

		if (!m_bLocked) return E_FAIL;
		

		if (!pArray) return E_INVALIDARG;
		if (*pArray) return E_INVALIDARG;
		m_ppSA=pArray;


		m_bLockedArray=TRUE;

		ZeroMemory(&m_saLockedArray,sizeof(SAFEARRAY));
		m_saLockedArray.cbElements =1;
		m_saLockedArray.cDims =2;
		m_saLockedArray.rgsabound[0].lLbound =0;
		m_saLockedArray.rgsabound[0].cElements =m_ddsd.dwHeight;
		m_saLockedArray.rgsabound[1].lLbound =0;
		m_saLockedArray.rgsabound[1].cElements =m_ddsd.lPitch;
		m_saLockedArray.pvData =m_ddsd.lpSurface;

		
		*pArray=&m_saLockedArray;
    
		
    	return S_OK;
	}



	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFontBackColor( 
                /* [in] */ long color)
    {
		m_fontBackColor=(DWORD)color;
    	return S_OK;
    }
    

	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFontBackColor( 
                /* [in] */ long *color)
    {    	
		if (!color) return E_INVALIDARG;            
        *color=(DWORD)m_fontBackColor;    	                    
    	return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddraw4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw4obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDraw4Obj.h"
#include "ddClipperObj.h"
#include "ddSurface4Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw4Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw4 [%d] AddRef %d \n",creationid,i);		
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw4Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw4Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw4Object::C_dxj_DirectDraw4Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw4Object[%d] \n ",g_creationcount);
	

	m__dxj_DirectDraw4= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw4;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw4 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw4Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw4Object::~C_dxj_DirectDraw4Object()
{
	DPF(1,"Entering ~DirectDraw4Object destructor \n");
	

     C_dxj_DirectDraw4Object *prev=NULL; 
	for(C_dxj_DirectDraw4Object *ptr=(C_dxj_DirectDraw4Object *)g_dxj_DirectDraw4; ptr; ptr=(C_dxj_DirectDraw4Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw4 = (void*)ptr->nextobj; 
			
			
			DPF(1,"	DirectDraw4Object found in g_dxj list now removed\n");
			
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw4){
		int count = IUNK(m__dxj_DirectDraw4)->Release();
		
		DPF1(1,"DirectX IDirectDraw4 Ref count [%d] \n",count);

		if(count==0)	m__dxj_DirectDraw4 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw4);
PASS_THROUGH_R(_dxj_DirectDraw4, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw4, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw4, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw4->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getGDISurface(I_dxj_DirectDrawSurface4 **rv)
{ 
	
	LPDIRECTDRAWSURFACE4 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw4->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw4->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw4->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw4->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;
	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw4->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw4->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface4 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE4	  dds4; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw4[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw4->CreateSurface( &ddsd, &dds4, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw4[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::duplicateSurface(I_dxj_DirectDrawSurface4 *ddIn, I_dxj_DirectDrawSurface4 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE4 lpddout4=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE4, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw4->DuplicateSurface(lpddin, &lpddout4)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface4, lpddout4, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw4->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw4->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw4->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw4->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}



///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw4->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw4->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	
	HRESULT hr=S_OK;

	if ( is4Bit )	return E_FAIL;

	LPCTSTR szBitmap = NULL;
	__try { szBitmap = W2T(bName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){
		DPF(1,"lock resource failed\n");
		return E_OUTOFMEMORY;			// error return...
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw4->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface4 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE4		dds4; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	__try { szFileName=W2T(file); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}
	

	if (!szFileName) return CTL_E_FILENOTFOUND;	

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	
	if (!hbm) return CTL_E_FILENOTFOUND;

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw4->CreateSurface(&ddsd, &dds4, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds4->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds4->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds4->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw4[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw4Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface4 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    	BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE4		dds4; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE: we used to call 
		// GetModuleHandleW but it   returned 0 on w98			
		// so we use the ANSI version which works on w98 
 		 LPCTSTR pszName = NULL;
 		 __try { pszName = W2T(resFile); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = NULL;
	__try { pszName2 = W2T(resourceName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	

    	hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		return E_FAIL;
	}


	// get size of the bitmap
	//	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw4->CreateSurface(&ddsd, &dds4, NULL)) != DD_OK )
	{
  		if (hbm) DeleteObject(hbm);
		return retv;
        }

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds4->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

    if (!hdcImage){
		DeleteObject(hbm);
		return E_OUTOFMEMORY;
    }

    SelectObject(hdcImage, hbm);		
	

    if ((hr = dds4->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds4->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw4->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw4,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw4->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw4->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw4Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface4 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE4 pDDS=NULL;
	hr=m__dxj_DirectDraw4->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface4,pDDS,ret);
	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddraw7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddClipperObj.h"
#include "ddSurface7Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
#include "ddIdentifierObj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw7 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::C_dxj_DirectDraw7Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw7Object[%d] \n ",g_creationcount);

	m__dxj_DirectDraw7= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw7;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw7 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::~C_dxj_DirectDraw7Object()
{

	DPF(1,"Entering ~DirectDraw7Object destructor \n");

     C_dxj_DirectDraw7Object *prev=NULL; 
	for(C_dxj_DirectDraw7Object *ptr=(C_dxj_DirectDraw7Object *)g_dxj_DirectDraw7; ptr; ptr=(C_dxj_DirectDraw7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw7 = (void*)ptr->nextobj; 
			
			DPF(1,"DirectDraw7Object found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw7){
		int count = IUNK(m__dxj_DirectDraw7)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectDraw7 Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectDraw7 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw7);
PASS_THROUGH_R(_dxj_DirectDraw7, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw7, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw7, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw7->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getGDISurface(I_dxj_DirectDrawSurface7 **rv)
{ 
	
	LPDIRECTDRAWSURFACE7 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw7->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw7->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw7->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw7->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;

	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw7->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw7->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface7 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE7	  dds7; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw7[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw7->CreateSurface( &ddsd, &dds7, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw7[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::duplicateSurface(I_dxj_DirectDrawSurface7 *ddIn, I_dxj_DirectDrawSurface7 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE7 lpddout7=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw7->DuplicateSurface(lpddin, &lpddout7)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface7, lpddout7, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw7->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw7->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}


///////////////////////////////////////////////////////////////////
// getDirect3D
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDirect3D(I_dxj_Direct3d7 **retval)
{
    LPDIRECT3D7 lpD3D;
	HRESULT hr = DD_OK;

	if ( is4Bit )
		return E_FAIL;

    if( (hr=m__dxj_DirectDraw7->QueryInterface(IID_IDirect3D7, (void**) &lpD3D)) != DD_OK)
		return hr;

  	INTERNAL_CREATE(_dxj_Direct3d7, lpD3D, retval);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw7->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw7->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	

	HRESULT hr=S_OK;

	if ( is4Bit )
		return E_FAIL;

	LPCTSTR szBitmap = NULL;
	__try { szBitmap = W2T(bName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){	
		DPF(1,"lock resource failed\n");
		return E_OUTOFMEMORY;		// error
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw7->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw7[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	__try { szFileName=W2T(file); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}

	if (!szFileName) return CTL_E_FILENOTFOUND;

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	DWORD dwErr=GetLastError();		
	if (!hbm){
		
		//often users pass in width and height in twips and not pixels
		//loadimage compails and returns  ERROR_NOT_ENOUGH_MEMORY		
		

		if (dwErr==ERROR_NOT_ENOUGH_MEMORY)
		{
			return E_OUTOFMEMORY;
		}
		else if (dwErr==ERROR_INVALID_PARAMETER)
		{
			return E_INVALIDARG;
		}
		else {
			return CTL_E_FILENOTFOUND;
		}
	}

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw7[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE:
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// so we must convert to ansi first
		 LPCTSTR pszName = NULL;
		 __try { pszName = W2T(resFile); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = NULL;
	__try { pszName2 = W2T(resourceName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    //hbm = (HBITMAP)LoadImageW((HINSTANCE)hMod, resourceName, 
	//				IMAGE_BITMAP, 
	//				0, 0, 
	//				LR_CREATEDIBSECTION);
	

    hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		//MessageBox(NULL,"FAILED ON LOAD IMAGE","TEST",MB_OK);
		return E_FAIL;
	}


	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK ){
                if (hbm) DeleteObject(hbm);
	  	return retv;
        }

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

    if (!hdcImage){
		DeleteObject(hbm);
		return E_OUTOFMEMORY;
    }

    SelectObject(hdcImage, hbm);		

	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw7->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw7,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw7Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE7 pDDS=NULL;
	hr=m__dxj_DirectDraw7->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface7,pDDS,ret);
	return hr;	
}




STDMETHODIMP C_dxj_DirectDraw7Object::getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret)  
 
{
	HRESULT hr=C_dxj_DirectDrawEnumSurfacesObject::create((I_dxj_DirectDraw7*)this , flags, desc,ret);
	return hr;
}


STDMETHODIMP C_dxj_DirectDraw7Object::getDeviceIdentifier( 
             long flags,I_dxj_DirectDrawIdentifier **ret) 
{
	HRESULT hr;				
	hr=C_dxj_DirectDrawIdentifierObject::Create(m__dxj_DirectDraw7,(DWORD)flags,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddraw7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.h
//
//--------------------------------------------------------------------------


// dDrawObj.h : Declaration of the CdDrawObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDraw7 LPDIRECTDRAW7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDraw7Object : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDraw7, &IID_I_dxj_DirectDraw7, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDraw7,
#endif

	//public CComCoClass<C_dxj_DirectDraw7Object, &CLSID__dxj_DirectDraw7>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectDraw7Object() ;
	virtual ~C_dxj_DirectDraw7Object() ;

BEGIN_COM_MAP(C_dxj_DirectDraw7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDraw7)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDraw7, "DIRECT.DirectDraw7.3", "DIRECT.DirectDraw7.3", IDS_DDRAW_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDraw7Object)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDraw
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
 
        
         HRESULT STDMETHODCALLTYPE createClipper( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createPalette( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pe,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createSurface( 
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromFile( 
            /* [in] */ BSTR file,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromResource( 
            /* [in] */ BSTR file,
            /* [in] */ BSTR resName,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE duplicateSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddIn,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ddOut);
        
         HRESULT STDMETHODCALLTYPE flipToGDISurface( void);
        
         HRESULT STDMETHODCALLTYPE getAvailableTotalMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDCaps __RPC_FAR *hwCaps,
            /* [out][in] */ DDCaps __RPC_FAR *helCaps);
        
         HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getDisplayMode( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getFourCCCodes( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ccCodes);
        
         HRESULT STDMETHODCALLTYPE getFreeMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getGDISurface( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getMonitorFrequency( 
            /* [retval][out] */ long __RPC_FAR *freq);
        
         HRESULT STDMETHODCALLTYPE getNumFourCCCodes( 
            /* [retval][out] */ long __RPC_FAR *nCodes);
        
         HRESULT STDMETHODCALLTYPE getScanLine( 
            /* [out][in] */ long __RPC_FAR *lines,
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE getSurfaceFromDC( 
            /* [in] */ long hdc,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getVerticalBlankStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE loadPaletteFromBitmap( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE restoreAllSurfaces( void);
        
         HRESULT STDMETHODCALLTYPE restoreDisplayMode( void);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hdl,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setDisplayMode( 
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ long bpp,
            /* [in] */ long ref,
            /* [in] */ long mode);
        
         HRESULT STDMETHODCALLTYPE testCooperativeLevel( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE waitForVerticalBlank( 
            /* [in] */ long flags,
            /* [in] */ long handle,
            /* [retval][out] */ long __RPC_FAR *status);


		HRESULT STDMETHODCALLTYPE getDeviceIdentifier(         
            /* [in] */ long flags, I_dxj_DirectDrawIdentifier **ret);

              	

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDraw7);

private:
	HWND m_hwnd;

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDraw7);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddsurface4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface4obj.h
//
//--------------------------------------------------------------------------

// ddSurfaceObj.h : Declaration of the C_dxj_DirectDrawSurfaceObject


#include "resource.h"       // main symbols

//#define typedef__dxj_DirectDrawSurface LPDIRECTDRAWSURFACE
// 2nd #define helps with macros - same thing
//#define typedef__dxj_DirectDrawSurface  LPDIRECTDRAWSURFACE
#define typedef__dxj_DirectDrawSurface4 LPDIRECTDRAWSURFACE4

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawSurface4Object :
	public I_dxj_DirectDrawSurface4,	
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawSurface4Object() ;
	virtual ~C_dxj_DirectDrawSurface4Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawSurface4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawSurface4)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawSurface4Object)

// I_dxj_DirectDrawSurface4
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdds);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdds);

		HRESULT STDMETHODCALLTYPE addAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS) ;
        
        HRESULT STDMETHODCALLTYPE blt( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltColorFill( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ long fillvalue,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFast( 
            /* [in] */ long dx,
            /* [in] */ long dy,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long trans,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFx( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [in] */ DDBltFx __RPC_FAR *bltfx,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltToDC( 
            /* [in] */ long hdc,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ Rect __RPC_FAR *destRect);
        
        HRESULT STDMETHODCALLTYPE changeUniquenessValue( void);
        
        HRESULT STDMETHODCALLTYPE deleteAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE drawBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawCircle( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long r);
        
        HRESULT STDMETHODCALLTYPE drawEllipse( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawLine( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawRoundedBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long rw,
            /* [in] */ long rh);
        
        HRESULT STDMETHODCALLTYPE drawText( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ BSTR text,
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE flip( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurface( 
            /* [in] */ DDSCaps2 __RPC_FAR *caps,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *dds);
                
        HRESULT STDMETHODCALLTYPE getBltStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDSCaps2 __RPC_FAR *caps);
        
        HRESULT STDMETHODCALLTYPE getClipper( 
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getColorKey( 
            /* [in] */ long flags,
            /* [out][in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDC( 
            /* [retval][out] */ long __RPC_FAR *hdc);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw4 __RPC_FAR *__RPC_FAR *val);
        
        
        HRESULT STDMETHODCALLTYPE getDrawStyle( 
            /* [retval][out] */ long __RPC_FAR *drawStyle);
        
        HRESULT STDMETHODCALLTYPE getDrawWidth( 
            /* [retval][out] */ long __RPC_FAR *drawWidth);
        
        HRESULT STDMETHODCALLTYPE getFillColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getFillStyle( 
            /* [retval][out] */ long __RPC_FAR *fillStyle);
        
        HRESULT STDMETHODCALLTYPE getFlipStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getFontTransparency( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
        HRESULT STDMETHODCALLTYPE getForeColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ long __RPC_FAR *col);
        
        HRESULT STDMETHODCALLTYPE getPalette( 
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getPixelFormat( 
            /* [out][in] */ DDPixelFormat __RPC_FAR *pf);
        
        HRESULT STDMETHODCALLTYPE getSurfaceDesc( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
        HRESULT STDMETHODCALLTYPE getUniquenessValue( 
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE isLost( 
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ Rect __RPC_FAR *r,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [in] */ Handle hnd);
        
        HRESULT STDMETHODCALLTYPE releaseDC( 
            /* [in] */ long hdc);
        
        HRESULT STDMETHODCALLTYPE restore( void);
        
        HRESULT STDMETHODCALLTYPE setClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setColorKey( 
            /* [in] */ long flags,
            /* [in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setDrawStyle( 
            /* [in] */ long drawStyle);
        
        HRESULT STDMETHODCALLTYPE setDrawWidth( 
            /* [in] */ long drawWidth);
        
        HRESULT STDMETHODCALLTYPE setFillColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setFillStyle( 
            /* [in] */ long fillStyle);
        
        HRESULT STDMETHODCALLTYPE setFont( 
            /* [in] */ IFont __RPC_FAR *font);
        
        HRESULT STDMETHODCALLTYPE setFontTransparency( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setForeColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ long col);
                
        HRESULT STDMETHODCALLTYPE setPalette( 
            /* [in] */ I_dxj_DirectDrawPalette __RPC_FAR *ddp);
        
        HRESULT STDMETHODCALLTYPE unlock( 
            /* [in] */ Rect __RPC_FAR *r);

		HRESULT STDMETHODCALLTYPE getLockedArray(SAFEARRAY **pArray);

        HRESULT STDMETHODCALLTYPE setFontBackColor( 
            /* [in] */ long color);

		HRESULT STDMETHODCALLTYPE getFontBackColor( 
            /* [out,retval] */ long *color);

        
////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDrawSurface4);
	//BOOL m_primaryflag;

private:
	C_dxj_DirectDrawSurface4Object *_dxj_DirectDrawSurface4Lock;


	DDSURFACEDESC2	m_ddsd;
	BOOL			m_bLocked;
	int				m_nPixelBytes;

	BOOL	m_fFontTransparent;
	BOOL	m_fFillSolid;
	BOOL	m_fFillTransparent;
	DWORD	m_fillStyle;
	DWORD	m_fillStyleHS;
	DWORD	m_fillColor;
	DWORD	m_foreColor;
	DWORD	m_fontBackColor;
	DWORD	m_drawStyle;
	DWORD	m_drawWidth;
	HPEN	m_hPen;
	HBRUSH	m_hBrush;
	HFONT	m_hFont;
	IFont	*m_pIFont;
	SAFEARRAY **m_ppSA;
	BOOL	m_bLockedArray;
	SAFEARRAY m_saLockedArray;
	DWORD	m_pad[4];
	
	

//pac

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDrawSurface4)
};


// 
// Copies values from native unions into redundant Java members.
void 	ExpandDDSurface4Desc(LPDDSURFACEDESC lpDesc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddsurface7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface7obj.cpp
//
//--------------------------------------------------------------------------

    // ddSurfaceObj.cpp : Implementation of CDirectApp and DLL registration.
    #include "stdafx.h"
    #include "stdio.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dDraw7Obj.h"
    #include "ddClipperObj.h"    
    #include "ddGammaControlObj.h"
    #include "ddColorControlObj.h"
    #include "ddSurface7Obj.h"
    #include "ddPaletteObj.h"
    #include "DDEnumSurfacesObj.h"
    
	

    
    
    
    C_dxj_DirectDrawSurface7Object::C_dxj_DirectDrawSurface7Object(){ 
    	m__dxj_DirectDrawSurface7= NULL;
    	parent = NULL;
    	pinterface = NULL; 
    	nextobj =  g_dxj_DirectDrawSurface7;
    	creationid = ++g_creationcount;
    
	DPF1(1,"Constructor Creation Surface7 [%d] \n",g_creationcount);
    
    	g_dxj_DirectDrawSurface7 = (void *)this; 
    	_dxj_DirectDrawSurface7Lock=NULL; 
    
    	m_bLocked=FALSE;
    
    	m_drawStyle = 0;	//solid lines are default for DDraw
    	m_fillStyle = 1;	//transparent fill is default since DDRaw has no selected Brush
    	m_fFontTransparent = TRUE;
    	m_fFillTransparent = TRUE;
    	m_fFillSolid=TRUE;
    	m_foreColor = 0;	//black is the default color.
		m_fontBackColor=-1;	//white is the default fill color
    	m_drawWidth = 1;
    	m_hPen = NULL; 
    	m_hBrush = NULL;
    	m_hFont=NULL;
	  	m_pIFont=NULL;
		m_bLockedArray=FALSE;
		m_ppSA=NULL;

		setFillStyle(1);	//transparent
     }
    
    
    DWORD C_dxj_DirectDrawSurface7Object::InternalAddRef(){
    	DWORD i;
    	i=CComObjectRoot::InternalAddRef();        	
    	DPF2(1,"Surf7 [%d] AddRef %d \n",creationid,i);
    	return i;
    }
    
    DWORD C_dxj_DirectDrawSurface7Object::InternalRelease(){
    	DWORD i;
    	i=CComObjectRoot::InternalRelease();
    	DPF2(1,"Surf7 [%d] Release %d \n",creationid,i);
    	return i;
    }
    
    
    C_dxj_DirectDrawSurface7Object::~C_dxj_DirectDrawSurface7Object()
    {

		
        C_dxj_DirectDrawSurface7Object *prev=NULL; 
    	for(C_dxj_DirectDrawSurface7Object *ptr=(C_dxj_DirectDrawSurface7Object *)g_dxj_DirectDrawSurface7; ptr; ptr=(C_dxj_DirectDrawSurface7Object *)ptr->nextobj) 
    	{
    		if(ptr == this) 
    		{ 
    			if(prev) 
    				prev->nextobj = ptr->nextobj; 
    			else 
     				g_dxj_DirectDrawSurface7 = (void*)ptr->nextobj; 
    			break; 
    		} 
    		prev = ptr; 
    	} 
    	if(m__dxj_DirectDrawSurface7){
    		int count = IUNK(m__dxj_DirectDrawSurface7)->Release();
    		
    		DPF1(1,"DirectX IDirectDrawSurface7 Ref count [%d]",count);
    
    		if(count==0) m__dxj_DirectDrawSurface7 = NULL;
    	} 
    	if(parent) IUNK(parent)->Release();
    
    
    	 
        if (m_hFont)  DeleteObject (m_hFont);
        if (m_hPen)   DeleteObject (m_hPen);
        if (m_hBrush) DeleteObject (m_hBrush);
	  	if (m_pIFont) m_pIFont->Release();
    
    }
    
    
    
    GETSET_OBJECT(_dxj_DirectDrawSurface7);
    
    RETURN_NEW_ITEM_R(_dxj_DirectDrawSurface7, getPalette, GetPalette, _dxj_DirectDrawPalette)
    
    GET_DIRECT_R(_dxj_DirectDrawSurface7,  isLost, IsLost, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface7, getBltStatus,  GetBltStatus,  long, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface7, getFlipStatus, GetFlipStatus, long, long)
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::addAttachedSurface(I_dxj_DirectDrawSurface7 *s3)
    {
    	HRESULT hr;	
    
    	IDirectDrawSurface7 *realsurf=NULL;
    	if (s3) s3->InternalGetObject((IUnknown**)&realsurf);
    
    	if (m__dxj_DirectDrawSurface7 == NULL) return E_FAIL;
    	hr=m__dxj_DirectDrawSurface7->AddAttachedSurface(realsurf);
    	
    	return hr;
    }
    
    
    
    

    
    //PASS_THROUGH1_R(_dxj_DirectDrawSurface7, pageLock,   PageLock,  long)
    //PASS_THROUGH1_R(_dxj_DirectDrawSurface7, pageUnlock, PageUnlock,long)
    
    
    
    PASS_THROUGH_CAST_1_R(_dxj_DirectDrawSurface7,releaseDC,ReleaseDC,long,(HDC ))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface7,setColorKey,SetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface7,getColorKey,GetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDC(long *hdc)
    {	
          return m__dxj_DirectDrawSurface7->GetDC((HDC*)hdc);
    }
    
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::lock(  Rect *r,  DDSurfaceDesc2 *desc,  long flags,  Handle hnd)
    {
    	if (m_bLocked) return E_FAIL;
    	
    	HRESULT hr;
    
    	CopyInDDSurfaceDesc2(&m_ddsd,desc);
		hr = m__dxj_DirectDrawSurface7->Lock(NULL,&m_ddsd,(DWORD)flags,(void*)hnd);
    	if FAILED(hr) return hr;
        
     	CopyOutDDSurfaceDesc2(desc,&m_ddsd);
    
    
    	m_bLocked=TRUE;
    	m_nPixelBytes=m_ddsd.ddpfPixelFormat.dwRGBBitCount/8; 
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::unlock(  Rect *r)
    {
    	HRESULT hr;
		if (m_bLockedArray) {				
			*m_ppSA=NULL;
			m_bLockedArray=FALSE;			
		}
		

		hr = m__dxj_DirectDrawSurface7->Unlock(NULL);
    
    	if FAILED(hr) return hr	;
    	m_bLocked=FALSE;
    
    	return hr;
    }


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setLockedPixel( int x,  int y,  long col)
    {
    	if (!m_bLocked) return E_FAIL;
    
    	//__try {
    
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*((WORD*)pByte)=(WORD)col;	
    		}
    		else if (m_nPixelBytes==4){
    			*((DWORD*)pByte)=(DWORD)col;	
    		}
    		else if (m_nPixelBytes==1){
    			*pByte=(Byte)col;
    		}
    		else if (m_nPixelBytes==3){				
				*(pByte)= (char)(col & 0xFF);
				pByte++;
				*(pByte)= (char)((col & 0xFF00)>>8);
				pByte++;
    			*(pByte)= (char)((col & 0xFF0000)>>16);
    		}

    		else{
    			return E_FAIL;
    		}
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLockedPixel( int x,  int y,  long *col)
    {
    	//__try {
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*col=(long) *((WORD*)pByte);	
    		}
    		else if (m_nPixelBytes==4){
    			*col=(long) *((DWORD*)pByte);	
    		}
	   		else if (m_nPixelBytes==3){
    			*col=(long) (*((DWORD*)pByte))& 0x00FFFFFF;	
    		}
    		else if (m_nPixelBytes==1){
    			*col=(long) *((long*)pByte);
    		}
    		else{
    			return E_FAIL;
    		}
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getClipper( I_dxj_DirectDrawClipper **val)
    {
    	LPDIRECTDRAWCLIPPER		ddc;
    	HRESULT hr=DD_OK;
    	if( (hr=m__dxj_DirectDrawSurface7->GetClipper( &ddc)) != DD_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);
    
    	return S_OK;
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // this is NOT the normal Blt, that is BltFx in our interface
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::blt( Rect *pDest, I_dxj_DirectDrawSurface7 *ddS, Rect *pSrc, long flags, long *status)
    {
    	
    	LPDIRECTDRAWSURFACE7 lpdds = NULL;
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc =(LPRECT)pSrc;
    	
    	if (!ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    	
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, lpdds, prcSrc, flags, NULL);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    											
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltFx(Rect *pDest, I_dxj_DirectDrawSurface7 *ddS, Rect *pSrc, long flags, DDBltFx *bltfx, long *status )
    {
    
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc= (LPRECT)pSrc;
    	LPDIRECTDRAWSURFACE7 lpdds = NULL;
    
    	if ( !ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    
    	if(bltfx)	bltfx->lSize = sizeof(DDBLTFX);
    
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, lpdds, prcSrc, flags, (struct _DDBLTFX *)bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltColorFill( Rect *pDest, long fillvalue, long *status )
    {
    	HWnd hWnd = NULL;
    
    	DDBLTFX bltfx;
    
    	memset(&bltfx,0,sizeof(DDBLTFX));
    	bltfx.dwSize = sizeof(DDBLTFX);
    	bltfx.dwFillColor = (DWORD)fillvalue;
    
    
    	LPRECT prcDest=(LPRECT)pDest;
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltFast( long dx, long dy, I_dxj_DirectDrawSurface7 *dds, Rect *src, long trans, long *status)
    {
    
		if (!dds) return E_INVALIDARG;

    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
    	
    	LPRECT prcSrc=(LPRECT)src;
    
		if (!src) return E_INVALIDARG;

    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->BltFast(dx, dy, lpdds, prcSrc, trans);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::deleteAttachedSurface( I_dxj_DirectDrawSurface7 *dds)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	return m__dxj_DirectDrawSurface7->DeleteAttachedSurface(0, lpdds);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::flip( I_dxj_DirectDrawSurface7 *dds, long flags)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
    
    	return m__dxj_DirectDrawSurface7->Flip(lpdds, flags);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getAttachedSurface( DDSCaps2  *caps, I_dxj_DirectDrawSurface7 **dds)
    {
    	LPDIRECTDRAWSURFACE7 lpdds;	
    	HRESULT hr=DD_OK;
    	
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetAttachedSurface( (DDSCAPS2*)caps, &lpdds)) != S_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpdds, dds);
    
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getCaps( DDSCaps2 *caps)
    {
    	
    	HRESULT hr=DD_OK;
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetCaps((DDSCAPS2*)caps)) != S_OK)
    		return hr;
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getPixelFormat( DDPixelFormat *pf)
    {
    	
    	HRESULT hr=DD_OK;
    
    	DDPIXELFORMAT ddpf;
    	ddpf.dwSize = sizeof(DDPIXELFORMAT);
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetPixelFormat(&ddpf)) != S_OK)
    		return hr;
    
    	CopyOutDDPixelFormat(pf,&ddpf);
    
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getSurfaceDesc( DDSurfaceDesc2 *desc)
    {
    	desc->lpSurface = NULL;
    	HRESULT hr=DD_OK;
    
    	DDSURFACEDESC2 ddsd;
    	ddsd.dwSize=sizeof(DDSURFACEDESC2);
    	ddsd.ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
    	ddsd.lpSurface=NULL;
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetSurfaceDesc( &ddsd )) != S_OK )
    		return hr;
    
    	CopyOutDDSurfaceDesc2(desc,&ddsd);
    		
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::restore()
    {
    	return m__dxj_DirectDrawSurface7->Restore();
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setPalette( I_dxj_DirectDrawPalette *ddp)
    {
    	//
    	// ignore the return value here. Will only work on 256 colours anyway!
    	//
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWPALETTE,lpddp,ddp)
    
    	return m__dxj_DirectDrawSurface7->SetPalette(lpddp);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDraw( I_dxj_DirectDraw7 **val)
    {
    
    	IUnknown *pUnk=NULL;
    	LPDIRECTDRAW7 lpdd;
    	HRESULT hr=DD_OK;
    
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetDDInterface((void **)&pUnk)) != S_OK)
    		return hr;
    	
    	hr=pUnk->QueryInterface(IID_IDirectDraw7,(void**)&lpdd);
    	if FAILED(hr) {
    		if (pUnk) pUnk->Release();
    		return hr;
    	}
    
    	INTERNAL_CREATE(_dxj_DirectDraw7, lpdd, val);
    
    	return S_OK;
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setClipper(I_dxj_DirectDrawClipper *val)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpc, val);
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->SetClipper( lpc);
    	return hr;	
    }

    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::changeUniquenessValue()
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->ChangeUniquenessValue();	
    	return hr;
    }
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getUniquenessValue(long *ret)
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->GetUniquenessValue((DWORD*)ret);	
    	return hr;
    }
    	 	 			
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDrawGammaControl(I_dxj_DirectDrawGammaControl **val)
    {
    
    	HRESULT hr;
    	LPDIRECTDRAWGAMMACONTROL lpGamma=NULL;
    	hr=m__dxj_DirectDrawSurface7->QueryInterface(IID_IDirectDrawGammaControl,(void **)&lpGamma);
    	if FAILED(hr) return hr;
    	INTERNAL_CREATE(_dxj_DirectDrawGammaControl,lpGamma,val);
    	if (*val==NULL) return E_OUTOFMEMORY;
    	return hr;
    	
    
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDrawColorControl(I_dxj_DirectDrawColorControl **val)
    {
    
    	HRESULT hr;
    	LPDIRECTDRAWCOLORCONTROL lpCC=NULL;
    	hr=m__dxj_DirectDrawSurface7->QueryInterface(IID_IDirectDrawColorControl,(void **)&lpCC);
    	if FAILED(hr) return hr;
    	INTERNAL_CREATE(_dxj_DirectDrawColorControl,lpCC,val);
    	if (*val==NULL) return E_OUTOFMEMORY;
    	return hr;
    	
    
    }
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setFont( 
                /* [in] */ IFont __RPC_FAR *font)
    {
    
  	HRESULT hr;
    	if (!font) return E_INVALIDARG;
  	if (m_pIFont) m_pIFont->Release();
  	m_pIFont=NULL;
  	hr=font->Clone(&m_pIFont);
  	return hr;
  	   	
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFontTransparency(VARIANT_BOOL b)
    {
    	m_fFontTransparent=(b!=VARIANT_FALSE);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFontTransparency(VARIANT_BOOL *b)
    {
    	if (m_fFontTransparent) 
    		*b= VARIANT_TRUE;
    	else 
    		*b= VARIANT_FALSE;
    	return S_OK;
    }
    
    
          
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setDrawWidth(  long drawWidth)
    {	
                HPEN hNewPen=NULL;
    		if (drawWidth < 1) return E_INVALIDARG;
    		m_drawWidth=drawWidth;		
    		hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    		if (!hNewPen) return E_INVALIDARG;
    		DeleteObject(m_hPen);    
    		m_hPen=hNewPen;
    		return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getDrawWidth(long *val)
    {
    	*val=m_drawWidth;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setDrawStyle(long drawStyle)
    {
    
        HPEN hNewPen=NULL;     
    	m_drawStyle=drawStyle;		
    	hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
    	DeleteObject(m_hPen);    
    	m_hPen=hNewPen;
    	return S_OK;
    }	
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getDrawStyle(long __RPC_FAR *val)
    {
    	*val=m_drawStyle;
    	return S_OK;
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFillStyle(long fillStyle)
    {
    	
        HBRUSH hNewBrush=NULL;
    
    	
		BOOL fillTransparent =m_fFillTransparent;
		BOOL fillSolid=m_fFillSolid;
		long fillStyle2=fillStyle;

		m_fillStyle = fillStyle;    
    	m_fFillTransparent = FALSE;
    	m_fFillSolid = FALSE;

    	switch(fillStyle){
    		case 6:	//vbCross:
    			m_fillStyleHS = HS_CROSS;
    			break;
    		case 7:	//vbDiagonalCross:
    			m_fillStyleHS = HS_DIAGCROSS;
    			break;
    		case 5: //vbxDownwardDiagonal:
    			m_fillStyleHS = HS_BDIAGONAL;
    			break;
    		case 2: //vbHorizontalLine:
    			m_fillStyleHS = HS_HORIZONTAL;
    			break;
    		case 4: //vbUpwardDiagonal:
    			m_fillStyleHS = HS_FDIAGONAL;
    			break;
    		case 3: //vbVerticalLine:
    			m_fillStyleHS = HS_VERTICAL;
    			break;
    		case 0: ///vbFSSolid:
    			m_fFillSolid = TRUE;
    			break;
    		case 1: //vbFSTransparent:
    			m_fFillTransparent = TRUE;
    			m_fFillSolid = TRUE;
				break;
    		default:
				m_fFillTransparent = fillTransparent;
    			m_fFillSolid = fillSolid;
				m_fillStyle=fillStyle2;
    			return E_INVALIDARG;
    	}
    
    
    	if (m_fFillTransparent) {
    		LOGBRUSH logb;
    		logb.lbStyle = BS_NULL;
    		hNewBrush = CreateBrushIndirect(&logb);
    	}
    	else if (m_fFillSolid) {
    		hNewBrush = CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush = CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
    	if (!hNewBrush) return E_FAIL;
    
    	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFillStyle(long *val)
    {
    	*val=m_fillStyle;
    	return S_OK;
    }
    
    	
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFillColor(long c)
    {   
    	m_fillColor = c;
        HBRUSH  hNewBrush;
    
    	if (m_fFillSolid){
    		hNewBrush= CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush= CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
        
    	if (!hNewBrush) return E_INVALIDARG;
  	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFillColor(long *val)
    {
    	*val=m_fillColor;
    	return S_OK;
    }
    
            
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setForeColor(  long color)
    {
    	m_foreColor=color;
        HPEN hNewPen=NULL;
                    
        
        hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
        if (m_hPen)  DeleteObject (m_hPen);
    	m_hPen=hNewPen;
    	return S_OK;
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getForeColor(long *val)
    {
    	*val=m_foreColor;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawLine( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	POINT points[2];
        HRESULT hr;
    
        hr =m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        points[0].x = x1;
        points[0].y = y1;
        
        
        points[1].x = x2;
        points[1].y = y2;
        
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
    
		
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }

        Polyline(hdc, points, 2);
        
    	//why do this..
        //if (oldpen)   SelectObject(hdc, oldpen);
        //if (oldbrush) SelectObject(hdc, oldbrush);
            
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
        
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
        HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
           
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
     
        Rectangle(hdc, x1,y1,x2,y2);
        
            
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawRoundedBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2,
                /* [in] */ long rw,
                /* [in] */ long rh)
    
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
        
        RoundRect(hdc, x1,y1,x2,y2,rw,rh);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }        
        
        
        
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawEllipse( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    
        hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
        
    	Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }        
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawCircle( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ long r)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    	long x1,y1,x2,y2;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);        
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
            
        x1 = x - r;
        x2 = x + r;
        y1 = y - r;
        y2 = y + r;
    

        Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawText( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ BSTR str,
                /* [in] */ VARIANT_BOOL b)
    {
        HDC hdc=NULL;
    	HRESULT hr;	
    	DWORD len=0;
    	UINT txtA;
    
    	if (!str) return E_INVALIDARG;

  		len = ((DWORD*)str)[-1]/2;
    
        hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	    	
    
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
        SetTextColor(hdc, m_foreColor);
        

        
    	txtA=GetTextAlign(hdc);
    	if (b!=VARIANT_FALSE){				
    		if (!(txtA & TA_UPDATECP)) SetTextAlign(hdc,txtA | TA_UPDATECP);
    	}
    	else {		
    		if (txtA & TA_UPDATECP)	SetTextAlign(hdc,txtA-TA_UPDATECP);			
    	}
    	
  	if (m_pIFont) {
  		HFONT hFont=NULL;
  		m_pIFont->SetHdc(hdc);
  	    m_pIFont->get_hFont(&hFont);
  		SelectObject (hdc, hFont);
  	}
  
        ExtTextOutW(hdc, (int)x, (int)y, 0, 0, str, len, 0);
    
    	m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::bltToDC( 
                /* [in] */ long hdcDest,
                /* [in] */ Rect __RPC_FAR *srcRect,
                /* [in] */ Rect __RPC_FAR *destRect)
    {
    	HRESULT hr;
    	BOOL b;
    	HDC		hdc=NULL;
    	
    	if (!srcRect) return E_INVALIDARG;
    	if (!destRect) return E_INVALIDARG;
    
    	hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
    	if FAILED(hr) return hr;
    
		
    	int nWidthDest= destRect->right-destRect->left;
    	int nHeightDest=destRect->bottom-destRect->top;
    	int nWidthSrc= srcRect->right-srcRect->left;
    	int nHeightSrc=srcRect->bottom-srcRect->top;
    

		if ((0==srcRect->top) && (0==srcRect->left ) && (0==srcRect->top) &&(0==srcRect->bottom ))
		{
			DDSURFACEDESC2 desc;
			desc.dwSize=sizeof(DDSURFACEDESC2);
			m__dxj_DirectDrawSurface7->GetSurfaceDesc(&desc);
			nWidthSrc=desc.dwWidth;
			nHeightSrc=desc.dwHeight;
		}  



    	b=StretchBlt((HDC)hdcDest,
    		destRect->left,destRect->top,
    		nWidthDest, nHeightDest,
    		hdc,
    		srcRect->left,srcRect->top,
    		nWidthSrc, nHeightSrc, SRCCOPY);
      
    
    	m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	
    	//CONSIDER: are we being presumptious that if blt fails its due to arg probs?
    	if (!b) return E_INVALIDARG;
    
    	return S_OK;
    
    }

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getAttachedSurfaceEnum(I_dxj_DirectDrawEnumSurfaces **val)
    {
    
    	HRESULT hr;
    	hr=C_dxj_DirectDrawEnumSurfacesObject::createAttachedEnum((I_dxj_DirectDrawSurface7 *)this,val);
    	return hr;
    
    }

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setPriority( long Priority)
	{
		return m__dxj_DirectDrawSurface7->SetPriority((DWORD)Priority);

	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getPriority( long *Priority)
	{
		return m__dxj_DirectDrawSurface7->GetPriority((DWORD*)Priority);
	}


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setLOD( long lod)
	{
		return m__dxj_DirectDrawSurface7->SetLOD((DWORD)lod);
	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLOD(long *lod)
	{
		return m__dxj_DirectDrawSurface7->GetLOD((DWORD*)lod);

	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLockedArray(SAFEARRAY **pArray)
	{
		

		if (!m_bLocked) return E_FAIL;
		

		if (!pArray) return E_INVALIDARG;
		if (*pArray) return E_INVALIDARG;
		m_ppSA=pArray;


		m_bLockedArray=TRUE;

		ZeroMemory(&m_saLockedArray,sizeof(SAFEARRAY));
		m_saLockedArray.cbElements =1;
		m_saLockedArray.cDims =2;
		m_saLockedArray.rgsabound[0].lLbound =0;
		m_saLockedArray.rgsabound[0].cElements =m_ddsd.dwHeight;
		m_saLockedArray.rgsabound[1].lLbound =0;
		m_saLockedArray.rgsabound[1].cElements =m_ddsd.lPitch;
		m_saLockedArray.pvData =m_ddsd.lpSurface;

		
		*pArray=&m_saLockedArray;
    
		
    	return S_OK;
	}



	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFontBackColor( 
                /* [in] */ long color)
    {
		m_fontBackColor=(DWORD)color;
    	return S_OK;
    }
    

	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFontBackColor( 
                /* [in] */ long *color)
    {    	
		if (!color) return E_INVALIDARG;            
        *color=(long)m_fontBackColor;    	                    
    	return S_OK;
    }
    
    		
	

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlayZOrder(long flags,I_dxj_DirectDrawSurface7 *dds)
    {
		HRESULT hr;
		DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
		hr= m__dxj_DirectDrawSurface7->UpdateOverlayZOrder((DWORD)flags,lpdds);
		return hr;
	}

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getOverlayZOrdersEnum(long flags,I_dxj_DirectDrawEnumSurfaces **val)
    {
    
    	HRESULT hr;
    	hr=C_dxj_DirectDrawEnumSurfacesObject::createZEnum((I_dxj_DirectDrawSurface7*)this,flags,val);
    	return hr;
    
    }
       
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getOverlayPosition( long *x, long *y)
    {   
    	return m__dxj_DirectDrawSurface7->GetOverlayPosition(x, y) ;
    }
    
	STDMETHODIMP C_dxj_DirectDrawSurface7Object::setOverlayPosition( long x, long y)
    {   
    	return m__dxj_DirectDrawSurface7->SetOverlayPosition(x, y) ;
    }
    


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlay( Rect *r, I_dxj_DirectDrawSurface7 *dds, Rect *d, long flags)
    {
    	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	LPRECT pr1=NULL;
		LPRECT pr2=NULL;

		if (r) {
			pr1=(RECT*) r;
			if ((r->top==0)&&(r->bottom==0)&&(r->left==0)&&(r->right==0))
				pr1=NULL;
		}

		if (d) {
			pr2=(RECT*) d;
			if ((d->top==0)&&(d->bottom==0)&&(d->left==0)&&(d->right==0))
				pr2=NULL;
		}

		return m__dxj_DirectDrawSurface7->UpdateOverlay(pr1, lpdds, pr2, flags, NULL);
    }
    


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlayFx( Rect *r, I_dxj_DirectDrawSurface7 *dds, Rect *d, long flags, DDOVERLAYFX_CDESC *desc)
    {
		if (!desc) return E_INVALIDARG;

		DDOVERLAYFX *lpOverlayFx=(DDOVERLAYFX*)desc;
		

		lpOverlayFx->dwSize =sizeof(DDOVERLAYFX);

    	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	LPRECT pr1=NULL;
		LPRECT pr2=NULL;

		if (r) {
			pr1=(RECT*) r;
			if ((r->top==0)&&(r->bottom==0)&&(r->left==0)&&(r->right==0))
				pr1=NULL;
		}

		if (d) {
			pr2=(RECT*) d;
			if ((d->top==0)&&(d->bottom==0)&&(d->left==0)&&(d->right==0))
				pr2=NULL;
		}

		return m__dxj_DirectDrawSurface7->UpdateOverlay(pr1, lpdds, pr2, flags, lpOverlayFx);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddsurfacedescobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddsurfacedescobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDSurfaceDescObject : 
	public I_dxj_DDSurfaceDesc,
	public CComCoClass<C_dxj_DDSurfaceDescObject, &CLSID__dxj_DDSurfaceDesc>, 
	public CComObjectRoot
{
public:
	C_dxj_DDSurfaceDescObject() ;
	virtual ~C_dxj_DDSurfaceDescObject() ;

BEGIN_COM_MAP(C_dxj_DDSurfaceDescObject)
	COM_INTERFACE_ENTRY( I_dxj_DDSurfaceDesc)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDSurfaceDescObject)
DECLARE_REGISTRY(CLSID__dxj_DDSurfaceDesc,	"DIRECT.DDSurfaceDesc.5",		"DIRECT.DDSurfaceDesc.5",	IDS_GENERIC_DESC, THREADFLAGS_BOTH)


public:

        HRESULT STDMETHODCALLTYPE getDescription( DDSurfaceDesc *desc);
		HRESULT STDMETHODCALLTYPE setDescription( DDSurfaceDesc *desc);

private:
		DDSurfaceDesc m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\ddsurface7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface7obj.h
//
//--------------------------------------------------------------------------

// ddSurfaceObj.h : Declaration of the C_dxj_DirectDrawSurfaceObject


#include "resource.h"       // main symbols
#define typedef__dxj_DirectDrawSurface7 LPDIRECTDRAWSURFACE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawSurface7Object :
	public I_dxj_DirectDrawSurface7,
	//public CComCoClass<C_dxj_DirectDrawSurface7Object, &CLSID__dxj_DirectDrawSurface7>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawSurface7Object() ;
	virtual ~C_dxj_DirectDrawSurface7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawSurface7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawSurface7)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawSurface7,  "DIRECT.ddSurface4.3",	"DIRECT.DirectDrawSurface7.3",	IDS_DDSURFACE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawSurface7Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawSurface7Object)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawSurface7
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdds);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdds);

		HRESULT STDMETHODCALLTYPE addAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS) ;
        
        HRESULT STDMETHODCALLTYPE blt( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltColorFill( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ long fillvalue,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFast( 
            /* [in] */ long dx,
            /* [in] */ long dy,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long trans,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFx( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [in] */ DDBltFx __RPC_FAR *bltfx,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltToDC( 
            /* [in] */ long hdc,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ Rect __RPC_FAR *destRect);
        
        HRESULT STDMETHODCALLTYPE changeUniquenessValue( void);
        
        HRESULT STDMETHODCALLTYPE deleteAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE drawBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawCircle( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long r);
        
        HRESULT STDMETHODCALLTYPE drawEllipse( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawLine( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawRoundedBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long rw,
            /* [in] */ long rh);
        
        HRESULT STDMETHODCALLTYPE drawText( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ BSTR text,
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE flip( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurface( 
            /* [in] */ DDSCaps2 __RPC_FAR *caps,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurfaceEnum( 
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *retval);
        
        HRESULT STDMETHODCALLTYPE getBltStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDSCaps2 __RPC_FAR *caps);
        
        HRESULT STDMETHODCALLTYPE getClipper( 
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getColorKey( 
            /* [in] */ long flags,
            /* [out][in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDC( 
            /* [retval][out] */ long __RPC_FAR *hdc);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDirectDrawColorControl( 
            /* [retval][out] */ I_dxj_DirectDrawColorControl __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDrawGammaControl( 
            /* [retval][out] */ I_dxj_DirectDrawGammaControl __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDrawStyle( 
            /* [retval][out] */ long __RPC_FAR *drawStyle);
        
        HRESULT STDMETHODCALLTYPE getDrawWidth( 
            /* [retval][out] */ long __RPC_FAR *drawWidth);
        
        HRESULT STDMETHODCALLTYPE getFillColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getFillStyle( 
            /* [retval][out] */ long __RPC_FAR *fillStyle);
        
        HRESULT STDMETHODCALLTYPE getFlipStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getFontTransparency( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
        HRESULT STDMETHODCALLTYPE getForeColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ long __RPC_FAR *col);
                        
        HRESULT STDMETHODCALLTYPE getPalette( 
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getPixelFormat( 
            /* [out][in] */ DDPixelFormat __RPC_FAR *pf);
        
        HRESULT STDMETHODCALLTYPE getSurfaceDesc( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
        //HRESULT STDMETHODCALLTYPE getTexture( 
        //    /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getUniquenessValue( 
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE isLost( 
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ Rect __RPC_FAR *r,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [in] */ Handle hnd);
        
        HRESULT STDMETHODCALLTYPE releaseDC( 
            /* [in] */ long hdc);
        
        HRESULT STDMETHODCALLTYPE restore( void);
        
        HRESULT STDMETHODCALLTYPE setClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setColorKey( 
            /* [in] */ long flags,
            /* [in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setDrawStyle( 
            /* [in] */ long drawStyle);
        
        HRESULT STDMETHODCALLTYPE setDrawWidth( 
            /* [in] */ long drawWidth);
        
        HRESULT STDMETHODCALLTYPE setFillColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setFillStyle( 
            /* [in] */ long fillStyle);
        
        HRESULT STDMETHODCALLTYPE setFont( 
            /* [in] */ IFont __RPC_FAR *font);
        
        HRESULT STDMETHODCALLTYPE setFontTransparency( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setForeColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ long col);
                
        HRESULT STDMETHODCALLTYPE setPalette( 
            /* [in] */ I_dxj_DirectDrawPalette __RPC_FAR *ddp);
        
        HRESULT STDMETHODCALLTYPE unlock( 
            /* [in] */ Rect __RPC_FAR *r);

		HRESULT STDMETHODCALLTYPE setPriority( long pri);
		HRESULT STDMETHODCALLTYPE getPriority( long *pri);

		HRESULT STDMETHODCALLTYPE setLOD( long lod);
		HRESULT STDMETHODCALLTYPE getLOD( long *lod);


		HRESULT STDMETHODCALLTYPE getLockedArray(SAFEARRAY **pArray);

        HRESULT STDMETHODCALLTYPE setFontBackColor( 
            /* [in] */ long color);

		HRESULT STDMETHODCALLTYPE getFontBackColor( 
            /* [out,retval] */ long *color);

		/* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlay( 
            /* [in] */ Rect __RPC_FAR *rect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *rectD,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlayZOrder( 
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getOverlayPosition( 
            /* [out][in] */ long __RPC_FAR *x,
            /* [out][in] */ long __RPC_FAR *y);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setOverlayPosition( 
            /* [in] */ long x,
            /* [in] */ long y);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getOverlayZOrdersEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *retval) ;

		/* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlayFx( 
            /* [in] */ Rect __RPC_FAR *rect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *rectD,
            /* [in] */ long flags,
			/* [in,out] */ DDOVERLAYFX_CDESC *desc);
			

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDrawSurface7);
	//BOOL m_primaryflag;

private:
	C_dxj_DirectDrawSurface7Object *_dxj_DirectDrawSurface7Lock;


	DDSURFACEDESC2	m_ddsd;
	BOOL			m_bLocked;
	int				m_nPixelBytes;

	BOOL	m_fFontTransparent;
	BOOL	m_fFillSolid;
	BOOL	m_fFillTransparent;
	DWORD	m_fillStyle;
	DWORD	m_fillStyleHS;
	DWORD	m_fillColor;
	DWORD	m_foreColor;
	DWORD	m_fontBackColor;
	DWORD	m_drawStyle;
	DWORD	m_drawWidth;
	HPEN	m_hPen;
	HBRUSH	m_hBrush;
	HFONT	m_hFont;
	IFont	*m_pIFont;
	SAFEARRAY **m_ppSA;
	BOOL	m_bLockedArray;
	SAFEARRAY m_saLockedArray;
	DWORD	m_pad[4];
	
	

//pac

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDrawSurface7)
};


// 
// Copies values from native unions into redundant Java members.
void 	ExpandDDSurface4Desc(LPDDSURFACEDESC lpDesc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\didevinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DIDeviceInstanceObject :
		public I_dxj_DirectInputDeviceInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceInstance)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DIDeviceInstanceObject)

public:
	C_dxj_DIDeviceInstanceObject();	
  

        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidProduct( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getInstanceName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidFFDriver( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getDevType( 
            /* [retval][out] */ long __RPC_FAR *ret);

		void init(DIDEVICEINSTANCE *inst);
		static HRESULT C_dxj_DIDeviceInstanceObject::create(DIDEVICEINSTANCE  *inst,I_dxj_DirectInputDeviceInstance **ret);


private:
		DIDEVICEINSTANCE m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\didevobjinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DIDeviceObjectInstanceObject :
		public I_dxj_DirectInputDeviceObjectInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceObjectInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceObjectInstance)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID_DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DIDeviceObjectInstanceObject)

public:
	C_dxj_DIDeviceObjectInstanceObject();	


	/* [propget] */ HRESULT STDMETHODCALLTYPE getGuidType( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getOfs( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getType( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getName( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getCollectionNumber( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDesignatorIndex( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDimension( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getExponent( 
		/* [retval][out] */ short __RPC_FAR *ret);

  
		static HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCE *inst,I_dxj_DirectInputDeviceObjectInstance **ret);

		void init(DIDEVICEOBJECTINSTANCE *inst);
private:
		DIDEVICEOBJECTINSTANCE m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\didevobjinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevObjInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);


	
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getGuidType( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidType);
	return S_OK;
}

        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getOfs(  long __RPC_FAR *ret){
	*ret=(long)m_inst.dwOfs;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwType;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getFlags( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwFlags;
	return S_OK;
}

//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getCollectionNumber( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wCollectionNumber;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDesignatorIndex( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wDesignatorIndex;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getExponent( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wExponent;
	return S_OK;
}


STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDimension( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDimension;
	return S_OK;
}

        
        
C_dxj_DIDeviceObjectInstanceObject::C_dxj_DIDeviceObjectInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEOBJECTINSTANCE));
}

void C_dxj_DIDeviceObjectInstanceObject::init(DIDEVICEOBJECTINSTANCE *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEOBJECTINSTANCE));
}

HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCE *inst,I_dxj_DirectInputDeviceObjectInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceObjectInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceObjectInstanceObject>;
	if( c == NULL ) return E_FAIL;
	c->init(inst);
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceObjectInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumdeviceobjectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdeviceobjectsobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DIEnumDeviceObjectsObj.h"
#include "didevObjInstOBj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL CALLBACK DIEnumDeviceObjectsProc(
  LPCDIDEVICEOBJECTINSTANCE lpddoi,  
  LPVOID lpArg                       
  )
{
 
	if (!lpddoi) return FALSE;

	C_dxj_DIEnumDeviceObjectsObject *pObj=(C_dxj_DIEnumDeviceObjectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIDEVICEOBJECTINSTANCE)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIDEVICEOBJECTINSTANCE *)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIDEVICEOBJECTINSTANCE *)malloc(sizeof(DIDEVICEOBJECTINSTANCE)* pObj->m_nMax);
		}

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddoi,sizeof(DIDEVICEOBJECTINSTANCE ));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDeviceObjectsObject::C_dxj_DIEnumDeviceObjectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDeviceObjectsObject::~C_dxj_DIEnumDeviceObjectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}
		

HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDeviceObjectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDeviceObjectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumObjects(
		(LPDIENUMDEVICEOBJECTSCALLBACK )DIEnumDeviceObjectsProc,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDeviceObjects,(void**)ppRet);
	return hr;
}


/* DEAD
HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, DIDeviceObjectInstance *instCover)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;


	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString((BSTR)instCover->strGuidType);
	if (instCover->strName) SysFreeString((BSTR)instCover->strName);

	
	DIDEVICEOBJECTINSTANCE *inst=&m_pList[index];

	//TODO - consider localization	
	if (inst->tszName){
		instCover->strName=T2BSTR(inst->tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst->guidType);
	instCover->lOfs=inst->dwOfs;
	instCover->lType=inst->dwType;
	instCover->lFlags=inst->dwFlags;
	
	instCover->lFFMaxForce=inst->dwFFMaxForce;
	instCover->lFFForceResolution=inst->dwFFForceResolution;
	instCover->nCollectionNumber=inst->wCollectionNumber;
	instCover->nDesignatorIndex=inst->wDesignatorIndex;
	instCover->nUsagePage=inst->wUsagePage;
	instCover->nUsage=inst->wUsage;
	instCover->lDimension=inst->dwDimension;
	instCover->nExponent=inst->wExponent;
	instCover->nReserved=inst->wReserved;
	
	return S_OK;
}
*/


HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, I_dxj_DirectInputDeviceObjectInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	DIDEVICEOBJECTINSTANCE *inst=&m_pList[index-1];

	if (!inst) return E_INVALIDARG;

	HRESULT hr;
	hr=C_dxj_DIDeviceObjectInstanceObject::create(inst,ret);
	return hr;
}

HRESULT C_dxj_DIEnumDeviceObjectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\didevinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);
       
	

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidInstance( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidInstance);
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidProduct( BSTR __RPC_FAR *ret){
	*ret=GUIDtoBSTR( &(m_inst.guidProduct));
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidFFDriver( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&(m_inst.guidFFDriver));
	return S_OK;
}
        
        
//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getProductName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszProductName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getInstanceName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszInstanceName);		
	return S_OK;
}

        

        
STDMETHODIMP C_dxj_DIDeviceInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getDevType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDevType;
	return S_OK;
}        
        
C_dxj_DIDeviceInstanceObject::C_dxj_DIDeviceInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEINSTANCE));
}

void C_dxj_DIDeviceInstanceObject::init(DIDEVICEINSTANCE *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEINSTANCE));
}

HRESULT C_dxj_DIDeviceInstanceObject::create(DIDEVICEINSTANCE *inst,I_dxj_DirectInputDeviceInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceInstanceObject>;
	c->init(inst);

	if( c == NULL ) return E_FAIL;
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumdevicesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdevicesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDevicesObject : 
	public I_dxj_DIEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDevicesObject() ;
	virtual ~C_dxj_DIEnumDevicesObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDevicesObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDevicesObject)

public:

        HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectInputDeviceInstance **ret);
        HRESULT STDMETHODCALLTYPE getCount( long __RPC_FAR *count);
		
		
		static HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT pDI,long deviceType, long flags,I_dxj_DIEnumDevices **ppRet)	;

public:
		DIDEVICEINSTANCE *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumdevicesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdevicesobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumDevicesObj.h"
#include "diDevInstObj.h"

extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoGUID(LPGUID pGuid,BSTR bstr);



/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL CALLBACK  objEnumInputDevicesCallback(
  LPDIDEVICEINSTANCE lpddi,  
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCE)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIDEVICEINSTANCE*)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCE*)malloc(   sizeof(DIDEVICEINSTANCE)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCE));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDevicesObject::C_dxj_DIEnumDevicesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDevicesObject::~C_dxj_DIEnumDevicesObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT pDI,long deviceType, long flags,I_dxj_DIEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumDevices((DWORD)deviceType, 
		(LPDIENUMDEVICESCALLBACK)objEnumInputDevicesCallback,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, I_dxj_DirectInputDeviceInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr;
	
	hr=C_dxj_DIDeviceInstanceObject::create(&m_pList[index-1],ret);		
	return hr;
}

/* DEAD
HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, DIDeviceInstance *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	if (info->strGuidInstance) SysFreeString((BSTR)info->strGuidInstance);
	if (info->strGuidProduct) SysFreeString((BSTR)info->strGuidProduct);
	if (info->strGuidFFDriver) SysFreeString((BSTR)info->strGuidFFDriver);


	info->strGuidInstance=GUIDtoBSTR(&((m_pList[index]).guidInstance));
	info->strGuidProduct=GUIDtoBSTR(&((m_pList[index]).guidProduct));
	info->strGuidFFDriver=GUIDtoBSTR(&((m_pList[index]).guidFFDriver));
	info->lDevType=(long)(m_pList[index]).dwDevType;
	info->nUsagePage=(short)(m_pList[index]).wUsagePage;
	info->nUsage=(short)(m_pList[index]).wUsage;
	
	USES_CONVERSION;

	if (info->strProductName)
		SysFreeString((BSTR)info->strProductName);
	if (info->strInstanceName)
		SysFreeString((BSTR)info->strInstanceName);
	
	info->strInstanceName=NULL;
	info->strProductName=NULL;

	if (m_pList[index].tszProductName)
		info->strProductName=T2BSTR(m_pList[index].tszProductName);

	if (m_pList[index].tszInstanceName)
		info->strInstanceName=T2BSTR(m_pList[index].tszInstanceName);

	return S_OK;
}
*/

HRESULT C_dxj_DIEnumDevicesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumdeviceobjectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdeviceobjectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDeviceObjectsObject : 
	public I_dxj_DIEnumDeviceObjects,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDeviceObjectsObject() ;
	virtual ~C_dxj_DIEnumDeviceObjectsObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDeviceObjectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDeviceObjects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDeviceObjectsObject)


public:
        HRESULT STDMETHODCALLTYPE getItem( 
            /* [in] */ long index,
            /* [out][in] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR **info);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
		
				
		static HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet);
public:
		DIDEVICEOBJECTINSTANCE *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinput1obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectInput LPDIRECTINPUT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputObject : 
	public I_dxj_DirectInput,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputObject() ;
	virtual ~C_dxj_DirectInputObject();

BEGIN_COM_MAP(C_dxj_DirectInputObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInput)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputObject)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectInputDevice __RPC_FAR *__RPC_FAR *dev);
        
        HRESULT STDMETHODCALLTYPE getDIEnumDevices( 
            /* [in] */ long deviceType,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDevices __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDeviceStatus( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ VARIANT_BOOL *status);
        
        HRESULT STDMETHODCALLTYPE runControlPanel( 
            /* [in] */ long hwndOwner
            ///* [in] */ long flags
			);
                

private:
    DECL_VARIABLE(_dxj_DirectInput);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumeffectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectInputEnumEffectsObject : 
	public I_dxj_DirectInputEnumEffects,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEnumEffectsObject() ;
	virtual ~C_dxj_DirectInputEnumEffectsObject() ;

BEGIN_COM_MAP(C_dxj_DirectInputEnumEffectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEnumEffects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEnumEffectsObject)

public:

         HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getStaticParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getDynamicParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		
		static HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE2 pDI,long effType,I_dxj_DirectInputEnumEffects **ppRet)	;

public:
		DIEFFECTINFO  *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinput1obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.cpp
//
//--------------------------------------------------------------------------

    // dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
    // DHF_DS entire file
    
    #include "stdafx.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    #include "dinput.h"
    #include "DIEnumDevicesObj.h"
    
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    extern HRESULT DINPUTBSTRtoGUID(LPGUID,BSTR);
    
    CONSTRUCTOR(_dxj_DirectInput, {});
    DESTRUCTOR(_dxj_DirectInput, {});
    GETSET_OBJECT(_dxj_DirectInput);
                                      
       
    STDMETHODIMP C_dxj_DirectInputObject::createDevice(BSTR strGuid, I_dxj_DirectInputDevice **dev)
    {    
    
    	HRESULT hr = DD_OK;
  		GUID		rguid;
    
    	LPDIRECTINPUTDEVICE realdevice1=NULL;
    	LPDIRECTINPUTDEVICE2 realdevice=NULL;
    
    	
		hr = DINPUTBSTRtoGUID(&rguid,strGuid);	
    	if FAILED(hr) return hr;	
    

    
     	hr=m__dxj_DirectInput->CreateDevice(rguid,&realdevice1,NULL);
    	if FAILED(hr) return hr;
    
    	hr=realdevice1->QueryInterface(IID_IDirectInputDevice2,(void**)&realdevice);
    	realdevice1->Release();
    	if FAILED(hr) return hr;
    
    	INTERNAL_CREATE(_dxj_DirectInputDevice,realdevice,dev);
    	if (*dev==NULL) {
    		realdevice->Release();
    		return E_OUTOFMEMORY;
    	}
    	
    
    	if (0==_wcsicmp(strGuid,L"guid_syskeyboard")){		
    		hr=realdevice->SetDataFormat(&c_dfDIKeyboard);
    	}
    	else if (0==_wcsicmp(strGuid,L"guid_sysmouse")){		
    		hr=realdevice->SetDataFormat(&c_dfDIMouse);
    	}
    	else {
    		hr=realdevice->SetDataFormat(&c_dfDIJoystick2);
    	}
    
    	return hr;
    }
    
    
    STDMETHODIMP C_dxj_DirectInputObject::runControlPanel( long hwndOwner )
    {
       HRESULT hr;
       hr = m__dxj_DirectInput->RunControlPanel((HWND)hwndOwner,  (DWORD)0);    
       return hr;
    }
    
    STDMETHODIMP C_dxj_DirectInputObject::getDeviceStatus( BSTR strGuid, VARIANT_BOOL *status){
       HRESULT hr;
       GUID g;
	   hr = DINPUTBSTRtoGUID(&g,strGuid);	       
       if FAILED(hr) return hr;

	   if (!status) return E_INVALIDARG;

       hr = m__dxj_DirectInput->GetDeviceStatus((REFGUID)g);    
    
	   if (hr==DI_OK)
			*status=VARIANT_TRUE;
	   else
			*status=VARIANT_FALSE;

       return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectInputObject::getDIEnumDevices(
    	long deviceType, long flags, I_dxj_DIEnumDevices **ppRet)
    
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::create(m__dxj_DirectInput,deviceType,flags,ppRet);
    	return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dienumeffectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumEffectsObj.h"


extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);



////////////////////////////////////////////////////////////////////////////

extern "C" BOOL CALLBACK  objEnumInputEffectsCallback(
  LPCDIEFFECTINFO pdei,  
  LPVOID lpArg           
  )
{

	DPF(1,"Entered objEnumInputEffectsCallback\r\n");

	if (!pdei) return FALSE;

	C_dxj_DirectInputEnumEffectsObject *pObj=(C_dxj_DirectInputEnumEffectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			void* tmp = realloc(pObj->m_pList,sizeof(DIEFFECTINFO)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DIEFFECTINFO*)tmp;
			else
				return FALSE;
		}
		else {
			pObj->m_pList=(DIEFFECTINFO*)malloc(   sizeof(DIEFFECTINFO)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pdei,sizeof(DIEFFECTINFO));
	
	DPF1(1,"objEnumInputEffects '%s'\n",pdei->tszName);

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectInputEnumEffectsObject::C_dxj_DirectInputEnumEffectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectInputEnumEffectsObject::~C_dxj_DirectInputEnumEffectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE2 pDI,long effectType,I_dxj_DirectInputEnumEffects **ppRet)
{
	HRESULT hr;
	C_dxj_DirectInputEnumEffectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectInputEnumEffectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumEffects(
		objEnumInputEffectsCallback,
		(void*)pNew,
		(DWORD) effectType);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectInputEnumEffects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getEffectGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=DINPUTGUIDtoBSTR(&(m_pList[index-1].guid));
		
	return S_OK;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	USES_CONVERSION;

	*ret=T2BSTR(m_pList[index-1].tszName);
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getType( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwEffType;
		
	return S_OK;
}


HRESULT C_dxj_DirectInputEnumEffectsObject::getStaticParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwStaticParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getDynamicParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwDynamicParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinputdeviceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500


// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dienumDeviceObjectsObj.h"
#include "dIEnumEffectsObj.h"
#include "dInputdeviceObj.h"
#include "dInputEffectObj.h"
#include "didevInstObj.h"
#include "didevObjInstObj.h"


//TODO move to typlib enum
#define dfDIKeyboard  1
#define dfDIMouse     2
#define dfDIJoystick  3
#define dfDIJoystick2 4

extern HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover);


extern HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str);
extern BSTR DINPUTGUIDtoBSTR(LPGUID pg);


HRESULT C_dxj_DirectInputDeviceObject::init()
{
	nFormat=0;
	return S_OK;
}
HRESULT C_dxj_DirectInputDeviceObject::cleanup()
{
	return S_OK;
}

CONSTRUCTOR(_dxj_DirectInputDevice, {init();});
DESTRUCTOR(_dxj_DirectInputDevice, {cleanup();});

//NOTE get set for Device object
// must use QI to get at other objects.
GETSET_OBJECT(_dxj_DirectInputDevice);
                                  
   
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects  **ppret)
{
	HRESULT hr;
	hr=C_dxj_DIEnumDeviceObjectsObject::create(m__dxj_DirectInputDevice,flags,ppret);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::acquire(){
	return m__dxj_DirectInputDevice->Acquire();	
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getCapabilities(DIDevCaps *caps)
{
	//DIDevCaps same in VB/Java as in C
	caps->lSize=sizeof(DIDEVCAPS);
	HRESULT hr=m__dxj_DirectInputDevice->GetCapabilities((DIDEVCAPS*)caps);		
	return hr;
}

//VB cant return sucess codes so we will return an error code
#define VB_DI_BUFFEROVERFLOW 0x80040260
        

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceData(            
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,            
            /* [in] */ long flags,
			long *ret)

{
	HRESULT hr;
	
	if ((*deviceObjectDataArray)->cDims!=1) return E_INVALIDARG;
	if ((*deviceObjectDataArray)->cbElements!=sizeof(DIDEVICEOBJECTDATA)) return E_INVALIDARG;
	
	DWORD dwC= (*deviceObjectDataArray)->rgsabound[0].cElements;

	if (dwC==0) return E_INVALIDARG;
	
	LPDIDEVICEOBJECTDATA  pobjData=(LPDIDEVICEOBJECTDATA)((SAFEARRAY*)*deviceObjectDataArray)->pvData;
	hr=m__dxj_DirectInputDevice->GetDeviceData(sizeof(DIDEVICEOBJECTDATA), pobjData, (DWORD*)&dwC,flags);		
	
	*ret=dwC;

	if (hr==DI_BUFFEROVERFLOW) hr= VB_DI_BUFFEROVERFLOW;
		

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceInfo(        
            /* [out] */ I_dxj_DirectInputDeviceInstance __RPC_FAR **info)
{
	HRESULT hr;

	//DIDeviceInstance not the Same in C as VB/J

	DIDEVICEINSTANCE inst;
	ZeroMemory(&inst,sizeof(DIDEVICEINSTANCE));
	inst.dwSize=sizeof(DIDEVICEINSTANCE);

	hr=m__dxj_DirectInputDevice->GetDeviceInfo(&inst);
	if FAILED(hr) return hr;

	hr=C_dxj_DIDeviceInstanceObject::create(&inst,info);
	return hr;

	/* DEAD
	info->strGuidInstance=GUIDtoBSTR(&inst.guidInstance);
	info->strGuidProduct=GUIDtoBSTR(&inst.guidProduct);
	info->strGuidFFDriver=GUIDtoBSTR(&inst.guidFFDriver);

	
	info->lDevType=(long)inst.dwDevType;
	info->nUsagePage=(short)inst.wUsagePage;
	info->nUsage=(short)inst.wUsage;
	
	USES_CONVERSION;
	
	if (info->strProductName)
		DXALLOCBSTR(info->strProductName);
	if (info->strInstanceName)
		DXALLOCBSTR(info->strInstanceName);
	
	info->strInstanceName=NULL;
	info->strProductName=NULL;

	if (inst.tszProductName)
		info->strProductName=T2BSTR(inst.tszProductName);

	if (inst.tszInstanceName)
		info->strInstanceName=T2BSTR(inst.tszInstanceName);
	*/
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateKeyboard(        
            /* [out] */ DIKeyboardState __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIKeyboard) && (nFormat!=-1)) return DIERR_NOTINITIALIZED    ;

	hr=m__dxj_DirectInputDevice->GetDeviceState(256,(void*)state->key);	
	
	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateMouse( 
            /* [out] */ DIMouseState __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIMOUSESTATE),(void*)state);	
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateJoystick( 
            /* [out] */ DIJoyState __RPC_FAR *state)
{
	HRESULT hr;

	//note Joystick1 or Joystick2 are valid formats since
	//one is a superset of the other
	if ((nFormat!= dfDIJoystick)&&(nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIJOYSTATE),(void*)state);	
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateJoystick2( 
            /* [out] */ DIJoyState2 __RPC_FAR *state)
{
	HRESULT hr;

	//only for format2
	if ((nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIJOYSTATE2),(void*)state);	
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void *pFormat)

{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectInputDevice->GetDeviceState((DWORD) cb,(void*)pFormat);	
	}
	__except(1,1){
		hr=E_INVALIDARG;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getObjectInfo(                         
            /* [in] */ long obj,
            /* [in] */ long how,
				I_dxj_DirectInputDeviceObjectInstance **ret)
{
	

	DIDEVICEOBJECTINSTANCE inst;
	ZeroMemory(&inst,sizeof(DIDEVICEOBJECTINSTANCE));
	inst.dwSize=sizeof(DIDEVICEOBJECTINSTANCE);

	HRESULT hr;
	hr=m__dxj_DirectInputDevice->GetObjectInfo(&inst,(DWORD) obj,(DWORD)how);
	if FAILED(hr) return hr;
	
	hr=C_dxj_DIDeviceObjectInstanceObject::create(&inst,ret);

	return hr;

	/* DEAD

	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString((BSTR)instCover->strGuidType);
	if (instCover->strName) SysFreeString((BSTR)instCover->strName);

	

	//TODO - consider localization	
	if (inst.tszName){
		instCover->strName=T2BSTR(inst.tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst.guidType);
	instCover->lOfs=inst.dwOfs;
	instCover->lType=inst.dwType;
	instCover->lFlags=inst.dwFlags;
	
	instCover->lFFMaxForce=inst.dwFFMaxForce;
	instCover->lFFForceResolution=inst.dwFFForceResolution;
	instCover->nCollectionNumber=inst.wCollectionNumber;
	instCover->nDesignatorIndex=inst.wDesignatorIndex;
	instCover->nUsagePage=inst.wUsagePage;
	instCover->nUsage=inst.wUsage;
	instCover->lDimension=inst.dwDimension;
	instCover->nExponent=inst.wExponent;
	instCover->nReserved=inst.wReserved;
	
	return hr;
	*/
}


//  NOTE: - current working implemtation promotes
//			code bloat
//			might want to revist this and do it in a more
//			tidy fasion
//        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getProperty( 
            /* [in] */ BSTR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;		

	//DWORD g;

	if (!propertyInfo) return E_INVALIDARG;

	((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	

	if( 0==_wcsicmp(str,L"diprop_buffersize")){
			//g = (DWORD)&DIPROP_BUFFERSIZE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
			//g = (DWORD)&DIPROP_AXISMODE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){
			//g = (DWORD)&DIPROP_GRANULARITY;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
			//g = (DWORD)&DIPROP_RANGE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_RANGE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
			//g = (DWORD)&DIPROP_DEADZONE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
			//g = (DWORD)&DIPROP_FFGAIN;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
			//g = (DWORD)&DIPROP_SATURATION;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_SATURATION,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){
			//g = (DWORD)&DIPROP_FFLOAD;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
			//g = (DWORD)&DIPROP_AUTOCENTER;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
			//g = (DWORD)&DIPROP_CALIBRATIONMODE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)propertyInfo);
	}
	else { 
		return E_INVALIDARG;		
	}

	/*
	__try{
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	
		hr=m__dxj_DirectInputDevice->GetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	*/
	return hr;
}
 
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::runControlPanel( 
            /* [in] */ long hwnd)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice->RunControlPanel((HWND) hwnd,(DWORD)0); 
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice->SetCooperativeLevel((HWND) hwnd,(DWORD)flags); 
	return hr;
}
    
STDMETHODIMP C_dxj_DirectInputDeviceObject::poll()
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->Poll();	
	return hr;
}





    
STDMETHODIMP C_dxj_DirectInputDeviceObject::setCommonDataFormat( 
            /* [in] */ long format)
{
	//variant so that when structs can be packed in VARIANTS we can take care of it
	HRESULT hr;
	
	//	c_dfDIKeyboard 
	//	c_dfDIMouse 
	//	c_dfDIJoystick
	//	c_dfDIJoystick2
	nFormat=format;

	switch(format){
		case dfDIKeyboard:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIKeyboard);
			break;
		case dfDIMouse:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIMouse);
			break;
		case dfDIJoystick:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIJoystick);
			break;
		case dfDIJoystick2:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIJoystick2);
			break;
		default:
			return E_INVALIDARG;
	}

		
	return hr;
}
        		

STDMETHODIMP C_dxj_DirectInputDeviceObject::setDataFormat( 
            /* [in] */ DIDataFormat __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray)
{
	HRESULT		   hr;
	LPDIDATAFORMAT pFormat=(LPDIDATAFORMAT)format;
	LPGUID		   pGuid=NULL;
	LPGUID		   pGuidArray=NULL;
	DIObjectDataFormat	*pDiDataFormat=NULL;




	if ((!format) || (!formatArray)) return E_INVALIDARG;


	if (!ISSAFEARRAY1D(formatArray,pFormat->dwNumObjs)) return E_INVALIDARG;
	
	pFormat->dwSize=sizeof(DIDATAFORMAT);
	pFormat->rgodf=NULL;
	pFormat->rgodf=(LPDIOBJECTDATAFORMAT)DXHEAPALLOC(pFormat->dwNumObjs*sizeof(DIOBJECTDATAFORMAT));	
	if (!pFormat->rgodf) return E_OUTOFMEMORY;

	pGuidArray=(LPGUID)DXHEAPALLOC(pFormat->dwNumObjs*sizeof(GUID));
	if (!pGuidArray)
	{
		DXHEAPFREE(pFormat->rgodf);
		return E_OUTOFMEMORY;
	}			


	__try {
		for (DWORD i=0; i< pFormat->dwNumObjs;i++){
			pGuid=&(pGuidArray[i]);
			pDiDataFormat=&(((DIObjectDataFormat*)((SAFEARRAY*)*formatArray)->pvData)[i]);
			hr=DINPUTBSTRtoGUID(pGuid, pDiDataFormat->strGuid);
			if FAILED(hr) {
				DXHEAPFREE(pGuidArray);
				DXHEAPFREE(pFormat->rgodf);
				pFormat->rgodf=NULL;
			}		
			pFormat->rgodf[i].pguid=pGuid;
			pFormat->rgodf[i].dwOfs=pDiDataFormat->lOfs;
			pFormat->rgodf[i].dwType=pDiDataFormat->lType;
			pFormat->rgodf[i].dwFlags=pDiDataFormat->lFlags;
		}
		
		hr=m__dxj_DirectInputDevice->SetDataFormat(pFormat);
		

		DXHEAPFREE(pGuidArray);
		DXHEAPFREE(pFormat->rgodf);

	}
	__except(1,1){
				DXHEAPFREE(pGuidArray);
				DXHEAPFREE(pFormat->rgodf);
		return E_INVALIDARG;
	}	


	//indicate we have a custom format
	nFormat=-1;

	return hr;

}
        

STDMETHODIMP C_dxj_DirectInputDeviceObject::setEventNotification( 
            /* [in] */ long hEvent)
{

	HRESULT hr=m__dxj_DirectInputDevice->SetEventNotification((HANDLE)hEvent);	
	return hr;
}













STDMETHODIMP C_dxj_DirectInputDeviceObject::setProperty( 
            /* [in] */ BSTR __RPC_FAR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;			
	//DWORD g;
	
	if (!propertyInfo) return E_INVALIDARG;
	((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
	if( 0==_wcsicmp(str,L"diprop_buffersize")){
		//g = (DWORD)&DIPROP_BUFFERSIZE;				
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
		//g = (DWORD)&DIPROP_AXISMODE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){
		//g = (DWORD)&DIPROP_GRANULARITY;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
		//g = (DWORD)&DIPROP_RANGE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_RANGE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
		//g = (DWORD)&DIPROP_DEADZONE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
		//g = (DWORD)&DIPROP_FFGAIN;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
		//g = (DWORD)&DIPROP_SATURATION;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_SATURATION,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){
		//g = (DWORD)&DIPROP_FFLOAD;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
		//g = (DWORD)&DIPROP_AUTOCENTER;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
		//g = (DWORD)&DIPROP_CALIBRATIONMODE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)propertyInfo);		
	}
	else { 
		return E_INVALIDARG;		
	}

	/*
	__try {
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
		hr=m__dxj_DirectInputDevice->SetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except (1,1){
		return E_INVALIDARG;
	}
	*/

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::unacquire()
{
	HRESULT hr=m__dxj_DirectInputDevice->Unacquire();	
	return hr;
}
        



STDMETHODIMP C_dxj_DirectInputDeviceObject::createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEffect __RPC_FAR *effectInfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=DINPUTBSTRtoGUID(&g,effectGuid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::createCustomEffect( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g=GUID_CustomForce;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	
	DICUSTOMFORCE customData;
	customData.cChannels =(DWORD)channels;
	customData.cSamples  =(DWORD)nSamples; 
	customData.dwSamplePeriod =(DWORD)samplePeriod;
	customData.rglForceData = (long*)(*sampledata)->pvData;
	
	realEffect.lpvTypeSpecificParams=&customData;
	realEffect.cbTypeSpecificParams=sizeof(DICUSTOMFORCE);
	
	__try {
		hr=m__dxj_DirectInputDevice->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDeviceObject::sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount)
{
	DWORD dwCount=count;
	HRESULT hr;
    __try {
		hr=m__dxj_DirectInputDevice->SendDeviceData(
			sizeof(DIDEVICEOBJECTDATA),
			(DIDEVICEOBJECTDATA*)(*data)->pvData,
			&dwCount,
			(DWORD)flags);

	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}    

STDMETHODIMP C_dxj_DirectInputDeviceObject::sendForceFeedbackCommand( 
            /* [in] */ long flags) 
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->SendForceFeedbackCommand((DWORD)flags);
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state)
{
	if (!state) return E_INVALIDARG;
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->GetForceFeedbackState((DWORD*)state);
	return hr;

}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getEffectsEnum( long effType,
			I_dxj_DirectInputEnumEffects **ret)
{
	HRESULT hr=C_dxj_DirectInputEnumEffectsObject::create(m__dxj_DirectInputDevice,effType,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinputeffectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.h
//
//--------------------------------------------------------------------------

	

#include "resource.h"       // main symbols
extern void* g_dxj_DirectInputEffect;

#define typedef__dxj_DirectInputEffect LPDIRECTINPUTEFFECT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputEffectObject : 
	public I_dxj_DirectInputEffect,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEffectObject() ;
	virtual ~C_dxj_DirectInputEffectObject();

BEGIN_COM_MAP(C_dxj_DirectInputEffectObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEffect)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEffectObject)


public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE download( void) ;
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [retval][out] */ BSTR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getEffectStatus( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long iterations,
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE stop( void) ;
        
         HRESULT STDMETHODCALLTYPE unload( void) ;
        
         HRESULT STDMETHODCALLTYPE setParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectinfo, long flags) ;
        
         HRESULT STDMETHODCALLTYPE getParameters( 
            /* [out][in] */ DIEffect __RPC_FAR *effectinfo) ;
        
   
             

private:
    DECL_VARIABLE(_dxj_DirectInputEffect);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputEffect);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinputeffectobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dInputEffectObj.h"

extern HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover);
extern BSTR DINPUTGUIDtoBSTR(LPGUID g);

CONSTRUCTOR(_dxj_DirectInputEffect, {});
DESTRUCTOR(_dxj_DirectInputEffect, {});
GETSET_OBJECT(_dxj_DirectInputEffect);
                                  
   
STDMETHODIMP C_dxj_DirectInputEffectObject::download()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Download();
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectGuid(BSTR *guid)
{
	HRESULT hr;
	GUID g;
	if (!guid) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	*guid=DINPUTGUIDtoBSTR(&g);
	return hr;
}

   
STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectStatus(long *ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectStatus((DWORD*)ret);
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::start(
			/* [in] */ long iterations,
            /* [in] */ long flags) 
     
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Start((DWORD)iterations,(DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::stop()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Stop();
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::unload()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Unload();
	return hr;
}
         
STDMETHODIMP C_dxj_DirectInputEffectObject::setParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo, long flags) 
{
	DIEFFECT realEffect;
	HRESULT hr;
	GUID g;
	m__dxj_DirectInputEffect->GetEffectGuid(&g);
	
	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

    hr=m__dxj_DirectInputEffect->SetParameters(&realEffect,(DWORD) flags);
	return hr;
}

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2


STDMETHODIMP C_dxj_DirectInputEffectObject::getParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo) 
{
	
	HRESULT hr;
	GUID g;
	DIEFFECT *pRealEffect=(DIEFFECT*)effectInfo;
	DWORD dwFlags= DIEP_ALLPARAMS;
	
 
	if (!effectInfo) return E_INVALIDARG;



	ZeroMemory(pRealEffect,sizeof(DIEffect));
	if (!pRealEffect->dwFlags) pRealEffect->dwFlags = DIEFF_OBJECTOFFSETS | DIEFF_POLAR;
	pRealEffect->dwSize =sizeof(DIEFFECT);
	pRealEffect->lpEnvelope =(DIENVELOPE*)&(effectInfo->envelope);
	pRealEffect->lpEnvelope->dwSize=sizeof(DIENVELOPE);
	pRealEffect->cAxes = 2;
	pRealEffect->rglDirection =(long*)&(effectInfo->x);
	
	hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	if FAILED(hr) return hr;
			
	if (g==GUID_ConstantForce)
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->constantForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DICONSTANTFORCE);		
	}		
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->periodicForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIPERIODIC);				
	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){		
			pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			pRealEffect->lpvTypeSpecificParams =&(effectInfo->conditionX);
	}	
	else if (g==GUID_RampForce){		
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->rampForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);				
	}
	else {
		pRealEffect->lpvTypeSpecificParams =NULL;
		pRealEffect->cbTypeSpecificParams =0;
		dwFlags= dwFlags -DIEP_TYPESPECIFICPARAMS;
	}


	effectInfo->axisOffsets.x=DIJOFS_X;
	effectInfo->axisOffsets.y=DIJOFS_Y;
	pRealEffect->rgdwAxes=(DWORD*)&(effectInfo->axisOffsets);

	hr=m__dxj_DirectInputEffect->GetParameters(pRealEffect, dwFlags);

	if FAILED(hr) return hr;

	if (pRealEffect->cbTypeSpecificParams == sizeof(DICONDITION)*2)
		effectInfo->conditionFlags=DICONDITION_USE_BOTH_AXIS;
	else
		effectInfo->conditionFlags=DICONDITION_USE_DIRECTION;

	if (pRealEffect->lpEnvelope){
		effectInfo->bUseEnvelope=VARIANT_TRUE;
	}
	
	    
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dinputdeviceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
#include "direct.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectInputDevice LPDIRECTINPUTDEVICE2

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputDeviceObject : 
	public I_dxj_DirectInputDevice,	
	public CComObjectRoot
{
public:
	C_dxj_DirectInputDeviceObject() ;
	virtual ~C_dxj_DirectInputDeviceObject();

BEGIN_COM_MAP(C_dxj_DirectInputDeviceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputDevice)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputDeviceObject)


public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE acquire( void);
        
         HRESULT STDMETHODCALLTYPE getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects __RPC_FAR *__RPC_FAR *ppret);
        
         HRESULT STDMETHODCALLTYPE getCapabilities( 
            /* [out][in] */ DIDevCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getDeviceData( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getDeviceInfo( 
            /* [retval][out] */ I_dxj_DirectInputDeviceInstance __RPC_FAR *__RPC_FAR *deviceInstance);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateKeyboard( 
            /* [out][in] */ DIKeyboardState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateMouse( 
            /* [out][in] */ DIMouseState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateJoystick( 
            /* [out][in] */ DIJoyState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateJoystick2( 
            /* [out][in] */ DIJoyState2 __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getObjectInfo( 
            /* [in] */ long obj,
            /* [in] */ long how,
            /* [retval][out] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR guid,
            /* [out] */ void __RPC_FAR *propertyInfo);
        
         HRESULT STDMETHODCALLTYPE runControlPanel( 
            /* [in] */ long hwnd);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCommonDataFormat( 
            /* [in] */ long format);
        
         HRESULT STDMETHODCALLTYPE setDataFormat( 
            /* [in] */ DIDataFormat __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray);
        
         HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ long hEvent);
        
         HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR guid,
            /* [in] */ void __RPC_FAR *propertyInfo);
        
         HRESULT STDMETHODCALLTYPE unacquire( void);
        
         HRESULT STDMETHODCALLTYPE poll( void);
        
         HRESULT STDMETHODCALLTYPE createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEffect __RPC_FAR *effectinfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createCustomEffect( 
            /* [in] */ DIEffect __RPC_FAR *effectinfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount);
        
         HRESULT STDMETHODCALLTYPE sendForceFeedbackCommand( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state);
                
			
		HRESULT STDMETHODCALLTYPE getEffectsEnum( long flag,
            /* [retval][out] */ I_dxj_DirectInputEnumEffects __RPC_FAR *__RPC_FAR *ret) ;
        
private:
    DECL_VARIABLE(_dxj_DirectInputDevice);
	IDirectInputDevice2 *m__dxj_DirectInputDevice2;	
	HRESULT cleanup();
	HRESULT init();
public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput)
	DWORD	nFormat;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\directinput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.h
//
//--------------------------------------------------------------------------

// DiectInput.h : Declaration of the dInputDevice

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// Input Device Ojbect

#define typedef_dInputDevice LPDIRECTINPUTDEVICE

class CdInputDeviceObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IdInputDevice, &IID_IdInputDevice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IdInputDevice,
#endif
	public CComObjectBase<&CLSID_dInputDevice>
{
public:
	CdInputDeviceObject() ;
BEGIN_COM_MAP(CdInputDeviceObject)
	COM_INTERFACE_ENTRY(IdInputDevice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CdInputDeviceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CdInputDeviceObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// IdInputDevice
public:
	// MUST BE FIRST!!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

private:
    DECL_VARIABLE(dInputDevice);

public:
	DX3J_GLOBAL_LINKS( dInputDevice )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmbandobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmbandobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmPerformanceObj.h"
#include "dmBandObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicBand, {});
DESTRUCTOR(_dxj_DirectMusicBand, {});
GETSET_OBJECT(_dxj_DirectMusicBand);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;



HRESULT C_dxj_DirectMusicBandObject::createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{  
	HRESULT hr;			
	LPDIRECTMUSICSEGMENT pSeg=NULL;
	hr=m__dxj_DirectMusicBand->CreateSegment(&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}

	

HRESULT C_dxj_DirectMusicBandObject::download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{  
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE,pPer,performance);
	hr=m__dxj_DirectMusicBand->Download(pPer);
	return hr;
}

HRESULT C_dxj_DirectMusicBandObject::unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{  
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE,pPer,performance);
	hr=m__dxj_DirectMusicBand->Unload(pPer);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\directinput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.cpp
//
//--------------------------------------------------------------------------

// dInputDevice.cpp : Implementation of dInputDevice and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DirectInput.h"

CONSTRUCTOR(dInputDevice, {});
DESTRUCTOR(dInputDevice, {});
GETSET_OBJECT(dInputDevice);

/////////////////////////////////////////////////////////////////////////////
// Direct Input Device Object 
//

#ifdef USING_IDISPATCH
STDMETHODIMP dInputDevice::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (riid == IID_IdInputDevice)
		return S_OK;
	return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\direct.cpp ===
// Direct.cpp : Implementation of DLL Exports.

// To fully complete this project follow these steps

// You will need the new MIDL compiler to build this project.  Additionally,
// if you are building the proxy stub DLL, you will need new headers and libs.

// 1) Add a custom build step to Direct.idl
//		You can select all of the .IDL files by holding Ctrl and clicking on
//		each of them.
//
//		Description
//			Running MIDL
//		Build Command(s)
//			midl Direct.idl
//		Outputs 
//			Direct.tlb
//			Direct.h
//			Direct_i.c
//
// NOTE: You must use the MIDL compiler from NT 4.0,
// preferably 3.00.15 or greater
//
// 2) Add a custom build step to the project to register the DLL
//		For this, you can select all projects at once
//		Description
//			Registering OLE Server...
//		Build Command(s)
//			regsvr32 /s /c "$(TargetPath)"
//			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
//		Outputs
//			$(OutDir)\regsvr32.trg

// 3) To add UNICODE support, follow these steps
//		Select Build|Configurations...
//		Press Add...
//		Change the configuration name to Unicode Release
//		Change the "Copy Settings From" combo to Direct - Win32 Release
//		Press OK
//		Press Add...
//		Change the configuration name to Unicode Debug
//		Change the "Copy Settings From" combo to Direct - Win32 Debug
//		Press OK
//		Press "Close"
//		Select Build|Settings...
//		Select the two UNICODE projects and press the C++ tab.
//		Select the "General" category
//		Add _UNICODE to the Preprocessor definitions
//		Select the Unicode Debug project
//		Press the "General" tab
//		Specify DebugU for the intermediate and output directories
//		Select the Unicode Release project
//		Press the "General" tab
//		Specify ReleaseU for the intermediate and output directories

// 4) Proxy stub DLL
//		To build a separate proxy/stub DLL,
//		run nmake -f ps.mak in the project directory.

#define DIRECTSOUND_VERSION 0x600
#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Direct.h"
#include "dms.h"

#include "DxGlob7Obj.h"

#include "dSound.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "dPlay4Obj.h"
#include "dPlayLobby3Obj.h"

#include "dDraw7obj.h"
#include "ddSurface7obj.h"
#include "ddClipperObj.h"
#include "ddColorControlObj.h"
#include "ddPaletteObj.h"

#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"

#include "d3drmViewport2Obj.h"
#include "d3drmDevice3Obj.h"
#include "d3drmFrame3Obj.h"		
#include "d3drm3Obj.h"	
#include "d3drmMeshObj.h"
#include "d3drmFace2Obj.h"
#include "d3drmLightObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmWrapObj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmArrayObj.h"
#include "d3drmDeviceArrayObj.h"
#include "d3drmViewportArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmProgressiveMeshObj.h"
#include "d3drmLightArrayObj.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmPick2ArrayObj.h"
#include "d3drmFaceArrayObj.h"
#include "dInput1Obj.h"
#include "dInputDeviceObj.h"
#include "d3drmLightInterObj.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmMeshInterObj.h"
#include "d3drmTextureInterObj.h"
#include "d3drmViewportInterObj.h"
#include "d3drmFrameInterObj.h"

#define IID_DEFINED
#include "Direct_i.c"
#include "d3drmobj.h"	

// When floating-point types are used, the compiler emits a reference to
// _fltused to initialize the CRT's floating-point package.  We're not
// using any of that support and the OS is responsible for initializing
// the FPU, so we'll link to the following _fltused instead to avoid CRT
// bloat.
//
// win2k doesnt like this so its been removed
// #ifdef NDEBUG
// extern "C" int _fltused = 0;
// #endif



// ATL COM OBJECT MAP
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID__dxj_DirectX7,				 C_dxj_DirectX7Object)
END_OBJECT_MAP()

//
// thanks to precompiled headers, we never get this properly!
//
#undef DEFINE_GUID
#define __based(a)
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }



// LINK LIST OF TEXTURE CALLBACKS
// get cleaned up on DLL exit
extern "C" TextureCallback3				*TextureCallbacks3 = NULL;
extern "C" TextureCallback				*TextureCallbacks = NULL;
extern "C" FrameMoveCallback3			*FrameMoveCallbacks3 = NULL;
extern "C" DeviceUpdateCallback3		*DeviceUpdateCallbacks3 = NULL;
extern "C" DestroyCallback				*DestroyCallbacks = NULL;
extern "C" EnumerateObjectsCallback		*EnumCallbacks = NULL;
extern "C" LoadCallback					*LoadCallbacks = NULL;

// MISC GLOBALS
static const char	c_szWav[] = "WAVE";
long				g_debuglevel=0;
extern "C" int		nObjects = 0;
BOOL				is4Bit = FALSE;
int					g_creationcount=0;
CRITICAL_SECTION	g_cbCriticalSection;
OSVERSIONINFOA		sysinfo;

// HANDLES TO DX DLLS
HINSTANCE			g_hDDrawHandle=NULL;
HINSTANCE			g_hDSoundHandle=NULL;
HINSTANCE			g_hDPlay=NULL;
HINSTANCE			g_hInstD3DRMDLL=NULL;
HINSTANCE			g_hInstDINPUTDLL=NULL;
HINSTANCE			g_hInstD3DXOFDLL=NULL;
HINSTANCE			g_hInst=NULL;


//LINK LISTS OF AVAILABLE OBJECTS
void *g_dxj_Direct3dRMAnimation2		= 0;
void *g_dxj_Direct3dRMAnimationSet2		= 0;
void *g_dxj_Direct3dRMAnimationArray	= 0;
void *g_dxj_Direct3dRMObjectArray		= 0;
void *g_dxj_Direct3dRMDeviceArray		= 0;
void *g_dxj_Direct3dRMDevice3			= 0;
void *g_dxj_Direct3dRMFaceArray			= 0;
void *g_dxj_Direct3dRMFace2				= 0;
void *g_dxj_Direct3dRMFrameArray		= 0;
void *g_dxj_Direct3dRMFrame3			= 0;
void *g_dxj_Direct3dRMLightArray		= 0;
void *g_dxj_Direct3dRMLight				= 0;
void *g_dxj_Direct3dRMMaterial2			= 0;
void *g_dxj_Direct3dRMMeshBuilder3		= 0;
void *g_dxj_Direct3dRMMesh				= 0;
void *g_dxj_Direct3dRMProgressiveMesh	= 0;
void *g_dxj_Direct3dRM3					= 0;
void *g_dxj_Direct3dRMObject			= 0;
void *g_dxj_Direct3dRMPickArray			= 0;
void *g_dxj_Direct3dRMPick2Array		= 0;
void *g_dxj_Direct3dRMShadow2			= 0;
void *g_dxj_Direct3dRMTexture3			= 0;
void *g_dxj_Direct3dRMClippedVisual		= 0;
void *g_dxj_Direct3dRMViewportArray		= 0;
void *g_dxj_Direct3dRMViewport2			= 0;
void *g_dxj_Direct3dRMVisualArray		= 0;
void *g_dxj_Direct3dRMVisual			= 0;
void *g_dxj_Direct3dRMWinDevice			= 0;
void *g_dxj_Direct3dRMWrap				= 0;
void *g_dxj_Direct3dRMMeshInterpolator	= 0;
void *g_dxj_Direct3dRMLightInterpolator	= 0;
void *g_dxj_Direct3dRMFrameInterpolator	= 0;
void *g_dxj_Direct3dRMTextureInterpolator  = 0;
void *g_dxj_Direct3dRMViewportInterpolator = 0;
void *g_dxj_Direct3dRMMaterialInterpolator = 0;

void *g_dxj_DirectSound3dListener		= 0;
void *g_dxj_DirectSoundBuffer			= 0;
void *g_dxj_DirectSound3dBuffer			= 0;
void *g_dxj_DirectSound					= 0;
void *g_dxj_DirectSoundCapture			= 0;
void *g_dxj_DirectSoundCaptureBuffer	= 0;

void *g_dxj_DirectPlay4					= 0;
void *g_dxj_DirectPlayLobby3			= 0;
void *g_dxj_DPLConnection				= 0;
void *g_dxj_DPAddress					= 0;
void *g_dxj_DirectInput					= 0;
void *g_dxj_DirectInputDevice			= 0;
void *g_dxj_DirectInputEffect			= 0;

void *g_dxj_DirectDraw4					= 0;
void *g_dxj_DirectDrawSurface4			= 0;
void *g_dxj_DirectDrawClipper			= 0;
void *g_dxj_DirectDrawPalette			= 0;
void *g_dxj_DirectDrawColorControl		= 0;
void *g_dxj_DirectDrawGammaControl		= 0;
void *g_dxj_DirectDraw7					= 0;
void *g_dxj_DirectDrawSurface7			= 0;

void *g_dxj_Direct3dDevice7				= 0;
void *g_dxj_Direct3dVertexBuffer7		= 0;
void *g_dxj_Direct3d7					= 0;

void *g_dxj_DirectMusicLoader			= 0;
void *g_dxj_DirectMusicPerformance		= 0;
void *g_dxj_DirectMusicComposer			= 0;
void *g_dxj_DirectMusicStyle			= 0;
void *g_dxj_DirectMusicBand				= 0;
void *g_dxj_DirectMusicChordMap			= 0;
void *g_dxj_DirectMusicSegment			= 0;
void *g_dxj_DirectMusicSegmentState		= 0;
void *g_dxj_DirectMusicCollection		= 0;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// DLL LOADING
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HINSTANCE LoadD3DXOFDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hInstD3DXOFDLL) 
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\d3dXOF.dll" );
		g_hInstD3DXOFDLL=LoadLibrary(Path);
	}
	return g_hInstD3DXOFDLL;
}

HINSTANCE LoadDDrawDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDDrawHandle)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\ddraw.dll" );
		g_hDDrawHandle=LoadLibrary( Path );
	}
	return g_hDDrawHandle;
}

HINSTANCE LoadDSoundDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDSoundHandle) 
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dsound.dll" );
		g_hDSoundHandle=LoadLibrary( Path );
	}
	return g_hDSoundHandle;
}

HINSTANCE LoadDPlayDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDPlay)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dplayx.dll" );
		g_hDPlay=LoadLibrary( Path );
	}
	return g_hDPlay;
}

HINSTANCE LoadD3DRMDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hInstD3DRMDLL)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\d3drm.dll" );
		g_hInstD3DRMDLL=LoadLibrary( Path );
	}
	return g_hInstD3DRMDLL;
}

HINSTANCE LoadDINPUTDLL()
{
	if (!g_hInstDINPUTDLL) {
		char  Path[MAX_PATH] = {'\0'};
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dinput.dll" );
		g_hInstDINPUTDLL=LoadLibrary( Path );
	}
	return g_hInstDINPUTDLL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// DLL ENTRY POINTS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

	g_hInst=hInstance;

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		//
		// Get the current display pixel depth
		// If it is 4-bit we are in trouble.
		//
        HDC hDisplayIC;
        BOOL bPalette = FALSE;
        hDisplayIC = CreateIC("DISPLAY", NULL, NULL, NULL);
		if (hDisplayIC)
        {
			if (GetDeviceCaps(hDisplayIC, BITSPIXEL) < 8)
				is4Bit = TRUE;
			DeleteDC(hDisplayIC);
        }

		//
		// Get the platform I'm running on. Used for NT or Win32 Checks.
		//
		GetVersionEx((OSVERSIONINFOA*)&sysinfo);

		/* now delay loading dlls
		g_hDSoundHandle  = LoadDSoundDLL();
		g_hDDrawHandle  = LoadDDrawDLL();
		g_hDPlay = LoadDPlayDLL();
		g_hInstD3DRMDLL = LoadD3DRMDLL();
		g_hInstSETUPDLL=NULL;
		g_hInstDINPUTDLL=LoadDINPUTDLL();
		g_hInstD3DXOFDLL=LoadD3DXOFDLL();
		*/

		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

		
		InitializeCriticalSection(&g_cbCriticalSection);

		nObjects = 0;
		

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		UINT i;	//for easy debugging
		
		//TEAR DOWN CALLBACK LISTS
		{
		 TextureCallback3 *pNext=NULL;
		 for (TextureCallback3 *pCB=TextureCallbacks3; (pCB); pCB=pNext)
		 {
	 		if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		
		{
		 FrameMoveCallback3 *pNext=NULL;
  		 for (FrameMoveCallback3 *pCB=FrameMoveCallbacks3; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		
		{
		 DeviceUpdateCallback3 *pNext=NULL;
		 for (DeviceUpdateCallback3 *pCB=DeviceUpdateCallbacks3; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}


		{
		 TextureCallback *pNext=NULL;
		 for (TextureCallback *pCB=TextureCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}

		DPF (1,"Final Destroy Callbacks \n");
		{
 		 DestroyCallback *pNext=NULL;
		 for (DestroyCallback *pCB=DestroyCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		DPF (1,"Final Destroy Callbacks Exit \n");

		{
		 EnumerateObjectsCallback *pNext=NULL;
		 for (EnumerateObjectsCallback *pCB=EnumCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}


		{
		 LoadCallback *pNext=NULL;
		 for (LoadCallback *pCB=LoadCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}

		//Andrewke bug30341 06/12/2000
		DeleteCriticalSection(&g_cbCriticalSection);

		//DEBUG CHECK ON REF COUNT FOR PROBLEMATIC OBJECTS
		#ifdef DEBUG		
			OBJCHECK("Direct3d7				",_dxj_Direct3d7			)
			OBJCHECK("Direct3dDevice7		",_dxj_Direct3dDevice7		)
			OBJCHECK("DirectDrawSurface7	",_dxj_DirectDrawSurface7	)
			OBJCHECK("DirectDraw7			",_dxj_DirectDraw7			)			
			DPF(4,"Dx7vb.dll will about to unload dx dlls\n\r");
		#endif

		//FREE DLLS
		if ( g_hDPlay ) 
			FreeLibrary(g_hDPlay);
		if ( g_hDSoundHandle )
			FreeLibrary(g_hDSoundHandle);
		if ( g_hDDrawHandle )
			FreeLibrary(g_hDDrawHandle);
		if ( g_hInstD3DRMDLL )
			FreeLibrary(g_hInstD3DRMDLL);
		if ( g_hInstDINPUTDLL )
			FreeLibrary(g_hInstDINPUTDLL);	
		if (g_hInstD3DXOFDLL)
			FreeLibrary(g_hInstD3DXOFDLL);	
		
		_Module.Term();

	}
	return TRUE;    
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(TRUE);
	if(hRes == S_OK)
	{
		//hRes = RegSecurityClass();
	}

	//now look
	HKEY hk=0;
	char szDocPath[MAX_PATH];
	DWORD cb=MAX_PATH;
	LONG res;
	DWORD type=REG_SZ;

	ZeroMemory(szDocPath,MAX_PATH);
	
	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx",&hk);
	if ((ERROR_SUCCESS!=res)||(hk==0) )
		return hRes;

	
	
	res=RegQueryValueEx(hk,"DXSDK Doc Path",NULL,&type,(LPBYTE)szDocPath,&cb);
	RegCloseKey(hk);

	if (ERROR_SUCCESS!=res) return hRes;

	hk=0;

	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\CLASSES\\TypeLib\\{E1211242-8E94-11D1-8808-00C04FC2C602}\\1.0\\HELPDIR",&hk);
	if (ERROR_SUCCESS!=res) return hRes;

	RegSetValueEx(hk,NULL,0,REG_SZ,(LPBYTE)szDocPath,cb);
	RegCloseKey(hk);


	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry
STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	hRes = _Module.UnregisterServer();
	if(hRes == S_OK)
	{
		//hRes = UnRegSecurityClass();
	}

	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// GUID CONVERSION FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// GUIDS_EQUAL - consider moving to dms.h

#define GUIDS_EQUAL(g,g2) (\
	(g.Data1==g2->Data1) && \
	(g.Data2==g2->Data2) && \
	(g.Data3==g2->Data3) && \
	(g.Data4[0]==g2->Data4[0]) && \
	(g.Data4[1]==g2->Data4[1]) && \
	(g.Data4[2]==g2->Data4[2]) && \
	(g.Data4[3]==g2->Data4[3]) && \
	(g.Data4[4]==g2->Data4[4]) && \
	(g.Data4[5]==g2->Data4[5]) && \
	(g.Data4[6]==g2->Data4[6]) && \
	(g.Data4[7]==g2->Data4[7]) )


/////////////////////////////////////////////////////////////////////////////
// GUIDtoBSTR - does conversion

BSTR GUIDtoBSTR(LPGUID pGuid){
	char  szOut[256];	
	char  szTemp[10];
	char  *pAt=NULL;
	int	  i;
	BSTR  bstrOut;

	// 00000000001111111111222222222233333333
	// 01234567890123456789012345678901234567
	// {XXXXXXXX-XXXX-XXXX-X  XXX-XXXXXXXXXXXX}
	if (pGuid!=NULL){

		szOut[0]='{';
		
		wsprintf(&(szOut)[1],"%.8X",pGuid->Data1);
		
		szOut[9]='-';
		
		wsprintf(szTemp,"%.4X",pGuid->Data2);
		memcpy(&(szOut[10]),szTemp,4);

		szOut[14]='-';

		wsprintf(szTemp,"%.4X",pGuid->Data3);
		memcpy(&(szOut[15]),szTemp,4);

		szOut[19]='-';

		for (i=0;i<2;i++){
			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
			memcpy(&(szOut[20+i*2]),szTemp,2);
			
		}

		szOut[24]='-';

		for (i=2;i<8;i++){
			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
			memcpy(&(szOut[21+i*2]),szTemp,2);
			
		}

		szOut[37]='}';
		szOut[38]='\0';

		USES_CONVERSION;
		bstrOut = T2BSTR(szOut);

	}
	else {
		bstrOut = T2BSTR("");
	}
		

	
	return bstrOut;
}

//////////////////////////////////////////////////////////////////////////////
// convertChar
// helper for GUIDtoBSTR
HRESULT convertChar(char *szIn,int i,char *valOut){
	int val[2];	//using int for easy out of bounds check
	
	char c;
	int j;
	
	for (j=0;j<2;j++){
	   c= szIn[i+j];
	   switch (c)
	   {
		case 'a':
		case 'A':
			val[j]=10;
			break;
		case 'b':
		case 'B':
			val[j]=11;
			break;
		case 'c':
		case 'C':
			val[j]=12;
			break;
		case 'd':
		case 'D':
			val[j]=13;
			break;

		case 'e':
		case 'E':
			val[j]=14;
			break;
		case 'f':
		case 'F':
			val[j]=15;
			break;
		default:
			val[j]=c-'0';
			if (val[j]<0) return E_INVALIDARG;
			if (val[j]>15) return E_INVALIDARG;
			break;
	   }
	}


	*valOut=(char)((val[0]<<4)|val[1]);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// BSTRtoGUID - does conversion
//
HRESULT BSTRtoGUID(LPGUID pGuid, BSTR bstr){
	HRESULT hr;
	//byte
	// 
	// 
	//char
	//           1111111111222222222233333333
	// 01234567890123456789012345678901234567
	// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}	
	USES_CONVERSION;
	if(!pGuid) return E_INVALIDARG;
	ZeroMemory(pGuid,sizeof(GUID));	
	if (!bstr) return S_OK;
		
	if (bstr[0]==0x00) return S_OK;

	LPSTR szGuid = NULL;
	__try { szGuid = W2T(bstr); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	
	//first and last char should be { }
	if ((szGuid[0]!='{')||(szGuid[37]!='}'))
		return E_INVALIDARG;
	if ((szGuid[9]!='-')||(szGuid[14]!='-')||(szGuid[19]!='-')||(szGuid[24]!='-'))
		return E_INVALIDARG;
	
	char val;
	char *pData=(char*)pGuid;
	int j=0;
	int i;
	
	//FIRST DWORD
	for ( i=7;i>=1;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;				
		pData[j++]=val;
	}

	//FIRST WORD
	for ( i=12;i>=10;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	//2nd WORD
	for ( i=17;i>=15;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}


	//3rd DWORD - BYTE ARRAY
	for ( i=20;i<24;i=i+2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	//BYTE ARRAY
	for ( i=25;i<37;i=i+2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// 
//
HRESULT BSTRtoPPGUID(LPGUID *ppGuid, BSTR bstr){
	if (!ppGuid) return E_INVALIDARG;
	if ((bstr==NULL)||(bstr[0]=='\0')){
		*ppGuid=NULL;
		return S_OK;
	}
	return BSTRtoGUID(*ppGuid,bstr);

}

/////////////////////////////////////////////////////////////////////////////
// D3DBSTRtoGUID - does conversion
//
HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str){
	HRESULT hr=S_OK;

	if (!pGuid) return E_INVALIDARG;

	if (!str) {
		ZeroMemory(pGuid,sizeof(GUID));
		return S_OK;
	}
	if( 0==_wcsicmp(str,L"iid_idirect3drgbdevice")){
			memcpy(pGuid,&IID_IDirect3DRGBDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dhaldevice")){
			memcpy(pGuid,&IID_IDirect3DHALDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dmmxdevice")){
			memcpy(pGuid,&IID_IDirect3DMMXDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3drefdevice")){
			memcpy(pGuid,&IID_IDirect3DRefDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dnulldevice")){
			memcpy(pGuid,&IID_IDirect3DNullDevice,sizeof(GUID));
	}
	else {
		hr = BSTRtoGUID(pGuid,str);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// D3DGUIDtoBSTR - does conversion
//
BSTR D3DGUIDtoBSTR(LPGUID pg){

	HRESULT hr=S_OK;
	WCHAR *pStr=NULL;

	if (!pg)
		return NULL;
	else if (GUIDS_EQUAL(IID_IDirect3DNullDevice,pg)){
		pStr=L"IID_IDirect3DNullDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DRefDevice,pg)){
		pStr=L"IID_IDirect3DRefDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DMMXDevice,pg)){
		pStr=L"IID_IDirect3DMMXDevice";
	}
	
	else if (GUIDS_EQUAL(IID_IDirect3DHALDevice,pg)){
		pStr=L"IID_IDirect3DHALDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DRGBDevice,pg)){
		pStr=L"IID_IDirect3DRGBDevice";
	}

	if (pStr){
		return DXALLOCBSTR(pStr);
	}
	else {
		return GUIDtoBSTR(pg);
	}

}



/////////////////////////////////////////////////////////////////////////////
// DINPUTGUIDtoBSTR
//
BSTR DINPUTGUIDtoBSTR(LPGUID pg){

	HRESULT hr=S_OK;
	WCHAR *pStr=NULL;

	if (!pg)
		return NULL;
	else if (GUIDS_EQUAL(GUID_XAxis,pg)){
		pStr=L"GUID_XAxis";
	}
	else if (GUIDS_EQUAL(GUID_YAxis,pg)){
		pStr=L"GUID_YAxis";
	}
	else if (GUIDS_EQUAL(GUID_ZAxis,pg)){
		pStr=L"GUID_ZAxis";
	}
	
	else if (GUIDS_EQUAL(GUID_RxAxis,pg)){
		pStr=L"GUID_RxAxis";
	}
	else if (GUIDS_EQUAL(GUID_RyAxis,pg)){
		pStr=L"GUID_RyAxis";
	}
	else if (GUIDS_EQUAL(GUID_RzAxis,pg)){
		pStr=L"GUID_RzAxis";
	}

	else if (GUIDS_EQUAL(GUID_Slider,pg)){
		pStr=L"GUID_Slider";
	}
	else if (GUIDS_EQUAL(GUID_Button,pg)){
		pStr=L"GUID_Button";
	}
	else if (GUIDS_EQUAL(GUID_Key,pg)){
		pStr=L"GUID_Key";
	}
	else if (GUIDS_EQUAL(GUID_POV,pg)){
		pStr=L"GUID_POV";
	}
	else if (GUIDS_EQUAL(GUID_Unknown,pg)){
		pStr=L"GUID_Unknown";
	}
	else if (GUIDS_EQUAL(GUID_SysMouse,pg)){
		pStr=L"GUID_SysMouse";
	}
	else if (GUIDS_EQUAL(GUID_SysKeyboard,pg)){
		pStr=L"GUID_SysKeyboard";
	}


	else if (GUIDS_EQUAL(GUID_ConstantForce,pg)){
		pStr=L"GUID_ConstantForce";
	}
	else if (GUIDS_EQUAL(GUID_Square,pg)){
		pStr=L"GUID_Square";
	}
	else if (GUIDS_EQUAL(GUID_Sine,pg)){
		pStr=L"GUID_Sine";
	}
	else if (GUIDS_EQUAL(GUID_Triangle,pg)){
		pStr=L"GUID_Triangle";
	}
	else if (GUIDS_EQUAL(GUID_SawtoothUp,pg)){
		pStr=L"GUID_SawtoothUp";
	}
	else if (GUIDS_EQUAL(GUID_SawtoothDown,pg)){
		pStr=L"GUID_SawtoothDown";
	}
	else if (GUIDS_EQUAL(GUID_Spring,pg)){
		pStr=L"GUID_Spring";
	}
	else if (GUIDS_EQUAL(GUID_Damper,pg)){
		pStr=L"GUID_Damper";
	}
	else if (GUIDS_EQUAL(GUID_Inertia,pg)){
		pStr=L"GUID_Inertia";
	}
	else if (GUIDS_EQUAL(GUID_Friction,pg)){
		pStr=L"GUID_Friction";
	}
	else if (GUIDS_EQUAL(GUID_CustomForce,pg)){
		pStr=L"GUID_CustomForce";
	}
	else if (GUIDS_EQUAL(GUID_RampForce,pg)){
		pStr=L"GUID_RampForce";
	}




	//else if (GUIDS_EQUAL(GUID_Joystick,pg)){
	//	pStr=L"GUID_JoyStick";
	//}

	if (pStr){
		return DXALLOCBSTR(pStr);
	}
	else {
		return GUIDtoBSTR(pg);
	}

}


/////////////////////////////////////////////////////////////////////////////
// DINPUTBSTRtoGUID
//
HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str){
	HRESULT hr=S_OK;

	if (!pGuid) return E_INVALIDARG;

	if (!str) {
		ZeroMemory(pGuid,sizeof(GUID));
		return S_OK;
	}
	if( 0==_wcsicmp(str,L"guid_xaxis")){
			memcpy(pGuid,&GUID_XAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_yaxis")){
			memcpy(pGuid,&GUID_YAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_zaxis")){
			memcpy(pGuid,&GUID_ZAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_rxaxis")){
			memcpy(pGuid,&GUID_RxAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_ryaxis")){
			memcpy(pGuid,&GUID_RyAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_rzaxis")){
			memcpy(pGuid,&GUID_RzAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_slider")){
			memcpy(pGuid,&GUID_Slider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_button")){
			memcpy(pGuid,&GUID_Button,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_key")){
			memcpy(pGuid,&GUID_Key,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_pov")){
			memcpy(pGuid,&GUID_POV,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_unknown")){
			memcpy(pGuid,&GUID_Unknown,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_sysmouse")){
			memcpy(pGuid,&GUID_SysMouse,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_syskeyboard")){
			memcpy(pGuid,&GUID_SysKeyboard,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_constantforce")){
			memcpy(pGuid,&GUID_ConstantForce,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_square")){
			memcpy(pGuid,&GUID_Square,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sine")){
			memcpy(pGuid,&GUID_Sine,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_triangle")){
			memcpy(pGuid,&GUID_Triangle,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sawtoothup")){
			memcpy(pGuid,&GUID_SawtoothUp,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sawtoothdown")){
			memcpy(pGuid,&GUID_SawtoothDown,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_spring")){
			memcpy(pGuid,&GUID_Spring,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_damper")){
			memcpy(pGuid,&GUID_Damper,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_inertia")){
			memcpy(pGuid,&GUID_Inertia,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_friction")){
			memcpy(pGuid,&GUID_Friction,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_customforce")){
			memcpy(pGuid,&GUID_CustomForce,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_rampforce")){
			memcpy(pGuid,&GUID_RampForce,sizeof(GUID));
	}

	//else if( 0==_wcsicmp(str,L"guid_joystick")){
	//		memcpy(pGuid,&GUID_Joystick,sizeof(GUID));
	//}
	else {
		hr = BSTRtoGUID(pGuid,str);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// GENERAL HELPER FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CreateCoverObject
//
// NOTE this function call INTERNAL_CREATE_NOADDREF alot
// the only difference from INTERNAL_CREATE is that these objects will not
// have a reference to the object that created them if they are not
// available to the user in an existing user variable.. (not in the ll allready)
//
// The parent pointer is a vestige of DX5 support where we had to 
// manage the order of release calls. But that only happens for ddraw api

HRESULT CreateCoverObject(LPDIRECT3DRMOBJECT lpo, I_dxj_Direct3dRMObject **coverObj)
{	
	IUnknown *realThing=NULL;
	IUnknown *coverThing=NULL;
	IDirect3DRMInterpolator *pInter=NULL;

    //See if we where passed an interpolator
    if (S_OK==lpo->QueryInterface(IID_IDirect3DRMInterpolator,(void**)&pInter)){
		
        // Figure out what kind
		if (S_OK==pInter->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrameInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);		
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMViewport2,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMViewportInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTextureInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMaterialInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMLight,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMLightInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else {			            
            // release reference from original Interpolator QI and exit
            DPF(1,"CreateCoverObject unable to find interpolator\r\n");
			pInter->Release();
			return E_FAIL;
		}

        //dont need pinter anymore
        pInter->Release();

	}
    else {
        // Not an interpolator.. See what else it could be.
	    if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshBuilder3,(IDirect3DRMMeshBuilder3*)realThing,&coverThing);		
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMAnimation2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMAnimation2,(IDirect3DRMAnimation2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMAnimationSet2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMAnimationSet2,(IDirect3DRMAnimationSet2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMFace2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFace2,(IDirect3DRMFace2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMDevice3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMDevice3,(IDirect3DRMDevice3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMLight,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMLight,(IDirect3DRMLight*)realThing,&coverThing);
	    }
    
        // no longer support USERVISUALS
	    // else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMUserVisual,(void**)&realThing)){
	    //	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMUserVisual,(IDirect3DRMUserVisual*)realThing,&coverThing);
	    // }
	    else {		
		    DPF(4,"CreateCoverObject didnt recognize guid");
		    return E_FAIL;
	    }
    }

    if (!coverThing) return E_OUTOFMEMORY;

     // All objects should support RMObject so get that interface	
    if (FAILED(coverThing->QueryInterface(IID_I_dxj_Direct3dRMObject, (void **)coverObj))) {
		coverThing->Release();
		return E_NOINTERFACE; 	
    }
    // Pass back cover object to user - has inc ref count from QI
	coverThing->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//  CreateCoverVisual
//
//  Similar to CreateCoverObject
//
HRESULT CreateCoverVisual(LPDIRECT3DRMOBJECT lpo, I_dxj_Direct3dRMVisual **ppret)
{
	IUnknown *realThing=NULL;
	IUnknown *coverThing=NULL;
	I_dxj_Direct3dRMVisual *pObj=NULL;
	
	*ppret=NULL;

	//What kind of visual are we
	if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing))  {		
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshBuilder3,(IDirect3DRMMeshBuilder3*)realThing,&coverThing);
	}
	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realThing,&coverThing);
	}
	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMesh,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMesh,(IDirect3DRMMesh*)realThing,&coverThing);
	}
   	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMProgressiveMesh,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMProgressiveMesh,(IDirect3DRMProgressiveMesh*)realThing,&coverThing);
	}
	else {		
		DPF(4," didnt recognize Visual in CreateCoverVisual");		
		return E_FAIL;
	}
	
    //release first QI
	if (realThing) realThing->Release();
	
    //make sure we have a coverThing.
	if (!coverThing) return E_FAIL;

    //QI for Visual Base Interface
	if (FAILED(coverThing->QueryInterface(IID_I_dxj_Direct3dRMVisual, (void **)ppret))){
		DPF(4,"CreateCoverVisual QI for object failed");
        coverThing->Release ();		
		return E_FAIL; 
	}
    
    //release 2nd QI
	coverThing->Release(); 
	
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// _GetName     helper function for RM object base class
//
extern "C" HRESULT _GetName(IDirect3DRMObject *iface, BSTR *Name, BOOL bNameNotClassName)
{
	DWORD cnt = 0;
	LPSTR str ;		// ANSI buffer on stack;

	if( bNameNotClassName )
	{
		if((iface->GetName(&cnt,(char*)NULL)) != D3DRM_OK) // size
			return E_FAIL;

		__try { str = (LPSTR)alloca(cnt); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

		if((iface->GetName(&cnt, str)) != D3DRM_OK)
			return E_FAIL;
	}
	else
	{
		if((iface->GetClassName(&cnt,(char*)NULL)) != D3DRM_OK) // size
			return E_FAIL;

		__try { str = (LPSTR)alloca(cnt); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

		if((iface->GetClassName(&cnt, str)) != D3DRM_OK)
			return E_FAIL;
	}

	PassBackUnicode(str, Name, cnt);
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Given an ANSI string, pass back a UNICODE string
// SysAllocString is your big friend here.
//
// CONSIDER finding all occerence of use and replacint with the
// T2BSTR macro .. much cleaner
//
extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt)
{
	//NOTE: length header is required to be filled, but the BSTR pointer
	//        points to the first character, not the length.
	// note, the count can never be too small as we get that from the string
	// before we pass it in!
	USES_CONVERSION;
	LPWSTR lpw = (LPWSTR)malloc((cnt+1)*2);

	if (!lpw) return;	//fix for bug45158 -no way of producing error code. (hmm)

	void *l = (void *)lpw;
	lpw = AtlA2WHelper(lpw, str, cnt);
	lpw[cnt] = 0;
	*Name = SysAllocString(lpw);
	free(l);
}

/////////////////////////////////////////////////////////////////////////////
// CopyOutDDSurfaceDesc2    real->cover
//
HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d){
	ZeroMemory(dOut, sizeof(DDSurfaceDesc2));
	memcpy (dOut,d,sizeof(DDSURFACEDESC2));	
	dOut->lMipMapCount=d->dwMipMapCount;
	dOut->lRefreshRate=d->dwRefreshRate;
	// Get Caps
	dOut->ddsCaps.lCaps = d->ddsCaps.dwCaps; 
	dOut->ddsCaps.lCaps2 = d->ddsCaps.dwCaps2; 
	dOut->ddsCaps.lCaps3 = d->ddsCaps.dwCaps3; 
	dOut->ddsCaps.lCaps4 = d->ddsCaps.dwCaps4; 
	CopyOutDDPixelFormat(&(dOut->ddpfPixelFormat) ,&(d->ddpfPixelFormat));
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyInDDSurfaceDesc2    cover->real
//
HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d){
	if(!d) return E_POINTER;															
	else if(!dOut) return E_POINTER;
	else if ( DDSD_MIPMAPCOUNT & d->lFlags ) d->lZBufferBitDepth = d->lMipMapCount;				
	else if ( DDSD_REFRESHRATE & d->lFlags ) d->lZBufferBitDepth = d->lRefreshRate;								
	memcpy (dOut,d,sizeof(DDSURFACEDESC2));

	CopyInDDPixelFormat(&(dOut->ddpfPixelFormat) ,&(d->ddpfPixelFormat));


	memcpy (&dOut->ddsCaps,&d->ddsCaps,sizeof(DDSCAPS2));
	dOut->dwSize=sizeof(DDSURFACEDESC2);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyInDDPixelFormat    cover->real
//
// note param ordering differnt that DDSURFACEDESC helpers
//
HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *pfOut, DDPixelFormat *pf)
{

	if (!pf) return E_POINTER;
	if (!pfOut) return E_POINTER;
	if ((pf->lFlags & DDPF_RGB)||(pf->lFlags &DDPF_RGBTOYUV)) {
		pf->internalVal1=pf->lRGBBitCount;
		pf->internalVal2=pf->lRBitMask;
		pf->internalVal3=pf->lGBitMask;
		pf->internalVal4=pf->lBBitMask;		
		if (pf->lFlags & DDPF_ALPHAPIXELS ){
			pf->internalVal5=pf->lRGBAlphaBitMask;
		}
		else if (pf->lFlags & DDPF_ZPIXELS ){
			pf->internalVal5=pf->lRGBZBitMask;
		}

	}
	else if (pf->lFlags & DDPF_YUV){
		pf->internalVal1=pf->lYUVBitCount;
		pf->internalVal2=pf->lYBitMask;
		pf->internalVal3=pf->lUBitMask;
		pf->internalVal4=pf->lVBitMask;
		if (pf->lFlags & DDPF_ALPHAPIXELS ){
			pf->internalVal5=pf->lYUVAlphaBitMask;
		}
		else if (pf->lFlags & DDPF_ZPIXELS ){
			pf->internalVal5=pf->lYUVZBitMask;
		}
	}
	
	else if (pf->lFlags & DDPF_BUMPDUDV) {
		pf->internalVal1=pf->lBumpBitCount;
		pf->internalVal2=pf->lBumpDuBitMask;
		pf->internalVal3=pf->lBumpDvBitMask;
		pf->internalVal4=pf->lBumpLuminanceBitMask;
	}

	//rest of internalVal1
	if (pf->lFlags & DDPF_ZBUFFER){
		pf->internalVal1=pf->lZBufferBitDepth;
	}
	else if (pf->lFlags & DDPF_ALPHA){
		pf->internalVal1=pf->lAlphaBitDepth;
	}
	else if (pf->lFlags & DDPF_LUMINANCE){
		pf->internalVal1=pf->lLuminanceBitCount;
	}

	//rest of internalVal2
	if (pf->lFlags & DDPF_STENCILBUFFER) {
		pf->internalVal2=pf->lStencilBitDepth;
	}
	else if ((pf ->lFlags & DDPF_LUMINANCE) || ( pf->lFlags & DDPF_BUMPLUMINANCE)){
		pf->internalVal2=pf->lLuminanceBitMask;
	}
	

	// internalVal3
	if ((pf->lFlags & DDPF_ZBUFFER)){
		pf->internalVal3=pf->lZBitMask;
	}

	// internalVal4
	if (pf->lFlags & DDPF_STENCILBUFFER){
		pf->internalVal4=pf->lStencilBitMask;
	}

	// internalVal5
	if (pf->lFlags & DDPF_LUMINANCE) {
		pf->internalVal5=pf->lLuminanceAlphaBitMask;
	}
	

	/*  map to indicate what is valid and when..

		long lRGBBitCount;			//DDPF_RGB 
		long lYUVBitCount;			//DDPF_YUV 
		long lZBufferBitDepth;		//DDPF_ZBUFFER 
		long lAlphaBitDepth;		//DDPF_ALPHA 
		long lLuminanceBitCount;	//DDPF_LUMINANCE 
		long lBumpBitCount;			//DDPF_BUMPDUDV 

		// union for internalVal2
		long lRBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lYBitMask;				//DDPF_YUV 
		long lStencilBitMask;		//DDPF_STENCILBUFFER 
		long lLuminanceBitMask;		//DDPF_BUMPLUMINANCE or DDPF_LUMINANCE 
		long lBumpDiBitMask;		//DDPF_BUMPDUDV 

		// union for internalVal3
		long lGBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lUBitMask;				//DPDF_YUV
		long lZBitMask;				//DDPF_STENCILBUFFER ?
		long lBumpDvBitMask;		//DDPF_BUMPDUDV 

		// union for internalVal4
		long lBBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lVBitMask;				//DDPF_YUV 
		long lStencilBitMask;		//DDPF_STENCILBUFFER 
		long lBumpLuminanceBitMask;	//DDPF_BUMPDUDV 


		// union for internalVal5
		long lRGBAlphaBitMask;		//DDPF_RGB and DDPF_ALPHAPIXELS 
        long lYUVAlphaBitMask;		//DDPF_YUV & DDPF_ALPHAPIXELS 
        long lLuminanceAlphaBitMask; //DDPF_LUMINANCE
        long lRGBZBitMask;			//DDPF_ZPIXELS & DDPF_RGB
		long lYUVZBitMask;			//DDPF_ZPIXELS & DDPF_YUV
	*/

	memcpy(pfOut,pf,sizeof(DDPIXELFORMAT));
	pfOut->dwSize=sizeof(DDPIXELFORMAT);

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CopyOutDDPixelFormat    real->cover
//
// note param ordering differnt that DDSURFACEDESC helpers
//
HRESULT CopyOutDDPixelFormat(DDPixelFormat *pfOut, DDPIXELFORMAT *pf)
{
	if (!pf) return E_POINTER;
	if (!pfOut) return E_POINTER;
	
	pfOut->lSize=pf->dwSize;	
	pfOut->lFlags=pf->dwFlags;
	pfOut->lFourCC=pf->dwFourCC ;	
	pfOut->lRGBBitCount=pf->dwRGBBitCount;			//DDPF_RGB 
	pfOut->lRGBBitCount=pf->dwRGBBitCount;			//DDPF_YUV 
	pfOut->lZBufferBitDepth=pf->dwZBufferBitDepth;		//DDPF_ZBUFFER 
	pfOut->lAlphaBitDepth=pf->dwAlphaBitDepth;		//DDPF_ALPHA 
	pfOut->lLuminanceBitCount=pf->dwLuminanceBitCount;	//DDPF_LUMINANCE 
	pfOut->lBumpBitCount=pf->dwBumpBitCount;			//DDPF_BUMPDUDV 

	// union for internalVal2
	pfOut->lRBitMask=pf->dwRBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lYBitMask=pf->dwYBitMask;				//DDPF_YUV 
	pfOut->lStencilBitDepth=pf->dwStencilBitDepth;		//DDPF_STENCILBUFFER 
	pfOut->lLuminanceBitMask=pf->dwLuminanceBitMask;		//DDPF_BUMPLUMINANCE or DDPF_LUMINANCE 
	pfOut->lBumpDuBitMask=pf->dwBumpDuBitMask;		//DDPF_BUMPDUDV 

	// union for internalVal3
	pfOut->lGBitMask=pf->dwGBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lUBitMask=pf->dwUBitMask;				//DPDF_YUV
	pfOut->lZBitMask=pf->dwZBitMask;				//DDPF_STENCILBUFFER ?
	pfOut->lBumpDvBitMask=pf->dwBumpDvBitMask;		//DDPF_BUMPDUDV 

	// union for internalVal4
	pfOut->lBBitMask=pf->dwBBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lVBitMask=pf->dwVBitMask;				//DDPF_YUV 
	pfOut->lStencilBitMask=pf->dwStencilBitMask;		//DDPF_STENCILBUFFER 
	pfOut->lBumpLuminanceBitMask=pf->dwBumpLuminanceBitMask;	//DDPF_BUMPDUDV 
	


	// union for internalVal5
	pfOut->lRGBAlphaBitMask=pf->dwRGBAlphaBitMask;		//DDPF_RGB and DDPF_ALPHAPIXELS 
    pfOut->lYUVAlphaBitMask=pf->dwYUVAlphaBitMask;		//DDPF_YUV & DDPF_ALPHAPIXELS 
    pfOut->lLuminanceAlphaBitMask=pf->dwLuminanceAlphaBitMask; //DDPF_LUMINANCE
    pfOut->lRGBZBitMask=pf->dwRGBZBitMask;			//DDPF_ZPIXELS & DDPF_RGB
	pfOut->lYUVZBitMask=pf->dwYUVZBitMask;			//DDPF_ZPIXELS & DDPF_YUV
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyOutDDPixelFormat    cover->real
//
//
HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc){

	long l=0;
	HRESULT hr;

	memset(dpSessionDesc,0,sizeof(DPSESSIONDESC2));
	dpSessionDesc->dwSize			= sizeof(DPSESSIONDESC2);
	dpSessionDesc->dwFlags			= sessionDesc->lFlags;

	hr=BSTRtoGUID(&(dpSessionDesc->guidInstance),sessionDesc->strGuidInstance);
	if FAILED(hr) return hr;
	hr=BSTRtoGUID(&(dpSessionDesc->guidApplication),sessionDesc->strGuidApplication);
	if FAILED(hr) return hr;
	
	dpSessionDesc->dwMaxPlayers		= sessionDesc->lMaxPlayers;
	dpSessionDesc->dwCurrentPlayers	= sessionDesc->lCurrentPlayers;

	//using wide strings

	dpSessionDesc->lpszSessionName=NULL;
	if ((sessionDesc->strSessionName)&& (sessionDesc->strSessionName[0]!='\0')){
		dpSessionDesc->lpszSessionName=SysAllocString(sessionDesc->strSessionName);
	}
	
	dpSessionDesc->lpszPassword=NULL;
	if ((sessionDesc->strPassword)&& (sessionDesc->strPassword[0]!='\0')){
		dpSessionDesc->lpszPassword=SysAllocString(sessionDesc->strPassword);
	}
	
	
	dpSessionDesc->dwReserved1		= 0;
	dpSessionDesc->dwReserved2		= 0;
	dpSessionDesc->dwUser1			= sessionDesc->lUser1;
	dpSessionDesc->dwUser2			= sessionDesc->lUser2;
	dpSessionDesc->dwUser3			= sessionDesc->lUser3;
	dpSessionDesc->dwUser4			= sessionDesc->lUser4;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// FillCoverSessionDesc    real->cover
//
//
void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc)
{
	sessionDesc->lFlags = dpSessionDesc->dwFlags;
	sessionDesc->lMaxPlayers = dpSessionDesc->dwMaxPlayers;
	sessionDesc->lCurrentPlayers = dpSessionDesc->dwCurrentPlayers;
	sessionDesc->lUser1 = (long)dpSessionDesc->dwUser1;
	sessionDesc->lUser2 = (long)dpSessionDesc->dwUser2;
	sessionDesc->lUser3 = (long)dpSessionDesc->dwUser3;
	sessionDesc->lUser4 = (long)dpSessionDesc->dwUser4;	

	// NOTE: if sessiondesc came in as [out] param then 
	// strGuidInstance -strPassword etc. would all be NULL
	// if it pas passed as in out we need to free the existing contents
	// before moving. Consulted with Matt curland to verify if ok. 

	if (sessionDesc->strGuidInstance) SysFreeString((BSTR)sessionDesc->strGuidInstance);
	if (sessionDesc->strGuidApplication) SysFreeString((BSTR)sessionDesc->strGuidApplication);
	if (sessionDesc->strSessionName) SysFreeString((BSTR)sessionDesc->strSessionName);
	if (sessionDesc->strPassword) SysFreeString((BSTR)sessionDesc->strPassword);

	sessionDesc->strGuidInstance=GUIDtoBSTR(&(dpSessionDesc->guidInstance));
	sessionDesc->strGuidApplication=GUIDtoBSTR(&(dpSessionDesc->guidApplication));	
	sessionDesc->strSessionName = SysAllocString(dpSessionDesc->lpszSessionName);
	sessionDesc->strPassword = SysAllocString(dpSessionDesc->lpszPassword);
}

/////////////////////////////////////////////////////////////////////////////
// IsAllZeros
//
BOOL IsAllZeros(void *pStruct,DWORD size){
	for (DWORD i=0;i<size;i++){
		if (((char*)pStruct)[i]!='\0'){
			return FALSE;
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CopyFloats
//
extern "C" void CopyFloats(D3DVALUE *dst, D3DVALUE *src, DWORD count)
{
	D3DVALUE *ptr1 = dst, *ptr2 = src;

	if (!count)		return;

	for (; count; count--)  *ptr1++ = *ptr2++;
	return;
}

/////////////////////////////////////////////////////////////////////////////
// IsWin95
//
// no longer needed since we support w95 now
#if 0
BOOL IsWin95(void)
{
	return FALSE;
    


	//We work on win95
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        DPF(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            DPF(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            DPF(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        DPF(2,"Detected WinNT");
        return FALSE;
    }
    DPF(2,"OS Detection failed");
    return TRUE;

}
#endif

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2

/////////////////////////////////////////////////////////////////////////////
// FixUpRealEffect  cover->real
//
HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover)
{
	if (!cover) return E_INVALIDARG;

	
	memcpy(realEffect,cover,sizeof(DIEFFECT));

	realEffect->dwSize =sizeof(DIEFFECT);	
	realEffect->lpEnvelope =NULL;
	realEffect->cbTypeSpecificParams =0;
	realEffect->lpvTypeSpecificParams =NULL;
	realEffect->cAxes =2;
	realEffect->dwFlags=realEffect->dwFlags | DIEFF_OBJECTOFFSETS ;
	realEffect->rglDirection =(long*)&(cover->x);
	realEffect->rgdwAxes =(DWORD*)&(cover->axisOffsets);	
	
	
	if (cover->bUseEnvelope){
		realEffect->lpEnvelope=(DIENVELOPE*)&(cover->envelope);
		
		((DIENVELOPE*)&(cover->envelope))->dwSize=sizeof(DIENVELOPE);
	}
	
	if (!cover->lFlags)
		realEffect->dwFlags= DIEFF_POLAR | DIEFF_OBJECTOFFSETS ;
	
	//constant
	if (g==GUID_ConstantForce)
	{
		realEffect->cbTypeSpecificParams =sizeof (DICONSTANTFORCE);
		realEffect->lpvTypeSpecificParams =&(cover->constantForce);
	}
	
	//periodic
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{

		realEffect->cbTypeSpecificParams =sizeof (DIPERIODIC);
		realEffect->lpvTypeSpecificParams =&(cover->periodicForce);

	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){

		if (cover->conditionFlags==DICONDITION_USE_BOTH_AXIS){
			realEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			realEffect->lpvTypeSpecificParams =&(cover->conditionX);			
		}
		else{
			realEffect->cbTypeSpecificParams =sizeof(DICONDITION);
			realEffect->lpvTypeSpecificParams =&(cover->conditionX);
		}

	}
	else if (g==GUID_RampForce){
		realEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);
		realEffect->lpvTypeSpecificParams =&(cover->rampForce);
	}

	cover->axisOffsets.x=DIJOFS_X;
	cover->axisOffsets.y=DIJOFS_Y;
	realEffect->rgdwAxes=(DWORD*)&(cover->axisOffsets);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// FixUpCoverEffect  real->cover
//
HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect)
{
	

	ZeroMemory(cover,sizeof(DIEffect));
	memcpy(cover,realEffect,sizeof(DIEFFECT));
	
	
	if (realEffect->lpEnvelope){
		memcpy(&cover->envelope,realEffect->lpEnvelope ,sizeof(DIENVELOPE));
		cover->bUseEnvelope=VARIANT_TRUE;
	}

	if (realEffect->rglDirection){
		cover->x=realEffect->rglDirection[0];
		cover->y=realEffect->rglDirection[1];
	}	
	

	
	if (realEffect->lpvTypeSpecificParams){
		
		if (g==GUID_ConstantForce)
		{
			memcpy(&(cover->constantForce),realEffect->lpvTypeSpecificParams,sizeof(DICONSTANTFORCE));
		}		
		//periodic
		else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
		{
			memcpy(&(cover->periodicForce),realEffect->lpvTypeSpecificParams,sizeof(DIPERIODIC));
		}
	
		else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
			
			if (realEffect->cbTypeSpecificParams ==sizeof(DICONDITION)*2){
				memcpy(&(cover->conditionY),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION)*2);
				cover->conditionFlags=DICONDITION_USE_BOTH_AXIS;
			}
			else{
				memcpy(&(cover->conditionX),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION));
				cover->conditionFlags=DICONDITION_USE_DIRECTION;
			}

		}
		
		else if (g==GUID_RampForce){
			memcpy(&(cover->rampForce),realEffect->lpvTypeSpecificParams,sizeof(DIRAMPFORCE));			
		}

	}


	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CALLBACK FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// myLoadTextureCallback - rm texture callback
// only userd by pmesh...
//
extern "C" HRESULT __cdecl myLoadTextureCallback(char *tex_name, void *lpArg,
										 LPDIRECT3DRMTEXTURE * lpD3DRMTex)
{	
	// user arg will contain our own struct
	struct TextureCallback3 *tcb = (struct TextureCallback3 *)lpArg;
	I_dxj_Direct3dRMTexture3 *iunk = NULL;
    LPDIRECT3DRMTEXTURE       lpTex= NULL;

	int i=0;
	
	// convert to Unicode
	USES_CONVERSION;;
	BSTR tex=T2BSTR(tex_name);

	// user arg is an object -- hang on to it during our callback as a precaution
	if (tcb->pUser) tcb->pUser->AddRef();

	// call the VB callback..
	tcb->c->callbackRMLoadTexture(tex,tcb->pUser , &iunk);

	// give up the extra reference
	if (tcb->pUser) tcb->pUser->Release();


	// free the string allocated by T2BSTR
	SysFreeString((BSTR)tex);

	// given  the user returned something in iunk..
	if ( iunk != NULL )
	{				
		// get the real object iunk covers 
		// note DO_GETOBJECT_NOTNULL does not addref and assumes 
		// the cover object allready has a reference.
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lp,iunk)		

        lp->QueryInterface(IID_IDirect3DRMTexture,(void**)&lpTex);

        // give it up to rm
		*lpD3DRMTex = lpTex;

		// we addref the real rm texture (as we are in a callback and
		// need to return an object to rm that it will later release)
		(*lpD3DRMTex)->AddRef();

        
		// release our reference to the cover object vb gave us
		iunk->Release();

    } 
	else
	{
		//otherwise return null to RM
		*lpD3DRMTex = NULL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// myLoadTextureCallback3 - rm texture callback

extern "C" HRESULT __cdecl myLoadTextureCallback3(char *tex_name, void *lpArg,
										 LPDIRECT3DRMTEXTURE3 * lpD3DRMTex)
{	
	// user arg will contain our own struct
	struct TextureCallback3 *tcb = (struct TextureCallback3 *)lpArg;
	I_dxj_Direct3dRMTexture3 *iunk = NULL;
	int i=0;
	
	// convert to Unicode
	USES_CONVERSION;;
	BSTR tex=T2BSTR(tex_name);

	// user arg is an object -- hang on to it during our callback as a precaution
	if (tcb->pUser) tcb->pUser->AddRef();

	// call the VB callback..
	tcb->c->callbackRMLoadTexture(tex,tcb->pUser , &iunk);

	// give up the extra reference
	if (tcb->pUser) tcb->pUser->Release();


	// free the string allocated by T2BSTR
	SysFreeString((BSTR)tex);

	// given  the user returned something in iunk..
	if ( iunk != NULL )
	{				
		// get the real object iunk covers 
		// note DO_GETOBJECT_NOTNULL does not addref and assumes 
		// the cover object allready has a reference.
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lp,iunk)		

   		// give it up to rm
		*lpD3DRMTex = lp;

		// we addref the real rm texture (as we are in a callback and
		// need to return an object to rm that it will later release)
		(*lpD3DRMTex)->AddRef();


		// release our reference to the cover object vb gave us
		iunk->Release();

    } 
	else
	{
		//otherwise return null to RM
		*lpD3DRMTex = NULL;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// myFrameMoveCallback - rm frame move callback
//
// we use a helper so we can call into INTERNAL_CREATE ..
//
HRESULT myFrameMoveCallbackHelper(LPDIRECT3DRMFRAME lpf1, void *lpArg, D3DVALUE delta)
{ 
                                  	// get our structure from the user args..
	FrameMoveCallback3		*fmcb = (FrameMoveCallback3 *)lpArg;	
	LPDIRECT3DRMFRAME3		lpf=NULL;
	I_dxj_Direct3dRMFrame3		*frame3=NULL;
	HRESULT				hr;

	// if RM gave is a frame (which it always will) then get the 
	// Frame3 interface as the VB api only has 1 frame type
	if (lpf1){
		hr=lpf1->QueryInterface(IID_IDirect3DRMFrame3,(void**)&lpf);
		if FAILED(hr) return hr;
	}

	// Try and find the object in our link list of cover objects
	// if its not there then create one.
	//
	// note: will eat the reference to lpf so dont release
	// bug gives us a frame3 with incrermented ref count
	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrame3,lpf,&frame3);

	// if Out of memory try and exit gracefully
	if (!frame3)   return E_FAIL;


	// make sure we have a reference to any user arg object
	if (fmcb->pUser) fmcb->pUser->AddRef();

	// make sure our vb callback doesnt go away
	fmcb->c->AddRef ();

	// call into VB
	fmcb->c->callbackRMFrameMove(frame3, fmcb->pUser, delta);
	
	// clean up our reference to the vb callback
	fmcb->c->Release();

	// clean up our reference to the user arg
	if (fmcb->pUser) fmcb->pUser->Release();

	// clean up of our reference to frame3
	frame3->Release();

	// clean up our reference created when we QI for Frame3
	lpf->Release();

	// clean up the variable passed to us..
	// lpf1->Release();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// myFrameMoveCallback - rm frame move callback
//
extern "C" void __cdecl myFrameMoveCallback( LPDIRECT3DRMFRAME lpf1, void *lpArg, D3DVALUE delta)
{
        
	DPF(4,"Entered myFrameMoveCallback\r\n");
    myFrameMoveCallbackHelper(lpf1,lpArg,delta);
    DPF(4,"Exiting myFrameMoveCallback\r\n");
}
	


/////////////////////////////////////////////////////////////////////////////
// myAddDestroyCallback
//
extern "C" void __cdecl myAddDestroyCallback(LPDIRECT3DRMOBJECT obj, void *lpArg)
{

	DPF(4,"Entered myAddDestroyCallback\r\n");
	
	// dont play with obj.... this can get you in a recursive
	// situation obj is at refcount zero but calling addref and release
	// on it will get you re-entered into this callback..
	// I guess in rm folks were expected to not do that but could
	// get the name..
	// we will just pass pack any user arg 

	// Get our struct from the user args
	d3drmCallback *destroyCb = (d3drmCallback*)lpArg;
	
	// make sure we keep are reference to the vb callback
	destroyCb->c->AddRef ();
	
	DPF(4,"myAddDestroyCallback:	completed Addref VBCallback\r\n");

	// make sure we have a reference to any user arg object
	if (destroyCb->pUser) destroyCb->pUser->AddRef();
	
	DPF(4,"myAddDestroyCallback:	completed Addref userargs\r\n");

	// call into VB..
	// CONSIDER what happens when VB is being shut down.
	// if we get a reference to the object does that mean that
	// we can still execute the code
	destroyCb->c->callbackRMDestroyObject(destroyCb->pUser);
	
	DPF(4,"myAddDestroyCallback:	call into VB\r\n");

	// release reference to user object
	if (destroyCb->pUser) destroyCb->pUser->AddRef();
	
	DPF(4,"myAddDestroyCallback:	completed release userargs\r\n");

	// release our reference to vb callback
	destroyCb->c->Release();
	
	DPF(4,"myAddDestroyCallback:	completed release VBCallback\r\n");
	

	DPF(4,"Leaving myAddDestroyCallback\r\n");
	
}


/////////////////////////////////////////////////////////////////////////////
// myAddUpdateCallback3
//
// NOTE: we can only pass the first update rect to VB
// 
// note we use a cover function so that we can make calls to INTERNAL_CREATE
//

#define MYVARIANTINIT(inArg,puser) \
	VariantInit(puser); \
	user.vt=VT_UNKNOWN; \
	user.punkVal = inArg; \
	user.punkVal->AddRef();

///////////////////////////////////////////////////////////////////////////
// myAddUpdateCallback3Helper - called by Load callback 
//
// seperated out only because have multiple load callbacks
//

HRESULT myAddUpdateCallback3Helper ( LPDIRECT3DRMDEVICE3 ref,void *lpArg, int x, LPD3DRECT update)
{
   	// Get our struct from the user args
	DeviceUpdateCallback3	*updateCb = (DeviceUpdateCallback3*)lpArg;
	I_dxj_Direct3dRMDevice3 *device3  = NULL;
	VARIANT					user;
	
    	// Try and find the object in our link list of cover objects
	// if its not there then create one.
	//
	// note: will eat the reference to lpf so dont release
	// bug gives us a frame3 with incrermented ref count
	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMDevice3,ref,&device3);

	// for reason unbeknown to me we user a variant here instead
	// of an object in our callback
	MYVARIANTINIT(updateCb->pUser,&user);

	// keep a reference to the callback
	updateCb->c->AddRef();

	// call the callback
	updateCb->c->callbackRMUpdate( device3, NULL, x, (D3dRect*)update);
	
	// releae our reference to the callback
	updateCb->c->Release();

	// clear any refernce to user args
	VariantClear(&user);

    device3->Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
// myLoadCoverFunc - called by Load callback 
//
// seperated out only because have multiple load callbacks
//
extern "C" void __cdecl myAddUpdateCallback3 ( LPDIRECT3DRMDEVICE3 ref,void *lpArg, int x, LPD3DRECT update)
{
 
	DPF(4,"Entered myAddUpdateCallback\r\n");
    myAddUpdateCallback3Helper(ref,lpArg,x,update);
	DPF(4,"Exiting myAddUpdateCallback\r\n");

}

///////////////////////////////////////////////////////////////////////////
// myLoadCoverFunc - called by Load callback 
//
// seperated out only because have multiple load callbacks
//
HRESULT myLoadCoverFunc(LPDIRECT3DRMOBJECT lpo, REFIID ObjGuid, LPVOID lpArg){
	
    I_dxj_Direct3dRMObject *pObj=NULL;
    HRESULT hr;
    
    // Get our callback struct from the user args
	LoadCallback *loadcb = (LoadCallback*)lpArg;	
	
    

    hr =CreateCoverObject(lpo,&pObj);
    
	// If no coverthing exit
	if ((pObj==NULL) ||(hr!=S_OK)) {		
		DPF(4,"Load callback - unrecognized type");		
		return E_FAIL;
	}


	// get a string represenation of whats passed in
	BSTR guid=GUIDtoBSTR((LPGUID)&ObjGuid);

	// addref the user arg 
	if (loadcb->pUser) loadcb->pUser->AddRef();

	//call into VB
	hr=((I_dxj_Direct3dRMLoadCallback*)(loadcb->c))->callbackRMLoad(&pObj,guid,loadcb->pUser);	
		
	//release the user arg
	if (loadcb->pUser) loadcb->pUser->Release();

	//free the guid string
	SysFreeString((BSTR)guid);
	
	//then release pObj
	pObj->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// myd3drmLoadCallback
//
extern "C" void  __cdecl myd3drmLoadCallback(LPDIRECT3DRMOBJECT lpo, REFIID ObjGuid, LPVOID lpArg)
{
	
	DPF(4,"Entered d3drmLoadCallback \r\n");
	
	myLoadCoverFunc( lpo,  ObjGuid,  lpArg);
    
    DPF(4,"Exited d3drmLoadCallback \r\n");
	return;
}




/////////////////////////////////////////////////////////////////////////////
// myCoverEnumObjects
//
// NOTE the RM bug this deals with..
//
HRESULT  myCoverEnumObjects( LPDIRECT3DRMOBJECT lpo,void *lpArg){
	EnumerateObjectsCallback *cb = (EnumerateObjectsCallback*)lpArg;
    I_dxj_Direct3dRMObject *pObj=NULL;
    HRESULT hr;

	hr=CreateCoverObject(lpo,&pObj);

	
	//RM has a bug in it that gives an extra addreff to lpo
	//get rid of it
	if (lpo) lpo->Release();
    
    //Make sure things went ok
    if FAILED(hr) return hr;	
    if (!pObj ) return E_FAIL;
	


    //addref user args
	if (cb->pUser) cb->pUser->AddRef();

    //call into VB
	cb->c->callbackRMEnumerateObjects(pObj,  cb->pUser);
	
    //release user args
    if (cb->pUser) cb->pUser->Release();

    //release pObj
    pObj->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//  myEnumerateObjectsCallback
//
extern "C" void __cdecl myEnumerateObjectsCallback( LPDIRECT3DRMOBJECT lpo,void *lpArg)
{	
	
	DPF(4,"Entered myEnumerateObjectsCallback\r\n");	
	myCoverEnumObjects(lpo,lpArg);
    DPF(4,"Exited  myEnumerateObjectsCallback\r\n");
	return;
}



/////////////////////////////////////////////////////////////////////////////
// UndoCallbackLink
//
extern "C" void UndoCallbackLink(GeneralCallback *entry, GeneralCallback **head)
{
	if (entry->next)
		entry->next->prev = entry->prev;	// pick members below us
	else 
		*head = entry->prev;				// possibly NULL

	if (entry->prev)
		entry->prev->next = entry->next;	// link to members above us

	if (entry->pUser) entry->pUser->Release();

	delete entry;
}




/////////////////////////////////////////////////////////////////////////////
// AddCallbackLink
//
// Add another entry in the object link list
extern "C" void* AddCallbackLink(void **ptr2,I_dxj_Direct3dRMCallback *enumC,void *args)
{
		d3drmCallback *enumcb = new d3drmCallback; // new link entry

		if ( !enumcb ) {

			
			DPF(4,"Creation using new failed\r\n");
			
			return (d3drmCallback*)NULL;
		}

		enumcb->c		= enumC;					// user callback
		enumcb->pUser	= (struct IUnknown *)args;	// callback args
		enumcb->pParent	= NULL;					
		enumcb->prev	= (d3drmCallback*)NULL;
		enumcb->m_stopflag = FALSE;
		enumcb->m_obj   = NULL;

		//CONSIDER:  locking the linked list here with a semaphore
		//	     to be more multithread friendly..
		//	     shame shame-  possible gpf otherwise

		enumcb->next	= (d3drmCallback*)(*ptr2);	// link to other calls
		*ptr2	= enumcb;						// we are at the top

		if (enumcb->pUser) enumcb->pUser->AddRef();

		if (enumcb->prev != NULL)				// nested callbacks
		{
			enumcb->prev->next = enumcb;		// back link


		DPF(4,"Callback nesting encountered\r\n");

		}

	// Need unlock here.
	return enumcb;
}


/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT _AddDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args)
{
    return E_NOTIMPL;

    #if 0
	DestroyCallback *dcb;

	// killed by companion DeleteDestroyCallback
	dcb = (DestroyCallback*)AddCallbackLink((void**)&DestroyCallbacks,
										(I_dxj_Direct3dRMCallback*)oC, (void*) args);
	if (!(dcb))
	{
		
		DPF(4,"AddDestroyCallback failed!\r\n");
		
		return E_FAIL;
	}

	if (iface->AddDestroyCallback(
							myAddDestroyCallback, dcb))	
		return E_FAIL;
	
	oC->AddRef();		// callback is persistent so make it so in Java/VB Land
	//oC->AddRef();		//? 2 ...
	return S_OK;
    #endif
}

/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT _DeleteDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args)
{
    return E_NOTIMPL;

    #if 0
	DestroyCallback *dcb = DestroyCallbacks;

	// look for our own specific entry
	for ( ;  dcb;  dcb = dcb->next )   {

		if( (dcb->c == oC) && (dcb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			iface->DeleteDestroyCallback(
							myAddDestroyCallback, dcb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)dcb,
										(GeneralCallback**)&DestroyCallbacks);
			iface->Release();
			return S_OK;
		}
	}
	iface->Release();	// none found so a release is not needed
	return E_FAIL;
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmchordmapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmchordmapobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicChordMap, {});
DESTRUCTOR(_dxj_DirectMusicChordMap, {});
GETSET_OBJECT(_dxj_DirectMusicChordMap);


	

HRESULT C_dxj_DirectMusicChordMapObject::getScale(long *scale)
{  
	HRESULT hr;				
	hr=m__dxj_DirectMusicChordMap->GetScale((DWORD*)scale);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmbandobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmbandobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicBandObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicBand IDirectMusicBand*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBandObject : 
	public I_dxj_DirectMusicBand,
	//public CComCoClass<C_dxj_DirectMusicBandObject, &CLSID__dxj_DirectMusicBand>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBandObject();
	virtual ~C_dxj_DirectMusicBandObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicBandObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicBand)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicBand,		"DIRECT.DirectMusicBand.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicBandObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance);

	HRESULT STDMETHODCALLTYPE unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance);

  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicBand);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicBand)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\directxhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       directxhelp.h
//
//--------------------------------------------------------------------------

#ifndef __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__
#define __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__

#define _vbd3drm_Direct3DRMAnimation2 867001                                        //  Direct3DRMAnimation2
#define _vbd3drm_Direct3DRMAnimationArray 867002                                    //  Direct3DRMAnimationArray
#define _vbd3drm_Direct3DRMAnimationSet2 867003                                     //  Direct3DRMAnimationSet2
#define _vbd3drm_Visual_Basic_Callback_Interfaces 867004                            //  Visual Basic Callback Interfaces
#define _vbd3drm_Direct3DRMClippedVisual 867005                                     //  Direct3DRMClippedVisual
#define _vbd3drm_Direct3DRMDevice3 867006                                           //  Direct3DRMDevice3
#define _vbd3drm_Direct3DRMDeviceArray 867007                                       //  Direct3DRMDeviceArray
#define _vbd3drm_Visual_Basic_Enumerations 867008                                   //  Visual Basic Enumerations
#define _vbd3drm_Direct3DRMFace2 867009                                             //  Direct3DRMFace2
#define _vbd3drm_Direct3DRMFaceArray 867010                                         //  Direct3DRMFaceArray
#define _vbd3drm_Direct3DRMFrame3_Methods_A_to_M 867011                             //  Direct3DRMFrame3 Methods A to M
#define _vbd3drm_Direct3DRMFrame3_Methods_N_to_Z 867012                             //  Direct3DRMFrame3 Methods N to Z
#define _vbd3drm_Direct3DRMFrame3 867013                                            //  Direct3DRMFrame3
#define _vbd3drm_Direct3DRMFrameArray 867014                                        //  Direct3DRMFrameArray
#define _vbd3drm_Direct3DRMFrameInterpolator 867015                                 //  Direct3DRMFrameInterpolator
#define _vbd3drm_Further_Reading_for_Visual_Basic_Programmers 867016                //  Further Reading for Visual Basic Programmers
#define _vbd3drm_Direct3DRM3 867017                                                 //  Direct3DRM3
#define _vbd3drm_Visual_Basic_Interfaces 867018                                     //  Visual Basic Interfaces
#define _vbd3drm_Direct3DRMLight 867019                                             //  Direct3DRMLight
#define _vbd3drm_Direct3DRMLightArray 867020                                        //  Direct3DRMLightArray
#define _vbd3drm_Direct3DRMLightInterpolator 867021                                 //  Direct3DRMLightInterpolator
#define _vbd3drm_Direct3DRMMaterial2 867022                                         //  Direct3DRMMaterial2
#define _vbd3drm_Direct3DRMMaterialInterpolator 867023                              //  Direct3DRMMaterialInterpolator
#define _vbd3drm_Direct3DRMMesh 867024                                              //  Direct3DRMMesh
#define _vbd3drm_Direct3DRMMeshBuilder3 867025                                      //  Direct3DRMMeshBuilder3
#define _vbd3drm_Direct3DRMMeshInterpolator 867026                                  //  Direct3DRMMeshInterpolator
#define _vbd3drm_Direct3DRMObject 867027                                            //  Direct3DRMObject
#define _vbd3drm_Direct3DRMObjectArray 867028                                       //  Direct3DRMObjectArray
#define _vbd3drm_Direct3DRMPick2Array 867029                                        //  Direct3DRMPick2Array
#define _vbd3drm_Direct3DRMPickArray 867030                                         //  Direct3DRMPickArray
#define _vbd3drm_Direct3DRMProgressiveMesh 867031                                   //  Direct3DRMProgressiveMesh
#define _vbd3drm_Reference 867032                                                   //  Reference
#define _D3DRM_Error_Values 867033                                                  //  Visual Basic Error Values
#define _vbd3drm_Direct3DRMShadow2 867034                                           //  Direct3DRMShadow2
#define _vbd3drm_Visual_Basic_Types 867035                                          //  Visual Basic Types
#define _vbd3drm_Direct3DRMTexture3 867036                                          //  Direct3DRMTexture3
#define _vbd3drm_Direct3DRMTextureInterpolator 867037                               //  Direct3DRMTextureInterpolator
#define _vbd3drm_Direct3DRMUserVisual 867038                                        //  Direct3DRMUserVisual
#define _vbd3drm_Direct3DRMViewport2 867039                                         //  Direct3DRMViewport2
#define _vbd3drm_Direct3DRMViewportArray 867040                                     //  Direct3DRMViewportArray
#define _vbd3drm_Direct3DRMViewportInterpolator 867041                              //  Direct3DRMViewportInterpolator
#define _vbd3drm_Direct3DRMVisual 867042                                            //  Direct3DRMVisual
#define _vbd3drm_Direct3DRMVisualArray 867043                                       //  Direct3DRMVisualArray
#define _vbd3drm_Direct3DRMWrap 867044                                              //  Direct3DRMWrap
#define idh__dx_direct3d3_d3d_vb 867045                                             //  Direct3D3
#define idh__dx_direct3d3_createdevice_d3d_vb 867046                                //  Direct3D3.CreateDevice
#define idh__dx_direct3d3_createlight_d3d_vb 867047                                 //  Direct3D3.CreateLight
#define idh__dx_direct3d3_creatematerial_d3d_vb 867048                              //  Direct3D3.CreateMaterial
#define idh__dx_direct3d3_createvertexbuffer_d3d_vb 867049                          //  Direct3D3.CreateVertexBuffer
#define idh__dx_direct3d3_createviewport_d3d_vb 867050                              //  Direct3D3.CreateViewport
#define idh__dx_direct3d3_evictmanagedtextures_d3d_vb 867051                        //  Direct3D3.EvictManagedTextures
#define idh__dx_direct3d3_finddevice_d3d_vb 867052                                  //  Direct3D3.FindDevice
#define idh__dx_direct3d3_getdevicesenum_d3d_vb 867053                              //  Direct3D3.GetDevicesEnum
#define idh__dx_direct3d3_getdirectdraw_d3d_vb 867054                               //  Direct3D3.GetDirectDraw
#define idh__dx_direct3d3_getenumzbufferformats_d3d_vb 867055                       //  Direct3D3.GetEnumZBufferFormats
#define idh__dx_direct3ddevice3_d3d_vb 867056                                       //  Direct3DDevice3
#define idh__dx_direct3ddevice3_addviewport_d3d_vb 867057                           //  Direct3DDevice3.AddViewport
#define idh__dx_direct3ddevice3_begin_d3d_vb 867058                                 //  Direct3DDevice3.Begin
#define idh__dx_direct3ddevice3_beginindexed_d3d_vb 867059                          //  Direct3DDevice3.BeginIndexed
#define idh__dx_direct3ddevice3_beginscene_d3d_vb 867060                            //  Direct3DDevice3.BeginScene
#define idh__dx_direct3ddevice3_computespherevisibility_d3d_vb 867061               //  Direct3DDevice3.ComputeSphereVisibility
#define idh__dx_direct3ddevice3_deleteviewport_d3d_vb 867062                        //  Direct3DDevice3.DeleteViewport
#define idh__dx_direct3ddevice3_drawindexedprimitive_d3d_vb 867063                  //  Direct3DDevice3.DrawIndexedPrimitive
#define idh__dx_direct3ddevice3_drawindexedprimitivevb_d3d_vb 867064                //  Direct3DDevice3.DrawIndexedPrimitiveVB
#define idh__dx_direct3ddevice3_drawprimitive_d3d_vb 867065                         //  Direct3DDevice3.DrawPrimitive
#define idh__dx_direct3ddevice3_drawprimitivevb_d3d_vb 867066                       //  Direct3DDevice3.DrawPrimitiveVB
#define idh__dx_direct3ddevice3_end_d3d_vb 867067                                   //  Direct3DDevice3.End
#define idh__dx_direct3ddevice3_endscene_d3d_vb 867068                              //  Direct3DDevice3.EndScene
#define idh__dx_direct3ddevice3_getcaps_d3d_vb 867069                               //  Direct3DDevice3.GetCaps
#define idh__dx_direct3ddevice3_getclipstatus_d3d_vb 867070                         //  Direct3DDevice3.GetClipStatus
#define idh__dx_direct3ddevice3_getcurrentviewport_d3d_vb 867071                    //  Direct3DDevice3.GetCurrentViewport
#define idh__dx_direct3ddevice3_getdirect3d_d3d_vb 867072                           //  Direct3DDevice3.GetDirect3D
#define idh__dx_direct3ddevice3_getlightstate_d3d_vb 867073                         //  Direct3DDevice3.GetLightState
#define idh__dx_direct3ddevice3_getrenderstate_d3d_vb 867074                        //  Direct3DDevice3.GetRenderState
#define idh__dx_direct3ddevice3_getrendertarget_d3d_vb 867075                       //  Direct3DDevice3.GetRenderTarget
#define idh__dx_direct3ddevice3_getstats_d3d_vb 867076                              //  Direct3DDevice3.GetStats
#define idh__dx_direct3ddevice3_gettexture_d3d_vb 867077                            //  Direct3DDevice3.GetTexture
#define idh__dx_direct3ddevice3_gettextureformatsenum_d3d_vb 867078                 //  Direct3DDevice3.GetTextureFormatsEnum
#define idh__dx_direct3ddevice3_gettexturestagestate_d3d_vb 867079                  //  Direct3DDevice3.GetTextureStageState
#define idh__dx_direct3ddevice3_gettransform_d3d_vb 867080                          //  Direct3DDevice3.GetTransform
#define idh__dx_direct3ddevice3_index_d3d_vb 867081                                 //  Direct3DDevice3.Index
#define idh__dx_direct3ddevice3_multiplytransform_d3d_vb 867082                     //  Direct3DDevice3.MultiplyTransform
#define idh__dx_direct3ddevice3_nextviewport_d3d_vb 867083                          //  Direct3DDevice3.NextViewport
#define idh__dx_direct3ddevice3_setclipstatus_d3d_vb 867084                         //  Direct3DDevice3.SetClipStatus
#define idh__dx_direct3ddevice3_setcurrentviewport_d3d_vb 867085                    //  Direct3DDevice3.SetCurrentViewport
#define idh__dx_direct3ddevice3_setlightstate_d3d_vb 867086                         //  Direct3DDevice3.SetLightState
#define idh__dx_direct3ddevice3_setrenderstate_d3d_vb 867087                        //  Direct3DDevice3.SetRenderState
#define idh__dx_direct3ddevice3_setrendertarget_d3d_vb 867088                       //  Direct3DDevice3.SetRenderTarget
#define idh__dx_direct3ddevice3_settexture_d3d_vb 867089                            //  Direct3DDevice3.SetTexture
#define idh__dx_direct3ddevice3_settexturestagestate_d3d_vb 867090                  //  Direct3DDevice3.SetTextureStageState
#define idh__dx_direct3ddevice3_settransform_d3d_vb 867091                          //  Direct3DDevice3.SetTransform
#define idh__dx_direct3ddevice3_validatedevice_d3d_vb 867092                        //  Direct3DDevice3.ValidateDevice
#define idh__dx_direct3ddevice3_vertex_d3d_vb 867093                                //  Direct3DDevice3.Vertex
#define idh__dx_direct3denumdevices_d3d_vb 867094                                   //  Direct3DEnumDevices
#define idh__dx_direct3denumdevices_getcount_d3d_vb 867095                          //  Direct3DEnumDevices.GetCount
#define idh__dx_direct3denumdevices_getdescription_d3d_vb 867096                    //  Direct3DEnumDevices.GetDescription
#define idh__dx_direct3denumdevices_getguid_d3d_vb 867097                           //  Direct3DEnumDevices.GetGuid
#define idh__dx_direct3denumdevices_getheldesc_d3d_vb 867098                        //  Direct3DEnumDevices.GetHELDesc
#define idh__dx_direct3denumdevices_gethwdesc_d3d_vb 867099                         //  Direct3DEnumDevices.GetHWDesc
#define idh__dx_direct3denumdevices_getname_d3d_vb 867100                           //  Direct3DEnumDevices.GetName
#define idh__dx_direct3denumpixelformats_d3d_vb 867101                              //  Direct3DEnumPixelFormats
#define idh__dx_direct3denumpixelformats_getcount_d3d_vb 867102                     //  Direct3DEnumPixelFormats.GetCount
#define idh__dx_direct3denumpixelformats_getitem_d3d_vb 867103                      //  Direct3DEnumPixelFormats.GetItem
#define idh__dx_direct3dlight_d3d_vb 867104                                         //  Direct3DLight
#define idh__dx_direct3dlight_getlight_d3d_vb 867105                                //  Direct3DLight.GetLight
#define idh__dx_direct3dlight_setlight_d3d_vb 867106                                //  Direct3DLight.SetLight
#define idh__dx_direct3dmaterial3_d3d_vb 867107                                     //  Direct3DMaterial3
#define idh__dx_direct3dmaterial3_gethandle_d3d_vb 867108                           //  Direct3DMaterial3.GetHandle
#define idh__dx_direct3dmaterial3_getmaterial_d3d_vb 867109                         //  Direct3DMaterial3.GetMaterial
#define idh__dx_direct3dmaterial3_setmaterial_d3d_vb 867110                         //  Direct3DMaterial3.SetMaterial
#define idh__dx_direct3dtexture2_d3d_vb 867111                                      //  Direct3DTexture2
#define idh__dx_direct3dtexture2_gethandle_d3d_vb 867112                            //  Direct3DTexture2.GetHandle
#define idh__dx_direct3dtexture2_getsurface_d3d_vb 867113                           //  Direct3DTexture2.GetSurface
#define idh__dx_direct3dtexture2_load_d3d_vb 867114                                 //  Direct3DTexture2.Load
#define idh__dx_direct3dtexture2_palettechanged_d3d_vb 867115                       //  Direct3DTexture2.PaletteChanged
#define idh__dx_direct3dvertexbuffer_d3d_vb 867116                                  //  Direct3DVertexBuffer
#define idh__dx_direct3dvertexbuffer_getvertexbufferdesc_d3d_vb 867117              //  Direct3DVertexBuffer.GetVertexBufferDesc
#define idh__dx_direct3dvertexbuffer_getvertices_d3d_vb 867118                      //  Direct3DVertexBuffer.GetVertices
#define idh__dx_direct3dvertexbuffer_lock_d3d_vb 867119                             //  Direct3DVertexBuffer.Lock
#define idh__dx_direct3dvertexbuffer_optimize_d3d_vb 867120                         //  Direct3DVertexBuffer.Optimize
#define idh__dx_direct3dvertexbuffer_processvertices_d3d_vb 867121                  //  Direct3DVertexBuffer.ProcessVertices
#define idh__dx_direct3dvertexbuffer_setvertices_d3d_vb 867122                      //  Direct3DVertexBuffer.SetVertices
#define idh__dx_direct3dvertexbuffer_unlock_d3d_vb 867123                           //  Direct3DVertexBuffer.Unlock
#define idh__dx_direct3dviewport3_d3d_vb 867124                                     //  Direct3DViewport3
#define idh__dx_direct3dviewport3_addlight_d3d_vb 867125                            //  Direct3DViewport3.AddLight
#define idh__dx_direct3dviewport3_clear_d3d_vb 867126                               //  Direct3DViewport3.Clear
#define idh__dx_direct3dviewport3_clear2_d3d_vb 867127                              //  Direct3DViewport3.Clear2
#define idh__dx_direct3dviewport3_deletelight_d3d_vb 867128                         //  Direct3DViewport3.DeleteLight
#define idh__dx_direct3dviewport3_getbackground_d3d_vb 867129                       //  Direct3DViewport3.GetBackground
#define idh__dx_direct3dviewport3_getbackgrounddepth_d3d_vb 867130                  //  Direct3DViewport3.GetBackgroundDepth
#define idh__dx_direct3dviewport3_getviewport_d3d_vb 867131                         //  Direct3DViewport3.GetViewport
#define idh__dx_direct3dviewport3_getviewport2_d3d_vb 867132                        //  Direct3DViewport3.GetViewport2
#define idh__dx_direct3dviewport3_lightelements_d3d_vb 867133                       //  Direct3DViewport3.LightElements
#define idh__dx_direct3dviewport3_nextlight_d3d_vb 867134                           //  Direct3DViewport3.NextLight
#define idh__dx_direct3dviewport3_setbackground_d3d_vb 867135                       //  Direct3DViewport3.SetBackground
#define idh__dx_direct3dviewport3_setbackgrounddepth_d3d_vb 867136                  //  Direct3DViewport3.SetBackgroundDepth
#define idh__dx_direct3dviewport3_setviewport_d3d_vb 867137                         //  Direct3DViewport3.SetViewport
#define idh__dx_direct3dviewport3_setviewport2_d3d_vb 867138                        //  Direct3DViewport3.SetViewport2
#define idh__dx_direct3dviewport3_transformvertices_d3d_vb 867139                   //  Direct3DViewport3.TransformVertices
#define idh__dx_d3dclipstatus_d3d_vb 867140                                         //  D3DCLIPSTATUS
#define idh__dx_d3dcolorvalue_d3d_vb 867141                                         //  D3DCOLORVALUE
#define idh__dx_d3ddevicedesc_d3d_vb 867142                                         //  D3DDEVICEDESC
#define idh__dx_d3dfinddeviceresult2_d3d_vb 867143                                  //  D3DFINDDEVICERESULT2
#define idh__dx_d3dfinddevicesearch_d3d_vb 867144                                   //  D3DFINDDEVICESEARCH
#define idh__dx_d3dhvertex_d3d_vb 867145                                            //  D3DHVERTEX
#define idh__dx_d3dlight2_d3d_vb 867146                                             //  D3DLIGHT2
#define idh__dx_d3dlightdata_d3d_vb 867147                                          //  D3DLIGHTDATA
#define idh__dx_d3dlightingcaps_d3d_vb 867148                                       //  D3DLIGHTINGCAPS
#define idh__dx_d3dlvertex_d3d_vb 867149                                            //  D3DLVERTEX
#define idh__dx_d3dmaterial_d3d_vb 867150                                           //  D3DMATERIAL
#define idh__dx_d3dmatrix_d3d_vb 867151                                             //  D3DMATRIX
#define idh__dx_d3dprimcaps_d3d_vb 867152                                           //  D3DPRIMCAPS
#define idh__dx_d3drect_d3d_vb 867153                                               //  D3DRECT
#define idh__dx_d3drotation_d3d_vb 867154                                           //  D3DROTATION
#define idh__dx_d3dstats_d3d_vb 867155                                              //  D3DSTATS
#define idh__dx_d3dstatus_d3d_vb 867156                                             //  D3DSTATUS
#define idh__dx_d3dtlvertex_d3d_vb 867157                                           //  D3DTLVERTEX
#define idh__dx_d3dtransformdata_d3d_vb 867158                                      //  D3DTRANSFORMDATA
#define idh__dx_d3dvector_d3d_vb 867159                                             //  D3DVECTOR
#define idh__dx_d3dvertex_d3d_vb 867160                                             //  D3DVERTEX
#define idh__dx_d3dvertexbufferdesc_d3d_vb 867161                                   //  D3DVERTEXBUFFERDESC
#define idh__dx_d3dviewport_d3d_vb 867162                                           //  D3DVIEWPORT
#define idh__dx_d3dviewport2_d3d_vb 867163                                          //  D3DVIEWPORT2
#define idh__dx_dxdriverinfo_d3d_vb 867164                                          //  DXDRIVERINFO
#define idh__dx_const_d3d_d3d_vb 867165                                             //  CONST_D3D
#define idh__dx_const_d3dantialiasmode_d3d_vb 867166                                //  CONST_D3DANTIALIASMODE
#define idh__dx_const_d3dblend_d3d_vb 867167                                        //  CONST_D3DBLEND
#define idh__dx_const_d3dcapsblend_d3d_vb 867168                                    //  CONST_D3DCAPSBLEND
#define idh__dx_const_d3dcapscmp_d3d_vb 867169                                      //  CONST_D3DCAPSCMP
#define idh__dx_const_d3dcapsmisc_d3d_vb 867170                                     //  CONST_D3DCAPSMISC
#define idh__dx_const_d3dcapsraster_d3d_vb 867171                                   //  CONST_D3DCAPSRASTER
#define idh__dx_const_d3dcapsshade_d3d_vb 867172                                    //  CONST_D3DCAPSSHADE
#define idh__dx_const_d3dcapstexture_d3d_vb 867173                                  //  CONST_D3DCAPSTEXTURE
#define idh__dx_const_d3dcapstextureaddress_d3d_vb 867174                           //  CONST_D3DCAPSTEXTUREADDRESS
#define idh__dx_const_d3dcapstextureblend_d3d_vb 867175                             //  CONST_D3DCAPSTEXTUREBLEND
#define idh__dx_const_d3dcapstexturefilter_d3d_vb 867176                            //  CONST_D3DCAPSTEXTUREFILTER
#define idh__dx_const_d3dclearflags_d3d_vb 867177                                   //  CONST_D3DCLEARFLAGS
#define idh__dx_const_d3dclipflags_d3d_vb 867178                                    //  CONST_D3DCLIPFLAGS
#define idh__dx_const_d3dclipstatusflags_d3d_vb 867179                              //  CONST_D3DCLIPSTATUSFLAGS
#define idh__dx_const_d3dcmpfunc_d3d_vb 867180                                      //  CONST_D3DCMPFUNC
#define idh__dx_const_d3dcolormodel_d3d_vb 867181                                   //  CONST_D3DCOLORMODEL
#define idh__dx_const_d3dcull_d3d_vb 867182                                         //  CONST_D3DCULL
#define idh__dx_const_d3ddevicedesccaps_d3d_vb 867183                               //  CONST_D3DDEVICEDESCCAPS
#define idh__dx_const_d3ddevicedescflags_d3d_vb 867184                              //  CONST_D3DDEVICEDESCFLAGS
#define idh__dx_const_d3ddpflags_d3d_vb 867185                                      //  CONST_D3DDPFLAGS
#define idh__dx_const_d3dfillmode_d3d_vb 867186                                     //  CONST_D3DFILLMODE
#define idh__dx_const_d3dfinddevicesearchflags_d3d_vb 867187                        //  CONST_D3DFINDDEVICESEARCHFLAGS
#define idh__dx_const_d3dfogmode_d3d_vb 867188                                      //  CONST_D3DFOGMODE
#define idh__dx_const_d3dfvfcapsflags_d3d_vb 867189                                 //  CONST_D3DFVFCAPSFLAGS
#define idh__dx_const_d3dfvfflags_d3d_vb 867190                                     //  CONST_D3DFVFFLAGS
#define idh__dx_const_d3dimerr_d3d_vb 867191                                        //  CONST_D3DIMERR
#define idh__dx_const_d3dlight2flags_d3d_vb 867192                                  //  CONST_D3DLIGHT2FLAGS
#define idh__dx_const_d3dlightcapsflags_d3d_vb 867193                               //  CONST_D3DLIGHTCAPSFLAGS
#define idh__dx_const_d3dlightingmodelflags_d3d_vb 867194                           //  CONST_D3DLIGHTINGMODELFLAGS
#define idh__dx_const_d3dlightstatetype_d3d_vb 867195                               //  CONST_D3DLIGHTSTATETYPE
#define idh__dx_const_d3dlighttype_d3d_vb 867196                                    //  CONST_D3DLIGHTTYPE
#define idh__dx_const_d3dnextflags_d3d_vb 867197                                    //  CONST_D3DNEXTFLAGS
#define idh__dx_const_d3dpalflags_d3d_vb 867198                                     //  CONST_D3DPALFLAGS
#define idh__dx_const_d3dprimitivetype_d3d_vb 867199                                //  CONST_D3DPRIMITIVETYPE
#define idh__dx_const_d3drenderstatetype_d3d_vb 867200                              //  CONST_D3DRENDERSTATETYPE
#define idh__dx_const_d3dsetstatusflags_d3d_vb 867201                               //  CONST_D3DSETSTATUSFLAGS
#define idh__dx_const_d3dshademode_d3d_vb 867202                                    //  CONST_D3DSHADEMODE
#define idh__dx_const_d3dstencilcapsflags_d3d_vb 867203                             //  CONST_D3DSTENCILCAPSFLAGS
#define idh__dx_const_d3dstencilop_d3d_vb 867204                                    //  CONST_D3DSTENCILOP
#define idh__dx_const_d3dtaflags_d3d_vb 867205                                      //  CONST_D3DTAFLAGS
#define idh__dx_const_d3dtexopcapsflags_d3d_vb 867206                               //  CONST_D3DTEXOPCAPSFLAGS
#define idh__dx_const_d3dtextureaddress_d3d_vb 867207                               //  CONST_D3DTEXTUREADDRESS
#define idh__dx_const_d3dtextureblend_d3d_vb 867208                                 //  CONST_D3DTEXTUREBLEND
#define idh__dx_const_d3dtexturefilter_d3d_vb 867209                                //  CONST_D3DTEXTUREFILTER
#define idh__dx_const_d3dtexturemagfilter_d3d_vb 867210                             //  CONST_D3DTEXTUREMAGFILTER
#define idh__dx_const_d3dtextureminfilter_d3d_vb 867211                             //  CONST_D3DTEXTUREMINFILTER
#define idh__dx_const_d3dtexturemipfilter_d3d_vb 867212                             //  CONST_D3DTEXTUREMIPFILTER
#define idh__dx_const_d3dtextureop_d3d_vb 867213                                    //  CONST_D3DTEXTUREOP
#define idh__dx_const_d3dtexturestagestatetype_d3d_vb 867214                        //  CONST_D3DTEXTURESTAGESTATETYPE
#define idh__dx_const_d3dtransformcaps_d3d_vb 867215                                //  CONST_D3DTRANSFORMCAPS
#define idh__dx_const_d3dtransformflags_d3d_vb 867216                               //  CONST_D3DTRANSFORMFLAGS
#define idh__dx_const_d3dtransformstatetype_d3d_vb 867217                           //  CONST_D3DTRANSFORMSTATETYPE
#define idh__dx_const_d3dvbcapsflags_d3d_vb 867218                                  //  CONST_D3DVBCAPSFLAGS
#define idh__dx_const_d3dvertextype_d3d_vb 867219                                   //  CONST_D3DVERTEXTYPE
#define idh__dx_const_d3dvisflags_d3d_vb 867220                                     //  CONST_D3DVISFLAGS
#define idh__dx_const_d3dvopflags_d3d_vb 867221                                     //  CONST_D3DVOPFLAGS
#define idh__dx_const_d3dzbuffertype_d3d_vb 867222                                  //  CONST_D3DZBUFFERTYPE
#define idh__dx_directdraw4_ddraw_vb 867223                                         //  DirectDraw4
#define idh__dx_directdraw4_createclipper_ddraw_vb 867224                           //  DirectDraw4.CreateClipper
#define idh__dx_directdraw4_createpalette_ddraw_vb 867225                           //  DirectDraw4.CreatePalette
#define idh__dx_directdraw4_createsurface_ddraw_vb 867226                           //  DirectDraw4.CreateSurface
#define idh__dx_directdraw4_createsurfacefromfile_ddraw_vb 867227                   //  DirectDraw4.CreateSurfaceFromFile
#define idh__dx_directdraw4_createsurfacefromresource_ddraw_vb 867228               //  DirectDraw4.CreateSurfaceFromResource
#define idh__dx_directdraw4_duplicatesurface_ddraw_vb 867229                        //  DirectDraw4.DuplicateSurface
#define idh__dx_directdraw4_fliptogdisurface_ddraw_vb 867230                        //  DirectDraw4.FlipToGDISurface
#define idh__dx_directdraw4_getavailabletotalmem_ddraw_vb 867231                    //  DirectDraw4.GetAvailableTotalMem
#define idh__dx_directdraw4_getcaps_ddraw_vb 867232                                 //  DirectDraw4.GetCaps
#define idh__dx_directdraw4_getdirect3d_ddraw_vb 867233                             //  DirectDraw4.GetDirect3D
#define idh__dx_directdraw4_getdisplaymode_ddraw_vb 867234                          //  DirectDraw4.GetDisplayMode
#define idh__dx_directdraw4_getdisplaymodesenum_ddraw_vb 867235                     //  DirectDraw4.GetDisplayModesEnum
#define idh__dx_directdraw4_getfourcccodes_ddraw_vb 867236                          //  DirectDraw4.GetFourCCCodes
#define idh__dx_directdraw4_getfreemem_ddraw_vb 867237                              //  DirectDraw4.GetFreeMem
#define idh__dx_directdraw4_getgdisurface_ddraw_vb 867238                           //  DirectDraw4.GetGDISurface
#define idh__dx_directdraw4_getmonitorfrequency_ddraw_vb 867239                     //  DirectDraw4.GetMonitorFrequency
#define idh__dx_directdraw4_getnumfourcccodes_ddraw_vb 867240                       //  DirectDraw4.GetNumFourCCCodes
#define idh__dx_directdraw4_getscanline_ddraw_vb 867241                             //  DirectDraw4.GetScanLine
#define idh__dx_directdraw4_getsurfacefromdc_ddraw_vb 867242                        //  DirectDraw4.GetSurfaceFromDC
#define idh__dx_directdraw4_getsurfacesenum_ddraw_vb 867243                         //  DirectDraw4.GetSurfacesEnum
#define idh__dx_directdraw4_getverticalblankstatus_ddraw_vb 867244                  //  DirectDraw4.GetVerticalBlankStatus
#define idh__dx_directdraw4_loadpalettefrombitmap_ddraw_vb 867245                   //  DirectDraw4.LoadPaletteFromBitmap
#define idh__dx_directdraw4_restoreallsurfaces_ddraw_vb 867246                      //  DirectDraw4.RestoreAllSurfaces
#define idh__dx_directdraw4_restoredisplaymode_ddraw_vb 867247                      //  DirectDraw4.RestoreDisplayMode
#define idh__dx_directdraw4_setcooperativelevel_ddraw_vb 867248                     //  DirectDraw4.SetCooperativeLevel
#define idh__dx_directdraw4_setdisplaymode_ddraw_vb 867249                          //  DirectDraw4.SetDisplayMode
#define idh__dx_directdraw4_testcooperativelevel_ddraw_vb 867250                    //  DirectDraw4.TestCooperativeLevel
#define idh__dx_directdraw4_waitforverticalblank_ddraw_vb 867251                    //  DirectDraw4.WaitForVerticalBlank
#define idh__dx_directdrawclipper_ddraw_vb 867252                                   //  DirectDrawClipper
#define idh__dx_directdrawclipper_getcliplist_ddraw_vb 867253                       //  DirectDrawClipper.GetClipList
#define idh__dx_directdrawclipper_getcliplistsize_ddraw_vb 867254                   //  DirectDrawClipper.GetClipListSize
#define idh__dx_directdrawclipper_gethwnd_ddraw_vb 867255                           //  DirectDrawClipper.GetHWnd
#define idh__dx_directdrawclipper_iscliplistchanged_ddraw_vb 867256                 //  DirectDrawClipper.IsClipListChanged
#define idh__dx_directdrawclipper_setcliplist_ddraw_vb 867257                       //  DirectDrawClipper.SetClipList
#define idh__dx_directdrawclipper_sethwnd_ddraw_vb 867258                           //  DirectDrawClipper.SetHWnd
#define idh__dx_directdrawcolorcontrol_ddraw_vb 867259                              //  DirectDrawColorControl
#define idh__dx_directdrawcolorcontrol_getcolorcontrols_ddraw_vb 867260             //  DirectDrawColorControl.GetColorControls
#define idh__dx_directdrawcolorcontrol_setcolorcontrols_ddraw_vb 867261             //  DirectDrawColorControl.SetColorControls
#define idh__dx_directdrawenum_ddraw_vb 867262                                      //  DirectDrawEnum
#define idh__dx_directdrawenum_getcount_ddraw_vb 867263                             //  DirectDrawEnum.GetCount
#define idh__dx_directdrawenum_getdescription_ddraw_vb 867264                       //  DirectDrawEnum.GetDescription
#define idh__dx_directdrawenum_getguid_ddraw_vb 867265                              //  DirectDrawEnum.GetGuid
#define idh__dx_directdrawenum_getname_ddraw_vb 867266                              //  DirectDrawEnum.GetName
#define idh__dx_directdrawenummodes_ddraw_vb 867267                                 //  DirectDrawEnumModes
#define idh__dx_directdrawenummodes_getcount_ddraw_vb 867268                        //  DirectDrawEnumModes.GetCount
#define idh__dx_directdrawenummodes_getitem_ddraw_vb 867269                         //  DirectDrawEnumModes.GetItem
#define idh__dx_directdrawenumsurfaces_ddraw_vb 867270                              //  DirectDrawEnumSurfaces
#define idh__dx_directdrawenumsurfaces_getcount_ddraw_vb 867271                     //  DirectDrawEnumSurfaces.GetCount
#define idh__dx_directdrawenumsurfaces_getitem_ddraw_vb 867272                      //  DirectDrawEnumSurfaces.GetItem
#define idh__dx_directdrawgammacontrol_ddraw_vb 867273                              //  DirectDrawGammaControl
#define idh__dx_directdrawgammacontrol_getgammaramp_ddraw_vb 867274                 //  DirectDrawGammaControl.GetGammaRamp
#define idh__dx_directdrawgammacontrol_setgammaramp_ddraw_vb 867275                 //  DirectDrawGammaControl.SetGammaRamp
#define idh__dx_directdrawpalette_ddraw_vb 867276                                   //  DirectDrawPalette
#define idh__dx_directdrawpalette_getcaps_ddraw_vb 867277                           //  DirectDrawPalette.GetCaps
#define idh__dx_directdrawpalette_getentries_ddraw_vb 867278                        //  DirectDrawPalette.GetEntries
#define idh__dx_directdrawpalette_setentries_ddraw_vb 867279                        //  DirectDrawPalette.SetEntries
#define idh__dx_directdrawsurface4_ddraw_vb 867280                                  //  DirectDrawSurface4
#define idh__dx_directdrawsurface4_addattachedsurface_ddraw_vb 867281               //  DirectDrawSurface4.AddAttachedSurface
#define idh__dx_directdrawsurface4_addoverlaydirtyrect_ddraw_vb 867282              //  DirectDrawSurface4.AddOverlayDirtyRect
#define idh__dx_directdrawsurface4_blt_ddraw_vb 867283                              //  DirectDrawSurface4.Blt
#define idh__dx_directdrawsurface4_bltcolorfill_ddraw_vb 867284                     //  DirectDrawSurface4.BltColorFill
#define idh__dx_directdrawsurface4_bltfast_ddraw_vb 867285                          //  DirectDrawSurface4.BltFast
#define idh__dx_directdrawsurface4_bltfx_ddraw_vb 867286                            //  DirectDrawSurface4.BltFx
#define idh__dx_directdrawsurface4_changeuniquenessvalue_ddraw_vb 867287            //  DirectDrawSurface4.ChangeUniquenessValue
#define idh__dx_directdrawsurface4_deleteattachedsurface_ddraw_vb 867288            //  DirectDrawSurface4.DeleteAttachedSurface
#define idh__dx_directdrawsurface4_flip_ddraw_vb 867289                             //  DirectDrawSurface4.Flip
#define idh__dx_directdrawsurface4_freeprivatedata_ddraw_vb 867290                  //  DirectDrawSurface4.FreePrivateData
#define idh__dx_directdrawsurface4_getattachedsurface_ddraw_vb 867291               //  DirectDrawSurface4.GetAttachedSurface
#define idh__dx_directdrawsurface4_getattachedsurfaceenum_ddraw_vb 867292           //  DirectDrawSurface4.GetAttachedSurfaceEnum
#define idh__dx_directdrawsurface4_getbltstatus_ddraw_vb 867293                     //  DirectDrawSurface4.GetBltStatus
#define idh__dx_directdrawsurface4_getcaps_ddraw_vb 867294                          //  DirectDrawSurface4.GetCaps
#define idh__dx_directdrawsurface4_getclipper_ddraw_vb 867295                       //  DirectDrawSurface4.GetClipper
#define idh__dx_directdrawsurface4_getcolorkey_ddraw_vb 867296                      //  DirectDrawSurface4.GetColorKey
#define idh__dx_directdrawsurface4_getdc_ddraw_vb 867297                            //  DirectDrawSurface4.GetDC
#define idh__dx_directdrawsurface4_getdirectdraw_ddraw_vb 867298                    //  DirectDrawSurface4.GetDirectDraw
#define idh__dx_directdrawsurface4_getdirectdrawcolorcontrol_ddraw_vb 867299        //  DirectDrawSurface4.GetDirectDrawColorControl
#define idh__dx_directdrawsurface4_getdirectdrawgammacontrol_ddraw_vb 867300        //  DirectDrawSurface4.GetDirectDrawGammaControl
#define idh__dx_directdrawsurface4_getflipstatus_ddraw_vb 867301                    //  DirectDrawSurface4.GetFlipStatus
#define idh__dx_directdrawsurface4_getlockedpixel_ddraw_vb 867302                   //  DirectDrawSurface4.GetLockedPixel
#define idh__dx_directdrawsurface4_getlockedsurfacebits_ddraw_vb 867303             //  DirectDrawSurface4.GetLockedSurfaceBits
#define idh__dx_directdrawsurface4_getoverlaypositionx_ddraw_vb 867304              //  DirectDrawSurface4.GetOverlayPositionX
#define idh__dx_directdrawsurface4_getoverlaypositiony_ddraw_vb 867305              //  DirectDrawSurface4.GetOverlayPositionY
#define idh__dx_directdrawsurface4_getoverlayzordersenum_ddraw_vb 867306            //  DirectDrawSurface4.GetOverlayZOrdersEnum
#define idh__dx_directdrawsurface4_getpalette_ddraw_vb 867307                       //  DirectDrawSurface4.GetPalette
#define idh__dx_directdrawsurface4_getpixelformat_ddraw_vb 867308                   //  DirectDrawSurface4.GetPixelFormat
#define idh__dx_directdrawsurface4_getprivatedata_ddraw_vb 867309                   //  DirectDrawSurface4.GetPrivateData
#define idh__dx_directdrawsurface4_getprivatedatasize_ddraw_vb 867310               //  DirectDrawSurface4.GetPrivateDataSize
#define idh__dx_directdrawsurface4_getsurfacedesc_ddraw_vb 867311                   //  DirectDrawSurface4.GetSurfaceDesc
#define idh__dx_directdrawsurface4_gettexture_ddraw_vb 867312                       //  DirectDrawSurface4.GetTexture
#define idh__dx_directdrawsurface4_getuniquenessvalue_ddraw_vb 867313               //  DirectDrawSurface4.GetUniquenessValue
#define idh__dx_directdrawsurface4_islost_ddraw_vb 867314                           //  DirectDrawSurface4.IsLost
#define idh__dx_directdrawsurface4_lock_ddraw_vb 867315                             //  DirectDrawSurface4.Lock
#define idh__dx_directdrawsurface4_releasedc_ddraw_vb 867316                        //  DirectDrawSurface4.ReleaseDC
#define idh__dx_directdrawsurface4_restore_ddraw_vb 867317                          //  DirectDrawSurface4.Restore
#define idh__dx_directdrawsurface4_setclipper_ddraw_vb 867318                       //  DirectDrawSurface4.SetClipper
#define idh__dx_directdrawsurface4_setcolorkey_ddraw_vb 867319                      //  DirectDrawSurface4.SetColorKey
#define idh__dx_directdrawsurface4_setlockedpixel_ddraw_vb 867320                   //  DirectDrawSurface4.SetLockedPixel
#define idh__dx_directdrawsurface4_setlockedsurfacebits_ddraw_vb 867321             //  DirectDrawSurface4.SetLockedSurfaceBits
#define idh__dx_directdrawsurface4_setoverlayposition_ddraw_vb 867322               //  DirectDrawSurface4.SetOverlayPosition
#define idh__dx_directdrawsurface4_setpalette_ddraw_vb 867323                       //  DirectDrawSurface4.SetPalette
#define idh__dx_directdrawsurface4_setprivatedata_ddraw_vb 867324                   //  DirectDrawSurface4.SetPrivateData
#define idh__dx_directdrawsurface4_unlock_ddraw_vb 867325                           //  DirectDrawSurface4.Unlock
#define idh__dx_directdrawsurface4_updateoverlay_ddraw_vb 867326                    //  DirectDrawSurface4.UpdateOverlay
#define idh__dx_directdrawsurface4_updateoverlayzorder_ddraw_vb 867327              //  DirectDrawSurface4.UpdateOverlayZOrder
#define idh__dx_directx7_ddraw_vb 867328                                            //  DirectX7
#define idh__dx_ddbltfx_ddraw_vb 867329                                             //  DDBLTFX
#define idh__dx_ddcaps_ddraw_vb 867330                                              //  DDCAPS
#define idh__dx_ddcolorcontrol_ddraw_vb 867331                                      //  DDCOLORCONTROL
#define idh__dx_ddcolorkey_ddraw_vb 867332                                          //  DDCOLORKEY
#define idh__dx_ddgammaramp_ddraw_vb 867333                                         //  DDGAMMARAMP
#define idh__dx_ddoverlayfx_ddraw_vb 867334                                         //  DDOVERLAYFX
#define idh__dx_ddpixelformat_ddraw_vb 867335                                       //  DDPIXELFORMAT
#define idh__dx_ddscaps2_ddraw_vb 867336                                            //  DDSCAPS2
#define idh__dx_ddsurfacedesc2_ddraw_vb 867337                                      //  DDSURFACEDESC2
#define idh__dx_dxdriverinfo_ddraw_vb 867338                                        //  DXDRIVERINFO
#define idh__dx_paletteentry_ddraw_vb 867339                                        //  PALETTEENTRY
#define idh__dx_rect_ddraw_vb 867340                                                //  RECT
#define idh__dx_const_ddbitdepthflags_ddraw_vb 867341                               //  CONST_DDBITDEPTHFLAGS
#define idh__dx_const_ddbltfastflags_ddraw_vb 867342                                //  CONST_DDBLTFASTFLAGS
#define idh__dx_const_ddbltflags_ddraw_vb 867343                                    //  CONST_DDBLTFLAGS
#define idh__dx_const_ddbltfxflags_ddraw_vb 867344                                  //  CONST_DDBLTFXFLAGS
#define idh__dx_const_ddcaps1flags_ddraw_vb 867345                                  //  CONST_DDCAPS1FLAGS
#define idh__dx_const_ddcaps2flags_ddraw_vb 867346                                  //  CONST_DDCAPS2FLAGS
#define idh__dx_const_ddckeycapsflags_ddraw_vb 867347                               //  CONST_DDCKEYCAPSFLAGS
#define idh__dx_const_ddckeyflags_ddraw_vb 867348                                   //  CONST_DDCKEYFLAGS
#define idh__dx_const_ddcolorflags_ddraw_vb 867349                                  //  CONST_DDCOLORFLAGS
#define idh__dx_const_ddedmflags_ddraw_vb 867350                                    //  CONST_DDEDMFLAGS
#define idh__dx_const_ddenumoverlayzflags_ddraw_vb 867351                           //  CONST_DDENUMOVERLAYZFLAGS
#define idh__dx_const_ddenumsurfacesflags_ddraw_vb 867352                           //  CONST_DDENUMSURFACESFLAGS
#define idh__dx_const_ddflipflags_ddraw_vb 867353                                   //  CONST_DDFLIPFLAGS
#define idh__dx_const_ddfxalphacapsflags_ddraw_vb 867354                            //  CONST_DDFXALPHACAPSFLAGS
#define idh__dx_const_ddfxcapsflags_ddraw_vb 867355                                 //  CONST_DDFXCAPSFLAGS
#define idh__dx_const_ddgbsflags_ddraw_vb 867356                                    //  CONST_DDGBSFLAGS
#define idh__dx_const_ddgfsflags_ddraw_vb 867357                                    //  CONST_DDGFSFLAGS
#define idh__dx_const_ddlockflags_ddraw_vb 867358                                   //  CONST_DDLOCKFLAGS
#define idh__dx_const_ddoverflags_ddraw_vb 867359                                   //  CONST_DDOVERFLAGS
#define idh__dx_const_ddoverlayfxflags_ddraw_vb 867360                              //  CONST_DDOVERLAYFXFLAGS
#define idh__dx_const_ddoverzflags_ddraw_vb 867361                                  //  CONST_DDOVERZFLAGS
#define idh__dx_const_ddpcapsflags_ddraw_vb 867362                                  //  CONST_DDPCAPSFLAGS
#define idh__dx_const_ddpixelformatflags_ddraw_vb 867363                            //  CONST_DDPIXELFORMATFLAGS
#define idh__dx_const_ddraw_ddraw_vb 867364                                         //  CONST_DDRAW
#define idh__dx_const_ddsclflags_ddraw_vb 867365                                    //  CONST_DDSCLFLAGS
#define idh__dx_const_ddsdmflags_ddraw_vb 867366                                    //  CONST_DDSDMFLAGS
#define idh__dx_const_ddsgrflags_ddraw_vb 867367                                    //  CONST_DDSGRFLAGS
#define idh__dx_const_ddstereocapsflags_ddraw_vb 867368                             //  CONST_DDSTEREOCAPSFLAGS
#define idh__dx_const_ddsurfacecaps2flags_ddraw_vb 867369                           //  CONST_DDSURFACECAPS2FLAGS
#define idh__dx_const_ddsurfacecapsflags_ddraw_vb 867370                            //  CONST_DDSURFACECAPSFLAGS
#define idh__dx_const_ddsurfacedescflags_ddraw_vb 867371                            //  CONST_DDSURFACEDESCFLAGS
#define idh__dx_const_ddwaitvbflags_ddraw_vb 867372                                 //  CONST_DDWAITVBFLAGS
#define idh__dx_directinput_dinput_vb 867373                                        //  DirectInput
#define idh__dx_directinput_createdevice_dinput_vb 867374                           //  DirectInput.CreateDevice
#define idh__dx_directinput_getdevicestatus_dinput_vb 867375                        //  DirectInput.GetDeviceStatus
#define idh__dx_directinput_getdienumdevices_dinput_vb 867376                       //  DirectInput.GetDIEnumDevices
#define idh__dx_directinput_runcontrolpanel_dinput_vb 867377                        //  DirectInput.RunControlPanel
#define idh__dx_directinputdevice_dinput_vb 867378                                  //  DirectInputDevice
#define idh__dx_directinputdevice_acquire_dinput_vb 867379                          //  DirectInputDevice.Acquire
#define idh__dx_directinputdevice_getcapabilities_dinput_vb 867380                  //  DirectInputDevice.GetCapabilities
#define idh__dx_directinputdevice_getdevicedata_dinput_vb 867381                    //  DirectInputDevice.GetDeviceData
#define idh__dx_directinputdevice_getdeviceinfo_dinput_vb 867382                    //  DirectInputDevice.GetDeviceInfo
#define idh__dx_directinputdevice_getdienumdeviceobjects_dinput_vb 867383           //  DirectInputDevice.GetDeviceObjectsEnum
#define idh__dx_directinputdevice_getdevicestate_dinput_vb 867384                   //  DirectInputDevice.GetDeviceState
#define idh__dx_directinputdevice_getdevicestatejoystick_dinput_vb 867385           //  DirectInputDevice.GetDeviceStateJoystick
#define idh__dx_directinputdevice_getdevicestatejoystick2_dinput_vb 867386          //  DirectInputDevice.GetDeviceStateJoystick2
#define idh__dx_directinputdevice_getdevicestatekeyboard_dinput_vb 867387           //  DirectInputDevice.GetDeviceStateKeyboard
#define idh__dx_directinputdevice_getdevicestatemouse_dinput_vb 867388              //  DirectInputDevice.GetDeviceStateMouse
#define idh__dx_directinputdevice_getobjectinfo_dinput_vb 867389                    //  DirectInputDevice.GetObjectInfo
#define idh__dx_directinputdevice_getproperty_dinput_vb 867390                      //  DirectInputDevice.GetProperty
#define idh__dx_directinputdevice_poll_dinput_vb 867391                             //  DirectInputDevice.Poll
#define idh__dx_directinputdevice_runcontrolpanel_dinput_vb 867392                  //  DirectInputDevice.RunControlPanel
#define idh__dx_directinputdevice_setcooperativelevel_dinput_vb 867393              //  DirectInputDevice.SetCooperativeLevel
#define idh__dx_directinputdevice_setdataformat_dinput_vb 867394                    //  DirectInputDevice.SetDataFormat
#define idh__dx_directinputdevice_seteventnotification_dinput_vb 867395             //  DirectInputDevice.SetEventNotification
#define idh__dx_directinputdevice_setproperty_dinput_vb 867396                      //  DirectInputDevice.SetProperty
#define idh__dx_directinputdevice_unacquire_dinput_vb 867397                        //  DirectInputDevice.Unacquire
#define idh__dx_directinputenumdeviceobjects_dinput_vb 867398                       //  DirectInputEnumDeviceObjects
#define idh__dx_directinputenumdeviceobjects_getcount_dinput_vb 867399              //  DirectInputEnumDeviceObjects.GetCount
#define idh__dx_directinputenumdeviceobjects_getitem_dinput_vb 867400               //  DirectInputEnumDeviceObjects.GetItem
#define idh__dx_directinputenumdevices_dinput_vb 867401                             //  DirectInputEnumDevices
#define idh__dx_directinputenumdevices_getcount_dinput_vb 867402                    //  DirectInputEnumDevices.GetCount
#define idh__dx_directinputenumdevices_getitem_dinput_vb 867403                     //  DirectInputEnumDevices.GetItem
#define idh__dx_didataformat_dinput_vb 867404                                       //  DIDATAFORMAT
#define idh__dx_didevcaps_dinput_vb 867405                                          //  DIDEVCAPS
#define idh__dx_dideviceobjectdata_dinput_vb 867406                                 //  DIDEVICEOBJECTDATA
#define idh__dx_dijoystate_dinput_vb 867407                                         //  DIJOYSTATE
#define idh__dx_dijoystate2_desc_dinput_vb 867408                                   //  DIJOYSTATE2
#define idh__dx_dikeyboardstate_dinput_vb 867409                                    //  DIKEYBOARDSTATE
#define idh__dx_dimousestate_dinput_vb 867410                                       //  DIMOUSESTATE
#define idh__dx_diobjectdataformat_dinput_vb 867411                                 //  DIOBJECTDATAFORMAT
#define idh__dx_const_didataformatflags_dinput_vb 867412                            //  CONST_DIDATAFORMATFLAGS
#define idh__dx_const_didevcapsflags_dinput_vb 867413                               //  CONST_DIDEVCAPSFLAGS
#define idh__dx_const_dideviceobjinstaceflags_dinput_vb 867414                      //  CONST_DIDEVICEOBJINSTANCEFLAGS
#define idh__dx_const_didevicetype_dinput_vb 867415                                 //  CONST_DIDEVICETYPE
#define idh__dx_const_didftflags_dinput_vb 867416                                   //  CONST_DIDFTFLAGS
#define idh__dx_const_didgddflags_dinput_vb 867417                                  //  CONST_DIDGDDFLAGS
#define idh__dx_const_dienumdevicesflags_dinput_vb 867418                           //  CONST_DIENUMDEVICESFLAGS
#define idh__dx_const_dikeyflags_dinput_vb 867419                                   //  CONST_DIKEYFLAGS
#define idh__dx_const_dinputerr_dinput_vb 867420                                    //  CONST_DINPUTERR
#define idh__dx_const_diphflags_dinput_vb 867421                                    //  CONST_DIPHFLAGS
#define idh__dx_const_disclflags_dinput_vb 867422                                   //  CONST_DISCLFLAGS
#define idh__dx_keyboard_device_constants_dinput_vb 867423                          //  Keyboard Device Constants
#define idh__dx_directinput_and_japanese_keyboards_dinput_vb 867424                 //  DirectInput and Japanese Keyboards
#define idh__dx_mouse_device_constants_dinput_vb 867425                             //  Mouse Device Constants
#define idh__dx_joystick_device_constants_dinput_vb 867426                          //  Joystick Device Constants
#define idh__dx_directmusicband_dmusic_vb 867427                                    //  DirectMusicBand
#define idh__dx_directmusicband_createsegment_dmusic_vb 867428                      //  DirectMusicBand.CreateSegment
#define idh__dx_directmusicband_download_dmusic_vb 867429                           //  DirectMusicBand.Download
#define idh__dx_directmusicband_unload_dmusic_vb 867430                             //  DirectMusicBand.Unload
#define idh__dx_directmusicchordmap_dmusic_vb 867431                                //  DirectMusicChordMap
#define idh__dx_directmusiccollection_dmusic_vb 867432                              //  DirectMusicCollection
#define idh__dx_directmusiccomposer_dmusic_vb 867433                                //  DirectMusicComposer
#define idh__dx_directmusiccomposer_autotransition_dmusic_vb 867434                 //  DirectMusicComposer.AutoTransition
#define idh__dx_directmusiccomposer_changechordmap_dmusic_vb 867435                 //  DirectMusicComposer.ChangeChordMap
#define idh__dx_directmusiccomposer_composesegmentfromshape_dmusic_vb 867436        //  DirectMusicComposer.ComposeSegmentFromShape
#define idh__dx_directmusiccomposer_composesegmentfromtemplate_dmusic_vb 867437     //  DirectMusicComposer.ComposeSegmentFromTemplate
#define idh__dx_directmusiccomposer_composetemplatefromshape_dmusic_vb 867438       //  DirectMusicComposer.ComposeTemplateFromShape
#define idh__dx_directmusiccomposer_composetransition_dmusic_vb 867439              //  DirectMusicComposer.ComposeTransition
#define idh__dx_directmusicloader_dmusic_vb 867440                                  //  DirectMusicLoader
#define idh__dx_directmusicloader_loadband_dmusic_vb 867441                         //  DirectMusicLoader.LoadBand
#define idh__dx_directmusicloader_loadbandfromresource_dmusic_vb 867442             //  DirectMusicLoader.LoadBandFromResource
#define idh__dx_directmusicloader_loadcollection_dmusic_vb 867443                   //  DirectMusicLoader.LoadCollection
#define idh__dx_directmusicloader_loadcollectionfromresource_dmusic_vb 867444       //  DirectMusicLoader.LoadCollectionFromResource
#define idh__dx_directmusicloader_loadsegment_dmusic_vb 867445                      //  DirectMusicLoader.LoadSegment
#define idh__dx_directmusicloader_loadsegmentfromresource_dmusic_vb 867446          //  DirectMusicLoader.LoadSegmentFromResource
#define idh__dx_directmusicloader_loadstyle_dmusic_vb 867447                        //  DirectMusicLoader.LoadStyle
#define idh__dx_directmusicloader_loadstylefromresource_dmusic_vb 867448            //  DirectMusicLoader.LoadStyleFromResource
#define idh__dx_directmusicloader_setsearchdirectory_dmusic_vb 867449               //  DirectMusicLoader.SetSearchDirectory
#define idh__dx_directmusicperformance_dmusic_vb 867450                             //  DirectMusicPerformance
#define idh__dx_directmusicperformance_addnotificationtype_dmusic_vb 867451         //  DirectMusicPerformance.AddNotificationType
#define idh__dx_directmusicperformance_adjusttime_dmusic_vb 867452                  //  DirectMusicPerformance.AdjustTime
#define idh__dx_directmusicperformance_clocktomusictime_dmusic_vb 867453            //  DirectMusicPerformance.ClockToMusicTime
#define idh__dx_directmusicperformance_closedown_dmusic_vb 867454                   //  DirectMusicPerformance.CloseDown
#define idh__dx_directmusicperformance_getbumperlength_dmusic_vb 867455             //  DirectMusicPerformance.GetBumperLength
#define idh__dx_directmusicperformance_getchordmap_dmusic_vb 867456                 //  DirectMusicPerformance.GetChordmap
#define idh__dx_directmusicperformance_getclocktime_dmusic_vb 867457                //  DirectMusicPerformance.GetClockTime
#define idh__dx_directmusicperformance_getcommand_dmusic_vb 867458                  //  DirectMusicPerformance.GetCommand
#define idh__dx_directmusicperformance_getgroovelevel_dmusic_vb 867459              //  DirectMusicPerformance.GetGrooveLevel
#define idh__dx_directmusicperformance_getlatencytime_dmusic_vb 867460              //  DirectMusicPerformance.GetLatencyTime
#define idh__dx_directmusicperformance_getmasterautodownload_dmusic_vb 867461       //  DirectMusicPerformance.GetMasterAutoDownload
#define idh__dx_directmusicperformance_getmastergroovelevel_dmusic_vb 867462        //  DirectMusicPerformance.GetMasterGrooveLevel
#define idh__dx_directmusicperformance_getmastertempo_dmusic_vb 867463              //  DirectMusicPerformance.GetMasterTempo
#define idh__dx_directmusicperformance_getmastervolume_dmusic_vb 867464             //  DirectMusicPerformance.GetMasterVolume
#define idh__dx_directmusicperformance_getmusictime_dmusic_vb 867465                //  DirectMusicPerformance.GetMusicTime
#define idh__dx_directmusicperformance_getnotificationpmsg_dmusic_vb 867466         //  DirectMusicPerformance.GetNotificationPMsg
#define idh__dx_directmusicperformance_getportcaps_dmusic_vb 867467                 //  DirectMusicPerformance.GetPortCaps
#define idh__dx_directmusicperformance_getportcount_dmusic_vb 867468                //  DirectMusicPerformance.GetPortCount
#define idh__dx_directmusicperformance_getportname_dmusic_vb 867469                 //  DirectMusicPerformance.GetPortName
#define idh__dx_directmusicperformance_getpreparetime_dmusic_vb 867470              //  DirectMusicPerformance.GetPrepareTime
#define idh__dx_directmusicperformance_getqueuetime_dmusic_vb 867471                //  DirectMusicPerformance.GetQueueTime
#define idh__dx_directmusicperformance_getresolvedtime_dmusic_vb 867472             //  DirectMusicPerformance.GetResolvedTime
#define idh__dx_directmusicperformance_getsegmentstate_dmusic_vb 867473             //  DirectMusicPerformance.GetSegmentState
#define idh__dx_directmusicperformance_getstyle_dmusic_vb 867474                    //  DirectMusicPerformance.GetStyle
#define idh__dx_directmusicperformance_gettempo_dmusic_vb 867475                    //  DirectMusicPerformance.GetTempo
#define idh__dx_directmusicperformance_gettimesig_dmusic_vb 867476                  //  DirectMusicPerformance.GetTimeSig
#define idh__dx_directmusicperformance_gmreset_dmusic_vb 867477                     //  DirectMusicPerformance.GMReset
#define idh__dx_directmusicperformance_init_dmusic_vb 867478                        //  DirectMusicPerformance.Init
#define idh__dx_directmusicperformance_invalidate_dmusic_vb 867479                  //  DirectMusicPerformance.Invalidate
#define idh__dx_directmusicperformance_isplaying_dmusic_vb 867480                   //  DirectMusicPerformance.IsPlaying
#define idh__dx_directmusicperformance_musictoclocktime_dmusic_vb 867481            //  DirectMusicPerformance.MusicToClockTime
#define idh__dx_directmusicperformance_playsegment_dmusic_vb 867482                 //  DirectMusicPerformance.PlaySegment
#define idh__dx_directmusicperformance_removenotificationtype_dmusic_vb 867483      //  DirectMusicPerformance.RemoveNotificationType
#define idh__dx_directmusicperformance_sendcurvepmsg_dmusic_vb 867484               //  DirectMusicPerformance.SendCurvePMSG
#define idh__dx_directmusicperformance_sendmidipmsg_dmusic_vb 867485                //  DirectMusicPerformance.SendMIDIPMSG
#define idh__dx_directmusicperformance_sendnotepmsg_dmusic_vb 867486                //  DirectMusicPerformance.SendNotePMSG
#define idh__dx_directmusicperformance_sendpatchpmsg_dmusic_vb 867487               //  DirectMusicPerformance.SendPatchPMSG
#define idh__dx_directmusicperformance_sendtempopmsg_dmusic_vb 867488               //  DirectMusicPerformance.SendTempoPMSG
#define idh__dx_directmusicperformance_sendtimesigpmsg_dmusic_vb 867489             //  DirectMusicPerformance.SendTimeSigPMSG
#define idh__dx_directmusicperformance_sendtransposepmsg_dmusic_vb 867490           //  DirectMusicPerformance.SendTransposePMSG
#define idh__dx_directmusicperformance_setbumperlength_dmusic_vb 867491             //  DirectMusicPerformance.SetBumperLength
#define idh__dx_directmusicperformance_setmasterautodownload_dmusic_vb 867492       //  DirectMusicPerformance.SetMasterAutoDownload
#define idh__dx_directmusicperformance_setmastergroovelevel_dmusic_vb 867493        //  DirectMusicPerformance.SetMasterGrooveLevel
#define idh__dx_directmusicperformance_setmastertempo_dmusic_vb 867494              //  DirectMusicPerformance.SetMasterTempo
#define idh__dx_directmusicperformance_setmastervolume_dmusic_vb 867495             //  DirectMusicPerformance.SetMasterVolume
#define idh__dx_directmusicperformance_setnotificationhandle_dmusic_vb 867496       //  DirectMusicPerformance.SetNotificationHandle
#define idh__dx_directmusicperformance_setport_dmusic_vb 867497                     //  DirectMusicPerformance.SetPort
#define idh__dx_directmusicperformance_setpreparetime_dmusic_vb 867498              //  DirectMusicPerformance.SetPrepareTime
#define idh__dx_directmusicperformance_stop_dmusic_vb 867499                        //  DirectMusicPerformance.Stop
#define idh__dx_directmusicsegment_dmusic_vb 867500                                 //  DirectMusicSegment
#define idh__dx_directmusicsegment_clone_dmusic_vb 867501                           //  DirectMusicSegment.Clone
#define idh__dx_directmusicsegment_connecttocollection_dmusic_vb 867502             //  DirectMusicSegment.ConnectToCollection
#define idh__dx_directmusicsegment_download_dmusic_vb 867503                        //  DirectMusicSegment.Download
#define idh__dx_directmusicsegment_getlength_dmusic_vb 867504                       //  DirectMusicSegment.GetLength
#define idh__dx_directmusicsegment_getlooppointend_dmusic_vb 867505                 //  DirectMusicSegment.GetLoopPointEnd
#define idh__dx_directmusicsegment_getlooppointstart_dmusic_vb 867506               //  DirectMusicSegment.GetLoopPointStart
#define idh__dx_directmusicsegment_getrepeats_dmusic_vb 867507                      //  DirectMusicSegment.GetRepeats
#define idh__dx_directmusicsegment_getstartpoint_dmusic_vb 867508                   //  DirectMusicSegment.GetStartPoint
#define idh__dx_directmusicsegment_setautodownloadenable_dmusic_vb 867509           //  DirectMusicSegment.SetAutoDownloadEnable
#define idh__dx_directmusicsegment_setlength_dmusic_vb 867510                       //  DirectMusicSegment.SetLength
#define idh__dx_directmusicsegment_setlooppoints_dmusic_vb 867511                   //  DirectMusicSegment.SetLoopPoints
#define idh__dx_directmusicsegment_setrepeats_dmusic_vb 867512                      //  DirectMusicSegment.SetRepeats
#define idh__dx_directmusicsegment_setstandardmidifile_dmusic_vb 867513             //  DirectMusicSegment.SetStandardMidiFile
#define idh__dx_directmusicsegment_setstartpoint_dmusic_vb 867514                   //  DirectMusicSegment.SetStartPoint
#define idh__dx_directmusicsegment_settempoenable_dmusic_vb 867515                  //  DirectMusicSegment.SetTempoEnable
#define idh__dx_directmusicsegment_settimesigenable_dmusic_vb 867516                //  DirectMusicSegment.SetTimeSigEnable
#define idh__dx_directmusicsegment_unload_dmusic_vb 867517                          //  DirectMusicSegment.Unload
#define idh__dx_directmusicsegmentstate_dmusic_vb 867518                            //  DirectMusicSegmentState
#define idh__dx_directmusicsegmentstate_getrepeats_dmusic_vb 867519                 //  DirectMusicSegmentState.GetRepeats
#define idh__dx_directmusicsegmentstate_getseek_dmusic_vb 867520                    //  DirectMusicSegmentState.GetSeek
#define idh__dx_directmusicsegmentstate_getsegment_dmusic_vb 867521                 //  DirectMusicSegmentState.GetSegment
#define idh__dx_directmusicsegmentstate_getstartpoint_dmusic_vb 867522              //  DirectMusicSegmentState.GetStartPoint
#define idh__dx_directmusicsegmentstate_getstarttime_dmusic_vb 867523               //  DirectMusicSegmentState.GetStartTime
#define idh__dx_directmusicstyle_dmusic_vb 867524                                   //  DirectMusicStyle
#define idh__dx_directmusicstyle_getband_dmusic_vb 867525                           //  DirectMusicStyle.GetBand
#define idh__dx_directmusicstyle_getbandcount_dmusic_vb 867526                      //  DirectMusicStyle.GetBandCount
#define idh__dx_directmusicstyle_getbandname_dmusic_vb 867527                       //  DirectMusicStyle.GetBandName
#define idh__dx_directmusicstyle_getchordmap_dmusic_vb 867528                       //  DirectMusicStyle.GetChordmap
#define idh__dx_directmusicstyle_getchordmapcount_dmusic_vb 867529                  //  DirectMusicStyle.GetChordmapCount
#define idh__dx_directmusicstyle_getchordmapname_dmusic_vb 867530                   //  DirectMusicStyle.GetChordmapName
#define idh__dx_directmusicstyle_getdefaultband_dmusic_vb 867531                    //  DirectMusicStyle.GetDefaultBand
#define idh__dx_directmusicstyle_getdefaultchordmap_dmusic_vb 867532                //  DirectMusicStyle.GetDefaultChordMap
#define idh__dx_directmusicstyle_getmotif_dmusic_vb 867533                          //  DirectMusicStyle.GetMotif
#define idh__dx_directmusicstyle_getmotifcount_dmusic_vb 867534                     //  DirectMusicStyle.GetMotifCount
#define idh__dx_directmusicstyle_getmotifname_dmusic_vb 867535                      //  DirectMusicStyle.GetMotifName
#define idh__dx_directmusicstyle_gettempo_dmusic_vb 867536                          //  DirectMusicStyle.GetTempo
#define idh__dx_directmusicstyle_gettimesignature_dmusic_vb 867537                  //  DirectMusicStyle.GetTimeSignature
#define idh__dx_dmus_curve_pmsg_dmusic_vb 867538                                    //  DMUS_CURVE_PMSG
#define idh__dx_dmus_note_pmsg_dmusic_vb 867539                                     //  DMUS_NOTE_PMSG
#define idh__dx_dmus_notification_pmsg_dmusic_vb 867540                             //  DMUS_NOTIFICATION_PMSG
#define idh__dx_dmus_portcaps_dmusic_vb 867541                                      //  DMUS_PORTCAPS
#define idh__dx_dmus_timesignature_dmusic_vb 867542                                 //  DMUS_TIMESIGNATURE
#define idh__dx_const_dmus_notificationtype_dmusic_vb 867543                        //  CONST_DMUS_NOTIFICATIONTYPE
#define idh__dx_enumdmus_commandt_types_dmusic_vb 867544                            //  enumDMUS_COMMANDT_TYPES
#define idh__dx_enumdmus_composef_flags_dmusic_vb 867545                            //  enumDMUS_COMPOSEF_FLAGS
#define idh__dx_enumdmus_playmode_flags_dmusic_vb 867546                            //  enumDMUS_PLAYMODE_FLAGS
#define idh__dx_enumdmus_pmsgf_flags_dmusic_vb 867547                               //  enumDMUS_PMSGF_FLAGS
#define idh__dx_enumdmus_segf_flags_dmusic_vb 867548                                //  enumDMUS_SEGF_FLAGS
#define idh__dx_enumdmus_shapet_types_dmusic_vb 867549                              //  enumDMUS_SHAPET_TYPES
#define idh__dx_directplay4_dplay_vb 867550                                         //  DirectPlay4
#define idh__dx_directplay4_addgrouptogroup_dplay_vb 867551                         //  DirectPlay4.AddGroupToGroup
#define idh__dx_directplay4_addplayertogroup_dplay_vb 867552                        //  DirectPlay4.AddPlayerToGroup
#define idh__dx_directplay4_cancelmessage_dplay_vb 867553                           //  DirectPlay4.CancelMessage
#define idh__dx_directplay4_cancelpriority_dplay_vb 867554                          //  DirectPlay4.CancelPriority
#define idh__dx_directplay4_close_dplay_vb 867555                                   //  DirectPlay4.Close
#define idh__dx_directplay4_creategroup_dplay_vb 867556                             //  DirectPlay4.CreateGroup
#define idh__dx_directplay4_creategroupingroup_dplay_vb 867557                      //  DirectPlay4.CreateGroupInGroup
#define idh__dx_directplay4_createmessage_dplay_vb 867558                           //  DirectPlay4.CreateMessage
#define idh__dx_directplay4_createplayer_dplay_vb 867559                            //  DirectPlay4.CreatePlayer
#define idh__dx_directplay4_createsessiondata_dplay_vb 867560                       //  DirectPlay4.CreateSessionData
#define idh__dx_directplay4_deletegroupfromgroup_dplay_vb 867561                    //  DirectPlay4.DeleteGroupFromGroup
#define idh__dx_directplay4_deleteplayerfromgroup_dplay_vb 867562                   //  DirectPlay4.DeletePlayerFromGroup
#define idh__dx_directplay4_destroygroup_dplay_vb 867563                            //  DirectPlay4.DestroyGroup
#define idh__dx_directplay4_destroyplayer_dplay_vb 867564                           //  DirectPlay4.DestroyPlayer
#define idh__dx_directplay4_getcaps_dplay_vb 867565                                 //  DirectPlay4.GetCaps
#define idh__dx_directplay4_getdpenumconnections_dplay_vb 867566                    //  DirectPlay4.GetDPEnumConnections
#define idh__dx_directplay4_getdpenumgroupplayers_dplay_vb 867567                   //  DirectPlay4.GetDPEnumGroupPlayers
#define idh__dx_directplay4_getdpenumgroups_dplay_vb 867568                         //  DirectPlay4.GetDPEnumGroups
#define idh__dx_directplay4_getdpenumgroupsingroup_dplay_vb 867569                  //  DirectPlay4.GetDPEnumGroupsInGroup
#define idh__dx_directplay4_getdpenumplayers_dplay_vb 867570                        //  DirectPlay4.GetDPEnumPlayers
#define idh__dx_directplay4_getdpenumsessions_dplay_vb 867571                       //  DirectPlay4.GetDPEnumSessions
#define idh__dx_directplay4_getgroupdata_dplay_vb 867572                            //  DirectPlay4.GetGroupData
#define idh__dx_directplay4_getgroupflags_dplay_vb 867573                           //  DirectPlay4.GetGroupFlags
#define idh__dx_directplay4_getgrouplongname_dplay_vb 867574                        //  DirectPlay4.GetGroupLongName
#define idh__dx_directplay4_getgroupowner_dplay_vb 867575                           //  DirectPlay4.GetGroupOwner
#define idh__dx_directplay4_getgroupparent_dplay_vb 867576                          //  DirectPlay4.GetGroupParent
#define idh__dx_directplay4_getgroupshortname_dplay_vb 867577                       //  DirectPlay4.GetGroupShortName
#define idh__dx_directplay4_getmessagecount_dplay_vb 867578                         //  DirectPlay4.GetMessageCount
#define idh__dx_directplay4_getmessagequeue_dplay_vb 867579                         //  DirectPlay4.GetMessageQueue
#define idh__dx_directplay4_getplayeraccountid_dplay_vb 867580                      //  DirectPlay4.GetPlayerAccountId
#define idh__dx_directplay4_getplayeraddress_dplay_vb 867581                        //  DirectPlay4.GetPlayerAddress
#define idh__dx_directplay4_getplayercaps_dplay_vb 867582                           //  DirectPlay4.GetPlayerCaps
#define idh__dx_directplay4_getplayerdata_dplay_vb 867583                           //  DirectPlay4.GetPlayerData
#define idh__dx_directplay4_getplayerflags_dplay_vb 867584                          //  DirectPlay4.GetPlayerFlags
#define idh__dx_directplay4_getplayerformalname_dplay_vb 867585                     //  DirectPlay4.GetPlayerFormalName
#define idh__dx_directplay4_getplayerfriendlyname_dplay_vb 867586                   //  DirectPlay4.GetPlayerFriendlyName
#define idh__dx_directplay4_getsessiondesc_dplay_vb 867587                          //  DirectPlay4.GetSessionDesc
#define idh__dx_directplay4_initializeconnection_dplay_vb 867588                    //  DirectPlay4.InitializeConnection
#define idh__dx_directplay4_open_dplay_vb 867589                                    //  DirectPlay4.Open
#define idh__dx_directplay4_receive_dplay_vb 867590                                 //  DirectPlay4.Receive
#define idh__dx_directplay4_secureopen_dplay_vb 867591                              //  DirectPlay4.SecureOpen
#define idh__dx_directplay4_send_dplay_vb 867592                                    //  DirectPlay4.Send
#define idh__dx_directplay4_sendchatmessage_dplay_vb 867593                         //  DirectPlay4.SendChatMessage
#define idh__dx_directplay4_sendex_dplay_vb 867594                                  //  DirectPlay4.SendEx
#define idh__dx_directplay4_setgroupconnectionsettings_dplay_vb 867595              //  DirectPlay4.SetGroupConnectionSettings
#define idh__dx_directplay4_setgroupdata_dplay_vb 867596                            //  DirectPlay4.SetGroupData
#define idh__dx_directplay4_setgroupname_dplay_vb 867597                            //  DirectPlay4.SetGroupName
#define idh__dx_directplay4_setgroupowner_dplay_vb 867598                           //  DirectPlay4.SetGroupOwner
#define idh__dx_directplay4_setplayerdata_dplay_vb 867599                           //  DirectPlay4.SetPlayerData
#define idh__dx_directplay4_setplayername_dplay_vb 867600                           //  DirectPlay4.SetPlayerName
#define idh__dx_directplay4_setsessiondesc_dplay_vb 867601                          //  DirectPlay4.SetSessionDesc
#define idh__dx_directplay4_startsession_dplay_vb 867602                            //  DirectPlay4.StartSession
#define idh__dx_directplayaddress_dplay_vb 867603                                   //  DirectPlayAddress
#define idh__dx_directplayenumaddress_dplay_vb 867604                               //  DirectPlayEnumAddress
#define idh__dx_directplayenumaddress_getcount_dplay_vb 867605                      //  DirectPlayEnumAddress.GetCount
#define idh__dx_directplayenumaddress_getdata_dplay_vb 867606                       //  DirectPlayEnumAddress.GetData
#define idh__dx_directplayenumaddress_gettype_dplay_vb 867607                       //  DirectPlayEnumAddress.GetType
#define idh__dx_directplayenumaddresstypes_dplay_vb 867608                          //  DirectPlayEnumAddressTypes
#define idh__dx_directplayenumaddresstypes_getcount_dplay_vb 867609                 //  DirectPlayEnumAddressTypes.GetCount
#define idh__dx_directplayenumaddresstypes_gettype_dplay_vb 867610                  //  DirectPlayEnumAddressTypes.GetType
#define idh__dx_directplayenumconnections_dplay_vb 867611                           //  DirectPlayEnumConnections
#define idh__dx_directplayenumconnections_getaddress_dplay_vb 867612                //  DirectPlayEnumConnections.GetAddress
#define idh__dx_directplayenumconnections_getcount_dplay_vb 867613                  //  DirectPlayEnumConnections.GetCount
#define idh__dx_directplayenumconnections_getflags_dplay_vb 867614                  //  DirectPlayEnumConnections.GetFlags
#define idh__dx_directplayenumconnections_getguid_dplay_vb 867615                   //  DirectPlayEnumConnections.GetGuid
#define idh__dx_directplayenumconnections_getshortname_dplay_vb 867616              //  DirectPlayEnumConnections.GetName
#define idh__dx_directplayenumlocalapplications_dplay_vb 867617                     //  DirectPlayEnumLocalApplications
#define idh__dx_directplayenumlocalapplications_getcount_dplay_vb 867618            //  DirectPlayEnumLocalApplications.GetCount
#define idh__dx_directplayenumlocalapplications_getguid_dplay_vb 867619             //  DirectPlayEnumLocalApplications.GetGuid
#define idh__dx_directplayenumlocalapplications_getname_dplay_vb 867620             //  DirectPlayEnumLocalApplications.GetName
#define idh__dx_directplayenumplayers_dplay_vb 867621                               //  DirectPlayEnumPlayers
#define idh__dx_directplayenumplayers_getcount_dplay_vb 867622                      //  DirectPlayEnumPlayers.GetCount
#define idh__dx_directplayenumplayers_getdpid_dplay_vb 867623                       //  DirectPlayEnumPlayers.GetDPID
#define idh__dx_directplayenumplayers_getflags_dplay_vb 867624                      //  DirectPlayEnumPlayers.GetFlags
#define idh__dx_directplayenumplayers_getlongname_dplay_vb 867625                   //  DirectPlayEnumPlayers.GetLongName
#define idh__dx_directplayenumplayers_getshortname_dplay_vb 867626                  //  DirectPlayEnumPlayers.GetShortName
#define idh__dx_directplayenumplayers_gettype_dplay_vb 867627                       //  DirectPlayEnumPlayers.GetType
#define idh__dx_directplayenumserviceproviders_dplay_vb 867628                      //  DirectPlayEnumServiceProviders
#define idh__dx_directplayenumserviceproviders_getcount_dplay_vb 867629             //  DirectPlayEnumServiceProviders.GetCount
#define idh__dx_directplayenumserviceproviders_getguid_dplay_vb 867630              //  DirectPlayEnumServiceProviders.GetGuid
#define idh__dx_directplayenumserviceproviders_getname_dplay_vb 867631              //  DirectPlayEnumServiceProviders.GetName
#define idh__dx_directplayenumserviceproviders_getversion_dplay_vb 867632           //  DirectPlayEnumServiceProviders.GetVersion
#define idh__dx_directplayenumsessions_dplay_vb 867633                              //  DirectPlayEnumSessions
#define idh__dx_directplayenumsessions_getcount_dplay_vb 867634                     //  DirectPlayEnumSessions.GetCount
#define idh__dx_directplayenumsessions_getitem_dplay_vb 867635                      //  DirectPlayEnumSessions.GetItem
#define idh__dx_directplaylobby3_dplay_vb 867636                                    //  DirectPlayLobby3
#define idh__dx_directplaylobby3_connect_dplay_vb 867637                            //  DirectPlayLobby3.Connect
#define idh__dx_directplaylobby3_createaddress_dplay_vb 867638                      //  DirectPlayLobby3.CreateAddress
#define idh__dx_directplaylobby3_createcompoundaddress_dplay_vb 867639              //  DirectPlayLobby3.CreateCompoundAddress
#define idh__dx_directplaylobby3_createconnectiondata_dplay_vb 867640               //  DirectPlayLobby3.CreateConnectionData
#define idh__dx_directplaylobby3_createmessage_dplay_vb 867641                      //  DirectPlayLobby3.CreateMessage
#define idh__dx_directplaylobby3_getconnectionsettings_dplay_vb 867642              //  DirectPlayLobby3.GetConnectionSettings
#define idh__dx_directplaylobby3_getdpenumaddress_dplay_vb 867643                   //  DirectPlayLobby3.GetDPEnumAddress
#define idh__dx_directplaylobby3_getdpenumaddresstypes_dplay_vb 867644              //  DirectPlayLobby3.GetDPEnumAddressTypes
#define idh__dx_directplaylobby3_getdpenumlocalapplications_dplay_vb 867645         //  DirectPlayLobby3.GetDPEnumLocalApplications
#define idh__dx_directplaylobby3_receivelobbymessage_dplay_vb 867646                //  DirectPlayLobby3.ReceiveLobbyMessage
#define idh__dx_directplaylobby3_registerapplication_dplay_vb 867647                //  DirectPlayLobby3.RegisterApplication
#define idh__dx_directplaylobby3_runapplication_dplay_vb 867648                     //  DirectPlayLobby3.RunApplication
#define idh__dx_directplaylobby3_sendlobbymessage_dplay_vb 867649                   //  DirectPlayLobby3.SendLobbyMessage
#define idh__dx_directplaylobby3_setconnectionsettings_dplay_vb 867650              //  DirectPlayLobby3.SetConnectionSettings
#define idh__dx_directplaylobby3_setlobbymessageevent_dplay_vb 867651               //  DirectPlayLobby3.SetLobbyMessageEvent
#define idh__dx_directplaylobby3_unregisterapplication_dplay_vb 867652              //  DirectPlayLobby3.UnregisterApplication
#define idh__dx_directplaylobby3_waitforconnectionsettings_dplay_vb 867653          //  DirectPlayLobby3.WaitForConnectionSettings
#define idh__dx_directplaylobbyconnection_dplay_vb 867654                           //  DirectPlayLobbyConnection
#define idh__dx_directplaylobbyconnection_getaddress_dplay_vb 867655                //  DirectPlayLobbyConnection.GetAddress
#define idh__dx_directplaylobbyconnection_getflags_dplay_vb 867656                  //  DirectPlayLobbyConnection.GetFlags
#define idh__dx_directplaylobbyconnection_getguidsp_dplay_vb 867657                 //  DirectPlayLobbyConnection.GetGuidSP
#define idh__dx_directplaylobbyconnection_getplayerlongname_dplay_vb 867658         //  DirectPlayLobbyConnection.GetPlayerLongName
#define idh__dx_directplaylobbyconnection_getplayershortname_dplay_vb 867659        //  DirectPlayLobbyConnection.GetPlayerShortName
#define idh__dx_directplaylobbyconnection_getsessiondesc_dplay_vb 867660            //  DirectPlayLobbyConnection.GetSessionDesc
#define idh__dx_directplaylobbyconnection_setaddress_dplay_vb 867661                //  DirectPlayLobbyConnection.SetAddress
#define idh__dx_directplaylobbyconnection_setflags_dplay_vb 867662                  //  DirectPlayLobbyConnection.SetFlags
#define idh__dx_directplaylobbyconnection_setguidsp_dplay_vb 867663                 //  DirectPlayLobbyConnection.SetGuidSP
#define idh__dx_directplaylobbyconnection_setplayerlongname_dplay_vb 867664         //  DirectPlayLobbyConnection.SetPlayerLongName
#define idh__dx_directplaylobbyconnection_setplayershortname_dplay_vb 867665        //  DirectPlayLobbyConnection.SetPlayerShortName
#define idh__dx_directplaylobbyconnection_setsessiondesc_dplay_vb 867666            //  DirectPlayLobbyConnection.SetSessionDesc
#define idh__dx_directplaymessage_dplay_vb 867667                                   //  DirectPlayMessage
#define idh__dx_directplaymessage_clear_dplay_vb 867668                             //  DirectPlayMessage.Clear
#define idh__dx_directplaymessage_getmessagedata_dplay_vb 867669                    //  DirectPlayMessage.GetMessageData
#define idh__dx_directplaymessage_getmessagesize_dplay_vb 867670                    //  DirectPlayMessage.GetMessageSize
#define idh__dx_directplaymessage_movetotop_dplay_vb 867671                         //  DirectPlayMessage.MoveToTop
#define idh__dx_directplaymessage_readbyte_dplay_vb 867672                          //  DirectPlayMessage.ReadByte
#define idh__dx_directplaymessage_readdouble_dplay_vb 867673                        //  DirectPlayMessage.ReadDouble
#define idh__dx_directplaymessage_readguid_dplay_vb 867674                          //  DirectPlayMessage.ReadGuid
#define idh__dx_directplaymessage_readlong_dplay_vb 867675                          //  DirectPlayMessage.ReadLong
#define idh__dx_directplaymessage_readshort_dplay_vb 867676                         //  DirectPlayMessage.ReadShort
#define idh__dx_directplaymessage_readsingle_dplay_vb 867677                        //  DirectPlayMessage.ReadSingle
#define idh__dx_directplaymessage_readstring_dplay_vb 867678                        //  DirectPlayMessage.ReadString
#define idh__dx_directplaymessage_setmessagedata_dplay_vb 867679                    //  DirectPlayMessage.SetMessageData
#define idh__dx_directplaymessage_writebyte_dplay_vb 867680                         //  DirectPlayMessage.WriteByte
#define idh__dx_directplaymessage_writedouble_dplay_vb 867681                       //  DirectPlayMessage.WriteDouble
#define idh__dx_directplaymessage_writeguid_dplay_vb 867682                         //  DirectPlayMessage.WriteGuid
#define idh__dx_directplaymessage_writelong_dplay_vb 867683                         //  DirectPlayMessage.WriteLong
#define idh__dx_directplaymessage_writeshort_dplay_vb 867684                        //  DirectPlayMessage.WriteShort
#define idh__dx_directplaymessage_writesingle_dplay_vb 867685                       //  DirectPlayMessage.WriteSingle
#define idh__dx_directplaymessage_writestring_dplay_vb 867686                       //  DirectPlayMessage.WriteString
#define idh__dx_directplaysessiondata_dplay_vb 867687                               //  DirectPlaySessionData
#define idh__dx_directplaysessiondata_getcurrentplayers_dplay_vb 867688             //  DirectPlaySessionData.GetCurrentPlayers
#define idh__dx_directplaysessiondata_getflags_dplay_vb 867689                      //  DirectPlaySessionData.GetFlags
#define idh__dx_directplaysessiondata_getguidapplication_dplay_vb 867690            //  DirectPlaySessionData.GetGuidApplication
#define idh__dx_directplaysessiondata_getguidinstance_dplay_vb 867691               //  DirectPlaySessionData.GetGuidInstance
#define idh__dx_directplaysessiondata_getmaxplayers_dplay_vb 867692                 //  DirectPlaySessionData.GetMaxPlayers
#define idh__dx_directplaysessiondata_getsessionname_dplay_vb 867693                //  DirectPlaySessionData.GetSessionName
#define idh__dx_directplaysessiondata_getsessionpassword_dplay_vb 867694            //  DirectPlaySessionData.GetSessionPassword
#define idh__dx_directplaysessiondata_getuser_n__dplay_vb 867695                    //  DirectPlaySessionData.GetUser(n)
#define idh__dx_directplaysessiondata_setflags_dplay_vb 867696                      //  DirectPlaySessionData.SetFlags
#define idh__dx_directplaysessiondata_setguidapplication_dplay_vb 867697            //  DirectPlaySessionData.SetGuidApplication
#define idh__dx_directplaysessiondata_setguidinstance_dplay_vb 867698               //  DirectPlaySessionData.SetGuidInstance
#define idh__dx_directplaysessiondata_setmaxplayers_dplay_vb 867699                 //  DirectPlaySessionData.SetMaxPlayers
#define idh__dx_directplaysessiondata_setsessionname_dplay_vb 867700                //  DirectPlaySessionData.SetSessionName
#define idh__dx_directplaysessiondata_setsessionpassword_dplay_vb 867701            //  DirectPlaySessionData.SetSessionPassword
#define idh__dx_directplaysessiondata_setuser_n__dplay_vb 867702                    //  DirectPlaySessionData.SetUser(n)
#define idh__dx_dpapplicationdesc_dplay_vb 867703                                   //  DPAPPLICATIONDESC
#define idh__dx_dpcaps_dplay_vb 867704                                              //  DPCAPS
#define idh__dx_dpcompoundaddresselement_dplay_vb 867705                            //  DPCOMPOUNDADDRESSELEMENT
#define idh__dx_dpcredentials_dplay_vb 867706                                       //  DPCREDENTIALS
#define idh__dx_dpplayerids_dplay_vb 867707                                         //  DPPLAYERIDS
#define idh__dx_dpsecuritydesc_dplay_vb 867708                                      //  DPSECURITYDESC
#define idh__dx_const_dpcapsflags_dplay_vb 867709                                   //  CONST_DPCAPSFLAGS
#define idh__dx_const_dpconnectflags_dplay_vb 867710                                //  CONST_DPCONNECTFLAGS
#define idh__dx_const_dpenumconnectionflags_dplay_vb 867711                         //  CONST_DPENUMCONNECTIONFLAGS
#define idh__dx_const_dpenumgroupflags_dplay_vb 867712                              //  CONST_DPENUMGROUPFLAGS
#define idh__dx_const_dpenumplayerflags_dplay_vb 867713                             //  CONST_DPENUMPLAYERFLAGS
#define idh__dx_const_dpenumsessionflags_dplay_vb 867714                            //  CONST_DPENUMSESSIONFLAGS
#define idh__dx_const_dpgetcapsflags_dplay_vb 867715                                //  CONST_DPGETCAPSFLAGS
#define idh__dx_const_dpgetflags_dplay_vb 867716                                    //  CONST_DPGETFLAGS
#define idh__dx_const_dpgroupflags_dplay_vb 867717                                  //  CONST_DPGROUPFLAGS
#define idh__dx_const_dpidflags_dplay_vb 867718                                     //  CONST_DPIDFLAGS
#define idh__dx_const_dpplayerflags_dplay_vb 867719                                 //  CONST_DPPLAYERFLAGS
#define idh__dx_const_dpsessionflags_dplay_vb 867720                                //  CONST_DPSESSIONFLAGS
#define idh__dx_const_dpsetflags_dplay_vb 867721                                    //  CONST_DPSETFLAGS
#define idh__dx_directsound_dsound_vb 867722                                        //  DirectSound
#define idh__dx_directsound_compact_dsound_vb 867723                                //  DirectSound.Compact
#define idh__dx_directsound_createsoundbuffer_dsound_vb 867724                      //  DirectSound.CreateSoundBuffer
#define idh__dx_directsound_createsoundbufferfromfile_dsound_vb 867725              //  DirectSound.CreateSoundBufferFromFile
#define idh__dx_directsound_createsoundbufferfromresource_dsound_vb 867726          //  DirectSound.CreateSoundBufferFromResource
#define idh__dx_directsound_duplicatesoundbuffer_dsound_vb 867727                   //  DirectSound.DuplicateSoundBuffer
#define idh__dx_directsound_getcaps_dsound_vb 867728                                //  DirectSound.GetCaps
#define idh__dx_directsound_getspeakerconfig_dsound_vb 867729                       //  DirectSound.GetSpeakerConfig
#define idh__dx_directsound_setcooperativelevel_dsound_vb 867730                    //  DirectSound.SetCooperativeLevel
#define idh__dx_directsound_setspeakerconfig_dsound_vb 867731                       //  DirectSound.SetSpeakerConfig
#define idh__dx_directsound3dbuffer_dsound_vb 867732                                //  DirectSounD3DBuffer
#define idh__dx_directsound3dbuffer_getallparameters_dsound_vb 867733               //  DirectSounD3DBuffer.GetAllParameters
#define idh__dx_directsound3dbuffer_getconeangles_dsound_vb 867734                  //  DirectSounD3DBuffer.GetConeAngles
#define idh__dx_directsound3dbuffer_getconeorientation_dsound_vb 867735             //  DirectSounD3DBuffer.GetConeOrientation
#define idh__dx_directsound3dbuffer_getconeoutsidevolume_dsound_vb 867736           //  DirectSounD3DBuffer.GetConeOutsideVolume
#define idh__dx_directsound3dbuffer_getdirectsound3dlistener_dsound_vb 867737       //  DirectSounD3DBuffer.GetDirectSounD3DListener
#define idh__dx_directsound3dbuffer_getdirectsoundbuffer_dsound_vb 867738           //  DirectSounD3DBuffer.GetDirectSoundBuffer
#define idh__dx_directsound3dbuffer_getmaxdistance_dsound_vb 867739                 //  DirectSounD3DBuffer.GetMaxDistance
#define idh__dx_directsound3dbuffer_getmindistance_dsound_vb 867740                 //  DirectSounD3DBuffer.GetMinDistance
#define idh__dx_directsound3dbuffer_getmode_dsound_vb 867741                        //  DirectSounD3DBuffer.GetMode
#define idh__dx_directsound3dbuffer_getposition_dsound_vb 867742                    //  DirectSounD3DBuffer.GetPosition
#define idh__dx_directsound3dbuffer_getvelocity_dsound_vb 867743                    //  DirectSounD3DBuffer.GetVelocity
#define idh__dx_directsound3dbuffer_setallparameters_dsound_vb 867744               //  DirectSounD3DBuffer.SetAllParameters
#define idh__dx_directsound3dbuffer_setconeangles_dsound_vb 867745                  //  DirectSounD3DBuffer.SetConeAngles
#define idh__dx_directsound3dbuffer_setconeorientation_dsound_vb 867746             //  DirectSounD3DBuffer.SetConeOrientation
#define idh__dx_directsound3dbuffer_setconeoutsidevolume_dsound_vb 867747           //  DirectSounD3DBuffer.SetConeOutsideVolume
#define idh__dx_directsound3dbuffer_setmaxdistance_dsound_vb 867748                 //  DirectSounD3DBuffer.SetMaxDistance
#define idh__dx_directsound3dbuffer_setmindistance_dsound_vb 867749                 //  DirectSounD3DBuffer.SetMinDistance
#define idh__dx_directsound3dbuffer_setmode_dsound_vb 867750                        //  DirectSounD3DBuffer.SetMode
#define idh__dx_directsound3dbuffer_setposition_dsound_vb 867751                    //  DirectSounD3DBuffer.SetPosition
#define idh__dx_directsound3dbuffer_setvelocity_dsound_vb 867752                    //  DirectSounD3DBuffer.SetVelocity
#define idh__dx_directsound3dlistener_dsound_vb 867753                              //  DirectSounD3DListener
#define idh__dx_directsound3dlistener_commitdeferredsettings_dsound_vb 867754       //  DirectSounD3DListener.CommitDeferredSettings
#define idh__dx_directsound3dlistener_getallparameters_dsound_vb 867755             //  DirectSounD3DListener.GetAllParameters
#define idh__dx_directsound3dlistener_getdirectsoundbuffer_dsound_vb 867756         //  DirectSounD3DListener.GetDirectSoundBuffer
#define idh__dx_directsound3dlistener_getdistancefactor_dsound_vb 867757            //  DirectSounD3DListener.GetDistanceFactor
#define idh__dx_directsound3dlistener_getdopplerfactor_dsound_vb 867758             //  DirectSounD3DListener.GetDopplerFactor
#define idh__dx_directsound3dlistener_getorientation_dsound_vb 867759               //  DirectSounD3DListener.GetOrientation
#define idh__dx_directsound3dlistener_getposition_dsound_vb 867760                  //  DirectSounD3DListener.GetPosition
#define idh__dx_directsound3dlistener_getrollofffactor_dsound_vb 867761             //  DirectSounD3DListener.GetRolloffFactor
#define idh__dx_directsound3dlistener_getvelocity_dsound_vb 867762                  //  DirectSounD3DListener.GetVelocity
#define idh__dx_directsound3dlistener_setallparameters_dsound_vb 867763             //  DirectSounD3DListener.SetAllParameters
#define idh__dx_directsound3dlistener_setdistancefactor_dsound_vb 867764            //  DirectSounD3DListener.SetDistanceFactor
#define idh__dx_directsound3dlistener_setdopplerfactor_dsound_vb 867765             //  DirectSounD3DListener.SetDopplerFactor
#define idh__dx_directsound3dlistener_setorientation_dsound_vb 867766               //  DirectSounD3DListener.SetOrientation
#define idh__dx_directsound3dlistener_setposition_dsound_vb 867767                  //  DirectSounD3DListener.SetPosition
#define idh__dx_directsound3dlistener_setrollofffactor_dsound_vb 867768             //  DirectSounD3DListener.SetRolloffFactor
#define idh__dx_directsound3dlistener_setvelocity_dsound_vb 867769                  //  DirectSounD3DListener.SetVelocity
#define idh__dx_directsoundbuffer_dsound_vb 867770                                  //  DirectSoundBuffer
#define idh__dx_directsoundbuffer_getcaps_dsound_vb 867771                          //  DirectSoundBuffer.GetCaps
#define idh__dx_directsoundbuffer_getcurrentposition_dsound_vb 867772               //  DirectSoundBuffer.GetCurrentPosition
#define idh__dx_directsoundbuffer_getdirectsound3dbuffer_dsound_vb 867773           //  DirectSoundBuffer.GetDirectSounD3DBuffer
#define idh__dx_directsoundbuffer_getdirectsound3dlistener_dsound_vb 867774         //  DirectSoundBuffer.GetDirectSounD3DListener
#define idh__dx_directsoundbuffer_getformat_dsound_vb 867775                        //  DirectSoundBuffer.GetFormat
#define idh__dx_directsoundbuffer_getfrequency_dsound_vb 867776                     //  DirectSoundBuffer.GetFrequency
#define idh__dx_directsoundbuffer_getpan_dsound_vb 867777                           //  DirectSoundBuffer.GetPan
#define idh__dx_directsoundbuffer_getstatus_dsound_vb 867778                        //  DirectSoundBuffer.GetStatus
#define idh__dx_directsoundbuffer_getvolume_dsound_vb 867779                        //  DirectSoundBuffer.GetVolume
#define idh__dx_directsoundbuffer_play_dsound_vb 867780                             //  DirectSoundBuffer.Play
#define idh__dx_directsoundbuffer_readbuffer_dsound_vb 867781                       //  DirectSoundBuffer.ReadBuffer
#define idh__dx_directsoundbuffer_restore_dsound_vb 867782                          //  DirectSoundBuffer.Restore
#define idh__dx_directsoundbuffer_setcurrentposition_dsound_vb 867783               //  DirectSoundBuffer.SetCurrentPosition
#define idh__dx_directsoundbuffer_setformat_dsound_vb 867784                        //  DirectSoundBuffer.SetFormat
#define idh__dx_directsoundbuffer_setfrequency_dsound_vb 867785                     //  DirectSoundBuffer.SetFrequency
#define idh__dx_directsoundbuffer_setnotificationpositions_dsound_vb 867786         //  DirectSoundBuffer.SetNotificationPositions
#define idh__dx_directsoundbuffer_setpan_dsound_vb 867787                           //  DirectSoundBuffer.SetPan
#define idh__dx_directsoundbuffer_setvolume_dsound_vb 867788                        //  DirectSoundBuffer.SetVolume
#define idh__dx_directsoundbuffer_stop_dsound_vb 867789                             //  DirectSoundBuffer.Stop
#define idh__dx_directsoundbuffer_writebuffer_dsound_vb 867790                      //  DirectSoundBuffer.WriteBuffer
#define idh__dx_directsoundcapture_dsound_vb 867791                                 //  DirectSoundCapture
#define idh__dx_directsoundcapture_createcapturebuffer_dsound_vb 867792             //  DirectSoundCapture.CreateCaptureBuffer
#define idh__dx_directsoundcapture_getcaps_dsound_vb 867793                         //  DirectSoundCapture.GetCaps
#define idh__dx_directsoundcapturebuffer_dsound_vb 867794                           //  DirectSoundCaptureBuffer
#define idh__dx_directsoundcapturebuffer_getcaps_dsound_vb 867795                   //  DirectSoundCaptureBuffer.GetCaps
#define idh__dx_directsoundcapturebuffer_getcurrentposition_dsound_vb 867796        //  DirectSoundCaptureBuffer.GetCurrentPosition
#define idh__dx_directsoundcapturebuffer_getformat_dsound_vb 867797                 //  DirectSoundCaptureBuffer.GetFormat
#define idh__dx_directsoundcapturebuffer_getstatus_dsound_vb 867798                 //  DirectSoundCaptureBuffer.GetStatus
#define idh__dx_directsoundcapturebuffer_readbuffer_dsound_vb 867799                //  DirectSoundCaptureBuffer.ReadBuffer
#define idh__dx_directsoundcapturebuffer_setnotificationpositions_dsound_vb 867800  //  DirectSoundCaptureBuffer.SetNotificationPositions
#define idh__dx_directsoundcapturebuffer_start_dsound_vb 867801                     //  DirectSoundCaptureBuffer.Start
#define idh__dx_directsoundcapturebuffer_stop_dsound_vb 867802                      //  DirectSoundCaptureBuffer.Stop
#define idh__dx_directsoundcapturebuffer_writebuffer_dsound_vb 867803               //  DirectSoundCaptureBuffer.WriteBuffer
#define idh__dx_directsoundenum_dsound_vb 867804                                    //  DirectSoundEnum
#define idh__dx_directsoundenum_getcount_dsound_vb 867805                           //  DirectSoundEnum.GetCount
#define idh__dx_directsoundenum_getitem_dsound_vb 867806                            //  DirectSoundEnum.GetItem
#define idh__dx_directx7_dsound_vb 867807                                           //  DirectX7
#define idh__dx_ds3dbuffer_dsound_vb 867808                                         //  DS3DBUFFER
#define idh__dx_ds3dlistener_dsound_vb 867809                                       //  DS3DLISTENER
#define idh__dx_dsbcaps_dsound_vb 867810                                            //  DSBCAPS
#define idh__dx_dsbpositionnotify_dsound_vb 867811                                  //  DSBPOSITIONNOTIFY
#define idh__dx_dsbufferdesc_dsound_vb 867812                                       //  DSBUFFERDESC
#define idh__dx_dscaps_dsound_vb 867813                                             //  DSCAPS
#define idh__dx_dscbcaps_dsound_vb 867814                                           //  DSCBCAPS
#define idh__dx_dscbufferdesc_dsound_vb 867815                                      //  DSCBUFFERDESC
#define idh__dx_dsccaps_dsound_vb 867816                                            //  DSCCAPS
#define idh__dx_dscursors_dsound_vb 867817                                          //  DSCURSORS
#define idh__dx_dxdriverinfo_dsound_vb 867818                                       //  DXDRIVERINFO
#define idh__dx_waveformatex_dsound_vb 867819                                       //  WAVEFORMATEX
#define idh__dx_const_ds3dapplyflags_dsound_vb 867820                               //  CONST_DS3DAPPLYFLAGS
#define idh__dx_const_ds3dmodeflags_dsound_vb 867821                                //  CONST_DS3DMODEFLAGS
#define idh__dx_const_dsbcapsflags_dsound_vb 867822                                 //  CONST_DSBCAPSFLAGS
#define idh__dx_const_dsblockflags_dsound_vb 867823                                 //  CONST_DSBLOCKFLAGS
#define idh__dx_const_dsbplayflags_dsound_vb 867824                                 //  CONST_DSBPLAYFLAGS
#define idh__dx_const_dsbstatusflags_dsound_vb 867825                               //  CONST_DSBSTATUSFLAGS
#define idh__dx_const_dscapsflags_dsound_vb 867826                                  //  CONST_DSCAPSFLAGS
#define idh__dx_const_dscbcapsflags_dsound_vb 867827                                //  CONST_DSCBCAPSFLAGS
#define idh__dx_const_dscblockflags_dsound_vb 867828                                //  CONST_DSCBLOCKFLAGS
#define idh__dx_const_dscbstartflags_dsound_vb 867829                               //  CONST_DSCBSTARTFLAGS
#define idh__dx_const_dscbstatusflags_dsound_vb 867830                              //  CONST_DSCBSTATUSFLAGS
#define idh__dx_const_dsccapsflags_dsound_vb 867831                                 //  CONST_DSCCAPSFLAGS
#define idh__dx_const_dsound_dsound_vb 867832                                       //  CONST_DSOUND
#define idh__dx_const_dssclflags_dsound_vb 867833                                   //  CONST_DSSCLFLAGS
#define idh__dx_const_dsspeakerflags_dsound_vb 867834                               //  CONST_DSSPEAKERFLAGS
#define idh__dx_const_waveformatflags_dsound_vb 867835                              //  CONST_WAVEFORMATFLAGS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmchordmapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmchordmapobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicChordMapObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicChordMap IDirectMusicChordMap*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicChordMapObject : 
	public I_dxj_DirectMusicChordMap,
	//public CComCoClass<C_dxj_DirectMusicChordMapObject, &CLSID__dxj_DirectMusicChordMap>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicChordMapObject();
	virtual ~C_dxj_DirectMusicChordMapObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicChordMapObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicChordMap)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicChordMap,		"DIRECT.DirectMusicChordMap.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicChordMapObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
    HRESULT STDMETHODCALLTYPE getScale(long *s); 
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicChordMap);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicChordMap)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmcollectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcollectionobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmCollectionObj.h"


extern void *g_dxj_DirectMusicCollection;


CONSTRUCTOR(_dxj_DirectMusicCollection, {});
DESTRUCTOR(_dxj_DirectMusicCollection, {});
GETSET_OBJECT(_dxj_DirectMusicCollection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmcollectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmcollectionobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicCollectionObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicCollection IDirectMusicCollection*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicCollectionObject : 
	public I_dxj_DirectMusicCollection,
	//public CComCoClass<C_dxj_DirectMusicCollectionObject, &CLSID__dxj_DirectMusicCollection>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicCollectionObject();
	virtual ~C_dxj_DirectMusicCollectionObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicCollectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicCollection)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicCollection,		"DIRECT.DirectMusicCollection.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicCollectionObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

      
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicCollection);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicCollection)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmcomposerobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmStyleObj.h"
#include "dmComposerObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicComposer, {});
DESTRUCTOR(_dxj_DirectMusicComposer, {});
GETSET_OBJECT(_dxj_DirectMusicComposer);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicComposerObject::autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg)
{
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE, pPerf,Performance);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->AutoTransition(pPerf,pToSeg,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg,NULL,NULL);
	if FAILED(hr) return hr;
	if (pNewSeg)	{
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,ppTransSeg);
	}
	else{
		*ppTransSeg=NULL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pTemp,TemplateSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromTemplate(pStyle,pTemp,activity,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;	
	
	BOOL bi= (bIntro==VARIANT_TRUE);
	BOOL be= (bEnd==VARIANT_TRUE);

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromShape(pStyle,numberOfMeasures,shape,activity,bi,be,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}



HRESULT C_dxj_DirectMusicComposerObject::composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *FromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pFromSeg,FromSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTransition(pFromSeg,pToSeg,(MUSIC_TIME)mtTime,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}
    


HRESULT C_dxj_DirectMusicComposerObject::composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg)
{
	HRESULT hr;		
	BOOL bi=(bIntro==VARIANT_TRUE);
	BOOL be=(bEnd==VARIANT_TRUE);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTemplateFromShape(numMeasures,shape,bi,be,endLength,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,TempSeg);

	return hr;
}
        


HRESULT C_dxj_DirectMusicComposerObject::changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR  *ChordMap)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,ChordMap);
	BOOL bs=(trackScale==VARIANT_TRUE);	

	
	hr=m__dxj_DirectMusicComposer->ChangeChordMap(pSeg,bs,pMap);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmcomposerobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicComposerObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicComposer IDirectMusicComposer*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicComposerObject : 
	public I_dxj_DirectMusicComposer,
	//public CComCoClass<C_dxj_DirectMusicComposerObject, &CLSID__dxj_DirectMusicComposer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicComposerObject();
	virtual ~C_dxj_DirectMusicComposerObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicComposerObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicComposer)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicComposer,		"DIRECT.DirectMusicComposer.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicComposerObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    
	    HRESULT STDMETHODCALLTYPE autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short Activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *pFromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg);
    
    HRESULT STDMETHODCALLTYPE changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap  *ChordMap);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicComposer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicComposer)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmloaderobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicLoaderObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicLoader IDirectMusicLoader*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicLoaderObject : 
	public I_dxj_DirectMusicLoader,
	//public CComCoClass<C_dxj_DirectMusicLoaderObject, &CLSID__dxj_DirectMusicLoader>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicLoaderObject();
	virtual ~C_dxj_DirectMusicLoaderObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicLoaderObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicLoader)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicLoader,		"DIRECT.DirectMusicLoader.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicLoaderObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	 HRESULT STDMETHODCALLTYPE loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

 	 HRESULT STDMETHODCALLTYPE loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadSegmentFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyleFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBandFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadCollectionFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE setSearchDirectory( BSTR path);

 	 HRESULT STDMETHODCALLTYPE loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadChordMapFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);



////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicLoader);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicLoader)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmloaderobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.cpp
//
//--------------------------------------------------------------------------

// dmLoaderObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dms.h"
#include "dmLoaderObj.h"
#include "dmBandObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmCollectionObj.h"
#include "dmChordMapObj.h"

extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicBand;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicCollection;
extern void *g_dxj_DirectMusicChordMap;
	

CONSTRUCTOR(_dxj_DirectMusicLoader, {});
DESTRUCTOR(_dxj_DirectMusicLoader, {});
GETSET_OBJECT(_dxj_DirectMusicLoader);


extern HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment *pSeg,I_dxj_DirectMusicSegment **segment) ;


BOOL HasBackslash(BSTR b){
	
	DWORD cbLen=SysStringLen(b);
	
	for (DWORD i=0;i<cbLen;i++) 
	{
		if (b[i]==((unsigned short)'\\'))
			 return TRUE;
	}
	return FALSE;
}


HRESULT C_dxj_DirectMusicLoaderObject::loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ; //DMUS_OBJ_FULLPATH
	objdesc.guidClass=CLSID_DirectMusicSegment;
	
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);	
	IDirectMusicSegment *pOut=NULL;
    
	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	hr=CREATE_DMSEGMENT_NOADDREF(pOut,ret);
	if FAILED(hr) return hr;

	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;
    
	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}


	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}
HRESULT C_dxj_DirectMusicLoaderObject::loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;

   	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME | DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;

    if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME | DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;
    
   	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadSegmentFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{

	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;
	

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// so we convert to ansi first
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSEG");
	if (!hres) return E_FAIL;
	

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;


	dwSize=SizeofResource(hMod,hres); 
	
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicSegment;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadStyleFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98				
		// convert to ansi first
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);

	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSTYLE");


	if (!hres) return E_FAIL;


	pMem=(void*)LoadResource(hMod,hres);


	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle,(void**)&pOut);	
	
	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadBandFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// converting to ansi first
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMBAND");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadCollectionFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98		
		// converting to ansi first
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCOL");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}

 
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadChordMapFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// converting to ansi first
		LPCTSTR pszName = NULL;
		__try { pszName = W2T(moduleName); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCHORD");
	if (!hres) {
		//MessageBox(NULL,"FindResourceW Failed","test",MB_OK);
		return E_FAIL;
	}

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem){
		//MessageBox(NULL,"LoadResource Failed","test",MB_OK);
		return E_FAIL;
	}

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap,(void**)&pOut);	
	if FAILED(hr) {
		//MessageBox(NULL,"GetObject Failed","test",MB_OK);
		return hr;
	}

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::setSearchDirectory( BSTR dir)
 {
	HRESULT hr;
	hr=m__dxj_DirectMusicLoader->SetSearchDirectory(GUID_DirectMusicAllTypes,dir, TRUE);    //?
	return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmperformanceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmPerformanceObj.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"
//#include "dsoundobj.h"

extern void *g_dxj_DirectMusicPerformance;
extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern CRITICAL_SECTION g_cbCriticalSection;

CONSTRUCTOR(_dxj_DirectMusicPerformance, {InternalInit();});
DESTRUCTOR(_dxj_DirectMusicPerformance, {InternalCleanup();});
GETSET_OBJECT(_dxj_DirectMusicPerformance);

typedef IDirectMusicSegment* LPDIRECTMUSICSEGMENT;
typedef IDirectMusicSegmentState* LPDIRECTMUSICSEGMENTSTATE ;

HRESULT C_dxj_DirectMusicPerformanceObject::InternalInit(){
	m_pDM = NULL;
	m_pPort=NULL;
	m_portid=-1;
	m_number_of_groups=4;

	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::InternalCleanup(){	
	if (m_pPort) m_pPort->Release();
	if (m_pDM) m_pDM->Release();
	m__dxj_DirectMusicPerformance->CloseDown();
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::init( 
		/* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
		/* [in] */ long hWnd)
{
	HRESULT hr;	
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND,pSound,DirectSound);
    
	hr=m__dxj_DirectMusicPerformance->Init(&m_pDM,pSound,(HWND)hWnd);
	if FAILED(hr) return hr;
	
	//hr=m__dxj_DirectMusicPerformance->AddPort(NULL);
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::closeDown( )
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicPerformance->CloseDown();
	return hr;
}
 

#define VBREF_TO_REALREFTIME(startTime) ((__int64)startTime*10000)
#define REALREF_TO_VBREFTIME(startTime) ((long)(startTime/10000))

HRESULT C_dxj_DirectMusicPerformanceObject::playSegment( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ long lFlags,
		/* [in] */ long startTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	if (!segment) return E_INVALIDARG;
	if (!segmentState) return E_INVALIDARG;
					     
	DO_GETOBJECT_NOTNULL(IDirectMusicSegment*,pSeg,segment);
	IDirectMusicSegmentState *pState=NULL;
	
	__int64 outTime=(__int64)startTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(startTime);
	
	hr=m__dxj_DirectMusicPerformance->PlaySegment(pSeg,(DWORD)lFlags,outTime,&pState);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

	 





HRESULT C_dxj_DirectMusicPerformanceObject::getSegmentState( 
		/* [in] */ long mtTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	IDirectMusicSegmentState *pState=NULL;
	hr=m__dxj_DirectMusicPerformance->GetSegmentState(&pState,(MUSIC_TIME)mtTime);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::invalidate( 
		/* [in] */ long mtTime,
		/* [in] */ long flags)

{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->Invalidate((MUSIC_TIME)mtTime,(DWORD)flags);
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::isPlaying( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
		/* [retval][out] */ VARIANT_BOOL __RPC_FAR *b)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
			
	hr=m__dxj_DirectMusicPerformance->IsPlaying(pSeg,pSegState);	
	if (hr==S_FALSE){
		*b=VARIANT_FALSE;
	}
	else if (hr==S_OK){
		*b=VARIANT_TRUE;
	}
	else{
		return hr;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicPerformanceObject::addNotificationType(CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	switch (t){	
	 case DMUS_NOTIFY_ON_CHORD:
		g=GUID_NOTIFICATION_CHORD;
		break;

	 case DMUS_NOTIFY_ON_COMMAND:
		g=GUID_NOTIFICATION_COMMAND;
		break;
	 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
		g=GUID_NOTIFICATION_MEASUREANDBEAT;
		break;
	 case DMUS_NOTIFY_ON_PERFORMANCE:
		g=GUID_NOTIFICATION_PERFORMANCE;
		break;
	 case DMUS_NOTIFY_ON_SEGMENT:
		g=GUID_NOTIFICATION_SEGMENT;
		break;
	 default:
		return E_INVALIDARG;
	}
	
	hr=m__dxj_DirectMusicPerformance->AddNotificationType(g);	
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::removeNotificationType( /* [in] */CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	switch (t){	
	 case DMUS_NOTIFY_ON_CHORD:
		g=GUID_NOTIFICATION_CHORD;
		break;

	 case DMUS_NOTIFY_ON_COMMAND:
		g=GUID_NOTIFICATION_COMMAND;
		break;
	 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
		g=GUID_NOTIFICATION_MEASUREANDBEAT;
		break;
	 case DMUS_NOTIFY_ON_PERFORMANCE:
		g=GUID_NOTIFICATION_PERFORMANCE;
		break;
	 case DMUS_NOTIFY_ON_SEGMENT:
		g=GUID_NOTIFICATION_SEGMENT;
		break;
	 default:
		return E_INVALIDARG;
	}
	hr=m__dxj_DirectMusicPerformance->RemoveNotificationType(g);	
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ long hnd)		
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicPerformance->SetNotificationHandle((HWND)hnd,0);	
	return hr;
}	
	

HRESULT C_dxj_DirectMusicPerformanceObject::getNotificationPMSG( DMUS_NOTIFICATION_PMSG_CDESC *pMsgOut, VARIANT_BOOL *bOut)				
{
	HRESULT hr;	
	DMUS_NOTIFICATION_PMSG *pMsg=NULL;
	
	if (!pMsgOut) return E_INVALIDARG;
	if (!bOut) return E_INVALIDARG;

	hr=m__dxj_DirectMusicPerformance->GetNotificationPMsg(&pMsg);	
	if FAILED(hr) return hr;
	
	*bOut=VARIANT_FALSE;	

	if (!pMsg) 	return S_OK;

	if (hr!=S_FALSE) 	*bOut=VARIANT_TRUE;	
	

	pMsgOut->mtTime=(long)pMsg->mtTime;
	pMsgOut->ctTime=(long)REALREF_TO_VBREFTIME(pMsg->rtTime);
	pMsgOut->lFlags=(long)pMsg->dwFlags;
	
	pMsgOut->lNotificationOption =pMsg->dwNotificationOption;
	pMsgOut->lField1=pMsg->dwField1;
	pMsgOut->lField2=pMsg->dwField2;


	if (0==memcmp(&GUID_NOTIFICATION_CHORD,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_CHORD;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_COMMAND,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_COMMAND;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_MEASUREANDBEAT,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_MEASUREANDBEAT;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_PERFORMANCE,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_PERFORMANCE;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_SEGMENT,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_SEGMENT;
	}
	else {
		pMsgOut->lNotificationType=0;		
	}

	m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG *)pMsg);

	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::musicToClockTime( /* [in] */ long mtTime,
		/* [retval][out] */ long __RPC_FAR *rtTime)				
{
	HRESULT hr;	
	__int64 outTime;
	hr=m__dxj_DirectMusicPerformance->MusicToReferenceTime((MUSIC_TIME)mtTime,&outTime);
	if FAILED(hr) return hr;
	*rtTime=REALREF_TO_VBREFTIME(outTime);
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::clockToMusicTime( 	/* [in] */ long rtTime,
		/* [retval][out] */ long __RPC_FAR *mtTime)				
{
	HRESULT hr;	
	__int64 outTime=VBREF_TO_REALREFTIME(rtTime);;
	hr=m__dxj_DirectMusicPerformance->ReferenceToMusicTime(outTime,(MUSIC_TIME*)mtTime);		
	return hr;
}	
	 


HRESULT C_dxj_DirectMusicPerformanceObject::getMusicTime( /* [retval][out] */ long __RPC_FAR *mtTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetTime(NULL,(MUSIC_TIME*)mtTime);		
	return hr;
}	
	 

HRESULT C_dxj_DirectMusicPerformanceObject::getClockTime( /* [retval][out] */ long __RPC_FAR *rtTime)		
{
	HRESULT hr;	
	__int64 outTime=0;
	hr=m__dxj_DirectMusicPerformance->GetTime(&outTime,NULL);
	*rtTime=REALREF_TO_VBREFTIME(outTime);
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::getPrepareTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetPrepareTime((DWORD*)pTime);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getBumperLength(/* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetBumperLength((DWORD*)pTime);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getLatencyTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	if (!pTime) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetLatencyTime(&t);	
	*pTime=REALREF_TO_VBREFTIME(t);
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getQueueTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	if (!pTime) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetQueueTime(&t);	
	*pTime=REALREF_TO_VBREFTIME(t);
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getResolvedTime( /* [in] */ long rtTime, /* [in] */ long flags,	/* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;		
	__int64 outtime1= VBREF_TO_REALREFTIME(rtTime);
	__int64 outtime2=0;
	hr=m__dxj_DirectMusicPerformance->GetResolvedTime(outtime1,&outtime2,(DWORD)flags);	
	*ret=REALREF_TO_VBREFTIME(outtime2);
	return hr;
}	

	 

HRESULT C_dxj_DirectMusicPerformanceObject::setPrepareTime( /* [retval][out] */ long  t)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->SetPrepareTime((DWORD)t);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setBumperLength(/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->SetBumperLength((DWORD)t);	
	return hr;
}	



HRESULT C_dxj_DirectMusicPerformanceObject::adjustTime( 		
		/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	REFERENCE_TIME rt =(REFERENCE_TIME)t;
	hr=m__dxj_DirectMusicPerformance->AdjustTime(rt);	
	return hr;
}	








HRESULT C_dxj_DirectMusicPerformanceObject::setMasterAutoDownload( /* [in] */ VARIANT_BOOL bval)
{
	HRESULT hr;
	BOOL b=(BOOL)(bval==VARIANT_TRUE);

	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfAutoDownload,(void*)&b,sizeof(BOOL));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterAutoDownload( /* [in] */ VARIANT_BOOL *bIn)
{
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfAutoDownload,(void*) &b,sizeof(BOOL));
	if (b){
		*bIn=VARIANT_TRUE;
	}
	else{
		*bIn=VARIANT_FALSE;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterTempo( /* [in] */ float tempo)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->SetGlobalParam( GUID_PerfMasterTempo ,(void*) &tempo,sizeof(float));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterTempo( /* [in] */ float *tempo)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam( GUID_PerfMasterTempo ,(void*) tempo,sizeof(float));
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::setMasterVolume( /* [in] */ long vol)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterVolume  ,(void*) &vol,sizeof(long));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterVolume( /* [in] */ long *vol)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterVolume ,(void*) vol,sizeof(long));
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::setMasterGrooveLevel( /* [in] */ short level)
{
	HRESULT hr;
	
	char l=(char)level;

	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterGrooveLevel  ,(void*) &l,sizeof(char));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterGrooveLevel( /* [in] */ short *level)
{
	HRESULT hr;
	if (!level) return E_INVALIDARG;
	char l=0;

	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterGrooveLevel ,(void*) &l,sizeof(char));
	*level=(short)l;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::stop( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,		
		/* [in] */ long endTime,
		/* [in] */ long lFlags)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
	
	
	
	__int64 outTime=(__int64)endTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(endTime);
	
	hr=m__dxj_DirectMusicPerformance->Stop(pSeg,pSegState,(MUSIC_TIME)outTime,(DWORD)lFlags);	
	
	return hr;
}




HRESULT C_dxj_DirectMusicPerformanceObject::Reset(long resetFlags)
{
    DMUS_SYSEX_PMSG     *pGMReset;
    BYTE                abGMReset[] = {0xF0,0x7E,0x7F,0x09,0x01,0xF7};
    DWORD               dwLen;
	HRESULT				hr=S_OK;

	if (!resetFlags){
		dwLen = sizeof(abGMReset)/sizeof(abGMReset[0]);

		if(SUCCEEDED( m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_SYSEX_PMSG) + dwLen,
																(DMUS_PMSG**)&pGMReset )))
		{
			ZeroMemory(pGMReset, sizeof(pGMReset));
			pGMReset->dwSize = sizeof(DMUS_SYSEX_PMSG);
			pGMReset->dwPChannel = 0;
			pGMReset->dwVirtualTrackID = 0;
			pGMReset->dwType = DMUS_PMSGT_SYSEX ;
			pGMReset->dwVoiceID = 0;
			pGMReset->dwGroupID = 0xFFFFFFFF;

			pGMReset->dwLen = dwLen;
			memcpy(pGMReset->abData, abGMReset, dwLen);

			if (SUCCEEDED(m__dxj_DirectMusicPerformance->GetTime(NULL, &pGMReset->mtTime)))
			{
				pGMReset->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
			}

			hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pGMReset);
		}
	}
	else if(resetFlags==1){

		//1) Find out what port we're playing through
		//2)  Close the port
		//3) Open the port back up.
		
		hr=setPort(m_portid,m_number_of_groups);
	}
	else {
		hr=E_INVALIDARG;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getStyle( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicStyle,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pStyle );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getChordMap( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getCommand( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *command)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;								
		if (!command) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*command=cmd.bCommand;		
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getGrooveLevel( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *level)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;			
		if (!level) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*level=cmd.bGrooveLevel;		
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTempo( 		
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ double __RPC_FAR *tempo)
{
	HRESULT hr;	
	DMUS_TEMPO_PARAM tmp;
	if (!tempo) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&tmp );	
	if FAILED(hr) return hr;		
	*tempo=tmp.dblTempo;		
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTimeSig( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig)
{
	
	HRESULT hr;	
	if (!timeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,(DMUS_TIMESIGNATURE*)timeSig);		
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendNotePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg)
{


	HRESULT		hr;
	DMUS_NOTE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),(DMUS_PMSG**)&pPMSG);
	if FAILED(hr) return hr;

	//memcpy(pPMSG,msg,sizeof(DMUS_NOTE_PMSG));
	//depends on alignment settings
	//and how dll is compiled to work right.
	//copy member by member instead..
	ZeroMemory(pPMSG,sizeof(DMUS_NOTE_PMSG));
	pPMSG->dwSize=sizeof(DMUS_NOTE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_NOTE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	
	
	pPMSG->mtDuration=(MUSIC_TIME)msg->mtDuration;
	pPMSG->wMusicValue=(WORD)msg->musicValue;
	pPMSG->wMeasure=(WORD)msg->measure;
	pPMSG->nOffset=(short)msg->offset;
	pPMSG->bBeat=(BYTE)msg->beat;
	pPMSG->bGrid=(BYTE)msg->grid;
	pPMSG->bVelocity=(BYTE)msg->velocity;
	pPMSG->bFlags=(BYTE)msg->flags;
	pPMSG->bTimeRange=(BYTE)msg->timeRange;
	pPMSG->bDurRange=(BYTE)msg->durRange;
	pPMSG->bVelRange=(BYTE)msg->velRange;
	pPMSG->bPlayModeFlags=(BYTE)msg->playModeFlags;
	pPMSG->bSubChordLevel=(BYTE)msg->subChordLevel;
	pPMSG->bMidiValue=(BYTE)msg->midiValue;
	pPMSG->cTranspose=(char)msg->transpose;


	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;

}

HRESULT C_dxj_DirectMusicPerformanceObject::sendCurvePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg)
{
	HRESULT		hr;
	DMUS_CURVE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;

	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pPMSG);

	
	pPMSG->dwSize=sizeof(DMUS_CURVE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_CURVE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

	pPMSG->mtDuration=msg->mtDuration;
	pPMSG->mtOriginalStart=msg->mtOriginalStart;
	pPMSG->mtResetDuration=msg->mtResetDuration;	
	pPMSG->nStartValue =(short)msg->startValue;
	pPMSG->nEndValue =(short)msg->endValue;
	pPMSG->nResetValue =(short)msg->resetValue;
	pPMSG->wMeasure =(short)msg->measure;
	pPMSG->nOffset =(short)msg->offset;
	pPMSG->bBeat =(Byte)msg->beat;
	pPMSG->bGrid =(Byte)msg->grid;
	pPMSG->bType =(Byte)msg->type;
	pPMSG->bCurveShape =(Byte)msg->curveShape;
	pPMSG->bCCData =(Byte)msg->ccData;
	pPMSG->bFlags =(Byte)msg->flags;


	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendMIDIPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte status,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_MIDI_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_MIDI_PMSG));
	pPMSG->dwSize=sizeof(DMUS_MIDI_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_MIDI;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->bStatus=status;
	pPMSG->bByte1=byte1;
	pPMSG->bByte2=byte2;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendPatchPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte instrument,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_PATCH_PMSG	*pPMSG=NULL; 
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_PATCH_PMSG));
	pPMSG->dwSize=sizeof(DMUS_PATCH_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_PATCH;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->byInstrument=instrument;
	pPMSG->byMSB=byte1;
	pPMSG->byLSB=byte2;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTempoPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		///* [in] */ long channel,
		/* [in] */ double tempo)
{
	HRESULT		hr;
	DMUS_TEMPO_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_TEMPO_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TEMPO_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_TEMPO;	
	pPMSG->dwPChannel =(DWORD)0;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->dblTempo=tempo;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTransposePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ short transpose)
{
	
	HRESULT		hr;
	DMUS_TRANSPOSE_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_TRANSPOSE_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TRANSPOSE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_TRANSPOSE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->nTranspose=transpose;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTimeSigPMSG( 
		/* [in] */ long mtTime,		
		/* [in] */ long flags,
		/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig)
{
	HRESULT		hr;
	DMUS_TIMESIG_PMSG	*pPMSG=NULL;
	if (!timesig) return E_INVALIDARG;

	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG**)&pPMSG);
	ZeroMemory(pPMSG,sizeof(DMUS_TIMESIG_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TIMESIG_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;	
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_CURVE;	
	pPMSG->dwPChannel =(DWORD)0;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

	pPMSG->bBeatsPerMeasure   =timesig->beatsPerMeasure; 
	pPMSG->bBeat=timesig->beat;  
	pPMSG->wGridsPerBeat=timesig->gridsPerBeat;

	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  

	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortName( 
		/* [in] */ long i,
		/* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;	
	DMUS_PORTCAPS caps;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	if (!name) return E_INVALIDARG;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   &caps );
	
	if (hr!=S_OK) return E_INVALIDARG;	//happens when we are out of bounds
										//manbug23240
	if FAILED(hr) return hr;			//for other resason ?

	*name=SysAllocString(caps.wszDescription);
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortCount( 
		/* [retval][out] */ long __RPC_FAR *c)
{
	HRESULT hr=S_OK;	
	DMUS_PORTCAPS caps;
	DWORD i=0;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (!c) return E_INVALIDARG;
	while (hr==S_OK){
		caps.dwSize=sizeof(DMUS_PORTCAPS);
		hr=m_pDM->EnumPort(  i++,   &caps );
		if FAILED(hr) return hr;
	}
	*c=(long)i-1;
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::getPortCaps( long i,
		/* [retval][out] */ DMUS_PORTCAPS_CDESC __RPC_FAR *c)
{
	HRESULT hr;		
	if (!c) return E_INVALIDARG;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	ZeroMemory(c,sizeof(DMUS_PORTCAPS));
	((DMUS_PORTCAPS*)c)->dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   (DMUS_PORTCAPS*)c );
	if (hr==S_FALSE) return E_INVALIDARG;

	return hr;		
}

HRESULT C_dxj_DirectMusicPerformanceObject::setPort( 
		/* [in] */ long portid,
		/* [in] */ long number_of_groups)
{
	if (!m_pDM) return DMUS_E_NOT_INIT;

	HRESULT             hr;
    DMUS_PORTPARAMS     dmos;
	DMUS_PORTCAPS       caps;
	GUID				guidSink;

	
    // Initialize the performance. Have the performance create the
    // DirectMusic object by setting pDM to NULL. It is needed to
    // create the port.

	    // Create the port.
    ZeroMemory( &dmos, sizeof(DMUS_PORTPARAMS) );
    dmos.dwSize = sizeof(DMUS_PORTPARAMS);  
    dmos.dwChannelGroups = number_of_groups;
    dmos.dwEffectFlags = 0;
    dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);

	DWORD j=0;

	if (m_pPort){
		
		//j=m_pPort->AddRef();
		//j=m_pPort->Release();

		j=m_pPort->Release();
		hr= m__dxj_DirectMusicPerformance->RemovePort(m_pPort);
		
		
		
		if FAILED(hr) return hr;
	}


	if (portid<=0) {
		ZeroMemory( &guidSink, sizeof(GUID) );
	}
	else {
		hr=m_pDM->EnumPort(  (DWORD) portid-1,   &caps );
		if FAILED(hr) return hr;
		memcpy(&guidSink,&caps.guidPort,sizeof(GUID));
	}

	// Create the port
    hr = m_pDM->CreatePort( guidSink, &dmos, &m_pPort, NULL );
    if  FAILED(hr)  return hr;

	// Activate
    hr = m_pDM->Activate( TRUE );
    if  FAILED(hr)  return hr;

	//j=m_pPort->AddRef();
	//j=m_pPort->Release();

	// Add the port to the performance.

    // Succeeded in creating the port. Add the port to the
    // Performance with five groups of 16 midi channels.
    hr = m__dxj_DirectMusicPerformance->AddPort( m_pPort );
    if  FAILED(hr)  return hr;


	//j=m_pPort->AddRef();
	//j=m_pPort->Release();

	// Assign PChannel blocks for the number of groups we want.

	for( long i = 0; i < number_of_groups; i++ )
	{
		m__dxj_DirectMusicPerformance->AssignPChannelBlock( i, m_pPort, i+1 );
	}

	m_portid=portid;
	m_number_of_groups=number_of_groups;
	return S_OK;

}




















//DEAD CODE left here for reference
#if 0

	HRESULT C_dxj_DirectMusicPerformanceObject::addCommandParam( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */ Byte command,
			/* [in] */ Byte grooveLevel)
	{	
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;
		cmd.bCommand=(BYTE)command;
		cmd.bGrooveLevel=(BYTE)grooveLevel;
		cmd.bGrooveRange=0;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&cmd);	
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::addBandChange(  /* [in] */ long trackIndex, /* [in] */ long mtTime, /* [in] */ I_dxj_DirectMusicBand __RPC_FAR *band)
	{
		if (!band) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicBand*,pBand,band);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_IDirectMusicBand,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,pBand);	
		return hr;
	}
 
	HRESULT C_dxj_DirectMusicPerformanceObject::addTempoChange( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */  double tempo)
	{
		HRESULT hr;	
		DMUS_TEMPO_PARAM tmp;
		tmp.dblTempo=tempo;
		tmp.mtTime=(MUSIC_TIME)mtTime;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&tmp);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::addTimeSigChange( /* [in] */ long trackIndex,/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSignature)
	{
		HRESULT hr;	
		if (!timeSignature) return E_INVALIDARG;
		MUSIC_TIME mtTime=((DMUS_TIMESIGNATURE*)timeSignature)->mtTime;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,(DMUS_TIMESIGNATURE*)timeSignature);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::setAutoDownloadEnable( /* [in] */ long trackIndex, /* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

     
	HRESULT C_dxj_DirectMusicPerformanceObject::setTempoEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::setTimeSigEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::clearAllBands ()
	{
		HRESULT hr;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Clear_All_Bands,0xFFFFFFFF,0,0,NULL);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::download(  /* [in] */ long trackIndex,    /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::unload( /* [in] */ long trackIndex,   /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dms.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dms.h
//
//--------------------------------------------------------------------------
 

//
// dms.h : david's funky stuff
//
// CLONETO, QIOVERLOAD: see d3drmVisualObj.cpp
//
//
//
#include "basetsd.h"
#include "dvp.h"

#ifdef DEBUG
 #define DPF(n,o)		{OutputDebugString(o);}
 #define DPF1(n,o,p)		{char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}
 #define DPF2(n,o,p,e)	{char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}
#else
 #define DPF(n,o)		
 #define DPF1(n,o,p)		
 #define DPF2(n,o,p,e)	
#endif

#define INTERNAL_CREATE_RETOBJ(objType,objOther,retval,classobj) \
{ 	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{	IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			classobj=ptr; \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) \
			return E_FAIL; \
		c->pinterface = (void*)*retval; \
		classobj=c; \
} }



#define INTERNAL_CREATE_STRUCT(objType,retval) { C##objType##Object *c=new CComObject<C##objType##Object>;\
	if (c==NULL) return E_OUTOFMEMORY;\
	if (FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL;\
	}


#define INTERNAL_CREATE_NOADDREF(objType,objOther,retval) {C##objType##Object *prev=NULL; *retval = NULL; \
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj){IUnknown *unk=0;ptr->InternalGetObject(&unk); 	if(unk == objOther) { 	*retval = (I##objType*)ptr->pinterface;	IUNK(ptr->pinterface)->AddRef(); IUNK(objOther)->Release(); break;	} 	prev = ptr; } \
	if(!ptr) { 	C##objType##Object *c=new CComObject<C##objType##Object>; if( c == NULL ) {	objOther->Release();return E_FAIL;}	c->InternalSetObject(objOther);  if FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval)) 	return E_FAIL; c->pinterface = (void*)*retval; }}	
		
// Given a java interface (objtype), envoke InternalSetObject and set the given
// DIRECTX pointer (objOther). Also envoke QueryInterface and set a ** interface
// ptr to a DIRECTX object (retval). So we create a DIRECTX object.
//#define INTERNAL_CREATE(objType,objOther,retval){C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
//c->parent = this; AddRef(); c->InternalSetObject(objOther);if (FAILED(c->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; }
//			if (FAILED(ptr->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; 
#ifdef _DEBUG
#define INTERNAL_CREATE(objType,objOther,retval) \
{ \
	DWORD refcount; char buffer[256]; wsprintf(buffer,"INTERNAL_CREATE %s \n",__FILE__); \
	OutputDebugString(buffer); \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface;\
			IUNK(ptr->pinterface)->AddRef();\
			IUNK(objOther)->Release(); \
			refcount = *(((DWORD*)ptr)+1); \
			wsprintf(buffer,"		Retrived Object [%s] RefCount %d \n\r",__FILE__, refcount);\
			OutputDebugString(buffer);\
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef(); \
		refcount = *(((DWORD*)this)+1); \
		wsprintf(buffer,"Object [%s] RefCount[%d]\n\r",__FILE__, refcount);\
		OutputDebugString(buffer);\
		c->InternalSetObject(objOther);if (FAILED((	((I##objType *)c))->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}
#else
#define INTERNAL_CREATE(objType,objOther,retval) \
{ \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}
#endif



#define INTERNAL_CREATE_2REFS(objType,objParentType,objParent, objOther,retval) \
{	 \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		c->parent2 = IUNK(objParent); \
		((I##objType *)this)->AddRef();  \
		((I##objParentType*)objParent)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}


#define INTERNAL_CREATE_1REFS(objType,objParentType,objParent, objOther,retval) \
{	 \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>; \
        if( c == NULL ) \
        { objOther->Release(); return E_FAIL;} \
		c->parent = IUNK(objParent); \
		((I##objParentType*)objParent)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}


typedef struct FrameMoveCallback3
{
	FrameMoveCallback3  *next;
	FrameMoveCallback3  *prev;
	I_dxj_Direct3dRMFrameMoveCallback3 *c;
	IUnknown		*pUser;
	IUnknown		*pParent;
	IUnknown		*m_obj;
	int				m_stopflag;
} FrameMoveCallback3;


struct TextureCallback
{
	TextureCallback  *next;
	TextureCallback  *prev;
	I_dxj_Direct3dRMLoadTextureCallback3 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
};


typedef struct TextureCallback3
{
	TextureCallback3  *next;
	TextureCallback3  *prev;
	I_dxj_Direct3dRMLoadTextureCallback3 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
} TextureCallback3;

struct d3drmCallback		// used for AddDestroyCallback
{
	d3drmCallback   *next;
	d3drmCallback   *prev;
	I_dxj_Direct3dRMCallback  *c;
	IUnknown		*pUser;
	IUnknown	  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};

struct DestroyCallback	
{
	DestroyCallback   *next;
	DestroyCallback   *prev;
	I_dxj_Direct3dRMCallback  *c;
	IUnknown		*pUser;
	IUnknown		  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};

struct EnumerateObjectsCallback
{
	EnumerateObjectsCallback  *next;
	EnumerateObjectsCallback  *prev;
	I_dxj_Direct3dRMEnumerateObjectsCallback *c;
	IUnknown			  *pUser;
	IUnknown	  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};




struct GeneralCallback
{
	GeneralCallback  *next;
	GeneralCallback  *prev;
	IUnknown		 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
};

typedef struct DeviceUpdateCallback3
{
	DeviceUpdateCallback3  *next;
	DeviceUpdateCallback3  *prev;
	I_dxj_Direct3dRMDeviceUpdateCallback3 *c;
	IUnknown				*pUser;
	IUnknown				*pParent;
	IUnknown				*m_obj;
	int						m_stopflag;
} DeviceUpdateCallback3;

struct LoadCallback
{
	LoadCallback  *next;
	LoadCallback  *prev;
	I_dxj_Direct3dRMLoadCallback *c;
	IUnknown	  *pUser;
	IUnknown	  *pParent;
	IUnknown	  *m_obj;
	int			  m_stopflag;
};




/////////////////////////////////////////////////////////////////////////
#define MAX_INTERNAL_STR_LEN	256

struct JavaString
{
	DWORD nBytes;
	WCHAR Item[MAX_INTERNAL_STR_LEN];
};

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// mod:dp helper macros for stuffing expanded unions in DirectX Structures

#define IUNK(o) ((IUnknown*)(void*)(o))
#define IS_NULLGUID(g) (\
	(g->data1==0) && \
	(g->data2==0) && \
	(g->data3==0) && \
	(g->data4[0]==0) && \
	(g->data4[1]==0) && \
	(g->data4[2]==0) && \
	(g->data4[3]==0) && \
	(g->data4[4]==0) && \
	(g->data4[5]==0) && \
	(g->data4[6]==0) && \
	(g->data4[7]==0) )

 	


extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d);
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);

/////////////////////////////////////////////////////////////////////////
#define JAVASTRING(item) {sizeof(item)*2-2, L##item}

#define PASS_THROUGH(cl,m) STDMETHODIMP C##cl##Object::m() { return m_##cl->m();}
#define PASS_THROUGH1(c,m,t1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(v1);}
#define PASS_THROUGH2(c,m,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(v1, v2);}
#define PASS_THROUGH3(c,m,t1,t2,t3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(v1, v2,v3);}
#define PASS_THROUGH4(c,m,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(v1, v2,v3,v4);}
#define PASS_THROUGH5(c,m,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(v1, v2,v3,v4,v5);}
#define PASS_THROUGH6(c,m,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(v1, v2,v3,v4,v5,v6);}
#define PASS_THROUGH7(c,m,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(v1, v2,v3,v4,v5,v6,v7);}
#define PASS_THROUGH8(c,m,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(v1,v2,v3,v4,v5,v6,v7,v8);}

#define PASS_THROUGH_CAST_1(c,m,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(tt1 v1);}
#define PASS_THROUGH_CAST_2(c,m,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(tt1 v1, tt2 v2);}
#define PASS_THROUGH_CAST_3(c,m,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(tt1 v1,tt2 v2,tt3 v3);}
#define PASS_THROUGH_CAST_4(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
#define PASS_THROUGH_CAST_5(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
#define PASS_THROUGH_CAST_6(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
#define PASS_THROUGH_CAST_7(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
#define PASS_THROUGH_CAST_8(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}

//mod:dp additions due to renaming 
#define PASS_THROUGH_R(c,m1,m2) STDMETHODIMP C##c##Object::m1() { if(m_##c==NULL)return E_FAIL; return m_##c->m2();}
#define PASS_THROUGH1_R(c,m1,m2,t1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1);}
#define PASS_THROUGH2_R(c,m1,m2,t1,t2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2);}
#define PASS_THROUGH3_R(c,m1,m2,t1,t2,t3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3);}
#define PASS_THROUGH4_R(c,m1,m2,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4);}
#define PASS_THROUGH5_R(c,m1,m2,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5);}
#define PASS_THROUGH6_R(c,m1,m2,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6);}
#define PASS_THROUGH7_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6,v7);}
#define PASS_THROUGH8_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1,v2,v3,v4,v5,v6,v7,v8);}

#define PASS_THROUGH_CAST_1_R(c,m1,m2,t1,tt1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1);}
#define PASS_THROUGH_CAST_2_R(c,m1,m2,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2);}
#define PASS_THROUGH_CAST_3_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3);}
#define PASS_THROUGH_CAST_4_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
#define PASS_THROUGH_CAST_5_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
#define PASS_THROUGH_CAST_6_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
#define PASS_THROUGH_CAST_7_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
#define PASS_THROUGH_CAST_8_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}

#define COPY_OR_CLEAR(dest, src, si) {if(src) memcpy((void *)dest, (void *)src, si);else memset((void *)dest, si, 0);}
#define COPY(dest, src, si) memcpy((void *)dest, (void *)src, si)

// ??
#define DECLSET_OBJECT(ifacevar, var, typ) {if(var) var->Release();	var = (typ)ifacevar;}
#define DECLGET_OBJECT(ifacevar, var){*ifacevar = (IUnknown *)var;}


#define ISEQUAL(c) \
	STDMETHODIMP C##c##Object::isEqual(I##c *d, int *retval)\
					{	IUnknown *IU1;\
						IUnknown *IU2;\
						if (d == NULL)\
							return E_FAIL;	\
						this->InternalGetObject((IUnknown **)(&IU1)); \
						d->InternalGetObject((IUnknown **)(&IU2)); \
						if (IU1 == IU2) \
							*retval = TRUE; \
						else \
							*retval = FALSE; \
						return S_OK;}

#define DX3J_GLOBAL_LINKS( obj_type ) \
int creationid;\
void *parent; \
void *pinterface; \
void *nextobj; 

/*STDMETHOD(isEqual)(IUnknown *pobj, int *ret)*/; 

// Given a class (c)
#define GETSET_OBJECT(c) \
	STDMETHODIMP C##c##Object::InternalSetObject(IUnknown *l)\
					{DECLSET_OBJECT(l,m_##c,typedef_##c);return S_OK;} \
	STDMETHODIMP C##c##Object::InternalGetObject(IUnknown **l)\
					{DECLGET_OBJECT(l,m_##c);return S_OK;} 
	//ISEQUAL(c);

// Given a java interface, go get a pointer_to_a_pointer to a DIRECTX object
//pac DO_GETOBJECT_NOTNULL is too dangerous and is commented.  use DO_GETOBJECT_NOTNULL
//#define DO_GETOBJECT(t,v,i) t v;i->InternalGetObject((IUnknown **)(&v));
#define DO_GETOBJECT_NOTNULL(t,v,i) t v=NULL;if(i) i->InternalGetObject((IUnknown **)(&v));


//
extern int g_creationcount;


#ifdef _DEBUG

#define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
	 m_##c = NULL; parent = NULL; pinterface = NULL; \
	 nextobj =  g##c##;\
	 creationid = ++g_creationcount;\
	 char buffer[256];\
	 wsprintf(buffer,"Constructor Creation Id [%d] %s",g_creationcount,__FILE__);\
	 OutputDebugString(buffer);\
	 g##c## = (void *)this; o }

#else
#define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
     m_##c = NULL; parent = NULL; pinterface = NULL; \
     nextobj = (void*)g##c##; \
     creationid = ++g_creationcount; \
     g##c## = (void*)this; o}
#endif

#ifdef _DEBUG

#define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
	char buffer[256]; \
	wsprintf(buffer,"Destructor Id[%d] %s ",creationid,__FILE__); \
	OutputDebugString(buffer); 	C##c##Object *prev=NULL; \
	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
	{\
		if(ptr == this) \
		{ \
			if(prev) \
				prev->nextobj = ptr->nextobj; \
			else \
				g##c## = (void*)ptr->nextobj; \
			break; \
		} \
		prev = ptr; \
	} \
	if(m_##c){ 	int count = IUNK(m_##c)->Release(); wsprintf(buffer,"DirectX %s Ref count [%d]",__FILE__,count); OutputDebugString(buffer); \
		if(count==0){ char szOut[512];wsprintf(szOut,"\n Real %s released \n",__FILE__); OutputDebugString(szOut); m_##c = NULL; } \
	} \
	if(parent) IUNK(parent)->Release(); \
}

#else
#define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
	C##c##Object *prev=NULL; \
	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
	{\
		if(ptr == this) \
		{ \
			if(prev) \
				prev->nextobj = ptr->nextobj; \
			else \
				g##c## = (void*)ptr->nextobj; \
			break; \
		} \
		prev = ptr; \
	} \
	if(m_##c){ \
		if (IUNK(m_##c)->Release()==0) m_##c = NULL; \
	} \
	if(parent) IUNK(parent)->Release();\
}
#endif 



#define OBJCHECK(lable, c) { \
	char buffer[256];\
	if ( g##c ) \
	{\
		int count = 0; \
		C##c##Object *prev=NULL; \
		C##c##Object *ptr;\
		for(ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
		{\
			DWORD refcount = *(((DWORD*)ptr)+1);\
			wsprintf( buffer,"%s: Ref Count [%d] CreateId [%d]\n\r",lable,refcount,ptr->creationid);\
			OutputDebugString(buffer);\
			count++;\
		}\
		wsprintf(buffer,"%s: %d \n\r",lable,count);\
		OutputDebugString(buffer);\
	}\
}




#ifdef _DEBUG
#define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){  nextobj = g##c##;\
	 creationid = ++g_creationcount;\
	char buffer[256];\
	wsprintf(buffer,"Creation Id [%d]",g_creationcount);\
	OutputDebugString(buffer);\
	 g##c## = (void*)this;o}
#else
#define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){ \
 nextobj =(void*) g##c##; \
 creationid = ++g_creationcount; \
 g##c## = (void*)this; \
 o}
#endif




#define DESTRUCTOR_STRUCT(c, o) C##c##Object::~C##c##Object(){o; \
C##c##Object *prev=NULL; \
for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
{\
	if(ptr == this) \
	{ \
		if(prev) \
			prev->nextobj = ptr->nextobj; \
		else \
			g##c## = (void*)ptr->nextobj; \
		break; \
	} \
	prev = ptr; \
} \
}

#define CHECK_AND_RETURN_RMVIS(real,cover,f) {##real *lpReal=NULL;\
		if (S_OK==lp->QueryInterface(IID_##real, (void**) &lpReal)){\
	 	 I##cover *lpFake=NULL;\
		 INTERNAL_CREATE(cover, lpReal, (void**)&lpFake);\
		 if (!lpFake) {IUNK(lpFake)->Release(); return E_OUTOFMEMORY;}\
		 ((I##cover *)lpFake)->QueryInterface(IID_I_dxj_Direct3dRMVisual,(void**)f);\
		 ((I##cover *)lpFake)->Release();\
		 return S_OK;\
		}}	

// Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
#define RETURN_NEW_ITEM(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST(c,m,oc, ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM1(c,m,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM2(c,m,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_1(c,m,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_2(c,m,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

//mod:dp additions due to renaming 
// Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
#define RETURN_NEW_ITEM_R(c,m,m2,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM1_R(c,m,m2,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_R(c,m,m2,oc,ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_1_R(c,m,m2,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_2_R(c,m,m2,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#if 0 
#define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}
#endif

// Return a primitive value by reference.
#define GET_DIRECT(cl,met,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met();return S_OK;}
#define GET_DIRECT1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met(v1);return S_OK;}
#define GET_DIRECT2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met(v1,v2);return S_OK;}

#define GET_DIRECT_R(cl,met,met2,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met2();return S_OK;}
#define GET_DIRECT1_R(cl,met,met2,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met2(v1);return S_OK;}
#define GET_DIRECT2_R(cl,met,met2,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met2(v1,v2);return S_OK;}


// Return a pointer to a primitive value as a ** ptr.
#define GET_DIRECTPTR(cl,met,t) STDMETHODIMP C##cl##Object::met(t **h){*h=(struct t*)m_##cl->met();return S_OK;}
#define GET_DIRECTPTR1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t **h){*h=(struct t*)m_##cl->met(v1);return S_OK;}
#define GET_DIRECTPTR2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t **h){*h=(struct t*)m_##cl->met(v1,v2);return S_OK;}

//Do a DO_GETOBJECT_NOTNULL and then call a method on the object
#define DO_GETOBJECT_ANDUSEIT(cl,me,iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(lp); }

#define DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me((t1)lp); }

#define DO_GETOBJECT_ANDUSEIT1(cl,me,iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, lp); }

#define DO_GETOBJECT_ANDUSEIT2(cl,me,iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, v2, lp); }

//mod:dp additions due to renaming 
//Do a DO_GETOBJECT_NOTNULL and then call a method on the object
#define DO_GETOBJECT_ANDUSEIT_R(cl,me, m2, iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(lp); }

#define DO_GETOBJECT_ANDUSEIT_CAST_R(cl,me, m2, iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2((t1)lp); }

#define DO_GETOBJECT_ANDUSEIT1_R(cl,me, m2, iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, lp); }

#define DO_GETOBJECT_ANDUSEIT2_R(cl,me, m2, iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, v2, lp); }


// Make a copy of an object!
//#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(Id3drmObject **retval){typedef_##cl lp;\
//	m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl,lp,retval);return S_OK;}

//#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(I##cl **retval){typedef_##cl lp;\
//m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}

//#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(I##cl **retval){typedef_##cl lp;\
//m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}


#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(IUnknown **retval){typedef_##cl lp;\
m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, (I##cl **)retval);	return S_OK;}


// ??
// Call the d3drmObject->GetName method
extern "C" HRESULT _GetName(IDirect3DRMObject *i, BSTR *Name, BOOL bName);

#define GETNAME(cl) STDMETHODIMP C##cl##Object::GetName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
#define GETCLASSNAME(cl) STDMETHODIMP C##cl##Object::GetClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}

#define SETNAME(cl) STDMETHODIMP C##cl##Object::SetName(BSTR Name){	\
	USES_CONVERSION;\
	LPSTR str = NULL; \
	__try { str = W2T(Name); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; } \
	return m_##cl->SetName( str );}

#define GETNAME_R(cl) STDMETHODIMP C##cl##Object::getName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
#define GETCLASSNAME_R(cl) STDMETHODIMP C##cl##Object::getClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}

#define SETNAME_R(cl) STDMETHODIMP C##cl##Object::setName(BSTR Name){	\
	USES_CONVERSION;\
	LPSTR str = W2T(Name); return m_##cl->SetName( str );}

extern "C" HRESULT _DeleteDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args);
#define DELETEDESTROYCALLBACK(cl) STDMETHODIMP C##cl##Object::DeleteDestroyCallback( I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _DeleteDestroyCallback(m_##cl, oC, args);}

#define DELETEDESTROYCALLBACK_R(cl) STDMETHODIMP C##cl##Object::deleteDestroyCallback( I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _DeleteDestroyCallback(m_##cl, oC, args);}

extern "C" HRESULT _AddDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args);
#define ADDDESTROYCALLBACK(cl) STDMETHODIMP C##cl##Object::AddDestroyCallback(I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _AddDestroyCallback(m_##cl, oC, args);}

#define ADDDESTROYCALLBACK_R(cl) STDMETHODIMP C##cl##Object::addDestroyCallback(I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _AddDestroyCallback(m_##cl, oC, args);}

#define CLONETO(clMe, cl, ifaceThat) STDMETHODIMP C##clMe##Object::Get##cl(I##cl **retval) \
{ typedef_##cl lp; if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK) return S_FALSE; \
	INTERNAL_CREATE( cl, lp, retval); return S_OK; }

#define CLONETO_RX(clMe, cl, ifaceThat)										\
STDMETHODIMP C##clMe##Object::getDirect3dRM##cl(I_dxj_Direct3dRM##cl **retval)   \
{																			\
typedef__dxj_Direct3dRM##cl lp; 											\
if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK)				\
	return S_FALSE;															\
INTERNAL_CREATE( _dxj_Direct3dRM##cl, lp, retval); 							\
return S_OK; 																\
}																  

#define ISSAFEARRAY1D(ppsa,count) ((*ppsa) &&  ( ((SAFEARRAY*)*ppsa)->cDims==1) && (((SAFEARRAY*)*ppsa)->rgsabound[0].cElements >= count))

/**********************************************************************************************/
extern "C" BOOL ParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader,
											BYTE **ppbWaveData,DWORD *pcbWaveSize);
extern "C" BOOL GetWaveResource(HMODULE hModule, LPCTSTR lpName,
			 WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize);

extern "C" DWORD bppToddbd(int bpp);

extern "C" void UndoCallbackLink(GeneralCallback *e, GeneralCallback **h);

extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt);
extern "C" void ctojDSBufferDesc( LPDSBUFFERDESC lpdd,
									 DSBufferDesc *ddsb, WaveFormatex *wave);
extern "C" void jtocDSBufferDesc( LPDSBUFFERDESC lpdd,
									 DSBufferDesc *ddsb, WaveFormatex *wave);
extern "C" void ctojWaveFormatEx( LPWAVEFORMATEX lpdd, WaveFormatex *wave);
extern "C" void CopyFloats(D3DVALUE *mat1, D3DVALUE *mat2, DWORD count);

extern "C" void* CheckCallbackLink(void *current, void **head);
extern "C" void* AddCallbackLink(void **ptr2, I_dxj_Direct3dRMCallback *enumC, void *args);
extern "C" void* AddCallbackLinkRetVal(IUnknown *m_obj, void **ptr2, I_dxj_Direct3dRMCallback *enumC, void *args);
extern "C" void SetStopFlag(IUnknown *m_obj, void** ptr2);

extern "C" BOOL PASCAL myEnumSoundDriversCallback(GUID &SPGuid, LPSTR description, 
													LPSTR module, void *lpArg);

extern "C" void __cdecl myFrameMoveCallback( LPDIRECT3DRMFRAME lpf,
                           void *lpArg, D3DVALUE delta);

extern "C" void __cdecl myFrameMoveCallback2( LPDIRECT3DRMFRAME lpf,
                           void *lpArg, D3DVALUE delta);

extern "C" void __cdecl myFrameMoveCallback3( LPDIRECT3DRMFRAME3 lpf,
                            void *lpArg, D3DVALUE delta);

extern "C" HRESULT __cdecl myLoadTextureCallback(char *tex_name,
							void *lpArg,LPDIRECT3DRMTEXTURE * lpD3DRMTex);

extern "C" HRESULT __cdecl myLoadTextureCallback3(char *tex_name,
							void *lpArg,LPDIRECT3DRMTEXTURE3 * lpD3DRMTex);

extern "C" void __cdecl myAddUpdateCallback3(LPDIRECT3DRMDEVICE3 ref,
										void *lpArg, int rectCount, LPD3DRECT update);

extern "C" void __cdecl myEnumerateObjectsCallback( LPDIRECT3DRMOBJECT lpo,void *lpArg);

extern "C" int __cdecl myUserVisualCallback(LPDIRECT3DRMUSERVISUAL lpUV,void *lpArg,
		DWORD reason, LPDIRECT3DRMDEVICE lpD, LPDIRECT3DRMVIEWPORT lpV);

extern "C" BOOL PASCAL myEnumServiceProvidersCallback(LPGUID lpSPGuid,  LPWSTR lpFriendlyName, 
					DWORD dwMajorVersion,DWORD dwMinorVersion, void *lpArg);

extern "C" BOOL PASCAL myEnumPlayersCallback2(DPID dpid, 
						DWORD dwPlayerType, LPCDPNAME lpName,
						DWORD dwFlags, LPVOID lpContext);

extern "C" BOOL PASCAL myEnumSessionsCallback2(const DPSESSIONDESC2 *gameDesc,
						 	 DWORD *timeout, DWORD dwFlags, void *lpArg);

extern "C" BOOL PASCAL myEnumAddressCallback(LPGUID guidDataType, 
						DWORD dwDataSize, LPCVOID lpData,	LPVOID lpContext);

extern "C" BOOL PASCAL myEnumAddressTypesCallback(LPGUID guidDataType, 
										LPVOID lpContext, DWORD dwFlags);
extern "C" BOOL PASCAL myEnumLocalApplicationsCallback(LPCDPLAPPINFO lpAppInfo, 
										LPVOID lpContext, DWORD dwFlags);

extern "C" BOOL PASCAL myEnumConnectionsCallback(	LPCGUID lpguidSP,
		LPVOID lpConnection,	DWORD dwConnectionSize,	LPCDPNAME lpName,
		DWORD dwFlags,	LPVOID lpContext);


extern "C" HRESULT PASCAL myEnumSurfacesCallback(LPDIRECTDRAWSURFACE lpDDSurface,
						 LPDDSURFACEDESC lpDDSurfaceDesc,void *lpContext);

extern "C" HRESULT PASCAL myEnumModesCallback(LPDDSURFACEDESC lpDDSurfaceDesc,
														 void *lpContext);

extern "C" HRESULT myEnumOverlayZOrdersCallback(LPDIRECTDRAWSURFACE lpDDS,
														void *lpContext);

extern "C" HRESULT PASCAL myEnumDevicesCallback( LPGUID Guid, LPSTR DevDesc,
						LPSTR DevName, LPD3DDEVICEDESC lpD3DHWDevDesc,
							LPD3DDEVICEDESC lpD3DHELDevDesc, void *lpArg);

extern "C" void myd3dValidateCallback(void *lpArg, DWORD offset);

extern "C" HRESULT myEnumTextureFormatsCallback(
									 LPDDSURFACEDESC lpDdsd, void *lpArg);

extern "C" void __cdecl myAddDestroyCallback(LPDIRECT3DRMOBJECT lpObj,void *lpArg);

extern "C" void __cdecl myd3drmLoadCallback(LPDIRECT3DRMOBJECT lpo,
											  REFIID ObjectGuid, LPVOID lpArg);
extern "C" HRESULT WINAPI myEnumVideoCallback( LPDDVIDEOPORTCAPS lpDDVideoPortCaps,    LPVOID lpContext    );

extern "C" BOOL WINAPI myDirectDrawEnumCallback(  GUID FAR *lpGUID, LPSTR lpDriverDescription,  
			LPSTR lpDriverName, LPVOID lpContext );

extern "C" BOOL CALLBACK myEnumDeviceObjectsCallback(  LPCDIDEVICEOBJECTINSTANCE pI,    LPVOID lpArg ) ;
extern "C" BOOL CALLBACK myEnumCreatedEffectObjectsCallback(LPDIRECTINPUTEFFECT peff,    LPVOID lpArg );
extern "C" BOOL CALLBACK myEnumEffectsCallback(  LPCDIEFFECTINFO pdei,    LPVOID lpArg   );
extern "C" BOOL CALLBACK myEnumInputDevicesCallback(  LPDIDEVICEINSTANCE lpddi,    LPVOID pvRef   );

//////////////////////////////////////////////////////////////////////////

extern "C" TextureCallback				*TextureCallbacks;			//d3drmTexture3
extern "C" TextureCallback3				*TextureCallbacks3;			//d3drmTexture3
extern "C" FrameMoveCallback3			*FrameMoveCallbacks3;		//d3drmFrame3
extern "C" DeviceUpdateCallback3		*DeviceUpdateCallbacks3;
extern "C" EnumerateObjectsCallback		*EnumCallbacks;			
extern "C" LoadCallback					*LoadCallbacks;			
extern "C" DestroyCallback				*DestroyCallbacks;



extern HRESULT CopyInDDSuraceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *pfOut, DDPixelFormat *pf);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d);
extern HRESULT CopyOutDDPixelFormat(DDPixelFormat *pfOut, DDPIXELFORMAT *pf);
extern HRESULT CreateCoverObject(LPDIRECT3DRMOBJECT lp, I_dxj_Direct3dRMObject** f);
extern HRESULT CreateCoverVisual(LPDIRECT3DRMOBJECT lp, I_dxj_Direct3dRMVisual** v);
/*
 **********************************************************************
 * INTERNAL_CREATE(thisClass, var, retval)
 *		thisClass	class we are working on
 *		var			variable created in routine to get DirectX object
 *		retval		return value back to java
 *
 * wrap a DirectX object in one of ours and shove it in the return value
 ***********************************************************************
 * INTERNAL_CREATE_NOREL(thisClass, var, retval)
 *		thisClass	class we are working on
 *		var			variable created in routine to get DirectX object
 *		retval		return value back to java
 *
 * wrap a DirectX object in one of ours and shove it in the return value
 * If the layer obejct fails, DONT release the DirectX object
 ***********************************************************************
 * DO_GETOBJECT_NOTNULL(type,var,iface)
 *		type		type of variable we are creating
 *		var			variable we are creating
 *		iface		layer iface where we are getting the object from
 *
 * declare and get a DirectX object from a layer object
 ***********************************************************************
 * DO_GETOBJECT_NOTNULL(type,var,iface)
 *		type		type of variable we are creating
 *		var			variable we are creating
 *		iface		layer iface where we are getting the object from
 *
 * same as DO_GETOBJECT_NOTNULL except that we check for iface==NULL before calling
 ***********************************************************************
 * PASS_THROUGH[x](class,method,[...])
 *		class		this class
 *		method		method to call
 *
 * pass call straight through
 ***********************************************************************
 * PASS_THROUGH_CAST_[x](class,method,[...])
 *		class		this class
 *		method		method to call
 *
 * pass call straight through, casting the parameters to allow the call to pass
 ***********************************************************************
 * RETURN_NEW_ITEM(thisClass,method,OtherClass)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *
 * call DirectX method to get the DirectX object, then wrap it in one of our layer
 * objects
 ***********************************************************************
 * RETURN_NEW_ITEM[1,2](thisClass,method,OtherClass,type)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *		type		type of parameter
 *
 * Same as RETURN_NEWITEM except that there is an extra parameter (or two) BEFORE the
 * returned one
 ***********************************************************************
 * RETURN_NEW_ITEM_CAST_[1,2](thisClass,method,OtherClass,type)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *		type		type of parameter
 *
 * Same as RETURN_NEW_ITEM[1,2] except that there the extra parameter(s) are type cast
 ******************************************************************************
 * RETURN_NEW_ITEM_NOREL(thisClass,method,OtherClass)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *
 * same as RETURN_NEW_ITEM except that calls INTERNAL_CREATE_NOTREL instead of
 * INTERNAL_CREATE
 ******************************************************************************
 * GET_DIRECT(cl,met,t)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *
 * DirectX returns value directly (no HRESULT), we get the value from Direct and
 * then return S_OK. (see CddSurfaceObject::Restore, may need to be added).
 * Note: the value is passed back via a pointer to that value.
 ******************************************************************************
 * GET_DIRECT[1,2](cl,met,t,t1)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *      t1			type of extra variable(s) BEFORE retval
 *
 * same as GET_DIRECT but there is another parameter (or two) BEFORE the returned one
 ****************************************************************************************
 * GET_DIRECTPTR(cl,met,t)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *
 * DirectX returns a pointer to a value directly (no HRESULT), we get the value from
 * Direct and then return S_OK. In this case it is a pointer to a pointer.
 ***************************************************************************************
 * GET_DIRECTPTR[1,2](cl,met,t,t1)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *      t1			type of extra variable(s) BEFORE retval
 *
 * same as GET_DIRECTPTR but there is a parameter (or two) BEFORE the one returned.
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT(cl,me,iface)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *
 * get an internal object from iface and use it in the method. we return from the method
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface,type)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *		type		type to cast to in the actual call.
 * get an internal object from iface and use it in the method. we return from the method
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT[1,2](cl,me,iface,ty)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *		type		type of parameter BEFORE 2nd object
 *
 * same as DO_GETOBJECT_ANDUSEIT except there is another parameter (or two) BEFORE
 * the object one
 ************************************************************************************
 * CLONE(cl)
 *		class		class to clone
 *
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * GETNAME(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * GETCLASSNAME(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * DELETEDESTROYCALLBACK(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * QIOVERLOAD(cl, ifaceThat, clThat)
 *		class		class being worked on
 *		iface		iface of DIRECT object.  Should really typedef_## this!
 *		clThat		object we are going to create
 *
 * this is really bright - overloading QI to get new objects
 ************************************************************************************
 * CLONETO(cl, clThat, ifaceThat)
 *		class		class being worked on
 *		iface		iface of DIRECT object.  Should really typedef_## this!
 *		clThat		object we are going to create
 *
 * this is really bright - overloading QI to get new objects
 ************************************************************************************
 */


extern void *g_dxj_DirectDraw7;
extern void *g_dxj_Direct3dTexture7;
extern void *g_dxj_DirectDrawSurface7;
extern void *g_dxj_Direct3dDevice7;
extern void *g_dxj_Direct3dVertexBuffer7;
extern void *g_dxj_Direct3d7;


extern void *g_dxj_DirectDrawSurface4;
extern void *g_dxj_Direct3dDevice3;
extern void *g_dxj_Direct3dLight;
extern void *g_dxj_Direct3dMaterial3;
extern void *g_dxj_Direct3dVertexBuffer;
extern void *g_dxj_Direct3d3;
extern void *g_dxj_Direct3dRMAnimation2;
extern void *g_dxj_Direct3dRMAnimationSet2;
extern void *g_dxj_Direct3dRMObjectArray;
extern void *g_dxj_Direct3dRMDeviceArray;
extern void *g_dxj_Direct3dRMDevice3;
extern void *g_dxj_Direct3dRMFaceArray;
extern void *g_dxj_Direct3dRMFace2;
extern void *g_dxj_Direct3dRMFrameArray;
extern void *g_dxj_Direct3dRMFrame3;
extern void *g_dxj_Direct3dRMLightArray;
extern void *g_dxj_Direct3dRMLight;
extern void *g_dxj_Direct3dRMMaterial2;
extern void *g_dxj_Direct3dRMMeshBuilder3;
extern void *g_dxj_Direct3dRMMesh;
extern void *g_dxj_Direct3dRMProgressiveMesh;
extern void *g_dxj_Direct3dRMObject;
extern void *g_dxj_Direct3dRMPickArray;
extern void *g_dxj_Direct3dRMPick2Array;
extern void *g_dxj_Direct3dRMShadow2;
extern void *g_dxj_Direct3dRMTexture3;
extern void *g_dxj_Direct3dRMUserVisual;
extern void *g_dxj_Direct3dRMViewportArray;
extern void *g_dxj_Direct3dRMVisualArray;
extern void *g_dxj_Direct3dRMVisual;
extern void *g_dxj_Direct3dRMClippedVisual;
extern void *g_dxj_Direct3dRMWinDevice;
extern void *g_dxj_Direct3dRMWrap;
extern void *g_dxj_Direct3dTexture2;
extern void *g_dxj_Direct3dViewport3;
extern void *g_dxj_DirectDrawClipper;
extern void *g_dxj_DirectDrawPalette;
extern void *g_dxj_DirectDraw4;
extern void *g_dxj_DDVideoPortContainer;
extern void *g_dxj_DirectDrawVideoPort;
extern void *g_dxj_DirectDrawColorControl;
extern void *g_dxj_DirectSound3dListener;
extern void *g_dxj_DirectSoundBuffer;
extern void *g_dxj_DirectSound3dBuffer;
extern void *g_dxj_DirectSound;
extern void *g_dxj_DirectSoundCapture;
extern void *g_dxj_DirectSoundCaptureBuffer;
extern void *g_dxj_DirectSoundNotify;
extern void *g_dxj_DirectPlay3;
extern void *g_dxj_DirectPlayLobby2;
extern void *g_dxj_Direct3dRM3;
extern void *g_dxj_Direct3dRMViewport2;
extern void *g_dxj_DirectInput;
extern void *g_dxj_DirectInputDevice;
extern void *g_dxj_DirectInputEffect;
extern void *g_dxj_DPAddress;
extern void *g_dxj_DPLConnection;
extern void *g_dxj_DirectDrawGammaControl;
extern void *g_dxj_DirectPlay4;
extern void *g_dxj_DirectPlayLobby3;


#define DXHEAPALLOC malloc
#define DXSTACKALLOC lalloc
#define DXHEAPFREE free
#define DXALLOCBSTR SysAllocString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmsegmentobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegment IDirectMusicSegment*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentObject : 
	public I_dxj_DirectMusicSegment,
	//public CComCoClass<C_dxj_DirectMusicSegmentObject, &CLSID__dxj_DirectMusicSegment>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentObject();
	virtual ~C_dxj_DirectMusicSegmentObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegment)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegment,		"DIRECT.DirectMusicSegment.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

        HRESULT STDMETHODCALLTYPE clone( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd,
            /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment);
        
        HRESULT STDMETHODCALLTYPE setStartPoint( 
            /* [in] */ long mtStart);
        
        HRESULT STDMETHODCALLTYPE getStartPoint( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE setLoopPoints( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd);
        
        HRESULT STDMETHODCALLTYPE getLoopPointStart( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE getLoopPointEnd( 
            /* [retval][out] */ long __RPC_FAR *pmtEnd);
        
        HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ long __RPC_FAR *pmtLength);
        
        HRESULT STDMETHODCALLTYPE setLength( 
            /* [in] */ long mtLength);
        
        HRESULT STDMETHODCALLTYPE getRepeats( 
            /* [retval][out] */ long __RPC_FAR *lRepeats);
        
        HRESULT STDMETHODCALLTYPE setRepeats( 
            /* [in] */ long lRepeats);
        
        
        HRESULT STDMETHODCALLTYPE download( 
            /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performace);
        
        HRESULT STDMETHODCALLTYPE unload( 
            /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performace);
        
        
        HRESULT STDMETHODCALLTYPE setAutoDownloadEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTempoEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTimeSigEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setStandardMidiFile();
        
        HRESULT STDMETHODCALLTYPE connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c);
	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegment);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegment)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmperformanceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicPerformanceObject

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicPerformance IDirectMusicPerformance*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPerformanceObject : 
	public I_dxj_DirectMusicPerformance,
	//public CComCoClass<C_dxj_DirectMusicPerformanceObject, &CLSID__dxj_DirectMusicPerformance>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPerformanceObject();
	virtual ~C_dxj_DirectMusicPerformanceObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicPerformanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicPerformance)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicPerformance,		"DIRECT.DirectMusicPerformance.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicPerformanceObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);



    HRESULT STDMETHODCALLTYPE init( 
        /* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
        /* [in] */ long hWnd);
    
    HRESULT STDMETHODCALLTYPE closeDown( void);
    
    HRESULT STDMETHODCALLTYPE playSegment( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ long lFlags,
        /* [in] */ long startTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState);
    
    HRESULT STDMETHODCALLTYPE stop( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [in] */ long mtTime,
        /* [in] */ long lFlags);
    
    HRESULT STDMETHODCALLTYPE getSegmentState( 
        /* [in] */ long mtTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE invalidate( 
        /* [in] */ long mtTime,
        /* [in] */ long flags);
    
    HRESULT STDMETHODCALLTYPE isPlaying( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE addNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE removeNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ long hnd);
    
    HRESULT STDMETHODCALLTYPE getNotificationPMSG( 
        /* [out][in] */ DMUS_NOTIFICATION_PMSG_CDESC __RPC_FAR *message, VARIANT_BOOL *b);
    
    HRESULT STDMETHODCALLTYPE musicToClockTime( 
        /* [in] */ long mtTime,
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE clockToMusicTime( 
        /* [in] */ long rtTime,
        /* [retval][out] */ long __RPC_FAR *mtTime);
    
    HRESULT STDMETHODCALLTYPE getMusicTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getClockTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getPrepareTime( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getBumperLength( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getLatencyTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime0);
    
    HRESULT STDMETHODCALLTYPE getQueueTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE getResolvedTime( 
        /* [in] */ long rtTime,
        /* [in] */ long flags,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE setPrepareTime( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE setBumperLength( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE adjustTime( 
        /* [in] */ long rtAmount);
    
    HRESULT STDMETHODCALLTYPE setMasterAutoDownload( 
        /* [in] */ VARIANT_BOOL b);
    
    HRESULT STDMETHODCALLTYPE getMasterAutoDownload( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE setMasterTempo( 
        /* [in] */ float tempo);
    
    HRESULT STDMETHODCALLTYPE getMasterTempo( 
        /* [retval][out] */ float __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE setMasterVolume( 
        /* [in] */ long vol);
    
    HRESULT STDMETHODCALLTYPE getMasterVolume( 
        /* [retval][out] */ long __RPC_FAR *v);
    
    HRESULT STDMETHODCALLTYPE setMasterGrooveLevel( 
        /* [in] */ short level);
    
    HRESULT STDMETHODCALLTYPE getMasterGrooveLevel( 
        /* [retval][out] */  __RPC_FAR short *level);
    
    HRESULT STDMETHODCALLTYPE Reset(long flags);
    
    HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getCommand( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *command);
    
    HRESULT STDMETHODCALLTYPE getGrooveLevel( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *level);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ double __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE getTimeSig( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig);
    
    HRESULT STDMETHODCALLTYPE sendNotePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendCurvePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendMIDIPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte status,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendPatchPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte instrument,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendTempoPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
       // /* [in] */ long channel,
        /* [in] */ double tempo);
    
    HRESULT STDMETHODCALLTYPE sendTransposePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ short transpose);
    
    HRESULT STDMETHODCALLTYPE sendTimeSigPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig);
    
    HRESULT STDMETHODCALLTYPE getPortName( 
        /* [in] */ long i,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getPortCount( 
        /* [retval][out] */ long __RPC_FAR *c);
    
    HRESULT STDMETHODCALLTYPE getPortCaps( long i,
        /* [out][in] */ DMUS_PORTCAPS_CDESC __RPC_FAR *caps);
    
    HRESULT STDMETHODCALLTYPE setPort( 
        /* [in] */ long portid,
        /* [in] */ long numGroups);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
	HRESULT InternalInit();
	HRESULT InternalCleanup();
	

	IDirectMusic *m_pDM;
	IDirectMusicPort *m_pPort;
    DECL_VARIABLE(_dxj_DirectMusicPerformance);
	long m_portid;
	long m_number_of_groups;


	

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicPerformance)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmsegmentstateobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicSegmentState, {});
DESTRUCTOR(_dxj_DirectMusicSegmentState, {});
GETSET_OBJECT(_dxj_DirectMusicSegmentState);


HRESULT C_dxj_DirectMusicSegmentStateObject::getRepeats( long __RPC_FAR *repeats)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetRepeats((DWORD*)repeats);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getSeek( long __RPC_FAR *seek)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetSeek(seek);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartPoint( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartPoint(t);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartTime( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartTime(t);
	return hr;
}




HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment *pSeg,I_dxj_DirectMusicSegment **segment) 
{
	C_dxj_DirectMusicSegmentObject *prev=NULL;
	*segment = NULL; 
	for(	
		C_dxj_DirectMusicSegmentObject 
			*ptr=(C_dxj_DirectMusicSegmentObject *)g_dxj_DirectMusicSegment;
			ptr;
			ptr=(C_dxj_DirectMusicSegmentObject *)ptr->nextobj
		)
	{
		IUnknown *unk=0;
		ptr->InternalGetObject(&unk); 
		if(unk == pSeg) 
		{ 
			*segment = (I_dxj_DirectMusicSegment*)ptr->pinterface;
			IUNK(ptr->pinterface)->AddRef();
			break;
		}
		prev = ptr;
	} 
	if(!ptr) 
	{
		C_dxj_DirectMusicSegmentObject *c=new CComObject<C_dxj_DirectMusicSegmentObject>;
		if( c == NULL ) 
		{
			pSeg->Release();
			return E_FAIL;
		}
		c->InternalSetObject(pSeg);  
		if FAILED(((I_dxj_DirectMusicSegment *)c)->QueryInterface(IID_I_dxj_DirectMusicSegment, (void **)segment)) 
		{
			return E_FAIL; 
		}
		if (!(*segment)) return E_FAIL;

		c->pinterface = (void*)*segment;
	}	
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentStateObject::getSegment( 		
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment)
{
	HRESULT hr;	
	IDirectMusicSegment *pSeg=NULL;
	if(!segment) return E_INVALIDARG;

	hr=m__dxj_DirectMusicSegmentState->GetSegment(&pSeg);
	if FAILED(hr) return hr;	
	
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,segment);
	hr= CREATE_DMSEGMENT_NOADDREF(pSeg,segment);
	if FAILED(hr) return hr;

	if (*segment==NULL) return E_OUTOFMEMORY;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmsegmentstateobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentStateObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegmentState IDirectMusicSegmentState*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentStateObject : 
	public I_dxj_DirectMusicSegmentState,
	//public CComCoClass<C_dxj_DirectMusicSegmentStateObject, &CLSID__dxj_DirectMusicSegmentState>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentStateObject();
	virtual ~C_dxj_DirectMusicSegmentStateObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentStateObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegmentState)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegmentState,		"DIRECT.DirectMusicSegmentState.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentStateObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE getRepeats( 
		/* [retval][out] */ long __RPC_FAR *repeats);

	HRESULT STDMETHODCALLTYPE getSeek( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartPoint( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartTime( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment);

	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegmentState);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegmentState)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmstyleobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmstyleobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmBandObj.h"

extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicStyle, {});
DESTRUCTOR(_dxj_DirectMusicStyle, {});
GETSET_OBJECT(_dxj_DirectMusicStyle);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicStyleObject:: getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{  
	HRESULT hr;			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumBand((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getBandCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumBand((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;

	hr=m__dxj_DirectMusicStyle->GetBand(name,&pBand);
	if FAILED(hr) return hr;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultBand(&pBand);
	if FAILED(hr) return hr;
	if (hr==S_FALSE) return S_OK;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

    
HRESULT C_dxj_DirectMusicStyleObject:: getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumMotif((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getMotifCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumMotif((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicSegment *pSeg=NULL;

	hr=m__dxj_DirectMusicStyle->GetMotif(name,&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}



HRESULT C_dxj_DirectMusicStyleObject:: getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    	
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumChordMap((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getChordMapCount( long *count)        
{ 
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumChordMap((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;

	hr=m__dxj_DirectMusicStyle->GetChordMap(name,&pMap);
	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultChordMap(&pMap);
	if (hr==S_FALSE) return S_OK;

	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);
	*ret=(long)dwMin;
	return hr;
}
		
HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);	
	*ret=(long)dwMax;
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getTempo( 
        /* [retval][out] */ double __RPC_FAR *ret)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicStyle->GetTempo(ret);	
	return hr;
}

		

HRESULT C_dxj_DirectMusicStyleObject::getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig)
{
	HRESULT hr;				
	if (!pTimeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pTimeSig);	
	return hr;
}
// GetDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmstyleobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmstyleobj.h
//
//--------------------------------------------------------------------------

//: Declaration of the C_dxj_DirectMusicStyleObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicStyle IDirectMusicStyle*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicStyleObject : 
	public I_dxj_DirectMusicStyle,
	//public CComCoClass<C_dxj_DirectMusicStyleObject, &CLSID__dxj_DirectMusicStyle>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicStyleObject();
	virtual ~C_dxj_DirectMusicStyleObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicStyleObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicStyle)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicStyle,		"DIRECT.DirectMusicStyle.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicStyleObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
          
    HRESULT STDMETHODCALLTYPE getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getBandCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getMotifCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getChordMapCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [retval][out] */ double __RPC_FAR *pTempo);
  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicStyle);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicStyle)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dmsegmentobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.cpp
//
//--------------------------------------------------------------------------

// dmSegmentObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "dms.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegment;

//CONSTRUCTOR(_dxj_DirectMusicSegment, {});

C_dxj_DirectMusicSegmentObject::C_dxj_DirectMusicSegmentObject()
{ 
     m__dxj_DirectMusicSegment = NULL;
	 parent = NULL; 
	 pinterface = NULL; 
     nextobj = (void*)g_dxj_DirectMusicSegment; 
     creationid = ++g_creationcount; 
     g_dxj_DirectMusicSegment = (void*)this; 

}

DESTRUCTOR(_dxj_DirectMusicSegment, {});
GETSET_OBJECT(_dxj_DirectMusicSegment);


HRESULT C_dxj_DirectMusicSegmentObject::clone( 
        /* [in] */ long mtStart,
        /* [in] */ long mtEnd,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment)
{
	HRESULT hr;	
	IDirectMusicSegment *pOut=NULL;    
	hr=m__dxj_DirectMusicSegment->Clone((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd,&pOut);	
	if FAILED(hr) return hr;
	if (!pOut)return E_OUTOFMEMORY;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ppSegment);
	if (!*ppSegment)return E_OUTOFMEMORY;
	return hr;

}


HRESULT C_dxj_DirectMusicSegmentObject::setStartPoint(   /* [in] */ long mtStart)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegment->SetStartPoint((MUSIC_TIME)mtStart);	
	return hr;
}


HRESULT C_dxj_DirectMusicSegmentObject::getStartPoint(   /* [in] */ long *mtStart)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetStartPoint((MUSIC_TIME*)mtStart);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLoopPoints(   /* [in] */ long mtStart,   /* [in] */ long mtEnd)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegment->SetLoopPoints((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointStart(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	
	hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
	*mtOut=(long)mtStart;
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointEnd(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	
	hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
	*mtOut=(long)mtEnd;
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLength(   /* [in] */ long mtLength)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->SetLength((MUSIC_TIME)mtLength);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLength(   /* [in] */ long *mtLength)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetLength((MUSIC_TIME*)mtLength);	
	return hr;
}
   


HRESULT C_dxj_DirectMusicSegmentObject::setRepeats(   /* [in] */ long lrep)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->SetRepeats((DWORD)lrep);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getRepeats(   /* [in] */ long *lrep)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetRepeats((DWORD*)lrep);	
	return hr;
}
     




HRESULT C_dxj_DirectMusicSegmentObject::download( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{
	if (!performance) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,pPerformance);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::unload(         
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{
	if (!performance) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,pPerformance);	
	return hr;
}



HRESULT C_dxj_DirectMusicSegmentObject::setAutoDownloadEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

     
HRESULT C_dxj_DirectMusicSegmentObject::setTempoEnable( 
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setTimeSigEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;
	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setStandardMidiFile()
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_StandardMIDIFile,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject:: connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(IDirectMusicCollection*,pCol,c);
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_ConnectToDLSCollection,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,(void*)pCol);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpaddressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpaddressobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DPAddressObject :
		public I_dxj_DPAddress,
//		public CComCoClass<C_dxj_DPAddressObject, &CLSID_DPAddress>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DPAddressObject)
		COM_INTERFACE_ENTRY(I_dxj_DPAddress)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__DPAddress, "DIRECT.DPAddress.5",		"DIRECT.DPAddress.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DPAddressObject)

public:
	C_dxj_DPAddressObject();
	~C_dxj_DPAddressObject();

   HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) ;
        
   HRESULT STDMETHODCALLTYPE getAddress( 
            /* [out] */ long  *pAddress,
            /* [out] */ long  *length) ;
                
private:
	void    *m_pAddress;
	DWORD 	m_size;
	void    *nextobj;
	int		creationid;
	void cleanUp();
	void init();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumaddressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddressobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

#define DPENUMGROUPSINGROUP 1
#define DPEnumAddress 2	
#define DPENUMGROUPPLAYERS 3
#define DPENUMGROUPS 4


class C_dxj_DPEnumAddressObject : 
	public I_dxj_DPEnumAddress,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumAddressObject() ;
	virtual ~C_dxj_DPEnumAddressObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumAddressObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumAddress)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumAddressObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
        HRESULT STDMETHODCALLTYPE getData( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
        				
		static HRESULT C_dxj_DPEnumAddressObject::create(IDirectPlayLobby3 * pdp, I_dxj_DPAddress *addr, I_dxj_DPEnumAddress **ret);
		
		void cleanup();	


public:
		
		I_dxj_DPAddress **m_pList;
		GUID		 *m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumaddresstypesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddresstypesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumAddressTypesObject : 
	public I_dxj_DPEnumAddressTypes,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumAddressTypesObject() ;
	virtual ~C_dxj_DPEnumAddressTypesObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumAddressTypesObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumAddressTypes)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumAddressTypesObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
		static HRESULT C_dxj_DPEnumAddressTypesObject::create(IDirectPlayLobby3 * pdp, BSTR strGuid, I_dxj_DPEnumAddressTypes **ret);
		void cleanup();	


public:
		
		GUID		 *m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumaddresstypesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddresstypesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumAddressTypesObj.h"
#include "DPAddressObj.h"

extern BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern HRESULT BSTRtoDPLGUID(LPGUID pGuid,BSTR str);

/////////////////////////////////////////////////////////////////////////////
// The callback is invoked as a result of IDirectPlay2::EnumPlayers(), 
// IDirectPlay2::EnumGroups() and IDirectPlay2::EnumGroupPlayers() calls.
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL FAR PASCAL EnumAddressTypesCallback(  REFGUID guidDataType,  LPVOID lpArg , DWORD flags )

{

	C_dxj_DPEnumAddressTypesObject *pObj=(C_dxj_DPEnumAddressTypesObject*)lpArg;

	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;


		if (pObj->m_pList2)
			pObj->m_pList2=(GUID*)realloc(pObj->m_pList2,sizeof(GUID) * pObj->m_nMax);
		else
			pObj->m_pList2=(GUID*)malloc(sizeof(I_dxj_DPAddress*)* pObj->m_nMax);

		
		
		if  (pObj->m_pList2==NULL)
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}



	ZeroMemory(&(pObj->m_pList2[pObj->m_nCount]), sizeof(GUID));
	
	//memcpy(&(pObj->m_pList2[pObj->m_nCount]), guidDataType,sizeof(GUID));
	pObj->m_pList2[pObj->m_nCount]= guidDataType;

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DPEnumAddressTypesObject::C_dxj_DPEnumAddressTypesObject()
{	
	m_nMax=0;
	m_pList2=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumAddressTypesObject::~C_dxj_DPEnumAddressTypesObject()
{
	//cleanup();
	if (m_pList2) free(m_pList2);
}

void C_dxj_DPEnumAddressTypesObject::cleanup()
{
	if (m_pList2) free(m_pList2);

}


HRESULT C_dxj_DPEnumAddressTypesObject::create(IDirectPlayLobby3 * pdp, BSTR strGuid, I_dxj_DPEnumAddressTypes **ret)
{
	HRESULT hr;
	
	GUID spGuid;
	hr=BSTRtoDPLGUID(&spGuid,strGuid);
	if FAILED(hr) return hr;

	C_dxj_DPEnumAddressTypesObject	*pNew=NULL;

	
	
	if (!strGuid) return E_INVALIDARG;
	if (!ret) return E_INVALIDARG;

	*ret=NULL;

	

	pNew= new CComObject<C_dxj_DPEnumAddressTypesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pdp->EnumAddressTypes( EnumAddressTypesCallback, spGuid, pNew,0 );
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		pNew->cleanup	();
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumAddressTypes,(void**)ret);
	return hr;
}



 
HRESULT C_dxj_DPEnumAddressTypesObject::getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList2==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	*ret=DPLGUIDtoBSTR(&(m_pList2[index-1]));
	return S_OK;
}



HRESULT C_dxj_DPEnumAddressTypesObject::getCount(  long *ret)
{
	*ret=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumconnectionsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumconnectionsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumConnectionsObj.h"
#include "DPAddressObj.h"

extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL FAR PASCAL myEnumConnectionsCallback(
	LPCGUID lpguidSP,
	LPVOID lpConnection,
	DWORD dwConnectionSize,
	LPCDPNAME lpName,
	DWORD dwFlags,
	LPVOID lpArg
	){

	
	DPF(1,"Entered objEnumConnectionsCallback\r\n");

	
	C_dxj_DPEnumConnectionsObject *pObj=(C_dxj_DPEnumConnectionsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DPConnection)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DPConnection*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DPConnection*)malloc(sizeof(DPConnection)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}

		if (pObj->m_pList2)
			pObj->m_pList2=(I_dxj_DPAddress**)realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
		else
			pObj->m_pList2=(I_dxj_DPAddress**)malloc(sizeof(void*) * pObj->m_nMax);

		if (pObj->m_pList2==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}

	}
	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPConnection));
	
	pObj->m_pList2[pObj->m_nCount]=NULL;


	I_dxj_DPAddress *address=NULL;
	
	if (lpName->lpszShortName)
		pObj->m_pList[pObj->m_nCount].strShortName = SysAllocString(lpName->lpszShortName);
	if (lpName->lpszLongName)
		pObj->m_pList[pObj->m_nCount].strLongName = SysAllocString(lpName->lpszLongName);
	if (lpguidSP)
		pObj->m_pList[pObj->m_nCount].strGuid = DPLGUIDtoBSTR((LPGUID)lpguidSP);
	
	pObj->m_pList[pObj->m_nCount].lFlags=(DWORD)dwFlags;

	//internal create does the addref.
	#pragma message ("make sure InternalCreate does addref")

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&address));		
	pObj->m_pList2[pObj->m_nCount]=address;

	if (address) address->setAddress((long)PtrToLong(lpConnection),(long)dwConnectionSize);	//bugbug SUNDOWN	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumConnectionsObject::C_dxj_DPEnumConnectionsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pList2=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumConnectionsObject::~C_dxj_DPEnumConnectionsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPConnection *conn=&(m_pList[i]);
			if (conn->strShortName ) SysFreeString((BSTR)conn->strShortName);
			if (conn->strLongName) SysFreeString((BSTR)conn->strLongName);			
			if (conn->strGuid) SysFreeString((BSTR)conn->strGuid);			
		}
		free(m_pList);
	}
	if (m_pList2){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList2[i]) m_pList2[i]->Release();
		}
		free(m_pList2);
	}

}

HRESULT C_dxj_DPEnumConnectionsObject::create(
		IDirectPlay3 * pdp,
		BSTR strGuid,
		long flags, I_dxj_DPEnumConnections **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumConnectionsObject *pNew=NULL;
	GUID g;
	LPGUID pguid=&g;

	hr=DPLBSTRtoPPGUID(&pguid,strGuid);
	if FAILED(hr) return hr;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumConnectionsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	hr = pdp->EnumConnections(pguid,
						myEnumConnectionsCallback,
						pNew, (long)flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;


	#pragma message ("make sure free on failure cleans up in enumerators on STrings and objects")
	if FAILED(hr) 
	{
		//free(pNew->m_pList);
		//pNew->m_pList=NULL;
		//destructor will clean up properly
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumConnections,(void**)ppRet);
	return hr;
}

/* DEAD CODE
HRESULT C_dxj_DPEnumConnectionsObject::getItem( long index, DPConnection *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	if (!info) return E_INVALIDARG;

	if (info->strGuid) SysFreeString((BSTR)info->strGuid);
	if (info->strShortName) SysFreeString((BSTR)info->strShortName);
	if (info->strLongName) SysFreeString((BSTR)info->strLongName);

	info->strGuid=SysAllocString(m_pList[index].strGuid);
	info->strShortName=SysAllocString(m_pList[index].strShortName);
	info->strLongName=SysAllocString(m_pList[index].strLongName);
	info->lFlags=m_pList[index].lFlags;
			


	return S_OK;
}
*/

HRESULT C_dxj_DPEnumConnectionsObject::getFlags( long index, long  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=m_pList[index-1].lFlags;
	return S_OK;
}
 
HRESULT C_dxj_DPEnumConnectionsObject::getGuid( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}       

HRESULT C_dxj_DPEnumConnectionsObject::getName( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strShortName);
	return S_OK;
}       

/*        
HRESULT C_dxj_DPEnumConnectionsObject::getLongName( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strLongName);
	return S_OK;
}       
*/
HRESULT C_dxj_DPEnumConnectionsObject::getAddress(long index,I_dxj_DPAddress **ppret){
	if (m_pList2==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (m_pList2[index-1]==NULL) return E_FAIL;
	HRESULT hr=m_pList2[index-1]->QueryInterface(IID_I_dxj_DPAddress,(void**)ppret);
	return hr;
}

HRESULT C_dxj_DPEnumConnectionsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumconnectionsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumconnectionsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumConnectionsObject : 
	public I_dxj_DPEnumConnections,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumConnectionsObject() ;
	virtual ~C_dxj_DPEnumConnectionsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumConnectionsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumConnections)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumConnectionsObject)

public:
	    HRESULT STDMETHODCALLTYPE getAddress( 
            /* [in] */ long index,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        //HRESULT STDMETHODCALLTYPE getLongName( 
        //    /* [in] */ long index,
        //    /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

	
		
		static HRESULT C_dxj_DPEnumConnectionsObject::create(IDirectPlay3 * pdp, BSTR guid, long flags, I_dxj_DPEnumConnections **ppRet);

public:
		DPConnection	*m_pList;
		I_dxj_DPAddress **m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpaddressobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpaddressobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPAddressObj.h"


CONSTRUCTOR_STRUCT(_dxj_DPAddress, {init();})
DESTRUCTOR_STRUCT(_dxj_DPAddress, {cleanUp();})


void C_dxj_DPAddressObject::init() {
	m_pAddress=NULL;	
	m_size=0;
}
void C_dxj_DPAddressObject::cleanUp() {
	//DPF(DPF_VERRBOSE,"_dxj_DPAddress object being destroyed");
	if (m_pAddress) free (m_pAddress);
	m_size=0;
}



HRESULT C_dxj_DPAddressObject::setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) {

	if (m_pAddress) free (m_pAddress);
	m_pAddress=NULL;
	m_pAddress=malloc((DWORD)length);
	if (m_pAddress==NULL) return E_OUTOFMEMORY;

	if (pAddress==NULL) return E_FAIL;	
	memcpy((void*)m_pAddress,(void*)pAddress,length);
	m_size=(DWORD)length; 

	return S_OK;

 }
        
HRESULT C_dxj_DPAddressObject::getAddress( 
            /* [out] */ long  *pAddress,
            /* [out] */ long  *length) {

	*pAddress=(long)PtrToLong(m_pAddress);	//bugbug SUNDOWN- sundown wont be able to do this
					//will need to implement new non VB interface to get at this functionality internally
	*length=(long)m_size;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplications.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumlocalapplications.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumLocalApplicationsObject : 
	public I_dxj_DPEnumLocalApplications,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumLocalApplicationsObject() ;
	virtual ~C_dxj_DPEnumLocalApplicationsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumLocalApplicationsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumLocalApplications)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumLocalApplicationsObject)

public:
		
	
		HRESULT STDMETHODCALLTYPE getItem( long index, DPLAppInfo *desc);		
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(IDirectPlayLobby3 * pdp,  long flags, I_dxj_DPEnumLocalApplications **ppRet);

public:
		DPLAppInfo	*m_pList;		
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplicationsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumlocalapplicationsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumLocalApplicationsObject : 
	public I_dxj_DPEnumLocalApplications,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumLocalApplicationsObject() ;
	virtual ~C_dxj_DPEnumLocalApplicationsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumLocalApplicationsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumLocalApplications)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumLocalApplicationsObject)

public:
		
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
        
        HRESULT STDMETHODCALLTYPE getName( long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret) ;
        
        HRESULT STDMETHODCALLTYPE getGuid( long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret) ;
		
		
		static HRESULT create(	IDirectPlayLobby3 * pdp,	long flags, I_dxj_DPEnumLocalApplications **ppRet);

public:
		DPLAppInfo	*m_pList;		
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DPEnumObj.h"

extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);

//typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );

extern "C" BOOL PASCAL objEnumServiceProvidersCallback(LPGUID lpGUID,  LPWSTR lpName, 
					DWORD dwMajorVersion,DWORD dwMinorVersion, void *lpArg)
{

	DPF(1,"Entered objEnumServiceProvidersCallback\r\n");



	C_dxj_DPEnumObject *pObj=(C_dxj_DPEnumObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DPServiceProvider)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DPServiceProvider*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DPServiceProvider*)malloc(sizeof(DPServiceProvider)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	USES_CONVERSION;


	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPServiceProvider));
	pObj->m_pList[pObj->m_nCount].strGuid=DPLGUIDtoBSTR((GUID*)lpGUID);
	
	if (lpName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=W2BSTR(lpName);
	}

	pObj->m_pList[pObj->m_nCount].lMajorVersion=(DWORD)dwMajorVersion;
	pObj->m_pList[pObj->m_nCount].lMinorVersion=(DWORD)dwMinorVersion;

	pObj->m_nCount++;

	return TRUE;
}




C_dxj_DPEnumObject::C_dxj_DPEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}

C_dxj_DPEnumObject::~C_dxj_DPEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString((BSTR)m_pList[i].strGuid);
			if (m_pList[i].strName) SysFreeString((BSTR)m_pList[i].strName);			
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DPEnumObject::create(DIRECTPLAYENUMERATE pcbFunc,I_dxj_DPEnumServiceProviders **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DPEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objEnumServiceProvidersCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}
	
	hr=pNew->QueryInterface(IID_I_dxj_DPEnumServiceProviders,(void**)ppRet);


	return hr;
}

HRESULT C_dxj_DPEnumObject::getName( long index, BSTR __RPC_FAR *ret)
{

	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=SysAllocString(m_pList[index-1].strName);
	return S_OK;

}
        
HRESULT C_dxj_DPEnumObject::getGuid( long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DPEnumObject::getVersion( 
            /* [in] */ long index,
            /* [in] */ long __RPC_FAR *majorVersion,
            /* [out][in] */ long __RPC_FAR *minorVersion)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	*majorVersion=m_pList[index-1].lMajorVersion;
	*minorVersion=m_pList[index-1].lMinorVersion;
	return S_OK;
}

HRESULT C_dxj_DPEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

/*
HRESULT C_dxj_DPEnumObject::getItem( long index, DPServiceProvider *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	ZeroMemory(info,sizeof(DPServiceProvider));
	
	if  (info->strGuid) SysFreeString((BSTR)info->strGuid);
	if  (info->strName) SysFreeString((BSTR)info->strName);


	if (m_pList[index].strGuid) info->strGuid=SysAllocString(m_pList[index].strGuid);
	if (m_pList[index].strName) info->strName=SysAllocString(m_pList[index].strName);
	info->lMajorVersion=m_pList[index].lMajorVersion;
	info->lMinorVersion=m_pList[index].lMinorVersion;
	
	return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DPEnumObject : 
	public I_dxj_DPEnumServiceProviders,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumObject() ;
	virtual ~C_dxj_DPEnumObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumServiceProviders)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getVersion( 
            /* [in] */ long index,
            /* [in] */ long __RPC_FAR *majorVersion,
            /* [out][in] */ long __RPC_FAR *minorVersion);
		
		HRESULT STDMETHODCALLTYPE getCount( long *count);
        
		static HRESULT C_dxj_DPEnumObject::create(DIRECTPLAYENUMERATE pcbFunc,I_dxj_DPEnumServiceProviders **ppRet);
		

public:
		DPServiceProvider *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumsessionsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumsessionsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpSessdataObj.h"
#include "DPEnumSessionsObj.h"



extern  BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoPPGUID(LPGUID *,BSTR);
extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc);


/////////////////////////////////////////////////////////////////////////////

extern "C" BOOL PASCAL objEnumSessionsCallback2(const DPSESSIONDESC2 *gameDesc,
						 	 DWORD *timeout, DWORD dwFlags, void *lpArg)
{
	
	DPF(1,"Entered objEnumSessionsCallback2\r\n");

	
	//with no elements in a list will still call this callback once
	if (!gameDesc) return FALSE;

	C_dxj_DPEnumSessionsObject *pObj=(C_dxj_DPEnumSessionsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DPSessionDesc2)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DPSessionDesc2*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DPSessionDesc2*)malloc(sizeof(DPSessionDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPSessionDesc2));
	FillCoverSessionDesc(&(pObj->m_pList[pObj->m_nCount]),(DPSESSIONDESC2*)gameDesc);
	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumSessionsObject::C_dxj_DPEnumSessionsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumSessionsObject::~C_dxj_DPEnumSessionsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPSessionDesc2 *sessionDesc=&(m_pList[i]);
			if (sessionDesc->strGuidInstance) SysFreeString((BSTR)sessionDesc->strGuidInstance);
			if (sessionDesc->strGuidApplication) SysFreeString((BSTR)sessionDesc->strGuidApplication);
			if (sessionDesc->strSessionName) SysFreeString((BSTR)sessionDesc->strSessionName);
			if (sessionDesc->strPassword) SysFreeString((BSTR)sessionDesc->strPassword);

		}
		free(m_pList);
	}

}

HRESULT C_dxj_DPEnumSessionsObject::create(
		IDirectPlay4 * pdp,
		I_dxj_DirectPlaySessionData *sess,
		long timeout, long flags, I_dxj_DPEnumSessions2 **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumSessionsObject *pNew=NULL;

	if (!sess) return E_INVALIDARG;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumSessionsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	if (sess){
		DPSESSIONDESC2 dpSessionDesc;
		//hr=FillRealSessionDesc(&dpSessionDesc,sess);
		//if FAILED(hr) return hr;
		sess->AddRef();

		sess->getData((void*)&dpSessionDesc);

		hr = pdp->EnumSessions(&dpSessionDesc, (DWORD)timeout, objEnumSessionsCallback2, pNew,(DWORD) flags);
		//if (dpSessionDesc.lpszSessionName)	SysFreeString((BSTR)dpSessionDesc.lpszSessionName);
		//if (dpSessionDesc.lpszPassword)		SysFreeString((BSTR)dpSessionDesc.lpszPassword);
		sess->Release();

	}
	else {
		hr = pdp->EnumSessions(NULL,(DWORD)timeout, objEnumSessionsCallback2, pNew,(DWORD) flags);
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;



	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumSessions2,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DPEnumSessionsObject::getItem( long index, I_dxj_DirectPlaySessionData **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr=C_dxj_DirectPlaySessionDataObject::create(&(m_pList[index-1]),info);
	
	/*
	memcpy(info,&(m_pList[index]),sizeof(DPSessionDesc2));

	if (info->strGuidInstance) SysFreeString((BSTR)info->strGuidInstance);
	if (info->strGuidApplication) SysFreeString((BSTR)info->strGuidApplication);
	if (info->strSessionName) SysFreeString((BSTR)info->strSessionName);
	if (info->strPassword) SysFreeString((BSTR)info->strPassword);

	info->strGuidInstance=  SysAllocString(m_pList[index].strGuidInstance);
	info->strGuidApplication=  SysAllocString(m_pList[index].strGuidApplication);
	info->strSessionName = SysAllocString(m_pList[index].strSessionName);
	info->strPassword = SysAllocString(m_pList[index].strPassword);
	*/
	return hr;
}

HRESULT C_dxj_DPEnumSessionsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplicationsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumlocalapplicationsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumLocalApplicationsObj.h"


extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL  PASCAL objEnumLocalApplicationsCallback(
					LPCDPLAPPINFO lpAppInfo, 
					LPVOID lpArg, DWORD dwFlags)
{

	DPF(1,"Entered objEnumLocalApplicationsCallback\r\n");
	
	C_dxj_DPEnumLocalApplicationsObject *pObj=(C_dxj_DPEnumLocalApplicationsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DPLAppInfo)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DPLAppInfo*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DPLAppInfo*)malloc(sizeof(DPLAppInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	
	}
	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPLAppInfo));
	
	if (!lpAppInfo) {
		pObj->m_bProblem=TRUE;
		return FALSE;
	}

	
	pObj->m_pList[pObj->m_nCount].strGuidApplication= DPLGUIDtoBSTR((GUID*)&(lpAppInfo->guidApplication));
	
	if (lpAppInfo->lpszAppName)
		pObj->m_pList[pObj->m_nCount].strAppName = SysAllocString(lpAppInfo->lpszAppName);
	
	//pObj->m_pList[pObj->m_nCount].lFlags=(DWORD)dwFlags;

	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumLocalApplicationsObject::C_dxj_DPEnumLocalApplicationsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumLocalApplicationsObject::~C_dxj_DPEnumLocalApplicationsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPLAppInfo *conn=&(m_pList[i]);
			if (conn->strGuidApplication ) SysFreeString((BSTR)conn->strGuidApplication);
			if (conn->strAppName) SysFreeString((BSTR)conn->strAppName);						
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DPEnumLocalApplicationsObject::create(
		IDirectPlayLobby3 * pdp,
		long flags, I_dxj_DPEnumLocalApplications **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumLocalApplicationsObject *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumLocalApplicationsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	hr = pdp->EnumLocalApplications(
			objEnumLocalApplicationsCallback, 
			pNew, (DWORD)flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;
	
	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumLocalApplications,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DPEnumLocalApplicationsObject::getName(  long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strAppName);
	return S_OK;
}





HRESULT C_dxj_DPEnumLocalApplicationsObject::getGuid(  long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strGuidApplication);
	return S_OK;
}        
       

/*
HRESULT C_dxj_DPEnumLocalApplicationsObject::getItem( long index, DPLAppInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DPLAppInfo));


	if (info->strGuidApplication) SysFreeString((BSTR)info->strGuidApplication);
	if (info->strAppName) SysFreeString((BSTR)info->strAppName);

	info->strAppName=SysAllocString(info->strAppName);
	info->strGuidApplication=SysAllocString(info->strGuidApplication);

	
	return S_OK;
}
*/

HRESULT C_dxj_DPEnumLocalApplicationsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumplayersobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumplayersobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumPlayersObj.h"


extern  BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoPPGUID(LPGUID *,BSTR);
extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);

/////////////////////////////////////////////////////////////////////////////
// The callback is invoked as a result of IDirectPlay2::EnumPlayers(), 
// IDirectPlay2::EnumGroups() and IDirectPlay2::EnumGroupPlayers() calls.
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL PASCAL objEnumPlayersCallback2(DPID dpid, 
						DWORD dwPlayerType, LPCDPNAME lpName,
						DWORD dwFlags, LPVOID lpArg)
{
	
	DPF(1,"Entered objEnumPlayersCallback2 \r\n");


	C_dxj_DPEnumPlayersObject *pObj=(C_dxj_DPEnumPlayersObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DPPlayerInfo)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DPPlayerInfo*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DPPlayerInfo*)malloc(sizeof(DPPlayerInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPPlayerInfo));
	pObj->m_pList[pObj->m_nCount].lDPID=(long)dpid;
	pObj->m_pList[pObj->m_nCount].lPlayerType=(long)dwPlayerType;
	pObj->m_pList[pObj->m_nCount].lFlags=(long)dwFlags;

	//unsing unicode DPLAY
	pObj->m_pList[pObj->m_nCount].strShortName=SysAllocString(lpName->lpszShortName);
	pObj->m_pList[pObj->m_nCount].strLongName=SysAllocString(lpName->lpszLongName);
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DPEnumPlayersObject::C_dxj_DPEnumPlayersObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumPlayersObject::~C_dxj_DPEnumPlayersObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if( m_pList[i].strShortName) SysFreeString((BSTR)m_pList[i].strShortName);
			if( m_pList[i].strLongName) SysFreeString((BSTR)m_pList[i].strLongName);			
		}
		free(m_pList);
	}

}

HRESULT C_dxj_DPEnumPlayersObject::create(IDirectPlay3 * pdp, long customFlags,long id, BSTR strGuid,long flags, I_dxj_DPEnumPlayers2 **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumPlayersObject *pNew=NULL;
	GUID g;
	LPGUID pguid=&g;

	hr= DPLBSTRtoPPGUID(&pguid,strGuid);
	if FAILED(hr) return hr;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumPlayersObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


	switch (customFlags){
		case DPENUMGROUPSINGROUP:
			hr = pdp->EnumGroupsInGroup((DPID)id,(GUID*) pguid,
						objEnumPlayersCallback2,
						pNew, (long)flags);
			break;
		case DPENUMPLAYERS:
			hr=pdp->EnumPlayers((GUID*) pguid,
						objEnumPlayersCallback2,
						pNew, (long)flags);
			break;
		case DPENUMGROUPPLAYERS:

			hr = pdp->EnumGroupPlayers( (DPID)id, (GUID*)pguid,
								objEnumPlayersCallback2,
								pNew, flags);
			break;
		case DPENUMGROUPS:
			hr=pdp->EnumGroups( (GUID*)pguid,
						objEnumPlayersCallback2,
						pNew, (DWORD)flags);

			break;
		default:
			hr=E_INVALIDARG;
			break;
	}
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumPlayers2,(void**)ppRet);
	return hr;
}

/* DEAD
HRESULT C_dxj_DPEnumPlayersObject::getItem( long index, DPPlayerInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DPPlayerInfo));


	if (info->strShortName) SysFreeString((BSTR)info->strShortName);
    if (info->strLongName) SysFreeString((BSTR)info->strLongName);

	//unsing unicode DPLAY
	info->strShortName=SysAllocString(m_pList[index].strShortName);
	info->strLongName=SysAllocString(m_pList[index].strLongName);
	
	
	return S_OK;
}
*/


HRESULT C_dxj_DPEnumPlayersObject::getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lFlags;
	return S_OK;
}
        
 
HRESULT C_dxj_DPEnumPlayersObject::getType( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lPlayerType;
	return S_OK;
}



HRESULT C_dxj_DPEnumPlayersObject::getDPID( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lDPID;
	return S_OK;
}


HRESULT C_dxj_DPEnumPlayersObject::getShortName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strShortName);
	return S_OK;
}        


HRESULT C_dxj_DPEnumPlayersObject::getLongName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strLongName);
	return S_OK;
}        
        
HRESULT C_dxj_DPEnumPlayersObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumplayersobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumplayersobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

#define DPENUMGROUPSINGROUP 1
#define DPENUMPLAYERS 2	
#define DPENUMGROUPPLAYERS 3
#define DPENUMGROUPS 4


class C_dxj_DPEnumPlayersObject : 
	public I_dxj_DPEnumPlayers2,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumPlayersObject() ;
	virtual ~C_dxj_DPEnumPlayersObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumPlayersObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumPlayers2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumPlayersObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getDPID( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getShortName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getLongName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        		
		static HRESULT C_dxj_DPEnumPlayersObject::create(IDirectPlay3 * pdp, long customFlags,long groupId, BSTR strGuid, long flags, I_dxj_DPEnumPlayers2 **ppRet);
								
		
		


public:
		DPPlayerInfo *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpladdressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpladdressobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_DPAddressObject :
		public IDPAddress,
		public CComCoClass<C_DPAddressObject, &CLSID__DPAddress>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_DPAddressObject)
		COM_INTERFACE_ENTRY(IDPAddress)
	END_COM_MAP()

	DECLARE_REGISTRY(CLSID__DPAddress, "DIRECT.DPAddress.5",		"DIRECT.DPAddress.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_DPAddressObject)

public:
	C_DPAddressObject();
	~C_DPAddressObject();

  virtual HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getAddress( 
            /* [out] */ long __RPC_FAR *pAddress,
            /* [out] */ long __RPC_FAR *length) = 0;
                
private:
	DPAddress m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	IUnknown	  *nextobj;
	DWORD		  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};

extern IUnknown *g_DPAddress;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpenumsessionsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumsessionsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumSessionsObject : 
	public I_dxj_DPEnumSessions2,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumSessionsObject() ;
	virtual ~C_dxj_DPEnumSessionsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumSessionsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumSessions2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumSessionsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectPlaySessionData **desc);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DPEnumSessionsObject::create(IDirectPlay4 * pdp, I_dxj_DirectPlaySessionData *desc, long timeout,long flags, I_dxj_DPEnumSessions2 **ppRet);

public:
		DPSessionDesc2 *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplay4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplay4obj.cpp
//
//--------------------------------------------------------------------------

// _dxj_DirectPlay2Obj.cpp : Implementation of C_dxj_DirectPlay2Object
// DHF begin - entire file




#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlay.h"
#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "dPlay4Obj.h"
#include "DPEnumPlayersObj.h"
#include "DPEnumSessionsObj.h"
#include "DPEnumConnectionsObj.h"
#include "dpMsgObj.h"
#include "dpSessDataObj.h"


typedef HRESULT (__stdcall *DIRECTPLAYCREATE)( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);
extern DIRECTPLAYCREATE pDirectPlayCreate;
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
extern DIRECTPLAYENUMERATE pDirectPlayEnumerate;

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc);

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern void *g_dxj_DirectPlay4;

C_dxj_DirectPlay4Object::C_dxj_DirectPlay4Object()
{
	m__dxj_DirectPlay4 = NULL;
	parent = NULL; 	
	nextobj = g_dxj_DirectPlay4;
	g_dxj_DirectPlay4 = this;
	creationid = ++g_creationcount;
}

DESTRUCTOR(_dxj_DirectPlay4, {})
GETSET_OBJECT(_dxj_DirectPlay4);

//
/*** I_dxj_DirectPlay4 methods ***/
//
PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, addPlayerToGroup, AddPlayerToGroup, Dpid,(DPID), Dpid,(DPID));
PASS_THROUGH_R(_dxj_DirectPlay4, close, Close);
//PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, initialize, Initialize, DxGuid*, (LPGUID));
PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, deletePlayerFromGroup, DeletePlayerFromGroup, Dpid, (DPID), Dpid, (DPID));
PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, destroyPlayer, DestroyPlayer, Dpid,(DPID));
PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, destroyGroup, DestroyGroup, Dpid,(DPID));

PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, getMessageCount, GetMessageCount, Dpid,(DPID), long *,(DWORD*));
//PASS_THROUGH_CAST_3_R(_dxj_DirectPlay4, getPlayerCaps, GetPlayerCaps, Dpid, (DPID), DPCaps*, (DPCAPS*), long, (DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, startSession, StartSession, long, (DWORD), Dpid, (DPID));
//PASS_THROUGH_CAST_3_R(_dxj_DirectPlay4, getPlayerCaps, GetPlayerCaps, Dpid, (DPID), DPCaps*, (DPCAPS*), long, (DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, getCaps, GetCaps, DPCaps*, (LPDPCAPS), long, (DWORD));

STDMETHODIMP C_dxj_DirectPlay4Object::getCaps(DPCaps *c,long flags){
	if (!c) return E_INVALIDARG;
	c->lSize=sizeof(DPCAPS);
	HRESULT hr = m__dxj_DirectPlay4->GetCaps((DPCAPS*)c,(DWORD)flags);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::startSession(Dpid id){
	HRESULT hr = m__dxj_DirectPlay4->StartSession(0,(DPID)id);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerCaps(Dpid id, DPCaps *caps, long flags)
{
	((DPCAPS*)caps)->dwSize=sizeof(DPCAPS);
	HRESULT hr = m__dxj_DirectPlay4->GetPlayerCaps((DPID)id,(DPCAPS*)caps,(DWORD)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::createGroup( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
					   long flags,
            /* [retval][out] */ Dpid  *v1) 
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));

	dpName.dwSize = sizeof(dpName);
	

	if ((!friendlyName) ||(!formalName)) return E_INVALIDARG;

	if (0==_wcsicmp(friendlyName,formalName)) return E_INVALIDARG;


	if ( friendlyName[0]!=0 )
	{
		__try { dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(friendlyName)+1)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		wcscpy(dpName.lpszShortName, friendlyName);
	}
	if ( formalName[0]!=0 )
	{
		__try { dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(formalName)+1)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		wcscpy(dpName.lpszLongName, formalName);
	}
		
	HRESULT hr = m__dxj_DirectPlay4->CreateGroup((DWORD*)v1, &dpName, NULL, 0, (DWORD)flags);

	return hr;

}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::createPlayer( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long receiveEvent,
			/* [in] */ long flags,
            /* [retval][out] */ Dpid __RPC_FAR *v1) 
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	
	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize = sizeof(DPNAME);

	if ((!friendlyName) ||(!formalName)) return E_INVALIDARG;

	if (0==_wcsicmp(friendlyName,formalName)) return E_INVALIDARG;
			

	if ( friendlyName[0]!=0 )
	{
		dpName.lpszShortName = (LPWSTR)friendlyName;
		//dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(friendlyName)+1));
		//wcscpy(dpName.lpszShortName, friendlyName);
	}
	if ( formalName[0]!=0 )
	{
		//dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(formalName)+1));
		//wcscpy(dpName.lpszLongName, formalName);
		dpName.lpszLongName = (LPWSTR)formalName;
	}
	
	HRESULT hr = m__dxj_DirectPlay4->CreatePlayer((DWORD*)v1, &dpName, (LPVOID)receiveEvent, NULL, 0, (DWORD)flags);


	//if (dpName.lpszShortName) free(dpName.lpszShortName);
	//if (dpName.lpszLongName) free(dpName.lpszLongName);

	
	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroupPlayers(
		Dpid groupPID,
		BSTR strGuid,
		long flags,
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPPLAYERS,groupPID,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroups(
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPS,0,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroupsInGroup(
		Dpid groupPID,
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPSINGROUP,groupPID,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumPlayers(
		BSTR strGuid,
		long flags,
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMPLAYERS,0,strGuid,flags,retVal);
		return hr;
}


//////////////////////////////////////////////////////////////////////////
// USE void because we can accept null in VB
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumSessions(
		I_dxj_DirectPlaySessionData *sessionDesc,
		long timeout,
		long flags, 
		I_dxj_DPEnumSessions2 **retVal)
{				
		HRESULT hr=C_dxj_DPEnumSessionsObject::create(m__dxj_DirectPlay4,sessionDesc,timeout,flags,retVal);
		return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupData(  Dpid id,long flags,   BSTR *ret)
{
	
	DWORD	size;
	HRESULT hr;
	void	*pData=NULL;

	//ASSERT ( m__dxj_DirectPlay4 != NULL )		
	if (!ret) return E_INVALIDARG;

	hr= m__dxj_DirectPlay4->GetGroupData((DWORD)id, (void*)NULL, (LPDWORD)&size, (DWORD)flags);	
	
	if (size==0) {
		*ret=NULL;
		return S_OK;
	}

	//we only want data we can cast to a string
	if ((size % 2)!=0) return E_INVALIDARG;

	
	pData=malloc(size+2);
	if (!pData) return E_OUTOFMEMORY;	

	//null terminate.
	((char*)pData)[size]='\0';
	((char*)pData)[size+1]='\0';

	hr= m__dxj_DirectPlay4->GetGroupData((DWORD)id, (void*)pData, (LPDWORD)&size, (DWORD)flags);	
	if FAILED(hr) 	{
		if (pData) free(pData);
		return hr;
	}
	
	*ret=SysAllocString((WCHAR*)pData);

	if (pData) free(pData);

	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupShortName(Dpid id, BSTR *friendlyN) 
{
	DWORD dwDataSize;

	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if(!friendlyN) return E_INVALIDARG;

	*friendlyN=NULL;

	HRESULT hr=m__dxj_DirectPlay4->GetGroupName(id, (char*)NULL, &dwDataSize);
	
	if (dwDataSize<sizeof(DPNAME)) return E_INVALIDARG;
	
	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = NULL;
	__try { dpName = (LPDPNAME)alloca(dwDataSize); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	hr = m__dxj_DirectPlay4->GetGroupName((DPID)id, dpName, &dwDataSize);	
	if FAILED(hr) return hr;
	*friendlyN = SysAllocString(dpName->lpszShortName);	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupLongName(Dpid id, BSTR *formalN) 
{
	DWORD dwDataSize=0;

	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;
	
	if(!formalN) return E_INVALIDARG;

	*formalN=NULL;

	HRESULT hr=m__dxj_DirectPlay4->GetGroupName(id, (char*)NULL, &dwDataSize);
		
	if (dwDataSize<sizeof(DPNAME)) return E_INVALIDARG;

	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = NULL;
	__try { dpName = (LPDPNAME)alloca(dwDataSize); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	hr = m__dxj_DirectPlay4->GetGroupName(id, dpName, &dwDataSize);
	if FAILED(hr) return hr;
	*formalN = SysAllocString(dpName->lpszLongName);			
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Gets a DirectPlay abstract address using a player id 
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerAddress( 
            /* [in] */ Dpid id,
            /* [out] */ I_dxj_DPAddress **ret)            
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	void *pAddress;
	DWORD size=0;

	HRESULT hr;

	hr= m__dxj_DirectPlay4->GetPlayerAddress((DPID)id, NULL,&size);
	if (size==0) return E_FAIL;

	pAddress=malloc(size);
	if (pAddress==NULL) return E_OUTOFMEMORY;

	hr= m__dxj_DirectPlay4->GetPlayerAddress((DPID)id,pAddress,&size);

	if FAILED(hr){
		free(pAddress);
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,ret);
	
	if (*ret==NULL) return E_OUTOFMEMORY;

	hr=(*ret)->setAddress((long)PtrToLong(pAddress),size);	//bugbug SUNDOWN
	free(pAddress);

	return hr;
}


//////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerData( 
            /* [in] */ Dpid id,
			long flags,
            /* [out] */ BSTR *ret)
{

	DWORD	size;
	HRESULT hr;
	void	*pData=NULL;

	//ASSERT ( m__dxj_DirectPlay4 != NULL )		

	hr=m__dxj_DirectPlay4->GetPlayerData((DWORD)id, (void*)NULL, (LPDWORD)&size, (DWORD)flags);
	
	if (size==0) {
		*ret=NULL;
		return S_OK;
	}

	//we only want data we can cast to a string
	if ((size % 2)!=0) return E_INVALIDARG;

	pData=malloc(size+sizeof(WCHAR));	
	if (!pData) return E_OUTOFMEMORY;

	ZeroMemory(pData,size+sizeof(WCHAR));
	
	hr= m__dxj_DirectPlay4->GetPlayerData((DWORD)id, (void*)pData, (LPDWORD)&size, (DWORD)flags);	
	if FAILED(hr) 	{
		if (pData) free(pData);
	}
	
	*ret=SysAllocString((WCHAR*)pData);

	if (pData) free(pData);

	return hr;	
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFriendlyName(Dpid id, BSTR *friendlyN) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD dwDataSize;

	HRESULT hr;
	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, (char*)NULL, &dwDataSize);	

	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = NULL;
	__try { dpName = (LPDPNAME)alloca(dwDataSize); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	
	hr = m__dxj_DirectPlay4->GetPlayerName((DPID)id, dpName, &dwDataSize);
	if FAILED(hr) return hr;

	*friendlyN = SysAllocString(dpName->lpszShortName);	
	

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFormalName(Dpid id, BSTR *formalN) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD dwDataSize;
	HRESULT hr;

	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, (char*)NULL, &dwDataSize);

	//// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = NULL;
	__try { dpName = (LPDPNAME)alloca(dwDataSize); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);

	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, dpName, &dwDataSize); // get ANSI
	if FAILED(hr) return hr;

	*formalN = SysAllocString(dpName->lpszLongName);
	
	
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Gets the current session description
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getSessionDesc(
			/* [out] */ I_dxj_DirectPlaySessionData __RPC_FAR **sessionDesc)
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if ( sessionDesc == NULL )
		return E_FAIL;

	DWORD dataSize = 0;
	HRESULT hr = m__dxj_DirectPlay4->GetSessionDesc(NULL, &dataSize);

	LPVOID data = NULL;
	__try { data = (LPDPNAME)alloca(dataSize); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	hr = m__dxj_DirectPlay4->GetSessionDesc((LPVOID)data, &dataSize);
	if(hr != DP_OK) {
		return hr;
	}
	LPDPSESSIONDESC2 dpSessionDesc = (LPDPSESSIONDESC2)data;

	hr=C_dxj_DirectPlaySessionDataObject::create(dpSessionDesc,sessionDesc);

	return hr;
}



//////////////////////////////////////////////////////////////////////////
// Establish a gaming session instance - create or join a game session
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::open(I_dxj_DirectPlaySessionData *sessionDesc,	long flags)
{
	
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if ( sessionDesc == NULL )
		return E_INVALIDARG;

	DPSESSIONDESC2	dpSessionDesc;
	
	//CONSIDER - validating sessiondesc object
	//	     to return friendly error

	sessionDesc->AddRef();
	sessionDesc->getData(&dpSessionDesc);
	
	
	HRESULT hr = m__dxj_DirectPlay4->Open(&dpSessionDesc, flags);

	//SysFreeString((BSTR)dpSessionDesc.lpszPassword);
	//SysFreeString((BSTR)dpSessionDesc.lpszSessionName);
	sessionDesc->Release();

	if FAILED(hr) return hr;

	//FillCoverSessionDesc(sessionDesc,&dpSessionDesc);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::receive( 
            /* [in, out] */ Dpid  *fromPlayerId,
            /* [in, out] */ Dpid  *toPlayerId,
            /* [in]  */ long flags,
			I_dxj_DirectPlayMessage **msg )

{
	
	
	HRESULT hr;
	DWORD dwSize=0;
    void  *pData=NULL;
	
	
	//#pragma message ("check with DPLAY folks if this is necessary")
	//DONE: The loop is not neccesary.. 
	//aaronO indicated the message order is consistent
	//a call to recieve to get the size can always be folowed by a call to get 
	//the message - ANDREWKE
	//
	//BOOL  fCont=TRUE;
	//while (fCont){

	hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, (DWORD)flags, NULL, &dwSize);
	
	//fix for manbug24192
	if 	(hr == DPERR_NOMESSAGES ) {
		*msg=NULL;
		return S_OK;
	}
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;
	

	hr=C_dxj_DirectPlayMessageObject::create((DWORD)*fromPlayerId,dwSize,&pData,msg);
	if FAILED(hr) return hr;
	
	hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, (DWORD)flags,pData, &dwSize);

	//should never hit this
	// if ( hr == DPERR_BUFFERTOOSMALL){
	//	fCont=TRUE;
	//	(*msg)->Release();
	//	
	// }
	// else{
	//	fCont=FALSE;
	// }
	//} end while
	
	if 	FAILED(hr) {
		if (*msg) (*msg)->Release();
		*msg=NULL;		
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectPlay4Object::receiveSize( 
            /* [in,out] */ Dpid  *fromPlayerId,
            /* [in,out] */ Dpid  *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ int *dataSize)
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	unsigned long  *id1 = 0, *id2 = 0;

	HRESULT hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, 
		(DWORD)flags, (void*)NULL, (LPDWORD)dataSize);
	if ( hr == DPERR_BUFFERTOOSMALL || hr == DPERR_NOMESSAGES )
		hr = S_OK;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::send( 
            /* [in] */ Dpid fromPlayerId,
            /* [in] */ Dpid toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage *msg)            
{
	
	HRESULT hr;	
	void *pdata=NULL;
	DWORD dataSize=0;
	
	if (!msg) return E_INVALIDARG;

	__try {
		msg->getPointer((long*)&pdata);
		msg->getMessageSize((long*)&dataSize);
		hr= m__dxj_DirectPlay4->Send((DPID)fromPlayerId, (DPID)toPlayerId, (DWORD)flags, 
			(void*)pdata, (DWORD) dataSize);
	}
	__except (1,1)
	{
		return E_INVALIDARG;	
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setGroupData( 
            /* [in] */ long id,
            /* [in] */ BSTR data,            
            /* [in] */ long flags)        
{
	
	HRESULT hr;
	DWORD datasize=0;
	void *pdata=NULL;
	
	if (data){
		pdata=data;
		datasize= ((DWORD*)data)[-1];
	}
	
	__try {
		hr = m__dxj_DirectPlay4->SetGroupData((DPID)id,(void*)pdata,
				(DWORD)datasize, (DWORD)flags);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setGroupName( 
            /* [in] */ Dpid id,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags) 
{
	//ASSERT( m__dxj_DirectPlay4 != NULL )
		

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize = sizeof(DPNAME);
	
	dpName.lpszShortName=NULL;
	dpName.lpszLongName=NULL;

	if ( friendlyName )
	{
		dpName.lpszShortName = friendlyName;
	}
	if ( formalName )
	{
		dpName.lpszLongName = formalName;		
	}

	HRESULT hr = m__dxj_DirectPlay4->SetGroupName((DPID)id, &dpName, flags);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setPlayerData( 
            /* [in] */ long id,
            /* [in] */ BSTR data,
            /* [in] */ long flags)        
{

		HRESULT hr;
	DWORD datasize=0;
	void *pdata=NULL;
	
	if (data){
		if (data[0]!=0x00) {
			pdata=data;
			datasize= ((DWORD*)data)[-1];
		}
	}
	
	__try {
		hr = m__dxj_DirectPlay4->SetPlayerData((DPID)id,(void*)pdata,
				(DWORD)datasize, (DWORD)flags);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setPlayerName( 
            /* [in] */ Dpid id,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD l=0;

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME))	;	
	dpName.dwSize=sizeof(DPNAME);
	dpName.lpszShortName = friendlyName;
	dpName.lpszLongName = formalName;
	
  	HRESULT hr = m__dxj_DirectPlay4->SetPlayerName((DPID) id, &dpName, (DWORD)flags);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Sets the current session description
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc           
		   )
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if (!sessionDesc) return E_INVALIDARG;

	DPSESSIONDESC2	dpSessionDesc;
	sessionDesc->AddRef();
	sessionDesc->getData(&dpSessionDesc);
	HRESULT hr = m__dxj_DirectPlay4->SetSessionDesc(&dpSessionDesc, 0);
	sessionDesc->Release();
	
	return hr;
}



STDMETHODIMP C_dxj_DirectPlay4Object::setGroupConnectionSettings(// long flags,
																 Dpid idGroup, I_dxj_DPLConnection *connect)
{
	DPLCONNECTION *con;
	connect->getConnectionStruct((long*)&con);
	
	HRESULT hr = m__dxj_DirectPlay4->SetGroupConnectionSettings((DWORD)0,(DPID) idGroup,con);
	
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::sendChatMessage( 
		Dpid fromPlayerId, Dpid toPlayerId, long flags, BSTR message)
{

	DPCHAT  dpChat;	

	dpChat.dwSize=sizeof(DPCHAT);
	dpChat.dwFlags=(DWORD)0;
	dpChat.lpszMessage=message;

	HRESULT hr = m__dxj_DirectPlay4->SendChatMessage((DPID)fromPlayerId,(DPID)toPlayerId,(DWORD)flags,&dpChat);

	
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::secureOpen(I_dxj_DirectPlaySessionData *desc, 
		long flags, DPSecurityDesc *security, DPCredentials *credentials){

	DPSESSIONDESC2 dpSessionDesc;
	DPSECURITYDESC dpSecurity;
	DPCREDENTIALS  dpCredentials;

	LPCDPSECURITYDESC lpSecurity=NULL;
	LPCDPCREDENTIALS lpCredentials=NULL;
	DWORD			l=0,i,j;

	if (desc==NULL) return E_INVALIDARG;
	//FillRealSessionDesc(&dpSessionDesc,desc);
	


	ZeroMemory((void*)&dpSecurity,sizeof(DPSECURITYDESC));
	ZeroMemory((void*)&dpCredentials,sizeof(DPCREDENTIALS));


	if (security){
		
		//if all members are NULL then replace with null pointer
		j=0;

		for (i=0;i<sizeof(DPSecurityDesc);i++){
			if (((char*)security)[i]==0) j++;
		}

				
		if (j!=sizeof(DPSecurityDesc)){


			dpSecurity.dwSize=sizeof(DPSECURITYDESC);
			l=0;l=wcslen(security->strSSPIProvider);
			if (l){
				dpSecurity.lpszSSPIProvider = SysAllocString(security->strSSPIProvider);				
			}	

			l=0;l=wcslen(security->strCAPIProvider);
			if (l){
				dpSecurity.lpszCAPIProvider = SysAllocString(security->strCAPIProvider);				
			}	
	
			lpSecurity=&dpSecurity;
		}
	}
	
	
	if (credentials){
		

		//if all members are NULL then replace with null pointer
		j=0;
		for (i=0;i<sizeof(DPCredentials);i++){
			if (((char*)credentials)[i]==0) j++;
		}

		if (j!=sizeof(DPCredentials)){
			
			dpCredentials.dwSize=sizeof(DPCREDENTIALS);


			l=0;l=wcslen(credentials->strUsername);
			if (l){
				//dpCredentials.lpszUsername = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszUsername , credentials->username);
				dpCredentials.lpszUsername=SysAllocString(credentials->strUsername);
			}	

			l=0;l=wcslen(credentials->strPassword);
			if (l){
				//dpCredentials.lpszPassword = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszPassword , credentials->password);
				dpCredentials.lpszPassword = SysAllocString(credentials->strPassword);
			}	

			l=0;l=wcslen(credentials->strDomain);
			if (l){
				//dpCredentials.lpszDomain = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszDomain , credentials->domain);
				dpCredentials.lpszDomain = SysAllocString(credentials->strDomain);
			}	

			lpSecurity=&dpSecurity;
		}
	}
	
	desc->AddRef();
	desc->getData(&dpSessionDesc);

	HRESULT hr = m__dxj_DirectPlay4->SecureOpen(&dpSessionDesc,(DWORD)flags,
			lpSecurity,	lpCredentials);

	desc->Release();

	if (dpCredentials.lpszDomain)	SysFreeString((BSTR)dpCredentials.lpszDomain);
	if (dpCredentials.lpszPassword) SysFreeString((BSTR)dpCredentials.lpszPassword);
	if (dpCredentials.lpszUsername)	SysFreeString((BSTR)dpCredentials.lpszUsername);	
	if (dpSecurity.lpszSSPIProvider)SysFreeString((BSTR)dpSecurity.lpszSSPIProvider);
	if (dpSecurity.lpszCAPIProvider)SysFreeString((BSTR)dpSecurity.lpszCAPIProvider);

	return hr;
	
}

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFlags(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetPlayerFlags((DPID)id,(DWORD*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupFlags(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetGroupFlags((DPID)id,(DWORD*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupParent(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetGroupParent((DPID)id,(DPID*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::deleteGroupFromGroup(Dpid id, Dpid id2){
	HRESULT hr = m__dxj_DirectPlay4->DeleteGroupFromGroup((DPID)id,(DPID)id2);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::addGroupToGroup(Dpid id, Dpid id2){
	HRESULT hr = m__dxj_DirectPlay4->AddGroupToGroup((DPID)id,(DPID)id2);
	return hr;		
}



STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerAccountId(Dpid id, BSTR *ret){
	LPDPACCOUNTDESC pdesc;
	HRESULT hr;
	DWORD size=0;

	hr=m__dxj_DirectPlay4->GetPlayerAccount((DPID)id,0,NULL,&size);

	if (size==0) return E_FAIL;

	pdesc=(LPDPACCOUNTDESC)malloc(size);
	if (!pdesc) return E_OUTOFMEMORY;	

	hr=m__dxj_DirectPlay4->GetPlayerAccount((DPID)id,0,(void*)pdesc,&size);
	if FAILED(hr) {
		free(pdesc);
		return hr;
	}
	*ret=SysAllocString(pdesc->lpszAccountID);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlay4Object::initializeConnection(I_dxj_DPAddress *con//,long flags
														   )
{
	DWORD size;
	void *pData;
	if (!con) return E_INVALIDARG;

	con->getAddress((long*)&pData,(long*)&size);
	HRESULT hr=m__dxj_DirectPlay4->InitializeConnection(pData,(DWORD)0);
	return hr;
	
}


STDMETHODIMP C_dxj_DirectPlay4Object::createGroupInGroup(Dpid id,BSTR longName,BSTR shortName,long flags, Dpid *retval){

	DPNAME dpName;
	DWORD  l1=0;
	DWORD  l2=0;

	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize=sizeof(DPNAME);

	if (shortName){
		l1=wcslen(shortName);
		if (l1>0){
			__try { dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(l1+1)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
			wcscpy(dpName.lpszShortName, shortName);
		}
	}

	if (longName){
		l2=0;l2=wcslen(longName);
		if (l2>0){
			__try { dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(l2+1)); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
			wcscpy(dpName.lpszLongName, longName);
		}
	}
	
	DPID ret;
	HRESULT hr;

	if ((l1==0)&&(l2==0)){
		hr=m__dxj_DirectPlay4->CreateGroupInGroup((DPID)id,&ret,NULL,NULL,0,(DWORD)flags);
	}
	else {
		hr=m__dxj_DirectPlay4->CreateGroupInGroup((DPID)id,&ret,&dpName,NULL,0,(DWORD)flags);
	}

	*retval=(Dpid)ret;
	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumConnections(	
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumConnections **retVal){
		HRESULT hr=C_dxj_DPEnumConnectionsObject::create(m__dxj_DirectPlay4,strGuid,flags,retVal);
		return hr;
}



STDMETHODIMP C_dxj_DirectPlay4Object::getMessageQueue( 
		/* [in] */ long from,
		/* [in] */ long to,
		 long flags,
		 long *nMessages,
		 long *nBytes)
{
	return m__dxj_DirectPlay4->GetMessageQueue((DPID)from,(DPID)to,(DWORD)flags,(DWORD*)nMessages,(DWORD*)nBytes);

}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupOwner( 
		/* [in] */ long groupId,
		/* [retval][out] */ long __RPC_FAR *ret)
{
	return m__dxj_DirectPlay4->GetGroupOwner((DWORD)groupId,(DWORD*)ret);
}


STDMETHODIMP C_dxj_DirectPlay4Object::cancelPriority( 
	 long minPriority,
	 long maxPriority
//	 long flags
	)
{
	return m__dxj_DirectPlay4->CancelPriority((DWORD)minPriority,(DWORD)maxPriority,(DWORD) 0);

}
	

STDMETHODIMP C_dxj_DirectPlay4Object::cancelMessage( 
		/* [in] */ long msgid
		///* [in] */ long flags
		)
{
	return m__dxj_DirectPlay4->CancelMessage((DWORD)msgid,(DWORD)0);

}
	

STDMETHODIMP C_dxj_DirectPlay4Object::setGroupOwner( 
		/* [in] */ long groupId,
		/* [in] */ long ownerId)
{
	return m__dxj_DirectPlay4->SetGroupOwner((DWORD)groupId,(DWORD)ownerId);

}

STDMETHODIMP C_dxj_DirectPlay4Object::sendEx( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage *msg,            
            /* [in] */ long priority,
            /* [in] */ long timeout,
            /* [in] */ long context,
            /* [retval][out] */ long  *messageid)
{



	
	HRESULT hr;	
	void *pdata=NULL;
	DWORD dataSize=0;
	
	if (!msg) return E_INVALIDARG;

	__try {
		msg->getPointer((long*)&pdata);
		msg->getMessageSize((long*)&dataSize);
		hr= m__dxj_DirectPlay4->SendEx((DPID)fromPlayerId, (DPID)toPlayerId, (DWORD)flags, 
			(void*)pdata, (DWORD) dataSize,	
				    (DWORD) priority,
					(DWORD) timeout,
					(void*) context,
					(DWORD_PTR*) messageid);	//bugbug SUNDOWN
	}
	__except (1,1)
	{
		return E_INVALIDARG;	
	}

	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::createSessionData(  I_dxj_DirectPlaySessionData __RPC_FAR *__RPC_FAR *sessionDesc)
{
	HRESULT hr;
	hr=C_dxj_DirectPlaySessionDataObject::create((DPSESSIONDESC2*)NULL,sessionDesc);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::createMessage(  I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	hr= C_dxj_DirectPlayMessageObject::create(1,0,NULL,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplaylobby3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplaylobby3obj.h
//
//--------------------------------------------------------------------------

// _dxj_DirectPlayLobby3Obj.h : Declaration of the C_dxj_DirectPlayLobby3Object
// DHF begin - entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlayLobby3 LPDIRECTPLAYLOBBY3

/////////////////////////////////////////////////////////////////////////////
// DirectPlayLobby3

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobby3Object :
 
	public I_dxj_DirectPlayLobby3,

//	public CComCoClass<C_dxj_DirectPlayLobby3Object, &CLSID__dxj_DirectPlayLobby3>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobby3Object() ;
	virtual ~C_dxj_DirectPlayLobby3Object() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobby3Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobby3)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectPlayLobby3,   "DIRECT.DirectPlayLobby3.5",	"DIRECT.DiectPlayLobby3.5",	IDS_DPLAYLOBBY_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectPlayLobby3Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobby3Object)


public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
		/* [in] */ IUnknown __RPC_FAR *lpdd);

	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
		/* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE connect( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectPlay4 __RPC_FAR *__RPC_FAR *directPlay);
        
//        HRESULT STDMETHODCALLTYPE createAddress( 
//            /* [in] */ BSTR spGuid,
//            /* [in] */ BSTR addressTypeGuid,
//            /* [in] */ BSTR addressString,
//            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
//        HRESULT STDMETHODCALLTYPE createCompoundAddress( 
//            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *elements,
//            /* [in] */ long elementCount,
//            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
//        HRESULT STDMETHODCALLTYPE getDPEnumAddress( 
//		    /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *addr,
//            /* [retval][out] */ I_dxj_DPEnumAddress __RPC_FAR *__RPC_FAR *retVal);
        
//        HRESULT STDMETHODCALLTYPE getDPEnumAddressTypes( 
//            /* [in] */ BSTR guid,
//              /* [retval][out] */ I_dxj_DPEnumAddressTypes __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumLocalApplications( 
            /* [retval][out] */ I_dxj_DPEnumLocalApplications __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getConnectionSettings( 
            /* [in] */ long applicationId,
            /* [retval][out] */ I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE receiveLobbyMessage( 
            /* [in] */ long applicationId,
            /* [out][in] */ long __RPC_FAR *messageFlags,
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE receiveLobbyMessageSize( 
            /* [in] */ long applicationId,
            /* [out][in] */ long __RPC_FAR *messageFlags,
            /* [retval][out] */ long __RPC_FAR *dataSize);
        
        HRESULT STDMETHODCALLTYPE runApplication(             
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection,
            /* [in] */ long receiveEvent,
			/* [out,retval] */ long __RPC_FAR *applicationId
            );
        
        HRESULT STDMETHODCALLTYPE sendLobbyMessage( 
            /* [in] */ long flags,
            /* [in] */ long applicationId,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE setConnectionSettings( 
            /* [in] */ long applicationId,
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE setLobbyMessageEvent( 
            /* [in] */ long applicationId,
            /* [in] */ long receiveEvent);
        
        HRESULT STDMETHODCALLTYPE registerApplication( 
            /* [in] */ DpApplicationDesc2 __RPC_FAR *ApplicationInfo);
        
        HRESULT STDMETHODCALLTYPE unregisterApplication( 
            /* [in] */ BSTR guidApplication);
        
        HRESULT STDMETHODCALLTYPE waitForConnectionSettings( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE createMessage( 
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *msg);

		HRESULT STDMETHODCALLTYPE createConnectionData( 
            /* [retval][out] */ I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *con);


         HRESULT STDMETHODCALLTYPE createINetAddress( 
            /* [in] */ BSTR addr,
            /* [in] */ int port,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createComPortAddress( 
            /* [in] */ long port,
            /* [in] */ long baudRate,
            /* [in] */ long stopBits,
            /* [in] */ long parity,
            /* [in] */ long flowcontrol,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createLobbyProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createServiceProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createModemAddress( 
            /* [in] */ BSTR modem,
            /* [in] */ BSTR phone,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);

         HRESULT STDMETHODCALLTYPE createIPXAddress( 
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
			
         HRESULT STDMETHODCALLTYPE createCustomAddress( 
            /* [in] */ long size,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getModemName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *name);
        
         HRESULT STDMETHODCALLTYPE getModemCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
	////////////////////////////////////////////////////////////////////////////////////
	//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobby3);
	
	DWORD m_modemIndex;
	BSTR  m_modemResult;

private:

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectPlayLobby3 )
};

//MUST DEFINE THIS IN DIRECT.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplaylobby3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplaylobby3obj.cpp
//
//--------------------------------------------------------------------------

// _dxj_DirectPlayLobbyObj.cp\p : Implementation of C_dxj_DirectPlayLobbyObject
// DHF begin - entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplay.h"
#include "dplobby.h"
#include "dxglob7obj.h"

#include "dPlayLobby3Obj.h"
#include "dPlay4Obj.h"
#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "DPEnumLocalApplications.h"
//#include "dpEnumAddressObj.h"
//#include "dpEnumAddressTypesObj.h"
#include "dpmsgObj.h"
#include "string.h"

typedef HRESULT (__stdcall *DIRECTPLAYLOBBYCREATE)(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern DIRECTPLAYLOBBYCREATE pDirectPlayLobbyCreate;
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
extern DIRECTPLAYENUMERATE pDirectPlayEnumerate;
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern void *g_dxj_DirectPlay4;
extern HINSTANCE g_hDPlay;


BSTR DPLGUIDtoBSTR(LPGUID pGuid);
HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);

C_dxj_DirectPlayLobby3Object::C_dxj_DirectPlayLobby3Object()
{
	m__dxj_DirectPlayLobby3 = NULL;	
	#pragma message("DirectPlayLobby3 should be in object list")
}


C_dxj_DirectPlayLobby3Object::~C_dxj_DirectPlayLobby3Object()
{
	
	if(m__dxj_DirectPlayLobby3)
	{
		m__dxj_DirectPlayLobby3->Release();
		m__dxj_DirectPlayLobby3 = NULL;
	}	
}

GETSET_OBJECT(_dxj_DirectPlayLobby3);


//
/*** I_dxj_DirectPlayLobby methods ***/
//

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::connect(long flags, I_dxj_DirectPlay4 **val)
{
	LPDIRECTPLAY2	dp=NULL;
	LPDIRECTPLAY4	dp4=NULL;
	HRESULT hr;
	
	hr= m__dxj_DirectPlayLobby3->Connect((DWORD) flags, &dp, NULL);
	if FAILED(hr) return hr;

	hr= dp->QueryInterface(IID_IDirectPlay4,(void**)&dp4);
	
	dp->Release();
	
	if FAILED(hr) return hr;

		
	INTERNAL_CREATE(_dxj_DirectPlay4, dp4, val)

	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getConnectionSettings( 
            /* [in] */ long AppID,
            /* [out]*/ I_dxj_DPLConnection **con){

	DWORD dataSize = 0;
	LPVOID data;
	HRESULT hr;
	
	if (!con) return E_INVALIDARG;

	hr= m__dxj_DirectPlayLobby3->GetConnectionSettings((DWORD)AppID, NULL, &dataSize);	
	
	//fix for bug 23385
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;	
	*con=NULL;

	//Andrewke-
	//we now pass pack null if there are no connection settings.
	//will this ever happen?
	if (dataSize==0) return S_OK;	

	__try { data = alloca(dataSize); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	hr = m__dxj_DirectPlayLobby3->GetConnectionSettings((DWORD)AppID, (LPVOID)data, &dataSize);

	if FAILED(hr){		
		return E_OUTOFMEMORY;
	}

	I_dxj_DPLConnection *dplConnection=NULL;
	INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,(&dplConnection));
	if (dplConnection==NULL){
		return E_OUTOFMEMORY;
	}

	hr=dplConnection->setConnectionStruct((long)PtrToLong(data)); //NOTE SUNDOWN issue
	if FAILED(hr){
		return hr;
	}
	
	*con=dplConnection;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::receiveLobbyMessage( 
        /* [in] */ long appID,
        /* [out] */ long *messageFlags,
        /* [out] */ I_dxj_DirectPlayMessage **msg)
{



	HRESULT hr;
	DWORD dwSize=0;
    void  *pData=NULL;
	BOOL  fCont=TRUE;
	
	if (!msg) return E_INVALIDARG;
	if (!messageFlags) return E_INVALIDARG;
	
		
	hr= m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											(void*)NULL,
											(LPDWORD)&dwSize);

	if 	(hr == DPERR_NOMESSAGES ) {
			*msg=NULL;
			return S_OK;
	}
	
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;
	

	hr=C_dxj_DirectPlayMessageObject::create((DWORD)0,dwSize,&pData,msg);
	if FAILED(hr) return hr;
		

	hr= m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											(void*)pData,
											(LPDWORD)&dwSize);

			
	if 	FAILED(hr) {
		if (*msg) (*msg)->Release();

		*msg=NULL;
		return hr;
	}
	
	return hr;


}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::receiveLobbyMessageSize( 
        /* [in] */ long appID,
        /* [out] */ long *messageFlags,
        /* [out] */ long __RPC_FAR *dataSize)
{
	*dataSize = 0;
	HRESULT hr = m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											NULL,
											(LPDWORD)dataSize);
	if (hr==DPERR_BUFFERTOOSMALL) hr=S_OK;
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Launch a DirectPlay application.
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::runApplication(			
			I_dxj_DPLConnection *conn,														 
            long  hReceiveEvent	,
			long  *appId
			) 
{
	if (!appId) return E_INVALIDARG;
	if (!conn) return E_INVALIDARG;

	void *lpConnection=NULL;
	HRESULT hr;

	*appId=0;
	hr=conn->getConnectionStruct((long*)&lpConnection);
	if FAILED(hr) return hr;

	hr = m__dxj_DirectPlayLobby3->RunApplication (0,
								(DWORD*)appId,
								(DPLCONNECTION*)lpConnection,
								(void*)hReceiveEvent);
	

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::sendLobbyMessage( 
		/* [in] */ long flags,															
        /* [in] */ long appID,
        /* [in] */ I_dxj_DirectPlayMessage *msg)
{
	//if (!ISSAFEARRAY1D(ppData,(DWORD)dataSize)) return E_INVALIDARG;

	HRESULT hr;
	if (!msg) return E_INVALIDARG;
	void *pData=NULL;
	DWORD dataSize=0;

	msg->AddRef();
	msg->getPointer((long*)&pData);
	msg->getMessageSize((long*)&dataSize);
	
	__try {
		hr = m__dxj_DirectPlayLobby3->SendLobbyMessage ((DWORD)flags,
											(DWORD)appID,
											pData,
											(DWORD)dataSize);
	}
	__except(1,1){
		msg->Release();
		return E_INVALIDARG;
	}
	
	msg->Release();
	return hr;
}
 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::setConnectionSettings ( long appID, I_dxj_DPLConnection *con)
{
	void *lpConnection=NULL;
	HRESULT hr;

	if (!con) return E_INVALIDARG;

	hr=con->getConnectionStruct((long*)&lpConnection);
	if FAILED(hr) return hr;


	hr = m__dxj_DirectPlayLobby3->SetConnectionSettings (0,
											(DWORD)appID,
											(DPLCONNECTION*)lpConnection);
	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::setLobbyMessageEvent( 
            /* [in] */ long appId,
            /* [in] */ long hReceiveEvent)
{
	HRESULT hr = m__dxj_DirectPlayLobby3->SetLobbyMessageEvent(0, (long)appId, (HANDLE)hReceiveEvent);
	return hr;
}




        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getDPEnumLocalApplications( 
            ///* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumLocalApplications __RPC_FAR *__RPC_FAR *retVal)
{
	HRESULT hr;
	hr=C_dxj_DPEnumLocalApplicationsObject::create(m__dxj_DirectPlayLobby3,0,retVal);
	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::waitForConnectionSettings( 
            /* [in] */ long flags)
{
	HRESULT hr = m__dxj_DirectPlayLobby3->WaitForConnectionSettings((DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::unregisterApplication(// long flags,
																 BSTR guid)
{
	GUID g;	
	HRESULT hr;

	hr=DPLBSTRtoGUID(&g,guid);	
	if FAILED(hr) return E_INVALIDARG;

	hr =m__dxj_DirectPlayLobby3->UnregisterApplication((DWORD) 0, g);

	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::registerApplication(// long flags, 
															   DpApplicationDesc2 *appDesc)
{
	HRESULT hr;
	DPAPPLICATIONDESC2 desc;

	if (!appDesc->strGuid) return E_INVALIDARG;

	ZeroMemory(&desc,sizeof(DPAPPLICATIONDESC2));
	desc.dwSize=sizeof(DPAPPLICATIONDESC2);
	desc.dwFlags=(DWORD)appDesc->lFlags;
	desc.lpszApplicationName=appDesc->strApplicationName;
	desc.lpszFilename=appDesc->strFilename;
	desc.lpszCommandLine=appDesc->strCommandLine;
	desc.lpszPath=appDesc->strPath;
	desc.lpszCurrentDirectory=appDesc->strCurrentDirectory;
	desc.lpszDescriptionW=appDesc->strDescription;
	desc.lpszAppLauncherName=appDesc->strAppLauncherName;
	
	hr=DPLBSTRtoGUID(&desc.guidApplication,appDesc->strGuid);
	if FAILED(hr) return E_INVALIDARG;
		
	hr =m__dxj_DirectPlayLobby3->RegisterApplication((DWORD) 0, &desc);

	return hr;
}



STDMETHODIMP C_dxj_DirectPlayLobby3Object::createConnectionData(  I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *ret)
{ 
	
	INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,ret);		
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayLobby3Object::createMessage(  I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	hr= C_dxj_DirectPlayMessageObject::create(1,0,NULL,ret);
	return hr;
}



//CONSIDER - why pass int - more appopriate to pass in short
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createINetAddress( 
            /* [in] */ BSTR addr,
            /* [in] */ int port,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[3];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	WORD wport=(WORD)port;
	DWORD dwElements=2;

	if (!addr) return E_INVALIDARG;

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_TCPIP;

	elem[1].guidDataType=DPAID_INetW;
	elem[1].dwDataSize =SysStringByteLen(addr)+sizeof(WCHAR);
	elem[1].lpData = (void*) addr;

	elem[2].guidDataType=DPAID_INetPort;
	elem[2].dwDataSize =sizeof(WORD);
	elem[2].lpData = &wport;

	if (port)  dwElements=3;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,dwElements,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,dwElements,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN issue need to use PtrToLong
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createComPortAddress( 
            /* [in] */ long port,
            /* [in] */ long baudRate,
            /* [in] */ long stopBits,
            /* [in] */ long parity,
            /* [in] */ long flowcontrol,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPORTADDRESS cpa;

	cpa.dwBaudRate =(DWORD)baudRate;
	cpa.dwComPort =(DWORD)port;
	cpa.dwFlowControl =(DWORD)flowcontrol;
	cpa.dwStopBits =(DWORD)stopBits;
	cpa.dwParity =(DWORD)parity;
	
	DPCOMPOUNDADDRESSELEMENT elem[2];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;

	

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_SERIAL;					

	elem[1].guidDataType=DPAID_ComPort;
	elem[1].dwDataSize =sizeof(DPCOMPORTADDRESS);
	elem[1].lpData = (void*) &cpa;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,2,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,2,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN issue
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}

STDMETHODIMP C_dxj_DirectPlayLobby3Object::createLobbyProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	
	DPCOMPOUNDADDRESSELEMENT elem[2];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID lobbyGuid;

	

	if (!guid) return E_INVALIDARG;

	hr=DPLBSTRtoGUID(&lobbyGuid,guid);
	if FAILED(hr) return E_INVALIDARG;


	
	elem[0].guidDataType=DPAID_LobbyProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &lobbyGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;

}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createServiceProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[1];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID SPGuid;

	
	if (!guid) return E_INVALIDARG;

	hr=DPLBSTRtoGUID(&SPGuid,guid);
	if FAILED(hr) return E_INVALIDARG;


	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &SPGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize);	//NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createModemAddress( 
            /* [in] */ BSTR modem,
            /* [in] */ BSTR phone,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[3];
	DWORD dwSize=0;
	DWORD i =1;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	
	
	if (!phone) return E_INVALIDARG;
	if (!modem) return E_INVALIDARG;

	


	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_MODEM;					

	if (modem[0]!=0) {

		elem[i].guidDataType=DPAID_ModemW;
		elem[i].dwDataSize =SysStringByteLen(modem)+sizeof(WCHAR);
		elem[i].lpData = (void*) modem;	
		i++;
	}
	if (phone[0]!=0) {

	    elem[i].guidDataType=DPAID_PhoneW;
	    elem[i].dwDataSize =SysStringByteLen(phone)+sizeof(WCHAR);
	    elem[i].lpData = (void*) phone;
        i++;
    }
	

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,i,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,i,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize);	//NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::createIPXAddress(             
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[1];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID SPGuid=DPSPGUID_IPX;

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &SPGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createCustomAddress( 
            /* [in] */ long size,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	return E_NOTIMPL;
}

 
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getModemName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *name)
{

		USES_CONVERSION;

		LPDIRECTPLAY4	dp=NULL;
    	LPDIRECTPLAY	lpDP=NULL;
    	GUID			guid=DPSPGUID_MODEM;
		HRESULT			hr;
		DIRECTPLAYCREATE pDirectPlayCreate = NULL;
		DWORD dwSize=0;
		DWORD	dwAt=0;
		void *pData=NULL;
		LPWSTR pszwName=NULL;
		char	*szLast=NULL;

		DWORD		dwCount;
		DWORD		i;
		BOOL	bZero;

		pDirectPlayCreate=(DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );        
    	if (pDirectPlayCreate == NULL )	return E_NOINTERFACE;
    
    

    	// create a DirectPlay1 interface
    	hr = (pDirectPlayCreate)(&guid, &lpDP, NULL);
    	if FAILED(hr) goto cleanup;
	  	
    
    	// now get Dplay4 interface
    	hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    	lpDP->Release(); lpDP=NULL;
  		if FAILED(hr) goto cleanup;
  						



		hr=dp->GetPlayerAddress(0,NULL,&dwSize);
		if (dwSize<=0) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		pData=malloc(dwSize);
		if (!pData){			
			hr= E_OUTOFMEMORY;
			goto cleanup;
		}	

		hr=dp->GetPlayerAddress(0,pData,&dwSize);
		if FAILED(hr) goto cleanup;
		
		if (dwSize<=80) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		//Get String count
		
		bZero=FALSE;
		dwCount=0;
		for( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){
				if (bZero) break;
				dwCount++;				
				bZero=TRUE;
			}
			else {
				bZero=FALSE;
			}			
		}
		
		if (((DWORD)index > dwCount) || (index <=0)){
			hr=E_INVALIDARG;
			goto cleanup;
		}

		szLast=& (((char*)pData)[80]);		

		dwAt=0;
		for	( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){													
				if ((DWORD)(index-1)==dwAt) break;
				dwAt++;							
				szLast=&( ( (char*)pData)[i+1]);				
			}			
		}
		
		if (i>dwSize) { 
			hr=E_INVALIDARG;
			goto cleanup;
		}

	
		__try { pszwName = T2W(szLast);	} 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		*name=SysAllocString(pszwName);
		


cleanup:
		if (pData) 	free(pData);
		if (dp) dp->Release();
		
		return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getModemCount( 
            /* [retval][out] */ long __RPC_FAR *count)
{

		LPDIRECTPLAY4	dp=NULL;
    	LPDIRECTPLAY	lpDP=NULL;
    	GUID			guid=DPSPGUID_MODEM;
		HRESULT			hr;
		DIRECTPLAYCREATE pDirectPlayCreate = NULL;
		DWORD dwSize=0;
		
		void *pData=NULL;		
		DWORD		dwCount;
		DWORD		i;
		BOOL		bZero;

		if (!count) return E_INVALIDARG;


		pDirectPlayCreate=(DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );        
    	if (pDirectPlayCreate == NULL )	return E_NOINTERFACE;
    
    

    	// create a DirectPlay1 interface
    	hr = (pDirectPlayCreate)(&guid, &lpDP, NULL);
		if (hr==DPERR_UNAVAILABLE) {		          
			hr = S_OK;
			*count=0;
			goto cleanup;
		}
		if FAILED(hr) goto cleanup;
	  	
    
    	// now get Dplay4 interface
    	hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    	lpDP->Release(); lpDP=NULL;
  		if FAILED(hr) goto cleanup;
  						



		hr=dp->GetPlayerAddress(0,NULL,&dwSize);
		if (dwSize<=0) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		pData=malloc(dwSize);
		if (!pData){			
			hr= E_OUTOFMEMORY;
			goto cleanup;
		}	

		hr=dp->GetPlayerAddress(0,pData,&dwSize);
		if (hr==DPERR_UNAVAILABLE) {		          
			hr = S_OK;
			*count=0;
			goto cleanup;
		}
		if FAILED(hr) goto cleanup;
		
		if (dwSize<=80) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		//Get String count
		
		bZero=FALSE;
		dwCount=0;
		for( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){
				if (bZero) break;
				dwCount++;				
				bZero=TRUE;
			}
			else {
				bZero=FALSE;
			}			
		}
		*count=(long)dwCount;

cleanup:
		if (pData) 	free(pData);
		if (dp) dp->Release();
		
		return hr;
}
        


	
#define GUIDS_EQUAL(g2,g) (\
	(g.Data1==g2->Data1) && \
	(g.Data2==g2->Data2) && \
	(g.Data3==g2->Data3) && \
	(g.Data4[0]==g2->Data4[0]) && \
	(g.Data4[1]==g2->Data4[1]) && \
	(g.Data4[2]==g2->Data4[2]) && \
	(g.Data4[3]==g2->Data4[3]) && \
	(g.Data4[4]==g2->Data4[4]) && \
	(g.Data4[5]==g2->Data4[5]) && \
	(g.Data4[6]==g2->Data4[6]) && \
	(g.Data4[7]==g2->Data4[7]) )




HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str)
{

	HRESULT hr;
	if( 0==_wcsicmp(str,L"dpaid_comport")){
		memcpy(pGuid,&DPAID_ComPort,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_inet")){
		memcpy(pGuid,&DPAID_INet,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_inetport")){
		memcpy(pGuid,&DPAID_INetPort,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_lobbyprovider")){
		memcpy(pGuid,&DPAID_LobbyProvider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_modem")){
		memcpy(pGuid,&DPAID_Modem,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_phone")){
		memcpy(pGuid,&DPAID_Phone,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_serviceprovider")){
		memcpy(pGuid,&DPAID_ServiceProvider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_totalsize")){
		memcpy(pGuid,&DPAID_TotalSize,sizeof(GUID));
	}	


	else if( 0==_wcsicmp(str,L"dpspguid_modem")){
		memcpy(pGuid,&DPSPGUID_MODEM,sizeof(GUID));
	}	
	else if( 0==_wcsicmp(str,L"dpspguid_ipx")){
		memcpy(pGuid,&DPSPGUID_IPX,sizeof(GUID));
	}	
	else if( 0==_wcsicmp(str,L"dpspguid_tcpip")){
		memcpy(pGuid,&DPSPGUID_TCPIP,sizeof(GUID));
	}	

	else if( 0==_wcsicmp(str,L"dpspguid_serial")){
		memcpy(pGuid,&DPSPGUID_SERIAL,sizeof(GUID));
	}	


	

	
	else { 
		hr=BSTRtoGUID(pGuid,str);
		return hr;
	}

	return S_OK;
}

HRESULT DPLBSTRtoPPGUID(LPGUID *ppGuid,BSTR str)
{
	if ((!str) || (str[0]==0)){
			ppGuid=NULL;
			return S_OK;
	}
	
	return DPLBSTRtoGUID(*ppGuid,str);
}


BSTR DPLGUIDtoBSTR(LPGUID pGuid)
{
	WCHAR *pOut=NULL;

	
	if( GUIDS_EQUAL(pGuid,DPAID_ComPort)){
		pOut=L"DPAID_ComPort";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_INet)){
		pOut=L"DPAID_INet";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_INetPort)){
		pOut=L"DPAID_INetPort";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_LobbyProvider)){
		pOut=L"DPAID_LobbyProvider";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_Modem)){
		pOut=L"DPAID_Modem";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_Phone)){
		pOut=L"DPAID_Phone";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_ServiceProvider)){
		pOut=L"DPAID_ServiceProvider";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_TotalSize)){
		pOut=L"DPAID_TotalSize";
	}	
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_MODEM)){
		pOut=L"DPSPGUID_MODEM";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_IPX)){
		pOut=L"DPSPGUID_IPX";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_TCPIP)){
		pOut=L"DPSPGUID_TCPIP";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_SERIAL)){
		pOut=L"DPSPGUID_SERIAL";
	}

	
	
	
	
	if (pOut) {
		return SysAllocString(pOut);	
	}
	else {
		return GUIDtoBSTR(pGuid);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplconnection.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplconnection.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_DPLConnectionObject :
		public IDPLConnection,
		public CComCoClass<C_DPLConnectionObject, &CLSID__DPLConnection>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_DPLConnectionObject)
		COM_INTERFACE_ENTRY(IDPLConnection)
	END_COM_MAP()

	DECLARE_REGISTRY(CLSID__DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_DPLConnectionObject)

public:
	C_DPLConnectionObject();
	~C_DPLConnectionObject();

         /* [hidden] */ HRESULT STDMETHODCALLTYPE getConnectionStruct( 
            /* [out] */ long __RPC_FAR *connect) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE setConnectionStruct( 
            /* [in] */ long connect) ;
        
         HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ DPSessionDesc2 __RPC_FAR *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out] */ DPSessionDesc2 __RPC_FAR *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE setGuidSP( 
            /* [in] */ DxGuid __RPC_FAR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getGuidSP( 
            /* [out] */ DxGuid __RPC_FAR *guid) ;
        
         HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ IDPAddress __RPC_FAR *address) ;
        
         HRESULT STDMETHODCALLTYPE getAddress( 
            /* [retval][out] */ IDPAddress __RPC_FAR *__RPC_FAR *address) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerShortName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerShortName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerLongName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerLongName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
  

private:
	DPLCONNECTION m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	IUnknown	  *nextobj;
	DWORD		  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};

extern IUnknown *g_DPLConnection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplay4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplay4obj.h
//
//--------------------------------------------------------------------------

// _dxj_DirectPlay4Obj.h : Declaration of the C_dxj_DirectPlay4Object
// DHF begin - entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlay4 LPDIRECTPLAY4

/////////////////////////////////////////////////////////////////////////////
// DirectPlay4

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlay4Object :
 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlay4, &IID_I_dxj_DirectPlay4, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlay4,
#endif

//	public CComCoClass<C_dxj_DirectPlay4Object, &CLSID__dxj_DirectPlay4>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectPlay4Object() ;
	~C_dxj_DirectPlay4Object() ;

BEGIN_COM_MAP(C_dxj_DirectPlay4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlay4)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectPlay4, "DIRECT.DirectPlay4.3",		"DIRECT.DiectPlay2.3",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectPlay4Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectPlay4Object)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlay4
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addGroupToGroup( 
            /* [in] */ long ParentGroupId,
            /* [in] */ long GroupId);
        
        HRESULT STDMETHODCALLTYPE addPlayerToGroup( 
            /* [in] */ long groupId,
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE cancelMessage( 
            /* [in] */ long msgid);
        
        HRESULT STDMETHODCALLTYPE cancelPriority( 
            /* [in] */ long minPrority,
            /* [in] */ long maxPriority);
        
        HRESULT STDMETHODCALLTYPE close( void);
        
        HRESULT STDMETHODCALLTYPE createGroup( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE createGroupInGroup( 
            /* [in] */ long parentid,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE createPlayer( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long receiveEvent,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE deleteGroupFromGroup( 
            /* [in] */ long groupParentId,
            /* [in] */ long groupId);
        
        HRESULT STDMETHODCALLTYPE deletePlayerFromGroup( 
            /* [in] */ long groupId,
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE destroyGroup( 
            /* [in] */ long groupId);
        
        HRESULT STDMETHODCALLTYPE destroyPlayer( 
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE getDPEnumConnections( 
            /* [in] */ BSTR guid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumConnections __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroupPlayers( 
            /* [in] */ long groupId,
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroups( 
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroupsInGroup( 
            /* [in] */ long groupId,
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumPlayers( 
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumSessions( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc,
            /* [in] */ long timeOut,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumSessions2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DPCaps __RPC_FAR *caps,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getGroupData( 
            /* [in] */ long groupId,
            /* [in] */ long flags,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGroupFlags( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *flags);
        
        HRESULT STDMETHODCALLTYPE getGroupLongName( 
            /* [in] */ long groupId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getGroupShortName( 
            /* [in] */ long groupId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getGroupParent( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGroupOwner( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getMessageCount( 
            /* [in] */ long playerId,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getMessageQueue( 
            /* [in] */ long from,
            /* [in] */ long to,
            /* [in] */ long flags,
            /* [out][in] */ long __RPC_FAR *nMessage,
            /* [out][in] */ long __RPC_FAR *nBytes);
        
        HRESULT STDMETHODCALLTYPE getPlayerAccountId( 
            /* [in] */ long playerid,
            /* [retval][out] */ BSTR __RPC_FAR *acctid);
        
        HRESULT STDMETHODCALLTYPE getPlayerAddress( 
            /* [in] */ long playerId,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getPlayerCaps( 
            /* [in] */ long playerId,
            /* [out] */ DPCaps __RPC_FAR *caps,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getPlayerData( 
            /* [in] */ long playerId,
            /* [in] */ long flags,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getPlayerFlags( 
            /* [in] */ long id,
            /* [retval][out] */ long __RPC_FAR *retflags);
        
        HRESULT STDMETHODCALLTYPE getPlayerFormalName( 
            /* [in] */ long playerId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getPlayerFriendlyName( 
            /* [in] */ long playerId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out][in] */ I_dxj_DirectPlaySessionData __RPC_FAR **sessionDesc);
        
        HRESULT STDMETHODCALLTYPE initializeConnection( 
            /* [in] */ I_dxj_DPAddress __RPC_FAR *address);
        
        HRESULT STDMETHODCALLTYPE open( 
            /* [out][in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE receive( 
            /* [out][in] */ long __RPC_FAR *fromPlayerId,
            /* [out][in] */ long __RPC_FAR *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE receiveSize( 
            /* [out][in] */ long __RPC_FAR *fromPlayerId,
            /* [out][in] */ long __RPC_FAR *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ int __RPC_FAR *dataSize);
        
        HRESULT STDMETHODCALLTYPE secureOpen( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessiondesc,
            /* [in] */ long flags,
            /* [in] */ DPSecurityDesc __RPC_FAR *security,
            /* [in] */ DPCredentials __RPC_FAR *credentials);
        
        HRESULT STDMETHODCALLTYPE send( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE sendChatMessage( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ BSTR message);
        
        HRESULT STDMETHODCALLTYPE sendEx( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg,
            /* [in] */ long priority,
            /* [in] */ long timeout,
            /* [in] */ long context,
            /* [retval][out] */ long __RPC_FAR *messageid);
        
        HRESULT STDMETHODCALLTYPE createMessage( 
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE setGroupConnectionSettings( 
            /* [in] */ long id,
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE setGroupData( 
            /* [in] */ long groupId,
            /* [in] */ BSTR data,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setGroupName( 
            /* [in] */ long groupId,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setGroupOwner( 
            /* [in] */ long groupId,
            /* [in] */ long ownerId);
        
        HRESULT STDMETHODCALLTYPE setPlayerData( 
            /* [in] */ long playerId,
            /* [in] */ BSTR data,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setPlayerName( 
            /* [in] */ long playerId,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc);
        
        HRESULT STDMETHODCALLTYPE startSession( 
            /* [in] */ long id);
        
        HRESULT STDMETHODCALLTYPE createSessionData( 
            /* [retval][out] */ I_dxj_DirectPlaySessionData __RPC_FAR *__RPC_FAR *sessionDesc);



////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlay4);
	C_dxj_DirectPlay4Object *nextPlayObj;

private:
	void doRemoveThisPlayObj();

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectPlay4 )
};

//MUST DEFINE THIS IN DIRECT.CPP
extern C_dxj_DirectPlay4Object *Play4Objs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplconnectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplconnectionobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplConnectionObj.h"
#include "dpAddressObj.h"
#include "dpSessDataObj.h"

#pragma message ("Should INTERNAL_CREATE_STRUCT play with AddRef and refcount")

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc, DPSESSIONDESC2 *dpSessionDesc);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLBSTRtoGUID(LPGUID,BSTR);
extern BSTR DPLGUIDtoBSTR(LPGUID);

CONSTRUCTOR_STRUCT(_dxj_DPLConnection, {init();})

//ANDREWKE - broke out for debuging
//DESTRUCTOR_STRUCT(_dxj_DPLConnection, {cleanUp();})
C_dxj_DPLConnectionObject::~C_dxj_DPLConnectionObject()
{

	C_dxj_DPLConnectionObject *prev=NULL; 
	for (
		C_dxj_DPLConnectionObject *ptr=(C_dxj_DPLConnectionObject *)g_dxj_DPLConnection; 
		ptr;
		ptr=(C_dxj_DPLConnectionObject *)ptr->nextobj
		) 
		{
			if(ptr == this) 	
			{ 
				if(prev) 
					prev->nextobj = ptr->nextobj; 
				else 
					g_dxj_DPLConnection = (void*)ptr->nextobj; 
				break;
			} 
			prev = ptr; 
		} 
	

	cleanUp();
}



void C_dxj_DPLConnectionObject::init() {
	ZeroMemory(&m_connect,sizeof(DPLCONNECTION));
	m_connect.dwSize=sizeof(DPLCONNECTION);
	ZeroMemory(&m_dpName,sizeof(DPNAME));		
	m_dpName.dwSize=sizeof(DPNAME);
	m_pAddress=NULL;	
	ZeroMemory(&m_sessionDesc,sizeof(DPSESSIONDESC2));
	
}

void C_dxj_DPLConnectionObject::cleanUp() {

	if (m_pAddress) free (m_pAddress);
	
	if (m_dpName.lpszShortName) SysFreeString((BSTR)m_dpName.lpszShortName);
	if (m_dpName.lpszLongName) SysFreeString((BSTR)m_dpName.lpszLongName);
	if (m_sessionDesc.lpszSessionName) SysFreeString((BSTR)m_sessionDesc.lpszSessionName);
	if (m_sessionDesc.lpszPassword) SysFreeString((BSTR)m_sessionDesc.lpszPassword);

}


HRESULT C_dxj_DPLConnectionObject::getConnectionStruct( long *pOut){
	//TODO this is haneous;
	*pOut=(long)&m_connect;	
	return S_OK;
}

//TODO consider - most of the time you are handed a buffer with
//all the necessary pointers in tact. why not copy the buffer
//as is? 
HRESULT C_dxj_DPLConnectionObject::setConnectionStruct( long pIn){
	DPLCONNECTION *pcon=(LPDPLCONNECTION)pIn;

	memcpy((void*)&m_connect,(void*)pcon,sizeof(DPLCONNECTION));
			
	ZeroMemory(&m_dpName,sizeof(DPNAME));
	ZeroMemory(&m_sessionDesc,sizeof(DPSESSIONDESC2));

	if (pcon->lpPlayerName){		
		
		//copy over the flags...
		memcpy ((void*)&m_dpName,(void*)pcon->lpPlayerName,sizeof(DPNAME));

		//copy over the names
		m_dpName.lpszShortName=SysAllocString(pcon->lpPlayerName->lpszShortName);
		m_dpName.lpszLongName=SysAllocString(pcon->lpPlayerName->lpszLongName);


	}
	if (pcon->lpSessionDesc){
		//copy over flags
		memcpy ((void*)&m_sessionDesc,(void*)pcon->lpSessionDesc,sizeof(DPSESSIONDESC2));

		if (m_sessionDesc.lpszSessionName) SysFreeString((BSTR)m_sessionDesc.lpszSessionName);
		if (m_sessionDesc.lpszPassword)SysFreeString((BSTR)m_sessionDesc.lpszPassword);
		m_sessionDesc.lpszSessionName=SysAllocString(pcon->lpSessionDesc->lpszSessionName);
		m_sessionDesc.lpszPassword=SysAllocString(pcon->lpSessionDesc->lpszPassword);		
	}

	if (pcon->lpAddress){
		if (m_pAddress)
			free(m_pAddress);
		m_pAddress=malloc(pcon->dwAddressSize);
		if (m_pAddress==NULL) 
			return E_OUTOFMEMORY;
		memcpy ((void*)m_pAddress,(void*)pcon->lpAddress,pcon->dwAddressSize);
	}
	
	
	return S_OK;
}



HRESULT C_dxj_DPLConnectionObject::setFlags(long flags){
	m_connect.dwFlags=(DWORD)flags;
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::getFlags(long *flags){
	*flags=(long)m_connect.dwFlags;
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setSessionDesc(I_dxj_DirectPlaySessionData *desc){
	//FillRealSessionDesc(&m_sessionDesc,desc);	
	if (!desc) return E_INVALIDARG;
	desc->AddRef();
	desc->getData((long*)&m_sessionDesc);
	
	m_connect.lpSessionDesc=&m_sessionDesc;

	//we copy over the structure but we dont own the strings yet
	if (m_sessionDesc.lpszSessionName) SysFreeString((BSTR)m_sessionDesc.lpszSessionName);
	if (m_sessionDesc.lpszPassword) SysFreeString((BSTR)m_sessionDesc.lpszPassword);

	m_sessionDesc.lpszSessionName=SysAllocString(m_sessionDesc.lpszSessionName);
	m_sessionDesc.lpszPassword=SysAllocString(m_sessionDesc.lpszPassword);		

	desc->Release();

	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::getSessionDesc(I_dxj_DirectPlaySessionData **desc){
	//FillCoverSessionDesc(desc,&m_sessionDesc);	
	HRESULT hr;
	hr=C_dxj_DirectPlaySessionDataObject::create(&m_sessionDesc,desc);
	return hr;
}


HRESULT C_dxj_DPLConnectionObject::setGuidSP(BSTR strGuid){
	HRESULT hr=DPLBSTRtoGUID(&m_connect.guidSP,strGuid);
	return hr;
}

HRESULT C_dxj_DPLConnectionObject::getGuidSP(BSTR *strGuid){
	*strGuid=DPLGUIDtoBSTR(&m_connect.guidSP);	
	return S_OK;
}

         

        

HRESULT C_dxj_DPLConnectionObject::getPlayerShortName(BSTR *name){
	*name = SysAllocString(m_dpName.lpszShortName);	
	return S_OK;
}
HRESULT C_dxj_DPLConnectionObject::getPlayerLongName(BSTR *name){
	*name = SysAllocString(m_dpName.lpszLongName);	
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setPlayerShortName(BSTR name){
	
	if (m_dpName.lpszShortName) SysFreeString (m_dpName.lpszShortName);
	m_dpName.lpszShortName=NULL;

	if (!name) return S_OK;
		
	m_dpName.lpszShortName = SysAllocString(name);
	
	m_connect.lpPlayerName=&m_dpName;
	return S_OK;


}

HRESULT C_dxj_DPLConnectionObject::setPlayerLongName(BSTR name){
	
	if (m_dpName.lpszLongName) SysFreeString (m_dpName.lpszLongName);
	m_dpName.lpszLongName=NULL;
	
	if (!name) return S_OK;
	

	
	m_dpName.lpszLongName =SysAllocString(name);
	
	m_connect.lpPlayerName=&m_dpName;
	return S_OK;
}


HRESULT C_dxj_DPLConnectionObject::getAddress(I_dxj_DPAddress **pRetAddress){
	

	HRESULT hr;

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,pRetAddress);
	
	if (*pRetAddress==NULL) return E_OUTOFMEMORY;

	hr=(*pRetAddress)->setAddress((long)m_connect.lpAddress,m_connect.dwAddressSize);
	
	//ASSERT(SUCCESS(hr),"setAddress C_dxj_DPLConnectionObject::getAddress)

	if FAILED(hr) return hr;

	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setAddress(I_dxj_DPAddress *address){
	
	DWORD length=0;
	Byte  *pAddress=NULL;

	//BUGFIX for MANBUG28198	2/2/00	ANDREWKE
	if (!address) return E_INVALIDARG;	

	//NOTE: TODO make this cleaner
	address->getAddress((long*)&pAddress,(long*)&length);

	if (m_pAddress) free (m_pAddress);
	m_pAddress=NULL;
	m_pAddress=malloc((DWORD)length);
	if (m_pAddress==NULL) return E_OUTOFMEMORY;

	#pragma message ("Write ASSERT macro")
	if (pAddress==NULL) return E_FAIL;	
	memcpy((void*)m_pAddress,(void*)pAddress,length);
	
	m_connect.lpAddress=m_pAddress;
	m_connect.dwAddressSize=length;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dplconnectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplconnectionobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DPLConnectionObject :
		public I_dxj_DPLConnection,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DPLConnectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DPLConnection)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID_DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DPLConnectionObject)

public:
	C_dxj_DPLConnectionObject();
	~C_dxj_DPLConnectionObject();

          HRESULT STDMETHODCALLTYPE getConnectionStruct( 
				 long  *connect) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE setConnectionStruct( 
            /* [in] */ long connect) ;
        
         HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long  *ret) ;
        
         HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData  *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out] */ I_dxj_DirectPlaySessionData  **sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE setGuidSP( 
            /* [in] */ BSTR  strGuid) ;
        
         HRESULT STDMETHODCALLTYPE getGuidSP( 
            /* [out] */ BSTR *strGuid) ;
        
         HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ I_dxj_DPAddress  *address) ;
        
         HRESULT STDMETHODCALLTYPE getAddress( 
            /* [retval][out] */ I_dxj_DPAddress  **address) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerShortName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerShortName( 
            /* [retval][out] */ BSTR  *name) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerLongName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerLongName( 
            /* [retval][out] */ BSTR  *name) ;
  

private:
	DPLCONNECTION m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	void		  *nextobj;
	int			  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpsessiondescobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpsessiondescobj.cpp
//
//--------------------------------------------------------------------------

/*
	interface I_dxj_DPSessionDesc;
	interface I_dxj_DDVideoPortCaps;
	interface I_dxj_DIDeviceObjectInstance;
	interface I_dxj_DIEffectInfo;
*/


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPSessionDescObj.h"

C_dxj_DPSessionDescObject::C_dxj_DPSessionDescObject(){
	ZeroMemory(&m_desc,sizeof(DPSessionDesc));
}
C_dxj_DPSessionDescObject::~C_dxj_DPSessionDescObject(){
}

STDMETHODIMP C_dxj_DPSessionDescObject::getDescription(DPSessionDesc *desc){
	if (desc==NULL) return E_INVALIDARG; 
	memcpy(&m_desc,desc,sizeof(DPSessionDesc));
	return S_OK;
}
STDMETHODIMP C_dxj_DPSessionDescObject::setDescription(DPSessionDesc *desc){
	if (desc==NULL) return E_INVALIDARG; 
	memcpy(desc,&m_desc,sizeof(DPSessionDesc));
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpmsgobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectPlayMessageObject :
		public I_dxj_DirectPlayMessage,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectPlayMessageObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectPlayMessage)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectPlayMessageObject)

public:
		C_dxj_DirectPlayMessageObject();	
		~C_dxj_DirectPlayMessageObject();

         HRESULT STDMETHODCALLTYPE writeGuid( 
            /* [in] */ BSTR val);
        
         HRESULT STDMETHODCALLTYPE readGuid( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeString( 
            /* [in] */ BSTR val);
        
         HRESULT STDMETHODCALLTYPE readString( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeLong( 
            /* [in] */ long val);
        
         HRESULT STDMETHODCALLTYPE readLong( 
            /* [retval][out] */ long __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeShort( 
            /* [in] */ short val);
        
         HRESULT STDMETHODCALLTYPE readShort( 
            /* [retval][out] */ short __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeSingle( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE readSingle( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeDouble( 
            /* [in] */ double val);
        
         HRESULT STDMETHODCALLTYPE readDouble( 
            /* [retval][out] */ double __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeByte( 
            /* [in] */ Byte val);
        
         HRESULT STDMETHODCALLTYPE readByte( 
            /* [retval][out] */ Byte __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE moveToTop( void);
        
         HRESULT STDMETHODCALLTYPE clear( void);
        
         HRESULT STDMETHODCALLTYPE getMessageSize( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getMessageData( 
            /* [out][in] */ void __RPC_FAR *userDefinedType);
        
         HRESULT STDMETHODCALLTYPE setMessageData( 
            /* [in] */ void __RPC_FAR *userDefinedType,
            /* [in] */ long size);
		
		HRESULT STDMETHODCALLTYPE getPointer(long *ret);

		 
		HRESULT STDMETHODCALLTYPE readSysMsgConnection( I_dxj_DPLConnection **ret);
		HRESULT STDMETHODCALLTYPE readSysMsgSessionDesc( I_dxj_DirectPlaySessionData **ret);
		HRESULT STDMETHODCALLTYPE readSysMsgData( BSTR *ret);
		HRESULT STDMETHODCALLTYPE readSysChatString( BSTR *ret);
		HRESULT STDMETHODCALLTYPE moveToSecureMessage();


		HRESULT AllocData(long size);
			
		HRESULT GrowBuffer(DWORD size);

		
		
		HRESULT init(DWORD f);

		static HRESULT C_dxj_DirectPlayMessageObject::create(DWORD from,DWORD size,void **data,I_dxj_DirectPlayMessage **ret);		


		char *m_pData;		
		DWORD m_dwSize;
		DWORD m_nWriteIndex;
		DWORD m_nReadIndex;

		BOOL m_fSystem;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpsessdataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpsessdataobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpSessDataObj.h"


extern BSTR GUIDtoBSTR(LPGUID pg);
extern HRESULT BSTRtoGUID(LPGUID pg,BSTR s);

C_dxj_DirectPlaySessionDataObject::C_dxj_DirectPlaySessionDataObject()
{
	ZeroMemory(&m_desc,sizeof(DPSESSIONDESC2));
	m_desc.dwSize=sizeof(DPSESSIONDESC2);
}

C_dxj_DirectPlaySessionDataObject::~C_dxj_DirectPlaySessionDataObject()
{
	if (m_desc.lpszSessionName) SysFreeString((BSTR)m_desc.lpszSessionName);
	if (m_desc.lpszPassword) SysFreeString((BSTR)m_desc.lpszPassword);
}


HRESULT C_dxj_DirectPlaySessionDataObject::setGuidInstance( BSTR guid)
{
	HRESULT hr =BSTRtoGUID(&m_desc.guidInstance,guid);	
	return hr;
}
HRESULT C_dxj_DirectPlaySessionDataObject::getGuidInstance( BSTR *guid)
{
	*guid=GUIDtoBSTR(&m_desc.guidInstance);	
	return S_OK;
}


HRESULT C_dxj_DirectPlaySessionDataObject::setGuidApplication( BSTR guid)
{
	HRESULT hr =BSTRtoGUID(&m_desc.guidApplication,guid);	
	return hr;
}
HRESULT C_dxj_DirectPlaySessionDataObject::getGuidApplication( BSTR *guid)
{
	*guid=GUIDtoBSTR(&m_desc.guidApplication);	
	return S_OK;
}        


        
HRESULT C_dxj_DirectPlaySessionDataObject::setMaxPlayers( long val)
{
	m_desc.dwMaxPlayers=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getMaxPlayers( long *val)
{
	*val=(long)m_desc.dwMaxPlayers;
    return S_OK;
}

    
HRESULT C_dxj_DirectPlaySessionDataObject::setCurrentPlayers( long val)
{
	m_desc.dwCurrentPlayers=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getCurrentPlayers( long *val)
{
	*val=(long)m_desc.dwCurrentPlayers;
    return S_OK;
}         


HRESULT C_dxj_DirectPlaySessionDataObject::setSessionName( BSTR name)
{
	if (m_desc.lpszSessionName) SysFreeString((BSTR)m_desc.lpszSessionName);
	m_desc.lpszSessionName=SysAllocString(name);
	return S_OK;	
}
HRESULT C_dxj_DirectPlaySessionDataObject::getSessionName( BSTR *name)
{
	*name=SysAllocString(m_desc.lpszSessionName);	
	return S_OK;
}


HRESULT C_dxj_DirectPlaySessionDataObject::setSessionPassword( BSTR name)
{
	if (m_desc.lpszPassword) SysFreeString((BSTR)m_desc.lpszPassword);
	m_desc.lpszPassword=SysAllocString(name);
	return S_OK;	
}
HRESULT C_dxj_DirectPlaySessionDataObject::getSessionPassword( BSTR *name)
{
	*name=SysAllocString(m_desc.lpszPassword);	
	return S_OK;
}



HRESULT C_dxj_DirectPlaySessionDataObject::setFlags( long val)
{
	m_desc.dwFlags=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getFlags( long *val)
{
	*val=(long)m_desc.dwFlags;
    return S_OK;
}

        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser1( long val)
{
	m_desc.dwUser1=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser1( long *val)
{
	*val=(long)m_desc.dwUser1;
    return S_OK;
}


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser2( long val)
{
	m_desc.dwUser2=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser2( long *val)
{
	*val=(long)m_desc.dwUser2;
    return S_OK;
}


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser3( long val)
{
	m_desc.dwUser3=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser3( long *val)
{
	*val=(long)m_desc.dwUser3;
    return S_OK;
}
	


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser4( long val)
{
	m_desc.dwUser4=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser4( long *val)
{
	*val=(long)m_desc.dwUser4;
    return S_OK;
}


void C_dxj_DirectPlaySessionDataObject::init(DPSESSIONDESC2 *desc)
{
	memcpy(&m_desc,desc,sizeof(DPSESSIONDESC2));
	m_desc.lpszSessionName=SysAllocString(desc->lpszSessionName);
	m_desc.lpszPassword=SysAllocString(desc->lpszPassword);
}


void C_dxj_DirectPlaySessionDataObject::init(DPSessionDesc2 *desc)
{	
	m_desc.lpszSessionName=SysAllocString(desc->strSessionName);
	m_desc.lpszPassword=SysAllocString(desc->strPassword);

	BSTRtoGUID(&(m_desc.guidInstance),desc->strGuidInstance);
	BSTRtoGUID(&(m_desc.guidApplication),desc->strGuidApplication);
	
	m_desc.lpszPassword=SysAllocString(desc->strPassword);
	m_desc.dwSize=sizeof(DPSESSIONDESC2);
	m_desc.dwFlags=desc->lFlags;
	m_desc.dwMaxPlayers=desc->lMaxPlayers;
	m_desc.dwCurrentPlayers=desc->lCurrentPlayers;
	m_desc.dwUser1=desc->lUser1;
	m_desc.dwUser2=desc->lUser2;
	m_desc.dwUser3=desc->lUser3;
	m_desc.dwUser4=desc->lUser4;

}


HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSESSIONDESC2 *desc,I_dxj_DirectPlaySessionData **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlaySessionDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlaySessionDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	if (desc)	c->init(desc);

	hr=c->QueryInterface(IID_I_dxj_DirectPlaySessionData, (void**)ret);
	return hr;
}


HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSessionDesc2 *desc,I_dxj_DirectPlaySessionData **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlaySessionDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlaySessionDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	if (desc)	c->init(desc);

	hr=c->QueryInterface(IID_I_dxj_DirectPlaySessionData, (void**)ret);
	return hr;
}


HRESULT C_dxj_DirectPlaySessionDataObject::getData(void *val){
	__try {
		memcpy(val,&m_desc,sizeof(DPSESSIONDESC2));
	}
	__except(1,1){
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpsessiondescobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpsessiondescobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DPSessionDescObject : 
	public I_dxj_DPSessionDesc,
	public CComCoClass<C_dxj_DPSessionDescObject, &CLSID__dxj_DPSessionDesc>, 
	public CComObjectRoot
{
public:
	C_dxj_DPSessionDescObject() ;
	virtual ~C_dxj_DPSessionDescObject() ;

BEGIN_COM_MAP(C_dxj_DPSessionDescObject)
	COM_INTERFACE_ENTRY( I_dxj_DPSessionDesc)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPSessionDescObject)
DECLARE_REGISTRY(CLSID__dxj_D3dDeviceDesc,	"DIRECT.DPSessionDesc.5",		"DIRECT.DPSessionDesc.5",	IDS_GENERIC_DESC, THREADFLAGS_BOTH)


public:

        HRESULT STDMETHODCALLTYPE getDescription( DPSessionDesc *desc);
		HRESULT STDMETHODCALLTYPE setDescription( DPSessionDesc *desc);

private:
		DPSessionDesc m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpmsgobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpMsgObj.h"
#include "dplconnectionobj.h"
#include "dpsessdataobj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);


HRESULT C_dxj_DirectPlayMessageObject::create(DWORD from,DWORD size,void **data,I_dxj_DirectPlayMessage **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlayMessageObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlayMessageObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	c->init(from);
	if (size!=0) {
		hr=c->AllocData(size);
		if FAILED(hr){
			delete c;
			return E_OUTOFMEMORY;
		}
		*data=c->m_pData;
	}

	hr=c->QueryInterface(IID_I_dxj_DirectPlayMessage, (void**)ret);
	return hr;

}
HRESULT C_dxj_DirectPlayMessageObject::init(DWORD f){
	if (!f)
		m_fSystem=TRUE;
	else
		m_fSystem=FALSE;
	return S_OK;
}


C_dxj_DirectPlayMessageObject::C_dxj_DirectPlayMessageObject()
{
	m_dwSize=0;
	m_pData=NULL;
	m_fSystem=FALSE;
	m_nWriteIndex=0;
	m_nReadIndex=0;
}

C_dxj_DirectPlayMessageObject::~C_dxj_DirectPlayMessageObject()
{
	clear();

}

HRESULT C_dxj_DirectPlayMessageObject::writeString(BSTR string)
{
	if (!string) return E_INVALIDARG;

	//read the length of the string 
	DWORD l= (((DWORD*)string)[-1]);
	DWORD growSize=l*sizeof(WCHAR)+sizeof(DWORD);	

	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;
		
	}
	
	
	//save a DWORD with the length of the string
	*((DWORD*)(m_pData+m_nWriteIndex)) =l;
	
				
	
	//increment our write pointer past the DWORD
	m_nWriteIndex=m_nWriteIndex+sizeof(DWORD);

	//save the string to our buffer
	wcscpy((WCHAR*) &(m_pData[m_nWriteIndex]),string);

	//increment the write pointer passed the data we wrote
	m_nWriteIndex=m_nWriteIndex+l*sizeof(WCHAR);


	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readString(BSTR *string)
{
	DWORD l;
	WCHAR *pstr=NULL;

	//make sure m_pData is set
	if (!m_pData) return E_OUTOFMEMORY;
	
	//make sure we havent gone past
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	if (m_dwSize< m_nReadIndex+sizeof(DWORD)) return E_FAIL;

	if (m_fSystem){
		pstr=*((WCHAR**)(m_pData+m_nReadIndex));
		m_nReadIndex=m_nReadIndex+sizeof(DWORD); //move on to the next arg if fail on a system message
		__try {
			*string=SysAllocString(pstr);	
		}
		__except(1,1){
			return E_FAIL;
		}

	}
	else {	
		//extract the length of the string
		l= *((DWORD*)(m_pData+m_nReadIndex));	
		m_nReadIndex=m_nReadIndex+sizeof(DWORD);
		if (m_dwSize< m_nReadIndex+l*sizeof(WCHAR)) return E_FAIL;
		
		*string=SysAllocString((WCHAR*)&(m_pData[m_nReadIndex]));
		m_nReadIndex=m_nReadIndex+l*sizeof(WCHAR);
	}
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeLong(long val)
{
	
	DWORD growSize=sizeof(long);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((long*) &(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(long);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readLong(long *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;


	*val= *((long*)(m_pData+m_nReadIndex));	
	m_nReadIndex=m_nReadIndex+sizeof(long);	
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::writeShort(short val)
{

	
	DWORD growSize=sizeof(short);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((short*) (&m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(short);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readShort(short *val)
{	
	if (!m_pData) return E_OUTOFMEMORY;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((short*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(short);	
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::writeSingle(float val)
{

	
	DWORD growSize=sizeof(float);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((float*)&(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(float);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSingle(float *val)
{	
	if (!m_pData) return E_OUTOFMEMORY;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((float*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(float);	
	return S_OK;
}




HRESULT C_dxj_DirectPlayMessageObject::writeDouble(double val)
{
	
	DWORD growSize=sizeof(double);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((double*)(&m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(double);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readDouble(double *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((double*)(m_pData+m_nReadIndex));	
	m_nReadIndex=m_nReadIndex+sizeof(double);	
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeByte(Byte val)
{
	
	DWORD growSize=sizeof(BYTE);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((BYTE*)&(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(BYTE);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readByte(Byte *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((BYTE*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(BYTE);	
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeGuid(BSTR string)
{
	HRESULT hr;

	
	DWORD growSize=sizeof(GUID);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;
		
	}

	hr=BSTRtoGUID((LPGUID)&(m_pData[m_nWriteIndex]),string);
	if FAILED(hr) return hr;
	
	//increment our write pointer past the DWORD
	m_nWriteIndex=m_nWriteIndex+sizeof(GUID);
	

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readGuid(BSTR *string)
{

	//make sure m_pData is set
	if (!m_pData) return E_FAIL;
	
	//make sure we havent gone past
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	if (m_dwSize < m_nReadIndex+sizeof(GUID)) return E_FAIL;

	*string=GUIDtoBSTR( (LPGUID)	&(m_pData[m_nReadIndex]) );
		
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::moveToTop()
{
	m_nReadIndex=0;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::getMessageSize(long *ret)
{
	*ret=m_dwSize;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::getMessageData(void *ret)
{
	__try{
		memcpy(ret,m_pData,m_dwSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::setMessageData(void *data, long size)
{
	clear();
	m_dwSize=(DWORD)size;
	m_pData=(char*)malloc(size);

	if (!m_pData) return E_OUTOFMEMORY;

	__try{
		memcpy(m_pData,data,m_dwSize);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::clear()
{
	if (m_pData) free(m_pData);

	m_dwSize=0;
	m_pData=NULL;
	m_fSystem=FALSE;
	m_nWriteIndex=0;
	m_nReadIndex=0;
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::getPointer(long *ret)
{
	*ret=(long)PtrToLong(m_pData);	//bugbug SUNDOWN
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::AllocData(long size)
{
	clear();
	m_pData=(char*)malloc(size);	
	if (!m_pData) return E_OUTOFMEMORY;
	ZeroMemory(m_pData,size);

	m_dwSize=size;

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::GrowBuffer(DWORD size){
	if (m_pData) 
	{
		void* tmp = realloc(m_pData,m_dwSize+size);
		if (tmp)
			m_pData=(char*)tmp;
		else
			return E_FAIL;

		if (!m_pData) return E_FAIL;		
	}
	else  
	{
		m_pData=(char*)malloc(m_dwSize+size);
		if (!m_pData) return E_FAIL;		
	}
	m_dwSize=m_dwSize+size;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgData(BSTR *ret)
{	
	if (!m_pData) return E_FAIL;
	

	WCHAR *pstr;
	DWORD size;
	DWORD type;
	
	//valid on DPSYS_CREATEPLAYERORGROUP
	//valid on DPSYS_DESTROYPLAYERORGROUP
	//valid on DPSYS_SETPLAYERORGROUPDATA
	//make sure we have enough space to check the type
	if (m_dwSize<4) return E_FAIL;
	type= *((DWORD*)(m_pData));	
	if (!((type==DPSYS_CREATEPLAYERORGROUP)||(type==DPSYS_DESTROYPLAYERORGROUP)||(type==DPSYS_SETPLAYERORGROUPDATA)))
		return E_FAIL;

	
	

	//read the pointer to BSTR
	if (m_nReadIndex >m_dwSize) return E_FAIL;
	pstr=*((WCHAR**)(m_pData+m_nReadIndex));
	
	//read the size
	m_nReadIndex=m_nReadIndex+sizeof(DWORD); //move on to the next arg if fail on a system message
	if (m_nReadIndex >m_dwSize) return E_FAIL;
	size= *((DWORD*)(m_pData+m_nReadIndex));	



	__try {
		*ret=SysAllocString(pstr);	
	}
	__except(1,1){
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgConnection( I_dxj_DPLConnection **ret)
{

		//valid on DPSYS_STARTSESSION
		//make sure we have enough space to check the type
		if (m_dwSize<8) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_STARTSESSION)) return E_FAIL;
		
		DWORD dwConnection= *((DWORD*)(m_pData+sizeof(DWORD)));	


		INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,ret);
		if (!ret) return E_OUTOFMEMORY;

		HRESULT hr=(*ret)->setConnectionStruct( dwConnection);		

		return hr;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgSessionDesc( I_dxj_DirectPlaySessionData **ret)
{

		//valid on DPSYS_SETSESSIONDESC
		//make sure we have enough space to check the type
		if (m_dwSize<8) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_SETSESSIONDESC)) return E_FAIL;
		
		DPSESSIONDESC2 *pDesc= (LPDPSESSIONDESC2) *((DWORD*)(m_pData+sizeof(DWORD)));	

		HRESULT hr=C_dxj_DirectPlaySessionDataObject::create(pDesc,ret);

		return hr;
}


HRESULT C_dxj_DirectPlayMessageObject::readSysChatString( BSTR *ret)
{

		//valid on DPSYS_CHAT. 
		//make sure we have enough space to check the type
		if (m_dwSize<40) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_CHAT)) return E_FAIL;
		

		DPMSG_CHAT *pChatMsg = (DPMSG_CHAT*)m_pData;

		__try{

			*ret = SysAllocString(pChatMsg->lpChat->lpszMessage);
		}
		__except(1,1){
			return E_FAIL;
		}	
		
		return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::moveToSecureMessage()
{
		//valid on DPSYS_CHAT. 
		//make sure we have enough space to check the type
		if (m_dwSize<18) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_SECUREMESSAGE)) return E_FAIL;

		DPMSG_SECUREMESSAGE *pMsg = (DPMSG_SECUREMESSAGE*)m_pData;
		DWORD newIndex=0;
		__try{
			newIndex= ((DWORD)pMsg->lpData)-((DWORD)m_pData);
		}
		__except(1,1)
		{
			return E_FAIL;
		}

		if (newIndex >m_dwSize) return E_FAIL;
		m_nReadIndex=newIndex;

		return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dpsessdataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpsessdataobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectPlaySessionDataObject :
		public I_dxj_DirectPlaySessionData,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectPlaySessionDataObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectPlaySessionData)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectPlaySessionDataObject)

public:
	C_dxj_DirectPlaySessionDataObject();	
    ~C_dxj_DirectPlaySessionDataObject();

        /* [propput] */ HRESULT STDMETHODCALLTYPE setGuidInstance( 
            /* [in] */ BSTR guid);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setGuidApplication( 
            /* [in] */ BSTR guid);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidApplication( 
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setMaxPlayers( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getMaxPlayers( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setCurrentPlayers( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getCurrentPlayers( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setSessionName( 
            /* [in] */ BSTR val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getSessionName( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setSessionPassword( 
            /* [in] */ BSTR val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getSessionPassword( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser1( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser1( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser2( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser2( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser3( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser3( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser4( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser4( 
            /* [retval][out] */ long __RPC_FAR *val);

        /* [propput] */ HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long __RPC_FAR *val);

        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getData(void *val);
		
			
		void init(DPSESSIONDESC2 *desc);	
		void init(DPSessionDesc2 *desc);

		static HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSESSIONDESC2  *desc,I_dxj_DirectPlaySessionData **ret);
		static HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSessionDesc2  *desc,I_dxj_DirectPlaySessionData **ret);			   

private:
		DPSESSIONDESC2 m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DSEnumObject : 
	public I_dxj_DSEnum,
	public CComObjectRoot
{
public:
	C_dxj_DSEnumObject() ;
	virtual ~C_dxj_DSEnumObject() ;

BEGIN_COM_MAP(C_dxj_DSEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DSEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DSEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
				
		static HRESULT create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet);		

public:
		DxDriverInfo *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsenumobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600
#define OLDDSENUM 1

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DSEnumObj.h"
 

extern BSTR GUIDtoBSTR(LPGUID pGuid);

extern "C" BOOL PASCAL  objDirectSoundEnumCallback( 

#ifdef OLDDSENUM
	LPGUID lpGuid,
#else
	LPCGUID lpGuid,
#endif

  LPCSTR lpDriverDescription,  
  LPCSTR lpDriverName,         
  LPVOID lpArg            
)
{
        GUID guid;
        ZeroMemory(&guid,sizeof(GUID));
        if (lpGuid){
           memcpy(&guid,lpGuid,sizeof(GUID));
        }

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");

	
	C_dxj_DSEnumObject *pObj=(C_dxj_DSEnumObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
		{
			void* tmp = realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
			if (tmp)
				pObj->m_pList=(DxDriverInfo*)tmp;
			else
				return FALSE;
		}
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
        pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)&guid);
//      pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGuid); 
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DSEnumObject::C_dxj_DSEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DSEnumObject::~C_dxj_DSEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString((BSTR)m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString((BSTR)m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString((BSTR)m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DSEnumObject::create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet)
{
	HRESULT hr=S_OK;	
	C_dxj_DSEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DSEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DSEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	if (pcbFunc) 
	{
		hr=pcbFunc(objDirectSoundEnumCallback,pNew);	
	}
	else if (pcbFunc2)
	{
		hr=pcbFunc2(objDirectSoundEnumCallback,pNew);
	}
	else {
		hr = E_INVALIDARG;
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		//let destructor do the clean up
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DSEnum,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_DSEnumObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	
	*ret=SysAllocString(m_pList[index-1].strName);		

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getDescription( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strDescription);

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsound3dbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dbuffer.h
//
//--------------------------------------------------------------------------

// dSound3DBuffer.h : Declaration of the C_dxj_DirectSound3dBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dBuffer LPDIRECTSOUND3DBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dBufferObject : 
	public I_dxj_DirectSound3dBuffer,
	//public CComCoClass<C_dxj_DirectSound3dBufferObject, &CLSID__dxj_DirectSound3dBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dBufferObject() ;
	virtual ~C_dxj_DirectSound3dBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dBuffer)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dBuffer,	"DIRECT.DirectSound3dBuffer.3",		"DIRECT.DirectSound3dBuffer.3",			IDS_DSOUND3DBUFFER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dBufferObject)

// I_dxj_DirectSound3dBuffer
public:
	/*** IDirectSoundBuffer3D methods ***/
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3dBuffer __RPC_FAR *buffer);
        
         HRESULT STDMETHODCALLTYPE getConeAngles( 
            /* [out][in] */ long __RPC_FAR *inCone,
            /* [out][in] */ long __RPC_FAR *outCone);
        
         HRESULT STDMETHODCALLTYPE getConeOrientation( 
            /* [out][in] */ D3dVector __RPC_FAR *orientation);
        
         HRESULT STDMETHODCALLTYPE getConeOutsideVolume( 
            /* [retval][out] */ long __RPC_FAR *coneOutsideVolume);
        
         HRESULT STDMETHODCALLTYPE getMaxDistance( 
            /* [retval][out] */ float __RPC_FAR *maxDistance);
        
         HRESULT STDMETHODCALLTYPE getMinDistance( 
            /* [retval][out] */ float __RPC_FAR *minDistance);
        
         HRESULT STDMETHODCALLTYPE getMode( 
            /* [retval][out] */ long __RPC_FAR *mode);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out][in] */ D3dVector __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [out][in] */ D3dVector __RPC_FAR *velocity);
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3dBuffer __RPC_FAR *buffer,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeAngles( 
            /* [in] */ long inCone,
            /* [in] */ long outCone,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOrientation( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOutsideVolume( 
            /* [in] */ long coneOutsideVolume,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMaxDistance( 
            /* [in] */ float maxDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMinDistance( 
            /* [in] */ float minDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ long mode,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
private:
    DECL_VARIABLE(_dxj_DirectSound3dBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsound3dlistener.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dlistener.cpp
//
//--------------------------------------------------------------------------

// dSound3DListener.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"

CONSTRUCTOR(_dxj_DirectSound3dListener, {});
DESTRUCTOR(_dxj_DirectSound3dListener,  {});
GETSET_OBJECT(_dxj_DirectSound3dListener);

	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDistanceFactor, GetDistanceFactor, d3dvalue*);
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDopplerFactor, GetDopplerFactor, d3dvalue*);
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, getOrientation, GetOrientation, D3dVector*, (_D3DVECTOR*) , D3dVector*, (_D3DVECTOR*) );
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getPosition, GetPosition, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getRolloffFactor, GetRolloffFactor, d3dvalue*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getVelocity, GetVelocity, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDistanceFactor, SetDistanceFactor, d3dvalue ,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDopplerFactor, SetDopplerFactor, d3dvalue , (float),long,(DWORD));
	PASS_THROUGH_CAST_7_R(_dxj_DirectSound3dListener, setOrientation, SetOrientation, 
		d3dvalue,(float), d3dvalue, (float), d3dvalue,(float),d3dvalue,(float),d3dvalue, (float),
		d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setPosition, SetPosition, d3dvalue,(float), d3dvalue, (float),d3dvalue,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setRolloffFactor, SetRolloffFactor,d3dvalue,(float),  long, (DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setVelocity, SetVelocity, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSound3dListener, commitDeferredSettings, CommitDeferredSettings);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getAllParameters( DS3dListener* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->GetAllParameters( (LPDS3DLISTENER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::setAllParameters( DS3dListener *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->SetAllParameters( (LPDS3DLISTENER)lobj, (DWORD)apply );
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dListener->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsound3dbuffer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dbuffer.cpp
//
//--------------------------------------------------------------------------

// dSound3DBuffer.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DBuffer.h"
#include "dSound3DListener.h"

CONSTRUCTOR(_dxj_DirectSound3dBuffer, {});
DESTRUCTOR(_dxj_DirectSound3dBuffer,  {});
GETSET_OBJECT(_dxj_DirectSound3dBuffer);

	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, getConeAngles, GetConeAngles, long*,(DWORD*), long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getConeOrientation, GetConeOrientation, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getConeOutsideVolume, GetConeOutsideVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMaxDistance, GetMaxDistance, d3dvalue*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMinDistance, GetMinDistance, d3dvalue*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getMode, GetMode,  long *,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getPosition, GetPosition, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getVelocity, GetVelocity, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_3_R(_dxj_DirectSound3dBuffer, setConeAngles, SetConeAngles, long,(DWORD) ,long,(DWORD) ,long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setConeOrientation,  SetConeOrientation, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setConeOutsideVolume, SetConeOutsideVolume, long, (long),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMaxDistance, SetMaxDistance, d3dvalue, (float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMinDistance, SetMinDistance, d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMode, SetMode, long,(unsigned long) , long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setPosition, SetPosition, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setVelocity, SetVelocity, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getAllParameters( DS3dBuffer* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->GetAllParameters( (LPDS3DBUFFER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::setAllParameters( DS3dBuffer *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->SetAllParameters( (LPDS3DBUFFER)lobj, (DWORD)apply );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSound3dListener( I_dxj_DirectSound3dListener **retv)
{
	HRESULT hr;
	IDirectSound3DListener *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSound3DListener,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSound3dListener,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundbufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"


extern HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file);

CONSTRUCTOR(_dxj_DirectSoundBuffer, {});
DESTRUCTOR(_dxj_DirectSoundBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getFrequency, GetFrequency, long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setCurrentPosition, SetCurrentPosition, long,(DWORD));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFormat, SetFormat, WaveFormatex*, (LPWAVEFORMATEX));
//	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setVolume, SetVolume, LONG);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFrequency, SetFrequency, long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundBufferObject::setVolume(LONG vol)
{
#ifdef JAVA
	IDxSecurity *ids=0;
	HRESULT hr = CoCreateInstance(CLSID_DxSecurity, 0, 1, IID_IDxSecurity, (void **)&ids);
	if(hr == S_OK)
		hr = ids->isFullDirectX();

	if(hr != S_OK )
		return E_FAIL;
#endif

	return m__dxj_DirectSoundBuffer->SetVolume(vol); 
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dListener(I_dxj_DirectSound3dListener **retval)
{
    IDirectSound3DListener *lp3dl;
	HRESULT hr = DD_OK;

    if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DListener, (void**) &lp3dl)) != DD_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dListener, lp3dl, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dBuffer(I_dxj_DirectSound3dBuffer **retval)
{
    IDirectSound3DBuffer *lp3db;
	HRESULT hr = DD_OK;

    if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DBuffer, (void**) &lp3db)) != DD_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lp3db, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getCaps(DSBCaps* caps)
{
	if(!caps)
		return E_POINTER;

	caps->lSize = sizeof(DSBCAPS);
	return m__dxj_DirectSoundBuffer->GetCaps((LPDSBCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getCurrentPosition(DSCursors *desc) 
{ 
	if(!desc)
		return E_POINTER;

  return (m__dxj_DirectSoundBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (p1, &buffer[start], size1);

	if (size2)	
		memcpy(p2, &buffer, size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val=m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (&buffer[start],p1,  size1);

	if (size2)	
		memcpy(&buffer,p2,  size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val= m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getFormat(WaveFormatex *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	hr=m__dxj_DirectSoundBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WaveFormatex), wsize);
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::initialize(I_dxj_DirectSound *ds, DSBufferDesc *buf,
				BYTE *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;

	// make Java desc look like DirectX desc
	buf->lSize = sizeof(DSBUFFERDESC);
	buf->lpwfxFormat = PtrToLong(wave);	//bugbug SUNDOWN

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpds, ds)

	m__dxj_DirectSoundBuffer->Initialize(lpds, (LPDSBUFFERDESC)buf);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	if((hr=m__dxj_DirectSoundBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
		return hr;

	return hr;
}



STDMETHODIMP C_dxj_DirectSoundBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;
	hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}


STDMETHODIMP C_dxj_DirectSoundBufferObject::saveToFile(BSTR file)
{

	HRESULT hr= InternalSaveToFile(m__dxj_DirectSoundBuffer,file);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsound3dlistener.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dlistener.h
//
//--------------------------------------------------------------------------

// dSound3DListener.h : Declaration of the C_dxj_DirectSound3dListenerObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dListener LPDIRECTSOUND3DLISTENER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dListenerObject : 
	public I_dxj_DirectSound3dListener,
	//public CComCoClass<C_dxj_DirectSound3dListenerObject, &CLSID__dxj_DirectSound3dListener>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dListenerObject() ;
	virtual ~C_dxj_DirectSound3dListenerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dListenerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dListener)
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dListener,	"DIRECT.DirectSound3dListener.3",	"DIRECT.DirectSound3dListener.3",		IDS_DSOUND3DLISTENER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dListenerObject)

// I_dxj_DirectSound3dListener
public:
	/*** IDirectSound3D methods ***/
	//
	//updated

	     /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3dListener __RPC_FAR *listener) ;
        
         HRESULT STDMETHODCALLTYPE getDistanceFactor( 
            /* [retval][out] */ float __RPC_FAR *distanceFactor) ;
        
         HRESULT STDMETHODCALLTYPE getDopplerFactor( 
            /* [retval][out] */ float __RPC_FAR *dopplerFactor) ;
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [out][in] */ D3dVector __RPC_FAR *orientFront,
            /* [out][in] */ D3dVector __RPC_FAR *orientTop) ;
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out] */ D3dVector __RPC_FAR *position) ;
        
         HRESULT STDMETHODCALLTYPE getRolloffFactor( 
            /* [retval][out] */ float __RPC_FAR *rolloffFactor) ;
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [retval][out] */ D3dVector __RPC_FAR *velocity) ;
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3dListener __RPC_FAR *listener,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDistanceFactor( 
            /* [in] */ float distanceFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDopplerFactor( 
            /* [in] */ float dopplerFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ float xFront,
            /* [in] */ float yFront,
            /* [in] */ float zFront,
            /* [in] */ float xTop,
            /* [in] */ float yTop,
            /* [in] */ float zTop,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setRolloffFactor( 
            /* [in] */ float rolloffFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE commitDeferredSettings( void) ;
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal) ;
private:
    DECL_VARIABLE(_dxj_DirectSound3dListener);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dListener )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundbufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundBuffer LPDIRECTSOUNDBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundBuffer, &IID_I_dxj_DirectSoundBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundBufferObject, &CLSID__dxj_DirectSoundBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundBufferObject() ;
	virtual ~C_dxj_DirectSoundBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSoundBuffer,	"DIRECT.DirectSoundBuffer.3",		"DIRECT.DirectSoundBuffer.3",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *lpdsl);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dBuffer( 
            /* [retval][out] */ I_dxj_DirectSound3dBuffer __RPC_FAR *__RPC_FAR *lpdsb);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCursors __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WaveFormatex __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getFrequency( 
            /* [retval][out] */ long __RPC_FAR *frequency);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCurrentPosition( 
            /* [in] */ long newPosition);
        
         HRESULT STDMETHODCALLTYPE setFormat( 
            /* [in] */ WaveFormatex __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE setFrequency( 
            /* [in] */ long frequency);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 
		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE saveToFile(BSTR b);

private:
    DECL_VARIABLE(_dxj_DirectSoundBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundcaptureobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcaptureobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCapture LPDIRECTSOUNDCAPTURE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCapture, &IID_I_dxj_DirectSoundCapture, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCapture,
#endif

	//public CComCoClass<C_dxj_DirectSoundCaptureObject, &CLSID__dxj_DirectSoundCapture>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureObject() ;
	virtual ~C_dxj_DirectSoundCaptureObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCapture)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCapture,	"DIRECT.DirectSoundCapture.5",		"DIRECT.DirectSoundCapture.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCapture
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE createCaptureBuffer( 
            /* [in] */ DSCBufferDesc __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCCaps __RPC_FAR *caps) ;

private:
    DECL_VARIABLE(_dxj_DirectSoundCapture);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCapture )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.cpp
//
//--------------------------------------------------------------------------

// dSoundObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"

extern HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer) ;
extern HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer);

CONSTRUCTOR(_dxj_DirectSound, {m__dxj_DirectSound=NULL;m_pDriverGuid=NULL;});
DESTRUCTOR(_dxj_DirectSound,  {if (m_pDriverGuid) delete m_pDriverGuid;});
GETSET_OBJECT(_dxj_DirectSound);
	//
    /*** IDirectSound methods ***/
	//

PASS_THROUGH_CAST_1_R(_dxj_DirectSound, getSpeakerConfig, GetSpeakerConfig, long*,(DWORD*)); 
PASS_THROUGH_CAST_1_R(_dxj_DirectSound, setSpeakerConfig, SetSpeakerConfig, long,(DWORD)); 

STDMETHODIMP C_dxj_DirectSoundObject::getCaps(DSCaps* caps)
{
	caps->lSize = sizeof(DSCAPS);
	return m__dxj_DirectSound->GetCaps((LPDSCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(HWnd h, long d)
{
	if( m__dxj_DirectSound == NULL )
		return E_FAIL;

	return m__dxj_DirectSound->SetCooperativeLevel((HWND)h, (DWORD)d); 
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::duplicateSoundBuffer(I_dxj_DirectSoundBuffer *src, 
													I_dxj_DirectSoundBuffer **val) 
{
	if(! (src && val) )
		return E_POINTER;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpdsb, src);

	//Need to create a second one
	LPDIRECTSOUNDBUFFER		dsb=0;
	HRESULT hr=DD_OK;
	hr=m__dxj_DirectSound->DuplicateSoundBuffer((LPDIRECTSOUNDBUFFER)lpdsb, &dsb); 
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

#pragma message ("Consider putting waveformat back in DSBufferDesc")

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundObject::createSoundBuffer(DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	BOOL bDirty=FALSE;

	// make Java desc look like DirectX desc
	desc->lSize = sizeof(DSBUFFERDESC);
	
	for (int i=0;i<sizeof(WAVEFORMATEX);i++) {
		if (((byte*)wave)[i]!=0) bDirty=TRUE;
	}

	if (bDirty==TRUE){
		desc->lpwfxFormat = PtrToLong(wave);	//bugbug SUNDOWN
	}
	else {
		desc->lpwfxFormat = 0;
	}

	LPDSBUFFERDESC lpds ;
	lpds = (LPDSBUFFERDESC)desc;
	HRESULT hr=S_OK;
	hr = m__dxj_DirectSound->CreateSoundBuffer(lpds, &dsb, NULL);
 
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromFile(BSTR fileName, DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;

		
	*val=NULL;	
	desc->lSize = sizeof(DSBUFFERDESC);
	desc->lpwfxFormat = (long)PtrToLong(wave);		//bugbug SUNDOWN
	lpds = (LPDSBUFFERDESC)desc;
	
	hr=InternalCreateSoundBufferFromFile(m__dxj_DirectSound,(LPDSBUFFERDESC)desc,
			(WCHAR*)fileName,&dsb); 

	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;


}



STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromResource(BSTR resFile, BSTR resName, DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{

		
	
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;	
	HMODULE					hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// use ansi verion
		 LPCTSTR pszName = NULL;
		 __try { pszName = W2T(resFile); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		 hMod= GetModuleHandle(pszName);
	}

		
	*val=NULL;	
	desc->lSize = sizeof(DSBUFFERDESC);
	desc->lpwfxFormat = (long)PtrToLong(wave);	//NOTE SUNDOWN issue
	lpds = (LPDSBUFFERDESC)desc;
	
	hr=InternalCreateSoundBufferFromResource(m__dxj_DirectSound,(LPDSBUFFERDESC)desc,
			(HANDLE)hMod,(WCHAR*)resName,&dsb);

	
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.h
//
//--------------------------------------------------------------------------

// dSoundObj.h : Declaration of the C_dxj_DirectSoundObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound  LPDIRECTSOUND
 
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSound, &IID_I_dxj_DirectSound, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSound,
#endif

	//public CComCoClass<C_dxj_DirectSoundObject, &CLSID__dxj_DirectSound>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundObject() ;
	virtual ~C_dxj_DirectSoundObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound, "DIRECT.DirectSound.3",				"DIRECT.DirectSound.3",					IDS_DSOUND_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:


         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createSoundBuffer( 
            /* [in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [in] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromFile( 
            /* [in] */ BSTR fileName,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromResource( 
            /* [in] */ BSTR resourceFile,
            /* [in] */ BSTR resourceName,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE duplicateSoundBuffer( 
            /* [in] */ I_dxj_DirectSoundBuffer __RPC_FAR *original,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *duplicate);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hwnd,
            /* [in] */ long level);
        
        
         HRESULT STDMETHODCALLTYPE getSpeakerConfig( 
            /* [retval][out] */ long __RPC_FAR *speakerConfig);
        
         HRESULT STDMETHODCALLTYPE setSpeakerConfig( 
            /* [in] */ long speakerConfig);


////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectSound);
	GUID *m_pDriverGuid;

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundcapturebufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcapturebufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCaptureBuffer LPDIRECTSOUNDCAPTUREBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCaptureBuffer, &IID_I_dxj_DirectSoundCaptureBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCaptureBuffer,
#endif

//	public CComCoClass<C_dxj_DirectSoundCaptureBufferObject, &CLSID__dxj_DirectSoundCaptureBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureBufferObject() ;
	virtual ~C_dxj_DirectSoundCaptureBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCaptureBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCaptureBuffer,	"DIRECT.DirectSoundCaptureBuffer.5",		"DIRECT.DirectSoundCaptureBuffer.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCaptureBuffer
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCBCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( DSCursors *desc);                  			

         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WaveFormatex __RPC_FAR *waveformat);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *captureBuffer,
            /* [in] */ DSCBufferDesc __RPC_FAR *bufferDesc);
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE stop( void);

		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE readBuffer(long start, long totsz, 
													void  *buf,  long flags) ;
		 HRESULT STDMETHODCALLTYPE writeBuffer(long start, long totsz, 
													void  *buf,  long flags) ;


private:
    DECL_VARIABLE(_dxj_DirectSoundCaptureBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCaptureBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundcapturebufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcapturebufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureBufferObj.h"
#include "dSoundCaptureObj.h"

CONSTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
DESTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundCaptureBuffer);

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCaps(DSCBCaps *caps)
{    
	((DSCBCAPS*)caps)->dwSize=sizeof(DSCBCAPS);
    return m__dxj_DirectSoundCaptureBuffer->GetCaps((DSCBCAPS*)caps);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCurrentPosition(DSCursors *desc) 
{    	
	/////////////////////////////////////////////////////////////////////////////
	if(!desc)
		return E_POINTER;

	return (m__dxj_DirectSoundCaptureBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}


STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getStatus(long *stat)
{    	
    return m__dxj_DirectSoundCaptureBuffer->GetStatus((DWORD*)stat);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::start(long flags)
{    	
    return m__dxj_DirectSoundCaptureBuffer->Start((DWORD)flags);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::stop()
{    	
    return m__dxj_DirectSoundCaptureBuffer->Stop();
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getFormat(WaveFormatex *format)
{    	
	DWORD cb=0;
    return m__dxj_DirectSoundCaptureBuffer->GetFormat((WAVEFORMATEX*)format,sizeof(WaveFormatex),&cb);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::initialize(I_dxj_DirectSoundCaptureBuffer *buffer,DSCBufferDesc *desc)
{    	
	((DSCBUFFERDESC*)desc)->dwSize=sizeof(DSCBUFFERDESC);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDCAPTURE, lpref, buffer);
    return m__dxj_DirectSoundCaptureBuffer->Initialize(lpref,(DSCBUFFERDESC*)desc);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;
	hr=m__dxj_DirectSoundCaptureBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}

        

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (p1, &buffer[start], size1);

	if (size2)	
		memcpy(p2, &buffer, size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val=m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (&buffer[start],p1,  size1);

	if (size2)	
		memcpy(&buffer,p2,  size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(0,0){
	return E_FAIL;
   }
   return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dxglob7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dxglob7obj.cpp
//
//--------------------------------------------------------------------------


#define DIRECTINPUT_VERSION 0x0500
#define DIRECTSOUND_VERSION 0x600

// dSoundResourceObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "windows.h"
#include "mmsystem.h"

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "math.h"

#include "dxGlob7Obj.h"


#include "d3drm.h"
#include "ddraw.h"
#include "dmusici.h"
#include "dmusicf.h"

#include "ddraw4Obj.h"    
#include "ddraw7Obj.h"
#include "DDEnumObj.h"
    	


#include "d3drm3Obj.h"

#include "dsoundObj.h"
#include "dsoundCaptureObj.h"
#include "DSEnumObj.h"    


#include "dplay4obj.h"
#include "dplaylobby3obj.h"
#include "DPEnumObj.h"

#include "dinput1Obj.h"




#include "dmSegmentObj.h"
#include "dmSegmentStateObj.h"
#include "dmChordMapObj.h"
#include "dmBandObj.h"
#include "dmCollectionObj.h"
#include "dmStyleObj.h"
#include "dmPerformanceObj.h"
#include "dmLoaderObj.h"
#include "dmComposerObj.h"


//#include "webObj.h"

extern HINSTANCE g_hInstD3DRMDLL;
extern HINSTANCE g_hDSoundHandle;
extern HINSTANCE g_hDPlay;
extern HINSTANCE g_hDDrawHandle;
extern HINSTANCE g_hInstDINPUTDLL;
extern HINSTANCE g_hInst;

extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicPerformance;

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);

extern HINSTANCE LoadDDrawDLL();
extern HINSTANCE LoadD3DXOFDLL();
extern HINSTANCE LoadDPlayDLL();
extern HINSTANCE LoadDSoundDLL();
extern HINSTANCE LoadD3DRMDLL();
extern HINSTANCE LoadDINPUTDLL();

DWORD WINAPI ThreadFunc(LPVOID param);

C_dxj_DirectX7Object::C_dxj_DirectX7Object(){
        	

    m_pDirectDrawCreate=NULL;
    m_pDirectDrawCreateEx=NULL;
    m_pDirectDrawCreateClipper=NULL;
    m_pDirectSoundCreate=NULL;
    m_pDirectSoundEnumerate=NULL;
    m_pDirectSoundCaptureEnumerate=NULL;
	m_pDirectSoundCaptureCreate=NULL;
    m_pDirectPlayCreate=NULL;
    m_pDirectPlayEnumerate=NULL;
    m_pDirectPlayLobbyCreate=NULL;
    m_pDirect3DRMCreate=NULL;
    m_pDirectDrawEnumerate=NULL;
    m_pDirectDrawEnumerateEx=NULL;
    m_pEventList=NULL;
}

void C_dxj_DirectX7Object::LoadDSOUND()
{   
	if (!g_hDSoundHandle )	LoadDSoundDLL();  
    if (!m_pDirectSoundCreate)              m_pDirectSoundCreate = (DSOUNDCREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCreate" );
    if (!m_pDirectSoundCaptureCreate)       m_pDirectSoundCaptureCreate = (DSOUNDCAPTURECREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureCreate" );
    if (!m_pDirectSoundEnumerate)           m_pDirectSoundEnumerate = (DSOUNDENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundEnumerateA" );
    if (!m_pDirectSoundCaptureEnumerate)    m_pDirectSoundCaptureEnumerate = (DSOUNDCAPTUREENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureEnumerateA" );
    
}

void C_dxj_DirectX7Object::LoadDDRAW()
{
    
    if (!g_hDDrawHandle ) LoadDDrawDLL();    	
    if (!m_pDirectDrawCreate)           m_pDirectDrawCreate = (DDRAWCREATE)GetProcAddress( g_hDDrawHandle, "DirectDrawCreate" );
    if (!m_pDirectDrawCreateEx)         m_pDirectDrawCreateEx = (DDRAWCREATEEX)GetProcAddress( g_hDDrawHandle, "DirectDrawCreateEx" );
    if (!m_pDirectDrawCreateClipper)    m_pDirectDrawCreateClipper = (DDCREATECLIPPER)GetProcAddress( g_hDDrawHandle, "DirectDrawCreateClipper" );
    if (!m_pDirectDrawEnumerate)        m_pDirectDrawEnumerate = (DDENUMERATE)GetProcAddress( g_hDDrawHandle, "DirectDrawEnumerateA" );
    if (!m_pDirectDrawEnumerateEx)    	m_pDirectDrawEnumerateEx = (DDENUMERATEEX)GetProcAddress( g_hDDrawHandle, "DirectDrawEnumerateExA" );
    
}

void C_dxj_DirectX7Object::LoadDPLAY()
{
    

    if (!g_hDPlay ) LoadDPlayDLL();
    
    //Note use of Wide char for DirectPlayLobby Create and
    //Ansi for DirectPlay
    if (!m_pDirectPlayCreate)           m_pDirectPlayCreate = (DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );
    if (!m_pDirectPlayEnumerate)        m_pDirectPlayEnumerate = (DIRECTPLAYENUMERATE)GetProcAddress( g_hDPlay, "DirectPlayEnumerateW" );
    if (!m_pDirectPlayLobbyCreate)      m_pDirectPlayLobbyCreate = (DIRECTPLAYLOBBYCREATE)GetProcAddress( g_hDPlay, "DirectPlayLobbyCreateW" );
    

}

void C_dxj_DirectX7Object::LoadD3DRM()
{
    
    if (!g_hInstD3DRMDLL)  {
            LoadD3DXOFDLL();
	        LoadD3DRMDLL();
    }

        //Note: always ansi no unicode version
    if (!m_pDirect3DRMCreate)           m_pDirect3DRMCreate =(DIRECT3DRMCREATE)GetProcAddress( g_hInstD3DRMDLL, "Direct3DRMCreate" );

    
            
}

C_dxj_DirectX7Object::~C_dxj_DirectX7Object()
{
    DWORD i=1;

    while (m_pEventList) {


 	//bugbug SUNDOWN gotcha
  	//vb does not have 64 bit values 
	//and we use the same api to release the event
	//but handles are 64 bit
	//note handles never get near 32 bits in win32
	//but whose knows on win64
        	destroyEvent((long)PtrToLong(m_pEventList->hEvent));

    	//m_pEventList=m_pEventList->pNext; done by destroyEvent
    }
}


STDMETHODIMP C_dxj_DirectX7Object::direct3dRMCreate( I_dxj_Direct3dRM3 **ret){
    HRESULT		  hr;
    LPDIRECT3DRM  realrm1=NULL;
    LPDIRECT3DRM3 realrm3=NULL;

    LoadD3DRM();


    if (!m_pDirect3DRMCreate) return E_FAIL;

    hr=(m_pDirect3DRMCreate)(&realrm1);
    if FAILED(hr) return  hr;

    hr=realrm1->QueryInterface(IID_IDirect3DRM3,(void**) &realrm3);
    if FAILED(hr){
        realrm1->Release();
        return hr;
    }

    INTERNAL_CREATE(_dxj_Direct3dRM3,realrm3,ret);
    realrm1->Release();
    
    if (*ret==NULL) {
        realrm3->Release();
        return E_FAIL;
    }
    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directDraw4Create(BSTR strGuid, I_dxj_DirectDraw4 **ret){
    HRESULT		  hr;
    LPDIRECTDRAW  realdraw1=NULL;
    LPDIRECTDRAW4 realdraw4=NULL;
    GUID		  guid;
    LPGUID		  pguid=&guid;
    DWORD		  i=0;

    LoadDDRAW();


    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return E_FAIL;
        
    
    if (!m_pDirectDrawCreate) return E_FAIL;

    hr=(m_pDirectDrawCreate)((GUID*)pguid,&realdraw1,NULL);
    if FAILED(hr) return  hr;


    hr=realdraw1->QueryInterface(IID_IDirectDraw4,(void**) &realdraw4);
    if FAILED(hr){
        i=realdraw1->Release();
        return hr;
    }

    i=realdraw1->Release();
        
    INTERNAL_CREATE(_dxj_DirectDraw4,realdraw4,ret);


    
    if (*ret==NULL) {
        i=realdraw4->Release();
        return E_FAIL;
    }
    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directDrawCreate(BSTR strGuid, I_dxj_DirectDraw7 **ret){
    HRESULT		  hr;	
    LPDIRECTDRAW7 realdraw7=NULL;
    GUID		  guid;
    LPGUID		  pguid=&guid;
    DWORD		  i=0;

    LoadDDRAW();


    ZeroMemory(&guid,sizeof(GUID));	//andrewke bugfix post dx7

    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return E_FAIL;
        
        
    if (!m_pDirectDrawCreateEx) return E_FAIL;


    hr=(m_pDirectDrawCreateEx)(pguid,(void**)&realdraw7,IID_IDirectDraw7,NULL);
    
    if FAILED(hr) return  hr;

        
    INTERNAL_CREATE(_dxj_DirectDraw7,realdraw7,ret);

    
    if (*ret==NULL) {
        i=realdraw7->Release();
        return E_FAIL;
    }
    return hr;		
}



STDMETHODIMP C_dxj_DirectX7Object::directSoundCreate(BSTR  strGuid, I_dxj_DirectSound **ret){
    HRESULT			hr;
    LPDIRECTSOUND	realsound1=NULL;
    GUID			guid;
    LPGUID			pguid=&guid;

    LoadDSOUND();

    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return hr;

    if (!m_pDirectSoundCreate) return E_FAIL;

    hr=(m_pDirectSoundCreate)((GUID*)pguid,&realsound1,NULL);
    if FAILED(hr) return  hr;


    INTERNAL_CREATE(_dxj_DirectSound,realsound1,ret);
    
    if (*ret==NULL) {
        realsound1->Release();
        return E_FAIL;
    }

    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directSoundCaptureCreate(BSTR strGuid, I_dxj_DirectSoundCapture **ret){
    HRESULT		  hr;
    LPDIRECTSOUNDCAPTURE realsound1=NULL;
    GUID			guid;
    LPGUID			pguid=&guid;
    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return hr;

	LoadDSOUND();


    if (!m_pDirectSoundCaptureCreate) return E_FAIL;

    hr=(m_pDirectSoundCaptureCreate)(pguid,&realsound1,NULL);
    if FAILED(hr) return  hr;


    INTERNAL_CREATE(_dxj_DirectSoundCapture,realsound1,ret);
    
    if (*ret==NULL) {
        realsound1->Release();
        return E_FAIL;
    }

    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::getDSCaptureEnum( I_dxj_DSEnum **retVal)
{	
    HRESULT hr;

    LoadDSOUND();

    if (!m_pDirectSoundCaptureEnumerate) return E_FAIL;	
    hr=C_dxj_DSEnumObject::create(NULL,m_pDirectSoundCaptureEnumerate,retVal);

    return hr;

}
        




STDMETHODIMP C_dxj_DirectX7Object::getDDEnum( I_dxj_DirectDrawEnum **retVal)
{

    LoadDDRAW();

    HRESULT hr;
    if (!m_pDirectDrawEnumerateEx) return E_FAIL;	
    hr=C_dxj_DirectDrawEnumObject::create(m_pDirectDrawEnumerateEx,retVal);
    return hr;

}

/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_DirectX7Object::getDSEnum( I_dxj_DSEnum **retVal)
{	
    HRESULT hr;
    LoadDSOUND();

    if (!m_pDirectSoundEnumerate) return E_FAIL;	
    hr=C_dxj_DSEnumObject::create(m_pDirectSoundEnumerate,NULL,retVal);

    return hr;

}




/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_DirectX7Object::colorGetAlpha(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){	
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetAlpha"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::colorGetRed(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;	
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetRed"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

         
STDMETHODIMP C_dxj_DirectX7Object::colorGetGreen(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;	
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetGreen"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::colorGetBlue(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetBlue"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createColorRGB(float r, float g, float b, long *color)
{
  static long (WINAPI *ProcAdd)(float,float,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (long (WINAPI*)(float,float,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMCreateColorRGB"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *color=(ProcAdd) (r,g,b);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createColorRGBA(float r, float g, float b, float a, long *color)
{
  static long (WINAPI *ProcAdd)(float,float,float,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (long (WINAPI*)(float,float,float,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMCreateColorRGBA"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *color=(ProcAdd) (r,g,b,a);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::matrixFromQuaternion(D3dMatrix *matrix, D3dRMQuaternion *quat)
{    
    if ((!matrix) || (!quat)) return E_INVALIDARG;

    D3DMATRIX *mat=(D3DMATRIX*)matrix;
    FLOAT w=quat->s;
    FLOAT x=quat->v.x;
    FLOAT y=quat->v.y;
    FLOAT z=quat->v.z;

    FLOAT xx = x*x,   xy = x*y,   xz = x*z,   xw = x*w;
    FLOAT yy = y*y,   yz = y*z,   yw = y*w;
    FLOAT zz = z*z,   zw = z*w;
    FLOAT ww = w*w;

    mat->_11 = xx-yy-zz+ww;
    mat->_12 = 2.0f*(xy-zw);
    mat->_13 = 2.0f*(xz+yw);

    mat->_21 = 2.0f*(xy+zw);
    mat->_22 = -xx+yy-zz+ww;
    mat->_23 = 2.0f*(yz-xw);

    mat->_31 = 2.0f*(xz-yw);
    mat->_32 = 2.0f*(yz+xw);
    mat->_33 = -xx-yy+zz+ww;

    mat->_14 = mat->_41 = 0.0f;
    mat->_24 = mat->_42 = 0.0f;
    mat->_34 = mat->_43 = 0.0f;
    mat->_44 = xx+yy+zz+ww;

return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::quaternionRotation(D3dRMQuaternion *quat, D3dVector *axis, float theta)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dVector*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dVector*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionRotation"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quat,axis,theta)) return E_FAIL;    
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::quaternionMultiply(D3dRMQuaternion *quatr, D3dRMQuaternion *quat1, D3dRMQuaternion *quat2)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionMultiply"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quatr,quat1,quat2)) return E_FAIL;
  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::quaternionSlerp(D3dRMQuaternion *quatr, D3dRMQuaternion *quat1, D3dRMQuaternion *quat2, float t)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionSlerp"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quatr,quat1,quat2,t)) return E_FAIL;
  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::vectorAdd(D3dVector *v, D3dVector *a, D3dVector *b)
{
  v->x = a->x + b->x;
  v->y = a->y + b->y;
  v->z = a->z + b->z;
  return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::vectorCopy(D3dVector *dest, D3dVector *src)
{
  memcpy(dest,src,sizeof(D3DVECTOR));

  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::vectorCrossProduct(D3dVector *v, D3dVector *a, D3dVector *b)
{
    v->x = ((a->y) * (b->z)) - ((a->z) * (b->y));
    v->y = ((a->z) * (b->x)) - ((a->x) * (b->z));
    v->z = ((a->x) * (b->y)) - ((a->y) * (b->x));

  return S_OK;
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorDotProduct(D3dVector *a, D3dVector *b, float *ret)
{
  //TODO consider overflow?
  *ret =	(a->x * b->x) + (a->y *b->y) + (a->z * b->z);
      
  return S_OK;
}        

STDMETHODIMP C_dxj_DirectX7Object::vectorModulus(D3dVector *a,  float *ret)
{
  //NOTE: would do it myself but dont want to link in c runtime for Sqrt

  static float (WINAPI *ProcAdd)(D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorModulus"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *ret=(ProcAdd) (a);    
  return S_OK;
    
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorNormalize(D3dVector *dest)
{

    
    double l;

      
    l = dest->x * dest->x + dest->y * dest->y + dest->z * dest->z;
    l = sqrt(l);
    dest->x = dest->x / (float)l;
    dest->y = dest->y / (float)l;
    dest->z = dest->z / (float)l;

  return S_OK;
    
}        



STDMETHODIMP C_dxj_DirectX7Object::vectorRandom(D3dVector *a)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorRandom"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(a)==NULL) return E_FAIL;    
  return S_OK;
    
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorReflect(D3dVector *dest,D3dVector *ray,D3dVector *norm)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*,D3dVector*,D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*,D3dVector*,D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorReflect"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(dest,ray,norm)==NULL) return E_FAIL;    
  return S_OK;	
}


STDMETHODIMP C_dxj_DirectX7Object::vectorRotate(D3dVector *dest,D3dVector *vA,D3dVector *vAxis, float theta)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*,D3dVector*,D3dVector*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*,D3dVector*,D3dVector*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorRotate"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(dest,vA,vAxis,theta)==NULL) return E_FAIL;    
  return S_OK;	
}
        

STDMETHODIMP C_dxj_DirectX7Object::vectorScale(D3dVector *v, D3dVector *a, float factor)
{
    v->x=a->x *factor;
    v->y=a->y *factor;
    v->z=a->z *factor;
  return S_OK;
}        
        						   

STDMETHODIMP C_dxj_DirectX7Object::vectorSubtract(D3dVector *v, D3dVector *a, D3dVector *b)
{
  v->x = a->x - b->x;
  v->y = a->y - b->y;
  v->z = a->z - b->z;
  return S_OK;
}
  

      



STDMETHODIMP C_dxj_DirectX7Object::directPlayCreate(BSTR strGuid, I_dxj_DirectPlay4 **directPlay)
{
    LPDIRECTPLAY4	dp;
    HRESULT hr=E_FAIL;
    LPDIRECTPLAY lpDP=NULL;
    GUID	guid;
    
    LoadDPLAY();
    

    ZeroMemory(&guid,sizeof(GUID));


    hr=DPLBSTRtoGUID(&guid,strGuid);
    if FAILED(hr) return E_INVALIDARG;


    if (m_pDirectPlayCreate == NULL )	return E_FAIL;

    // create a DirectPlay1 interface
    hr = (m_pDirectPlayCreate)(&guid, &lpDP, NULL);
    if FAILED(hr) return hr;
    if (!lpDP) return E_FAIL;

    // now get Dplay3 interface
    hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    lpDP->Release();
    if FAILED(hr) return hr;

    if (!dp) return E_FAIL;

    *directPlay=NULL;
    INTERNAL_CREATE(_dxj_DirectPlay4, dp, directPlay);
    if (*directPlay==NULL) return E_FAIL;

    return hr;
}


STDMETHODIMP C_dxj_DirectX7Object::directPlayLobbyCreate(I_dxj_DirectPlayLobby3 **ret)
{
    LPDIRECTPLAYLOBBY3	dp=NULL;
    HRESULT hr=E_FAIL;
    LPDIRECTPLAYLOBBY  lpDP=NULL;

    LoadDPLAY();

    if (m_pDirectPlayLobbyCreate == NULL )	return E_FAIL;


    // create a DirectPlay1 interface
    hr = m_pDirectPlayLobbyCreate(NULL, &lpDP, NULL,NULL,0);
    if FAILED(hr) return hr;

if (!lpDP) return E_FAIL;

    // no get Dplay3 interface
    hr = lpDP->QueryInterface(IID_IDirectPlayLobby3,(LPVOID *)&dp);			
    lpDP->Release();
if FAILED(hr) return hr;

    *ret=NULL;
    
if (!dp) return E_FAIL;

    INTERNAL_CREATE(_dxj_DirectPlayLobby3, dp, ret);
    if (*ret==NULL) return E_FAIL;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectX7Object::getDPEnum( I_dxj_DPEnumServiceProviders **retVal)
{	
    HRESULT hr;
    LoadDPLAY();


    if (!m_pDirectPlayEnumerate) return E_FAIL;	
    hr=C_dxj_DPEnumObject::create(m_pDirectPlayEnumerate,retVal);

    return hr;

}

////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectX7Object::directInputCreate(I_dxj_DirectInput **ret){
  
  LoadDINPUTDLL();

  HRESULT hr;
  static HRESULT (WINAPI *ProcAdd)(HINSTANCE,DWORD,LPDIRECTINPUT*,LPUNKNOWN)=NULL;  
  if (ProcAdd==NULL){
    if (g_hInstDINPUTDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (HRESULT (WINAPI*)(HINSTANCE,DWORD,LPDIRECTINPUT*,LPUNKNOWN)) GetProcAddress(g_hInstDINPUTDLL, "DirectInputCreateA"); 
    if (ProcAdd==NULL) return E_FAIL;
  }	
 
  LPDIRECTINPUT lpInput=NULL;

  hr= (ProcAdd)(g_hInst,(DWORD)DIRECTINPUT_VERSION,&lpInput,NULL);
  if FAILED(hr) return hr;

  INTERNAL_CREATE(_dxj_DirectInput,lpInput,ret);	

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_DirectX7Object::tickCount( long *retval)
{

    *retval = GetTickCount();

    return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::systemBpp(long *retval)
{
    HDC hdc;

    hdc = ::GetDC(NULL);
    if (!hdc) return E_OUTOFMEMORY;
    *retval = GetDeviceCaps(hdc, BITSPIXEL);
    ::ReleaseDC(NULL, hdc);

    return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::rotateXMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){


        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc11 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc22 = fcos;
        	mDest->rc33 = fcos;
        	mDest->rc23 = -fsin;
        	mDest->rc32 = fsin;


        	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::rotateYMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){

        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc22 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc11 = fcos;
        	mDest->rc33 = fcos;
        	mDest->rc13 = fsin;
        	mDest->rc31 = -fsin;

        	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::rotateZMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){


        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc33 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc11 = fcos;
        	mDest->rc22 = fcos;
        	mDest->rc12 = -fsin;
        	mDest->rc21 = fsin;

        	return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::viewMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *view,
            /* [in] */ D3dVector __RPC_FAR *from,
            /* [in] */ D3dVector __RPC_FAR *at,
            /* [in] */ D3dVector __RPC_FAR *world_up,
            /* [in] */ float roll)
{

    


        D3dVector up;
        D3dVector right;
        D3dVector view_Dir;

        ZeroMemory(view,sizeof(D3dMatrix));
        view->rc11 = 1;
        view->rc22 = 1;
        view->rc33 = 1;
        view->rc44 = 1;

        view_Dir.x=at->x-from->x;
        view_Dir.y=at->y-from->y;
        view_Dir.z=at->z-from->z;
            
        vectorNormalize(&view_Dir);

        
        //think lefthanded coords
        vectorCrossProduct(&right, world_up, &view_Dir);
        vectorCrossProduct(&up, &view_Dir, &right);
    
        vectorNormalize(&right);
        vectorNormalize(&up);
    
        view->rc11 = right.x;
        view->rc21 = right.y;
        view->rc31 = right.z;
        view->rc12 = up.x ;  //AK? should this be negative?
        view->rc22 = up.y;
        view->rc32 = up.z;
        view->rc13 = view_Dir.x;
        view->rc23 = view_Dir.y;
        view->rc33 = view_Dir.z;
    
        view->rc41 =  -((right.x * from->x) + (right.y * from->y) + (right.z * from->z));
        view->rc42 =  -((up.x * from->x) + (up.y * from->y) + (up.z * from->z));
        view->rc43 =  -((view_Dir.x * from->x) + (view_Dir.y * from->y) + (view_Dir.z * from->z));


        if (roll!=0){
        	D3dMatrix rotZMat;
        	rotateZMatrix(&rotZMat,-roll);
        	matrixMultiply(view,&rotZMat,view);
        }


        return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::matrixMultiply( 
            /* [out][in] */ D3dMatrix __RPC_FAR *result,
          /* [in] */ D3dMatrix __RPC_FAR *a,
          /* [in] */ D3dMatrix __RPC_FAR *b)
{

  D3dMatrix ret;

  ZeroMemory(&ret,sizeof(D3dMatrix));
  ret.rc11 = b->rc11 * a->rc11 + b->rc21 * a->rc12 + b->rc31 * a->rc13 + b->rc41 * a->rc14;
  ret.rc12 = b->rc12 * a->rc11 + b->rc22 * a->rc12 + b->rc32 * a->rc13 + b->rc42 * a->rc14;
  ret.rc13 = b->rc13 * a->rc11 + b->rc23 * a->rc12 + b->rc33 * a->rc13 + b->rc43 * a->rc14;
  ret.rc14 = b->rc14 * a->rc11 + b->rc24 * a->rc12 + b->rc34 * a->rc13 + b->rc44 * a->rc14;
  ret.rc21 = b->rc11 * a->rc21 + b->rc21 * a->rc22 + b->rc31 * a->rc23 + b->rc41 * a->rc24;
  ret.rc22 = b->rc12 * a->rc21 + b->rc22 * a->rc22 + b->rc32 * a->rc23 + b->rc42 * a->rc24;
  ret.rc23 = b->rc13 * a->rc21 + b->rc23 * a->rc22 + b->rc33 * a->rc23 + b->rc43 * a->rc24;
  ret.rc24 = b->rc14 * a->rc21 + b->rc24 * a->rc22 + b->rc34 * a->rc23 + b->rc44 * a->rc24;
  ret.rc31 = b->rc11 * a->rc31 + b->rc21 * a->rc32 + b->rc31 * a->rc33 + b->rc41 * a->rc34;
  ret.rc32 = b->rc12 * a->rc31 + b->rc22 * a->rc32 + b->rc32 * a->rc33 + b->rc42 * a->rc34;
  ret.rc33 = b->rc13 * a->rc31 + b->rc23 * a->rc32 + b->rc33 * a->rc33 + b->rc43 * a->rc34;
  ret.rc34 = b->rc14 * a->rc31 + b->rc24 * a->rc32 + b->rc34 * a->rc33 + b->rc44 * a->rc34;
  ret.rc41 = b->rc11 * a->rc41 + b->rc21 * a->rc42 + b->rc31 * a->rc43 + b->rc41 * a->rc44;
  ret.rc42 = b->rc12 * a->rc41 + b->rc22 * a->rc42 + b->rc32 * a->rc43 + b->rc42 * a->rc44;
  ret.rc43 = b->rc13 * a->rc41 + b->rc23 * a->rc42 + b->rc33 * a->rc43 + b->rc43 * a->rc44;
  ret.rc44 = b->rc14 * a->rc41 + b->rc24 * a->rc42 + b->rc34 * a->rc43 + b->rc44 * a->rc44;
  memcpy(result,&ret,sizeof(D3dMatrix));
        
  return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::projectionMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float near_plane,
            /* [in] */ float far_plane,
            /* [in] */ float fov)
{
    float c,s,Q;

        
    
    c =(float) cos(fov * 0.5);
    s = (float)sin(fov * 0.5);
    
    if (far_plane==0) return E_INVALIDARG;
    Q = s / (1 - near_plane / far_plane);

    ZeroMemory(mDest,sizeof(D3dMatrix));
    
    mDest->rc11 = c;
    mDest->rc22 = c;
    mDest->rc33 = Q;
    mDest->rc43 = -Q * near_plane;
    mDest->rc34 = s;

    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::copyMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mSrc)
{
    memcpy(mDest,mSrc,sizeof(D3dMatrix));
    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::identityMatrix( 
          /* [out][in] */ D3dMatrix __RPC_FAR *mDest)
{
    ZeroMemory (mDest,sizeof(D3dMatrix));
    mDest->rc11=1;
    mDest->rc22=1;
    mDest->rc33=1;
    mDest->rc44=1;

    return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::zeroMatrix( 
        	/* [out][in] */ D3dMatrix __RPC_FAR *mDest)
{
    ZeroMemory (mDest,sizeof(D3dMatrix));
    return S_OK;

}


STDMETHODIMP C_dxj_DirectX7Object::directMusicLoaderCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
    

    IDirectMusicLoader *pLoader=NULL;    


    hr =CoCreateInstance(
            CLSID_DirectMusicLoader, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicLoader,
            (void**)&pLoader);



    if (FAILED(hr))  return E_NOINTERFACE;
    
    if (!pLoader) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicLoader,pLoader,ret);

    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::directMusicComposerCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret)
{
    

    IDirectMusicComposer *pComp=NULL;    
    if (FAILED(CoCreateInstance(
            CLSID_DirectMusicComposer, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicComposer,
            (void**)&pComp        )))   {
         return E_NOINTERFACE;
    }
    if (!pComp) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicComposer,pComp,ret);
    return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::directMusicPerformanceCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret)
{

        

    IDirectMusicPerformance *pPerf=NULL;    
    if (FAILED(CoCreateInstance(
            CLSID_DirectMusicPerformance, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicPerformance,
            (void**)&pPerf        )))   {
         return E_NOINTERFACE;
    }
    if (!pPerf) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicPerformance,pPerf,ret);
    return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::getWindowRect( 
            /* [in] */ long hwnd,
            /* [out][in] */ Rect __RPC_FAR *r) 
{
    BOOL b=GetWindowRect((HWND)hwnd,(LPRECT)r);
    if (!b) return E_FAIL;
    return S_OK;
}
        



STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
            /* [in] */ I_dxj_DirectXEvent __RPC_FAR *event,
            /* [retval][out] */ long __RPC_FAR *h) 
{

    HRESULT	  hr;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

    HANDLE hEvent=NULL;	
    EVENTTHREADINFO *pNewEvent=NULL;
    EVENTTHREADINFO *pTemp=NULL;
    if (!event) return E_INVALIDARG;
    if (!h) return E_INVALIDARG;

    pNewEvent=(EVENTTHREADINFO*)malloc(sizeof(EVENTTHREADINFO));
    if (!pNewEvent) return E_OUTOFMEMORY;
    pNewEvent->pNext=NULL;
    pNewEvent->fEnd=FALSE;	
    pNewEvent->pCallback=event;
    pNewEvent->pStream=NULL;
    pNewEvent->threadID=0;

    event->AddRef();



    pNewEvent->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (!pNewEvent->hEvent){
        free(pNewEvent);
        event->Release();
        return E_FAIL;
    }

    //pNewEvent->hEndEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    
    hr=event->QueryInterface(IID_IUnknown,(void**)&pUnk);
    if FAILED(hr) {
      	free(pNewEvent);
      	event->Release();
      	return E_FAIL;
    }

    hr=CoMarshalInterThreadInterfaceInStream(IID_IUnknown,pUnk,&pStm);
    if (pUnk) pUnk->Release();
    if FAILED(hr) {  			
      	free(pNewEvent);
      	event->Release();			
      	return E_FAIL;
    }

    pNewEvent->pStream=pStm;

    pNewEvent->hThread=CreateThread(NULL,0,ThreadFunc,(unsigned long*)pNewEvent,CREATE_SUSPENDED ,&pNewEvent->threadID);
    if (!pNewEvent->threadID) {
        	CloseHandle(pNewEvent->hEvent);
        	free(pNewEvent);
        	event->Release();
        	return E_FAIL;
    }


    if (!m_pEventList){
        m_pEventList=pNewEvent;
    }
    else{
        pTemp=m_pEventList;
        m_pEventList=pNewEvent;	
        pNewEvent->pNext=pTemp;
    }


    ResumeThread(pNewEvent->hThread);
        

*h=(long)PtrToLong(pNewEvent->hEvent); //bugbug SUNDOWN -
    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
            /* [in] */ long eventId)  
{
    SetEvent((HANDLE)eventId);
    return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
            /* [in] */ long eventId)  
{
    //find the info on the stack
    if (!m_pEventList) return E_INVALIDARG;

    EVENTTHREADINFO *pTemp=NULL;
    EVENTTHREADINFO *pLast=NULL;

    //rely on lazy evaluation
    for (pTemp=m_pEventList; ((pTemp)&&(pTemp->hEvent!=(HANDLE)eventId));pLast=pTemp,pTemp=pTemp->pNext);
    if (!pTemp) return E_INVALIDARG;

    //remove it from our Link List
    if (!pLast) {
        m_pEventList=pTemp->pNext;		
    }
    else {
        pLast->pNext=pTemp->pNext;
    }

    //indicate that we want to kill the thread
    pTemp->fEnd=TRUE;

    //Fire the event in case we are waiting	
    if (pTemp->hEvent) SetEvent(pTemp->hEvent);

    //Wait for it to finish out
    if (pTemp->hThread) WaitForSingleObject(pTemp->hThread,1000);

    //wait for the end event to signal
    //if (pTemp->hEndEvent) WaitForSingleObject(pTemp->hEndEvent,1000);

    //desctroy the event
    if (pTemp->hEvent) CloseHandle(pTemp->hEvent);
    //if (pTemp->hEndEvent) CloseHandle (pTemp->hEndEvent);
    
    if (pTemp->pCallback) pTemp->pCallback->Release();
    
    //thread is gone..
    
    //free the memory
    free(pTemp);

    return S_OK;
}

DWORD WINAPI ThreadFunc(LPVOID param){
    HRESULT hr;
    IUnknown *pUnk=NULL;
    EVENTTHREADINFO *pCntrl=(EVENTTHREADINFO *)param;
    I_dxj_DirectXEvent	*pVBCallback=NULL;
        

    OleInitialize(NULL);


    LCID LOCAL_SYSTEM_DEFAULT=GetSystemDefaultLCID();


    //note pstrm is released even on failure
    hr=CoGetInterfaceAndReleaseStream(pCntrl->pStream,IID_IUnknown,(void**)&pUnk);
    pCntrl->pCallback=NULL;	//since released to 0

    if FAILED(hr) return -1;
    if (!pUnk) return -1;
    

    
    hr=pUnk->QueryInterface(IID_I_dxj_DirectXEvent,(void**)&pVBCallback);
    pUnk->Release();

    if FAILED(hr) return -1;  

    while (pCntrl->fEnd==FALSE) 
    {
        WaitForSingleObject(pCntrl->hEvent,INFINITE);
      	if ((pVBCallback )&&(pCntrl->fEnd==FALSE))
    	{
     		pVBCallback->AddRef();
    		pVBCallback->DXCallback((long)PtrToLong(pCntrl->hEvent)); //bugbug SUNDOWN
      		pVBCallback->Release();
     	}
    }


    if (pVBCallback) pVBCallback->Release();

    OleUninitialize();

    //we need to syncronize the ending of the thread..
    //if (pCntrl->hEndEvent) SetEvent(pCntrl->hEndEvent);		
    
    return 0;
}


STDMETHODIMP C_dxj_DirectX7Object::createD3DVertex(float x, float y, float z, float nx, float ny, float nz, float tu, float tv,  D3dVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DVERTEX*)v)->x=x;
    ((D3DVERTEX*)v)->y=y;
    ((D3DVERTEX*)v)->z=z;
    ((D3DVERTEX*)v)->nx=nx;
    ((D3DVERTEX*)v)->ny=ny;
    ((D3DVERTEX*)v)->nz=nz;
    ((D3DVERTEX*)v)->tu=tu;
    ((D3DVERTEX*)v)->tv=tv;
    return S_OK;
}
STDMETHODIMP C_dxj_DirectX7Object::createD3DLVertex(float x, float y, float z, long color,  long specular,  float tu,  float tv,  D3dLVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DLVERTEX*)v)->x=x;
    ((D3DLVERTEX*)v)->y=y;
    ((D3DLVERTEX*)v)->z=z;
    ((D3DLVERTEX*)v)->color=color;
    ((D3DLVERTEX*)v)->specular=specular;
    ((D3DLVERTEX*)v)->dwReserved=0;
    ((D3DLVERTEX*)v)->tu=tu;
    ((D3DLVERTEX*)v)->tv=tv;
    return S_OK;
}
STDMETHODIMP C_dxj_DirectX7Object::createD3DTLVertex(float sx, float sy, float sz, float rhw, long color, long  specular, float tu, float tv,   D3dTLVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DTLVERTEX*)v)->sx=sx;
    ((D3DTLVERTEX*)v)->sy=sy;
    ((D3DTLVERTEX*)v)->sz=sz;
    ((D3DTLVERTEX*)v)->rhw=rhw;
    ((D3DTLVERTEX*)v)->color=color;
    ((D3DTLVERTEX*)v)->specular=specular;		
    ((D3DTLVERTEX*)v)->tu=tu;
    ((D3DTLVERTEX*)v)->tv=tv;
    return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createNewGuid(BSTR *ret)
{
	HRESULT hr;
  	GUID g=GUID_NULL;
  	if (!ret) return E_INVALIDARG;

  	hr=::CoCreateGuid(&g);
	if FAILED(hr) return hr;
  	*ret=GUIDtoBSTR(&g);
  	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dsoundcaptureobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcaptureobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

CONSTRUCTOR(_dxj_DirectSoundCapture, {});
DESTRUCTOR(_dxj_DirectSoundCapture, {});
GETSET_OBJECT(_dxj_DirectSoundCapture);

   

STDMETHODIMP C_dxj_DirectSoundCaptureObject::createCaptureBuffer(
	DSCBufferDesc *desc,I_dxj_DirectSoundCaptureBuffer **retval)
{
    
	HRESULT hr = DD_OK;
	IDirectSoundCaptureBuffer *lpBuffer=NULL;
	DSCBUFFERDESC *realDesc=(DSCBUFFERDESC*)desc;


	realDesc->dwSize=sizeof(DSCBUFFERDESC);	
	desc->pFormat=(long)PtrToLong(&(desc->fxFormat));	//bugbug SUNDOWN

    hr=m__dxj_DirectSoundCapture->CreateCaptureBuffer(realDesc,&lpBuffer,NULL);	
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectSoundCaptureBuffer, lpBuffer, retval);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundCaptureObject::getCaps(DSCCaps *caps){
	((DSCCAPS*)caps)->dwSize=sizeof(DSCCAPS);
	return m__dxj_DirectSoundCapture->GetCaps((DSCCAPS*)caps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\dxglob7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dxglob7obj.h
//
//--------------------------------------------------------------------------


#include "resource.h"       // main symbols


typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DDCREATECLIPPER)( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DDENUMERATE)(LPDDENUMCALLBACK, LPVOID);
typedef HRESULT (__stdcall *DDENUMERATEEX)(LPDDENUMCALLBACKEX, LPVOID, DWORD);
typedef HRESULT (__stdcall *DIRECT3DRMCREATE)(LPDIRECT3DRM *lpCreate);
typedef HRESULT (__stdcall *DSOUNDCREATE)(GUID FAR * lpGUID, LPDIRECTSOUND * ppDS, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DSOUNDCAPTURECREATE)(GUID FAR * lpGUID, LPDIRECTSOUNDCAPTURE * ppDS, IUnknown FAR *pUnkOuter );
typedef HRESULT (CALLBACK *DSOUNDENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
typedef HRESULT (CALLBACK *DSOUNDCAPTUREENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
typedef HRESULT (__stdcall *DIRECTPLAYCREATE)( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
typedef HRESULT (__stdcall *DIRECTPLAYLOBBYCREATE)(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
typedef HRESULT (__stdcall *DDRAWCREATEEX)(  GUID FAR * rGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );


typedef struct tag_EVENTTHREADINFO {
	HANDLE hEvent;
	struct tag_EVENTTHREADINFO *pNext;
	IStream *pStream;
	I_dxj_DirectXEvent *pCallback;
	DWORD threadID;
	HANDLE hThread;
	BOOL	fEnd;
	HANDLE  hEndEvent;
} EVENTTHREADINFO;


class C_dxj_DirectX7Object :
	public I_dxj_DirectX7,
	public CComCoClass<C_dxj_DirectX7Object, &CLSID__dxj_DirectX7>, public CComObjectRoot
{
public:
	C_dxj_DirectX7Object() ;
	virtual ~C_dxj_DirectX7Object() ;

BEGIN_COM_MAP(C_dxj_DirectX7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectX7)
END_COM_MAP()

	DECLARE_REGISTRY(CLSID__dxj_DirectX7,	"DIRECT.DirectX6.0",		"DIRECT.DirectX6.0",	IDS_DIRECTX6_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundResourceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectX7Object)


public:

        HRESULT STDMETHODCALLTYPE direct3dRMCreate( 
            /* [retval][out] */ I_dxj_Direct3dRM3 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directDrawCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *ret);        
			
        HRESULT STDMETHODCALLTYPE getDDEnum( 
            /* [retval][out] */ I_dxj_DirectDrawEnum __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directSoundCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectSound __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directSoundCaptureCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectSoundCapture __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getDSEnum( 
            /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDSCaptureEnum( 
            /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE directInputCreate( 
            /* [retval][out] */ I_dxj_DirectInput __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directPlayCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectPlay4 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directPlayLobbyCreate( 
            /* [retval][out] */ I_dxj_DirectPlayLobby3 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getDPEnum( 
            /* [retval][out] */ I_dxj_DPEnumServiceProviders __RPC_FAR *__RPC_FAR *retval);
        
        HRESULT STDMETHODCALLTYPE colorGetAlpha( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetBlue( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetGreen( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetRed( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b,
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE createColorRGBA( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b,
            /* [in] */ float a,
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE matrixFromQuaternion( 
            /* [out] */ D3dMatrix __RPC_FAR *matrix,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quat);
        
        HRESULT STDMETHODCALLTYPE quaternionRotation( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dVector __RPC_FAR *axis,
            /* [in] */ float theta);
        
        HRESULT STDMETHODCALLTYPE quaternionMultiply( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatA,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatB);
        
        HRESULT STDMETHODCALLTYPE quaternionSlerp( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatA,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatB,
            /* [in] */ float alpha);
        
        HRESULT STDMETHODCALLTYPE vectorAdd( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorCrossProduct( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorDotProduct( 
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE vectorModulus( 
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE vectorNormalize( 
            /* [out][in] */ D3dVector __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE vectorRandom( 
            /* [out][in] */ D3dVector __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE vectorReflect( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vRay,
            /* [in] */ D3dVector __RPC_FAR *vNormal);
        
        HRESULT STDMETHODCALLTYPE vectorRotate( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vAxis,
            /* [in] */ float theta);
        
        HRESULT STDMETHODCALLTYPE vectorScale( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ float factor);
        
        HRESULT STDMETHODCALLTYPE vectorSubtract( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorCopy( 
            /* [out][in] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vSrc);
        
        HRESULT STDMETHODCALLTYPE rotateXMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE rotateYMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE rotateZMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE viewMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dVector __RPC_FAR *vFrom,
            /* [in] */ D3dVector __RPC_FAR *vTo,
            /* [in] */ D3dVector __RPC_FAR *vUp,
            /* [in] */ float roll);
        
        HRESULT STDMETHODCALLTYPE matrixMultiply( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mA,
            /* [in] */ D3dMatrix __RPC_FAR *mB);
        
        HRESULT STDMETHODCALLTYPE projectionMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float nearPlane,
            /* [in] */ float farplane,
            /* [in] */ float fov);
        
        HRESULT STDMETHODCALLTYPE copyMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mSrc);
        
        HRESULT STDMETHODCALLTYPE identityMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest);
        
        HRESULT STDMETHODCALLTYPE zeroMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest);
        
        
        HRESULT STDMETHODCALLTYPE tickCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE systemBpp( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
      
        HRESULT STDMETHODCALLTYPE directMusicLoaderCreate( 
            /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directMusicComposerCreate( 
            /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directMusicPerformanceCreate( 
            /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret);
			
    
        HRESULT STDMETHODCALLTYPE getWindowRect( 
            /* [in] */ long hwnd,
            /* [out][in] */ Rect __RPC_FAR *r) ;
        
        HRESULT STDMETHODCALLTYPE createEvent( 
            /* [in] */ I_dxj_DirectXEvent __RPC_FAR *event,
            /* [retval][out] */ long __RPC_FAR *h) ;
        
        HRESULT STDMETHODCALLTYPE setEvent( 
            /* [in] */ long eventId) ;
        
        HRESULT STDMETHODCALLTYPE destroyEvent( 
            /* [in] */ long eventId) ;


		HRESULT STDMETHODCALLTYPE createD3DVertex(float x, float y, float z, float nx, float ny, float nz, float tu, float tv,  D3dVertex *v);
		HRESULT STDMETHODCALLTYPE createD3DLVertex(float x, float y, float z, long color,  long specular,  float tu,  float tv,  D3dLVertex *v);
		HRESULT STDMETHODCALLTYPE createD3DTLVertex(float sx, float sy, float sz, float rhw, long color, long  specular, float tu, float tv,   D3dTLVertex *v);

        HRESULT STDMETHODCALLTYPE directDraw4Create( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectDraw4 __RPC_FAR *__RPC_FAR *ret);        

		HRESULT STDMETHODCALLTYPE createNewGuid(BSTR *ret);

        void LoadDDRAW();
        void LoadDPLAY();
        void LoadDSOUND();
        void LoadDINPUT();
        void LoadD3DRM();

private:

	DDRAWCREATE				m_pDirectDrawCreate;
	DDRAWCREATEEX	    	m_pDirectDrawCreateEx;
	DDCREATECLIPPER			m_pDirectDrawCreateClipper;
	DSOUNDCREATE			m_pDirectSoundCreate;
	DSOUNDCAPTURECREATE		m_pDirectSoundCaptureCreate;
	DSOUNDENUMERATE			m_pDirectSoundEnumerate;
	DSOUNDCAPTUREENUMERATE	m_pDirectSoundCaptureEnumerate;
	DIRECTPLAYCREATE		m_pDirectPlayCreate;
	DIRECTPLAYENUMERATE		m_pDirectPlayEnumerate;
	DIRECTPLAYLOBBYCREATE	m_pDirectPlayLobbyCreate;
	DIRECT3DRMCREATE		m_pDirect3DRMCreate;
	DDENUMERATE				m_pDirectDrawEnumerate;
	DDENUMERATEEX			m_pDirectDrawEnumerateEx;
	EVENTTHREADINFO			*m_pEventList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\guids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600


#define INITGUID 1
#include "objbase.h"
#include "dmusici.h"
#include "dsound.h"
#include "dplay.h"
#include "dplobby.h"
#include "ddraw.h"
#include "d3drm.h"
#include "d3drmwin.h"
#include "d3d.h"
#include "dinput.h"
#include "rmxfguid.h"
//#include "rmxftmpl.h"
#include <dxfile.h>


int pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\frmsave.h ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.h
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************

typedef struct _Header {
    WORD major;
    WORD minor;
    DWORD flags;
} Header;

typedef struct _ColorRGBA {
    float r;
    float g;
    float b;
    float a;
} ColorRGBA;

typedef struct _ColorRGB {
    float r;
    float g;
    float b;
} ColorRGB;

typedef struct _IndexedColor {
    DWORD index;
    ColorRGBA color;
} IndexedColor;

typedef struct _VertexColors {
    DWORD cVertices;
    IndexedColor vertexColors[1];
} VertexColors;

typedef struct _Boolean2d {
    BOOL u;
    BOOL v;
} Boolean2d;

typedef struct _FaceWraps {
    DWORD cFaces;
    Boolean2d faceWraps[1];
} FaceWraps;

typedef struct _Coords2d {
    float u;
    float v;
} Coords2d;

typedef struct _TextureCoords {
    DWORD cVertices;
    Coords2d textureCoords[1];
} TextureCoords;

typedef struct _FaceMaterials {
    DWORD cMaterials;
    DWORD cFaceIndexes;
    DWORD faceIndexes[1];
} FaceMaterials;

typedef struct _BaseMaterial {
    ColorRGBA faceColor;
    float power;
    ColorRGB specularColor;
    ColorRGB emissiveColor;
} BaseMaterial;

typedef struct _FaceMaterial {
    D3DCOLOR faceColor;
    LPDIRECT3DRMMATERIAL pMaterial;
    LPDIRECT3DRMTEXTURE pTexture;
    _FaceMaterial *pNext;
} FaceMaterial;

typedef void (__stdcall *CREATEXFILE)( IDirectXFile **);

class FaceMaterialList
{
    DWORD cElements;
    FaceMaterial *pFirst;	

public:
    FaceMaterialList();
    ~FaceMaterialList();

    DWORD Find(D3DCOLOR faceColor,
               LPDIRECT3DRMMATERIAL pMaterial,
               LPDIRECT3DRMTEXTURE pTexture);

    DWORD Count() { return cElements; }
    FaceMaterial *First() { return pFirst; }
};

class NameEntry {
public:
    LPSTR pName;
    NameEntry *pNext;
};

class NameList
{
    NameEntry *pFirst;
    NameEntry **ppLast;
public:
    NameList();
    ~NameList();
    void Add(LPSTR pName);
};

class Saver {
public:
    Saver();
    ~Saver();

    HRESULT Init(LPCSTR filename,
                 D3DRMXOFFORMAT d3dFormat,
                 D3DRMSAVEOPTIONS d3dSaveFlags);

    HRESULT SaveHeaderObject();
    
    HRESULT SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                      LPDIRECT3DRMFRAME3 pRefFrame = NULL,
                      LPDIRECTXFILEDATA  pRefFrameObj = NULL);
private:	
    LPDIRECTXFILE pXFile;
    LPDIRECTXFILESAVEOBJECT pSave;
    D3DRMXOFFORMAT d3dFormat;
    D3DRMSAVEOPTIONS d3dSaveFlags;
    NameList lNames;

    HRESULT SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMFRAME3 pFrame,
                               LPDIRECT3DRMFRAME3 pRefFrame);
    
    HRESULT SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                            LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMeshObject(DWORD cVertices,
                             DWORD cFaces,
                             DWORD dwFaceData,
                             LPDWORD pdwFaceData,
                             LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                             LPDIRECTXFILEDATA *ppMeshObj);
    
    HRESULT CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                DWORD cNormals,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                     DWORD cVertices,
                                     LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                 FaceMaterial *pMat);
    
    HRESULT CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                      DWORD cVertices,
                                      LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Direct.rc
//
#define IDS_DSOUND_DESC                 1
#define IDS_GENERIC_DESC                1
#define IDS_DIRECTX6_DESC               2
#define IDS_DDRAW_DESC                  3
#define IDS_DIRECTX7_DESC               3
#define IDS_DDCLIPPER_DESC              5
#define IDS_D3DRMVIEWPORT_DESC          7
#define IDS_D3DRMDEVICE_DESC            9
#define IDS_D3DRMFRAME_DESC             11
#define IDS_D3DRMMESH_DESC              13
#define IDS_D3DRMMESHBUILDER_DESC       15
#define IDS_D3DRMFACE_DESC              17
#define IDS_D3DRMLIGHT_DESC             19
#define IDS_D3DRMTEXTURE_DESC           21
#define IDS_D3DRMWRAP_DESC              23
#define IDS_D3DRMMATERIAL_DESC          25
#define IDS_D3DRMANIMATION_DESC         27
#define IDS_D3DRMANIMATIONSET_DESC      29
#define IDS_D3DRMUSERVISUAL_DESC        31
#define IDS_D3DRMSHADOW_DESC            33
#define IDS_D3D_DESC                    35
#define IDS_D3DTEXTURE_DESC             37
#define IDS_D3DLIGHT_DESC               39
#define IDS_D3DMATERIAL_DESC            41
#define IDS_D3DEXECUTEBUFFER_DESC       43
#define IDS_DBITMAP_DESC                45
#define IDS_D3DVIEWPORT_DESC            47
#define IDS_D3DRM_DESC                  49
#define IDS_D3DRMOBJECT_DESC            51
#define IDS_D3DRMVISUAL_DESC            53
#define IDS_D3DRMWINDEVICE_DESC         55
#define IDS_DDSURFACE_DESC              57
#define IDS_DDPALETTE_DESC              59
#define IDS_DPLAY_DESC                  61
#define IDS_DSOUNDBUFFER_DESC           63
#define IDS_DMSTEST_DESC                65
#define IDS_D3DRMDEVICEARRAY_DESC       67
#define IDS_D3DRMVIEWPORTARRAY_DESC     69
#define IDS_D3DRMFRAMEARRAY_DESC        71
#define IDS_D3DRMVISUALARRAY_DESC       73
#define IDS_CHOOSECOLOR_DESC            75
#define IDS_D3DRMLIGHTARRAY_DESC        77
#define IDS_D3DRMPICKEDARRAY_DESC       79
#define IDS_D3DRMFACEARRAY_DESC         81
#define IDS_DIRECT42_DESC               83
#define IDS_D3DDEVICE_DESC              83
#define IDS_DIRECTINPUTDEVICE           83
#define IDS_DIRECT43_DESC               85
#define IDS_DIRECT44_DESC               87
#define IDS_DSOUNDRESOURCE_DESC         87
#define IDS_JOYSTICK                    87
#define IDS_DIRECT45_DESC               89
#define IDS_DPLAY2_DESC                 89
#define IDS_DIRECT46_DESC               91
#define IDS_DPLAYLOBBY_DESC             91
#define IDS_DIRECT47_DESC               93
#define IDS_DIRECT48_DESC               95
#define IDS_DIRECT49_DESC               97
#define IDS_DIRECT50_DESC               99
#define IDS_DIRECT51_DESC               101
#define IDS_D3DRMARRAY_DESC             101
#define IDS_DIRECT52_DESC               103
#define IDS_DIRECT53_DESC               105
#define IDS_DIRECT54_DESC               107
#define IDS_DIRECT55_DESC               109
#define IDS_DIRECT56_DESC               111
#define IDS_DIRECT57_DESC               113
#define IDS_DIRECT58_DESC               115
#define IDS_DIRECT59_DESC               117
#define IDS_DIRECT60_DESC               119
#define IDS_DSOUND3DBUFFER_DESC         120
#define IDS_DSOUND3DLISTENER_DESC       121
#define IDS_DDVIDEOPORT_DESC            122

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        209
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

RegisterBin: $(TARGET)
!ifndef NTDEBUG
!MESSAGE Registering $(TARGETNAME)
	regsvr32 -s -u $(?F)
	regsvr32 -s $?
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\sources.inc ===
!IF 0


Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Andrew Kertesz (Andrewke) 20-DEC-98

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF


MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dx7vb
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=direct.def
!IF 0
        DLLENTRY=_DllMainCRTStartup
!ENDIF

DLLENTRY=DllMain

USE_MAPSYM=1
USE_CRTDLL=1
USE_STATIC_ATL=1
DX7=1
DX6=1


PLAT_DIR           = daytona
# ALT_PROJECT_TARGET = .
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
DEBUG=1
!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\kernel32.lib		\
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib		\
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib                \
           $(BASEDIR)\public\sdk\lib\*\gdi32.lib                \
           $(BASEDIR)\public\sdk\lib\*\winmm.lib                \
           $(BASEDIR)\public\sdk\lib\*\dinput.lib               \
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\USER32.lib              \
           $(BASEDIR)\public\sdk\lib\*\OLEAUT32.lib            
           

PASS0_HEADERDIR=$O

INCLUDES=$(DXROOT)\inc; \
	 ..\inc; \
	 $(SDK_INC_PATH); \
	 $(PASS0_HEADERDIR);




SOURCES=   \
        ..\direct.idl              \
	..\directvb.idl            \
        ..\direct.cpp              \
        ..\dxGlob7Obj.cpp          \
        ..\StdAfx.cpp              \
        ..\wave.cpp                \
        \
        ..\dmLoaderObj.cpp         \
        ..\dmSegmentObj.cpp        \
        ..\dmBandObj.cpp           \
        ..\dmChordMapObj.cpp       \
        ..\dmCollectionObj.cpp     \
        ..\dmPerformanceObj.cpp    \
        ..\dmSegmentStateObj.cpp   \
        ..\dmStyleObj.cpp          \
        ..\dmComposerObj.cpp       \
        \
        ..\d3d7Obj.cpp \
        ..\d3ddevice7obj.cpp \
        ..\D3DEnumDevices7Obj.cpp \
        ..\D3DEnumPixelFormats7Obj.cpp \
        ..\d3dVertexBuffer7Obj.cpp \
        \
        ..\d3drm3Obj.cpp \
        ..\d3drmAnimation2Obj.cpp \
        ..\d3drmAnimationSet2Obj.cpp \
        ..\d3drmObjectArrayObj.cpp \
        ..\d3drmClippedVisualObj.cpp \
        ..\d3drmDevice3Obj.cpp \
        ..\d3drmDeviceArrayObj.cpp \
        ..\d3drmFace2Obj.cpp \
        ..\d3drmFaceArrayObj.cpp \
        ..\d3drmFrame3Obj.cpp \
        ..\d3drmFrameArrayObj.cpp \
        ..\d3drmLightArrayObj.cpp \
        ..\d3drmLightObj.cpp \
        ..\d3drmMaterial2Obj.cpp \
        ..\d3drmMeshBuilder3Obj.cpp \
        ..\d3drmMeshObj.cpp \
        ..\d3drmPicked2ArrayObj.cpp \
        ..\d3drmPickedArrayObj.cpp \
        ..\d3drmProgressiveMeshObj.cpp \
        ..\d3drmShadow2Obj.cpp \
        ..\d3drmTexture3Obj.cpp \
        ..\d3drmViewport2Obj.cpp \
        ..\d3drmViewportArrayObj.cpp \
        ..\d3drmVisualArrayObj.cpp \
        ..\d3drmWrapObj.cpp \
        ..\d3drmMeshInterObj.cpp \
        ..\d3drmViewportInterObj.cpp \
        ..\d3drmMaterialInterObj.cpp \
        ..\d3drmTextureInterObj.cpp \
        ..\d3drmLightInterObj.cpp \
        ..\d3drmFrameInterObj.cpp \
	..\d3drmAnimationArrayObj.cpp \
	..\frmsave.cpp \
        \
        ..\ddClipperObj.cpp \
        ..\ddColorControlObj.cpp \
        ..\DDEnumModesObj.cpp \
        ..\DDEnumObj.cpp \
        ..\DDEnumSurfacesObj.cpp \
        ..\ddGammaControlObj.cpp \
        ..\ddPaletteObj.cpp \
        ..\dDraw7Obj.cpp \
        ..\ddSurface7Obj.cpp \
        ..\dDraw4Obj.cpp \
        ..\ddSurface4Obj.cpp \
        ..\ddIdentifierObj.cpp \
        \
        ..\DIEnumDeviceObjectsObj.cpp \
        ..\DIEnumDevicesObj.cpp \
        ..\dInput1Obj.cpp \
        ..\dInputDeviceObj.cpp \
        ..\dInputEffectObj.cpp \
        ..\dIDevObjInstObj.cpp \
        ..\dIDevInstObj.cpp \
	..\dIEnumEffectsObj.cpp \
        \
        ..\DPAddressObj.cpp \
        ..\DPEnumConnectionsObj.cpp \
        ..\DPEnumLocalApplicationsObj.cpp \
        ..\DPEnumObj.cpp \
        ..\DPEnumPlayersObj.cpp \
        ..\DPEnumSessionsObj.cpp \
        ..\Dplay4obj.cpp \
        ..\Dplaylobby3obj.cpp \
        ..\DPLConnectionObj.cpp \
        ..\DPMsgObj.cpp    \
        ..\DPSessDataObj.cpp       \
        \
        ..\DSEnumObj.cpp \
        ..\dSound3DBuffer.cpp \
        ..\dSound3DListener.cpp \
        ..\dSoundBufferObj.cpp \
        ..\dSoundCaptureBufferObj.cpp \
        ..\dSoundCaptureObj.cpp \
        ..\dSoundObj.cpp      \
        \
        ..\dxvb.rc \
        \
        ..\guids.cpp
        

!if "$(__PRODUCT)" == "DX7"
!if  "$(ALPHA)"=="1" || "$(WIN95)"=="1"
NTTARGETFILE1=RegisterBin
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\frmsave.cpp ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.cpp
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************


#include <d3drm.h>
#include <dxfile.h>
#include <rmxftmpl.h>
#include <rmxfguid.h>
#include "frmsave.h"

extern HINSTANCE g_hInstD3DXOFDLL;

#define MyD3DRMColorGetAlpha(color)  ((float)((color & 0xFF000000)>>24)/(float)255)
#define MyD3DRMColorGetRed(color)  ((float)((color & 0x00FF0000)>>16)/(float)255)
#define MyD3DRMColorGetGreen(color)  ((float)((color & 0x0000FF00)>>8)/(float)255)
#define MyD3DRMColorGetBlue(color)  ((float)((color & 0x000000FF))/(float)255)


HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags)
{
    Saver saver;
    saver.Init(filename, d3dFormat, d3dSaveFlags);
    saver.SaveHeaderObject();
    saver.SaveFrame(pFrame);
    return S_OK;
}

Saver::Saver()
{
	pXFile=NULL;
	pSave=NULL;
}

Saver::~Saver()
{
    if (pSave) pSave->Release();
    if (pXFile) pXFile->Release();
}

HRESULT Saver::Init(LPCSTR filename,
                    D3DRMXOFFORMAT d3dFormatArg,
                    D3DRMSAVEOPTIONS d3dSaveFlagsArg)
{
    HRESULT hr;
    d3dFormat = d3dFormatArg;
    d3dSaveFlags = d3dSaveFlagsArg;


    CREATEXFILE pCreateXFile=(CREATEXFILE)GetProcAddress( g_hInstD3DXOFDLL, "DirectXFileCreate" );	
    if (!pCreateXFile) return E_NOTIMPL;
		
	
    DXFILEFORMAT xFormat;

    if (d3dFormat == D3DRMXOF_BINARY)
        xFormat = DXFILEFORMAT_BINARY;
    else if (d3dFormat == D3DRMXOF_TEXT)
        xFormat = DXFILEFORMAT_TEXT;
    else
        xFormat = DXFILEFORMAT_COMPRESSED;

    //DirectXFileCreate(&pXFile);
    pCreateXFile(&pXFile);
    if (!pXFile) return E_FAIL;
    
    hr=pXFile->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES);
    if FAILED(hr) 
    {
	pXFile->Release();
	pXFile=NULL;
	return hr;
    }

    hr=pXFile->CreateSaveObject(filename, xFormat, &pSave);
    if FAILED(hr) 
    {
	pXFile->Release();
	pXFile=NULL;
	pSave=NULL;
	return hr;
    }

    return S_OK;
}

HRESULT Saver::SaveHeaderObject()
{
    LPDIRECTXFILEDATA pHeader=NULL;
    Header data;
    HRESULT hr;

    data.major = 1;
    data.minor = 0;
    data.flags = (d3dFormat == D3DRMXOF_TEXT)? 1 : 0;

    if (!pSave) return E_FAIL;

    hr=pSave->CreateDataObject(TID_DXFILEHeader,
                            NULL,
                            NULL,
                            sizeof(Header),
                            &data,
                            &pHeader);
    if FAILED(hr) return hr;
    if (!pHeader) return hr;	

    hr=pSave->SaveData(pHeader);
    pHeader->Release();
    return hr;
}

HRESULT Saver::SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                         LPDIRECT3DRMFRAME3 pRefFrame,
                         LPDIRECTXFILEDATA pRefFrameObj)
{
    DWORD i;
    HRESULT hr;
    LPDIRECTXFILEDATA pFrameObj=NULL;

    if (!pSave) return E_FAIL;
    if (!pFrame) return E_FAIL;

    hr=pSave->CreateDataObject(TID_D3DRMFrame,
                            NULL, 
                            NULL,
                            0,
                            NULL,
                            &pFrameObj);
    if FAILED(hr) return hr;
    if (!pFrameObj) return E_FAIL;

    hr=SaveFrameTransform(pFrameObj, pFrame, pRefFrame);
    if FAILED(hr) {
	pFrameObj->Release();
	return hr;  
    }    

    // Enumerate visuals.

    DWORD cVisuals=0;

    hr=pFrame->GetVisuals(&cVisuals, NULL);
    if FAILED(hr) {
	pFrameObj->Release();
	return hr;  
    }    
	

    if (cVisuals)
    {
        LPUNKNOWN *ppUnk = new LPUNKNOWN[cVisuals];

        hr=pFrame->GetVisuals(&cVisuals, ppUnk);
	if SUCCEEDED(hr)
	{
            for (i = 0; i < cVisuals; i++)
            {
              LPDIRECT3DRMFRAME3 pChildFrame;
	      if (ppUnk[i]) 
              {
                 hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);

                 if (SUCCEEDED(hr))
                 {
                   SaveFrame(pChildFrame, pFrame, pFrameObj);
                   pChildFrame->Release();
                 }
                 else
                 {
                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder;
                   hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID *)&pMeshBuilder);
     
                   if (SUCCEEDED(hr))
                   {
                       SaveMeshBuilder(pFrameObj, pMeshBuilder);
                       pMeshBuilder->Release();
                   }
	        }         
                ppUnk[i]->Release();
             }
          }
	
          delete[] ppUnk;
       }
    }  //cVisuals

    // Enumerate child frames.

    LPDIRECT3DRMFRAMEARRAY pFrameArray=NULL;

    hr=pFrame->GetChildren(&pFrameArray);
    if SUCCEEDED(hr) 
    {
       for (i = 0; i < pFrameArray->GetSize(); i++)
       {
           LPDIRECT3DRMFRAME pTmpFrame;
           LPDIRECT3DRMFRAME3 pChildFrame;
           pFrameArray->GetElement(i, &pTmpFrame);
           pTmpFrame->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);
           pTmpFrame->Release();
           SaveFrame(pChildFrame, pFrame, pFrameObj);
           pChildFrame->Release();
       }

       pFrameArray->Release();

       // Add frame object to the saved list.

       if (pRefFrameObj)
           pRefFrameObj->AddDataObject(pFrameObj);
       else
           pSave->SaveData(pFrameObj);

       pFrameObj->Release();
    }

    return hr;
}

HRESULT Saver::SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                                  LPDIRECT3DRMFRAME3 pFrame,
                                  LPDIRECT3DRMFRAME3 pRefFrame)
{
    LPDIRECTXFILEDATA pFrameTransformObj=NULL;
    D3DRMMATRIX4D rmMatrix;
    HRESULT hr;

    if (!pFrame) return E_INVALIDARG;

    pFrame->GetTransform(pRefFrame, rmMatrix);

    hr=pSave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
                            NULL,
                            NULL,
                            sizeof(D3DRMMATRIX4D),
                            rmMatrix,
                            &pFrameTransformObj);
    if FAILED(hr) return hr;

    hr=pFrameObj->AddDataObject(pFrameTransformObj);
    pFrameTransformObj->Release();
    return hr;
}

HRESULT Saver::SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    LPDIRECTXFILEDATA pMeshObj;
    DWORD cVertices, cNormals, cFaces, dwFaceData, *pdwFaceData;
    LPDIRECT3DRMFACEARRAY pFaceArray = NULL;
    HRESULT hr;

    if (!pMeshBuilder) return E_INVALIDARG;
    //pFrameObj can be null

    hr=pMeshBuilder->GetGeometry(&cVertices, NULL,
                              &cNormals, NULL,
                              &dwFaceData, NULL);
    if FAILED(hr) return hr;

    cFaces = pMeshBuilder->GetFaceCount();

    if (!cVertices || !cNormals || !dwFaceData || !cFaces)
        return S_OK;

    pdwFaceData = new DWORD[dwFaceData];
    if FAILED(pdwFaceData) return E_OUTOFMEMORY;

    hr=pMeshBuilder->GetGeometry(NULL, NULL,
                              NULL, NULL,
                              &dwFaceData, pdwFaceData);
    if FAILED(hr) return hr;

    hr=CreateMeshObject(cVertices, cFaces, dwFaceData, pdwFaceData,
                     pMeshBuilder, &pMeshObj);
    if FAILED(hr) return hr;

    D3DRMCOLORSOURCE clrSrc = pMeshBuilder->GetColorSource();

    if (clrSrc == D3DRMCOLOR_FROMVERTEX)
    {
        CreateVertexColorsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_MATERIALS)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateMaterialListObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_NORMALS)
    {
        CreateNormalsObject(pMeshObj,
                            cNormals, cFaces, dwFaceData, pdwFaceData,
                            pMeshBuilder);
    }
    

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURETOPOLOGY)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateTextureWrapsObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURECOORDINATES)
    {
        CreateTextureCoordsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (pFrameObj)
        pFrameObj->AddDataObject(pMeshObj);
    else
        pSave->SaveData(pMeshObj);

    pMeshObj->Release();
    delete[] pdwFaceData;
    if (pFaceArray)
        pFaceArray->Release();

    return S_OK;
}

HRESULT Saver::CreateMeshObject(DWORD cVertices,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                                LPDIRECTXFILEDATA *ppMeshObj)
{
    // mesh data is vertex_count + vertices + face_count + face_vertex_data;
    HRESULT hr;

    if (!pMeshBuilder) return E_INVALIDARG;
    if (!pSave) return E_INVALIDARG;

    DWORD cbSize, *data;
    cbSize = cVertices * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;
    data[0] = cVertices;
    LPD3DVECTOR pVertices = (LPD3DVECTOR)&data[1];
    pMeshBuilder->GetGeometry(&cVertices, pVertices,
                              NULL, NULL,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pVertices[cVertices];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            *pdwTmp++ = *pdwFaceData++;
            pdwFaceData++; // skip normal index.
        }
    }

    DWORD dwSize;
    pMeshBuilder->GetName(&dwSize, NULL);
    
    LPSTR szName = NULL;
    if (dwSize)
    {
        szName = new char[dwSize];
        pMeshBuilder->GetName(&dwSize, szName);
    }

    hr=pSave->CreateDataObject(TID_D3DRMMesh,
                            szName,
                            NULL,
                            cbSize,
                            data,
                            ppMeshObj);

    if (szName) lNames.Add(szName);
    delete[] data;
    return S_OK;
}

HRESULT Saver::CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                   DWORD cNormals,
                                   DWORD cFaces,
                                   DWORD dwFaceData,
                                   LPDWORD pdwFaceData,
                                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{                                
    // normals data is normal_count + normals + face_count + face_normal_data;
    HRESULT hr;

    if (!pMeshObj) return E_INVALIDARG;

    DWORD cbSize, *data;
    cbSize = cNormals * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data[0] = cNormals;

    LPD3DVECTOR pNormals = (LPD3DVECTOR)&data[1];

    hr=pMeshBuilder->GetGeometry(NULL, NULL,
                              &cNormals, pNormals,      
	                        NULL, NULL);
    if FAILED(hr) return hr;

    LPDWORD pdwTmp = (LPDWORD)&pNormals[cNormals];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            pdwFaceData++; // skip vertex index.
            *pdwTmp++ = *pdwFaceData++;
        }
    }

    LPDIRECTXFILEDATA pNormalsObj=NULL;

    hr=pSave->CreateDataObject(TID_D3DRMMeshNormals,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pNormalsObj);
    if FAILED(hr) return hr;

    pMeshObj->AddDataObject(pNormalsObj);
    pNormalsObj->Release();
    delete[] data;

    return S_OK;
}

HRESULT Saver::CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                        DWORD cVertices,
                                        LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    VertexColors *data;
    HRESULT hr;
    
    if (!pSave) return E_INVALIDARG;
    if (!pMeshBuilder) return E_INVALIDARG;

    cbSize = sizeof(DWORD) + cVertices * sizeof(IndexedColor);

    data = (VertexColors *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cVertices = cVertices;

    for (DWORD i = 0; i < cVertices; i++)
    {
        D3DCOLOR color = pMeshBuilder->GetVertexColor(i);
        data->vertexColors[i].index = i;
        data->vertexColors[i].color.r = MyD3DRMColorGetRed(color);
        data->vertexColors[i].color.g = MyD3DRMColorGetGreen(color);
        data->vertexColors[i].color.b = MyD3DRMColorGetBlue(color);
        data->vertexColors[i].color.a = MyD3DRMColorGetAlpha(color);
    }

    LPDIRECTXFILEDATA pVertexColorsObj=NULL;

    hr=pSave->CreateDataObject(TID_D3DRMMeshVertexColors,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pVertexColorsObj);
    if FAILED(hr) {
        delete[] data;                        
	return hr;
    }

    pMeshObj->AddDataObject(pVertexColorsObj);
    pVertexColorsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceMaterials *data;
    FaceMaterialList lMat;
    

    cFaces = pFaceArray->GetSize();
    cbSize = (2 + cFaces) * sizeof(DWORD);

    data = (FaceMaterials *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cFaceIndexes = cFaces;
    LPDWORD pdwIndex = data->faceIndexes;

    for (DWORD i = 0; i < cFaces; i++, pdwIndex++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);

        D3DCOLOR faceColor;
        LPDIRECT3DRMMATERIAL pMaterial;
        LPDIRECT3DRMTEXTURE pTexture;

        faceColor = pFace->GetColor();
        pFace->GetMaterial(&pMaterial);
        pFace->GetTexture(&pTexture);
        
        *pdwIndex = lMat.Find(faceColor, pMaterial, pTexture);

        pMaterial->Release();
        if (pTexture) pTexture->Release();
        pFace->Release();
    }

    data->cMaterials = lMat.Count();

    if (data->cMaterials == 1)
    {
        data->cFaceIndexes = 1;
        data->faceIndexes[0] = 0;
        cbSize = 3 * sizeof(DWORD);
    }

    LPDIRECTXFILEDATA pMatListObj;

    pSave->CreateDataObject(TID_D3DRMMeshMaterialList,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pMatListObj);

    FaceMaterial *pMat;
    for (pMat = lMat.First(); pMat; pMat = pMat->pNext)
    {
        CreateMaterialObject(pMatListObj,
                             pMat);
    }

    pMeshObj->AddDataObject(pMatListObj);
    pMatListObj->Release();
    delete[] data;
    
    return S_OK;
}

HRESULT Saver::CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                    FaceMaterial *pMat)
{
    BaseMaterial data;

    data.faceColor.r = MyD3DRMColorGetRed(pMat->faceColor);
    data.faceColor.g = MyD3DRMColorGetGreen(pMat->faceColor);
    data.faceColor.b = MyD3DRMColorGetBlue(pMat->faceColor);
    data.faceColor.a = MyD3DRMColorGetAlpha(pMat->faceColor);

    data.power = pMat->pMaterial->GetPower();

    pMat->pMaterial->GetSpecular(&data.specularColor.r,
                                 &data.specularColor.g,
                                 &data.specularColor.b);

    pMat->pMaterial->GetEmissive(&data.emissiveColor.r,
                                 &data.emissiveColor.g,
                                 &data.emissiveColor.b);

    LPDIRECTXFILEDATA pMaterialObj;

    pSave->CreateDataObject(TID_D3DRMMaterial,
                            NULL,
                            NULL,
                            sizeof(BaseMaterial),
                            &data,
                            &pMaterialObj);

    if (pMat->pTexture)
    {
        IDirectXFileData *pTextureObj;

        DWORD dwSize;
        pMat->pTexture->GetName(&dwSize, NULL);

        if (dwSize)
        {
            LPSTR szName = new char[dwSize];
            pMat->pTexture->GetName(&dwSize, szName);
    
            pSave->CreateDataObject(TID_D3DRMTextureFilename,
                                    NULL,
                                    NULL,
                                    sizeof(LPSTR),
                                    &szName,
                                    &pTextureObj);
    
            pMaterialObj->AddDataObject(pTextureObj);
            pTextureObj->Release();
            lNames.Add(szName);
        }
    }

    pMatListObj->AddDataObject(pMaterialObj);
    pMaterialObj->Release();

    return S_OK;
}

HRESULT Saver::CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceWraps *data;

    cFaces = pFaceArray->GetSize();
    cbSize = sizeof(DWORD) + cFaces * sizeof(Boolean2d);

    data = (FaceWraps *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cFaces = cFaces;
    Boolean2d *pWrap = data->faceWraps;

    for (DWORD i = 0; i < cFaces; i++, pWrap++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);
        pFace->GetTextureTopology(&pWrap->u, &pWrap->v);
        pFace->Release();
    }

    LPDIRECTXFILEDATA pTextureWrapsObj;

    pSave->CreateDataObject(TID_D3DRMMeshFaceWraps,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTextureWrapsObj);

    pMeshObj->AddDataObject(pTextureWrapsObj);
    pTextureWrapsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                         DWORD cVertices,
                                         LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    TextureCoords *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(Coords2d);

    data = (TextureCoords *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cVertices = cVertices;
    Coords2d *pCoords = data->textureCoords;

    for (DWORD i = 0; i < cVertices; i++, pCoords++)
    {
        pMeshBuilder->GetTextureCoordinates(i, &pCoords->u, &pCoords->v);
    }

    LPDIRECTXFILEDATA pTexCoordsObj;

    pSave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTexCoordsObj);

    pMeshObj->AddDataObject(pTexCoordsObj);
    pTexCoordsObj->Release();
    delete[] data;                        

    return S_OK;
}

FaceMaterialList::FaceMaterialList()
  : cElements(0), pFirst(NULL)
{
}

FaceMaterialList::~FaceMaterialList()
{
    FaceMaterial *pMat = pFirst;
    while (pMat)
    {
        FaceMaterial *pNext = pMat->pNext;
        pMat->pMaterial->Release();
        if (pMat->pTexture) pMat->pTexture->Release();
        delete pMat;
        pMat = pNext;
    }
}

DWORD FaceMaterialList::Find(D3DCOLOR faceColor,
                             LPDIRECT3DRMMATERIAL pMaterial,
                             LPDIRECT3DRMTEXTURE pTexture)
{
    FaceMaterial *pTmp = pFirst;
    FaceMaterial **ppNew = &pFirst;

    for (DWORD i = 0; pTmp; i++, pTmp = pTmp->pNext)
    {
        if (pTmp->faceColor == faceColor &&
            pTmp->pMaterial == pMaterial &&
            pTmp->pTexture == pTexture)
            return i;

        if (!pTmp->pNext)
            ppNew = &pTmp->pNext;
    }

    FaceMaterial *pNew = new FaceMaterial;
    if (!pNew) return 0;

    pNew->faceColor = faceColor;
    pNew->pMaterial = pMaterial;
    pNew->pTexture = pTexture;
    pNew->pNext = NULL;
    pMaterial->AddRef();
    if (pTexture) pTexture->AddRef();

    *ppNew = pNew;
    cElements++;
    return i;
}

NameList::NameList()
 : pFirst(NULL),
   ppLast(NULL)
{
}

NameList::~NameList()
{
    NameEntry *pEntry = pFirst;

    while (pEntry)
    {
        NameEntry *pNext = pEntry->pNext;
        delete[] pEntry->pName;
        delete pEntry;
        pEntry = pNext;
    }
}

void NameList::Add(LPSTR pName)
{
    NameEntry *pNew = new NameEntry;
    if (!pNew) return;
	
    pNew->pName = pName;
    pNew->pNext = NULL;

    if (ppLast)
        *ppLast = pNew;
    else
        pFirst = pNew;

    ppLast = &pNew->pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

#if 0
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

DEFINE_GUID(IID_IDirectSound3DListener,0x279AFA84,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound3DBuffer,0x279AFA86,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);
DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);



DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);




DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);
DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0xff6b7f71, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray,  0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);



DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x2e34065, 0xc243, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#define DX6 1
#define DX7 1
#include "windows.h"
#include "mmsystem.h"

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"


#include "ddraw.h"
#include "dvp.h"

#ifndef _DEBUG
__inline void* __cdecl malloc(size_t cbSize)
{
    return (void*) LocalAlloc(LMEM_FIXED, cbSize);
}

__inline void* __cdecl realloc(void* oldptr, size_t cbSize)
{
    return (void*) LocalReAlloc(oldptr, cbSize, LMEM_MOVEABLE);
}

__inline void __cdecl free(void *pv)
{
    LocalFree((HLOCAL)pv);
}

__inline void* __cdecl operator new(size_t cbSize)
{
    return (void*) malloc(cbSize);
}

__inline void __cdecl operator delete(void *pv)
{
    free(pv);
}

__inline int __cdecl _purecall(void)
{
    return(0);
}
#endif

#include "d3d.h"
#include "d3dcaps.h"
#include "d3drm.h"
#include "d3drmwin.h"

#include "dSound.h"
#include "dPlay.h"
#include "dpLobby.h" 
#include "d3drmdef.h"
#include "d3drmobj.h"
#include "dinput.h"


#define DECL_VARIABLE(c) typedef_##c m_##c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\wave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wave.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include <mmreg.h>
#include <msacm.h>


// FOURCC codes
#undef FOURCC_RIFF
#define FOURCC_RIFF         'FFIR'

#undef FOURCC_MEM
#define FOURCC_MEM          ' MEM'

#undef FOURCC_WAVE
#define FOURCC_WAVE         'EVAW'

#undef FOURCC_FORMAT
#define FOURCC_FORMAT       ' tmf'

#undef FOURCC_DATA
#define FOURCC_DATA         'atad'

#define RPF(level,str,err) \
	{ char outBuf[MAX_PATH]; \
	  wsprintf(outBuf,str,err); \
	  OutputDebugString(outBuf); \
	}


#define DPFLVL_ERROR 1



/***************************************************************************
 *
 *  FillWfx
 *
 *  Description:
 *      Fills a WAVEFORMATEX structure, given only the necessary values.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: structure to fill.
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME

void FillWfx(LPWAVEFORMATEX pwfx, WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = min(2, max(1, wChannels));
    pwfx->nSamplesPerSec = min(DSBFREQUENCY_MAX, max(DSBFREQUENCY_MIN, dwSamplesPerSec));
    
    if(wBitsPerSample < 12)
    {
        pwfx->wBitsPerSample = 8;
    }
    else
    {
        pwfx->wBitsPerSample = 16;
    }

    pwfx->nBlockAlign = pwfx->nChannels * pwfx->wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;
}


#if 0

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData,DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;
    ACMSTREAMHEADER         ash;
    DWORD                   dwBufferBytes;
    LPVOID                  pvWrite;
    DWORD                   cbWrite;
    HMMIO                   hmm                 = NULL;
	MMRESULT                mmr;
	MMIOINFO                mmioinfo;
    MMCKINFO                ckiRiff;
    MMCKINFO                cki;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;
	BOOL					bNULLFORMAT			= FALSE;    
	


    ZeroMemory(&mmioinfo, sizeof(mmioinfo));

	if(SUCCEEDED(hr)){
		mmioinfo.fccIOProc = FOURCC_MEM;
		mmioinfo.pchBuffer = (HPSTR)pbWaveData;
		mmioinfo.cchBuffer = cbWaveData;
    
		hmm = mmioOpen(NULL, &mmioinfo, MMIO_READ);
		
		if(!hmm)
		{
			DPF1(1, "Unable to open file via MMIO.  Error %lu", mmioinfo.wErrorRet);
			hr = E_FAIL; 
		}
	 }

    // Decend into the RIFF chunk
    if(SUCCEEDED(hr))
    {
        ckiRiff.ckid = FOURCC_RIFF;
        mmr = mmioDescend(hmm, &ckiRiff, NULL, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into RIFF chunk.  Error %lu", mmr);
            hr = E_FAIL; 
        }
    }

    // Verify that this is a wave file
    if(SUCCEEDED(hr) && FOURCC_WAVE != ckiRiff.fccType)
    {
        DPF1(1, "File is not type WAVE %d",GetLastError());
        hr = DSERR_BADFORMAT;
    }

    // Decend into the format chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_FORMAT;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            pwfxSrcFormat = (LPWAVEFORMATEX)(pbWaveData + cki.dwDataOffset);
        }
    }



    // Ascend out of the format chunk
    if(SUCCEEDED(hr))
    {
        mmr = mmioAscend(hmm, &cki, 0);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Unable to ascend out of format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Descend into the data chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_DATA;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            RPF(DPFLVL_ERROR, "Unable to descend into data chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Prepare PCM conversion
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            // Populate the buffer description
            dwBufferBytes = cki.cksize;
            pwfxDestFormat = pwfxSrcFormat;
        }
        else
        {
            // Open an ACM conversion stream
            mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to open an ACM stream.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            // Get the size of the PCM data
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamSize(has, cki.cksize, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to determine converted data size.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }

            // Create the destination format
            if(SUCCEEDED(hr))
            {
                pwfxDestFormat = (WAVEFORMATEX*)malloc(sizeof(WAVEFORMATEX));
                if (pwfxDestFormat==NULL) hr=E_OUTOFMEMORY;				
            }
        
            if(SUCCEEDED(hr))
            {
                FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
            }
        }
    }

	
	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer=NULL;
	
    if(SUCCEEDED(hr))
    {
		//hr = InitializeEmpty(pDsbDesc->dwFlags, dwBufferBytes, pwfxDestFormat, NULL);
		pDsbDesc->dwBufferBytes=dwBufferBytes;
		
		if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
		else {
			pDsbDesc->lpwfxFormat=pwfxDestFormat;
		}

		hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
		if (*lplpDirectSoundBuffer==NULL) hr= E_FAIL;
		lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	}


    

    // Lock the buffer in order to write the PCM data to it
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
    }

    // Convert to PCM
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            CopyMemory(pvWrite, pbWaveData + cki.dwDataOffset, cbWrite);
        }
        else
        {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = pbWaveData + cki.dwDataOffset;
            ash.cbSrcLength = cki.cksize;
            ash.pbDst = (LPBYTE)pvWrite;
            ash.cbDstLength = cbWrite;

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to prepare ACM stream header.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            fPrep = SUCCEEDED(hr);

            // Convert the buffer
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamConvert(has, &ash, 0);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to convert wave data.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }
        }
    }

    // Unlock the buffer
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    }

    // Clean up
    if(fPrep)
    {
        acmStreamUnprepareHeader(has, &ash, 0);
    }

    if(has)
    {
        acmStreamClose(has, 0);
    }
    
    if(hmm)
    {
        mmioClose(hmm, 0);
    }

    if(pwfxDestFormat != pwfxSrcFormat)
    {
        free(pwfxDestFormat);
    }

    return hr;

}

#endif


















///////////////////////////////////////////////////////////////////////////////////////////
		

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData, DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;    
    DWORD                   dwBufferBytes		= 0;
    LPVOID                  pvWrite				= NULL;
    DWORD                   cbWrite				= 0;
	LPWAVEFORMATEX			pwfxFormat			= NULL;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;    
	MMRESULT                mmr					= 0;
	DWORD					dwDataLength		= 0;
	DWORD					dwOffset			= 0;
	char					*pChunk				= NULL;
	LPDIRECTSOUNDBUFFER		lpDirectSoundBuffer	= NULL;
	ACMSTREAMHEADER         ash;
	BOOL					bNULLFORMAT			=FALSE;
	BOOL					bDirty				=FALSE;

	
	struct tag_FileHeader
	{
		DWORD       dwRiff;
		DWORD       dwFileSize;
		DWORD       dwWave;
		DWORD       dwFormat;
		DWORD       dwFormatLength;		
	} FileHeader;
	
	ZeroMemory(&FileHeader,sizeof(struct tag_FileHeader));
	
	//	If our file is big enough to have a header copy it over
	//	other wise error out
	if (cbWaveData>sizeof(struct tag_FileHeader)) 
	{
		memcpy(&FileHeader,pbWaveData,sizeof(struct tag_FileHeader));
	}
	else 
	{
		hr= E_INVALIDARG;
	}

	// File must be a riff file ( 52 R, 49 I, 46 F, 46 F)
	if (FileHeader.dwRiff != 0x46464952) 
	{
		DPF(1, "DXVB: not a RIFF file\n");
		return E_INVALIDARG;	
	}

	//  must be a WAVE format ( 57 W, 41 A, 56 V, 45 E )
	if (FileHeader.dwWave != 0x45564157)
	{
		DPF(1, "DXVB: not a WAVE file\n");
		return E_INVALIDARG;	
	}

	//  check for odd stuff
	//  note 18bytes is a typical WAVEFORMATEX
	if (FileHeader.dwFormatLength <= 14) return E_INVALIDARG;
	if (FileHeader.dwFormatLength > 1000) return E_INVALIDARG;

	//allocate the waveformat
	__try { pwfxFormat=(WAVEFORMATEX*)alloca(FileHeader.dwFormatLength); } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
	if (!pwfxFormat) return E_OUTOFMEMORY;

	//copy it to our own data structure
	pChunk=(char*)(pbWaveData+sizeof (struct tag_FileHeader));
	memcpy(pwfxFormat,pChunk,FileHeader.dwFormatLength);

	
	// Now look for the next chunk after the WaveFormat
	pChunk=(char*)(pChunk+FileHeader.dwFormatLength);
		
	// Look for option FACT chunk and skip it
	//	(66 F, 61 A, 63 C, 74 T)
	// this chunk is required for compressed wave files
	// but is optional for PCM
	//
	if ( ((DWORD*)pChunk)[0]==0x74636166) 
	{
		dwOffset=((DWORD*)pChunk)[1];
		dwBufferBytes=((DWORD*)pChunk)[2];	//number of bytes of PCM data
		pChunk =(char*)(pChunk+ dwOffset+8);	
		
	}

	//Look for required data chunk
	// (64 D, 61 A, 74 T, 61 A)
	if (((DWORD*)pChunk)[0]!=0x61746164) 
	{
				DPF(1, "DXVB: no DATA chunk in wave file\n");
				return E_INVALIDARG;	
	}

	dwDataLength=((DWORD*)pChunk)[1];
	pChunk=(char*)(pChunk+8);
								
	
	//IF we assume PCM 
	//pcm files are not required to have their fact chunk 
	//so be ware they may missreport the data length			
	dwBufferBytes=dwDataLength;	
	pwfxDestFormat=pwfxSrcFormat=pwfxFormat;

	// if we are not PCM then we need to do some things first
	if (pwfxFormat->wFormatTag!=WAVE_FORMAT_PCM)
	{
	

		// source format is from the file 
	
		pwfxSrcFormat=pwfxFormat;				//from file
		pwfxDestFormat=pDsbDesc->lpwfxFormat ;	//from user	
		

		
		//pick the format of the file passed in
		FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
		

		// Open an ACM conversion stream
		mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );
		if(MMSYSERR_NOERROR != mmr)
		{
			DPF1(1, "Unable to open an ACM stream.  Error %lu\n", mmr);
			return E_FAIL;
		}

	
        // Get the size of the PCM data
        mmr = acmStreamSize(has, dwDataLength, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);
        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to determine converted data size.  Error %lu\n", mmr);
            return E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
   

		// Allocate a DestFormat struct
        //pwfxDestFormat = (WAVEFORMATEX*)alloca(sizeof(WAVEFORMATEX));
        //if (!pwfxDestFormat) return E_OUTOFMEMORY;				
        

		// Fill the format with information from the source but
		// FillWfx sets the format to PCM
        //FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
        

    }

	
	// fill the buffer desc the user passed in with the buffer bytes
	// this is the number of PCM bytes
	pDsbDesc->dwBufferBytes=dwBufferBytes;
	
	// if they provide us a pointer to a waveformatex
	// copy over the format to the input desc and use it
	// otherwise have it point to our data format temprarily
	if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
	else {
		pDsbDesc->lpwfxFormat=pwfxDestFormat;
		//make sure we null out the format before passing it back to the user
		//NOTE: consider the problems in a multithreaded enviroment
		//where the users data structures are being accesed by multiple
		//threads... on the other hand if thats going on..
		//then the user would need to syncronize things on his or her own 
		//for everything else including calling into apis that fill structures..
		bNULLFORMAT=TRUE;		
	}

	// Create the buffer
	hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
	if FAILED(hr) return hr;
	if (*lplpDirectSoundBuffer==NULL) return E_FAIL;	//todo ASSERT this instead..
	
	// for more convenient referencing...
	lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	
    
    // Lock the buffer in order to write the PCM data to it
	// cbWrite will contain the number of locked bytes
    hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
	if FAILED(hr) return hr;


	// If the sorce format was pcm then copy from the file to the buffer
    if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
    {
    	CopyMemory(pvWrite, pChunk, cbWrite);


		// Unlock the buffer
		hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    
		if (FAILED(hr)) 
		{
			 DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
			 return hr;
		}

    }

	// if the source format is compressed then convert first then copy
    else
    {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = (unsigned char*)pChunk;	//start of compressed data
            ash.cbSrcLength = dwDataLength;		//number of bytes of compressed data
            ash.pbDst = (LPBYTE)pvWrite;		//where to put the decompressed data
            ash.cbDstLength = cbWrite;			//how big is that buffer

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                DPF1(1, "DXVB: Unable to prepare ACM stream header.  Error %lu \n", mmr);
                return E_FAIL;
            }

            
            mmr = acmStreamConvert(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
				DPF1(1, "DXVB:  Unable to convert wave data.  Error %lu \n", mmr);
                return hr;  
            }

			// Unlock the buffer
			hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
			if (FAILED(hr)) 
			{
				DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
				return hr;
			}

		    acmStreamUnprepareHeader(has, &ash, 0);
	        acmStreamClose(has, 0);
    }
    
	
	if (bNULLFORMAT){
		pDsbDesc->lpwfxFormat=NULL;
	}

    return hr;

}





HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer) 
{
		HRESULT					hr=S_OK;
	    HANDLE                  hFile               = NULL;
	    HANDLE                  hFileMapping        = NULL;
	    DWORD                   cbWaveData;
		LPBYTE                  pbWaveData          = NULL;

		#pragma message("CreateFileW should be used for localization why wont it work")
		//hFile = CreateFileW(file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
		USES_CONVERSION;
		LPSTR pStrA = NULL;
		__try { pStrA = W2T(file); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }
		
		if (!pStrA) return E_INVALIDARG;
		hFile = CreateFileA(pStrA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hFile = NULL;
        }

        if(!hFile)
        {
            RPF(DPFLVL_ERROR, "Unable to open file.  Error %lu", GetLastError());
            hr=STG_E_FILENOTFOUND;
			return hr;
        }

        if(hFile)
        {
            cbWaveData = GetFileSize(hFile, NULL);

            if(-1 == cbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to get file size.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbWaveData, NULL);

            if(INVALID_HANDLE_VALUE == hFileMapping)
            {
                hFileMapping = NULL;
            }
            
            if(!hFileMapping)
            {
                RPF(DPFLVL_ERROR, "Unable to create file mapping.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            pbWaveData = (LPBYTE)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, cbWaveData);

            if(!pbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to map view of file.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

		if(SUCCEEDED(hr)) {
			hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
		}

	    if(pbWaveData)
        {
            UnmapViewOfFile(pbWaveData);
        }

        if(hFileMapping)
        {
            CloseHandle(hFileMapping);
        }
        
        if(hFile)
        {
            CloseHandle(hFile);
        }
		

		return hr;
    

}

HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{
    const LPCSTR            apszResourceTypeA[] = { "WAVE", "WAV" };
    const LPCWSTR           apszResourceTypeW[] = { L"WAVE", L"WAV" };
    UINT                    cResourceType       = 2;
    HRSRC                   hRsrc               = NULL;
    DWORD                   cbWaveData;
    LPBYTE                  pbWaveData          = NULL;
	HRESULT					hr=S_OK;
	
	LPCDSBUFFERDESC	pDsbDesc=pDesc;

    
	while(!hRsrc && cResourceType--)
    {
        hRsrc = FindResourceW((HINSTANCE)resHandle, resName, apszResourceTypeW[cResourceType]);            
    }

    if(!hRsrc)
    {
		RPF(DPFLVL_ERROR,"Unable to find resource.  Error %lu", GetLastError());
        hr = STG_E_FILENOTFOUND;
    }

    if(SUCCEEDED(hr))
    {
        cbWaveData = SizeofResource((HINSTANCE)resHandle, hRsrc);
        if(!cbWaveData)
        {

            RPF(DPFLVL_ERROR, "Unable to get resource size.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }
        
    if(SUCCEEDED(hr))
    {                
        pbWaveData = (LPBYTE)LoadResource((HINSTANCE)resHandle, hRsrc);            
        if(!pbWaveData)
        {
            RPF(DPFLVL_ERROR, "Unable to load resource.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }

	if(SUCCEEDED(hr)) {
		hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
	}

	//loadResource
   return hr;
}




HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file)
{
	WAVEFORMATEX waveFormat;
	DWORD dwWritten=0;
	DWORD dwBytes=0;
	LPBYTE lpByte=NULL;
	HRESULT hr;
	HANDLE hFile=NULL;

	if (!pBuff) return E_FAIL;
	if (!file) return E_INVALIDARG;

	
	pBuff->GetFormat(&waveFormat,sizeof(WAVEFORMATEX),NULL);


    

	USES_CONVERSION;
	LPSTR pStrA = NULL;
	__try { pStrA = W2T(file); /* Now convert to ANSI */ } 	__except(EXCEPTION_EXECUTE_HANDLER)	{ return E_FAIL; }

    hFile = CreateFile 
                (
                    pStrA,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );
	if (INVALID_HANDLE_VALUE != hFile)
    {
			
		struct tag_FileHeader
		{
			DWORD       dwRiff;
			DWORD       dwFileSize;
			DWORD       dwWave;
			DWORD       dwFormat;
			DWORD       dwFormatLength;
			WORD        wFormatTag;
			WORD        nChannels;
			DWORD       nSamplesPerSec;
			DWORD       nAvgBytesPerSec;
			WORD        nBlockAlign;
			WORD        wBitsPerSample;
			DWORD       dwData;
			DWORD       dwDataLength;
		} FileHeader;    

		hr=pBuff->Lock(0,0,(void**)&lpByte,&dwBytes,NULL,NULL,DSBLOCK_ENTIREBUFFER);
		if FAILED(hr) {
			CloseHandle(hFile);
			return hr;
		}

        FileHeader.dwRiff             = 0x46464952;                // RIFF
        FileHeader.dwWave             = 0x45564157;                // WAVE
        FileHeader.dwFormat           = 0x20746D66;                // fmt_chnk
        FileHeader.dwFormatLength     = 16; 
	    FileHeader.wFormatTag         = WAVE_FORMAT_PCM;
	    FileHeader.nChannels          = waveFormat.nChannels ;
	    FileHeader.nSamplesPerSec     = waveFormat.nSamplesPerSec ;
	    FileHeader.wBitsPerSample     = waveFormat.wBitsPerSample ;
	    FileHeader.nBlockAlign        = FileHeader.wBitsPerSample / 8 * FileHeader.nChannels;
	    FileHeader.nAvgBytesPerSec    = FileHeader.nSamplesPerSec * FileHeader.nBlockAlign;
        FileHeader.dwData             = 0x61746164;					// data_chnk
        FileHeader.dwDataLength       = dwBytes;
        FileHeader.dwFileSize         = dwBytes + sizeof(FileHeader);


        WriteFile(hFile, &FileHeader, sizeof(FileHeader), &dwWritten, NULL);
        

        WriteFile(hFile, lpByte, dwBytes, &dwWritten, NULL);

		hr=pBuff->Unlock(lpByte,0,NULL,0); 

        CloseHandle(hFile);
    }
    else{
		return E_FAIL;
	}
    

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#ifndef MAKE_FOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT    1
#define DMUS_DOWNLOADINFO_WAVE          2
#define DMUS_DOWNLOADINFO_INSTRUMENT2   3   /* New version for better DLS2 support. */

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;             
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;                        
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;                                      
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE]; 
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;       
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dinput.h ===
/****************************************************************************
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinput.h
 *  Content:    DirectInput include file
 *
 ****************************************************************************/

#ifndef __DINPUT_INCLUDED__
#define __DINPUT_INCLUDED__

#ifndef DIJ_RINGZERO

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#endif /* DIJ_RINGZERO */

#ifdef __cplusplus
extern "C" {
#endif




/*
 *  To build applications for older versions of DirectInput 
 *
 *  #define DIRECTINPUT_VERSION 0x0300
 *  or
 *  #define DIRECTINPUT_VERSION 0x0500
 *
 *  before #include <dinput.h>.  By default, #include <dinput.h>
 *  will produce a DirectX 7-compatible header file.
 *
 */

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0700
#endif

#ifndef DIJ_RINGZERO
/****************************************************************************
 *
 *      Class IDs
 *
 ****************************************************************************/

DEFINE_GUID(CLSID_DirectInput,      0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice,0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput7A,    0X9A4CB684,0X236D,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInput7W,    0X9A4CB685,0X236D,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

DEFINE_GUID(IID_IDirectInputDevice7A,0X57D7C6BC,0X2356,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInputDevice7W,0X57D7C6BD,0X2356,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);

/****************************************************************************
 *
 *      Predefined object types
 *
 ****************************************************************************/

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined product GUIDs
 *
 ****************************************************************************/

DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm, 0x6F1D2B80,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm2,0x6F1D2B81,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm, 0x6F1D2B82,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm2,0x6F1D2B83,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined force feedback effects
 *
 ****************************************************************************/

DEFINE_GUID(GUID_ConstantForce, 0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,     0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,        0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,          0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,      0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,    0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown,  0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,        0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,        0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,       0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,      0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,   0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Interfaces and Structures...
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0500)

/****************************************************************************
 *
 *      IDirectInputEffect
 *
 ****************************************************************************/

#define DIEFT_ALL                   0x00000000

#define DIEFT_CONSTANTFORCE         0x00000001
#define DIEFT_RAMPFORCE             0x00000002
#define DIEFT_PERIODIC              0x00000003
#define DIEFT_CONDITION             0x00000004
#define DIEFT_CUSTOMFORCE           0x00000005
#define DIEFT_HARDWARE              0x000000FF
#define DIEFT_FFATTACK              0x00000200
#define DIEFT_FFFADE                0x00000400
#define DIEFT_SATURATION            0x00000800
#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
#define DIEFT_POSNEGSATURATION      0x00002000
#define DIEFT_DEADBAND              0x00004000
#define DIEFT_STARTDELAY            0x00008000
#define DIEFT_GETTYPE(n)            LOBYTE(n)

#define DI_DEGREES                  100
#define DI_FFNOMINALMAX             10000
#define DI_SECONDS                  1000000

typedef struct DICONSTANTFORCE {
    LONG  lMagnitude;
} DICONSTANTFORCE, *LPDICONSTANTFORCE;
typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;

typedef struct DIRAMPFORCE {
    LONG  lStart;
    LONG  lEnd;
} DIRAMPFORCE, *LPDIRAMPFORCE;
typedef const DIRAMPFORCE *LPCDIRAMPFORCE;

typedef struct DIPERIODIC {
    DWORD dwMagnitude;
    LONG  lOffset;
    DWORD dwPhase;
    DWORD dwPeriod;
} DIPERIODIC, *LPDIPERIODIC;
typedef const DIPERIODIC *LPCDIPERIODIC;

typedef struct DICONDITION {
    LONG  lOffset;
    LONG  lPositiveCoefficient;
    LONG  lNegativeCoefficient;
    DWORD dwPositiveSaturation;
    DWORD dwNegativeSaturation;
    LONG  lDeadBand;
} DICONDITION, *LPDICONDITION;
typedef const DICONDITION *LPCDICONDITION;

typedef struct DICUSTOMFORCE {
    DWORD cChannels;
    DWORD dwSamplePeriod;
    DWORD cSamples;
    LPLONG rglForceData;
} DICUSTOMFORCE, *LPDICUSTOMFORCE;
typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;


typedef struct DIENVELOPE {
    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
    DWORD dwAttackLevel;
    DWORD dwAttackTime;             /* Microseconds         */
    DWORD dwFadeLevel;
    DWORD dwFadeTime;               /* Microseconds         */
} DIENVELOPE, *LPDIENVELOPE;
typedef const DIENVELOPE *LPCDIENVELOPE;


/* This structure is defined for DirectX 5.0 compatibility */
typedef struct DIEFFECT_DX5 {
    DWORD dwSize;                   /* sizeof(DIEFFECT_DX5) */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
} DIEFFECT_DX5, *LPDIEFFECT_DX5;
typedef const DIEFFECT_DX5 *LPCDIEFFECT_DX5;

typedef struct DIEFFECT {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
#if(DIRECTINPUT_VERSION >= 0x0600)
    DWORD  dwStartDelay;            /* Microseconds         */
#endif /* DIRECTINPUT_VERSION >= 0x0600 */
} DIEFFECT, *LPDIEFFECT;
typedef DIEFFECT DIEFFECT_DX6;
typedef LPDIEFFECT LPDIEFFECT_DX6;
typedef const DIEFFECT *LPCDIEFFECT;


#if(DIRECTINPUT_VERSION >= 0x0700)
#ifndef DIJ_RINGZERO
typedef struct DIFILEEFFECT{
    DWORD       dwSize;
    GUID        GuidEffect;
    LPCDIEFFECT lpDiEffect;
    CHAR        szFriendlyName[MAX_PATH];                    
}DIFILEEFFECT, *LPDIFILEEFFECT;                                            
typedef const DIFILEEFFECT *LPCDIFILEEFFECT;                                            
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSINFILECALLBACK)(LPCDIFILEEFFECT , LPVOID); 
#endif /* DIJ_RINGZERO */
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#define DIEFF_OBJECTIDS             0x00000001
#define DIEFF_OBJECTOFFSETS         0x00000002
#define DIEFF_CARTESIAN             0x00000010
#define DIEFF_POLAR                 0x00000020
#define DIEFF_SPHERICAL             0x00000040

#define DIEP_DURATION               0x00000001
#define DIEP_SAMPLEPERIOD           0x00000002
#define DIEP_GAIN                   0x00000004
#define DIEP_TRIGGERBUTTON          0x00000008
#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
#define DIEP_AXES                   0x00000020
#define DIEP_DIRECTION              0x00000040
#define DIEP_ENVELOPE               0x00000080
#define DIEP_TYPESPECIFICPARAMS     0x00000100
#if(DIRECTINPUT_VERSION >= 0x0600)
#define DIEP_STARTDELAY             0x00000200
#define DIEP_ALLPARAMS_DX5          0x000001FF
#define DIEP_ALLPARAMS              0x000003FF
#else /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_ALLPARAMS              0x000001FF
#endif /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_START                  0x20000000
#define DIEP_NORESTART              0x40000000
#define DIEP_NODOWNLOAD             0x80000000
#define DIEB_NOTRIGGER              0xFFFFFFFF

#define DIES_SOLO                   0x00000001
#define DIES_NODOWNLOAD             0x80000000

#define DIEGES_PLAYING              0x00000001
#define DIEGES_EMULATED             0x00000002

typedef struct DIEFFESCAPE {
    DWORD   dwSize;
    DWORD   dwCommand;
    LPVOID  lpvInBuffer;
    DWORD   cbInBuffer;
    LPVOID  lpvOutBuffer;
    DWORD   cbOutBuffer;
} DIEFFESCAPE, *LPDIEFFESCAPE;

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputEffect

DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffect methods ***/
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(Download)(THIS) PURE;
    STDMETHOD(Unload)(THIS) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
};

typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#else
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffect_AddRef(p) (p)->AddRef()
#define IDirectInputEffect_Release(p) (p)->Release()
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
#define IDirectInputEffect_Stop(p) (p)->Stop()
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
#define IDirectInputEffect_Download(p) (p)->Download()
#define IDirectInputEffect_Unload(p) (p)->Unload()
#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      IDirectInputDevice
 *
 ****************************************************************************/

#define DIDEVTYPE_DEVICE    1
#define DIDEVTYPE_MOUSE     2
#define DIDEVTYPE_KEYBOARD  3
#define DIDEVTYPE_JOYSTICK  4
#define DIDEVTYPE_HID       0x00010000

#define DIDEVTYPEMOUSE_UNKNOWN          1
#define DIDEVTYPEMOUSE_TRADITIONAL      2
#define DIDEVTYPEMOUSE_FINGERSTICK      3
#define DIDEVTYPEMOUSE_TOUCHPAD         4
#define DIDEVTYPEMOUSE_TRACKBALL        5

#define DIDEVTYPEKEYBOARD_UNKNOWN       0
#define DIDEVTYPEKEYBOARD_PCXT          1
#define DIDEVTYPEKEYBOARD_OLIVETTI      2
#define DIDEVTYPEKEYBOARD_PCAT          3
#define DIDEVTYPEKEYBOARD_PCENH         4
#define DIDEVTYPEKEYBOARD_NOKIA1050     5
#define DIDEVTYPEKEYBOARD_NOKIA9140     6
#define DIDEVTYPEKEYBOARD_NEC98         7
#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
#define DIDEVTYPEKEYBOARD_NEC98106      9
#define DIDEVTYPEKEYBOARD_JAPAN106     10
#define DIDEVTYPEKEYBOARD_JAPANAX      11
#define DIDEVTYPEKEYBOARD_J3100        12

#define DIDEVTYPEJOYSTICK_UNKNOWN       1
#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
#define DIDEVTYPEJOYSTICK_GAMEPAD       4
#define DIDEVTYPEJOYSTICK_RUDDER        5
#define DIDEVTYPEJOYSTICK_WHEEL         6
#define DIDEVTYPEJOYSTICK_HEADTRACKER   7

#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)

#if(DIRECTINPUT_VERSION >= 0x0500)
/* This structure is defined for DirectX 3.0 compatibility */
typedef struct DIDEVCAPS_DX3 {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVCAPS {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVCAPS, *LPDIDEVCAPS;

#define DIDC_ATTACHED           0x00000001
#define DIDC_POLLEDDEVICE       0x00000002
#define DIDC_EMULATED           0x00000004
#define DIDC_POLLEDDATAFORMAT   0x00000008
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDC_FORCEFEEDBACK      0x00000100
#define DIDC_FFATTACK           0x00000200
#define DIDC_FFFADE             0x00000400
#define DIDC_SATURATION         0x00000800
#define DIDC_POSNEGCOEFFICIENTS 0x00001000
#define DIDC_POSNEGSATURATION   0x00002000
#define DIDC_DEADBAND           0x00004000
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#define DIDC_STARTDELAY         0x00008000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDC_ALIAS              0x00010000
#define DIDC_PHANTOM            0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ALL           0x00000000

#define DIDFT_RELAXIS       0x00000001
#define DIDFT_ABSAXIS       0x00000002
#define DIDFT_AXIS          0x00000003

#define DIDFT_PSHBUTTON     0x00000004
#define DIDFT_TGLBUTTON     0x00000008
#define DIDFT_BUTTON        0x0000000C

#define DIDFT_POV           0x00000010
#define DIDFT_COLLECTION    0x00000040
#define DIDFT_NODATA        0x00000080

#define DIDFT_ANYINSTANCE   0x00FFFF00
#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
#define DIDFT_GETTYPE(n)     LOBYTE(n)
#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
#define DIDFT_FFACTUATOR        0x01000000
#define DIDFT_FFEFFECTTRIGGER   0x02000000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDFT_OUTPUT            0x10000000
#define DIDFT_VENDORDEFINED     0x04000000
#define DIDFT_ALIAS             0x08000000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
#define DIDFT_NOCOLLECTION      0x00FFFF00

#ifndef DIJ_RINGZERO

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIDATAFORMAT {
    DWORD   dwSize;
    DWORD   dwObjSize;
    DWORD   dwFlags;
    DWORD   dwDataSize;
    DWORD   dwNumObjs;
    LPDIOBJECTDATAFORMAT rgodf;
} DIDATAFORMAT, *LPDIDATAFORMAT;
typedef const DIDATAFORMAT *LPCDIDATAFORMAT;

#define DIDF_ABSAXIS            0x00000001
#define DIDF_RELAXIS            0x00000002

#ifdef __cplusplus
extern "C" {
#endif
extern const DIDATAFORMAT c_dfDIMouse;

#if(DIRECTINPUT_VERSION >= 0x0700)
extern const DIDATAFORMAT c_dfDIMouse2;
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

extern const DIDATAFORMAT c_dfDIKeyboard;

#if(DIRECTINPUT_VERSION >= 0x0500)
extern const DIDATAFORMAT c_dfDIJoystick;
extern const DIDATAFORMAT c_dfDIJoystick2;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#ifdef __cplusplus
};
#endif

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
#else
typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEOBJECTINSTANCEA {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
typedef struct DIDEVICEOBJECTINSTANCEW {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
#else
typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;

typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
#else
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
#endif // !UNICODE

#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDOI_FFACTUATOR        0x00000001
#define DIDOI_FFEFFECTTRIGGER   0x00000002
#define DIDOI_POLLED            0x00008000
#define DIDOI_ASPECTPOSITION    0x00000100
#define DIDOI_ASPECTVELOCITY    0x00000200
#define DIDOI_ASPECTACCEL       0x00000300
#define DIDOI_ASPECTFORCE       0x00000400
#define DIDOI_ASPECTMASK        0x00000F00
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDOI_GUIDISUSAGE       0x00010000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPHEADER {
    DWORD   dwSize;
    DWORD   dwHeaderSize;
    DWORD   dwObj;
    DWORD   dwHow;
} DIPROPHEADER, *LPDIPROPHEADER;
typedef const DIPROPHEADER *LPCDIPROPHEADER;

#define DIPH_DEVICE             0
#define DIPH_BYOFFSET           1
#define DIPH_BYID               2
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPH_BYUSAGE            3

#define DIMAKEUSAGEDWORD(UsagePage, Usage) \
                                (DWORD)MAKELONG(Usage, UsagePage)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPDWORD {
    DIPROPHEADER diph;
    DWORD   dwData;
} DIPROPDWORD, *LPDIPROPDWORD;
typedef const DIPROPDWORD *LPCDIPROPDWORD;

typedef struct DIPROPRANGE {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lMax;
} DIPROPRANGE, *LPDIPROPRANGE;
typedef const DIPROPRANGE *LPCDIPROPRANGE;

#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)

#if(DIRECTINPUT_VERSION >= 0x050a)
typedef struct DIPROPCAL {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIPROPCAL, *LPDIPROPCAL;
typedef const DIPROPCAL *LPCDIPROPCAL;

typedef struct DIPROPGUIDANDPATH {
    DIPROPHEADER diph;
    GUID    guidClass;
    WCHAR   wszPath[MAX_PATH];
} DIPROPGUIDANDPATH, *LPDIPROPGUIDANDPATH;
typedef const DIPROPGUIDANDPATH *LPCDIPROPGUIDANDPATH;

typedef struct DIPROPSTRING {
    DIPROPHEADER diph;
    WCHAR   wsz[MAX_PATH];
} DIPROPSTRING, *LPDIPROPSTRING;
typedef const DIPROPSTRING *LPCDIPROPSTRING;

#endif /* DIRECTINPUT_VERSION >= 0x050a */
#ifdef __cplusplus
#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
#else
#define MAKEDIPROP(prop)    ((REFGUID)(prop))
#endif

#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)

#define DIPROP_AXISMODE         MAKEDIPROP(2)

#define DIPROPAXISMODE_ABS      0
#define DIPROPAXISMODE_REL      1

#define DIPROP_GRANULARITY      MAKEDIPROP(3)

#define DIPROP_RANGE            MAKEDIPROP(4)

#define DIPROP_DEADZONE         MAKEDIPROP(5)

#define DIPROP_SATURATION       MAKEDIPROP(6)

#define DIPROP_FFGAIN           MAKEDIPROP(7)

#define DIPROP_FFLOAD           MAKEDIPROP(8)

#define DIPROP_AUTOCENTER       MAKEDIPROP(9)

#define DIPROPAUTOCENTER_OFF    0
#define DIPROPAUTOCENTER_ON     1

#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)

#define DIPROPCALIBRATIONMODE_COOKED    0
#define DIPROPCALIBRATIONMODE_RAW       1

#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPROP_CALIBRATION      MAKEDIPROP(11)

#define DIPROP_GUIDANDPATH      MAKEDIPROP(12)

#define DIPROP_INSTANCENAME     MAKEDIPROP(13)

#define DIPROP_PRODUCTNAME      MAKEDIPROP(14)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIPROP_JOYSTICKID       MAKEDIPROP(15)

#define DIPROP_GETPORTDISPLAYNAME       MAKEDIPROP(16)


#define DIPROP_ENABLEREPORTID       MAKEDIPROP(17)


#define DIPROP_GETPHYSICALRANGE            MAKEDIPROP(18)

#define DIPROP_GETLOGICALRANGE            MAKEDIPROP(19)


typedef struct DIDEVICEOBJECTDATA {
    DWORD   dwOfs;
    DWORD   dwData;
    DWORD   dwTimeStamp;
    DWORD   dwSequence;
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

#define DIGDD_PEEK          0x00000001

#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
#define DISCL_EXCLUSIVE     0x00000001
#define DISCL_NONEXCLUSIVE  0x00000002
#define DISCL_FOREGROUND    0x00000004
#define DISCL_BACKGROUND    0x00000008
#define DISCL_NOWINKEY      0x00000010

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
typedef struct DIDEVICEINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
#else
typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEINSTANCEA {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
typedef struct DIDEVICEINSTANCEW {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
#endif // UNICODE
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceW

DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceA

DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;

#ifdef UNICODE
#define IID_IDirectInputDevice IID_IDirectInputDeviceW
#define IDirectInputDevice IDirectInputDeviceW
#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
#else
#define IID_IDirectInputDevice IID_IDirectInputDeviceA
#define IDirectInputDevice IDirectInputDeviceA
#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
#endif
typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#else
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice_AddRef(p) (p)->AddRef()
#define IDirectInputDevice_Release(p) (p)->Release()
#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice_Acquire(p) (p)->Acquire()
#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#endif

#endif /* DIJ_RINGZERO */


#if(DIRECTINPUT_VERSION >= 0x0500)

#define DISFFC_RESET            0x00000001
#define DISFFC_STOPALL          0x00000002
#define DISFFC_PAUSE            0x00000004
#define DISFFC_CONTINUE         0x00000008
#define DISFFC_SETACTUATORSON   0x00000010
#define DISFFC_SETACTUATORSOFF  0x00000020

#define DIGFFS_EMPTY            0x00000001
#define DIGFFS_STOPPED          0x00000002
#define DIGFFS_PAUSED           0x00000004
#define DIGFFS_ACTUATORSON      0x00000010
#define DIGFFS_ACTUATORSOFF     0x00000020
#define DIGFFS_POWERON          0x00000040
#define DIGFFS_POWEROFF         0x00000080
#define DIGFFS_SAFETYSWITCHON   0x00000100
#define DIGFFS_SAFETYSWITCHOFF  0x00000200
#define DIGFFS_USERFFSWITCHON   0x00000400
#define DIGFFS_USERFFSWITCHOFF  0x00000800
#define DIGFFS_DEVICELOST       0x80000000

#ifndef DIJ_RINGZERO

typedef struct DIEFFECTINFOA {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    CHAR    tszName[MAX_PATH];
} DIEFFECTINFOA, *LPDIEFFECTINFOA;
typedef struct DIEFFECTINFOW {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    WCHAR   tszName[MAX_PATH];
} DIEFFECTINFOW, *LPDIEFFECTINFOW;
#ifdef UNICODE
typedef DIEFFECTINFOW DIEFFECTINFO;
typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
#else
typedef DIEFFECTINFOA DIEFFECTINFO;
typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
#endif // UNICODE
typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;

#define DISDD_CONTINUE          0x00000001

typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
#ifdef UNICODE
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
#else
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);

#undef INTERFACE
#define INTERFACE IDirectInputDevice2W

DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice2A

DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;

#ifdef UNICODE
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
#define IDirectInputDevice2 IDirectInputDevice2W
#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
#else
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
#define IDirectInputDevice2 IDirectInputDevice2A
#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
#endif
typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#else
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
#define IDirectInputDevice2_Release(p) (p)->Release()
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice2_Poll(p) (p)->Poll()
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIFEF_DEFAULT               0x00000000
#define DIFEF_INCLUDENONSTANDARD    0x00000001
#define DIFEF_MODIFYIFNEEDED		0x00000010

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice7W

DECLARE_INTERFACE_(IDirectInputDevice7W, IDirectInputDevice2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7W methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7W *LPDIRECTINPUTDEVICE7W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice7A

DECLARE_INTERFACE_(IDirectInputDevice7A, IDirectInputDevice2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7A methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7A *LPDIRECTINPUTDEVICE7A;

#ifdef UNICODE
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7W
#define IDirectInputDevice7 IDirectInputDevice7W
#define IDirectInputDevice7Vtbl IDirectInputDevice7WVtbl
#else
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7A
#define IDirectInputDevice7 IDirectInputDevice7A
#define IDirectInputDevice7Vtbl IDirectInputDevice7AVtbl
#endif
typedef struct IDirectInputDevice7 *LPDIRECTINPUTDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice7_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice7_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice7_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#else
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice7_AddRef(p) (p)->AddRef()
#define IDirectInputDevice7_Release(p) (p)->Release()
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice7_Acquire(p) (p)->Acquire()
#define IDirectInputDevice7_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice7_Poll(p) (p)->Poll()
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0700 */

/****************************************************************************
 *
 *      Mouse
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct _DIMOUSESTATE {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;

#if DIRECTINPUT_VERSION >= 0x0700
typedef struct _DIMOUSESTATE2 {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[8];
} DIMOUSESTATE2, *LPDIMOUSESTATE2;
#endif


#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
#if (DIRECTINPUT_VERSION >= 0x0700)
#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
#endif
#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Keyboard
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      DirectInput keyboard scan codes
 *
 ****************************************************************************/

#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_OEM_102         0x56    /* < > | on UK/Germany keyboards */
#define DIK_F11             0x57
#define DIK_F12             0x58

#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */

#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_ABNT_C1         0x73    /* / ? on Portugese (Brazilian) keyboards */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_ABNT_C2         0x7E    /* Numpad . on Portugese (Brazilian) keyboards */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NEXTTRACK       0x99    /* Next Track */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_MUTE            0xA0    /* Mute */
#define DIK_CALCULATOR      0xA1    /* Calculator */
#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
#define DIK_MEDIASTOP       0xA4    /* Media Stop */
#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
#define DIK_VOLUMEUP        0xB0    /* Volume + */
#define DIK_WEBHOME         0xB2    /* Web home */
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */
#define DIK_POWER           0xDE    /* System Power */
#define DIK_SLEEP           0xDF    /* System Sleep */
#define DIK_WAKE            0xE3    /* System Wake */
#define DIK_WEBSEARCH       0xE5    /* Web Search */
#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
#define DIK_WEBSTOP         0xE8    /* Web Stop */
#define DIK_WEBFORWARD      0xE9    /* Web Forward */
#define DIK_WEBBACK         0xEA    /* Web Back */
#define DIK_MYCOMPUTER      0xEB    /* My Computer */
#define DIK_MAIL            0xEC    /* Mail */
#define DIK_MEDIASELECT     0xED    /* Media Select */

/*
 *  Alternate names for keys, to facilitate transition from DOS.
 */
#define DIK_BACKSPACE       DIK_BACK            /* backspace */
#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
#define DIK_LALT            DIK_LMENU           /* left Alt */
#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
#define DIK_RALT            DIK_RMENU           /* right Alt */
#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */

/*
 *  Alternate names for keys originally not used on US keyboards.
 */
#define DIK_CIRCUMFLEX      DIK_PREVTRACK       /* Japanese keyboard */

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Joystick
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct DIJOYSTATE {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[32];         /* 32 buttons                   */
} DIJOYSTATE, *LPDIJOYSTATE;

typedef struct DIJOYSTATE2 {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[128];        /* 128 buttons                  */
    LONG    lVX;                    /* x-axis velocity              */
    LONG    lVY;                    /* y-axis velocity              */
    LONG    lVZ;                    /* z-axis velocity              */
    LONG    lVRx;                   /* x-axis angular velocity      */
    LONG    lVRy;                   /* y-axis angular velocity      */
    LONG    lVRz;                   /* z-axis angular velocity      */
    LONG    rglVSlider[2];          /* extra axes velocities        */
    LONG    lAX;                    /* x-axis acceleration          */
    LONG    lAY;                    /* y-axis acceleration          */
    LONG    lAZ;                    /* z-axis acceleration          */
    LONG    lARx;                   /* x-axis angular acceleration  */
    LONG    lARy;                   /* y-axis angular acceleration  */
    LONG    lARz;                   /* z-axis angular acceleration  */
    LONG    rglASlider[2];          /* extra axes accelerations     */
    LONG    lFX;                    /* x-axis force                 */
    LONG    lFY;                    /* y-axis force                 */
    LONG    lFZ;                    /* z-axis force                 */
    LONG    lFRx;                   /* x-axis torque                */
    LONG    lFRy;                   /* y-axis torque                */
    LONG    lFRz;                   /* z-axis torque                */
    LONG    rglFSlider[2];          /* extra axes forces            */
} DIJOYSTATE2, *LPDIJOYSTATE2;

#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
                                                        (n) * sizeof(LONG))
#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
                                                        (n) * sizeof(DWORD))
#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  IDirectInput
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#define DIENUM_STOP             0
#define DIENUM_CONTINUE         1

typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
#else
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
#endif // !UNICODE

#define DIEDFL_ALLDEVICES       0x00000000
#define DIEDFL_ATTACHEDONLY     0x00000001
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIEDFL_FORCEFEEDBACK    0x00000100
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIEDFL_INCLUDEALIASES   0x00010000
#define DIEDFL_INCLUDEPHANTOMS  0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#undef INTERFACE
#define INTERFACE IDirectInputW

DECLARE_INTERFACE_(IDirectInputW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputW *LPDIRECTINPUTW;

#undef INTERFACE
#define INTERFACE IDirectInputA

DECLARE_INTERFACE_(IDirectInputA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputA *LPDIRECTINPUTA;

#ifdef UNICODE
#define IID_IDirectInput IID_IDirectInputW
#define IDirectInput IDirectInputW
#define IDirectInputVtbl IDirectInputWVtbl
#else
#define IID_IDirectInput IID_IDirectInputA
#define IDirectInput IDirectInputA
#define IDirectInputVtbl IDirectInputAVtbl
#endif
typedef struct IDirectInput *LPDIRECTINPUT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#else
#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput_AddRef(p) (p)->AddRef()
#define IDirectInput_Release(p) (p)->Release()
#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirectInput2W

DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
};

typedef struct IDirectInput2W *LPDIRECTINPUT2W;

#undef INTERFACE
#define INTERFACE IDirectInput2A

DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
};

typedef struct IDirectInput2A *LPDIRECTINPUT2A;

#ifdef UNICODE
#define IID_IDirectInput2 IID_IDirectInput2W
#define IDirectInput2 IDirectInput2W
#define IDirectInput2Vtbl IDirectInput2WVtbl
#else
#define IID_IDirectInput2 IID_IDirectInput2A
#define IDirectInput2 IDirectInput2A
#define IDirectInput2Vtbl IDirectInput2AVtbl
#endif
typedef struct IDirectInput2 *LPDIRECTINPUT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#else
#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput2_AddRef(p) (p)->AddRef()
#define IDirectInput2_Release(p) (p)->Release()
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#endif


#undef INTERFACE
#define INTERFACE IDirectInput7W

DECLARE_INTERFACE_(IDirectInput7W, IDirectInput2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;

    /*** IDirectInput7W methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7W *LPDIRECTINPUT7W;

#undef INTERFACE
#define INTERFACE IDirectInput7A

DECLARE_INTERFACE_(IDirectInput7A, IDirectInput2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;

    /*** IDirectInput7A methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7A *LPDIRECTINPUT7A;

#ifdef UNICODE
#define IID_IDirectInput7 IID_IDirectInput7W
#define IDirectInput7 IDirectInput7W
#define IDirectInput7Vtbl IDirectInput7WVtbl
#else
#define IID_IDirectInput7 IID_IDirectInput7A
#define IDirectInput7 IDirectInput7A
#define IDirectInput7Vtbl IDirectInput7AVtbl
#endif
typedef struct IDirectInput7 *LPDIRECTINPUT7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->lpVtbl->CreateDeviceEx(p,a,b,c,d)
#else
#define IDirectInput7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput7_AddRef(p) (p)->AddRef()
#define IDirectInput7_Release(p) (p)->Release()
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->CreateDeviceEx(a,b,c,d)
#endif

extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
#ifdef UNICODE
#define DirectInputCreate  DirectInputCreateW
#else
#define DirectInputCreate  DirectInputCreateA
#endif // !UNICODE

extern HRESULT WINAPI DirectInputCreateEx(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

/*
 *  The operation completed successfully.
 */
#define DI_OK                           S_OK

/*
 *  The device exists but is not currently attached.
 */
#define DI_NOTATTACHED                  S_FALSE

/*
 *  The device buffer overflowed.  Some input was lost.
 */
#define DI_BUFFEROVERFLOW               S_FALSE

/*
 *  The change in device properties had no effect.
 */
#define DI_PROPNOEFFECT                 S_FALSE

/*
 *  The operation had no effect.
 */
#define DI_NOEFFECT                     S_FALSE

/*
 *  The device is a polled device.  As a result, device buffering
 *  will not collect any data and event notifications will not be
 *  signalled until GetDeviceState is called.
 */
#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but the effect was not
 *  downloaded because the device is not exclusively acquired
 *  or because the DIEP_NODOWNLOAD flag was passed.
 */
#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but in order to change
 *  the parameters, the effect needed to be restarted.
 */
#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but some of them were
 *  beyond the capabilities of the device and were truncated.
 */
#define DI_TRUNCATED                    ((HRESULT)0x00000008L)

/*
 *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
 */
#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)

/*
 *  The application requires a newer version of DirectInput.
 */
#define DIERR_OLDDIRECTINPUTVERSION     \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)

/*
 *  The application was written for an unsupported prerelease version
 *  of DirectInput.
 */
#define DIERR_BETADIRECTINPUTVERSION    \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)

/*
 *  The object could not be created due to an incompatible driver version
 *  or mismatched or incomplete driver components.
 */
#define DIERR_BADDRIVERVER              \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)

/*
 * The device or device instance or effect is not registered with DirectInput.
 */
#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG

/*
 * The requested object does not exist.
 */
#define DIERR_NOTFOUND                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * The requested object does not exist.
 */
#define DIERR_OBJECTNOTFOUND            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * An invalid parameter was passed to the returning function,
 * or the object was not in a state that admitted the function
 * to be called.
 */
#define DIERR_INVALIDPARAM              E_INVALIDARG

/*
 * The specified interface is not supported by the object
 */
#define DIERR_NOINTERFACE               E_NOINTERFACE

/*
 * An undetermined error occured inside the DInput subsystem
 */
#define DIERR_GENERIC                   E_FAIL

/*
 * The DInput subsystem couldn't allocate sufficient memory to complete the
 * caller's request.
 */
#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY

/*
 * The function called is not supported at this time
 */
#define DIERR_UNSUPPORTED               E_NOTIMPL

/*
 * This object has not been initialized
 */
#define DIERR_NOTINITIALIZED            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)

/*
 * This object is already initialized
 */
#define DIERR_ALREADYINITIALIZED        \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)

/*
 * This object does not support aggregation
 */
#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

/*
 * Another app has a higher priority level, preventing this call from
 * succeeding.
 */
#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED

/*
 * Access to the device has been lost.  It must be re-acquired.
 */
#define DIERR_INPUTLOST                 \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)

/*
 * The operation cannot be performed while the device is acquired.
 */
#define DIERR_ACQUIRED                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)

/*
 * The operation cannot be performed unless the device is acquired.
 */
#define DIERR_NOTACQUIRED               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)

/*
 * The specified property cannot be changed.
 */
#define DIERR_READONLY                  E_ACCESSDENIED

/*
 * The device already has an event notification associated with it.
 */
#define DIERR_HANDLEEXISTS              E_ACCESSDENIED

/*
 * Data is not yet available.
 */
#ifndef E_PENDING
#define E_PENDING                       0x8000000AL
#endif

/*
 * Unable to IDirectInputJoyConfig_Acquire because the user
 * does not have sufficient privileges to change the joystick
 * configuration.
 */
#define DIERR_INSUFFICIENTPRIVS         0x80040200L

/*
 * The device is full.
 */
#define DIERR_DEVICEFULL                0x80040201L

/*
 * Not all the requested information fit into the buffer.
 */
#define DIERR_MOREDATA                  0x80040202L

/*
 * The effect is not downloaded.
 */
#define DIERR_NOTDOWNLOADED             0x80040203L

/*
 *  The device cannot be reinitialized because there are still effects
 *  attached to it.
 */
#define DIERR_HASEFFECTS                0x80040204L

/*
 *  The operation cannot be performed unless the device is acquired
 *  in DISCL_EXCLUSIVE mode.
 */
#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L

/*
 *  The effect could not be downloaded because essential information
 *  is missing.  For example, no axes have been associated with the
 *  effect, or no type-specific information has been created.
 */
#define DIERR_INCOMPLETEEFFECT          0x80040206L

/*
 *  Attempted to read buffered device data from a device that is
 *  not buffered.
 */
#define DIERR_NOTBUFFERED               0x80040207L

/*
 *  An attempt was made to modify parameters of an effect while it is
 *  playing.  Not all hardware devices support altering the parameters
 *  of an effect while it is playing.
 */
#define DIERR_EFFECTPLAYING             0x80040208L

/*
 *  The operation could not be completed because the device is not
 *  plugged in.
 */
#define DIERR_UNPLUGGED                 0x80040209L

/*
 *  SendDeviceData failed because more information was requested
 *  to be sent than can be sent to the device.  Some devices have
 *  restrictions on how much data can be sent to them.  (For example,
 *  there might be a limit on the number of buttons that can be
 *  pressed at once.)
 */
#define DIERR_REPORTFULL                0x8004020AL

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );


/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l

/*
 * Hardware Setting indicating that VJoyD should not load this
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l


/*
 * Hardware Setting indicating that the device is a gameport bus
 */
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l

/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxvb\dx7vb\inc\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * This code indicates that a band download was only successful in reaching
 * some, but not all, of the referenced ports. Some samples may not play
 * correctly.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */

#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are 
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#def